--- a/target/linux/generic/backport-4.14/012-kbuild-add-macro-for-controlling-warnings-to-linux-c.patch	2022-03-22 08:54:47.009464339 +0800
+++ b/target/linux/generic/backport-4.14/012-kbuild-add-macro-for-controlling-warnings-to-linux-c.patch	2022-03-22 12:15:53.991429886 +0800
@@ -84,7 +84,7 @@
 
 --- a/include/linux/compiler-gcc.h
 +++ b/include/linux/compiler-gcc.h
-@@ -366,3 +366,30 @@
+@@ -372,3 +372,30 @@
  #if GCC_VERSION >= 50100
  #define COMPILER_HAS_GENERIC_BUILTIN_OVERFLOW 1
  #endif
--- a/target/linux/generic/backport-4.14/025-tcp-allow-drivers-to-tweak-TSQ-logic.patch	2022-03-22 08:54:47.011464343 +0800
+++ b/target/linux/generic/backport-4.14/025-tcp-allow-drivers-to-tweak-TSQ-logic.patch	2022-03-22 12:15:53.992429879 +0800
@@ -55,7 +55,7 @@
  	rwlock_t		sk_callback_lock;
 --- a/net/core/sock.c
 +++ b/net/core/sock.c
-@@ -2745,6 +2745,7 @@ void sock_init_data(struct socket *sock,
+@@ -2771,6 +2771,7 @@ void sock_init_data(struct socket *sock,
  
  	sk->sk_max_pacing_rate = ~0U;
  	sk->sk_pacing_rate = ~0U;
@@ -65,7 +65,7 @@
  	 * Before updating sk_refcnt, we must commit prior changes to memory
 --- a/net/ipv4/tcp_output.c
 +++ b/net/ipv4/tcp_output.c
-@@ -1696,7 +1696,7 @@ u32 tcp_tso_autosize(const struct sock *
+@@ -1701,7 +1701,7 @@ u32 tcp_tso_autosize(const struct sock *
  {
  	u32 bytes, segs;
  
@@ -74,7 +74,7 @@
  		    sk->sk_gso_max_size - 1 - MAX_TCP_HEADER);
  
  	/* Goal is to send at least one packet per ms,
-@@ -2214,7 +2214,7 @@ static bool tcp_small_queue_check(struct
+@@ -2219,7 +2219,7 @@ static bool tcp_small_queue_check(struct
  {
  	unsigned int limit;
  
--- a/target/linux/generic/backport-4.14/030-USB-serial-option-fix-dwm-158-3g-modem-interface.patch	2022-03-22 08:54:47.011464343 +0800
+++ b/target/linux/generic/backport-4.14/030-USB-serial-option-fix-dwm-158-3g-modem-interface.patch	2022-03-22 12:15:53.993429872 +0800
@@ -30,7 +30,7 @@
 
 --- a/drivers/usb/serial/option.c
 +++ b/drivers/usb/serial/option.c
-@@ -1968,7 +1968,8 @@ static const struct usb_device_id option
+@@ -2031,7 +2031,8 @@ static const struct usb_device_id option
  	{ USB_DEVICE_INTERFACE_CLASS(0x2001, 0x7d01, 0xff) },			/* D-Link DWM-156 (variant) */
  	{ USB_DEVICE_INTERFACE_CLASS(0x2001, 0x7d02, 0xff) },
  	{ USB_DEVICE_INTERFACE_CLASS(0x2001, 0x7d03, 0xff) },
--- a/target/linux/generic/backport-4.14/030-v4.17-0001-usb-dwc2-add-support-for-host-mode-external-vbus-sup.patch	2022-03-22 08:54:47.012464344 +0800
+++ b/target/linux/generic/backport-4.14/030-v4.17-0001-usb-dwc2-add-support-for-host-mode-external-vbus-sup.patch	2022-03-22 12:15:53.993429872 +0800
@@ -21,7 +21,7 @@
 
 --- a/drivers/usb/dwc2/core.h
 +++ b/drivers/usb/dwc2/core.h
-@@ -777,6 +777,7 @@ struct dwc2_hregs_backup {
+@@ -779,6 +779,7 @@ struct dwc2_hregs_backup {
   * @plat:               The platform specific configuration data. This can be
   *                      removed once all SoCs support usb transceiver.
   * @supplies:           Definition of USB power supplies
@@ -29,7 +29,7 @@
   * @phyif:              PHY interface width
   * @lock:		Spinlock that protects all the driver data structures
   * @priv:		Stores a pointer to the struct usb_hcd
-@@ -914,6 +915,7 @@ struct dwc2_hsotg {
+@@ -916,6 +917,7 @@ struct dwc2_hsotg {
  	struct usb_phy *uphy;
  	struct dwc2_hsotg_plat *plat;
  	struct regulator_bulk_data supplies[DWC2_NUM_SUPPLIES];
@@ -63,7 +63,7 @@
  /**
   * dwc2_enable_host_interrupts() - Enables the Host mode interrupts
   *
-@@ -3346,6 +3363,7 @@ static void dwc2_conn_id_status_change(s
+@@ -3347,6 +3364,7 @@ static void dwc2_conn_id_status_change(s
  
  	/* B-Device connector (Device Mode) */
  	if (gotgctl & GOTGCTL_CONID_B) {
@@ -71,7 +71,7 @@
  		/* Wait for switch to device mode */
  		dev_dbg(hsotg->dev, "connId B\n");
  		if (hsotg->bus_suspended) {
-@@ -4455,6 +4473,9 @@ static int _dwc2_hcd_start(struct usb_hc
+@@ -4456,6 +4474,9 @@ static int _dwc2_hcd_start(struct usb_hc
  	}
  
  	spin_unlock_irqrestore(&hsotg->lock, flags);
@@ -81,7 +81,7 @@
  	return 0;
  }
  
-@@ -4482,6 +4503,8 @@ static void _dwc2_hcd_stop(struct usb_hc
+@@ -4483,6 +4504,8 @@ static void _dwc2_hcd_stop(struct usb_hc
  	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
  	spin_unlock_irqrestore(&hsotg->lock, flags);
  
@@ -90,7 +90,7 @@
  	usleep_range(1000, 3000);
  }
  
-@@ -4518,6 +4541,7 @@ static int _dwc2_hcd_suspend(struct usb_
+@@ -4519,6 +4542,7 @@ static int _dwc2_hcd_suspend(struct usb_
  		hprt0 |= HPRT0_SUSP;
  		hprt0 &= ~HPRT0_PWR;
  		dwc2_writel(hprt0, hsotg->regs + HPRT0);
@@ -98,7 +98,7 @@
  	}
  
  	/* Enter hibernation */
-@@ -4598,6 +4622,8 @@ static int _dwc2_hcd_resume(struct usb_h
+@@ -4599,6 +4623,8 @@ static int _dwc2_hcd_resume(struct usb_h
  		spin_unlock_irqrestore(&hsotg->lock, flags);
  		dwc2_port_resume(hsotg);
  	} else {
--- a/target/linux/generic/backport-4.14/030-v4.17-0002-usb-dwc2-dwc2_vbus_supply_init-fix-error-check.patch	2022-03-22 08:54:47.012464344 +0800
+++ b/target/linux/generic/backport-4.14/030-v4.17-0002-usb-dwc2-dwc2_vbus_supply_init-fix-error-check.patch	2022-03-22 12:15:53.994429865 +0800
@@ -42,7 +42,7 @@
  
  	return regulator_enable(hsotg->vbus_supply);
  }
-@@ -4474,9 +4479,7 @@ static int _dwc2_hcd_start(struct usb_hc
+@@ -4475,9 +4480,7 @@ static int _dwc2_hcd_start(struct usb_hc
  
  	spin_unlock_irqrestore(&hsotg->lock, flags);
  
--- a/target/linux/generic/backport-4.14/050-v4.19-f2fs-skip-verifying-block-address-non-regular-inode.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/backport-4.14/050-v4.19-f2fs-skip-verifying-block-address-non-regular-inode.patch	2022-03-22 12:15:53.999429831 +0800
@@ -0,0 +1,69 @@
+From dda9f4b9cac6bdd2a96253b4444d7a6ce5132edb Mon Sep 17 00:00:00 2001
+From: Chao Yu <yuchao0@huawei.com>
+Date: Sat, 11 Aug 2018 23:42:09 +0800
+Subject: f2fs: fix to skip verifying block address for non-regular inode
+
+generic/184 1s ... [failed, exit status 1]- output mismatch
+    --- tests/generic/184.out	2015-01-11 16:52:27.643681072 +0800
+     QA output created by 184 - silence is golden
+    +rm: cannot remove '/mnt/f2fs/null': Bad address
+    +mknod: '/mnt/f2fs/null': Bad address
+    +chmod: cannot access '/mnt/f2fs/null': Bad address
+    +./tests/generic/184: line 36: /mnt/f2fs/null: Bad address
+    ...
+
+F2FS-fs (zram0): access invalid blkaddr:259
+EIP: f2fs_is_valid_blkaddr+0x14b/0x1b0 [f2fs]
+ f2fs_iget+0x927/0x1010 [f2fs]
+ f2fs_lookup+0x26e/0x630 [f2fs]
+ __lookup_slow+0xb3/0x140
+ lookup_slow+0x31/0x50
+ walk_component+0x185/0x1f0
+ path_lookupat+0x51/0x190
+ filename_lookup+0x7f/0x140
+ user_path_at_empty+0x36/0x40
+ vfs_statx+0x61/0xc0
+ __do_sys_stat64+0x29/0x40
+ sys_stat64+0x13/0x20
+ do_fast_syscall_32+0xaa/0x22c
+ entry_SYSENTER_32+0x53/0x86
+
+In f2fs_iget(), we will check inode's first block address, if it is valid,
+we will set FI_FIRST_BLOCK_WRITTEN flag in inode.
+
+But we should only do this for regular inode, otherwise, like special
+inode, i_addr[0] is used for storing device info instead of block address,
+it will fail checking flow obviously.
+
+So for non-regular inode, let's skip verifying address and setting flag.
+
+Signed-off-by: Chao Yu <yuchao0@huawei.com>
+Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>
+---
+ fs/f2fs/inode.c | 14 ++++++++------
+ 1 file changed, 8 insertions(+), 6 deletions(-)
+
+--- a/fs/f2fs/inode.c
++++ b/fs/f2fs/inode.c
+@@ -310,13 +310,15 @@ static int do_read_inode(struct inode *i
+ 	/* get rdev by using inline_info */
+ 	__get_inode_rdev(inode, ri);
+ 
+-	err = __written_first_block(sbi, ri);
+-	if (err < 0) {
+-		f2fs_put_page(node_page, 1);
+-		return err;
++	if (S_ISREG(inode->i_mode)) {
++		err = __written_first_block(sbi, ri);
++		if (err < 0) {
++			f2fs_put_page(node_page, 1);
++			return err;
++		}
++		if (!err)
++			set_inode_flag(inode, FI_FIRST_BLOCK_WRITTEN);
+ 	}
+-	if (!err)
+-		set_inode_flag(inode, FI_FIRST_BLOCK_WRITTEN);
+ 
+ 	if (!need_inode_block_update(sbi, inode->i_ino))
+ 		fi->last_disk_size = inode->i_size;
--- a/target/linux/generic/backport-4.14/090-net-bridge-add-support-for-port-isolation.patch	2022-03-22 08:54:47.019464356 +0800
+++ b/target/linux/generic/backport-4.14/090-net-bridge-add-support-for-port-isolation.patch	2022-03-22 12:15:54.001429817 +0800
@@ -117,7 +117,7 @@
  int br_add_bridge(struct net *net, const char *name);
 --- a/net/bridge/br_sysfs_if.c
 +++ b/net/bridge/br_sysfs_if.c
-@@ -174,6 +174,7 @@ BRPORT_ATTR_FLAG(proxyarp, BR_PROXYARP);
+@@ -177,6 +177,7 @@ BRPORT_ATTR_FLAG(proxyarp, BR_PROXYARP);
  BRPORT_ATTR_FLAG(proxyarp_wifi, BR_PROXYARP_WIFI);
  BRPORT_ATTR_FLAG(multicast_flood, BR_MCAST_FLOOD);
  BRPORT_ATTR_FLAG(broadcast_flood, BR_BCAST_FLOOD);
@@ -125,7 +125,7 @@
  
  #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
  static ssize_t show_multicast_router(struct net_bridge_port *p, char *buf)
-@@ -223,6 +224,7 @@ static const struct brport_attribute *br
+@@ -226,6 +227,7 @@ static const struct brport_attribute *br
  	&brport_attr_proxyarp_wifi,
  	&brport_attr_multicast_flood,
  	&brport_attr_broadcast_flood,
--- a/target/linux/generic/backport-4.14/095-Allow-class-e-address-assignment-via-ifconfig-ioctl.patch	2022-03-22 08:54:47.019464356 +0800
+++ b/target/linux/generic/backport-4.14/095-Allow-class-e-address-assignment-via-ifconfig-ioctl.patch	2022-03-22 12:15:54.002429810 +0800
@@ -48,7 +48,7 @@
  #define	INADDR_ANY		((unsigned long int) 0x00000000)
 --- a/net/ipv4/devinet.c
 +++ b/net/ipv4/devinet.c
-@@ -929,7 +929,7 @@ static int inet_abc_len(__be32 addr)
+@@ -935,7 +935,7 @@ static int inet_abc_len(__be32 addr)
  {
  	int rc = -1;	/* Something else, probably a multicast. */
  
@@ -57,7 +57,7 @@
  		rc = 0;
  	else {
  		__u32 haddr = ntohl(addr);
-@@ -940,6 +940,8 @@ static int inet_abc_len(__be32 addr)
+@@ -946,6 +946,8 @@ static int inet_abc_len(__be32 addr)
  			rc = 16;
  		else if (IN_CLASSC(haddr))
  			rc = 24;
--- a/target/linux/generic/backport-4.14/273-batman-adv-Convert-packet.h-to-uapi-header.patch	2022-03-22 08:54:47.023464363 +0800
+++ b/target/linux/generic/backport-4.14/273-batman-adv-Convert-packet.h-to-uapi-header.patch	2022-03-22 12:15:54.005429790 +0800
@@ -27,7 +27,7 @@
  
 --- a/net/batman-adv/bat_iv_ogm.c
 +++ b/net/batman-adv/bat_iv_ogm.c
-@@ -51,6 +51,7 @@
+@@ -52,6 +52,7 @@
  #include <linux/workqueue.h>
  #include <net/genetlink.h>
  #include <net/netlink.h>
@@ -35,7 +35,7 @@
  #include <uapi/linux/batman_adv.h>
  
  #include "bat_algo.h"
-@@ -62,7 +63,6 @@
+@@ -63,7 +64,6 @@
  #include "netlink.h"
  #include "network-coding.h"
  #include "originator.h"
@@ -45,7 +45,7 @@
  #include "translation-table.h"
 --- a/net/batman-adv/bat_v.c
 +++ b/net/batman-adv/bat_v.c
-@@ -37,6 +37,7 @@
+@@ -36,6 +36,7 @@
  #include <linux/workqueue.h>
  #include <net/genetlink.h>
  #include <net/netlink.h>
@@ -53,7 +53,7 @@
  #include <uapi/linux/batman_adv.h>
  
  #include "bat_algo.h"
-@@ -49,7 +50,6 @@
+@@ -48,7 +49,6 @@
  #include "log.h"
  #include "netlink.h"
  #include "originator.h"
@@ -80,7 +80,7 @@
  
 --- a/net/batman-adv/bat_v_ogm.c
 +++ b/net/batman-adv/bat_v_ogm.c
-@@ -38,13 +38,13 @@
+@@ -40,13 +40,13 @@
  #include <linux/string.h>
  #include <linux/types.h>
  #include <linux/workqueue.h>
@@ -97,7 +97,7 @@
  #include "translation-table.h"
 --- a/net/batman-adv/bridge_loop_avoidance.c
 +++ b/net/batman-adv/bridge_loop_avoidance.c
-@@ -49,6 +49,7 @@
+@@ -50,6 +50,7 @@
  #include <net/genetlink.h>
  #include <net/netlink.h>
  #include <net/sock.h>
@@ -105,7 +105,7 @@
  #include <uapi/linux/batman_adv.h>
  
  #include "hard-interface.h"
-@@ -56,7 +57,6 @@
+@@ -57,7 +58,6 @@
  #include "log.h"
  #include "netlink.h"
  #include "originator.h"
@@ -174,7 +174,7 @@
  /**
 --- a/net/batman-adv/hard-interface.c
 +++ b/net/batman-adv/hard-interface.c
-@@ -36,6 +36,7 @@
+@@ -37,6 +37,7 @@
  #include <linux/spinlock.h>
  #include <net/net_namespace.h>
  #include <net/rtnetlink.h>
@@ -182,7 +182,7 @@
  
  #include "bat_v.h"
  #include "bridge_loop_avoidance.h"
-@@ -44,7 +45,6 @@
+@@ -45,7 +46,6 @@
  #include "gateway_client.h"
  #include "log.h"
  #include "originator.h"
@@ -1025,7 +1025,7 @@
  
 --- a/net/batman-adv/types.h
 +++ b/net/batman-adv/types.h
-@@ -34,10 +34,9 @@
+@@ -35,10 +35,9 @@
  #include <linux/types.h>
  #include <linux/wait.h>
  #include <linux/workqueue.h>
--- a/target/linux/generic/backport-4.14/274-flow_dissector-Parse-batman-adv-unicast-headers.patch	2022-03-22 08:54:47.023464363 +0800
+++ b/target/linux/generic/backport-4.14/274-flow_dissector-Parse-batman-adv-unicast-headers.patch	2022-03-22 12:15:54.006429783 +0800
@@ -94,7 +94,7 @@
  static void
  __skb_flow_dissect_tcp(const struct sk_buff *skb,
  		       struct flow_dissector *flow_dissector,
-@@ -717,6 +769,11 @@ proto_again:
+@@ -718,6 +770,11 @@ proto_again:
  					       nhoff, hlen);
  		break;
  
--- a/target/linux/generic/backport-4.14/293-v4.16-netfilter-reduce-size-of-hook-entry-point-locations.patch	2022-03-22 08:54:47.025464366 +0800
+++ b/target/linux/generic/backport-4.14/293-v4.16-netfilter-reduce-size-of-hook-entry-point-locations.patch	2022-03-22 12:15:54.008429769 +0800
@@ -92,7 +92,7 @@
  #endif
 --- a/net/bridge/br_netfilter_hooks.c
 +++ b/net/bridge/br_netfilter_hooks.c
-@@ -988,7 +988,7 @@ int br_nf_hook_thresh(unsigned int hook,
+@@ -994,7 +994,7 @@ int br_nf_hook_thresh(unsigned int hook,
  	unsigned int i;
  	int ret;
  
--- a/target/linux/generic/backport-4.14/303-v4.16-netfilter-nf_tables-remove-multihook-chains-and-fami.patch	2022-03-22 08:54:47.030464374 +0800
+++ b/target/linux/generic/backport-4.14/303-v4.16-netfilter-nf_tables-remove-multihook-chains-and-fami.patch	2022-03-22 12:15:54.013429734 +0800
@@ -11,7 +11,7 @@
 
 --- a/include/net/netfilter/nf_tables.h
 +++ b/include/net/netfilter/nf_tables.h
-@@ -898,8 +898,6 @@ struct nft_stats {
+@@ -900,8 +900,6 @@ struct nft_stats {
  	struct u64_stats_sync	syncp;
  };
  
@@ -20,7 +20,7 @@
  /**
   *	struct nft_base_chain - nf_tables base chain
   *
-@@ -911,7 +909,7 @@ struct nft_stats {
+@@ -913,7 +911,7 @@ struct nft_stats {
   *	@dev_name: device name that this base chain is attached to (if any)
   */
  struct nft_base_chain {
@@ -29,7 +29,7 @@
  	const struct nf_chain_type	*type;
  	u8				policy;
  	u8				flags;
-@@ -972,8 +970,6 @@ enum nft_af_flags {
+@@ -974,8 +972,6 @@ enum nft_af_flags {
   *	@owner: module owner
   *	@tables: used internally
   *	@flags: family flags
@@ -38,7 +38,7 @@
   *	@hooks: hookfn overrides for packet validation
   */
  struct nft_af_info {
-@@ -983,9 +979,6 @@ struct nft_af_info {
+@@ -985,9 +981,6 @@ struct nft_af_info {
  	struct module			*owner;
  	struct list_head		tables;
  	u32				flags;
@@ -264,7 +264,7 @@
  		}
  		nft_chain_release_hook(&hook);
  	}
-@@ -5156,10 +5144,9 @@ static int nf_tables_commit(struct net *
+@@ -5163,10 +5151,9 @@ static int nf_tables_commit(struct net *
  		case NFT_MSG_DELCHAIN:
  			list_del_rcu(&trans->ctx.chain->list);
  			nf_tables_chain_notify(&trans->ctx, NFT_MSG_DELCHAIN);
@@ -278,7 +278,7 @@
  			break;
  		case NFT_MSG_NEWRULE:
  			nft_clear(trans->ctx.net, nft_trans_rule(trans));
-@@ -5296,10 +5283,9 @@ static int nf_tables_abort(struct net *n
+@@ -5303,10 +5290,9 @@ static int nf_tables_abort(struct net *n
  			} else {
  				trans->ctx.table->use--;
  				list_del_rcu(&trans->ctx.chain->list);
@@ -292,7 +292,7 @@
  			}
  			break;
  		case NFT_MSG_DELCHAIN:
-@@ -5402,7 +5388,7 @@ int nft_chain_validate_hooks(const struc
+@@ -5409,7 +5395,7 @@ int nft_chain_validate_hooks(const struc
  	if (nft_is_base_chain(chain)) {
  		basechain = nft_base_chain(chain);
  
@@ -301,7 +301,7 @@
  			return 0;
  
  		return -EOPNOTSUPP;
-@@ -5884,8 +5870,7 @@ int __nft_release_basechain(struct nft_c
+@@ -5891,8 +5877,7 @@ int __nft_release_basechain(struct nft_c
  
  	BUG_ON(!nft_is_base_chain(ctx->chain));
  
@@ -311,7 +311,7 @@
  	list_for_each_entry_safe(rule, nr, &ctx->chain->rules, list) {
  		list_del(&rule->list);
  		ctx->chain->use--;
-@@ -5914,8 +5899,7 @@ static void __nft_release_afinfo(struct
+@@ -5921,8 +5906,7 @@ static void __nft_release_afinfo(struct
  
  	list_for_each_entry_safe(table, nt, &afi->tables, list) {
  		list_for_each_entry(chain, &table->chains, list)
--- a/target/linux/generic/backport-4.14/312-v4.16-netfilter-nf_tables-remove-hooks-from-family-definit.patch	2022-03-22 08:54:47.035464383 +0800
+++ b/target/linux/generic/backport-4.14/312-v4.16-netfilter-nf_tables-remove-hooks-from-family-definit.patch	2022-03-22 12:15:54.018429700 +0800
@@ -10,7 +10,7 @@
 
 --- a/include/net/netfilter/nf_tables.h
 +++ b/include/net/netfilter/nf_tables.h
-@@ -876,7 +876,7 @@ enum nft_chain_type {
+@@ -878,7 +878,7 @@ enum nft_chain_type {
   * 	@family: address family
   * 	@owner: module owner
   * 	@hook_mask: mask of valid hooks
@@ -19,7 +19,7 @@
   */
  struct nf_chain_type {
  	const char			*name;
-@@ -970,7 +970,6 @@ enum nft_af_flags {
+@@ -972,7 +972,6 @@ enum nft_af_flags {
   *	@owner: module owner
   *	@tables: used internally
   *	@flags: family flags
@@ -27,7 +27,7 @@
   */
  struct nft_af_info {
  	struct list_head		list;
-@@ -979,7 +978,6 @@ struct nft_af_info {
+@@ -981,7 +980,6 @@ struct nft_af_info {
  	struct module			*owner;
  	struct list_head		tables;
  	u32				flags;
--- a/target/linux/generic/backport-4.14/320-v4.16-netfilter-nf_conntrack-add-IPS_OFFLOAD-status-bit.patch	2022-03-22 08:54:47.037464386 +0800
+++ b/target/linux/generic/backport-4.14/320-v4.16-netfilter-nf_conntrack-add-IPS_OFFLOAD-status-bit.patch	2022-03-22 12:15:54.020429686 +0800
@@ -47,7 +47,7 @@
  };
 --- a/net/netfilter/nf_conntrack_core.c
 +++ b/net/netfilter/nf_conntrack_core.c
-@@ -960,6 +960,9 @@ static unsigned int early_drop_list(stru
+@@ -975,6 +975,9 @@ static unsigned int early_drop_list(stru
  	hlist_nulls_for_each_entry_rcu(h, n, head, hnnode) {
  		tmp = nf_ct_tuplehash_to_ctrack(h);
  
@@ -57,7 +57,7 @@
  		if (nf_ct_is_expired(tmp)) {
  			nf_ct_gc_expired(tmp);
  			continue;
-@@ -1037,6 +1040,18 @@ static bool gc_worker_can_early_drop(con
+@@ -1052,6 +1055,18 @@ static bool gc_worker_can_early_drop(con
  	return false;
  }
  
@@ -76,7 +76,7 @@
  static void gc_worker(struct work_struct *work)
  {
  	unsigned int min_interval = max(HZ / GC_MAX_BUCKETS_DIV, 1u);
-@@ -1073,6 +1088,11 @@ static void gc_worker(struct work_struct
+@@ -1088,6 +1103,11 @@ static void gc_worker(struct work_struct
  			tmp = nf_ct_tuplehash_to_ctrack(h);
  
  			scanned++;
@@ -90,7 +90,7 @@
  				expired_count++;
 --- a/net/netfilter/nf_conntrack_netlink.c
 +++ b/net/netfilter/nf_conntrack_netlink.c
-@@ -1123,6 +1123,14 @@ static const struct nla_policy ct_nla_po
+@@ -1128,6 +1128,14 @@ static const struct nla_policy ct_nla_po
  				    .len = NF_CT_LABELS_MAX_SIZE },
  };
  
@@ -105,7 +105,7 @@
  static int ctnetlink_flush_conntrack(struct net *net,
  				     const struct nlattr * const cda[],
  				     u32 portid, int report)
-@@ -1135,7 +1143,7 @@ static int ctnetlink_flush_conntrack(str
+@@ -1140,7 +1148,7 @@ static int ctnetlink_flush_conntrack(str
  			return PTR_ERR(filter);
  	}
  
@@ -114,7 +114,7 @@
  				  portid, report);
  	kfree(filter);
  
-@@ -1181,6 +1189,11 @@ static int ctnetlink_del_conntrack(struc
+@@ -1186,6 +1194,11 @@ static int ctnetlink_del_conntrack(struc
  
  	ct = nf_ct_tuplehash_to_ctrack(h);
  
@@ -140,7 +140,7 @@
  #endif
 --- a/net/netfilter/nf_conntrack_standalone.c
 +++ b/net/netfilter/nf_conntrack_standalone.c
-@@ -309,10 +309,12 @@ static int ct_seq_show(struct seq_file *
+@@ -310,10 +310,12 @@ static int ct_seq_show(struct seq_file *
  	WARN_ON(!l4proto);
  
  	ret = -ENOSPC;
@@ -156,7 +156,7 @@
  
  	if (l4proto->print_conntrack)
  		l4proto->print_conntrack(s, ct);
-@@ -339,7 +341,9 @@ static int ct_seq_show(struct seq_file *
+@@ -340,7 +342,9 @@ static int ct_seq_show(struct seq_file *
  	if (seq_print_acct(s, ct, IP_CT_DIR_REPLY))
  		goto release;
  
--- a/target/linux/generic/backport-4.14/321-v4.16-netfilter-nf_tables-add-flow-table-netlink-frontend.patch	2022-03-22 08:54:47.038464388 +0800
+++ b/target/linux/generic/backport-4.14/321-v4.16-netfilter-nf_tables-add-flow-table-netlink-frontend.patch	2022-03-22 12:15:54.021429679 +0800
@@ -50,7 +50,7 @@
  #include <net/netlink.h>
  
  #define NFT_JUMP_STACK_SIZE	16
-@@ -939,6 +940,7 @@ unsigned int nft_do_chain(struct nft_pkt
+@@ -941,6 +942,7 @@ unsigned int nft_do_chain(struct nft_pkt
   *	@chains: chains in the table
   *	@sets: sets in the table
   *	@objects: stateful objects in the table
@@ -58,7 +58,7 @@
   *	@hgenerator: handle generator state
   *	@use: number of chain references to this table
   *	@flags: table flag (see enum nft_table_flags)
-@@ -950,6 +952,7 @@ struct nft_table {
+@@ -952,6 +954,7 @@ struct nft_table {
  	struct list_head		chains;
  	struct list_head		sets;
  	struct list_head		objects;
@@ -66,7 +66,7 @@
  	u64				hgenerator;
  	u32				use;
  	u16				flags:14,
-@@ -1081,6 +1084,44 @@ int nft_register_obj(struct nft_object_t
+@@ -1083,6 +1086,44 @@ int nft_register_obj(struct nft_object_t
  void nft_unregister_obj(struct nft_object_type *obj_type);
  
  /**
@@ -111,7 +111,7 @@
   *	struct nft_traceinfo - nft tracing information and state
   *
   *	@pkt: pktinfo currently processed
-@@ -1316,4 +1357,11 @@ struct nft_trans_obj {
+@@ -1318,4 +1359,11 @@ struct nft_trans_obj {
  #define nft_trans_obj(trans)	\
  	(((struct nft_trans_obj *)trans->data)->obj)
  
@@ -292,7 +292,7 @@
  	list_for_each_entry_safe(obj, ne, &ctx->table->objects, list) {
  		err = nft_delobj(ctx, obj);
  		if (err < 0)
-@@ -4856,6 +4900,605 @@ static void nf_tables_obj_notify(const s
+@@ -4863,6 +4907,605 @@ static void nf_tables_obj_notify(const s
  		       ctx->afi->family, ctx->report, GFP_KERNEL);
  }
  
@@ -898,7 +898,7 @@
  static int nf_tables_fill_gen_info(struct sk_buff *skb, struct net *net,
  				   u32 portid, u32 seq)
  {
-@@ -4886,6 +5529,49 @@ nla_put_failure:
+@@ -4893,6 +5536,49 @@ nla_put_failure:
  	return -EMSGSIZE;
  }
  
@@ -948,7 +948,7 @@
  static void nf_tables_gen_notify(struct net *net, struct sk_buff *skb,
  				 int event)
  {
-@@ -5038,6 +5724,21 @@ static const struct nfnl_callback nf_tab
+@@ -5045,6 +5731,21 @@ static const struct nfnl_callback nf_tab
  		.attr_count	= NFTA_OBJ_MAX,
  		.policy		= nft_obj_policy,
  	},
@@ -970,7 +970,7 @@
  };
  
  static void nft_chain_commit_update(struct nft_trans *trans)
-@@ -5086,6 +5787,9 @@ static void nf_tables_commit_release(str
+@@ -5093,6 +5794,9 @@ static void nf_tables_commit_release(str
  	case NFT_MSG_DELOBJ:
  		nft_obj_destroy(nft_trans_obj(trans));
  		break;
@@ -980,7 +980,7 @@
  	}
  	kfree(trans);
  }
-@@ -5205,6 +5909,21 @@ static int nf_tables_commit(struct net *
+@@ -5212,6 +5916,21 @@ static int nf_tables_commit(struct net *
  			nf_tables_obj_notify(&trans->ctx, nft_trans_obj(trans),
  					     NFT_MSG_DELOBJ);
  			break;
@@ -1002,7 +1002,7 @@
  		}
  	}
  
-@@ -5242,6 +5961,9 @@ static void nf_tables_abort_release(stru
+@@ -5249,6 +5968,9 @@ static void nf_tables_abort_release(stru
  	case NFT_MSG_NEWOBJ:
  		nft_obj_destroy(nft_trans_obj(trans));
  		break;
@@ -1012,7 +1012,7 @@
  	}
  	kfree(trans);
  }
-@@ -5333,6 +6055,17 @@ static int nf_tables_abort(struct net *n
+@@ -5340,6 +6062,17 @@ static int nf_tables_abort(struct net *n
  			nft_clear(trans->ctx.net, nft_trans_obj(trans));
  			nft_trans_destroy(trans);
  			break;
@@ -1030,7 +1030,7 @@
  		}
  	}
  
-@@ -5883,6 +6616,7 @@ EXPORT_SYMBOL_GPL(__nft_release_basechai
+@@ -5890,6 +6623,7 @@ EXPORT_SYMBOL_GPL(__nft_release_basechai
  /* Called by nft_unregister_afinfo() from __net_exit path, nfnl_lock is held. */
  static void __nft_release_afinfo(struct net *net, struct nft_af_info *afi)
  {
@@ -1038,7 +1038,7 @@
  	struct nft_table *table, *nt;
  	struct nft_chain *chain, *nc;
  	struct nft_object *obj, *ne;
-@@ -5896,6 +6630,9 @@ static void __nft_release_afinfo(struct
+@@ -5903,6 +6637,9 @@ static void __nft_release_afinfo(struct
  	list_for_each_entry_safe(table, nt, &afi->tables, list) {
  		list_for_each_entry(chain, &table->chains, list)
  			nf_tables_unregister_hook(net, table, chain);
@@ -1048,7 +1048,7 @@
  		/* No packets are walking on these chains anymore. */
  		ctx.table = table;
  		list_for_each_entry(chain, &table->chains, list) {
-@@ -5906,6 +6643,11 @@ static void __nft_release_afinfo(struct
+@@ -5913,6 +6650,11 @@ static void __nft_release_afinfo(struct
  				nf_tables_rule_release(&ctx, rule);
  			}
  		}
@@ -1060,7 +1060,7 @@
  		list_for_each_entry_safe(set, ns, &table->sets, list) {
  			list_del(&set->list);
  			table->use--;
-@@ -5949,6 +6691,8 @@ static int __init nf_tables_module_init(
+@@ -5956,6 +6698,8 @@ static int __init nf_tables_module_init(
  	if (err < 0)
  		goto err3;
  
@@ -1069,7 +1069,7 @@
  	pr_info("nf_tables: (c) 2007-2009 Patrick McHardy <kaber@trash.net>\n");
  	return register_pernet_subsys(&nf_tables_net_ops);
  err3:
-@@ -5963,6 +6707,7 @@ static void __exit nf_tables_module_exit
+@@ -5970,6 +6714,7 @@ static void __exit nf_tables_module_exit
  {
  	unregister_pernet_subsys(&nf_tables_net_ops);
  	nfnetlink_subsys_unregister(&nf_tables_subsys);
--- a/target/linux/generic/backport-4.14/324-v4.16-netfilter-flow-table-support-for-IPv6.patch	2022-03-22 08:54:47.040464391 +0800
+++ b/target/linux/generic/backport-4.14/324-v4.16-netfilter-flow-table-support-for-IPv6.patch	2022-03-22 12:15:54.024429659 +0800
@@ -23,10 +23,10 @@
 +
  int ip6_dst_lookup(struct net *net, struct sock *sk, struct dst_entry **dst,
  		   struct flowi6 *fl6);
- struct dst_entry *ip6_dst_lookup_flow(const struct sock *sk, struct flowi6 *fl6,
+ struct dst_entry *ip6_dst_lookup_flow(struct net *net, const struct sock *sk, struct flowi6 *fl6,
 --- a/net/ipv6/ip6_output.c
 +++ b/net/ipv6/ip6_output.c
-@@ -381,7 +381,7 @@ static inline int ip6_forward_finish(str
+@@ -419,7 +419,7 @@ static inline int ip6_forward_finish(str
  	return dst_output(net, sk, skb);
  }
  
@@ -35,7 +35,7 @@
  {
  	unsigned int mtu;
  	struct inet6_dev *idev;
-@@ -401,6 +401,7 @@ static unsigned int ip6_dst_mtu_forward(
+@@ -439,6 +439,7 @@ static unsigned int ip6_dst_mtu_forward(
  
  	return mtu;
  }
--- a/target/linux/generic/backport-4.14/327-v4.16-netfilter-nf_tables-remove-nhooks-field-from-struct-.patch	2022-03-22 08:54:47.042464394 +0800
+++ b/target/linux/generic/backport-4.14/327-v4.16-netfilter-nf_tables-remove-nhooks-field-from-struct-.patch	2022-03-22 12:15:54.025429652 +0800
@@ -14,7 +14,7 @@
 
 --- a/include/net/netfilter/nf_tables.h
 +++ b/include/net/netfilter/nf_tables.h
-@@ -969,7 +969,6 @@ enum nft_af_flags {
+@@ -971,7 +971,6 @@ enum nft_af_flags {
   *
   *	@list: used internally
   *	@family: address family
@@ -22,7 +22,7 @@
   *	@owner: module owner
   *	@tables: used internally
   *	@flags: family flags
-@@ -977,7 +976,6 @@ enum nft_af_flags {
+@@ -979,7 +978,6 @@ enum nft_af_flags {
  struct nft_af_info {
  	struct list_head		list;
  	int				family;
@@ -82,7 +82,7 @@
  	hook->priority = ntohl(nla_get_be32(ha[NFTA_HOOK_PRIORITY]));
  
  	type = chain_type[afi->family][NFT_CHAIN_T_DEFAULT];
-@@ -5008,7 +5005,7 @@ static int nf_tables_flowtable_parse_hoo
+@@ -5015,7 +5012,7 @@ static int nf_tables_flowtable_parse_hoo
  		return -EINVAL;
  
  	hooknum = ntohl(nla_get_be32(tb[NFTA_FLOWTABLE_HOOK_NUM]));
--- a/target/linux/generic/backport-4.14/328-v4.16-netfilter-nf_tables-fix-a-typo-in-nf_tables_getflowt.patch	2022-03-22 08:54:47.042464394 +0800
+++ b/target/linux/generic/backport-4.14/328-v4.16-netfilter-nf_tables-fix-a-typo-in-nf_tables_getflowt.patch	2022-03-22 12:15:54.026429645 +0800
@@ -11,7 +11,7 @@
 
 --- a/net/netfilter/nf_tables_api.c
 +++ b/net/netfilter/nf_tables_api.c
-@@ -5432,7 +5432,7 @@ static int nf_tables_getflowtable(struct
+@@ -5439,7 +5439,7 @@ static int nf_tables_getflowtable(struct
  
  	flowtable = nf_tables_flowtable_lookup(table, nla[NFTA_FLOWTABLE_NAME],
  					       genmask);
--- a/target/linux/generic/backport-4.14/330-v4.16-netfilter-nf_tables-remove-flag-field-from-struct-nf.patch	2022-03-22 08:54:47.043464396 +0800
+++ b/target/linux/generic/backport-4.14/330-v4.16-netfilter-nf_tables-remove-flag-field-from-struct-nf.patch	2022-03-22 12:15:54.026429645 +0800
@@ -10,7 +10,7 @@
 
 --- a/include/net/netfilter/nf_tables.h
 +++ b/include/net/netfilter/nf_tables.h
-@@ -960,10 +960,6 @@ struct nft_table {
+@@ -962,10 +962,6 @@ struct nft_table {
  	char				*name;
  };
  
@@ -21,7 +21,7 @@
  /**
   *	struct nft_af_info - nf_tables address family info
   *
-@@ -971,14 +967,12 @@ enum nft_af_flags {
+@@ -973,14 +969,12 @@ enum nft_af_flags {
   *	@family: address family
   *	@owner: module owner
   *	@tables: used internally
--- a/target/linux/generic/backport-4.14/331-v4.16-netfilter-nf_tables-no-need-for-struct-nft_af_info-t.patch	2022-03-22 08:54:47.043464396 +0800
+++ b/target/linux/generic/backport-4.14/331-v4.16-netfilter-nf_tables-no-need-for-struct-nft_af_info-t.patch	2022-03-22 12:15:54.027429638 +0800
@@ -62,7 +62,7 @@
  		if (ret >= 0) {
  			ctx->table->flags &= ~NFT_TABLE_F_DORMANT;
  			nft_trans_table_enable(trans) = true;
-@@ -5813,7 +5806,6 @@ static int nf_tables_commit(struct net *
+@@ -5820,7 +5813,6 @@ static int nf_tables_commit(struct net *
  			if (nft_trans_table_update(trans)) {
  				if (!nft_trans_table_enable(trans)) {
  					nf_tables_table_disable(net,
@@ -70,7 +70,7 @@
  								trans->ctx.table);
  					trans->ctx.table->flags |= NFT_TABLE_F_DORMANT;
  				}
-@@ -5977,7 +5969,6 @@ static int nf_tables_abort(struct net *n
+@@ -5984,7 +5976,6 @@ static int nf_tables_abort(struct net *n
  			if (nft_trans_table_update(trans)) {
  				if (nft_trans_table_enable(trans)) {
  					nf_tables_table_disable(net,
--- a/target/linux/generic/backport-4.14/334-v4.15-netfilter-nf_tables-fix-potential-NULL-ptr-deref-in-.patch	2022-03-22 08:54:47.044464398 +0800
+++ b/target/linux/generic/backport-4.14/334-v4.15-netfilter-nf_tables-fix-potential-NULL-ptr-deref-in-.patch	2022-03-22 12:15:54.028429631 +0800
@@ -15,7 +15,7 @@
 
 --- a/net/netfilter/nf_tables_api.c
 +++ b/net/netfilter/nf_tables_api.c
-@@ -5351,8 +5351,10 @@ static int nf_tables_dump_flowtable_done
+@@ -5358,8 +5358,10 @@ static int nf_tables_dump_flowtable_done
  	if (!filter)
  		return 0;
  
--- a/target/linux/generic/backport-4.14/335-v4.16-netfilter-nf_tables-add-single-table-list-for-all-fa.patch	2022-03-22 08:54:47.045464399 +0800
+++ b/target/linux/generic/backport-4.14/335-v4.16-netfilter-nf_tables-add-single-table-list-for-all-fa.patch	2022-03-22 12:15:54.030429617 +0800
@@ -17,7 +17,7 @@
 
 --- a/include/net/netfilter/nf_tables.h
 +++ b/include/net/netfilter/nf_tables.h
-@@ -143,22 +143,22 @@ static inline void nft_data_debug(const
+@@ -145,22 +145,22 @@ static inline void nft_data_debug(const
   *	struct nft_ctx - nf_tables rule/set context
   *
   *	@net: net namespace
@@ -42,7 +42,7 @@
  	bool				report;
  };
  
-@@ -945,6 +945,7 @@ unsigned int nft_do_chain(struct nft_pkt
+@@ -947,6 +947,7 @@ unsigned int nft_do_chain(struct nft_pkt
   *	@use: number of chain references to this table
   *	@flags: table flag (see enum nft_table_flags)
   *	@genmask: generation mask
@@ -50,7 +50,7 @@
   *	@name: name of the table
   */
  struct nft_table {
-@@ -957,6 +958,7 @@ struct nft_table {
+@@ -959,6 +960,7 @@ struct nft_table {
  	u32				use;
  	u16				flags:14,
  					genmask:2;
@@ -58,7 +58,7 @@
  	char				*name;
  };
  
-@@ -966,13 +968,11 @@ struct nft_table {
+@@ -968,13 +970,11 @@ struct nft_table {
   *	@list: used internally
   *	@family: address family
   *	@owner: module owner
@@ -679,7 +679,7 @@
  	nfmsg->version		= NFNETLINK_V0;
  	nfmsg->res_id		= htons(ctx->net->nft.base_seq & 0xffff);
  
-@@ -2952,10 +2949,8 @@ static int nf_tables_dump_sets(struct sk
+@@ -2953,10 +2950,8 @@ static int nf_tables_dump_sets(struct sk
  {
  	const struct nft_set *set;
  	unsigned int idx, s_idx = cb->args[0];
@@ -690,7 +690,7 @@
  	struct nft_ctx *ctx = cb->data, ctx_set;
  
  	if (cb->args[1])
-@@ -2964,51 +2959,44 @@ static int nf_tables_dump_sets(struct sk
+@@ -2965,51 +2960,44 @@ static int nf_tables_dump_sets(struct sk
  	rcu_read_lock();
  	cb->seq = net->nft.base_seq;
  
@@ -771,7 +771,7 @@
  	}
  	cb->args[1] = 1;
  done:
-@@ -3221,11 +3209,12 @@ static int nf_tables_newset(struct net *
+@@ -3222,11 +3210,12 @@ static int nf_tables_newset(struct net *
  	if (IS_ERR(afi))
  		return PTR_ERR(afi);
  
@@ -786,7 +786,7 @@
  
  	set = nf_tables_set_lookup(table, nla[NFTA_SET_NAME], genmask);
  	if (IS_ERR(set)) {
-@@ -3494,12 +3483,12 @@ static int nft_ctx_init_from_elemattr(st
+@@ -3495,12 +3484,12 @@ static int nft_ctx_init_from_elemattr(st
  	if (IS_ERR(afi))
  		return PTR_ERR(afi);
  
@@ -802,7 +802,7 @@
  	return 0;
  }
  
-@@ -3604,7 +3593,6 @@ static int nf_tables_dump_set(struct sk_
+@@ -3605,7 +3594,6 @@ static int nf_tables_dump_set(struct sk_
  {
  	struct nft_set_dump_ctx *dump_ctx = cb->data;
  	struct net *net = sock_net(skb->sk);
@@ -810,7 +810,7 @@
  	struct nft_table *table;
  	struct nft_set *set;
  	struct nft_set_dump_args args;
-@@ -3616,21 +3604,19 @@ static int nf_tables_dump_set(struct sk_
+@@ -3617,21 +3605,19 @@ static int nf_tables_dump_set(struct sk_
  	int event;
  
  	rcu_read_lock();
@@ -841,7 +841,7 @@
  		}
  		break;
  	}
-@@ -3650,7 +3636,7 @@ static int nf_tables_dump_set(struct sk_
+@@ -3651,7 +3637,7 @@ static int nf_tables_dump_set(struct sk_
  		goto nla_put_failure;
  
  	nfmsg = nlmsg_data(nlh);
@@ -850,7 +850,7 @@
  	nfmsg->version      = NFNETLINK_V0;
  	nfmsg->res_id	    = htons(net->nft.base_seq & 0xffff);
  
-@@ -3752,7 +3738,7 @@ static int nf_tables_fill_setelem_info(s
+@@ -3753,7 +3739,7 @@ static int nf_tables_fill_setelem_info(s
  		goto nla_put_failure;
  
  	nfmsg = nlmsg_data(nlh);
@@ -859,7 +859,7 @@
  	nfmsg->version		= NFNETLINK_V0;
  	nfmsg->res_id		= htons(ctx->net->nft.base_seq & 0xffff);
  
-@@ -3996,7 +3982,7 @@ static int nft_add_set_elem(struct nft_c
+@@ -4003,7 +3989,7 @@ static int nft_add_set_elem(struct nft_c
  		list_for_each_entry(binding, &set->bindings, list) {
  			struct nft_ctx bind_ctx = {
  				.net	= ctx->net,
@@ -868,7 +868,7 @@
  				.table	= ctx->table,
  				.chain	= (struct nft_chain *)binding->chain,
  			};
-@@ -4548,7 +4534,8 @@ static int nf_tables_newobj(struct net *
+@@ -4555,7 +4541,8 @@ static int nf_tables_newobj(struct net *
  	if (IS_ERR(afi))
  		return PTR_ERR(afi);
  
@@ -878,7 +878,7 @@
  	if (IS_ERR(table))
  		return PTR_ERR(table);
  
-@@ -4566,7 +4553,7 @@ static int nf_tables_newobj(struct net *
+@@ -4573,7 +4560,7 @@ static int nf_tables_newobj(struct net *
  		return 0;
  	}
  
@@ -887,7 +887,7 @@
  
  	type = nft_obj_type_get(objtype);
  	if (IS_ERR(type))
-@@ -4643,7 +4630,6 @@ struct nft_obj_filter {
+@@ -4650,7 +4637,6 @@ struct nft_obj_filter {
  static int nf_tables_dump_obj(struct sk_buff *skb, struct netlink_callback *cb)
  {
  	const struct nfgenmsg *nfmsg = nlmsg_data(cb->nlh);
@@ -895,7 +895,7 @@
  	const struct nft_table *table;
  	unsigned int idx = 0, s_idx = cb->args[0];
  	struct nft_obj_filter *filter = cb->data;
-@@ -4658,38 +4644,37 @@ static int nf_tables_dump_obj(struct sk_
+@@ -4665,38 +4651,37 @@ static int nf_tables_dump_obj(struct sk_
  	rcu_read_lock();
  	cb->seq = net->nft.base_seq;
  
@@ -960,7 +960,7 @@
  		}
  	}
  done:
-@@ -4776,7 +4761,8 @@ static int nf_tables_getobj(struct net *
+@@ -4783,7 +4768,8 @@ static int nf_tables_getobj(struct net *
  	if (IS_ERR(afi))
  		return PTR_ERR(afi);
  
@@ -970,7 +970,7 @@
  	if (IS_ERR(table))
  		return PTR_ERR(table);
  
-@@ -4836,7 +4822,8 @@ static int nf_tables_delobj(struct net *
+@@ -4843,7 +4829,8 @@ static int nf_tables_delobj(struct net *
  	if (IS_ERR(afi))
  		return PTR_ERR(afi);
  
@@ -980,7 +980,7 @@
  	if (IS_ERR(table))
  		return PTR_ERR(table);
  
-@@ -4847,7 +4834,7 @@ static int nf_tables_delobj(struct net *
+@@ -4854,7 +4841,7 @@ static int nf_tables_delobj(struct net *
  	if (obj->use > 0)
  		return -EBUSY;
  
@@ -989,7 +989,7 @@
  
  	return nft_delobj(&ctx, obj);
  }
-@@ -4885,7 +4872,7 @@ static void nf_tables_obj_notify(const s
+@@ -4892,7 +4879,7 @@ static void nf_tables_obj_notify(const s
  				 struct nft_object *obj, int event)
  {
  	nft_obj_notify(ctx->net, ctx->table, obj, ctx->portid, ctx->seq, event,
@@ -998,7 +998,7 @@
  }
  
  /*
-@@ -5075,7 +5062,7 @@ void nft_flow_table_iterate(struct net *
+@@ -5082,7 +5069,7 @@ void nft_flow_table_iterate(struct net *
  
  	rcu_read_lock();
  	list_for_each_entry_rcu(afi, &net->nft.af_info, list) {
@@ -1007,7 +1007,7 @@
  			list_for_each_entry_rcu(flowtable, &table->flowtables, list) {
  				iter(&flowtable->data, data);
  			}
-@@ -5123,7 +5110,8 @@ static int nf_tables_newflowtable(struct
+@@ -5130,7 +5117,8 @@ static int nf_tables_newflowtable(struct
  	if (IS_ERR(afi))
  		return PTR_ERR(afi);
  
@@ -1017,7 +1017,7 @@
  	if (IS_ERR(table))
  		return PTR_ERR(table);
  
-@@ -5140,7 +5128,7 @@ static int nf_tables_newflowtable(struct
+@@ -5147,7 +5135,7 @@ static int nf_tables_newflowtable(struct
  		return 0;
  	}
  
@@ -1026,7 +1026,7 @@
  
  	flowtable = kzalloc(sizeof(*flowtable), GFP_KERNEL);
  	if (!flowtable)
-@@ -5221,7 +5209,8 @@ static int nf_tables_delflowtable(struct
+@@ -5228,7 +5216,8 @@ static int nf_tables_delflowtable(struct
  	if (IS_ERR(afi))
  		return PTR_ERR(afi);
  
@@ -1036,7 +1036,7 @@
  	if (IS_ERR(table))
  		return PTR_ERR(table);
  
-@@ -5232,7 +5221,7 @@ static int nf_tables_delflowtable(struct
+@@ -5239,7 +5228,7 @@ static int nf_tables_delflowtable(struct
  	if (flowtable->use > 0)
  		return -EBUSY;
  
@@ -1045,7 +1045,7 @@
  
  	return nft_delflowtable(&ctx, flowtable);
  }
-@@ -5301,40 +5290,37 @@ static int nf_tables_dump_flowtable(stru
+@@ -5308,40 +5297,37 @@ static int nf_tables_dump_flowtable(stru
  	struct net *net = sock_net(skb->sk);
  	int family = nfmsg->nfgen_family;
  	struct nft_flowtable *flowtable;
@@ -1107,7 +1107,7 @@
  		}
  	}
  done:
-@@ -5419,7 +5405,8 @@ static int nf_tables_getflowtable(struct
+@@ -5426,7 +5412,8 @@ static int nf_tables_getflowtable(struct
  	if (IS_ERR(afi))
  		return PTR_ERR(afi);
  
@@ -1117,7 +1117,7 @@
  	if (IS_ERR(table))
  		return PTR_ERR(table);
  
-@@ -5462,7 +5449,7 @@ static void nf_tables_flowtable_notify(s
+@@ -5469,7 +5456,7 @@ static void nf_tables_flowtable_notify(s
  
  	err = nf_tables_fill_flowtable_info(skb, ctx->net, ctx->portid,
  					    ctx->seq, event, 0,
@@ -1126,7 +1126,7 @@
  	if (err < 0) {
  		kfree_skb(skb);
  		goto err;
-@@ -5540,17 +5527,14 @@ static int nf_tables_flowtable_event(str
+@@ -5547,17 +5534,14 @@ static int nf_tables_flowtable_event(str
  	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
  	struct nft_flowtable *flowtable;
  	struct nft_table *table;
@@ -1147,7 +1147,7 @@
  		}
  	}
  	nfnl_unlock(NFNL_SUBSYS_NFTABLES);
-@@ -6576,6 +6560,7 @@ EXPORT_SYMBOL_GPL(nft_data_dump);
+@@ -6583,6 +6567,7 @@ EXPORT_SYMBOL_GPL(nft_data_dump);
  static int __net_init nf_tables_init_net(struct net *net)
  {
  	INIT_LIST_HEAD(&net->nft.af_info);
@@ -1155,7 +1155,7 @@
  	INIT_LIST_HEAD(&net->nft.commit_list);
  	net->nft.base_seq = 1;
  	return 0;
-@@ -6612,10 +6597,10 @@ static void __nft_release_afinfo(struct
+@@ -6619,10 +6604,10 @@ static void __nft_release_afinfo(struct
  	struct nft_set *set, *ns;
  	struct nft_ctx ctx = {
  		.net	= net,
--- a/target/linux/generic/backport-4.14/336-v4.15-netfilter-exit_net-cleanup-check-added.patch	2022-03-22 08:54:47.046464401 +0800
+++ b/target/linux/generic/backport-4.14/336-v4.15-netfilter-exit_net-cleanup-check-added.patch	2022-03-22 12:15:54.030429617 +0800
@@ -21,7 +21,7 @@
  static struct pernet_operations clusterip_net_ops = {
 --- a/net/netfilter/nf_tables_api.c
 +++ b/net/netfilter/nf_tables_api.c
-@@ -6566,6 +6566,12 @@ static int __net_init nf_tables_init_net
+@@ -6573,6 +6573,12 @@ static int __net_init nf_tables_init_net
  	return 0;
  }
  
@@ -34,7 +34,7 @@
  int __nft_release_basechain(struct nft_ctx *ctx)
  {
  	struct nft_rule *rule, *nr;
-@@ -6643,6 +6649,7 @@ static void __nft_release_afinfo(struct
+@@ -6650,6 +6656,7 @@ static void __nft_release_afinfo(struct
  
  static struct pernet_operations nf_tables_net_ops = {
  	.init	= nf_tables_init_net,
@@ -80,7 +80,7 @@
  static void nfnl_queue_net_exit_batch(struct list_head *net_exit_list)
 --- a/net/netfilter/x_tables.c
 +++ b/net/netfilter/x_tables.c
-@@ -1785,8 +1785,17 @@ static int __net_init xt_net_init(struct
+@@ -1784,8 +1784,17 @@ static int __net_init xt_net_init(struct
  	return 0;
  }
  
--- a/target/linux/generic/backport-4.14/337-v4.16-netfilter-nf_tables-get-rid-of-pernet-families.patch	2022-03-22 08:54:47.046464401 +0800
+++ b/target/linux/generic/backport-4.14/337-v4.16-netfilter-nf_tables-get-rid-of-pernet-families.patch	2022-03-22 12:15:54.031429610 +0800
@@ -14,7 +14,7 @@
 
 --- a/include/net/netfilter/nf_tables.h
 +++ b/include/net/netfilter/nf_tables.h
-@@ -975,8 +975,8 @@ struct nft_af_info {
+@@ -977,8 +977,8 @@ struct nft_af_info {
  	struct module			*owner;
  };
  
@@ -364,7 +364,7 @@
  		if (afi->family == family)
  			return afi;
  	}
-@@ -5057,15 +5055,12 @@ void nft_flow_table_iterate(struct net *
+@@ -5064,15 +5062,12 @@ void nft_flow_table_iterate(struct net *
  			    void *data)
  {
  	struct nft_flowtable *flowtable;
@@ -383,7 +383,7 @@
  		}
  	}
  	rcu_read_unlock();
-@@ -6557,21 +6552,6 @@ int nft_data_dump(struct sk_buff *skb, i
+@@ -6564,21 +6559,6 @@ int nft_data_dump(struct sk_buff *skb, i
  }
  EXPORT_SYMBOL_GPL(nft_data_dump);
  
@@ -405,7 +405,7 @@
  int __nft_release_basechain(struct nft_ctx *ctx)
  {
  	struct nft_rule *rule, *nr;
-@@ -6592,8 +6572,7 @@ int __nft_release_basechain(struct nft_c
+@@ -6599,8 +6579,7 @@ int __nft_release_basechain(struct nft_c
  }
  EXPORT_SYMBOL_GPL(__nft_release_basechain);
  
@@ -415,7 +415,7 @@
  {
  	struct nft_flowtable *flowtable, *nf;
  	struct nft_table *table, *nt;
-@@ -6603,10 +6582,11 @@ static void __nft_release_afinfo(struct
+@@ -6610,10 +6589,11 @@ static void __nft_release_afinfo(struct
  	struct nft_set *set, *ns;
  	struct nft_ctx ctx = {
  		.net	= net,
@@ -428,7 +428,7 @@
  		list_for_each_entry(chain, &table->chains, list)
  			nf_tables_unregister_hook(net, table, chain);
  		list_for_each_entry(flowtable, &table->flowtables, list)
-@@ -6647,6 +6627,21 @@ static void __nft_release_afinfo(struct
+@@ -6654,6 +6634,21 @@ static void __nft_release_afinfo(struct
  	}
  }
  
--- a/target/linux/generic/backport-4.14/338-v4.16-netfilter-nf_tables-get-rid-of-struct-nft_af_info-ab.patch	2022-03-22 08:54:47.048464404 +0800
+++ b/target/linux/generic/backport-4.14/338-v4.16-netfilter-nf_tables-get-rid-of-struct-nft_af_info-ab.patch	2022-03-22 12:15:54.033429597 +0800
@@ -11,7 +11,7 @@
 
 --- a/include/net/netfilter/nf_tables.h
 +++ b/include/net/netfilter/nf_tables.h
-@@ -956,28 +956,12 @@ struct nft_table {
+@@ -958,28 +958,12 @@ struct nft_table {
  	struct list_head		flowtables;
  	u64				hgenerator;
  	u32				use;
@@ -42,7 +42,7 @@
  int nft_register_chain_type(const struct nf_chain_type *);
  void nft_unregister_chain_type(const struct nf_chain_type *);
  
-@@ -1145,9 +1129,6 @@ void nft_trace_notify(struct nft_tracein
+@@ -1147,9 +1131,6 @@ void nft_trace_notify(struct nft_tracein
  #define nft_dereference(p)					\
  	nfnl_dereference(p, NFNL_SUBSYS_NFTABLES)
  
@@ -729,7 +729,7 @@
  	return 0;
  }
  
-@@ -2959,7 +2834,7 @@ static int nf_tables_dump_sets(struct sk
+@@ -2960,7 +2835,7 @@ static int nf_tables_dump_sets(struct sk
  
  	list_for_each_entry_rcu(table, &net->nft.tables, list) {
  		if (ctx->family != NFPROTO_UNSPEC &&
@@ -738,7 +738,7 @@
  			continue;
  
  		if (ctx->table && ctx->table != table)
-@@ -2980,7 +2855,7 @@ static int nf_tables_dump_sets(struct sk
+@@ -2981,7 +2856,7 @@ static int nf_tables_dump_sets(struct sk
  
  			ctx_set = *ctx;
  			ctx_set.table = table;
@@ -747,7 +747,7 @@
  
  			if (nf_tables_fill_set(skb, &ctx_set, set,
  					       NFT_MSG_NEWSET,
-@@ -3092,8 +2967,8 @@ static int nf_tables_newset(struct net *
+@@ -3093,8 +2968,8 @@ static int nf_tables_newset(struct net *
  {
  	const struct nfgenmsg *nfmsg = nlmsg_data(nlh);
  	u8 genmask = nft_genmask_next(net);
@@ -757,7 +757,7 @@
  	struct nft_table *table;
  	struct nft_set *set;
  	struct nft_ctx ctx;
-@@ -3203,16 +3078,12 @@ static int nf_tables_newset(struct net *
+@@ -3204,16 +3079,12 @@ static int nf_tables_newset(struct net *
  
  	create = nlh->nlmsg_flags & NLM_F_CREATE ? true : false;
  
@@ -776,7 +776,7 @@
  
  	set = nf_tables_set_lookup(table, nla[NFTA_SET_NAME], genmask);
  	if (IS_ERR(set)) {
-@@ -3474,19 +3345,15 @@ static int nft_ctx_init_from_elemattr(st
+@@ -3475,19 +3346,15 @@ static int nft_ctx_init_from_elemattr(st
  				      u8 genmask)
  {
  	const struct nfgenmsg *nfmsg = nlmsg_data(nlh);
@@ -799,7 +799,7 @@
  	return 0;
  }
  
-@@ -3604,7 +3471,7 @@ static int nf_tables_dump_set(struct sk_
+@@ -3605,7 +3472,7 @@ static int nf_tables_dump_set(struct sk_
  	rcu_read_lock();
  	list_for_each_entry_rcu(table, &net->nft.tables, list) {
  		if (dump_ctx->ctx.family != NFPROTO_UNSPEC &&
@@ -808,7 +808,7 @@
  			continue;
  
  		if (table != dump_ctx->ctx.table)
-@@ -3634,7 +3501,7 @@ static int nf_tables_dump_set(struct sk_
+@@ -3635,7 +3502,7 @@ static int nf_tables_dump_set(struct sk_
  		goto nla_put_failure;
  
  	nfmsg = nlmsg_data(nlh);
@@ -817,7 +817,7 @@
  	nfmsg->version      = NFNETLINK_V0;
  	nfmsg->res_id	    = htons(net->nft.base_seq & 0xffff);
  
-@@ -4516,7 +4383,6 @@ static int nf_tables_newobj(struct net *
+@@ -4523,7 +4390,6 @@ static int nf_tables_newobj(struct net *
  	const struct nft_object_type *type;
  	u8 genmask = nft_genmask_next(net);
  	int family = nfmsg->nfgen_family;
@@ -825,7 +825,7 @@
  	struct nft_table *table;
  	struct nft_object *obj;
  	struct nft_ctx ctx;
-@@ -4528,11 +4394,7 @@ static int nf_tables_newobj(struct net *
+@@ -4535,11 +4401,7 @@ static int nf_tables_newobj(struct net *
  	    !nla[NFTA_OBJ_DATA])
  		return -EINVAL;
  
@@ -838,7 +838,7 @@
  				       genmask);
  	if (IS_ERR(table))
  		return PTR_ERR(table);
-@@ -4551,7 +4413,7 @@ static int nf_tables_newobj(struct net *
+@@ -4558,7 +4420,7 @@ static int nf_tables_newobj(struct net *
  		return 0;
  	}
  
@@ -847,7 +847,7 @@
  
  	type = nft_obj_type_get(objtype);
  	if (IS_ERR(type))
-@@ -4643,7 +4505,7 @@ static int nf_tables_dump_obj(struct sk_
+@@ -4650,7 +4512,7 @@ static int nf_tables_dump_obj(struct sk_
  	cb->seq = net->nft.base_seq;
  
  	list_for_each_entry_rcu(table, &net->nft.tables, list) {
@@ -856,7 +856,7 @@
  			continue;
  
  		list_for_each_entry_rcu(obj, &table->objects, list) {
-@@ -4666,7 +4528,7 @@ static int nf_tables_dump_obj(struct sk_
+@@ -4673,7 +4535,7 @@ static int nf_tables_dump_obj(struct sk_
  						    cb->nlh->nlmsg_seq,
  						    NFT_MSG_NEWOBJ,
  						    NLM_F_MULTI | NLM_F_APPEND,
@@ -865,7 +865,7 @@
  						    obj, reset) < 0)
  				goto done;
  
-@@ -4724,7 +4586,6 @@ static int nf_tables_getobj(struct net *
+@@ -4731,7 +4593,6 @@ static int nf_tables_getobj(struct net *
  	const struct nfgenmsg *nfmsg = nlmsg_data(nlh);
  	u8 genmask = nft_genmask_cur(net);
  	int family = nfmsg->nfgen_family;
@@ -873,7 +873,7 @@
  	const struct nft_table *table;
  	struct nft_object *obj;
  	struct sk_buff *skb2;
-@@ -4755,11 +4616,7 @@ static int nf_tables_getobj(struct net *
+@@ -4762,11 +4623,7 @@ static int nf_tables_getobj(struct net *
  	    !nla[NFTA_OBJ_TYPE])
  		return -EINVAL;
  
@@ -886,7 +886,7 @@
  				       genmask);
  	if (IS_ERR(table))
  		return PTR_ERR(table);
-@@ -4806,7 +4663,6 @@ static int nf_tables_delobj(struct net *
+@@ -4813,7 +4670,6 @@ static int nf_tables_delobj(struct net *
  	const struct nfgenmsg *nfmsg = nlmsg_data(nlh);
  	u8 genmask = nft_genmask_next(net);
  	int family = nfmsg->nfgen_family;
@@ -894,7 +894,7 @@
  	struct nft_table *table;
  	struct nft_object *obj;
  	struct nft_ctx ctx;
-@@ -4816,11 +4672,7 @@ static int nf_tables_delobj(struct net *
+@@ -4823,11 +4679,7 @@ static int nf_tables_delobj(struct net *
  	    !nla[NFTA_OBJ_NAME])
  		return -EINVAL;
  
@@ -907,7 +907,7 @@
  				       genmask);
  	if (IS_ERR(table))
  		return PTR_ERR(table);
-@@ -4832,7 +4684,7 @@ static int nf_tables_delobj(struct net *
+@@ -4839,7 +4691,7 @@ static int nf_tables_delobj(struct net *
  	if (obj->use > 0)
  		return -EBUSY;
  
@@ -916,7 +916,7 @@
  
  	return nft_delobj(&ctx, obj);
  }
-@@ -5017,33 +4869,31 @@ err1:
+@@ -5024,33 +4876,31 @@ err1:
  	return err;
  }
  
@@ -956,7 +956,7 @@
  			return ERR_PTR(-EAGAIN);
  	}
  #endif
-@@ -5091,7 +4941,6 @@ static int nf_tables_newflowtable(struct
+@@ -5098,7 +4948,6 @@ static int nf_tables_newflowtable(struct
  	u8 genmask = nft_genmask_next(net);
  	int family = nfmsg->nfgen_family;
  	struct nft_flowtable *flowtable;
@@ -964,7 +964,7 @@
  	struct nft_table *table;
  	struct nft_ctx ctx;
  	int err, i, k;
-@@ -5101,12 +4950,8 @@ static int nf_tables_newflowtable(struct
+@@ -5108,12 +4957,8 @@ static int nf_tables_newflowtable(struct
  	    !nla[NFTA_FLOWTABLE_HOOK])
  		return -EINVAL;
  
@@ -978,7 +978,7 @@
  	if (IS_ERR(table))
  		return PTR_ERR(table);
  
-@@ -5123,7 +4968,7 @@ static int nf_tables_newflowtable(struct
+@@ -5130,7 +4975,7 @@ static int nf_tables_newflowtable(struct
  		return 0;
  	}
  
@@ -987,7 +987,7 @@
  
  	flowtable = kzalloc(sizeof(*flowtable), GFP_KERNEL);
  	if (!flowtable)
-@@ -5136,7 +4981,7 @@ static int nf_tables_newflowtable(struct
+@@ -5143,7 +4988,7 @@ static int nf_tables_newflowtable(struct
  		goto err1;
  	}
  
@@ -996,7 +996,7 @@
  	if (IS_ERR(type)) {
  		err = PTR_ERR(type);
  		goto err2;
-@@ -5196,16 +5041,11 @@ static int nf_tables_delflowtable(struct
+@@ -5203,16 +5048,11 @@ static int nf_tables_delflowtable(struct
  	u8 genmask = nft_genmask_next(net);
  	int family = nfmsg->nfgen_family;
  	struct nft_flowtable *flowtable;
@@ -1014,7 +1014,7 @@
  	if (IS_ERR(table))
  		return PTR_ERR(table);
  
-@@ -5216,7 +5056,7 @@ static int nf_tables_delflowtable(struct
+@@ -5223,7 +5063,7 @@ static int nf_tables_delflowtable(struct
  	if (flowtable->use > 0)
  		return -EBUSY;
  
@@ -1023,7 +1023,7 @@
  
  	return nft_delflowtable(&ctx, flowtable);
  }
-@@ -5291,7 +5131,7 @@ static int nf_tables_dump_flowtable(stru
+@@ -5298,7 +5138,7 @@ static int nf_tables_dump_flowtable(stru
  	cb->seq = net->nft.base_seq;
  
  	list_for_each_entry_rcu(table, &net->nft.tables, list) {
@@ -1032,7 +1032,7 @@
  			continue;
  
  		list_for_each_entry_rcu(flowtable, &table->flowtables, list) {
-@@ -5310,7 +5150,7 @@ static int nf_tables_dump_flowtable(stru
+@@ -5317,7 +5157,7 @@ static int nf_tables_dump_flowtable(stru
  							  cb->nlh->nlmsg_seq,
  							  NFT_MSG_NEWFLOWTABLE,
  							  NLM_F_MULTI | NLM_F_APPEND,
@@ -1041,7 +1041,7 @@
  				goto done;
  
  			nl_dump_check_consistent(cb, nlmsg_hdr(skb));
-@@ -5370,7 +5210,6 @@ static int nf_tables_getflowtable(struct
+@@ -5377,7 +5217,6 @@ static int nf_tables_getflowtable(struct
  	u8 genmask = nft_genmask_cur(net);
  	int family = nfmsg->nfgen_family;
  	struct nft_flowtable *flowtable;
@@ -1049,7 +1049,7 @@
  	const struct nft_table *table;
  	struct sk_buff *skb2;
  	int err;
-@@ -5396,12 +5235,8 @@ static int nf_tables_getflowtable(struct
+@@ -5403,12 +5242,8 @@ static int nf_tables_getflowtable(struct
  	if (!nla[NFTA_FLOWTABLE_NAME])
  		return -EINVAL;
  
@@ -1063,7 +1063,7 @@
  	if (IS_ERR(table))
  		return PTR_ERR(table);
  
-@@ -6572,7 +6407,7 @@ int __nft_release_basechain(struct nft_c
+@@ -6579,7 +6414,7 @@ int __nft_release_basechain(struct nft_c
  }
  EXPORT_SYMBOL_GPL(__nft_release_basechain);
  
@@ -1072,7 +1072,7 @@
  {
  	struct nft_flowtable *flowtable, *nf;
  	struct nft_table *table, *nt;
-@@ -6585,7 +6420,7 @@ static void __nft_release_afinfo(struct
+@@ -6592,7 +6427,7 @@ static void __nft_release_afinfo(struct
  	};
  
  	list_for_each_entry_safe(table, nt, &net->nft.tables, list) {
@@ -1081,7 +1081,7 @@
  
  		list_for_each_entry(chain, &table->chains, list)
  			nf_tables_unregister_hook(net, table, chain);
-@@ -6637,7 +6472,7 @@ static int __net_init nf_tables_init_net
+@@ -6644,7 +6479,7 @@ static int __net_init nf_tables_init_net
  
  static void __net_exit nf_tables_exit_net(struct net *net)
  {
--- a/target/linux/generic/backport-4.14/339-v4.16-netfilter-nft_flow_offload-wait-for-garbage-collecto.patch	2022-03-22 08:54:47.048464404 +0800
+++ b/target/linux/generic/backport-4.14/339-v4.16-netfilter-nft_flow_offload-wait-for-garbage-collecto.patch	2022-03-22 12:15:54.034429590 +0800
@@ -17,7 +17,7 @@
 
 --- a/net/netfilter/nf_tables_api.c
 +++ b/net/netfilter/nf_tables_api.c
-@@ -4907,13 +4907,13 @@ void nft_flow_table_iterate(struct net *
+@@ -4914,13 +4914,13 @@ void nft_flow_table_iterate(struct net *
  	struct nft_flowtable *flowtable;
  	const struct nft_table *table;
  
--- a/target/linux/generic/backport-4.14/342-v4.16-netfilter-nf_tables-fix-flowtable-free.patch	2022-03-22 08:54:47.049464406 +0800
+++ b/target/linux/generic/backport-4.14/342-v4.16-netfilter-nf_tables-fix-flowtable-free.patch	2022-03-22 12:15:54.035429583 +0800
@@ -118,7 +118,7 @@
  };
 --- a/net/netfilter/nf_tables_api.c
 +++ b/net/netfilter/nf_tables_api.c
-@@ -5292,17 +5292,12 @@ err:
+@@ -5299,17 +5299,12 @@ err:
  	nfnetlink_set_err(ctx->net, ctx->portid, NFNLGRP_NFTABLES, -ENOBUFS);
  }
  
--- a/target/linux/generic/backport-4.14/344-v4.16-netfilter-nf_tables-allocate-handle-and-delete-objec.patch	2022-03-22 08:54:47.050464408 +0800
+++ b/target/linux/generic/backport-4.14/344-v4.16-netfilter-nf_tables-allocate-handle-and-delete-objec.patch	2022-03-22 12:15:54.036429576 +0800
@@ -12,7 +12,7 @@
 
 --- a/include/net/netfilter/nf_tables.h
 +++ b/include/net/netfilter/nf_tables.h
-@@ -370,6 +370,7 @@ void nft_unregister_set(struct nft_set_t
+@@ -372,6 +372,7 @@ void nft_unregister_set(struct nft_set_t
   *	@list: table set list node
   *	@bindings: list of set bindings
   * 	@name: name of the set
@@ -20,7 +20,7 @@
   * 	@ktype: key type (numeric type defined by userspace, not used in the kernel)
   * 	@dtype: data type (verdict or numeric type defined by userspace)
   * 	@objtype: object type (see NFT_OBJECT_* definitions)
-@@ -392,6 +393,7 @@ struct nft_set {
+@@ -394,6 +395,7 @@ struct nft_set {
  	struct list_head		list;
  	struct list_head		bindings;
  	char				*name;
@@ -28,7 +28,7 @@
  	u32				ktype;
  	u32				dtype;
  	u32				objtype;
-@@ -942,6 +944,7 @@ unsigned int nft_do_chain(struct nft_pkt
+@@ -944,6 +946,7 @@ unsigned int nft_do_chain(struct nft_pkt
   *	@objects: stateful objects in the table
   *	@flowtables: flow tables in the table
   *	@hgenerator: handle generator state
@@ -36,7 +36,7 @@
   *	@use: number of chain references to this table
   *	@flags: table flag (see enum nft_table_flags)
   *	@genmask: generation mask
-@@ -955,6 +958,7 @@ struct nft_table {
+@@ -957,6 +960,7 @@ struct nft_table {
  	struct list_head		objects;
  	struct list_head		flowtables;
  	u64				hgenerator;
@@ -44,7 +44,7 @@
  	u32				use;
  	u16				family:6,
  					flags:8,
-@@ -979,9 +983,9 @@ int nft_verdict_dump(struct sk_buff *skb
+@@ -981,9 +985,9 @@ int nft_verdict_dump(struct sk_buff *skb
   *	@name: name of this stateful object
   *	@genmask: generation mask
   *	@use: number of references to this stateful object
@@ -56,7 +56,7 @@
   */
  struct nft_object {
  	struct list_head		list;
-@@ -989,6 +993,7 @@ struct nft_object {
+@@ -991,6 +995,7 @@ struct nft_object {
  	struct nft_table		*table;
  	u32				genmask:2,
  					use:30;
@@ -64,7 +64,7 @@
  	/* runtime data below here */
  	const struct nft_object_ops	*ops ____cacheline_aligned;
  	unsigned char			data[]
-@@ -1070,6 +1075,7 @@ void nft_unregister_obj(struct nft_objec
+@@ -1072,6 +1077,7 @@ void nft_unregister_obj(struct nft_objec
   *	@ops_len: number of hooks in array
   *	@genmask: generation mask
   *	@use: number of references to this flow table
@@ -72,7 +72,7 @@
   *	@data: rhashtable and garbage collector
   * 	@ops: array of hooks
   */
-@@ -1082,6 +1088,7 @@ struct nft_flowtable {
+@@ -1084,6 +1090,7 @@ struct nft_flowtable {
  	int				ops_len;
  	u32				genmask:2,
  					use:30;
@@ -307,7 +307,7 @@
  	if (set->flags != 0)
  		if (nla_put_be32(skb, NFTA_SET_FLAGS, htonl(set->flags)))
  			goto nla_put_failure;
-@@ -3149,6 +3217,7 @@ static int nf_tables_newset(struct net *
+@@ -3150,6 +3218,7 @@ static int nf_tables_newset(struct net *
  	set->udata  = udata;
  	set->timeout = timeout;
  	set->gc_int = gc_int;
@@ -315,7 +315,7 @@
  
  	err = ops->init(set, &desc, nla);
  	if (err < 0)
-@@ -3208,7 +3277,10 @@ static int nf_tables_delset(struct net *
+@@ -3209,7 +3278,10 @@ static int nf_tables_delset(struct net *
  	if (err < 0)
  		return err;
  
@@ -327,7 +327,7 @@
  	if (IS_ERR(set))
  		return PTR_ERR(set);
  
-@@ -4271,6 +4343,21 @@ struct nft_object *nf_tables_obj_lookup(
+@@ -4278,6 +4350,21 @@ struct nft_object *nf_tables_obj_lookup(
  }
  EXPORT_SYMBOL_GPL(nf_tables_obj_lookup);
  
@@ -349,7 +349,7 @@
  static const struct nla_policy nft_obj_policy[NFTA_OBJ_MAX + 1] = {
  	[NFTA_OBJ_TABLE]	= { .type = NLA_STRING,
  				    .len = NFT_TABLE_MAXNAMELEN - 1 },
-@@ -4278,6 +4365,7 @@ static const struct nla_policy nft_obj_p
+@@ -4285,6 +4372,7 @@ static const struct nla_policy nft_obj_p
  				    .len = NFT_OBJ_MAXNAMELEN - 1 },
  	[NFTA_OBJ_TYPE]		= { .type = NLA_U32 },
  	[NFTA_OBJ_DATA]		= { .type = NLA_NESTED },
@@ -357,7 +357,7 @@
  };
  
  static struct nft_object *nft_obj_init(const struct nft_ctx *ctx,
-@@ -4425,6 +4513,8 @@ static int nf_tables_newobj(struct net *
+@@ -4432,6 +4520,8 @@ static int nf_tables_newobj(struct net *
  		goto err1;
  	}
  	obj->table = table;
@@ -366,7 +366,7 @@
  	obj->name = nla_strdup(nla[NFTA_OBJ_NAME], GFP_KERNEL);
  	if (!obj->name) {
  		err = -ENOMEM;
-@@ -4471,7 +4561,9 @@ static int nf_tables_fill_obj_info(struc
+@@ -4478,7 +4568,9 @@ static int nf_tables_fill_obj_info(struc
  	    nla_put_string(skb, NFTA_OBJ_NAME, obj->name) ||
  	    nla_put_be32(skb, NFTA_OBJ_TYPE, htonl(obj->ops->type->type)) ||
  	    nla_put_be32(skb, NFTA_OBJ_USE, htonl(obj->use)) ||
@@ -377,7 +377,7 @@
  		goto nla_put_failure;
  
  	nlmsg_end(skb, nlh);
-@@ -4669,7 +4761,7 @@ static int nf_tables_delobj(struct net *
+@@ -4676,7 +4768,7 @@ static int nf_tables_delobj(struct net *
  	u32 objtype;
  
  	if (!nla[NFTA_OBJ_TYPE] ||
@@ -386,7 +386,7 @@
  		return -EINVAL;
  
  	table = nf_tables_table_lookup(net, nla[NFTA_OBJ_TABLE], family,
-@@ -4678,7 +4770,12 @@ static int nf_tables_delobj(struct net *
+@@ -4685,7 +4777,12 @@ static int nf_tables_delobj(struct net *
  		return PTR_ERR(table);
  
  	objtype = ntohl(nla_get_be32(nla[NFTA_OBJ_TYPE]));
@@ -400,7 +400,7 @@
  	if (IS_ERR(obj))
  		return PTR_ERR(obj);
  	if (obj->use > 0)
-@@ -4750,6 +4847,7 @@ static const struct nla_policy nft_flowt
+@@ -4757,6 +4854,7 @@ static const struct nla_policy nft_flowt
  	[NFTA_FLOWTABLE_NAME]		= { .type = NLA_STRING,
  					    .len = NFT_NAME_MAXLEN - 1 },
  	[NFTA_FLOWTABLE_HOOK]		= { .type = NLA_NESTED },
@@ -408,7 +408,7 @@
  };
  
  struct nft_flowtable *nf_tables_flowtable_lookup(const struct nft_table *table,
-@@ -4767,6 +4865,20 @@ struct nft_flowtable *nf_tables_flowtabl
+@@ -4774,6 +4872,20 @@ struct nft_flowtable *nf_tables_flowtabl
  }
  EXPORT_SYMBOL_GPL(nf_tables_flowtable_lookup);
  
@@ -429,7 +429,7 @@
  #define NFT_FLOWTABLE_DEVICE_MAX	8
  
  static int nf_tables_parse_devices(const struct nft_ctx *ctx,
-@@ -4975,6 +5087,8 @@ static int nf_tables_newflowtable(struct
+@@ -4982,6 +5094,8 @@ static int nf_tables_newflowtable(struct
  		return -ENOMEM;
  
  	flowtable->table = table;
@@ -438,7 +438,7 @@
  	flowtable->name = nla_strdup(nla[NFTA_FLOWTABLE_NAME], GFP_KERNEL);
  	if (!flowtable->name) {
  		err = -ENOMEM;
-@@ -5049,8 +5163,14 @@ static int nf_tables_delflowtable(struct
+@@ -5056,8 +5170,14 @@ static int nf_tables_delflowtable(struct
  	if (IS_ERR(table))
  		return PTR_ERR(table);
  
@@ -455,7 +455,7 @@
  	if (IS_ERR(flowtable))
                  return PTR_ERR(flowtable);
  	if (flowtable->use > 0)
-@@ -5083,7 +5203,9 @@ static int nf_tables_fill_flowtable_info
+@@ -5090,7 +5210,9 @@ static int nf_tables_fill_flowtable_info
  
  	if (nla_put_string(skb, NFTA_FLOWTABLE_TABLE, flowtable->table->name) ||
  	    nla_put_string(skb, NFTA_FLOWTABLE_NAME, flowtable->name) ||
--- a/target/linux/generic/backport-4.14/350-v4.18-ipv6-make-ip6_dst_mtu_forward-inline.patch	2022-03-22 08:54:47.052464411 +0800
+++ b/target/linux/generic/backport-4.14/350-v4.18-ipv6-make-ip6_dst_mtu_forward-inline.patch	2022-03-22 12:15:54.039429555 +0800
@@ -9,7 +9,7 @@
 
 --- a/include/net/ip6_route.h
 +++ b/include/net/ip6_route.h
-@@ -252,4 +252,26 @@ static inline bool rt6_duplicate_nexthop
+@@ -253,4 +253,26 @@ static inline bool rt6_duplicate_nexthop
  	       ipv6_addr_equal(&a->rt6i_gateway, &b->rt6i_gateway) &&
  	       !lwtunnel_cmp_encap(a->dst.lwtstate, b->dst.lwtstate);
  }
@@ -46,10 +46,10 @@
 -
  int ip6_dst_lookup(struct net *net, struct sock *sk, struct dst_entry **dst,
  		   struct flowi6 *fl6);
- struct dst_entry *ip6_dst_lookup_flow(const struct sock *sk, struct flowi6 *fl6,
+ struct dst_entry *ip6_dst_lookup_flow(struct net *net, const struct sock *sk, struct flowi6 *fl6,
 --- a/net/ipv6/ip6_output.c
 +++ b/net/ipv6/ip6_output.c
-@@ -381,28 +381,6 @@ static inline int ip6_forward_finish(str
+@@ -419,28 +419,6 @@ static inline int ip6_forward_finish(str
  	return dst_output(net, sk, skb);
  }
  
--- a/target/linux/generic/backport-4.14/357-v4.18-netfilter-nf_flow_table-move-init-code-to-nf_flow_ta.patch	2022-03-22 08:54:47.056464418 +0800
+++ b/target/linux/generic/backport-4.14/357-v4.18-netfilter-nf_flow_table-move-init-code-to-nf_flow_ta.patch	2022-03-22 12:15:54.043429528 +0800
@@ -236,7 +236,7 @@
  	.owner		= THIS_MODULE,
 --- a/net/netfilter/nf_tables_api.c
 +++ b/net/netfilter/nf_tables_api.c
-@@ -5102,40 +5102,38 @@ static int nf_tables_newflowtable(struct
+@@ -5109,40 +5109,38 @@ static int nf_tables_newflowtable(struct
  	}
  
  	flowtable->data.type = type;
@@ -285,7 +285,7 @@
  err3:
  	module_put(type->owner);
  err2:
-@@ -5416,10 +5414,8 @@ err:
+@@ -5423,10 +5421,8 @@ err:
  
  static void nf_tables_flowtable_destroy(struct nft_flowtable *flowtable)
  {
--- a/target/linux/generic/backport-4.14/358-v4.18-netfilter-nf_flow_table-fix-priv-pointer-for-netdev-.patch	2022-03-22 08:54:47.057464419 +0800
+++ b/target/linux/generic/backport-4.14/358-v4.18-netfilter-nf_flow_table-fix-priv-pointer-for-netdev-.patch	2022-03-22 12:15:54.044429521 +0800
@@ -11,7 +11,7 @@
 
 --- a/net/netfilter/nf_tables_api.c
 +++ b/net/netfilter/nf_tables_api.c
-@@ -4968,7 +4968,7 @@ static int nf_tables_flowtable_parse_hoo
+@@ -4975,7 +4975,7 @@ static int nf_tables_flowtable_parse_hoo
  		flowtable->ops[i].pf		= NFPROTO_NETDEV;
  		flowtable->ops[i].hooknum	= hooknum;
  		flowtable->ops[i].priority	= priority;
--- a/target/linux/generic/backport-4.14/359-v4.18-netfilter-nf_flow_table-track-flow-tables-in-nf_flow.patch	2022-03-22 08:54:47.057464419 +0800
+++ b/target/linux/generic/backport-4.14/359-v4.18-netfilter-nf_flow_table-track-flow-tables-in-nf_flow.patch	2022-03-22 12:15:54.044429521 +0800
@@ -21,7 +21,7 @@
  	struct delayed_work		gc_work;
 --- a/include/net/netfilter/nf_tables.h
 +++ b/include/net/netfilter/nf_tables.h
-@@ -1097,9 +1097,6 @@ struct nft_flowtable {
+@@ -1099,9 +1099,6 @@ struct nft_flowtable {
  struct nft_flowtable *nf_tables_flowtable_lookup(const struct nft_table *table,
  						 const struct nlattr *nla,
  						 u8 genmask);
@@ -88,7 +88,7 @@
  	WARN_ON(!nf_flow_offload_gc_step(flow_table));
 --- a/net/netfilter/nf_tables_api.c
 +++ b/net/netfilter/nf_tables_api.c
-@@ -5012,23 +5012,6 @@ static const struct nf_flowtable_type *n
+@@ -5019,23 +5019,6 @@ static const struct nf_flowtable_type *n
  	return ERR_PTR(-ENOENT);
  }
  
--- a/target/linux/generic/backport-4.14/370-netfilter-nf_flow_table-fix-offloaded-connection-tim.patch	2022-03-22 08:54:47.061464426 +0800
+++ b/target/linux/generic/backport-4.14/370-netfilter-nf_flow_table-fix-offloaded-connection-tim.patch	2022-03-22 12:15:54.049429487 +0800
@@ -21,7 +21,7 @@
 
 --- a/net/netfilter/nf_conntrack_core.c
 +++ b/net/netfilter/nf_conntrack_core.c
-@@ -1040,18 +1040,6 @@ static bool gc_worker_can_early_drop(con
+@@ -1055,18 +1055,6 @@ static bool gc_worker_can_early_drop(con
  	return false;
  }
  
@@ -40,7 +40,7 @@
  static void gc_worker(struct work_struct *work)
  {
  	unsigned int min_interval = max(HZ / GC_MAX_BUCKETS_DIV, 1u);
-@@ -1088,10 +1076,8 @@ static void gc_worker(struct work_struct
+@@ -1103,10 +1091,8 @@ static void gc_worker(struct work_struct
  			tmp = nf_ct_tuplehash_to_ctrack(h);
  
  			scanned++;
--- a/target/linux/generic/backport-4.14/373-netfilter_actual_sk.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/backport-4.14/373-netfilter_actual_sk.patch	2022-03-22 12:15:54.050429480 +0800
@@ -0,0 +1,234 @@
+From: "Jason A. Donenfeld" <Jason@zx2c4.com>
+To: Pablo Neira Ayuso <pablo@netfilter.org>,
+        netfilter-devel@vger.kernel.org, netdev@vger.kernel.org
+Cc: "Jason A. Donenfeld" <Jason@zx2c4.com>
+Subject: [PATCH nf 2/2] netfilter: use actual socket sk rather than skb sk when routing harder
+Date: Thu, 29 Oct 2020 03:56:06 +0100
+Message-ID: <20201029025606.3523771-3-Jason@zx2c4.com> (raw)
+In-Reply-To: <20201029025606.3523771-1-Jason@zx2c4.com>
+
+If netfilter changes the packet mark when mangling, the packet is
+rerouted using the route_me_harder set of functions. Prior to this
+commit, there's one big difference between route_me_harder and the
+ordinary initial routing functions, described in the comment above
+__ip_queue_xmit():
+
+   /* Note: skb->sk can be different from sk, in case of tunnels */
+   int __ip_queue_xmit(struct sock *sk, struct sk_buff *skb, struct flowi *fl,
+
+That function goes on to correctly make use of sk->sk_bound_dev_if,
+rather than skb->sk->sk_bound_dev_if. And indeed the comment is true: a
+tunnel will receive a packet in ndo_start_xmit with an initial skb->sk.
+It will make some transformations to that packet, and then it will send
+the encapsulated packet out of a *new* socket. That new socket will
+basically always have a different sk_bound_dev_if (otherwise there'd be
+a routing loop). So for the purposes of routing the encapsulated packet,
+the routing information as it pertains to the socket should come from
+that socket's sk, rather than the packet's original skb->sk. For that
+reason __ip_queue_xmit() and related functions all do the right thing.
+
+One might argue that all tunnels should just call skb_orphan(skb) before
+transmitting the encapsulated packet into the new socket. But tunnels do
+*not* do this -- and this is wisely avoided in skb_scrub_packet() too --
+because features like TSQ rely on skb->destructor() being called when
+that buffer space is truely available again. Calling skb_orphan(skb) too
+early would result in buffers filling up unnecessarily and accounting
+info being all wrong. Instead, additional routing must take into account
+the new sk, just as __ip_queue_xmit() notes.
+
+So, this commit addresses the problem by fishing the correct sk out of
+state->sk -- it's already set properly in the call to nf_hook() in
+__ip_local_out(), which receives the sk as part of its normal
+functionality. So we make sure to plumb state->sk through the various
+route_me_harder functions, and then make correct use of it following the
+example of __ip_queue_xmit().
+
+Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
+Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
+[aaronjg@stanford.edu: backported to 4.14]
+Signed-off-by: Aaron Goodman <aaronjg@stanford.edu>
+--- a/include/linux/netfilter_ipv4.h
++++ b/include/linux/netfilter_ipv4.h
+@@ -16,7 +16,7 @@ struct ip_rt_info {
+ 	u_int32_t mark;
+ };
+ 
+-int ip_route_me_harder(struct net *net, struct sk_buff *skb, unsigned addr_type);
++int ip_route_me_harder(struct net *net, struct sock *sk, struct sk_buff *skb, unsigned addr_type);
+ 
+ struct nf_queue_entry;
+ 
+--- a/include/linux/netfilter_ipv6.h
++++ b/include/linux/netfilter_ipv6.h
+@@ -41,7 +41,7 @@ struct nf_ipv6_ops {
+ };
+ 
+ #ifdef CONFIG_NETFILTER
+-int ip6_route_me_harder(struct net *net, struct sk_buff *skb);
++int ip6_route_me_harder(struct net *net, struct sock *sk, struct sk_buff *skb);
+ __sum16 nf_ip6_checksum(struct sk_buff *skb, unsigned int hook,
+ 			unsigned int dataoff, u_int8_t protocol);
+ 
+--- a/net/ipv4/netfilter.c
++++ b/net/ipv4/netfilter.c
+@@ -17,17 +17,19 @@
+ #include <net/netfilter/nf_queue.h>
+ 
+ /* route_me_harder function, used by iptable_nat, iptable_mangle + ip_queue */
+-int ip_route_me_harder(struct net *net, struct sk_buff *skb, unsigned int addr_type)
++int ip_route_me_harder(struct net *net, struct sock *sk, struct sk_buff *skb, unsigned int addr_type)
+ {
+ 	const struct iphdr *iph = ip_hdr(skb);
+ 	struct rtable *rt;
+ 	struct flowi4 fl4 = {};
+ 	__be32 saddr = iph->saddr;
+-	const struct sock *sk = skb_to_full_sk(skb);
+-	__u8 flags = sk ? inet_sk_flowi_flags(sk) : 0;
++	__u8 flags;
+ 	struct net_device *dev = skb_dst(skb)->dev;
+ 	unsigned int hh_len;
+ 
++	sk = sk_to_full_sk(sk);
++	flags = sk ? inet_sk_flowi_flags(sk) : 0;
++
+ 	if (addr_type == RTN_UNSPEC)
+ 		addr_type = inet_addr_type_dev_table(net, dev, saddr);
+ 	if (addr_type == RTN_LOCAL || addr_type == RTN_UNICAST)
+@@ -91,7 +93,7 @@ int nf_ip_reroute(struct sk_buff *skb, c
+ 		      skb->mark == rt_info->mark &&
+ 		      iph->daddr == rt_info->daddr &&
+ 		      iph->saddr == rt_info->saddr))
+-			return ip_route_me_harder(entry->state.net, skb,
++			return ip_route_me_harder(entry->state.net, entry->state.sk, skb,
+ 						  RTN_UNSPEC);
+ 	}
+ 	return 0;
+--- a/net/ipv4/netfilter/ipt_SYNPROXY.c
++++ b/net/ipv4/netfilter/ipt_SYNPROXY.c
+@@ -53,7 +53,7 @@ synproxy_send_tcp(struct net *net,
+ 
+ 	skb_dst_set_noref(nskb, skb_dst(skb));
+ 	nskb->protocol = htons(ETH_P_IP);
+-	if (ip_route_me_harder(net, nskb, RTN_UNSPEC))
++	if (ip_route_me_harder(net, nskb->sk, nskb, RTN_UNSPEC))
+ 		goto free_nskb;
+ 
+ 	if (nfct) {
+--- a/net/ipv4/netfilter/iptable_mangle.c
++++ b/net/ipv4/netfilter/iptable_mangle.c
+@@ -65,7 +65,7 @@ ipt_mangle_out(struct sk_buff *skb, cons
+ 		    iph->daddr != daddr ||
+ 		    skb->mark != mark ||
+ 		    iph->tos != tos) {
+-			err = ip_route_me_harder(state->net, skb, RTN_UNSPEC);
++			err = ip_route_me_harder(state->net, state->sk, skb, RTN_UNSPEC);
+ 			if (err < 0)
+ 				ret = NF_DROP_ERR(err);
+ 		}
+--- a/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
++++ b/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
+@@ -397,7 +397,7 @@ nf_nat_ipv4_local_fn(void *priv, struct
+ 
+ 		if (ct->tuplehash[dir].tuple.dst.u3.ip !=
+ 		    ct->tuplehash[!dir].tuple.src.u3.ip) {
+-			err = ip_route_me_harder(state->net, skb, RTN_UNSPEC);
++			err = ip_route_me_harder(state->net, state->sk, skb, RTN_UNSPEC);
+ 			if (err < 0)
+ 				ret = NF_DROP_ERR(err);
+ 		}
+--- a/net/ipv4/netfilter/nf_reject_ipv4.c
++++ b/net/ipv4/netfilter/nf_reject_ipv4.c
+@@ -129,7 +129,7 @@ void nf_send_reset(struct net *net, stru
+ 				   ip4_dst_hoplimit(skb_dst(nskb)));
+ 	nf_reject_ip_tcphdr_put(nskb, oldskb, oth);
+ 
+-	if (ip_route_me_harder(net, nskb, RTN_UNSPEC))
++	if (ip_route_me_harder(net, nskb->sk, nskb, RTN_UNSPEC))
+ 		goto free_nskb;
+ 
+ 	niph = ip_hdr(nskb);
+--- a/net/ipv4/netfilter/nft_chain_route_ipv4.c
++++ b/net/ipv4/netfilter/nft_chain_route_ipv4.c
+@@ -50,7 +50,7 @@ static unsigned int nf_route_table_hook(
+ 		    iph->daddr != daddr ||
+ 		    skb->mark != mark ||
+ 		    iph->tos != tos) {
+-			err = ip_route_me_harder(state->net, skb, RTN_UNSPEC);
++			err = ip_route_me_harder(state->net, state->sk, skb, RTN_UNSPEC);
+ 			if (err < 0)
+ 				ret = NF_DROP_ERR(err);
+ 		}
+--- a/net/ipv6/netfilter.c
++++ b/net/ipv6/netfilter.c
+@@ -18,10 +18,10 @@
+ #include <net/ip6_checksum.h>
+ #include <net/netfilter/nf_queue.h>
+ 
+-int ip6_route_me_harder(struct net *net, struct sk_buff *skb)
++int ip6_route_me_harder(struct net *net, struct sock *sk_partial, struct sk_buff *skb)
+ {
+ 	const struct ipv6hdr *iph = ipv6_hdr(skb);
+-	struct sock *sk = sk_to_full_sk(skb->sk);
++	struct sock *sk = sk_to_full_sk(sk_partial);
+ 	unsigned int hh_len;
+ 	struct dst_entry *dst;
+ 	int strict = (ipv6_addr_type(&iph->daddr) &
+@@ -82,7 +82,7 @@ static int nf_ip6_reroute(struct sk_buff
+ 		if (!ipv6_addr_equal(&iph->daddr, &rt_info->daddr) ||
+ 		    !ipv6_addr_equal(&iph->saddr, &rt_info->saddr) ||
+ 		    skb->mark != rt_info->mark)
+-			return ip6_route_me_harder(entry->state.net, skb);
++			return ip6_route_me_harder(entry->state.net, entry->state.sk, skb);
+ 	}
+ 	return 0;
+ }
+--- a/net/ipv6/netfilter/ip6table_mangle.c
++++ b/net/ipv6/netfilter/ip6table_mangle.c
+@@ -60,7 +60,7 @@ ip6t_mangle_out(struct sk_buff *skb, con
+ 	     skb->mark != mark ||
+ 	     ipv6_hdr(skb)->hop_limit != hop_limit ||
+ 	     flowlabel != *((u_int32_t *)ipv6_hdr(skb)))) {
+-		err = ip6_route_me_harder(state->net, skb);
++		err = ip6_route_me_harder(state->net, state->sk, skb);
+ 		if (err < 0)
+ 			ret = NF_DROP_ERR(err);
+ 	}
+--- a/net/ipv6/netfilter/nf_nat_l3proto_ipv6.c
++++ b/net/ipv6/netfilter/nf_nat_l3proto_ipv6.c
+@@ -414,7 +414,7 @@ nf_nat_ipv6_local_fn(void *priv, struct
+ 
+ 		if (!nf_inet_addr_cmp(&ct->tuplehash[dir].tuple.dst.u3,
+ 				      &ct->tuplehash[!dir].tuple.src.u3)) {
+-			err = ip6_route_me_harder(state->net, skb);
++			err = ip6_route_me_harder(state->net, state->sk,  skb);
+ 			if (err < 0)
+ 				ret = NF_DROP_ERR(err);
+ 		}
+--- a/net/ipv6/netfilter/nft_chain_route_ipv6.c
++++ b/net/ipv6/netfilter/nft_chain_route_ipv6.c
+@@ -52,7 +52,7 @@ static unsigned int nf_route_table_hook(
+ 	     skb->mark != mark ||
+ 	     ipv6_hdr(skb)->hop_limit != hop_limit ||
+ 	     flowlabel != *((u_int32_t *)ipv6_hdr(skb)))) {
+-		err = ip6_route_me_harder(state->net, skb);
++		err = ip6_route_me_harder(state->net, state->sk, skb);
+ 		if (err < 0)
+ 			ret = NF_DROP_ERR(err);
+ 	}
+--- a/net/netfilter/ipvs/ip_vs_core.c
++++ b/net/netfilter/ipvs/ip_vs_core.c
+@@ -713,12 +713,12 @@ static int ip_vs_route_me_harder(struct
+ 		struct dst_entry *dst = skb_dst(skb);
+ 
+ 		if (dst->dev && !(dst->dev->flags & IFF_LOOPBACK) &&
+-		    ip6_route_me_harder(ipvs->net, skb) != 0)
++		    ip6_route_me_harder(ipvs->net, skb->sk, skb) != 0)
+ 			return 1;
+ 	} else
+ #endif
+ 		if (!(skb_rtable(skb)->rt_flags & RTCF_LOCAL) &&
+-		    ip_route_me_harder(ipvs->net, skb, RTN_LOCAL) != 0)
++		    ip_route_me_harder(ipvs->net, skb->sk, skb, RTN_LOCAL) != 0)
+ 			return 1;
+ 
+ 	return 0;
--- a/target/linux/generic/backport-4.14/380-v5.3-net-sched-Introduce-act_ctinfo-action.patch	2022-03-22 08:54:47.063464429 +0800
+++ b/target/linux/generic/backport-4.14/380-v5.3-net-sched-Introduce-act_ctinfo-action.patch	2022-03-22 12:15:54.052429466 +0800
@@ -1,110 +1,47 @@
-From 147b0d133b53635db0cc572294840652c9c7b662 Mon Sep 17 00:00:00 2001
+From e3777dd42dc6f1b9cb099836707a3e7971dcf4df Mon Sep 17 00:00:00 2001
 From: Kevin Darbyshire-Bryant <ldir@darbyshire-bryant.me.uk>
 Date: Wed, 13 Mar 2019 20:54:49 +0000
-Subject: [PATCH] net: sched: Backport Introduce act_ctinfo action
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-ctinfo is a new tc filter action module.  It is designed to restore
-information contained in firewall conntrack marks to other packet fields
-and is typically used on packet ingress paths.  At present it has two
-independent sub-functions or operating modes, DSCP restoration mode &
-skb mark restoration mode.
-
-The DSCP restore mode:
-
-This mode copies DSCP values that have been placed in the firewall
-conntrack mark back into the IPv4/v6 diffserv fields of relevant
-packets.
-
-The DSCP restoration is intended for use and has been found useful for
-restoring ingress classifications based on egress classifications across
-links that bleach or otherwise change DSCP, typically home ISP Internet
-links.  Restoring DSCP on ingress on the WAN link allows qdiscs such as
-but by no means limited to CAKE to shape inbound packets according to
-policies that are easier to set & mark on egress.
+Subject: [PATCH] net: sched: Introduce act_ctinfo action
+
+ctinfo is a new tc filter action module.  It is designed to restore DSCPs
+stored in conntrack marks
+
+The feature is intended for use and has been found useful for restoring
+ingress classifications based on egress classifications across links
+that bleach or otherwise change DSCP, typically home ISP Internet links.
+Restoring DSCP on ingress on the WAN link allows qdiscs such as CAKE to
+shape inbound packets according to policies that are easier to implement
+on egress.
 
 Ingress classification is traditionally a challenging task since
 iptables rules haven't yet run and tc filter/eBPF programs are pre-NAT
 lookups, hence are unable to see internal IPv4 addresses as used on the
-typical home masquerading gateway.  Thus marking the connection in some
-manner on egress for later restoration of classification on ingress is
-easier to implement.
+typical home masquerading gateway.
+
+ctinfo understands the following parameters:
 
-Parameters related to DSCP restore mode:
+dscp mask[/statemask]
 
-dscpmask - a 32 bit mask of 6 contiguous bits and indicate bits of the
-conntrack mark field contain the DSCP value to be restored.
+mask - a 32 bit mask of at least 6 contiguous bits where conndscp will
+place the DSCP in conntrack mark.  The DSCP is left-shifted by the
+number of unset lower bits of the mask before storing into the mark
+field.
 
 statemask - a 32 bit mask of (usually) 1 bit length, outside the area
-specified by dscpmask.  This represents a conditional operation flag
-whereby the DSCP is only restored if the flag is set.  This is useful to
-implement a 'one shot' iptables based classification where the
-'complicated' iptables rules are only run once to classify the
-connection on initial (egress) packet and subsequent packets are all
-marked/restored with the same DSCP.  A mask of zero disables the
-conditional behaviour ie. the conntrack mark DSCP bits are always
-restored to the ip diffserv field (assuming the conntrack entry is found
-& the skb is an ipv4/ipv6 type)
-
-e.g. dscpmask 0xfc000000 statemask 0x01000000
-
-|----0xFC----conntrack mark----000000---|
-| Bits 31-26 | bit 25 | bit24 |~~~ Bit 0|
-| DSCP       | unused | flag  |unused   |
-|-----------------------0x01---000000---|
-      |                   |
-      |                   |
-      ---|             Conditional flag
-         v             only restore if set
-|-ip diffserv-|
-| 6 bits      |
-|-------------|
-
-The skb mark restore mode (cpmark):
-
-This mode copies the firewall conntrack mark to the skb's mark field.
-It is completely the functional equivalent of the existing act_connmark
-action with the additional feature of being able to apply a mask to the
-restored value.
-
-Parameters related to skb mark restore mode:
-
-mask - a 32 bit mask applied to the firewall conntrack mark to mask out
-bits unwanted for restoration.  This can be useful where the conntrack
-mark is being used for different purposes by different applications.  If
-not specified and by default the whole mark field is copied (i.e.
-default mask of 0xffffffff)
-
-e.g. mask 0x00ffffff to mask out the top 8 bits being used by the
-aforementioned DSCP restore mode.
-
-|----0x00----conntrack mark----ffffff---|
-| Bits 31-24 |                          |
-| DSCP & flag|      some value here     |
-|---------------------------------------|
-			|
-			|
-			v
-|------------skb mark-------------------|
-|            |                          |
-|  zeroed    |                          |
-|---------------------------------------|
+specified by mask.  This represents a conditional operation flag the
+DSCP is only restored if the flag is set.  This is useful to implement a
+'one shot' iptables based classification where the 'complicated'
+iptables rules are only run once to classify the connection on initial
+(egress) packet and subsequent packets are all marked/restored with the
+same DSCP.  A mask of zero disables the conditional behaviour.
 
-Overall parameters:
+optional parameters:
 
 zone - conntrack zone
 
 control - action related control (reclassify | pipe | drop | continue |
-ok | goto chain <CHAIN_INDEX>)
-
-Signed-off-by: Kevin Darbyshire-Bryant <ldir@darbyshire-bryant.me.uk>
-Reviewed-by: Toke Hiland-Jrgensen <toke@redhat.com>
-Acked-by: Cong Wang <xiyou.wangcong@gmail.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
+ok | goto chain <CHAIN_INDEX>
 
-Backport
 Signed-off-by: Kevin Darbyshire-Bryant <ldir@darbyshire-bryant.me.uk>
 ---
  include/net/tc_act/tc_ctinfo.h        |  33 +++
@@ -595,7 +532,7 @@
 +{
 +	struct tc_action_net *tn = net_generic(net, ctinfo_net_id);
 +
-+	return tc_action_net_init(tn, &act_ctinfo_ops);
++	return tc_action_net_init(net, tn, &act_ctinfo_ops);
 +}
 +
 +static void __net_exit ctinfo_exit_net(struct net *net)
--- a/target/linux/generic/backport-4.14/403-v4.15-0001-mtd-spi-nor-add-a-quad_enable-callback-in-struct-fla.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/backport-4.14/403-v4.15-0001-mtd-spi-nor-add-a-quad_enable-callback-in-struct-fla.patch	2022-03-22 12:15:54.054429452 +0800
@@ -0,0 +1,47 @@
+From e27072851bf7d706c592fc528549b52023b17a09 Mon Sep 17 00:00:00 2001
+From: Andy Yan <andy.yan@rock-chips.com>
+Date: Mon, 28 Aug 2017 09:58:29 +0800
+Subject: [PATCH 1/2] mtd: spi-nor: add a quad_enable callback in struct
+ flash_info
+
+Some manufacturers may use different bit to set QE on different
+memories.
+
+The GD25Q256 from GigaDevice is an example, which uses S6(bit 6
+of the Status Register-1) to set QE, which is different with
+other supported memories from GigaDevice that use S9(bit 1 of
+the Status Register-2). This makes it is impossible to select
+the quad enable method by distinguishing the MFR. This patch
+introduce a quad_enable function which can be set per memory
+in the flash_info list table.
+
+Signed-off-by: Andy Yan <andy.yan@rock-chips.com>
+Signed-off-by: Cyrille Pitchen <cyrille.pitchen@wedev4u.fr>
+
+--- a/drivers/mtd/spi-nor/spi-nor.c
++++ b/drivers/mtd/spi-nor/spi-nor.c
+@@ -89,6 +89,8 @@ struct flash_info {
+ #define NO_CHIP_ERASE		BIT(12) /* Chip does not support chip erase */
+ #define SPI_NOR_SKIP_SFDP	BIT(13)	/* Skip parsing of SFDP tables */
+ #define USE_CLSR		BIT(14)	/* use CLSR command */
++
++	int	(*quad_enable)(struct spi_nor *nor);
+ };
+ 
+ #define JEDEC_MFR(info)	((info)->id[0])
+@@ -2433,6 +2435,15 @@ static int spi_nor_init_params(struct sp
+ 			params->quad_enable = spansion_quad_enable;
+ 			break;
+ 		}
++
++		/*
++		 * Some manufacturer like GigaDevice may use different
++		 * bit to set QE on different memories, so the MFR can't
++		 * indicate the quad_enable method for this case, we need
++		 * set it in flash info list.
++		 */
++		if (info->quad_enable)
++			params->quad_enable = info->quad_enable;
+ 	}
+ 
+ 	/* Override the parameters with data read from SFDP tables. */
--- a/target/linux/generic/backport-4.14/403-v4.15-0002-mtd-spi-nor-add-support-for-GD25Q256.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/backport-4.14/403-v4.15-0002-mtd-spi-nor-add-support-for-GD25Q256.patch	2022-03-22 12:15:54.055429445 +0800
@@ -0,0 +1,35 @@
+From 65153846b18c486ce3c90477c467d53915114e3f Mon Sep 17 00:00:00 2001
+From: Andy Yan <andy.yan@rock-chips.com>
+Date: Mon, 28 Aug 2017 10:00:46 +0800
+Subject: [PATCH 2/2] mtd: spi-nor: add support for GD25Q256
+
+Add support for GD25Q256, a 32MiB SPI Nor flash
+from GigaDevice.
+
+Signed-off-by: Andy Yan <andy.yan@rock-chips.com>
+Signed-off-by: Cyrille Pitchen <cyrille.pitchen@wedev4u.fr>
+
+--- a/drivers/mtd/spi-nor/spi-nor.c
++++ b/drivers/mtd/spi-nor/spi-nor.c
+@@ -872,6 +872,8 @@ static int spi_nor_is_locked(struct mtd_
+ 	return ret;
+ }
+ 
++static int macronix_quad_enable(struct spi_nor *nor);
++
+ /* Used when the "_ext_id" is two bytes at most */
+ #define INFO(_jedec_id, _ext_id, _sector_size, _n_sectors, _flags)	\
+ 		.id = {							\
+@@ -999,6 +1001,12 @@ static const struct flash_info spi_nor_i
+ 			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
+ 			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
+ 	},
++	{
++		"gd25q256", INFO(0xc84019, 0, 64 * 1024, 512,
++			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
++			SPI_NOR_4B_OPCODES | SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
++			.quad_enable = macronix_quad_enable,
++	},
+ 
+ 	/* Intel/Numonyx -- xxxs33b */
+ 	{ "160s33b",  INFO(0x898911, 0, 64 * 1024,  32, 0) },
--- a/target/linux/generic/backport-4.14/500-v4.20-ubifs-Fix-default-compression-selection-in-ubifs.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/backport-4.14/500-v4.20-ubifs-Fix-default-compression-selection-in-ubifs.patch	2022-03-22 12:15:54.055429445 +0800
@@ -0,0 +1,37 @@
+From: Gabor Juhos <juhosg@openwrt.org>
+Subject: fs: ubifs: fix default compression selection in ubifs
+
+Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
+---
+ fs/ubifs/sb.c | 13 ++++++++++++-
+ 1 file changed, 12 insertions(+), 1 deletion(-)
+
+--- a/fs/ubifs/sb.c
++++ b/fs/ubifs/sb.c
+@@ -63,6 +63,17 @@
+ /* Default time granularity in nanoseconds */
+ #define DEFAULT_TIME_GRAN 1000000000
+ 
++static int get_default_compressor(void)
++{
++	if (ubifs_compr_present(UBIFS_COMPR_LZO))
++		return UBIFS_COMPR_LZO;
++
++	if (ubifs_compr_present(UBIFS_COMPR_ZLIB))
++		return UBIFS_COMPR_ZLIB;
++
++	return UBIFS_COMPR_NONE;
++}
++
+ /**
+  * create_default_filesystem - format empty UBI volume.
+  * @c: UBIFS file-system description object
+@@ -186,7 +197,7 @@ static int create_default_filesystem(str
+ 	if (c->mount_opts.override_compr)
+ 		sup->default_compr = cpu_to_le16(c->mount_opts.compr_type);
+ 	else
+-		sup->default_compr = cpu_to_le16(UBIFS_COMPR_LZO);
++		sup->default_compr = cpu_to_le16(get_default_compressor());
+ 
+ 	generate_random_uuid(sup->uuid);
+ 
--- a/target/linux/generic/backport-4.14/900-v4.18-firmware-dmi-Add-access-to-the-SKU-ID-string.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/backport-4.14/900-v4.18-firmware-dmi-Add-access-to-the-SKU-ID-string.patch	2022-03-22 12:15:54.056429438 +0800
@@ -0,0 +1,57 @@
+From b23908d3c48a37c46c6a26df2cdeab1610b360ba Mon Sep 17 00:00:00 2001
+From: Simon Glass <sjg@chromium.org>
+Date: Sun, 17 Jun 2018 14:09:42 +0200
+Subject: [PATCH] firmware: dmi: Add access to the SKU ID string
+
+This is used in some systems from user space for determining the identity
+of the device.
+
+Expose this as a file so that that user-space tools don't need to read
+from /sys/firmware/dmi/tables/DMI
+
+Signed-off-by: Simon Glass <sjg@chromium.org>
+Signed-off-by: Jean Delvare <jdelvare@suse.de>
+---
+ drivers/firmware/dmi-id.c       | 2 ++
+ drivers/firmware/dmi_scan.c     | 1 +
+ include/linux/mod_devicetable.h | 1 +
+ 3 files changed, 4 insertions(+)
+
+--- a/drivers/firmware/dmi-id.c
++++ b/drivers/firmware/dmi-id.c
+@@ -47,6 +47,7 @@ DEFINE_DMI_ATTR_WITH_SHOW(product_name,
+ DEFINE_DMI_ATTR_WITH_SHOW(product_version,	0444, DMI_PRODUCT_VERSION);
+ DEFINE_DMI_ATTR_WITH_SHOW(product_serial,	0400, DMI_PRODUCT_SERIAL);
+ DEFINE_DMI_ATTR_WITH_SHOW(product_uuid,		0400, DMI_PRODUCT_UUID);
++DEFINE_DMI_ATTR_WITH_SHOW(product_sku,		0444, DMI_PRODUCT_SKU);
+ DEFINE_DMI_ATTR_WITH_SHOW(product_family,	0444, DMI_PRODUCT_FAMILY);
+ DEFINE_DMI_ATTR_WITH_SHOW(board_vendor,		0444, DMI_BOARD_VENDOR);
+ DEFINE_DMI_ATTR_WITH_SHOW(board_name,		0444, DMI_BOARD_NAME);
+@@ -193,6 +194,7 @@ static void __init dmi_id_init_attr_tabl
+ 	ADD_DMI_ATTR(product_serial,    DMI_PRODUCT_SERIAL);
+ 	ADD_DMI_ATTR(product_uuid,      DMI_PRODUCT_UUID);
+ 	ADD_DMI_ATTR(product_family,    DMI_PRODUCT_FAMILY);
++	ADD_DMI_ATTR(product_sku,       DMI_PRODUCT_SKU);
+ 	ADD_DMI_ATTR(board_vendor,      DMI_BOARD_VENDOR);
+ 	ADD_DMI_ATTR(board_name,        DMI_BOARD_NAME);
+ 	ADD_DMI_ATTR(board_version,     DMI_BOARD_VERSION);
+--- a/drivers/firmware/dmi_scan.c
++++ b/drivers/firmware/dmi_scan.c
+@@ -435,6 +435,7 @@ static void __init dmi_decode(const stru
+ 		dmi_save_ident(dm, DMI_PRODUCT_VERSION, 6);
+ 		dmi_save_ident(dm, DMI_PRODUCT_SERIAL, 7);
+ 		dmi_save_uuid(dm, DMI_PRODUCT_UUID, 8);
++		dmi_save_ident(dm, DMI_PRODUCT_SKU, 25);
+ 		dmi_save_ident(dm, DMI_PRODUCT_FAMILY, 26);
+ 		break;
+ 	case 2:		/* Base Board Information */
+--- a/include/linux/mod_devicetable.h
++++ b/include/linux/mod_devicetable.h
+@@ -471,6 +471,7 @@ enum dmi_field {
+ 	DMI_PRODUCT_VERSION,
+ 	DMI_PRODUCT_SERIAL,
+ 	DMI_PRODUCT_UUID,
++	DMI_PRODUCT_SKU,
+ 	DMI_PRODUCT_FAMILY,
+ 	DMI_BOARD_VENDOR,
+ 	DMI_BOARD_NAME,
--- a/target/linux/generic/backport-4.14/950-tty-serial-exar-generalize-rs485-setup.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/backport-4.14/950-tty-serial-exar-generalize-rs485-setup.patch	2022-03-22 12:15:54.056429438 +0800
@@ -0,0 +1,75 @@
+From 9d9398944488cd3a3e1e0912b26fbc4d5921e547 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Mon, 4 Jun 2018 23:33:07 +0200
+Subject: [PATCH] tty: serial: exar: generalize RS485 setup
+
+Move the non-board-specific part of the RS485 initialization from
+iot2040_rs485_config function to a new generic function used also for
+other boards.
+This allows using TIOCGRS485 and TIOCSRS485 on boards (such as mPCIe
+serial IO modules) which are hard-wired to RS485 or have jumpers for
+their configurations.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Reviewed-by: Jan Kiszka <jan.kiszka@siemens.com>
+Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+---
+ drivers/tty/serial/8250/8250_exar.c | 38 +++++++++++++++++++----------
+ 1 file changed, 25 insertions(+), 13 deletions(-)
+
+--- a/drivers/tty/serial/8250/8250_exar.c
++++ b/drivers/tty/serial/8250/8250_exar.c
+@@ -293,8 +293,32 @@ static int xr17v35x_register_gpio(struct
+ 	return 0;
+ }
+ 
++static int generic_rs485_config(struct uart_port *port,
++				struct serial_rs485 *rs485)
++{
++	bool is_rs485 = !!(rs485->flags & SER_RS485_ENABLED);
++	u8 __iomem *p = port->membase;
++	u8 value;
++
++	value = readb(p + UART_EXAR_FCTR);
++	if (is_rs485)
++		value |= UART_FCTR_EXAR_485;
++	else
++		value &= ~UART_FCTR_EXAR_485;
++
++	writeb(value, p + UART_EXAR_FCTR);
++
++	if (is_rs485)
++		writeb(UART_EXAR_RS485_DLY(4), p + UART_MSR);
++
++	port->rs485 = *rs485;
++
++	return 0;
++}
++
+ static const struct exar8250_platform exar8250_default_platform = {
+ 	.register_gpio = xr17v35x_register_gpio,
++	.rs485_config = generic_rs485_config,
+ };
+ 
+ static int iot2040_rs485_config(struct uart_port *port,
+@@ -327,19 +351,7 @@ static int iot2040_rs485_config(struct u
+ 	value |= mode;
+ 	writeb(value, p + UART_EXAR_MPIOLVL_7_0);
+ 
+-	value = readb(p + UART_EXAR_FCTR);
+-	if (is_rs485)
+-		value |= UART_FCTR_EXAR_485;
+-	else
+-		value &= ~UART_FCTR_EXAR_485;
+-	writeb(value, p + UART_EXAR_FCTR);
+-
+-	if (is_rs485)
+-		writeb(UART_EXAR_RS485_DLY(4), p + UART_MSR);
+-
+-	port->rs485 = *rs485;
+-
+-	return 0;
++	return generic_rs485_config(port, rs485);
+ }
+ 
+ static const struct property_entry iot2040_gpio_properties[] = {
--- a/target/linux/generic/backport-4.19/010-Kbuild-don-t-hardcode-path-to-awk-in-scripts-ld-vers.patch	2022-03-22 08:54:47.065464433 +0800
+++ b/target/linux/generic/backport-4.19/010-Kbuild-don-t-hardcode-path-to-awk-in-scripts-ld-vers.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,30 +0,0 @@
-From 13b1ecc3401653a355798eb1dee10cc1608202f4 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Mon, 18 Jan 2016 12:27:49 +0100
-Subject: [PATCH 33/34] Kbuild: don't hardcode path to awk in
- scripts/ld-version.sh
-
-On some systems /usr/bin/awk does not exist, or is broken. Find it via
-$PATH instead.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- scripts/ld-version.sh | 4 +++-
- 1 file changed, 3 insertions(+), 1 deletion(-)
-
---- a/scripts/ld-version.sh
-+++ b/scripts/ld-version.sh
-@@ -1,6 +1,7 @@
--#!/usr/bin/awk -f
-+#!/bin/sh
- # SPDX-License-Identifier: GPL-2.0
- # extract linker version number from stdin and turn into single number
-+exec awk '
- 	{
- 	gsub(".*\\)", "");
- 	gsub(".*version ", "");
-@@ -9,3 +10,4 @@
- 	print a[1]*100000000 + a[2]*1000000 + a[3]*10000;
- 	exit
- 	}
-+'
--- a/target/linux/generic/backport-4.19/011-kbuild-export-SUBARCH.patch	2022-03-22 08:54:47.066464434 +0800
+++ b/target/linux/generic/backport-4.19/011-kbuild-export-SUBARCH.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,23 +0,0 @@
-From 173019b66dcc9d68ad9333aa744dad1e369b5aa8 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sun, 9 Jul 2017 00:26:53 +0200
-Subject: [PATCH 34/34] kernel: add compile fix for linux 4.9 on x86
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- Makefile | 4 ++--
- 1 file changed, 2 insertions(+), 2 deletions(-)
-
---- a/Makefile
-+++ b/Makefile
-@@ -432,8 +432,8 @@ KBUILD_LDFLAGS :=
- GCC_PLUGINS_CFLAGS :=
- CLANG_FLAGS :=
- 
--export ARCH SRCARCH CONFIG_SHELL HOSTCC KBUILD_HOSTCFLAGS CROSS_COMPILE AS LD CC
--export CPP AR NM STRIP OBJCOPY OBJDUMP KBUILD_HOSTLDFLAGS KBUILD_HOSTLDLIBS
-+export ARCH SRCARCH SUBARCH CONFIG_SHELL HOSTCC KBUILD_HOSTCFLAGS CROSS_COMPILE AS LD
-+export CC CPP AR NM STRIP OBJCOPY OBJDUMP KBUILD_HOSTLDFLAGS KBUILD_HOSTLDLIBS
- export MAKE LEX YACC AWK GENKSYMS INSTALLKERNEL PERL PYTHON PYTHON2 PYTHON3 UTS_MACHINE
- export HOSTCXX KBUILD_HOSTCXXFLAGS LDFLAGS_MODULE CHECK CHECKFLAGS
- 
--- a/target/linux/generic/backport-4.19/020-backport_netfilter_rtcache.patch	2022-03-22 08:54:47.066464434 +0800
+++ b/target/linux/generic/backport-4.19/020-backport_netfilter_rtcache.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,558 +0,0 @@
-From 1bb0c3ec899827cfa4668bb63a08713a40744d21 Mon Sep 17 00:00:00 2001
-From: Florian Westphal <fw@strlen.de>
-Date: Sun, 9 Jul 2017 08:58:30 +0200
-Subject: [PATCH] netfilter: conntrack: cache route for forwarded connections
-
-... to avoid per-packet FIB lookup if possible.
-
-The cached dst is re-used provided the input interface
-is the same as that of the previous packet in the same direction.
-
-If not, the cached dst is invalidated.
-
-For ipv6 we also need to store sernum, else dst_check doesn't work,
-pointed out by Eric Dumazet.
-
-This should speed up forwarding when conntrack is already in use
-anyway, especially when using reverse path filtering -- active RPF
-enforces two FIB lookups for each packet.
-
-Before the routing cache removal this didn't matter since RPF was performed
-only when route cache didn't yield a result; but without route cache it
-comes at higher price.
-
-Julian Anastasov suggested to add NETDEV_UNREGISTER handler to
-avoid holding on to dsts of 'frozen' conntracks.
-
-Signed-off-by: Florian Westphal <fw@strlen.de>
----
- include/net/netfilter/nf_conntrack_extend.h  |   4 +
- include/net/netfilter/nf_conntrack_rtcache.h |  34 +++
- net/netfilter/Kconfig                        |  12 +
- net/netfilter/Makefile                       |   3 +
- net/netfilter/nf_conntrack_rtcache.c         | 428 +++++++++++++++++++++++++++
- 5 files changed, 481 insertions(+)
- create mode 100644 include/net/netfilter/nf_conntrack_rtcache.h
- create mode 100644 net/netfilter/nf_conntrack_rtcache.c
-
---- a/include/net/netfilter/nf_conntrack_extend.h
-+++ b/include/net/netfilter/nf_conntrack_extend.h
-@@ -28,6 +28,9 @@ enum nf_ct_ext_id {
- #if IS_ENABLED(CONFIG_NETFILTER_SYNPROXY)
- 	NF_CT_EXT_SYNPROXY,
- #endif
-+#if IS_ENABLED(CONFIG_NF_CONNTRACK_RTCACHE)
-+	NF_CT_EXT_RTCACHE,
-+#endif
- 	NF_CT_EXT_NUM,
- };
- 
-@@ -40,6 +43,7 @@ enum nf_ct_ext_id {
- #define NF_CT_EXT_TIMEOUT_TYPE struct nf_conn_timeout
- #define NF_CT_EXT_LABELS_TYPE struct nf_conn_labels
- #define NF_CT_EXT_SYNPROXY_TYPE struct nf_conn_synproxy
-+#define NF_CT_EXT_RTCACHE_TYPE struct nf_conn_rtcache
- 
- /* Extensions: optional stuff which isn't permanently in struct. */
- struct nf_ct_ext {
---- /dev/null
-+++ b/include/net/netfilter/nf_conntrack_rtcache.h
-@@ -0,0 +1,34 @@
-+#include <linux/gfp.h>
-+#include <net/netfilter/nf_conntrack.h>
-+#include <net/netfilter/nf_conntrack_extend.h>
-+
-+struct dst_entry;
-+
-+struct nf_conn_dst_cache {
-+	struct dst_entry *dst;
-+	int iif;
-+#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
-+	u32 cookie;
-+#endif
-+
-+};
-+
-+struct nf_conn_rtcache {
-+	struct nf_conn_dst_cache cached_dst[IP_CT_DIR_MAX];
-+};
-+
-+static inline
-+struct nf_conn_rtcache *nf_ct_rtcache_find(const struct nf_conn *ct)
-+{
-+#if IS_ENABLED(CONFIG_NF_CONNTRACK_RTCACHE)
-+	return nf_ct_ext_find(ct, NF_CT_EXT_RTCACHE);
-+#else
-+	return NULL;
-+#endif
-+}
-+
-+static inline int nf_conn_rtcache_iif_get(const struct nf_conn_rtcache *rtc,
-+					  enum ip_conntrack_dir dir)
-+{
-+	return rtc->cached_dst[dir].iif;
-+}
---- a/net/netfilter/Kconfig
-+++ b/net/netfilter/Kconfig
-@@ -135,6 +135,18 @@ config NF_CONNTRACK_EVENTS
- 
- 	  If unsure, say `N'.
- 
-+config NF_CONNTRACK_RTCACHE
-+	tristate "Cache route entries in conntrack objects"
-+	depends on NETFILTER_ADVANCED
-+	depends on NF_CONNTRACK
-+	help
-+	  If this option is enabled, the connection tracking code will
-+	  cache routing information for each connection that is being
-+	  forwarded, at a cost of 32 bytes per conntrack object.
-+
-+	  To compile it as a module, choose M here.  If unsure, say N.
-+	  The module will be called nf_conntrack_rtcache.
-+
- config NF_CONNTRACK_TIMEOUT
- 	bool  'Connection tracking timeout'
- 	depends on NETFILTER_ADVANCED
---- a/net/netfilter/Makefile
-+++ b/net/netfilter/Makefile
-@@ -25,6 +25,9 @@ obj-$(CONFIG_NETFILTER_NETLINK_OSF) += n
- # connection tracking
- obj-$(CONFIG_NF_CONNTRACK) += nf_conntrack.o
- 
-+# optional conntrack route cache extension
-+obj-$(CONFIG_NF_CONNTRACK_RTCACHE) += nf_conntrack_rtcache.o
-+
- obj-$(CONFIG_NF_CT_PROTO_GRE) += nf_conntrack_proto_gre.o
- 
- # netlink interface for nf_conntrack
---- /dev/null
-+++ b/net/netfilter/nf_conntrack_rtcache.c
-@@ -0,0 +1,428 @@
-+/* route cache for netfilter.
-+ *
-+ * (C) 2014 Red Hat GmbH
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License version 2 as
-+ * published by the Free Software Foundation.
-+ */
-+
-+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-+
-+#include <linux/types.h>
-+#include <linux/netfilter.h>
-+#include <linux/skbuff.h>
-+#include <linux/stddef.h>
-+#include <linux/kernel.h>
-+#include <linux/netdevice.h>
-+#include <linux/export.h>
-+#include <linux/module.h>
-+
-+#include <net/dst.h>
-+
-+#include <net/netfilter/nf_conntrack.h>
-+#include <net/netfilter/nf_conntrack_core.h>
-+#include <net/netfilter/nf_conntrack_extend.h>
-+#include <net/netfilter/nf_conntrack_rtcache.h>
-+
-+#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
-+#include <net/ip6_fib.h>
-+#endif
-+
-+static void __nf_conn_rtcache_destroy(struct nf_conn_rtcache *rtc,
-+				      enum ip_conntrack_dir dir)
-+{
-+	struct dst_entry *dst = rtc->cached_dst[dir].dst;
-+
-+	dst_release(dst);
-+}
-+
-+static void nf_conn_rtcache_destroy(struct nf_conn *ct)
-+{
-+	struct nf_conn_rtcache *rtc = nf_ct_rtcache_find(ct);
-+
-+	if (!rtc)
-+		return;
-+
-+	__nf_conn_rtcache_destroy(rtc, IP_CT_DIR_ORIGINAL);
-+	__nf_conn_rtcache_destroy(rtc, IP_CT_DIR_REPLY);
-+}
-+
-+static void nf_ct_rtcache_ext_add(struct nf_conn *ct)
-+{
-+	struct nf_conn_rtcache *rtc;
-+
-+	rtc = nf_ct_ext_add(ct, NF_CT_EXT_RTCACHE, GFP_ATOMIC);
-+	if (rtc) {
-+		rtc->cached_dst[IP_CT_DIR_ORIGINAL].iif = -1;
-+		rtc->cached_dst[IP_CT_DIR_ORIGINAL].dst = NULL;
-+		rtc->cached_dst[IP_CT_DIR_REPLY].iif = -1;
-+		rtc->cached_dst[IP_CT_DIR_REPLY].dst = NULL;
-+	}
-+}
-+
-+static struct nf_conn_rtcache *nf_ct_rtcache_find_usable(struct nf_conn *ct)
-+{
-+	return nf_ct_rtcache_find(ct);
-+}
-+
-+static struct dst_entry *
-+nf_conn_rtcache_dst_get(const struct nf_conn_rtcache *rtc,
-+			enum ip_conntrack_dir dir)
-+{
-+	return rtc->cached_dst[dir].dst;
-+}
-+
-+static u32 nf_rtcache_get_cookie(int pf, const struct dst_entry *dst)
-+{
-+#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
-+	if (pf == NFPROTO_IPV6) {
-+		const struct rt6_info *rt = (const struct rt6_info *)dst;
-+
-+		if (rt->from && rt->from->fib6_node)
-+			return (u32)rt->from->fib6_node->fn_sernum;
-+	}
-+#endif
-+	return 0;
-+}
-+
-+static void nf_conn_rtcache_dst_set(int pf,
-+				    struct nf_conn_rtcache *rtc,
-+				    struct dst_entry *dst,
-+				    enum ip_conntrack_dir dir, int iif)
-+{
-+	if (rtc->cached_dst[dir].iif != iif)
-+		rtc->cached_dst[dir].iif = iif;
-+
-+	if (rtc->cached_dst[dir].dst != dst) {
-+		struct dst_entry *old;
-+
-+		dst_hold(dst);
-+
-+		old = xchg(&rtc->cached_dst[dir].dst, dst);
-+		dst_release(old);
-+
-+#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
-+		if (pf == NFPROTO_IPV6)
-+			rtc->cached_dst[dir].cookie =
-+				nf_rtcache_get_cookie(pf, dst);
-+#endif
-+	}
-+}
-+
-+static void nf_conn_rtcache_dst_obsolete(struct nf_conn_rtcache *rtc,
-+					 enum ip_conntrack_dir dir)
-+{
-+	struct dst_entry *old;
-+
-+	pr_debug("Invalidate iif %d for dir %d on cache %p\n",
-+		 rtc->cached_dst[dir].iif, dir, rtc);
-+
-+	old = xchg(&rtc->cached_dst[dir].dst, NULL);
-+	dst_release(old);
-+	rtc->cached_dst[dir].iif = -1;
-+}
-+
-+static unsigned int nf_rtcache_in(u_int8_t pf,
-+				  struct sk_buff *skb,
-+				  const struct nf_hook_state *state)
-+{
-+	struct nf_conn_rtcache *rtc;
-+	enum ip_conntrack_info ctinfo;
-+	enum ip_conntrack_dir dir;
-+	struct dst_entry *dst;
-+	struct nf_conn *ct;
-+	int iif;
-+	u32 cookie;
-+
-+	if (skb_dst(skb) || skb->sk)
-+		return NF_ACCEPT;
-+
-+	ct = nf_ct_get(skb, &ctinfo);
-+	if (!ct)
-+		return NF_ACCEPT;
-+
-+	rtc = nf_ct_rtcache_find_usable(ct);
-+	if (!rtc)
-+		return NF_ACCEPT;
-+
-+	/* if iif changes, don't use cache and let ip stack
-+	 * do route lookup.
-+	 *
-+	 * If rp_filter is enabled it might toss skb, so
-+	 * we don't want to avoid these checks.
-+	 */
-+	dir = CTINFO2DIR(ctinfo);
-+	iif = nf_conn_rtcache_iif_get(rtc, dir);
-+	if (state->in->ifindex != iif) {
-+		pr_debug("ct %p, iif %d, cached iif %d, skip cached entry\n",
-+			 ct, iif, state->in->ifindex);
-+		return NF_ACCEPT;
-+	}
-+	dst = nf_conn_rtcache_dst_get(rtc, dir);
-+	if (dst == NULL)
-+		return NF_ACCEPT;
-+
-+	cookie = nf_rtcache_get_cookie(pf, dst);
-+
-+	dst = dst_check(dst, cookie);
-+	pr_debug("obtained dst %p for skb %p, cookie %d\n", dst, skb, cookie);
-+	if (likely(dst))
-+		skb_dst_set_noref(skb, dst);
-+	else
-+		nf_conn_rtcache_dst_obsolete(rtc, dir);
-+
-+	return NF_ACCEPT;
-+}
-+
-+static unsigned int nf_rtcache_forward(u_int8_t pf,
-+				       struct sk_buff *skb,
-+				       const struct nf_hook_state *state)
-+{
-+	struct nf_conn_rtcache *rtc;
-+	enum ip_conntrack_info ctinfo;
-+	enum ip_conntrack_dir dir;
-+	struct nf_conn *ct;
-+	struct dst_entry *dst = skb_dst(skb);
-+	int iif;
-+
-+	ct = nf_ct_get(skb, &ctinfo);
-+	if (!ct)
-+		return NF_ACCEPT;
-+
-+	if (dst && dst_xfrm(dst))
-+		return NF_ACCEPT;
-+
-+	if (!nf_ct_is_confirmed(ct)) {
-+		if (WARN_ON(nf_ct_rtcache_find(ct)))
-+			return NF_ACCEPT;
-+		nf_ct_rtcache_ext_add(ct);
-+		return NF_ACCEPT;
-+	}
-+
-+	rtc = nf_ct_rtcache_find_usable(ct);
-+	if (!rtc)
-+		return NF_ACCEPT;
-+
-+	dir = CTINFO2DIR(ctinfo);
-+	iif = nf_conn_rtcache_iif_get(rtc, dir);
-+	pr_debug("ct %p, skb %p, dir %d, iif %d, cached iif %d\n",
-+		 ct, skb, dir, iif, state->in->ifindex);
-+	if (likely(state->in->ifindex == iif))
-+		return NF_ACCEPT;
-+
-+	nf_conn_rtcache_dst_set(pf, rtc, skb_dst(skb), dir, state->in->ifindex);
-+	return NF_ACCEPT;
-+}
-+
-+static unsigned int nf_rtcache_in4(void *priv,
-+				  struct sk_buff *skb,
-+				  const struct nf_hook_state *state)
-+{
-+	return nf_rtcache_in(NFPROTO_IPV4, skb, state);
-+}
-+
-+static unsigned int nf_rtcache_forward4(void *priv,
-+				       struct sk_buff *skb,
-+				       const struct nf_hook_state *state)
-+{
-+	return nf_rtcache_forward(NFPROTO_IPV4, skb, state);
-+}
-+
-+#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
-+static unsigned int nf_rtcache_in6(void *priv,
-+				  struct sk_buff *skb,
-+				  const struct nf_hook_state *state)
-+{
-+	return nf_rtcache_in(NFPROTO_IPV6, skb, state);
-+}
-+
-+static unsigned int nf_rtcache_forward6(void *priv,
-+				       struct sk_buff *skb,
-+				       const struct nf_hook_state *state)
-+{
-+ 	return nf_rtcache_forward(NFPROTO_IPV6, skb, state);
-+}
-+#endif
-+
-+static int nf_rtcache_dst_remove(struct nf_conn *ct, void *data)
-+{
-+	struct nf_conn_rtcache *rtc = nf_ct_rtcache_find(ct);
-+	struct net_device *dev = data;
-+
-+	if (!rtc)
-+		return 0;
-+
-+	if (dev->ifindex == rtc->cached_dst[IP_CT_DIR_ORIGINAL].iif ||
-+	    dev->ifindex == rtc->cached_dst[IP_CT_DIR_REPLY].iif) {
-+		nf_conn_rtcache_dst_obsolete(rtc, IP_CT_DIR_ORIGINAL);
-+		nf_conn_rtcache_dst_obsolete(rtc, IP_CT_DIR_REPLY);
-+	}
-+
-+	return 0;
-+}
-+
-+static int nf_rtcache_netdev_event(struct notifier_block *this,
-+				   unsigned long event, void *ptr)
-+{
-+	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
-+	struct net *net = dev_net(dev);
-+
-+	if (event == NETDEV_DOWN)
-+		nf_ct_iterate_cleanup_net(net, nf_rtcache_dst_remove, dev, 0, 0);
-+
-+	return NOTIFY_DONE;
-+}
-+
-+static struct notifier_block nf_rtcache_notifier = {
-+	.notifier_call = nf_rtcache_netdev_event,
-+};
-+
-+static struct nf_hook_ops rtcache_ops[] = {
-+	{
-+		.hook		= nf_rtcache_in4,
-+		.pf		= NFPROTO_IPV4,
-+		.hooknum	= NF_INET_PRE_ROUTING,
-+		.priority       = NF_IP_PRI_LAST,
-+	},
-+	{
-+		.hook           = nf_rtcache_forward4,
-+		.pf             = NFPROTO_IPV4,
-+		.hooknum        = NF_INET_FORWARD,
-+		.priority       = NF_IP_PRI_LAST,
-+	},
-+#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
-+	{
-+		.hook		= nf_rtcache_in6,
-+		.pf		= NFPROTO_IPV6,
-+		.hooknum	= NF_INET_PRE_ROUTING,
-+		.priority       = NF_IP_PRI_LAST,
-+	},
-+	{
-+		.hook           = nf_rtcache_forward6,
-+		.pf             = NFPROTO_IPV6,
-+		.hooknum        = NF_INET_FORWARD,
-+		.priority       = NF_IP_PRI_LAST,
-+	},
-+#endif
-+};
-+
-+static struct nf_ct_ext_type rtcache_extend __read_mostly = {
-+	.len	= sizeof(struct nf_conn_rtcache),
-+	.align	= __alignof__(struct nf_conn_rtcache),
-+	.id	= NF_CT_EXT_RTCACHE,
-+	.destroy = nf_conn_rtcache_destroy,
-+};
-+
-+static int __net_init rtcache_net_init(struct net *net)
-+{
-+	return nf_register_net_hooks(net, rtcache_ops, ARRAY_SIZE(rtcache_ops));
-+}
-+
-+static void __net_exit rtcache_net_exit(struct net *net)
-+{
-+	/* remove hooks so no new connections get rtcache extension */
-+	nf_unregister_net_hooks(net, rtcache_ops, ARRAY_SIZE(rtcache_ops));
-+}
-+
-+static struct pernet_operations rtcache_ops_net_ops = {
-+	.init	= rtcache_net_init,
-+	.exit	= rtcache_net_exit,
-+};
-+
-+static int __init nf_conntrack_rtcache_init(void)
-+{
-+	int ret = nf_ct_extend_register(&rtcache_extend);
-+
-+	if (ret < 0) {
-+		pr_err("nf_conntrack_rtcache: Unable to register extension\n");
-+		return ret;
-+	}
-+
-+	ret = register_pernet_subsys(&rtcache_ops_net_ops);
-+	if (ret) {
-+		nf_ct_extend_unregister(&rtcache_extend);
-+		return ret;
-+	}
-+
-+	ret = register_netdevice_notifier(&nf_rtcache_notifier);
-+	if (ret) {
-+		nf_ct_extend_unregister(&rtcache_extend);
-+		unregister_pernet_subsys(&rtcache_ops_net_ops);
-+	}
-+
-+	return ret;
-+}
-+
-+static int nf_rtcache_ext_remove(struct nf_conn *ct, void *data)
-+{
-+	struct nf_conn_rtcache *rtc = nf_ct_rtcache_find(ct);
-+
-+	return rtc != NULL;
-+}
-+
-+static bool __exit nf_conntrack_rtcache_wait_for_dying(struct net *net)
-+{
-+	bool wait = false;
-+	int cpu;
-+
-+	for_each_possible_cpu(cpu) {
-+		struct nf_conntrack_tuple_hash *h;
-+		struct hlist_nulls_node *n;
-+		struct nf_conn *ct;
-+		struct ct_pcpu *pcpu = per_cpu_ptr(net->ct.pcpu_lists, cpu);
-+
-+		rcu_read_lock();
-+		spin_lock_bh(&pcpu->lock);
-+
-+		hlist_nulls_for_each_entry(h, n, &pcpu->dying, hnnode) {
-+			ct = nf_ct_tuplehash_to_ctrack(h);
-+			if (nf_ct_rtcache_find(ct) != NULL) {
-+				wait = true;
-+				break;
-+			}
-+		}
-+		spin_unlock_bh(&pcpu->lock);
-+		rcu_read_unlock();
-+	}
-+
-+	return wait;
-+}
-+
-+static void __exit nf_conntrack_rtcache_fini(void)
-+{
-+	struct net *net;
-+	int count = 0;
-+
-+	synchronize_net();
-+
-+	unregister_netdevice_notifier(&nf_rtcache_notifier);
-+	unregister_pernet_subsys(&rtcache_ops_net_ops);
-+
-+	synchronize_net();
-+
-+	rtnl_lock();
-+
-+	/* zap all conntracks with rtcache extension */
-+	for_each_net(net)
-+		nf_ct_iterate_cleanup_net(net, nf_rtcache_ext_remove, NULL, 0, 0);
-+
-+	for_each_net(net) {
-+		/* .. and make sure they're gone from dying list, too */
-+		while (nf_conntrack_rtcache_wait_for_dying(net)) {
-+			msleep(200);
-+			WARN_ONCE(++count > 25, "Waiting for all rtcache conntracks to go away\n");
-+		}
-+	}
-+
-+	rtnl_unlock();
-+
-+	synchronize_net();
-+	nf_ct_extend_unregister(&rtcache_extend);
-+}
-+module_init(nf_conntrack_rtcache_init);
-+module_exit(nf_conntrack_rtcache_fini);
-+
-+MODULE_LICENSE("GPL");
-+MODULE_AUTHOR("Florian Westphal <fw@strlen.de>");
-+MODULE_DESCRIPTION("Conntrack route cache extension");
--- a/target/linux/generic/backport-4.19/047-v4.21-mtd-keep-original-flags-for-every-struct-mtd_info.patch	2022-03-22 08:54:47.067464436 +0800
+++ b/target/linux/generic/backport-4.19/047-v4.21-mtd-keep-original-flags-for-every-struct-mtd_info.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,58 +0,0 @@
-From 1186af457cc186c5ed01708da71b1ffbdf0a2638 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Tue, 20 Nov 2018 09:55:45 +0100
-Subject: [PATCH] mtd: keep original flags for every struct mtd_info
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-When allocating a new partition mtd subsystem runs internal tests in the
-allocate_partition(). They may result in modifying specified flags (e.g.
-dropping some /features/ like write access).
-
-Those constraints don't have to be necessary true for subpartitions. It
-may happen parent partition isn't block aligned (effectively disabling
-write access) while subpartition may fit blocks nicely. In such case all
-checks should be run again (starting with original flags value).
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
----
- drivers/mtd/mtdcore.c   | 2 ++
- drivers/mtd/mtdpart.c   | 3 ++-
- include/linux/mtd/mtd.h | 1 +
- 3 files changed, 5 insertions(+), 1 deletion(-)
-
---- a/drivers/mtd/mtdcore.c
-+++ b/drivers/mtd/mtdcore.c
-@@ -665,6 +665,8 @@ static void mtd_set_dev_defaults(struct
- 	} else {
- 		pr_debug("mtd device won't show a device symlink in sysfs\n");
- 	}
-+
-+	mtd->orig_flags = mtd->flags;
- }
- 
- /**
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -346,7 +346,8 @@ static struct mtd_part *allocate_partiti
- 
- 	/* set up the MTD object for this partition */
- 	slave->mtd.type = parent->type;
--	slave->mtd.flags = parent->flags & ~part->mask_flags;
-+	slave->mtd.flags = parent->orig_flags & ~part->mask_flags;
-+	slave->mtd.orig_flags = slave->mtd.flags;
- 	slave->mtd.size = part->size;
- 	slave->mtd.writesize = parent->writesize;
- 	slave->mtd.writebufsize = parent->writebufsize;
---- a/include/linux/mtd/mtd.h
-+++ b/include/linux/mtd/mtd.h
-@@ -207,6 +207,7 @@ struct mtd_debug_info {
- struct mtd_info {
- 	u_char type;
- 	uint32_t flags;
-+	uint32_t orig_flags; /* Flags as before running mtd checks */
- 	uint64_t size;	 // Total size of the MTD
- 
- 	/* "Major" erase size for the device. Nave users may take this
--- a/target/linux/generic/backport-4.19/048-v4.21-mtd-improve-calculating-partition-boundaries-when-ch.patch	2022-03-22 08:54:47.067464436 +0800
+++ b/target/linux/generic/backport-4.19/048-v4.21-mtd-improve-calculating-partition-boundaries-when-ch.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,55 +0,0 @@
-From 6750f61a13a0197c40e4a40739117493b15f19e8 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Tue, 20 Nov 2018 10:24:09 +0100
-Subject: [PATCH] mtd: improve calculating partition boundaries when checking
- for alignment
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-When checking for alignment mtd should check absolute offsets. It's
-important for subpartitions as it doesn't make sense to check their
-relative addresses.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
----
- drivers/mtd/mtdpart.c | 13 +++++++++++--
- 1 file changed, 11 insertions(+), 2 deletions(-)
-
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -61,6 +61,15 @@ static inline struct mtd_part *mtd_to_pa
- 	return container_of(mtd, struct mtd_part, mtd);
- }
- 
-+static u64 part_absolute_offset(struct mtd_info *mtd)
-+{
-+	struct mtd_part *part = mtd_to_part(mtd);
-+
-+	if (!mtd_is_partition(mtd))
-+		return 0;
-+
-+	return part_absolute_offset(part->parent) + part->offset;
-+}
- 
- /*
-  * MTD methods which simply translate the effective address and pass through
-@@ -518,7 +527,7 @@ static struct mtd_part *allocate_partiti
- 	if (!(slave->mtd.flags & MTD_NO_ERASE))
- 		wr_alignment = slave->mtd.erasesize;
- 
--	tmp = slave->offset;
-+	tmp = part_absolute_offset(parent) + slave->offset;
- 	remainder = do_div(tmp, wr_alignment);
- 	if ((slave->mtd.flags & MTD_WRITEABLE) && remainder) {
- 		/* Doesn't start on a boundary of major erase size */
-@@ -529,7 +538,7 @@ static struct mtd_part *allocate_partiti
- 			part->name);
- 	}
- 
--	tmp = slave->mtd.size;
-+	tmp = part_absolute_offset(parent) + slave->mtd.size;
- 	remainder = do_div(tmp, wr_alignment);
- 	if ((slave->mtd.flags & MTD_WRITEABLE) && remainder) {
- 		slave->mtd.flags &= ~MTD_WRITEABLE;
--- a/target/linux/generic/backport-4.19/080-v5.1-0001-bcma-keep-a-direct-pointer-to-the-struct-device.patch	2022-03-22 08:54:47.067464436 +0800
+++ b/target/linux/generic/backport-4.19/080-v5.1-0001-bcma-keep-a-direct-pointer-to-the-struct-device.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,199 +0,0 @@
-From 5a1c18b761ddb299a06746948b9ec2814b04fa92 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Wed, 2 Jan 2019 00:00:01 +0100
-Subject: [PATCH] bcma: keep a direct pointer to the struct device
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Accessing struct device is pretty useful/common so having a direct
-pointer:
-1) Simplifies some code
-2) Makes bcma_bus_get_host_dev() unneeded
-3) Allows further improvements like using dev_* printing helpers
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
- drivers/bcma/bcma_private.h |  1 -
- drivers/bcma/driver_gpio.c  |  2 +-
- drivers/bcma/host_pci.c     |  2 ++
- drivers/bcma/host_soc.c     |  4 ++--
- drivers/bcma/main.c         | 45 +++++++++----------------------------
- include/linux/bcma/bcma.h   | 11 +++------
- 6 files changed, 18 insertions(+), 47 deletions(-)
-
---- a/drivers/bcma/bcma_private.h
-+++ b/drivers/bcma/bcma_private.h
-@@ -33,7 +33,6 @@ int __init bcma_bus_early_register(struc
- int bcma_bus_suspend(struct bcma_bus *bus);
- int bcma_bus_resume(struct bcma_bus *bus);
- #endif
--struct device *bcma_bus_get_host_dev(struct bcma_bus *bus);
- 
- /* scan.c */
- void bcma_detect_chip(struct bcma_bus *bus);
---- a/drivers/bcma/driver_gpio.c
-+++ b/drivers/bcma/driver_gpio.c
-@@ -183,7 +183,7 @@ int bcma_gpio_init(struct bcma_drv_cc *c
- 	chip->direction_input	= bcma_gpio_direction_input;
- 	chip->direction_output	= bcma_gpio_direction_output;
- 	chip->owner		= THIS_MODULE;
--	chip->parent		= bcma_bus_get_host_dev(bus);
-+	chip->parent		= bus->dev;
- #if IS_BUILTIN(CONFIG_OF)
- 	chip->of_node		= cc->core->dev.of_node;
- #endif
---- a/drivers/bcma/host_pci.c
-+++ b/drivers/bcma/host_pci.c
-@@ -196,6 +196,8 @@ static int bcma_host_pci_probe(struct pc
- 		goto err_pci_release_regions;
- 	}
- 
-+	bus->dev = &dev->dev;
-+
- 	/* Map MMIO */
- 	err = -ENOMEM;
- 	bus->mmio = pci_iomap(dev, 0, ~0UL);
---- a/drivers/bcma/host_soc.c
-+++ b/drivers/bcma/host_soc.c
-@@ -179,7 +179,6 @@ int __init bcma_host_soc_register(struct
- 	/* Host specific */
- 	bus->hosttype = BCMA_HOSTTYPE_SOC;
- 	bus->ops = &bcma_host_soc_ops;
--	bus->host_pdev = NULL;
- 
- 	/* Initialize struct, detect chip */
- 	bcma_init_bus(bus);
-@@ -213,6 +212,8 @@ static int bcma_host_soc_probe(struct pl
- 	if (!bus)
- 		return -ENOMEM;
- 
-+	bus->dev = dev;
-+
- 	/* Map MMIO */
- 	bus->mmio = of_iomap(np, 0);
- 	if (!bus->mmio)
-@@ -221,7 +222,6 @@ static int bcma_host_soc_probe(struct pl
- 	/* Host specific */
- 	bus->hosttype = BCMA_HOSTTYPE_SOC;
- 	bus->ops = &bcma_host_soc_ops;
--	bus->host_pdev = pdev;
- 
- 	/* Initialize struct, detect chip */
- 	bcma_init_bus(bus);
---- a/drivers/bcma/main.c
-+++ b/drivers/bcma/main.c
-@@ -223,8 +223,8 @@ unsigned int bcma_core_irq(struct bcma_d
- 			mips_irq = bcma_core_mips_irq(core);
- 			return mips_irq <= 4 ? mips_irq + 2 : 0;
- 		}
--		if (bus->host_pdev)
--			return bcma_of_get_irq(&bus->host_pdev->dev, core, num);
-+		if (bus->dev)
-+			return bcma_of_get_irq(bus->dev, core, num);
- 		return 0;
- 	case BCMA_HOSTTYPE_SDIO:
- 		return 0;
-@@ -239,18 +239,18 @@ void bcma_prepare_core(struct bcma_bus *
- 	core->dev.release = bcma_release_core_dev;
- 	core->dev.bus = &bcma_bus_type;
- 	dev_set_name(&core->dev, "bcma%d:%d", bus->num, core->core_index);
--	core->dev.parent = bcma_bus_get_host_dev(bus);
--	if (core->dev.parent)
--		bcma_of_fill_device(core->dev.parent, core);
-+	core->dev.parent = bus->dev;
-+	if (bus->dev)
-+		bcma_of_fill_device(bus->dev, core);
- 
- 	switch (bus->hosttype) {
- 	case BCMA_HOSTTYPE_PCI:
--		core->dma_dev = &bus->host_pci->dev;
-+		core->dma_dev = bus->dev;
- 		core->irq = bus->host_pci->irq;
- 		break;
- 	case BCMA_HOSTTYPE_SOC:
--		if (IS_ENABLED(CONFIG_OF) && bus->host_pdev) {
--			core->dma_dev = &bus->host_pdev->dev;
-+		if (IS_ENABLED(CONFIG_OF) && bus->dev) {
-+			core->dma_dev = bus->dev;
- 		} else {
- 			core->dev.dma_mask = &core->dev.coherent_dma_mask;
- 			core->dma_dev = &core->dev;
-@@ -261,28 +261,6 @@ void bcma_prepare_core(struct bcma_bus *
- 	}
- }
- 
--struct device *bcma_bus_get_host_dev(struct bcma_bus *bus)
--{
--	switch (bus->hosttype) {
--	case BCMA_HOSTTYPE_PCI:
--		if (bus->host_pci)
--			return &bus->host_pci->dev;
--		else
--			return NULL;
--	case BCMA_HOSTTYPE_SOC:
--		if (bus->host_pdev)
--			return &bus->host_pdev->dev;
--		else
--			return NULL;
--	case BCMA_HOSTTYPE_SDIO:
--		if (bus->host_sdio)
--			return &bus->host_sdio->dev;
--		else
--			return NULL;
--	}
--	return NULL;
--}
--
- void bcma_init_bus(struct bcma_bus *bus)
- {
- 	mutex_lock(&bcma_buses_mutex);
-@@ -402,7 +380,6 @@ int bcma_bus_register(struct bcma_bus *b
- {
- 	int err;
- 	struct bcma_device *core;
--	struct device *dev;
- 
- 	/* Scan for devices (cores) */
- 	err = bcma_bus_scan(bus);
-@@ -425,10 +402,8 @@ int bcma_bus_register(struct bcma_bus *b
- 		bcma_core_pci_early_init(&bus->drv_pci[0]);
- 	}
- 
--	dev = bcma_bus_get_host_dev(bus);
--	if (dev) {
--		of_platform_default_populate(dev->of_node, NULL, dev);
--	}
-+	if (bus->dev)
-+		of_platform_default_populate(bus->dev->of_node, NULL, bus->dev);
- 
- 	/* Cores providing flash access go before SPROM init */
- 	list_for_each_entry(core, &bus->cores, list) {
---- a/include/linux/bcma/bcma.h
-+++ b/include/linux/bcma/bcma.h
-@@ -332,6 +332,8 @@ extern int bcma_arch_register_fallback_s
- 		struct ssb_sprom *out));
- 
- struct bcma_bus {
-+	struct device *dev;
-+
- 	/* The MMIO area. */
- 	void __iomem *mmio;
- 
-@@ -339,14 +341,7 @@ struct bcma_bus {
- 
- 	enum bcma_hosttype hosttype;
- 	bool host_is_pcie2; /* Used for BCMA_HOSTTYPE_PCI only */
--	union {
--		/* Pointer to the PCI bus (only for BCMA_HOSTTYPE_PCI) */
--		struct pci_dev *host_pci;
--		/* Pointer to the SDIO device (only for BCMA_HOSTTYPE_SDIO) */
--		struct sdio_func *host_sdio;
--		/* Pointer to platform device (only for BCMA_HOSTTYPE_SOC) */
--		struct platform_device *host_pdev;
--	};
-+	struct pci_dev *host_pci; /* PCI bus pointer (BCMA_HOSTTYPE_PCI only) */
- 
- 	struct bcma_chipinfo chipinfo;
- 
--- a/target/linux/generic/backport-4.19/080-v5.1-0002-bcma-use-dev_-printing-functions.patch	2022-03-22 08:54:47.068464438 +0800
+++ b/target/linux/generic/backport-4.19/080-v5.1-0002-bcma-use-dev_-printing-functions.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,36 +0,0 @@
-From 777bc4801a6868fcbff09ffb6e30f023e7c5ed38 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Wed, 2 Jan 2019 00:00:02 +0100
-Subject: [PATCH] bcma: use dev_* printing functions
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-It provides more meaningful messages.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
- drivers/bcma/bcma_private.h | 8 ++++----
- 1 file changed, 4 insertions(+), 4 deletions(-)
-
---- a/drivers/bcma/bcma_private.h
-+++ b/drivers/bcma/bcma_private.h
-@@ -10,13 +10,13 @@
- #include <linux/delay.h>
- 
- #define bcma_err(bus, fmt, ...) \
--	pr_err("bus%d: " fmt, (bus)->num, ##__VA_ARGS__)
-+	dev_err((bus)->dev, "bus%d: " fmt, (bus)->num, ##__VA_ARGS__)
- #define bcma_warn(bus, fmt, ...) \
--	pr_warn("bus%d: " fmt, (bus)->num, ##__VA_ARGS__)
-+	dev_warn((bus)->dev, "bus%d: " fmt, (bus)->num, ##__VA_ARGS__)
- #define bcma_info(bus, fmt, ...) \
--	pr_info("bus%d: " fmt, (bus)->num, ##__VA_ARGS__)
-+	dev_info((bus)->dev, "bus%d: " fmt, (bus)->num, ##__VA_ARGS__)
- #define bcma_debug(bus, fmt, ...) \
--	pr_debug("bus%d: " fmt, (bus)->num, ##__VA_ARGS__)
-+	dev_dbg((bus)->dev, "bus%d: " fmt, (bus)->num, ##__VA_ARGS__)
- 
- struct bcma_bus;
- 
--- a/target/linux/generic/backport-4.19/095-Allow-class-e-address-assignment-via-ifconfig-ioctl.patch	2022-03-22 08:54:47.068464438 +0800
+++ b/target/linux/generic/backport-4.19/095-Allow-class-e-address-assignment-via-ifconfig-ioctl.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,79 +0,0 @@
-From 46bf067870156abd61fe24d14c2486d15b8b502c Mon Sep 17 00:00:00 2001
-From: Dave Taht <dave@taht.net>
-Date: Fri, 14 Dec 2018 18:38:40 +0000
-Subject: [PATCH 1/1] Allow class-e address assignment in ifconfig and early
- boot
-
-While the linux kernel became mostly "class-e clean" a decade ago,
-and most distributions long ago switched to the iproute2 suite
-of utilities, which allow class-e (240.0.0.0/4) address assignment,
-distributions relying on busybox, toybox and other forms of
-ifconfig cannot assign class-e addresses without this kernel patch.
-
-With this patch, also, a boot command line on these addresses is feasible:
-(ip=248.0.1.2::248.0.1.1:255.255.255.0).
-
-While CIDR has been obsolete for 2 decades, and a survey of all the
-userspace open source code in the world shows most IN_whatever macros
-are also obsolete... rather than obsolete CIDR from this ioctl entirely,
-this patch merely enables class-e assignment, sanely.
-
-H/T to Vince Fuller and his original patch here:
-    https://lkml.org/lkml/2008/1/7/370
-
-Signed-off-by: Dave Taht <dave.taht@gmail.com>
-Reviewed-by: John Gilmore <gnu@toad.com>
----
- include/uapi/linux/in.h | 8 ++++++--
- net/ipv4/devinet.c      | 4 +++-
- net/ipv4/ipconfig.c     | 2 ++
- 3 files changed, 11 insertions(+), 3 deletions(-)
-
---- a/include/uapi/linux/in.h
-+++ b/include/uapi/linux/in.h
-@@ -268,8 +268,12 @@ struct sockaddr_in {
- #define	IN_MULTICAST(a)		IN_CLASSD(a)
- #define IN_MULTICAST_NET	0xF0000000
- 
--#define	IN_EXPERIMENTAL(a)	((((long int) (a)) & 0xf0000000) == 0xf0000000)
--#define	IN_BADCLASS(a)		IN_EXPERIMENTAL((a))
-+#define	IN_BADCLASS(a)		(((long int) (a) ) == (long int)0xffffffff)
-+#define	IN_EXPERIMENTAL(a)	IN_BADCLASS((a))
-+
-+#define	IN_CLASSE(a)		((((long int) (a)) & 0xf0000000) == 0xf0000000)
-+#define	IN_CLASSE_NET		0xffffffff
-+#define	IN_CLASSE_NSHIFT	0
- 
- /* Address to accept any incoming messages. */
- #define	INADDR_ANY		((unsigned long int) 0x00000000)
---- a/net/ipv4/devinet.c
-+++ b/net/ipv4/devinet.c
-@@ -949,7 +949,7 @@ static int inet_abc_len(__be32 addr)
- {
- 	int rc = -1;	/* Something else, probably a multicast. */
- 
--	if (ipv4_is_zeronet(addr))
-+	if (ipv4_is_zeronet(addr) || ipv4_is_lbcast(addr))
- 		rc = 0;
- 	else {
- 		__u32 haddr = ntohl(addr);
-@@ -960,6 +960,8 @@ static int inet_abc_len(__be32 addr)
- 			rc = 16;
- 		else if (IN_CLASSC(haddr))
- 			rc = 24;
-+		else if (IN_CLASSE(haddr))
-+			rc = 32;
- 	}
- 
- 	return rc;
---- a/net/ipv4/ipconfig.c
-+++ b/net/ipv4/ipconfig.c
-@@ -429,6 +429,8 @@ static int __init ic_defaults(void)
- 			ic_netmask = htonl(IN_CLASSB_NET);
- 		else if (IN_CLASSC(ntohl(ic_myaddr)))
- 			ic_netmask = htonl(IN_CLASSC_NET);
-+		else if (IN_CLASSE(ntohl(ic_myaddr)))
-+			ic_netmask = htonl(IN_CLASSE_NET);
- 		else {
- 			pr_err("IP-Config: Unable to guess netmask for address %pI4\n",
- 			       &ic_myaddr);
--- a/target/linux/generic/backport-4.19/101-arm-cns3xxx-use-actual-size-reads-for-PCIe.patch	2022-03-22 08:54:47.068464438 +0800
+++ b/target/linux/generic/backport-4.19/101-arm-cns3xxx-use-actual-size-reads-for-PCIe.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,46 +0,0 @@
-From 4cc30de79d293f1e8c5f50ae3a9c005def9564a0 Mon Sep 17 00:00:00 2001
-From: Koen Vandeputte <koen.vandeputte@ncentric.com>
-Date: Mon, 7 Jan 2019 14:14:27 +0100
-Subject: [PATCH 2/2] arm: cns3xxx: use actual size reads for PCIe
-
-commit 802b7c06adc7 ("ARM: cns3xxx: Convert PCI to use generic config accessors")
-reimplemented cns3xxx_pci_read_config() using pci_generic_config_read32(),
-which preserved the property of only doing 32-bit reads.
-
-It also replaced cns3xxx_pci_write_config() with pci_generic_config_write(),
-so it changed writes from always being 32 bits to being the actual size,
-which works just fine.
-
-Due to:
-- The documentation does not mention that only 32 bit access is allowed.
-- Writes are already executed using the actual size
-- Extensive testing shows that 8b, 16b and 32b reads work as intended
-
-It makes perfectly sense to also swap 32 bit reading in favor of actual size.
-
-Fixes: 802b7c06adc7 ("ARM: cns3xxx: Convert PCI to use generic config accessors")
-Suggested-by: Bjorn Helgaas <bhelgaas@google.com>
-Signed-off-by: Koen Vandeputte <koen.vandeputte@ncentric.com>
-CC: Arnd Bergmann <arnd@arndb.de>
-CC: Krzysztof Halasa <khalasa@piap.pl>
-CC: Olof Johansson <olof@lixom.net>
-CC: Robin Leblon <robin.leblon@ncentric.com>
-CC: Rob Herring <robh@kernel.org>
-CC: Russell King <linux@armlinux.org.uk>
-CC: Tim Harvey <tharvey@gateworks.com>
-CC: stable@vger.kernel.org # v4.0+
----
- arch/arm/mach-cns3xxx/pcie.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/arch/arm/mach-cns3xxx/pcie.c
-+++ b/arch/arm/mach-cns3xxx/pcie.c
-@@ -93,7 +93,7 @@ static int cns3xxx_pci_read_config(struc
- 	u32 mask = (0x1ull << (size * 8)) - 1;
- 	int shift = (where % 4) * 8;
- 
--	ret = pci_generic_config_read32(bus, devfn, where, size, val);
-+	ret = pci_generic_config_read(bus, devfn, where, size, val);
- 
- 	if (ret == PCIBIOS_SUCCESSFUL && !bus->number && !devfn &&
- 	    (where & 0xffc) == PCI_CLASS_REVISION)
--- a/target/linux/generic/backport-4.19/200-v5.2-usb-dwc2-Set-lpm-mode-parameters-depend-on-HW-configuration.patch	2022-03-22 08:54:47.069464439 +0800
+++ b/target/linux/generic/backport-4.19/200-v5.2-usb-dwc2-Set-lpm-mode-parameters-depend-on-HW-configuration.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,63 +0,0 @@
-From 28b5c129ca6e585ec95c160ec4297bc6c6360b6f Mon Sep 17 00:00:00 2001
-From: Minas Harutyunyan <minas.harutyunyan@synopsys.com>
-Date: Mon, 4 Mar 2019 17:08:07 +0400
-Subject: usb: dwc2: Set lpm mode parameters depend on HW configuration
-
-If core not supported lpm, i.e. BCM2835 then confusing warnings seen
-in log.
-
-To avoid these warnings, added function dwc2_set_param_lpm() to set
-lpm and other lpm related parameters based on lpm support by core.
-
-Signed-off-by: Minas Harutyunyan <hminas@synopsys.com>
-Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
----
- drivers/usb/dwc2/params.c | 23 ++++++++++++++++++-----
- 1 file changed, 18 insertions(+), 5 deletions(-)
-
---- a/drivers/usb/dwc2/params.c
-+++ b/drivers/usb/dwc2/params.c
-@@ -273,6 +273,23 @@ static void dwc2_set_param_power_down(st
- 	hsotg->params.power_down = val;
- }
- 
-+static void dwc2_set_param_lpm(struct dwc2_hsotg *hsotg)
-+{
-+	struct dwc2_core_params *p = &hsotg->params;
-+
-+	p->lpm = hsotg->hw_params.lpm_mode;
-+	if (p->lpm) {
-+		p->lpm_clock_gating = true;
-+		p->besl = true;
-+		p->hird_threshold_en = true;
-+		p->hird_threshold = 4;
-+	} else {
-+		p->lpm_clock_gating = false;
-+		p->besl = false;
-+		p->hird_threshold_en = false;
-+	}
-+}
-+
- /**
-  * dwc2_set_default_params() - Set all core parameters to their
-  * auto-detected default values.
-@@ -291,6 +308,7 @@ static void dwc2_set_default_params(stru
- 	dwc2_set_param_speed(hsotg);
- 	dwc2_set_param_phy_utmi_width(hsotg);
- 	dwc2_set_param_power_down(hsotg);
-+	dwc2_set_param_lpm(hsotg);
- 	p->phy_ulpi_ddr = false;
- 	p->phy_ulpi_ext_vbus = false;
- 
-@@ -303,11 +321,6 @@ static void dwc2_set_default_params(stru
- 	p->reload_ctl = (hw->snpsid >= DWC2_CORE_REV_2_92a);
- 	p->uframe_sched = true;
- 	p->external_id_pin_ctl = false;
--	p->lpm = true;
--	p->lpm_clock_gating = true;
--	p->besl = true;
--	p->hird_threshold_en = true;
--	p->hird_threshold = 4;
- 	p->ipg_isoc_en = false;
- 	p->max_packet_count = hw->max_packet_count;
- 	p->max_transfer_size = hw->max_transfer_size;
--- a/target/linux/generic/backport-4.19/343-netfilter-nft_flow_offload-handle-netdevice-events-f.patch	2022-03-22 08:54:47.069464439 +0800
+++ b/target/linux/generic/backport-4.19/343-netfilter-nft_flow_offload-handle-netdevice-events-f.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,99 +0,0 @@
-From: Pablo Neira Ayuso <pablo@netfilter.org>
-Date: Thu, 25 Jan 2018 12:58:55 +0100
-Subject: [PATCH] netfilter: nft_flow_offload: handle netdevice events from
- nf_flow_table
-
-Move the code that deals with device events to the core.
-
-Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
----
-
---- a/net/netfilter/nf_flow_table_core.c
-+++ b/net/netfilter/nf_flow_table_core.c
-@@ -532,5 +532,35 @@ void nf_flow_table_free(struct nf_flowta
- }
- EXPORT_SYMBOL_GPL(nf_flow_table_free);
- 
-+static int nf_flow_table_netdev_event(struct notifier_block *this,
-+				      unsigned long event, void *ptr)
-+{
-+	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
-+
-+	if (event != NETDEV_DOWN)
-+		return NOTIFY_DONE;
-+
-+	nf_flow_table_cleanup(dev_net(dev), dev);
-+
-+	return NOTIFY_DONE;
-+}
-+
-+static struct notifier_block flow_offload_netdev_notifier = {
-+	.notifier_call	= nf_flow_table_netdev_event,
-+};
-+
-+static int __init nf_flow_table_module_init(void)
-+{
-+	return register_netdevice_notifier(&flow_offload_netdev_notifier);
-+}
-+
-+static void __exit nf_flow_table_module_exit(void)
-+{
-+	unregister_netdevice_notifier(&flow_offload_netdev_notifier);
-+}
-+
-+module_init(nf_flow_table_module_init);
-+module_exit(nf_flow_table_module_exit);
-+
- MODULE_LICENSE("GPL");
- MODULE_AUTHOR("Pablo Neira Ayuso <pablo@netfilter.org>");
---- a/net/netfilter/nft_flow_offload.c
-+++ b/net/netfilter/nft_flow_offload.c
-@@ -217,47 +217,14 @@ static struct nft_expr_type nft_flow_off
- 	.owner		= THIS_MODULE,
- };
- 
--static int flow_offload_netdev_event(struct notifier_block *this,
--				     unsigned long event, void *ptr)
--{
--	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
--
--	if (event != NETDEV_DOWN)
--		return NOTIFY_DONE;
--
--	nf_flow_table_cleanup(dev_net(dev), dev);
--
--	return NOTIFY_DONE;
--}
--
--static struct notifier_block flow_offload_netdev_notifier = {
--	.notifier_call	= flow_offload_netdev_event,
--};
--
- static int __init nft_flow_offload_module_init(void)
- {
--	int err;
--
--	err = register_netdevice_notifier(&flow_offload_netdev_notifier);
--	if (err)
--		goto err;
--
--	err = nft_register_expr(&nft_flow_offload_type);
--	if (err < 0)
--		goto register_expr;
--
--	return 0;
--
--register_expr:
--	unregister_netdevice_notifier(&flow_offload_netdev_notifier);
--err:
--	return err;
-+	return nft_register_expr(&nft_flow_offload_type);
- }
- 
- static void __exit nft_flow_offload_module_exit(void)
- {
- 	nft_unregister_expr(&nft_flow_offload_type);
--	unregister_netdevice_notifier(&flow_offload_netdev_notifier);
- }
- 
- module_init(nft_flow_offload_module_init);
--- a/target/linux/generic/backport-4.19/370-netfilter-nf_flow_table-fix-offloaded-connection-tim.patch	2022-03-22 08:54:47.069464439 +0800
+++ b/target/linux/generic/backport-4.19/370-netfilter-nf_flow_table-fix-offloaded-connection-tim.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,112 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Wed, 13 Jun 2018 12:33:39 +0200
-Subject: [PATCH] netfilter: nf_flow_table: fix offloaded connection timeout
- corner case
-
-The full teardown of offloaded flows is deferred to a gc work item,
-however processing of packets by netfilter needs to happen immediately
-after a teardown is requested, because the conntrack state needs to be
-fixed up.
-
-Since the IPS_OFFLOAD_BIT is still kept until the teardown is complete,
-the netfilter conntrack gc can accidentally bump the timeout of a
-connection where offload was just stopped, causing a conntrack entry
-leak.
-
-Fix this by moving the conntrack timeout bumping from conntrack core to
-the nf_flow_offload and add a check to prevent bogus timeout bumps.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/netfilter/nf_conntrack_core.c
-+++ b/net/netfilter/nf_conntrack_core.c
-@@ -1178,18 +1178,6 @@ static bool gc_worker_can_early_drop(con
- 	return false;
- }
- 
--#define	DAY	(86400 * HZ)
--
--/* Set an arbitrary timeout large enough not to ever expire, this save
-- * us a check for the IPS_OFFLOAD_BIT from the packet path via
-- * nf_ct_is_expired().
-- */
--static void nf_ct_offload_timeout(struct nf_conn *ct)
--{
--	if (nf_ct_expires(ct) < DAY / 2)
--		ct->timeout = nfct_time_stamp + DAY;
--}
--
- static void gc_worker(struct work_struct *work)
- {
- 	unsigned int min_interval = max(HZ / GC_MAX_BUCKETS_DIV, 1u);
-@@ -1226,10 +1214,8 @@ static void gc_worker(struct work_struct
- 			tmp = nf_ct_tuplehash_to_ctrack(h);
- 
- 			scanned++;
--			if (test_bit(IPS_OFFLOAD_BIT, &tmp->status)) {
--				nf_ct_offload_timeout(tmp);
-+			if (test_bit(IPS_OFFLOAD_BIT, &tmp->status))
- 				continue;
--			}
- 
- 			if (nf_ct_is_expired(tmp)) {
- 				nf_ct_gc_expired(tmp);
---- a/net/netfilter/nf_flow_table_core.c
-+++ b/net/netfilter/nf_flow_table_core.c
-@@ -183,10 +183,29 @@ static const struct rhashtable_params nf
- 	.automatic_shrinking	= true,
- };
- 
-+#define        DAY     (86400 * HZ)
-+
-+/* Set an arbitrary timeout large enough not to ever expire, this save
-+ * us a check for the IPS_OFFLOAD_BIT from the packet path via
-+ * nf_ct_is_expired().
-+ */
-+static void nf_ct_offload_timeout(struct flow_offload *flow)
-+{
-+	struct flow_offload_entry *entry;
-+	struct nf_conn *ct;
-+
-+	entry = container_of(flow, struct flow_offload_entry, flow);
-+	ct = entry->ct;
-+
-+	if (nf_ct_expires(ct) < DAY / 2)
-+		ct->timeout = nfct_time_stamp + DAY;
-+}
-+
- int flow_offload_add(struct nf_flowtable *flow_table, struct flow_offload *flow)
- {
- 	int err;
- 
-+	nf_ct_offload_timeout(flow);
- 	flow->timeout = (u32)jiffies + NF_FLOW_TIMEOUT;
- 
- 	err = rhashtable_insert_fast(&flow_table->rhashtable,
-@@ -317,6 +336,8 @@ static int nf_flow_offload_gc_step(struc
- 	rhashtable_walk_start(&hti);
- 
- 	while ((tuplehash = rhashtable_walk_next(&hti))) {
-+		bool teardown;
-+
- 		if (IS_ERR(tuplehash)) {
- 			err = PTR_ERR(tuplehash);
- 			if (err != -EAGAIN)
-@@ -329,9 +350,13 @@ static int nf_flow_offload_gc_step(struc
- 
- 		flow = container_of(tuplehash, struct flow_offload, tuplehash[0]);
- 
--		if (nf_flow_has_expired(flow) ||
--		    (flow->flags & (FLOW_OFFLOAD_DYING |
--				    FLOW_OFFLOAD_TEARDOWN)))
-+		teardown = flow->flags & (FLOW_OFFLOAD_DYING |
-+					  FLOW_OFFLOAD_TEARDOWN);
-+
-+		if (!teardown)
-+			nf_ct_offload_timeout(flow);
-+
-+		if (nf_flow_has_expired(flow) || teardown)
- 			flow_offload_del(flow_table, flow);
- 	}
- out:
--- a/target/linux/generic/backport-4.19/371-netfilter-nf_flow_table-fix-up-ct-state-of-flows-aft.patch	2022-03-22 08:54:47.070464441 +0800
+++ b/target/linux/generic/backport-4.19/371-netfilter-nf_flow_table-fix-up-ct-state-of-flows-aft.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,24 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Thu, 14 Jun 2018 11:20:09 +0200
-Subject: [PATCH] netfilter: nf_flow_table: fix up ct state of flows after
- timeout
-
-If a connection simply times out instead of being torn down, it is left
-active with a long timeout. Fix this by calling flow_offload_fixup_ct_state
-here as well.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/netfilter/nf_flow_table_core.c
-+++ b/net/netfilter/nf_flow_table_core.c
-@@ -243,6 +243,9 @@ static void flow_offload_del(struct nf_f
- 	e = container_of(flow, struct flow_offload_entry, flow);
- 	clear_bit(IPS_OFFLOAD_BIT, &e->ct->status);
- 
-+	if (!(flow->flags & FLOW_OFFLOAD_TEARDOWN))
-+		flow_offload_fixup_ct_state(e->ct);
-+
- 	flow_offload_free(flow);
- }
- 
--- a/target/linux/generic/backport-4.19/380-v5.3-net-sched-Introduce-act_ctinfo-action.patch	2022-03-22 08:54:47.070464441 +0800
+++ b/target/linux/generic/backport-4.19/380-v5.3-net-sched-Introduce-act_ctinfo-action.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,659 +0,0 @@
-From 6d8071bbbdcd9d3a2fbb49e55b51617906e3b816 Mon Sep 17 00:00:00 2001
-From: Kevin Darbyshire-Bryant <ldir@darbyshire-bryant.me.uk>
-Date: Wed, 13 Mar 2019 20:54:49 +0000
-Subject: [PATCH] net: sched: Backport Introduce act_ctinfo action
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-ctinfo is a new tc filter action module.  It is designed to restore
-information contained in firewall conntrack marks to other packet fields
-and is typically used on packet ingress paths.  At present it has two
-independent sub-functions or operating modes, DSCP restoration mode &
-skb mark restoration mode.
-
-The DSCP restore mode:
-
-This mode copies DSCP values that have been placed in the firewall
-conntrack mark back into the IPv4/v6 diffserv fields of relevant
-packets.
-
-The DSCP restoration is intended for use and has been found useful for
-restoring ingress classifications based on egress classifications across
-links that bleach or otherwise change DSCP, typically home ISP Internet
-links.  Restoring DSCP on ingress on the WAN link allows qdiscs such as
-but by no means limited to CAKE to shape inbound packets according to
-policies that are easier to set & mark on egress.
-
-Ingress classification is traditionally a challenging task since
-iptables rules haven't yet run and tc filter/eBPF programs are pre-NAT
-lookups, hence are unable to see internal IPv4 addresses as used on the
-typical home masquerading gateway.  Thus marking the connection in some
-manner on egress for later restoration of classification on ingress is
-easier to implement.
-
-Parameters related to DSCP restore mode:
-
-dscpmask - a 32 bit mask of 6 contiguous bits and indicate bits of the
-conntrack mark field contain the DSCP value to be restored.
-
-statemask - a 32 bit mask of (usually) 1 bit length, outside the area
-specified by dscpmask.  This represents a conditional operation flag
-whereby the DSCP is only restored if the flag is set.  This is useful to
-implement a 'one shot' iptables based classification where the
-'complicated' iptables rules are only run once to classify the
-connection on initial (egress) packet and subsequent packets are all
-marked/restored with the same DSCP.  A mask of zero disables the
-conditional behaviour ie. the conntrack mark DSCP bits are always
-restored to the ip diffserv field (assuming the conntrack entry is found
-& the skb is an ipv4/ipv6 type)
-
-e.g. dscpmask 0xfc000000 statemask 0x01000000
-
-|----0xFC----conntrack mark----000000---|
-| Bits 31-26 | bit 25 | bit24 |~~~ Bit 0|
-| DSCP       | unused | flag  |unused   |
-|-----------------------0x01---000000---|
-      |                   |
-      |                   |
-      ---|             Conditional flag
-         v             only restore if set
-|-ip diffserv-|
-| 6 bits      |
-|-------------|
-
-The skb mark restore mode (cpmark):
-
-This mode copies the firewall conntrack mark to the skb's mark field.
-It is completely the functional equivalent of the existing act_connmark
-action with the additional feature of being able to apply a mask to the
-restored value.
-
-Parameters related to skb mark restore mode:
-
-mask - a 32 bit mask applied to the firewall conntrack mark to mask out
-bits unwanted for restoration.  This can be useful where the conntrack
-mark is being used for different purposes by different applications.  If
-not specified and by default the whole mark field is copied (i.e.
-default mask of 0xffffffff)
-
-e.g. mask 0x00ffffff to mask out the top 8 bits being used by the
-aforementioned DSCP restore mode.
-
-|----0x00----conntrack mark----ffffff---|
-| Bits 31-24 |                          |
-| DSCP & flag|      some value here     |
-|---------------------------------------|
-			|
-			|
-			v
-|------------skb mark-------------------|
-|            |                          |
-|  zeroed    |                          |
-|---------------------------------------|
-
-Overall parameters:
-
-zone - conntrack zone
-
-control - action related control (reclassify | pipe | drop | continue |
-ok | goto chain <CHAIN_INDEX>)
-
-Signed-off-by: Kevin Darbyshire-Bryant <ldir@darbyshire-bryant.me.uk>
-Reviewed-by: Toke Hiland-Jrgensen <toke@redhat.com>
-Acked-by: Cong Wang <xiyou.wangcong@gmail.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
-
-Backport
-Signed-off-by: Kevin Darbyshire-Bryant <ldir@darbyshire-bryant.me.uk>
----
- include/net/tc_act/tc_ctinfo.h            |  33 ++
- include/uapi/linux/pkt_cls.h              |   3 +-
- include/uapi/linux/tc_act/tc_ctinfo.h     |  29 ++
- net/sched/Kconfig                         |  17 +
- net/sched/Makefile                        |   1 +
- net/sched/act_ctinfo.c                    | 409 ++++++++++++++++++++++
- tools/testing/selftests/tc-testing/config |   1 +
- 7 files changed, 492 insertions(+), 1 deletion(-)
- create mode 100644 include/net/tc_act/tc_ctinfo.h
- create mode 100644 include/uapi/linux/tc_act/tc_ctinfo.h
- create mode 100644 net/sched/act_ctinfo.c
-
---- /dev/null
-+++ b/include/net/tc_act/tc_ctinfo.h
-@@ -0,0 +1,33 @@
-+/* SPDX-License-Identifier: GPL-2.0 */
-+#ifndef __NET_TC_CTINFO_H
-+#define __NET_TC_CTINFO_H
-+
-+#include <net/act_api.h>
-+
-+struct tcf_ctinfo_params {
-+	struct rcu_head rcu;
-+	struct net *net;
-+	u32 dscpmask;
-+	u32 dscpstatemask;
-+	u32 cpmarkmask;
-+	u16 zone;
-+	u8 mode;
-+	u8 dscpmaskshift;
-+};
-+
-+struct tcf_ctinfo {
-+	struct tc_action common;
-+	struct tcf_ctinfo_params __rcu *params;
-+	u64 stats_dscp_set;
-+	u64 stats_dscp_error;
-+	u64 stats_cpmark_set;
-+};
-+
-+enum {
-+	CTINFO_MODE_DSCP	= BIT(0),
-+	CTINFO_MODE_CPMARK	= BIT(1)
-+};
-+
-+#define to_ctinfo(a) ((struct tcf_ctinfo *)a)
-+
-+#endif /* __NET_TC_CTINFO_H */
---- a/include/uapi/linux/pkt_cls.h
-+++ b/include/uapi/linux/pkt_cls.h
-@@ -68,7 +68,8 @@ enum {
- 	TCA_ID_UNSPEC=0,
- 	TCA_ID_POLICE=1,
- 	/* other actions go here */
--	__TCA_ID_MAX=255
-+	TCA_ID_CTINFO,
-+	__TCA_ID_MAX = 255
- };
- 
- #define TCA_ID_MAX __TCA_ID_MAX
---- /dev/null
-+++ b/include/uapi/linux/tc_act/tc_ctinfo.h
-@@ -0,0 +1,29 @@
-+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
-+#ifndef __UAPI_TC_CTINFO_H
-+#define __UAPI_TC_CTINFO_H
-+
-+#include <linux/types.h>
-+#include <linux/pkt_cls.h>
-+
-+struct tc_ctinfo {
-+	tc_gen;
-+};
-+
-+enum {
-+	TCA_CTINFO_UNSPEC,
-+	TCA_CTINFO_PAD,
-+	TCA_CTINFO_TM,
-+	TCA_CTINFO_ACT,
-+	TCA_CTINFO_ZONE,
-+	TCA_CTINFO_PARMS_DSCP_MASK,
-+	TCA_CTINFO_PARMS_DSCP_STATEMASK,
-+	TCA_CTINFO_PARMS_CPMARK_MASK,
-+	TCA_CTINFO_STATS_DSCP_SET,
-+	TCA_CTINFO_STATS_DSCP_ERROR,
-+	TCA_CTINFO_STATS_CPMARK_SET,
-+	__TCA_CTINFO_MAX
-+};
-+
-+#define TCA_CTINFO_MAX (__TCA_CTINFO_MAX - 1)
-+
-+#endif
---- a/net/sched/Kconfig
-+++ b/net/sched/Kconfig
-@@ -866,6 +866,23 @@ config NET_ACT_CONNMARK
- 	  To compile this code as a module, choose M here: the
- 	  module will be called act_connmark.
- 
-+config NET_ACT_CTINFO
-+        tristate "Netfilter Connection Mark Actions"
-+        depends on NET_CLS_ACT && NETFILTER && IP_NF_IPTABLES
-+        depends on NF_CONNTRACK && NF_CONNTRACK_MARK
-+        help
-+	  Say Y here to allow transfer of a connmark stored information.
-+	  Current actions transfer connmark stored DSCP into
-+	  ipv4/v6 diffserv and/or to transfer connmark to packet
-+	  mark.  Both are useful for restoring egress based marks
-+	  back onto ingress connections for qdisc priority mapping
-+	  purposes.
-+
-+	  If unsure, say N.
-+
-+	  To compile this code as a module, choose M here: the
-+	  module will be called act_ctinfo.
-+
- config NET_ACT_SKBMOD
-         tristate "skb data modification action"
-         depends on NET_CLS_ACT
---- a/net/sched/Makefile
-+++ b/net/sched/Makefile
-@@ -21,6 +21,7 @@ obj-$(CONFIG_NET_ACT_CSUM)	+= act_csum.o
- obj-$(CONFIG_NET_ACT_VLAN)	+= act_vlan.o
- obj-$(CONFIG_NET_ACT_BPF)	+= act_bpf.o
- obj-$(CONFIG_NET_ACT_CONNMARK)	+= act_connmark.o
-+obj-$(CONFIG_NET_ACT_CTINFO)	+= act_ctinfo.o
- obj-$(CONFIG_NET_ACT_SKBMOD)	+= act_skbmod.o
- obj-$(CONFIG_NET_ACT_IFE)	+= act_ife.o
- obj-$(CONFIG_NET_IFE_SKBMARK)	+= act_meta_mark.o
---- /dev/null
-+++ b/net/sched/act_ctinfo.c
-@@ -0,0 +1,409 @@
-+// SPDX-License-Identifier: GPL-2.0+
-+/* net/sched/act_ctinfo.c  netfilter ctinfo connmark actions
-+ *
-+ * Copyright (c) 2019 Kevin Darbyshire-Bryant <ldir@darbyshire-bryant.me.uk>
-+ */
-+
-+#include <linux/module.h>
-+#include <linux/init.h>
-+#include <linux/kernel.h>
-+#include <linux/skbuff.h>
-+#include <linux/rtnetlink.h>
-+#include <linux/pkt_cls.h>
-+#include <linux/ip.h>
-+#include <linux/ipv6.h>
-+#include <net/netlink.h>
-+#include <net/pkt_sched.h>
-+#include <net/act_api.h>
-+#include <net/pkt_cls.h>
-+#include <uapi/linux/tc_act/tc_ctinfo.h>
-+#include <net/tc_act/tc_ctinfo.h>
-+
-+#include <net/netfilter/nf_conntrack.h>
-+#include <net/netfilter/nf_conntrack_core.h>
-+#include <net/netfilter/nf_conntrack_ecache.h>
-+#include <net/netfilter/nf_conntrack_zones.h>
-+
-+static struct tc_action_ops act_ctinfo_ops;
-+static unsigned int ctinfo_net_id;
-+
-+static void tcf_ctinfo_dscp_set(struct nf_conn *ct, struct tcf_ctinfo *ca,
-+				struct tcf_ctinfo_params *cp,
-+				struct sk_buff *skb, int wlen, int proto)
-+{
-+	u8 dscp, newdscp;
-+
-+	newdscp = (((ct->mark & cp->dscpmask) >> cp->dscpmaskshift) << 2) &
-+		     ~INET_ECN_MASK;
-+
-+	switch (proto) {
-+	case NFPROTO_IPV4:
-+		dscp = ipv4_get_dsfield(ip_hdr(skb)) & ~INET_ECN_MASK;
-+		if (dscp != newdscp) {
-+			if (likely(!skb_try_make_writable(skb, wlen))) {
-+				ipv4_change_dsfield(ip_hdr(skb),
-+						    INET_ECN_MASK,
-+						    newdscp);
-+				ca->stats_dscp_set++;
-+			} else {
-+				ca->stats_dscp_error++;
-+			}
-+		}
-+		break;
-+	case NFPROTO_IPV6:
-+		dscp = ipv6_get_dsfield(ipv6_hdr(skb)) & ~INET_ECN_MASK;
-+		if (dscp != newdscp) {
-+			if (likely(!skb_try_make_writable(skb, wlen))) {
-+				ipv6_change_dsfield(ipv6_hdr(skb),
-+						    INET_ECN_MASK,
-+						    newdscp);
-+				ca->stats_dscp_set++;
-+			} else {
-+				ca->stats_dscp_error++;
-+			}
-+		}
-+		break;
-+	default:
-+		break;
-+	}
-+}
-+
-+static void tcf_ctinfo_cpmark_set(struct nf_conn *ct, struct tcf_ctinfo *ca,
-+				  struct tcf_ctinfo_params *cp,
-+				  struct sk_buff *skb)
-+{
-+	ca->stats_cpmark_set++;
-+	skb->mark = ct->mark & cp->cpmarkmask;
-+}
-+
-+static int tcf_ctinfo_act(struct sk_buff *skb, const struct tc_action *a,
-+			  struct tcf_result *res)
-+{
-+	const struct nf_conntrack_tuple_hash *thash = NULL;
-+	struct tcf_ctinfo *ca = to_ctinfo(a);
-+	struct nf_conntrack_tuple tuple;
-+	struct nf_conntrack_zone zone;
-+	enum ip_conntrack_info ctinfo;
-+	struct tcf_ctinfo_params *cp;
-+	struct nf_conn *ct;
-+	int proto, wlen;
-+	int action;
-+
-+	cp = rcu_dereference_bh(ca->params);
-+
-+	tcf_lastuse_update(&ca->tcf_tm);
-+	bstats_update(&ca->tcf_bstats, skb);
-+	action = READ_ONCE(ca->tcf_action);
-+
-+	wlen = skb_network_offset(skb);
-+	if (tc_skb_protocol(skb) == htons(ETH_P_IP)) {
-+		wlen += sizeof(struct iphdr);
-+		if (!pskb_may_pull(skb, wlen))
-+			goto out;
-+
-+		proto = NFPROTO_IPV4;
-+	} else if (tc_skb_protocol(skb) == htons(ETH_P_IPV6)) {
-+		wlen += sizeof(struct ipv6hdr);
-+		if (!pskb_may_pull(skb, wlen))
-+			goto out;
-+
-+		proto = NFPROTO_IPV6;
-+	} else {
-+		goto out;
-+	}
-+
-+	ct = nf_ct_get(skb, &ctinfo);
-+	if (!ct) { /* look harder, usually ingress */
-+		if (!nf_ct_get_tuplepr(skb, skb_network_offset(skb),
-+				       proto, cp->net, &tuple))
-+			goto out;
-+		zone.id = cp->zone;
-+		zone.dir = NF_CT_DEFAULT_ZONE_DIR;
-+
-+		thash = nf_conntrack_find_get(cp->net, &zone, &tuple);
-+		if (!thash)
-+			goto out;
-+
-+		ct = nf_ct_tuplehash_to_ctrack(thash);
-+	}
-+
-+	if (cp->mode & CTINFO_MODE_DSCP)
-+		if (!cp->dscpstatemask || (ct->mark & cp->dscpstatemask))
-+			tcf_ctinfo_dscp_set(ct, ca, cp, skb, wlen, proto);
-+
-+	if (cp->mode & CTINFO_MODE_CPMARK)
-+		tcf_ctinfo_cpmark_set(ct, ca, cp, skb);
-+
-+	if (thash)
-+		nf_ct_put(ct);
-+out:
-+	return action;
-+}
-+
-+static const struct nla_policy ctinfo_policy[TCA_CTINFO_MAX + 1] = {
-+	[TCA_CTINFO_ACT]		  = { .len = sizeof(struct
-+							    tc_ctinfo) },
-+	[TCA_CTINFO_ZONE]		  = { .type = NLA_U16 },
-+	[TCA_CTINFO_PARMS_DSCP_MASK]	  = { .type = NLA_U32 },
-+	[TCA_CTINFO_PARMS_DSCP_STATEMASK] = { .type = NLA_U32 },
-+	[TCA_CTINFO_PARMS_CPMARK_MASK]	  = { .type = NLA_U32 },
-+};
-+
-+static int tcf_ctinfo_init(struct net *net, struct nlattr *nla,
-+			   struct nlattr *est, struct tc_action **a,
-+			   int ovr, int bind, bool rtnl_held,
-+			   struct netlink_ext_ack *extack)
-+{
-+	struct tc_action_net *tn = net_generic(net, ctinfo_net_id);
-+	u32 dscpmask = 0, dscpstatemask, index;
-+	struct nlattr *tb[TCA_CTINFO_MAX + 1];
-+	struct tcf_ctinfo_params *cp_new;
-+/*	struct tcf_chain *goto_ch = NULL; */
-+	struct tc_ctinfo *actparm;
-+	struct tcf_ctinfo *ci;
-+	u8 dscpmaskshift;
-+	int ret = 0, err;
-+
-+	if (!nla) {
-+		NL_SET_ERR_MSG_MOD(extack, "ctinfo requires attributes to be passed");
-+		return -EINVAL;
-+	}
-+
-+	err = nla_parse_nested(tb, TCA_CTINFO_MAX, nla, ctinfo_policy, extack);
-+	if (err < 0)
-+		return err;
-+
-+	if (!tb[TCA_CTINFO_ACT]) {
-+		NL_SET_ERR_MSG_MOD(extack,
-+				   "Missing required TCA_CTINFO_ACT attribute");
-+		return -EINVAL;
-+	}
-+	actparm = nla_data(tb[TCA_CTINFO_ACT]);
-+
-+	/* do some basic validation here before dynamically allocating things */
-+	/* that we would otherwise have to clean up.			      */
-+	if (tb[TCA_CTINFO_PARMS_DSCP_MASK]) {
-+		dscpmask = nla_get_u32(tb[TCA_CTINFO_PARMS_DSCP_MASK]);
-+		/* need contiguous 6 bit mask */
-+		dscpmaskshift = dscpmask ? __ffs(dscpmask) : 0;
-+		if ((~0 & (dscpmask >> dscpmaskshift)) != 0x3f) {
-+			NL_SET_ERR_MSG_ATTR(extack,
-+					    tb[TCA_CTINFO_PARMS_DSCP_MASK],
-+					    "dscp mask must be 6 contiguous bits");
-+			return -EINVAL;
-+		}
-+		dscpstatemask = tb[TCA_CTINFO_PARMS_DSCP_STATEMASK] ?
-+			nla_get_u32(tb[TCA_CTINFO_PARMS_DSCP_STATEMASK]) : 0;
-+		/* mask & statemask must not overlap */
-+		if (dscpmask & dscpstatemask) {
-+			NL_SET_ERR_MSG_ATTR(extack,
-+					    tb[TCA_CTINFO_PARMS_DSCP_STATEMASK],
-+					    "dscp statemask must not overlap dscp mask");
-+			return -EINVAL;
-+		}
-+	}
-+
-+	/* done the validation:now to the actual action allocation */
-+	index = actparm->index;
-+	err = tcf_idr_check_alloc(tn, &index, a, bind);
-+	if (!err) {
-+		ret = tcf_idr_create(tn, index, est, a,
-+				     &act_ctinfo_ops, bind, false);
-+		if (ret) {
-+			tcf_idr_cleanup(tn, index);
-+			return ret;
-+		}
-+		ret = ACT_P_CREATED;
-+	} else if (err > 0) {
-+		if (bind) /* don't override defaults */
-+			return 0;
-+		if (!ovr) {
-+			tcf_idr_release(*a, bind);
-+			return -EEXIST;
-+		}
-+	} else {
-+		return err;
-+	}
-+
-+/*	err = tcf_action_check_ctrlact(actparm->action, tp, &goto_ch, extack);
-+	if (err < 0)
-+		goto release_idr;
-+		*/
-+
-+	ci = to_ctinfo(*a);
-+
-+	cp_new = kzalloc(sizeof(*cp_new), GFP_KERNEL);
-+	if (unlikely(!cp_new)) {
-+		err = -ENOMEM;
-+		goto put_chain;
-+	}
-+
-+	cp_new->net = net;
-+	cp_new->zone = tb[TCA_CTINFO_ZONE] ?
-+			nla_get_u16(tb[TCA_CTINFO_ZONE]) : 0;
-+	if (dscpmask) {
-+		cp_new->dscpmask = dscpmask;
-+		cp_new->dscpmaskshift = dscpmaskshift;
-+		cp_new->dscpstatemask = dscpstatemask;
-+		cp_new->mode |= CTINFO_MODE_DSCP;
-+	}
-+
-+	if (tb[TCA_CTINFO_PARMS_CPMARK_MASK]) {
-+		cp_new->cpmarkmask =
-+				nla_get_u32(tb[TCA_CTINFO_PARMS_CPMARK_MASK]);
-+		cp_new->mode |= CTINFO_MODE_CPMARK;
-+	}
-+
-+	spin_lock_bh(&ci->tcf_lock);
-+/*	goto_ch = tcf_action_set_ctrlact(*a, actparm->action, goto_ch); */
-+	ci->tcf_action = actparm->action;
-+	rcu_swap_protected(ci->params, cp_new,
-+			   lockdep_is_held(&ci->tcf_lock));
-+	spin_unlock_bh(&ci->tcf_lock);
-+
-+/*	if (goto_ch)
-+		tcf_chain_put_by_act(goto_ch); */
-+	if (cp_new)
-+		kfree_rcu(cp_new, rcu);
-+
-+	if (ret == ACT_P_CREATED)
-+		tcf_idr_insert(tn, *a);
-+
-+	return ret;
-+
-+put_chain:
-+/*	if (goto_ch)
-+		tcf_chain_put_by_act(goto_ch);
-+release_idr: */
-+	tcf_idr_release(*a, bind);
-+	return err;
-+}
-+
-+static int tcf_ctinfo_dump(struct sk_buff *skb, struct tc_action *a,
-+			   int bind, int ref)
-+{
-+	struct tcf_ctinfo *ci = to_ctinfo(a);
-+	struct tc_ctinfo opt = {
-+		.index   = ci->tcf_index,
-+		.refcnt  = refcount_read(&ci->tcf_refcnt) - ref,
-+		.bindcnt = atomic_read(&ci->tcf_bindcnt) - bind,
-+	};
-+	unsigned char *b = skb_tail_pointer(skb);
-+	struct tcf_ctinfo_params *cp;
-+	struct tcf_t t;
-+
-+	spin_lock_bh(&ci->tcf_lock);
-+	cp = rcu_dereference_protected(ci->params,
-+				       lockdep_is_held(&ci->tcf_lock));
-+
-+	tcf_tm_dump(&t, &ci->tcf_tm);
-+	if (nla_put_64bit(skb, TCA_CTINFO_TM, sizeof(t), &t, TCA_CTINFO_PAD))
-+		goto nla_put_failure;
-+
-+	opt.action = ci->tcf_action;
-+	if (nla_put(skb, TCA_CTINFO_ACT, sizeof(opt), &opt))
-+		goto nla_put_failure;
-+
-+	if (nla_put_u16(skb, TCA_CTINFO_ZONE, cp->zone))
-+		goto nla_put_failure;
-+
-+	if (cp->mode & CTINFO_MODE_DSCP) {
-+		if (nla_put_u32(skb, TCA_CTINFO_PARMS_DSCP_MASK,
-+				cp->dscpmask))
-+			goto nla_put_failure;
-+		if (nla_put_u32(skb, TCA_CTINFO_PARMS_DSCP_STATEMASK,
-+				cp->dscpstatemask))
-+			goto nla_put_failure;
-+	}
-+
-+	if (cp->mode & CTINFO_MODE_CPMARK) {
-+		if (nla_put_u32(skb, TCA_CTINFO_PARMS_CPMARK_MASK,
-+				cp->cpmarkmask))
-+			goto nla_put_failure;
-+	}
-+
-+	if (nla_put_u64_64bit(skb, TCA_CTINFO_STATS_DSCP_SET,
-+			      ci->stats_dscp_set, TCA_CTINFO_PAD))
-+		goto nla_put_failure;
-+
-+	if (nla_put_u64_64bit(skb, TCA_CTINFO_STATS_DSCP_ERROR,
-+			      ci->stats_dscp_error, TCA_CTINFO_PAD))
-+		goto nla_put_failure;
-+
-+	if (nla_put_u64_64bit(skb, TCA_CTINFO_STATS_CPMARK_SET,
-+			      ci->stats_cpmark_set, TCA_CTINFO_PAD))
-+		goto nla_put_failure;
-+
-+	spin_unlock_bh(&ci->tcf_lock);
-+	return skb->len;
-+
-+nla_put_failure:
-+	spin_unlock_bh(&ci->tcf_lock);
-+	nlmsg_trim(skb, b);
-+	return -1;
-+}
-+
-+static int tcf_ctinfo_walker(struct net *net, struct sk_buff *skb,
-+			     struct netlink_callback *cb, int type,
-+			     const struct tc_action_ops *ops,
-+			     struct netlink_ext_ack *extack)
-+{
-+	struct tc_action_net *tn = net_generic(net, ctinfo_net_id);
-+
-+	return tcf_generic_walker(tn, skb, cb, type, ops, extack);
-+}
-+
-+static int tcf_ctinfo_search(struct net *net, struct tc_action **a, u32 index,
-+			     struct netlink_ext_ack *extack)
-+{
-+	struct tc_action_net *tn = net_generic(net, ctinfo_net_id);
-+
-+	return tcf_idr_search(tn, a, index);
-+}
-+
-+static struct tc_action_ops act_ctinfo_ops = {
-+	.kind	= "ctinfo",
-+	.type	= TCA_ID_CTINFO,
-+	.owner	= THIS_MODULE,
-+	.act	= tcf_ctinfo_act,
-+	.dump	= tcf_ctinfo_dump,
-+	.init	= tcf_ctinfo_init,
-+	.walk	= tcf_ctinfo_walker,
-+	.lookup	= tcf_ctinfo_search,
-+	.size	= sizeof(struct tcf_ctinfo),
-+};
-+
-+static __net_init int ctinfo_init_net(struct net *net)
-+{
-+	struct tc_action_net *tn = net_generic(net, ctinfo_net_id);
-+
-+	return tc_action_net_init(net, tn, &act_ctinfo_ops);
-+}
-+
-+static void __net_exit ctinfo_exit_net(struct list_head *net_list)
-+{
-+	tc_action_net_exit(net_list, ctinfo_net_id);
-+}
-+
-+static struct pernet_operations ctinfo_net_ops = {
-+	.init		= ctinfo_init_net,
-+	.exit_batch	= ctinfo_exit_net,
-+	.id		= &ctinfo_net_id,
-+	.size		= sizeof(struct tc_action_net),
-+};
-+
-+static int __init ctinfo_init_module(void)
-+{
-+	return tcf_register_action(&act_ctinfo_ops, &ctinfo_net_ops);
-+}
-+
-+static void __exit ctinfo_cleanup_module(void)
-+{
-+	tcf_unregister_action(&act_ctinfo_ops, &ctinfo_net_ops);
-+}
-+
-+module_init(ctinfo_init_module);
-+module_exit(ctinfo_cleanup_module);
-+MODULE_AUTHOR("Kevin Darbyshire-Bryant <ldir@darbyshire-bryant.me.uk>");
-+MODULE_DESCRIPTION("Connection tracking mark actions");
-+MODULE_LICENSE("GPL");
---- a/tools/testing/selftests/tc-testing/config
-+++ b/tools/testing/selftests/tc-testing/config
-@@ -38,6 +38,7 @@ CONFIG_NET_ACT_CSUM=m
- CONFIG_NET_ACT_VLAN=m
- CONFIG_NET_ACT_BPF=m
- CONFIG_NET_ACT_CONNMARK=m
-+CONFIG_NET_ACT_CONNCTINFO=m
- CONFIG_NET_ACT_SKBMOD=m
- CONFIG_NET_ACT_IFE=m
- CONFIG_NET_ACT_TUNNEL_KEY=m
--- a/target/linux/generic/backport-4.19/402-leds-trigger-netdev-fix-handling-on-interface-rename.patch	2022-03-22 08:54:47.070464441 +0800
+++ b/target/linux/generic/backport-4.19/402-leds-trigger-netdev-fix-handling-on-interface-rename.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,49 +0,0 @@
-From 0ff035231edca3713c3d0839c44e64a4ac41ef38 Mon Sep 17 00:00:00 2001
-From: Martin Schiller <ms@dev.tdt.de>
-Date: Thu, 24 Oct 2019 15:09:23 +0200
-Subject: [PATCH] leds: trigger: netdev: fix handling on interface rename
-
-The NETDEV_CHANGENAME code is not "unneeded" like it is stated in commit
-4cb6560514fa ("leds: trigger: netdev: fix refcnt leak on interface
-rename").
-
-The event was accidentally misinterpreted equivalent to
-NETDEV_UNREGISTER, but should be equivalent to NETDEV_REGISTER.
-
-This was the case in the original code from the openwrt project.
-
-Otherwise, you are unable to set netdev led triggers for (non-existent)
-netdevices, which has to be renamed. This is the case, for example, for
-ppp interfaces in openwrt.
-
-Fixes: 06f502f57d0d ("leds: trigger: Introduce a NETDEV trigger")
-Fixes: 4cb6560514fa ("leds: trigger: netdev: fix refcnt leak on interface rename")
-Signed-off-by: Martin Schiller <ms@dev.tdt.de>
----
- drivers/leds/trigger/ledtrig-netdev.c | 5 ++++-
- 1 file changed, 4 insertions(+), 1 deletion(-)
-
---- a/drivers/leds/trigger/ledtrig-netdev.c
-+++ b/drivers/leds/trigger/ledtrig-netdev.c
-@@ -302,10 +302,12 @@ static int netdev_trig_notify(struct not
- 		container_of(nb, struct led_netdev_data, notifier);
- 
- 	if (evt != NETDEV_UP && evt != NETDEV_DOWN && evt != NETDEV_CHANGE
--	    && evt != NETDEV_REGISTER && evt != NETDEV_UNREGISTER)
-+	    && evt != NETDEV_REGISTER && evt != NETDEV_UNREGISTER
-+	    && evt != NETDEV_CHANGENAME)
- 		return NOTIFY_DONE;
- 
- 	if (!(dev == trigger_data->net_dev ||
-+	      (evt == NETDEV_CHANGENAME && !strcmp(dev->name, trigger_data->device_name)) ||
- 	      (evt == NETDEV_REGISTER && !strcmp(dev->name, trigger_data->device_name))))
- 		return NOTIFY_DONE;
- 
-@@ -315,6 +317,7 @@ static int netdev_trig_notify(struct not
- 
- 	clear_bit(NETDEV_LED_MODE_LINKUP, &trigger_data->mode);
- 	switch (evt) {
-+	case NETDEV_CHANGENAME:
- 	case NETDEV_REGISTER:
- 		if (trigger_data->net_dev)
- 			dev_put(trigger_data->net_dev);
--- a/target/linux/generic/backport-4.19/450-v5.0-mtd-spinand-add-support-for-GigaDevice-GD5FxGQ4xA.patch	2022-03-22 08:54:47.071464443 +0800
+++ b/target/linux/generic/backport-4.19/450-v5.0-mtd-spinand-add-support-for-GigaDevice-GD5FxGQ4xA.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,196 +0,0 @@
-From c93c613214ac70c87beab5422a60077bf126b855 Mon Sep 17 00:00:00 2001
-From: Chuanhong Guo <gch981213@gmail.com>
-Date: Wed, 28 Nov 2018 21:07:25 +0800
-Subject: [PATCH] mtd: spinand: add support for GigaDevice GD5FxGQ4xA
-
-Add support for GigaDevice GD5F1G/2G/4GQ4xA SPI NAND.
-
-Signed-off-by: Chuanhong Guo <gch981213@gmail.com>
-Reviewed-by: Frieder Schrempf <frieder.schrempf@kontron.de>
-Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
----
- drivers/mtd/nand/spi/Makefile     |   2 +-
- drivers/mtd/nand/spi/core.c       |   1 +
- drivers/mtd/nand/spi/gigadevice.c | 148 ++++++++++++++++++++++++++++++++++++++
- include/linux/mtd/spinand.h       |   1 +
- 4 files changed, 151 insertions(+), 1 deletion(-)
- create mode 100644 drivers/mtd/nand/spi/gigadevice.c
-
---- a/drivers/mtd/nand/spi/Makefile
-+++ b/drivers/mtd/nand/spi/Makefile
-@@ -1,3 +1,3 @@
- # SPDX-License-Identifier: GPL-2.0
--spinand-objs := core.o macronix.o micron.o winbond.o
-+spinand-objs := core.o gigadevice.o macronix.o micron.o winbond.o
- obj-$(CONFIG_MTD_SPI_NAND) += spinand.o
---- a/drivers/mtd/nand/spi/core.c
-+++ b/drivers/mtd/nand/spi/core.c
-@@ -762,6 +762,7 @@ static const struct nand_ops spinand_ops
- };
- 
- static const struct spinand_manufacturer *spinand_manufacturers[] = {
-+	&gigadevice_spinand_manufacturer,
- 	&macronix_spinand_manufacturer,
- 	&micron_spinand_manufacturer,
- 	&winbond_spinand_manufacturer,
---- /dev/null
-+++ b/drivers/mtd/nand/spi/gigadevice.c
-@@ -0,0 +1,148 @@
-+// SPDX-License-Identifier: GPL-2.0
-+/*
-+ * Author:
-+ *	Chuanhong Guo <gch981213@gmail.com>
-+ */
-+
-+#include <linux/device.h>
-+#include <linux/kernel.h>
-+#include <linux/mtd/spinand.h>
-+
-+#define SPINAND_MFR_GIGADEVICE			0xC8
-+#define GD5FXGQ4XA_STATUS_ECC_1_7_BITFLIPS	(1 << 4)
-+#define GD5FXGQ4XA_STATUS_ECC_8_BITFLIPS	(3 << 4)
-+
-+static SPINAND_OP_VARIANTS(read_cache_variants,
-+		SPINAND_PAGE_READ_FROM_CACHE_QUADIO_OP(0, 2, NULL, 0),
-+		SPINAND_PAGE_READ_FROM_CACHE_X4_OP(0, 1, NULL, 0),
-+		SPINAND_PAGE_READ_FROM_CACHE_DUALIO_OP(0, 1, NULL, 0),
-+		SPINAND_PAGE_READ_FROM_CACHE_X2_OP(0, 1, NULL, 0),
-+		SPINAND_PAGE_READ_FROM_CACHE_OP(true, 0, 1, NULL, 0),
-+		SPINAND_PAGE_READ_FROM_CACHE_OP(false, 0, 1, NULL, 0));
-+
-+static SPINAND_OP_VARIANTS(write_cache_variants,
-+		SPINAND_PROG_LOAD_X4(true, 0, NULL, 0),
-+		SPINAND_PROG_LOAD(true, 0, NULL, 0));
-+
-+static SPINAND_OP_VARIANTS(update_cache_variants,
-+		SPINAND_PROG_LOAD_X4(false, 0, NULL, 0),
-+		SPINAND_PROG_LOAD(false, 0, NULL, 0));
-+
-+static int gd5fxgq4xa_ooblayout_ecc(struct mtd_info *mtd, int section,
-+				  struct mtd_oob_region *region)
-+{
-+	if (section > 3)
-+		return -ERANGE;
-+
-+	region->offset = (16 * section) + 8;
-+	region->length = 8;
-+
-+	return 0;
-+}
-+
-+static int gd5fxgq4xa_ooblayout_free(struct mtd_info *mtd, int section,
-+				   struct mtd_oob_region *region)
-+{
-+	if (section > 3)
-+		return -ERANGE;
-+
-+	if (section) {
-+		region->offset = 16 * section;
-+		region->length = 8;
-+	} else {
-+		/* section 0 has one byte reserved for bad block mark */
-+		region->offset = 1;
-+		region->length = 7;
-+	}
-+	return 0;
-+}
-+
-+static int gd5fxgq4xa_ecc_get_status(struct spinand_device *spinand,
-+					 u8 status)
-+{
-+	switch (status & STATUS_ECC_MASK) {
-+	case STATUS_ECC_NO_BITFLIPS:
-+		return 0;
-+
-+	case GD5FXGQ4XA_STATUS_ECC_1_7_BITFLIPS:
-+		/* 1-7 bits are flipped. return the maximum. */
-+		return 7;
-+
-+	case GD5FXGQ4XA_STATUS_ECC_8_BITFLIPS:
-+		return 8;
-+
-+	case STATUS_ECC_UNCOR_ERROR:
-+		return -EBADMSG;
-+
-+	default:
-+		break;
-+	}
-+
-+	return -EINVAL;
-+}
-+
-+static const struct mtd_ooblayout_ops gd5fxgq4xa_ooblayout = {
-+	.ecc = gd5fxgq4xa_ooblayout_ecc,
-+	.free = gd5fxgq4xa_ooblayout_free,
-+};
-+
-+static const struct spinand_info gigadevice_spinand_table[] = {
-+	SPINAND_INFO("GD5F1GQ4xA", 0xF1,
-+		     NAND_MEMORG(1, 2048, 64, 64, 1024, 1, 1, 1),
-+		     NAND_ECCREQ(8, 512),
-+		     SPINAND_INFO_OP_VARIANTS(&read_cache_variants,
-+					      &write_cache_variants,
-+					      &update_cache_variants),
-+		     0,
-+		     SPINAND_ECCINFO(&gd5fxgq4xa_ooblayout,
-+				     gd5fxgq4xa_ecc_get_status)),
-+	SPINAND_INFO("GD5F2GQ4xA", 0xF2,
-+		     NAND_MEMORG(1, 2048, 64, 64, 2048, 1, 1, 1),
-+		     NAND_ECCREQ(8, 512),
-+		     SPINAND_INFO_OP_VARIANTS(&read_cache_variants,
-+					      &write_cache_variants,
-+					      &update_cache_variants),
-+		     0,
-+		     SPINAND_ECCINFO(&gd5fxgq4xa_ooblayout,
-+				     gd5fxgq4xa_ecc_get_status)),
-+	SPINAND_INFO("GD5F4GQ4xA", 0xF4,
-+		     NAND_MEMORG(1, 2048, 64, 64, 4096, 1, 1, 1),
-+		     NAND_ECCREQ(8, 512),
-+		     SPINAND_INFO_OP_VARIANTS(&read_cache_variants,
-+					      &write_cache_variants,
-+					      &update_cache_variants),
-+		     0,
-+		     SPINAND_ECCINFO(&gd5fxgq4xa_ooblayout,
-+				     gd5fxgq4xa_ecc_get_status)),
-+};
-+
-+static int gigadevice_spinand_detect(struct spinand_device *spinand)
-+{
-+	u8 *id = spinand->id.data;
-+	int ret;
-+
-+	/*
-+	 * For GD NANDs, There is an address byte needed to shift in before IDs
-+	 * are read out, so the first byte in raw_id is dummy.
-+	 */
-+	if (id[1] != SPINAND_MFR_GIGADEVICE)
-+		return 0;
-+
-+	ret = spinand_match_and_init(spinand, gigadevice_spinand_table,
-+				     ARRAY_SIZE(gigadevice_spinand_table),
-+				     id[2]);
-+	if (ret)
-+		return ret;
-+
-+	return 1;
-+}
-+
-+static const struct spinand_manufacturer_ops gigadevice_spinand_manuf_ops = {
-+	.detect = gigadevice_spinand_detect,
-+};
-+
-+const struct spinand_manufacturer gigadevice_spinand_manufacturer = {
-+	.id = SPINAND_MFR_GIGADEVICE,
-+	.name = "GigaDevice",
-+	.ops = &gigadevice_spinand_manuf_ops,
-+};
---- a/include/linux/mtd/spinand.h
-+++ b/include/linux/mtd/spinand.h
-@@ -194,6 +194,7 @@ struct spinand_manufacturer {
- };
- 
- /* SPI NAND manufacturers */
-+extern const struct spinand_manufacturer gigadevice_spinand_manufacturer;
- extern const struct spinand_manufacturer macronix_spinand_manufacturer;
- extern const struct spinand_manufacturer micron_spinand_manufacturer;
- extern const struct spinand_manufacturer winbond_spinand_manufacturer;
--- a/target/linux/generic/backport-4.19/451-v5.1-mtd-spinand-Add-support-for-GigaDevice-GD5F1GQ4UExxG.patch	2022-03-22 08:54:47.072464444 +0800
+++ b/target/linux/generic/backport-4.19/451-v5.1-mtd-spinand-Add-support-for-GigaDevice-GD5F1GQ4UExxG.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,129 +0,0 @@
-From c40c7a990a46e5102a1cc4190557bf315d32d80d Mon Sep 17 00:00:00 2001
-From: Stefan Roese <sr@denx.de>
-Date: Thu, 24 Jan 2019 13:48:06 +0100
-Subject: [PATCH] mtd: spinand: Add support for GigaDevice GD5F1GQ4UExxG
-
-Add support for GigaDevice GD5F1GQ4UExxG SPI NAND chip.
-
-Signed-off-by: Stefan Roese <sr@denx.de>
-Cc: Chuanhong Guo <gch981213@gmail.com>
-Cc: Frieder Schrempf <frieder.schrempf@kontron.de>
-Cc: Miquel Raynal <miquel.raynal@bootlin.com>
-Cc: Boris Brezillon <bbrezillon@kernel.org>
-Reviewed-by: Boris Brezillon <bbrezillon@kernel.org>
-Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
----
- drivers/mtd/nand/spi/gigadevice.c | 83 +++++++++++++++++++++++++++++++++++++++
- 1 file changed, 83 insertions(+)
-
---- a/drivers/mtd/nand/spi/gigadevice.c
-+++ b/drivers/mtd/nand/spi/gigadevice.c
-@@ -12,6 +12,8 @@
- #define GD5FXGQ4XA_STATUS_ECC_1_7_BITFLIPS	(1 << 4)
- #define GD5FXGQ4XA_STATUS_ECC_8_BITFLIPS	(3 << 4)
- 
-+#define GD5FXGQ4UEXXG_REG_STATUS2		0xf0
-+
- static SPINAND_OP_VARIANTS(read_cache_variants,
- 		SPINAND_PAGE_READ_FROM_CACHE_QUADIO_OP(0, 2, NULL, 0),
- 		SPINAND_PAGE_READ_FROM_CACHE_X4_OP(0, 1, NULL, 0),
-@@ -81,11 +83,83 @@ static int gd5fxgq4xa_ecc_get_status(str
- 	return -EINVAL;
- }
- 
-+static int gd5fxgq4uexxg_ooblayout_ecc(struct mtd_info *mtd, int section,
-+				       struct mtd_oob_region *region)
-+{
-+	if (section)
-+		return -ERANGE;
-+
-+	region->offset = 64;
-+	region->length = 64;
-+
-+	return 0;
-+}
-+
-+static int gd5fxgq4uexxg_ooblayout_free(struct mtd_info *mtd, int section,
-+					struct mtd_oob_region *region)
-+{
-+	if (section)
-+		return -ERANGE;
-+
-+	/* Reserve 1 bytes for the BBM. */
-+	region->offset = 1;
-+	region->length = 63;
-+
-+	return 0;
-+}
-+
-+static int gd5fxgq4uexxg_ecc_get_status(struct spinand_device *spinand,
-+					u8 status)
-+{
-+	u8 status2;
-+	struct spi_mem_op op = SPINAND_GET_FEATURE_OP(GD5FXGQ4UEXXG_REG_STATUS2,
-+						      &status2);
-+	int ret;
-+
-+	switch (status & STATUS_ECC_MASK) {
-+	case STATUS_ECC_NO_BITFLIPS:
-+		return 0;
-+
-+	case GD5FXGQ4XA_STATUS_ECC_1_7_BITFLIPS:
-+		/*
-+		 * Read status2 register to determine a more fine grained
-+		 * bit error status
-+		 */
-+		ret = spi_mem_exec_op(spinand->spimem, &op);
-+		if (ret)
-+			return ret;
-+
-+		/*
-+		 * 4 ... 7 bits are flipped (1..4 can't be detected, so
-+		 * report the maximum of 4 in this case
-+		 */
-+		/* bits sorted this way (3...0): ECCS1,ECCS0,ECCSE1,ECCSE0 */
-+		return ((status & STATUS_ECC_MASK) >> 2) |
-+			((status2 & STATUS_ECC_MASK) >> 4);
-+
-+	case GD5FXGQ4XA_STATUS_ECC_8_BITFLIPS:
-+		return 8;
-+
-+	case STATUS_ECC_UNCOR_ERROR:
-+		return -EBADMSG;
-+
-+	default:
-+		break;
-+	}
-+
-+	return -EINVAL;
-+}
-+
- static const struct mtd_ooblayout_ops gd5fxgq4xa_ooblayout = {
- 	.ecc = gd5fxgq4xa_ooblayout_ecc,
- 	.free = gd5fxgq4xa_ooblayout_free,
- };
- 
-+static const struct mtd_ooblayout_ops gd5fxgq4uexxg_ooblayout = {
-+	.ecc = gd5fxgq4uexxg_ooblayout_ecc,
-+	.free = gd5fxgq4uexxg_ooblayout_free,
-+};
-+
- static const struct spinand_info gigadevice_spinand_table[] = {
- 	SPINAND_INFO("GD5F1GQ4xA", 0xF1,
- 		     NAND_MEMORG(1, 2048, 64, 64, 1024, 1, 1, 1),
-@@ -114,6 +188,15 @@ static const struct spinand_info gigadev
- 		     0,
- 		     SPINAND_ECCINFO(&gd5fxgq4xa_ooblayout,
- 				     gd5fxgq4xa_ecc_get_status)),
-+	SPINAND_INFO("GD5F1GQ4UExxG", 0xd1,
-+		     NAND_MEMORG(1, 2048, 128, 64, 1024, 1, 1, 1),
-+		     NAND_ECCREQ(8, 512),
-+		     SPINAND_INFO_OP_VARIANTS(&read_cache_variants,
-+					      &write_cache_variants,
-+					      &update_cache_variants),
-+		     0,
-+		     SPINAND_ECCINFO(&gd5fxgq4uexxg_ooblayout,
-+				     gd5fxgq4uexxg_ecc_get_status)),
- };
- 
- static int gigadevice_spinand_detect(struct spinand_device *spinand)
--- a/target/linux/generic/backport-4.19/460-v5.0-mtd-spi-nor-Add-support-for-mx25u12835f.patch	2022-03-22 08:54:47.072464444 +0800
+++ b/target/linux/generic/backport-4.19/460-v5.0-mtd-spi-nor-Add-support-for-mx25u12835f.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,25 +0,0 @@
-From 81554171373018b83f3554b9e725d2b5bf1844a5 Mon Sep 17 00:00:00 2001
-From: Alexander Sverdlin <alexander.sverdlin@nokia.com>
-Date: Fri, 13 Jul 2018 15:06:46 +0200
-Subject: [PATCH] mtd: spi-nor: Add support for mx25u12835f
-
-This chip supports dual and quad read and uniform 4K-byte erase.
-
-Signed-off-by: Alexander Sverdlin <alexander.sverdlin@nokia.com>
-Reviewed-by: Tudor Ambarus <tudor.ambarus@microchip.com>
-Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
----
- drivers/mtd/spi-nor/spi-nor.c | 2 ++
- 1 file changed, 2 insertions(+)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -1088,6 +1088,8 @@ static const struct flash_info spi_nor_i
- 	{ "mx25u6435f",  INFO(0xc22537, 0, 64 * 1024, 128, SECT_4K) },
- 	{ "mx25l12805d", INFO(0xc22018, 0, 64 * 1024, 256, 0) },
- 	{ "mx25l12855e", INFO(0xc22618, 0, 64 * 1024, 256, 0) },
-+	{ "mx25u12835f", INFO(0xc22538, 0, 64 * 1024, 256,
-+			 SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
- 	{ "mx25l25635e", INFO(0xc22019, 0, 64 * 1024, 512, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
- 	{ "mx25u25635f", INFO(0xc22539, 0, 64 * 1024, 512, SECT_4K | SPI_NOR_4B_OPCODES) },
- 	{ "mx25l25655e", INFO(0xc22619, 0, 64 * 1024, 512, 0) },
--- a/target/linux/generic/backport-4.9/010-Kbuild-don-t-hardcode-path-to-awk-in-scripts-ld-vers.patch	2022-03-22 08:54:47.073464446 +0800
+++ b/target/linux/generic/backport-4.9/010-Kbuild-don-t-hardcode-path-to-awk-in-scripts-ld-vers.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,29 +0,0 @@
-From 13b1ecc3401653a355798eb1dee10cc1608202f4 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Mon, 18 Jan 2016 12:27:49 +0100
-Subject: [PATCH 33/34] Kbuild: don't hardcode path to awk in
- scripts/ld-version.sh
-
-On some systems /usr/bin/awk does not exist, or is broken. Find it via
-$PATH instead.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- scripts/ld-version.sh | 4 +++-
- 1 file changed, 3 insertions(+), 1 deletion(-)
-
---- a/scripts/ld-version.sh
-+++ b/scripts/ld-version.sh
-@@ -1,5 +1,6 @@
--#!/usr/bin/awk -f
-+#!/bin/sh
- # extract linker version number from stdin and turn into single number
-+exec awk '
- 	{
- 	gsub(".*\\)", "");
- 	gsub(".*version ", "");
-@@ -8,3 +9,4 @@
- 	print a[1]*100000000 + a[2]*1000000 + a[3]*10000;
- 	exit
- 	}
-+'
--- a/target/linux/generic/backport-4.9/011-kbuild-export-SUBARCH.patch	2022-03-22 08:54:47.073464446 +0800
+++ b/target/linux/generic/backport-4.9/011-kbuild-export-SUBARCH.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,23 +0,0 @@
-From 173019b66dcc9d68ad9333aa744dad1e369b5aa8 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sun, 9 Jul 2017 00:26:53 +0200
-Subject: [PATCH 34/34] kernel: add compile fix for linux 4.9 on x86
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- Makefile | 4 ++--
- 1 file changed, 2 insertions(+), 2 deletions(-)
-
---- a/Makefile
-+++ b/Makefile
-@@ -407,8 +407,8 @@ KERNELRELEASE = $(shell cat include/conf
- KERNELVERSION = $(VERSION)$(if $(PATCHLEVEL),.$(PATCHLEVEL)$(if $(SUBLEVEL),.$(SUBLEVEL)))$(EXTRAVERSION)
- 
- export VERSION PATCHLEVEL SUBLEVEL KERNELRELEASE KERNELVERSION
--export ARCH SRCARCH CONFIG_SHELL HOSTCC HOSTCFLAGS CROSS_COMPILE AS LD CC
--export CPP AR NM STRIP OBJCOPY OBJDUMP
-+export ARCH SRCARCH SUBARCH CONFIG_SHELL HOSTCC HOSTCFLAGS CROSS_COMPILE AS LD
-+export CC CPP AR NM STRIP OBJCOPY OBJDUMP
- export MAKE AWK GENKSYMS INSTALLKERNEL PERL PYTHON UTS_MACHINE
- export HOSTCXX HOSTCXXFLAGS LDFLAGS_MODULE CHECK CHECKFLAGS
- 
--- a/target/linux/generic/backport-4.9/012-kbuild-add-macro-for-controlling-warnings-to-linux-c.patch	2022-03-22 08:54:47.073464446 +0800
+++ b/target/linux/generic/backport-4.9/012-kbuild-add-macro-for-controlling-warnings-to-linux-c.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,143 +0,0 @@
-From: Arnd Bergmann <arnd@arndb.de>
-Date: Tue, 19 Jun 2018 13:14:56 -0700
-Subject: [PATCH] kbuild: add macro for controlling warnings to
- linux/compiler.h
-
-I have occasionally run into a situation where it would make sense to
-control a compiler warning from a source file rather than doing so from
-a Makefile using the $(cc-disable-warning, ...) or $(cc-option, ...)
-helpers.
-
-The approach here is similar to what glibc uses, using __diag() and
-related macros to encapsulate a _Pragma("GCC diagnostic ...") statement
-that gets turned into the respective "#pragma GCC diagnostic ..." by
-the preprocessor when the macro gets expanded.
-
-Like glibc, I also have an argument to pass the affected compiler
-version, but decided to actually evaluate that one. For now, this
-supports GCC_4_6, GCC_4_7, GCC_4_8, GCC_4_9, GCC_5, GCC_6, GCC_7,
-GCC_8 and GCC_9. Adding support for CLANG_5 and other interesting
-versions is straightforward here. GNU compilers starting with gcc-4.2
-could support it in principle, but "#pragma GCC diagnostic push"
-was only added in gcc-4.6, so it seems simpler to not deal with those
-at all. The same versions show a large number of warnings already,
-so it seems easier to just leave it at that and not do a more
-fine-grained control for them.
-
-The use cases I found so far include:
-
-- turning off the gcc-8 -Wattribute-alias warning inside of the
-  SYSCALL_DEFINEx() macro without having to do it globally.
-
-- Reducing the build time for a simple re-make after a change,
-  once we move the warnings from ./Makefile and
-  ./scripts/Makefile.extrawarn into linux/compiler.h
-
-- More control over the warnings based on other configurations,
-  using preprocessor syntax instead of Makefile syntax. This should make
-  it easier for the average developer to understand and change things.
-
-- Adding an easy way to turn the W=1 option on unconditionally
-  for a subdirectory or a specific file. This has been requested
-  by several developers in the past that want to have their subsystems
-  W=1 clean.
-
-- Integrating clang better into the build systems. Clang supports
-  more warnings than GCC, and we probably want to classify them
-  as default, W=1, W=2 etc, but there are cases in which the
-  warnings should be classified differently due to excessive false
-  positives from one or the other compiler.
-
-- Adding a way to turn the default warnings into errors (e.g. using
-  a new "make E=0" tag) while not also turning the W=1 warnings into
-  errors.
-
-This patch for now just adds the minimal infrastructure in order to
-do the first of the list above. As the #pragma GCC diagnostic
-takes precedence over command line options, the next step would be
-to convert a lot of the individual Makefiles that set nonstandard
-options to use __diag() instead.
-
-[paul.burton@mips.com:
-  - Rebase atop current master.
-  - Add __diag_GCC, or more generally __diag_<compiler>, abstraction to
-    avoid code outside of linux/compiler-gcc.h needing to duplicate
-    knowledge about different GCC versions.
-  - Add a comment argument to __diag_{ignore,warn,error} which isn't
-    used in the expansion of the macros but serves to push people to
-    document the reason for using them - per feedback from Kees Cook.
-  - Translate severity to GCC-specific pragmas in linux/compiler-gcc.h
-    rather than using GCC-specific in linux/compiler_types.h.
-  - Drop all but GCC 8 macros, since we only need to define macros for
-    versions that we need to introduce pragmas for, and as of this
-    series that's just GCC 8.
-  - Capitalize comments in linux/compiler-gcc.h to match the style of
-    the rest of the file.
-  - Line up macro definitions with tabs in linux/compiler-gcc.h.]
-
-Signed-off-by: Arnd Bergmann <arnd@arndb.de>
-Signed-off-by: Paul Burton <paul.burton@mips.com>
-Tested-by: Christophe Leroy <christophe.leroy@c-s.fr>
-Tested-by: Stafford Horne <shorne@gmail.com>
-Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
----
-
---- a/include/linux/compiler-gcc.h
-+++ b/include/linux/compiler-gcc.h
-@@ -351,3 +351,30 @@
- #if GCC_VERSION >= 50100
- #define COMPILER_HAS_GENERIC_BUILTIN_OVERFLOW 1
- #endif
-+
-+
-+/*
-+ * Turn individual warnings and errors on and off locally, depending
-+ * on version.
-+ */
-+#define __diag_GCC(version, severity, s) \
-+	__diag_GCC_ ## version(__diag_GCC_ ## severity s)
-+
-+/* Severity used in pragma directives */
-+#define __diag_GCC_ignore	ignored
-+#define __diag_GCC_warn		warning
-+#define __diag_GCC_error	error
-+
-+/* Compilers before gcc-4.6 do not understand "#pragma GCC diagnostic push" */
-+#if GCC_VERSION >= 40600
-+#define __diag_str1(s)		#s
-+#define __diag_str(s)		__diag_str1(s)
-+#define __diag(s)		_Pragma(__diag_str(GCC diagnostic s))
-+#endif
-+
-+#if GCC_VERSION >= 80000
-+#define __diag_GCC_8(s)		__diag(s)
-+#else
-+#define __diag_GCC_8(s)
-+#endif
-+
---- a/include/linux/compiler.h
-+++ b/include/linux/compiler.h
-@@ -605,4 +605,23 @@ unsigned long read_word_at_a_time(const
- # define __kprobes
- # define nokprobe_inline	inline
- #endif
-+
-+#ifndef __diag
-+#define __diag(string)
-+#endif
-+
-+#ifndef __diag_GCC
-+#define __diag_GCC(version, severity, string)
-+#endif
-+
-+#define __diag_push()	__diag(push)
-+#define __diag_pop()	__diag(pop)
-+
-+#define __diag_ignore(compiler, version, option, comment) \
-+	__diag_ ## compiler(version, ignore, option)
-+#define __diag_warn(compiler, version, option, comment) \
-+	__diag_ ## compiler(version, warn, option)
-+#define __diag_error(compiler, version, option, comment) \
-+	__diag_ ## compiler(version, error, option)
-+
- #endif /* __LINUX_COMPILER_H */
--- a/target/linux/generic/backport-4.9/013-disable-Wattribute-alias-warning-for-SYSCALL_DEFINEx.patch	2022-03-22 08:54:47.074464448 +0800
+++ b/target/linux/generic/backport-4.9/013-disable-Wattribute-alias-warning-for-SYSCALL_DEFINEx.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,88 +0,0 @@
-From: Arnd Bergmann <arnd@arndb.de>
-Date: Tue, 19 Jun 2018 13:14:57 -0700
-Subject: [PATCH] disable -Wattribute-alias warning for SYSCALL_DEFINEx()
-
-gcc-8 warns for every single definition of a system call entry
-point, e.g.:
-
-include/linux/compat.h:56:18: error: 'compat_sys_rt_sigprocmask' alias between functions of incompatible types 'long int(int,  compat_sigset_t *, compat_sigset_t *, compat_size_t)' {aka 'long int(int,  struct <anonymous> *, struct <anonymous> *, unsigned int)'} and 'long int(long int,  long int,  long int,  long int)' [-Werror=attribute-alias]
-  asmlinkage long compat_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))\
-                  ^~~~~~~~~~
-include/linux/compat.h:45:2: note: in expansion of macro 'COMPAT_SYSCALL_DEFINEx'
-  COMPAT_SYSCALL_DEFINEx(4, _##name, __VA_ARGS__)
-  ^~~~~~~~~~~~~~~~~~~~~~
-kernel/signal.c:2601:1: note: in expansion of macro 'COMPAT_SYSCALL_DEFINE4'
- COMPAT_SYSCALL_DEFINE4(rt_sigprocmask, int, how, compat_sigset_t __user *, nset,
- ^~~~~~~~~~~~~~~~~~~~~~
-include/linux/compat.h:60:18: note: aliased declaration here
-  asmlinkage long compat_SyS##name(__MAP(x,__SC_LONG,__VA_ARGS__))\
-                  ^~~~~~~~~~
-
-The new warning seems reasonable in principle, but it doesn't
-help us here, since we rely on the type mismatch to sanitize the
-system call arguments. After I reported this as GCC PR82435, a new
--Wno-attribute-alias option was added that could be used to turn the
-warning off globally on the command line, but I'd prefer to do it a
-little more fine-grained.
-
-Interestingly, turning a warning off and on again inside of
-a single macro doesn't always work, in this case I had to add
-an extra statement inbetween and decided to copy the __SC_TEST
-one from the native syscall to the compat syscall macro.  See
-https://gcc.gnu.org/bugzilla/show_bug.cgi?id=83256 for more details
-about this.
-
-[paul.burton@mips.com:
-  - Rebase atop current master.
-  - Split GCC & version arguments to __diag_ignore() in order to match
-    changes to the preceding patch.
-  - Add the comment argument to match the preceding patch.]
-
-Link: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=82435
-Signed-off-by: Arnd Bergmann <arnd@arndb.de>
-Signed-off-by: Paul Burton <paul.burton@mips.com>
-Tested-by: Christophe Leroy <christophe.leroy@c-s.fr>
-Tested-by: Stafford Horne <shorne@gmail.com>
-Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
----
-
---- a/include/linux/compat.h
-+++ b/include/linux/compat.h
-@@ -47,6 +47,9 @@
- 	COMPAT_SYSCALL_DEFINEx(6, _##name, __VA_ARGS__)
- 
- #define COMPAT_SYSCALL_DEFINEx(x, name, ...)				\
-+	__diag_push();							\
-+	__diag_ignore(GCC, 8, "-Wattribute-alias",			\
-+		      "Type aliasing is used to sanitize syscall arguments");\
- 	asmlinkage long compat_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))\
- 		__attribute__((alias(__stringify(compat_SyS##name))));  \
- 	static inline long C_SYSC##name(__MAP(x,__SC_DECL,__VA_ARGS__));\
-@@ -55,6 +58,7 @@
- 	{								\
- 		return C_SYSC##name(__MAP(x,__SC_DELOUSE,__VA_ARGS__));	\
- 	}								\
-+	__diag_pop();							\
- 	static inline long C_SYSC##name(__MAP(x,__SC_DECL,__VA_ARGS__))
- 
- #ifndef compat_user_stack_pointer
---- a/include/linux/syscalls.h
-+++ b/include/linux/syscalls.h
-@@ -192,6 +192,9 @@ extern struct trace_event_functions exit
- 
- #define __PROTECT(...) asmlinkage_protect(__VA_ARGS__)
- #define __SYSCALL_DEFINEx(x, name, ...)					\
-+	__diag_push();							\
-+	__diag_ignore(GCC, 8, "-Wattribute-alias",			\
-+		      "Type aliasing is used to sanitize syscall arguments");\
- 	asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))	\
- 		__attribute__((alias(__stringify(SyS##name))));		\
- 	static inline long SYSC##name(__MAP(x,__SC_DECL,__VA_ARGS__));	\
-@@ -203,6 +206,7 @@ extern struct trace_event_functions exit
- 		__PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));	\
- 		return ret;						\
- 	}								\
-+	__diag_pop();							\
- 	static inline long SYSC##name(__MAP(x,__SC_DECL,__VA_ARGS__))
- 
- asmlinkage long sys32_quotactl(unsigned int cmd, const char __user *special,
--- a/target/linux/generic/backport-4.9/020-backport_netfilter_rtcache.patch	2022-03-22 08:54:47.074464448 +0800
+++ b/target/linux/generic/backport-4.9/020-backport_netfilter_rtcache.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,543 +0,0 @@
-From c4d66e57455f5384128753674cc0f9e02db5e1f6 Mon Sep 17 00:00:00 2001
-From: Florian Westphal <fw@strlen.de>
-Date: Sun, 9 Jul 2017 08:58:30 +0200
-Subject: [PATCH] netfilter: conntrack: cache route for forwarded connections
-
-... to avoid per-packet FIB lookup if possible.
-
-The cached dst is re-used provided the input interface
-is the same as that of the previous packet in the same direction.
-
-If not, the cached dst is invalidated.
-
-For ipv6 we also need to store sernum, else dst_check doesn't work,
-pointed out by Eric Dumazet.
-
-This should speed up forwarding when conntrack is already in use
-anyway, especially when using reverse path filtering -- active RPF
-enforces two FIB lookups for each packet.
-
-Before the routing cache removal this didn't matter since RPF was performed
-only when route cache didn't yield a result; but without route cache it
-comes at higher price.
-
-Julian Anastasov suggested to add NETDEV_UNREGISTER handler to
-avoid holding on to dsts of 'frozen' conntracks.
-
-Signed-off-by: Florian Westphal <fw@strlen.de>
----
- include/net/netfilter/nf_conntrack_extend.h  |   4 +
- include/net/netfilter/nf_conntrack_rtcache.h |  34 +++
- net/netfilter/Kconfig                        |  12 +
- net/netfilter/Makefile                       |   3 +
- net/netfilter/nf_conntrack_rtcache.c         | 413 +++++++++++++++++++++++++++
- 5 files changed, 466 insertions(+)
- create mode 100644 include/net/netfilter/nf_conntrack_rtcache.h
- create mode 100644 net/netfilter/nf_conntrack_rtcache.c
-
---- a/include/net/netfilter/nf_conntrack_extend.h
-+++ b/include/net/netfilter/nf_conntrack_extend.h
-@@ -27,6 +27,9 @@ enum nf_ct_ext_id {
- #if IS_ENABLED(CONFIG_NETFILTER_SYNPROXY)
- 	NF_CT_EXT_SYNPROXY,
- #endif
-+#if IS_ENABLED(CONFIG_NF_CONNTRACK_RTCACHE)
-+	NF_CT_EXT_RTCACHE,
-+#endif
- 	NF_CT_EXT_NUM,
- };
- 
-@@ -39,6 +42,7 @@ enum nf_ct_ext_id {
- #define NF_CT_EXT_TIMEOUT_TYPE struct nf_conn_timeout
- #define NF_CT_EXT_LABELS_TYPE struct nf_conn_labels
- #define NF_CT_EXT_SYNPROXY_TYPE struct nf_conn_synproxy
-+#define NF_CT_EXT_RTCACHE_TYPE struct nf_conn_rtcache
- 
- /* Extensions: optional stuff which isn't permanently in struct. */
- struct nf_ct_ext {
---- /dev/null
-+++ b/include/net/netfilter/nf_conntrack_rtcache.h
-@@ -0,0 +1,34 @@
-+#include <linux/gfp.h>
-+#include <net/netfilter/nf_conntrack.h>
-+#include <net/netfilter/nf_conntrack_extend.h>
-+
-+struct dst_entry;
-+
-+struct nf_conn_dst_cache {
-+	struct dst_entry *dst;
-+	int iif;
-+#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
-+	u32 cookie;
-+#endif
-+
-+};
-+
-+struct nf_conn_rtcache {
-+	struct nf_conn_dst_cache cached_dst[IP_CT_DIR_MAX];
-+};
-+
-+static inline
-+struct nf_conn_rtcache *nf_ct_rtcache_find(const struct nf_conn *ct)
-+{
-+#if IS_ENABLED(CONFIG_NF_CONNTRACK_RTCACHE)
-+	return nf_ct_ext_find(ct, NF_CT_EXT_RTCACHE);
-+#else
-+	return NULL;
-+#endif
-+}
-+
-+static inline int nf_conn_rtcache_iif_get(const struct nf_conn_rtcache *rtc,
-+					  enum ip_conntrack_dir dir)
-+{
-+	return rtc->cached_dst[dir].iif;
-+}
---- a/net/netfilter/Kconfig
-+++ b/net/netfilter/Kconfig
-@@ -114,6 +114,18 @@ config NF_CONNTRACK_EVENTS
- 
- 	  If unsure, say `N'.
- 
-+config NF_CONNTRACK_RTCACHE
-+	tristate "Cache route entries in conntrack objects"
-+	depends on NETFILTER_ADVANCED
-+	depends on NF_CONNTRACK
-+	help
-+	  If this option is enabled, the connection tracking code will
-+	  cache routing information for each connection that is being
-+	  forwarded, at a cost of 32 bytes per conntrack object.
-+
-+	  To compile it as a module, choose M here.  If unsure, say N.
-+	  The module will be called nf_conntrack_rtcache.
-+
- config NF_CONNTRACK_TIMEOUT
- 	bool  'Connection tracking timeout'
- 	depends on NETFILTER_ADVANCED
---- a/net/netfilter/Makefile
-+++ b/net/netfilter/Makefile
-@@ -16,6 +16,9 @@ obj-$(CONFIG_NETFILTER_NETLINK_LOG) += n
- # connection tracking
- obj-$(CONFIG_NF_CONNTRACK) += nf_conntrack.o
- 
-+# optional conntrack route cache extension
-+obj-$(CONFIG_NF_CONNTRACK_RTCACHE) += nf_conntrack_rtcache.o
-+
- # SCTP protocol connection tracking
- obj-$(CONFIG_NF_CT_PROTO_DCCP) += nf_conntrack_proto_dccp.o
- obj-$(CONFIG_NF_CT_PROTO_GRE) += nf_conntrack_proto_gre.o
---- /dev/null
-+++ b/net/netfilter/nf_conntrack_rtcache.c
-@@ -0,0 +1,413 @@
-+/* route cache for netfilter.
-+ *
-+ * (C) 2014 Red Hat GmbH
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License version 2 as
-+ * published by the Free Software Foundation.
-+ */
-+
-+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-+
-+#include <linux/types.h>
-+#include <linux/netfilter.h>
-+#include <linux/skbuff.h>
-+#include <linux/stddef.h>
-+#include <linux/kernel.h>
-+#include <linux/netdevice.h>
-+#include <linux/export.h>
-+#include <linux/module.h>
-+
-+#include <net/dst.h>
-+
-+#include <net/netfilter/nf_conntrack.h>
-+#include <net/netfilter/nf_conntrack_core.h>
-+#include <net/netfilter/nf_conntrack_extend.h>
-+#include <net/netfilter/nf_conntrack_rtcache.h>
-+
-+#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
-+#include <net/ip6_fib.h>
-+#endif
-+
-+static void __nf_conn_rtcache_destroy(struct nf_conn_rtcache *rtc,
-+				      enum ip_conntrack_dir dir)
-+{
-+	struct dst_entry *dst = rtc->cached_dst[dir].dst;
-+
-+	dst_release(dst);
-+}
-+
-+static void nf_conn_rtcache_destroy(struct nf_conn *ct)
-+{
-+	struct nf_conn_rtcache *rtc = nf_ct_rtcache_find(ct);
-+
-+	if (!rtc)
-+		return;
-+
-+	__nf_conn_rtcache_destroy(rtc, IP_CT_DIR_ORIGINAL);
-+	__nf_conn_rtcache_destroy(rtc, IP_CT_DIR_REPLY);
-+}
-+
-+static void nf_ct_rtcache_ext_add(struct nf_conn *ct)
-+{
-+	struct nf_conn_rtcache *rtc;
-+
-+	rtc = nf_ct_ext_add(ct, NF_CT_EXT_RTCACHE, GFP_ATOMIC);
-+	if (rtc) {
-+		rtc->cached_dst[IP_CT_DIR_ORIGINAL].iif = -1;
-+		rtc->cached_dst[IP_CT_DIR_ORIGINAL].dst = NULL;
-+		rtc->cached_dst[IP_CT_DIR_REPLY].iif = -1;
-+		rtc->cached_dst[IP_CT_DIR_REPLY].dst = NULL;
-+	}
-+}
-+
-+static struct nf_conn_rtcache *nf_ct_rtcache_find_usable(struct nf_conn *ct)
-+{
-+	if (nf_ct_is_untracked(ct))
-+		return NULL;
-+	return nf_ct_rtcache_find(ct);
-+}
-+
-+static struct dst_entry *
-+nf_conn_rtcache_dst_get(const struct nf_conn_rtcache *rtc,
-+			enum ip_conntrack_dir dir)
-+{
-+	return rtc->cached_dst[dir].dst;
-+}
-+
-+static u32 nf_rtcache_get_cookie(int pf, const struct dst_entry *dst)
-+{
-+#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
-+	if (pf == NFPROTO_IPV6) {
-+		const struct rt6_info *rt = (const struct rt6_info *)dst;
-+
-+		if (rt->rt6i_node)
-+			return (u32)rt->rt6i_node->fn_sernum;
-+	}
-+#endif
-+	return 0;
-+}
-+
-+static void nf_conn_rtcache_dst_set(int pf,
-+				    struct nf_conn_rtcache *rtc,
-+				    struct dst_entry *dst,
-+				    enum ip_conntrack_dir dir, int iif)
-+{
-+	if (rtc->cached_dst[dir].iif != iif)
-+		rtc->cached_dst[dir].iif = iif;
-+
-+	if (rtc->cached_dst[dir].dst != dst) {
-+		struct dst_entry *old;
-+
-+		dst_hold(dst);
-+
-+		old = xchg(&rtc->cached_dst[dir].dst, dst);
-+		dst_release(old);
-+
-+#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
-+		if (pf == NFPROTO_IPV6)
-+			rtc->cached_dst[dir].cookie =
-+				nf_rtcache_get_cookie(pf, dst);
-+#endif
-+	}
-+}
-+
-+static void nf_conn_rtcache_dst_obsolete(struct nf_conn_rtcache *rtc,
-+					 enum ip_conntrack_dir dir)
-+{
-+	struct dst_entry *old;
-+
-+	pr_debug("Invalidate iif %d for dir %d on cache %p\n",
-+		 rtc->cached_dst[dir].iif, dir, rtc);
-+
-+	old = xchg(&rtc->cached_dst[dir].dst, NULL);
-+	dst_release(old);
-+	rtc->cached_dst[dir].iif = -1;
-+}
-+
-+static unsigned int nf_rtcache_in(u_int8_t pf,
-+				  struct sk_buff *skb,
-+				  const struct nf_hook_state *state)
-+{
-+	struct nf_conn_rtcache *rtc;
-+	enum ip_conntrack_info ctinfo;
-+	enum ip_conntrack_dir dir;
-+	struct dst_entry *dst;
-+	struct nf_conn *ct;
-+	int iif;
-+	u32 cookie;
-+
-+	if (skb_dst(skb) || skb->sk)
-+		return NF_ACCEPT;
-+
-+	ct = nf_ct_get(skb, &ctinfo);
-+	if (!ct)
-+		return NF_ACCEPT;
-+
-+	rtc = nf_ct_rtcache_find_usable(ct);
-+	if (!rtc)
-+		return NF_ACCEPT;
-+
-+	/* if iif changes, don't use cache and let ip stack
-+	 * do route lookup.
-+	 *
-+	 * If rp_filter is enabled it might toss skb, so
-+	 * we don't want to avoid these checks.
-+	 */
-+	dir = CTINFO2DIR(ctinfo);
-+	iif = nf_conn_rtcache_iif_get(rtc, dir);
-+	if (state->in->ifindex != iif) {
-+		pr_debug("ct %p, iif %d, cached iif %d, skip cached entry\n",
-+			 ct, iif, state->in->ifindex);
-+		return NF_ACCEPT;
-+	}
-+	dst = nf_conn_rtcache_dst_get(rtc, dir);
-+	if (dst == NULL)
-+		return NF_ACCEPT;
-+
-+	cookie = nf_rtcache_get_cookie(pf, dst);
-+
-+	dst = dst_check(dst, cookie);
-+	pr_debug("obtained dst %p for skb %p, cookie %d\n", dst, skb, cookie);
-+	if (likely(dst))
-+		skb_dst_set_noref(skb, dst);
-+	else
-+		nf_conn_rtcache_dst_obsolete(rtc, dir);
-+
-+	return NF_ACCEPT;
-+}
-+
-+static unsigned int nf_rtcache_forward(u_int8_t pf,
-+				       struct sk_buff *skb,
-+				       const struct nf_hook_state *state)
-+{
-+	struct nf_conn_rtcache *rtc;
-+	enum ip_conntrack_info ctinfo;
-+	enum ip_conntrack_dir dir;
-+	struct nf_conn *ct;
-+	struct dst_entry *dst = skb_dst(skb);
-+	int iif;
-+
-+	ct = nf_ct_get(skb, &ctinfo);
-+	if (!ct)
-+		return NF_ACCEPT;
-+
-+	if (dst && dst_xfrm(dst))
-+		return NF_ACCEPT;
-+
-+	if (!nf_ct_is_confirmed(ct)) {
-+		if (WARN_ON(nf_ct_rtcache_find(ct)))
-+			return NF_ACCEPT;
-+		nf_ct_rtcache_ext_add(ct);
-+		return NF_ACCEPT;
-+	}
-+
-+	rtc = nf_ct_rtcache_find_usable(ct);
-+	if (!rtc)
-+		return NF_ACCEPT;
-+
-+	dir = CTINFO2DIR(ctinfo);
-+	iif = nf_conn_rtcache_iif_get(rtc, dir);
-+	pr_debug("ct %p, skb %p, dir %d, iif %d, cached iif %d\n",
-+		 ct, skb, dir, iif, state->in->ifindex);
-+	if (likely(state->in->ifindex == iif))
-+		return NF_ACCEPT;
-+
-+	nf_conn_rtcache_dst_set(pf, rtc, skb_dst(skb), dir, state->in->ifindex);
-+	return NF_ACCEPT;
-+}
-+
-+static unsigned int nf_rtcache_in4(void *priv,
-+				  struct sk_buff *skb,
-+				  const struct nf_hook_state *state)
-+{
-+	return nf_rtcache_in(NFPROTO_IPV4, skb, state);
-+}
-+
-+static unsigned int nf_rtcache_forward4(void *priv,
-+				       struct sk_buff *skb,
-+				       const struct nf_hook_state *state)
-+{
-+	return nf_rtcache_forward(NFPROTO_IPV4, skb, state);
-+}
-+
-+#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
-+static unsigned int nf_rtcache_in6(void *priv,
-+				  struct sk_buff *skb,
-+				  const struct nf_hook_state *state)
-+{
-+	return nf_rtcache_in(NFPROTO_IPV6, skb, state);
-+}
-+
-+static unsigned int nf_rtcache_forward6(void *priv,
-+				       struct sk_buff *skb,
-+				       const struct nf_hook_state *state)
-+{
-+ 	return nf_rtcache_forward(NFPROTO_IPV6, skb, state);
-+}
-+#endif
-+
-+static int nf_rtcache_dst_remove(struct nf_conn *ct, void *data)
-+{
-+	struct nf_conn_rtcache *rtc = nf_ct_rtcache_find(ct);
-+	struct net_device *dev = data;
-+
-+	if (!rtc)
-+		return 0;
-+
-+	if (dev->ifindex == rtc->cached_dst[IP_CT_DIR_ORIGINAL].iif ||
-+	    dev->ifindex == rtc->cached_dst[IP_CT_DIR_REPLY].iif) {
-+		nf_conn_rtcache_dst_obsolete(rtc, IP_CT_DIR_ORIGINAL);
-+		nf_conn_rtcache_dst_obsolete(rtc, IP_CT_DIR_REPLY);
-+	}
-+
-+	return 0;
-+}
-+
-+static int nf_rtcache_netdev_event(struct notifier_block *this,
-+				   unsigned long event, void *ptr)
-+{
-+	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
-+	struct net *net = dev_net(dev);
-+
-+	if (event == NETDEV_DOWN)
-+		nf_ct_iterate_cleanup(net, nf_rtcache_dst_remove, dev, 0, 0);
-+
-+	return NOTIFY_DONE;
-+}
-+
-+static struct notifier_block nf_rtcache_notifier = {
-+	.notifier_call = nf_rtcache_netdev_event,
-+};
-+
-+static struct nf_hook_ops rtcache_ops[] = {
-+	{
-+		.hook		= nf_rtcache_in4,
-+		.pf		= NFPROTO_IPV4,
-+		.hooknum	= NF_INET_PRE_ROUTING,
-+		.priority       = NF_IP_PRI_LAST,
-+	},
-+	{
-+		.hook           = nf_rtcache_forward4,
-+		.pf             = NFPROTO_IPV4,
-+		.hooknum        = NF_INET_FORWARD,
-+		.priority       = NF_IP_PRI_LAST,
-+	},
-+#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
-+	{
-+		.hook		= nf_rtcache_in6,
-+		.pf		= NFPROTO_IPV6,
-+		.hooknum	= NF_INET_PRE_ROUTING,
-+		.priority       = NF_IP_PRI_LAST,
-+	},
-+	{
-+		.hook           = nf_rtcache_forward6,
-+		.pf             = NFPROTO_IPV6,
-+		.hooknum        = NF_INET_FORWARD,
-+		.priority       = NF_IP_PRI_LAST,
-+	},
-+#endif
-+};
-+
-+static struct nf_ct_ext_type rtcache_extend __read_mostly = {
-+	.len	= sizeof(struct nf_conn_rtcache),
-+	.align	= __alignof__(struct nf_conn_rtcache),
-+	.id	= NF_CT_EXT_RTCACHE,
-+	.destroy = nf_conn_rtcache_destroy,
-+};
-+
-+static int __init nf_conntrack_rtcache_init(void)
-+{
-+	int ret = nf_ct_extend_register(&rtcache_extend);
-+
-+	if (ret < 0) {
-+		pr_err("nf_conntrack_rtcache: Unable to register extension\n");
-+		return ret;
-+	}
-+
-+	ret = nf_register_hooks(rtcache_ops, ARRAY_SIZE(rtcache_ops));
-+	if (ret < 0) {
-+		nf_ct_extend_unregister(&rtcache_extend);
-+		return ret;
-+	}
-+
-+	ret = register_netdevice_notifier(&nf_rtcache_notifier);
-+	if (ret) {
-+		nf_unregister_hooks(rtcache_ops, ARRAY_SIZE(rtcache_ops));
-+		nf_ct_extend_unregister(&rtcache_extend);
-+	}
-+
-+	return ret;
-+}
-+
-+static int nf_rtcache_ext_remove(struct nf_conn *ct, void *data)
-+{
-+	struct nf_conn_rtcache *rtc = nf_ct_rtcache_find(ct);
-+
-+	return rtc != NULL;
-+}
-+
-+static bool __exit nf_conntrack_rtcache_wait_for_dying(struct net *net)
-+{
-+	bool wait = false;
-+	int cpu;
-+
-+	for_each_possible_cpu(cpu) {
-+		struct nf_conntrack_tuple_hash *h;
-+		struct hlist_nulls_node *n;
-+		struct nf_conn *ct;
-+		struct ct_pcpu *pcpu = per_cpu_ptr(net->ct.pcpu_lists, cpu);
-+
-+		rcu_read_lock();
-+		spin_lock_bh(&pcpu->lock);
-+
-+		hlist_nulls_for_each_entry(h, n, &pcpu->dying, hnnode) {
-+			ct = nf_ct_tuplehash_to_ctrack(h);
-+			if (nf_ct_rtcache_find(ct) != NULL) {
-+				wait = true;
-+				break;
-+			}
-+		}
-+		spin_unlock_bh(&pcpu->lock);
-+		rcu_read_unlock();
-+	}
-+
-+	return wait;
-+}
-+
-+static void __exit nf_conntrack_rtcache_fini(void)
-+{
-+	struct net *net;
-+	int count = 0;
-+
-+	/* remove hooks so no new connections get rtcache extension */
-+	nf_unregister_hooks(rtcache_ops, ARRAY_SIZE(rtcache_ops));
-+
-+	synchronize_net();
-+
-+	unregister_netdevice_notifier(&nf_rtcache_notifier);
-+
-+	rtnl_lock();
-+
-+	/* zap all conntracks with rtcache extension */
-+	for_each_net(net)
-+		nf_ct_iterate_cleanup(net, nf_rtcache_ext_remove, NULL, 0, 0);
-+
-+	for_each_net(net) {
-+		/* .. and make sure they're gone from dying list, too */
-+		while (nf_conntrack_rtcache_wait_for_dying(net)) {
-+			msleep(200);
-+			WARN_ONCE(++count > 25, "Waiting for all rtcache conntracks to go away\n");
-+		}
-+	}
-+
-+	rtnl_unlock();
-+	synchronize_net();
-+	nf_ct_extend_unregister(&rtcache_extend);
-+}
-+module_init(nf_conntrack_rtcache_init);
-+module_exit(nf_conntrack_rtcache_fini);
-+
-+MODULE_LICENSE("GPL");
-+MODULE_AUTHOR("Florian Westphal <fw@strlen.de>");
-+MODULE_DESCRIPTION("Conntrack route cache extension");
--- a/target/linux/generic/backport-4.9/021-bridge-multicast-to-unicast.patch	2022-03-22 08:54:47.075464449 +0800
+++ b/target/linux/generic/backport-4.9/021-bridge-multicast-to-unicast.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,499 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Thu, 19 Jan 2017 03:45:10 +0100
-Subject: [PATCH] bridge: multicast to unicast
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Implements an optional, per bridge port flag and feature to deliver
-multicast packets to any host on the according port via unicast
-individually. This is done by copying the packet per host and
-changing the multicast destination MAC to a unicast one accordingly.
-
-multicast-to-unicast works on top of the multicast snooping feature of
-the bridge. Which means unicast copies are only delivered to hosts which
-are interested in it and signalized this via IGMP/MLD reports
-previously.
-
-This feature is intended for interface types which have a more reliable
-and/or efficient way to deliver unicast packets than broadcast ones
-(e.g. wifi).
-
-However, it should only be enabled on interfaces where no IGMPv2/MLDv1
-report suppression takes place. This feature is disabled by default.
-
-The initial patch and idea is from Felix Fietkau.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
-[linus.luessing@c0d3.blue: various bug + style fixes, commit message]
-Signed-off-by: Linus Lssing <linus.luessing@c0d3.blue>
----
-
---- a/include/linux/if_bridge.h
-+++ b/include/linux/if_bridge.h
-@@ -46,6 +46,7 @@ struct br_ip_list {
- #define BR_LEARNING_SYNC	BIT(9)
- #define BR_PROXYARP_WIFI	BIT(10)
- #define BR_MCAST_FLOOD		BIT(11)
-+#define BR_MULTICAST_TO_UNICAST	BIT(12)
- 
- #define BR_DEFAULT_AGEING_TIME	(300 * HZ)
- 
---- a/include/uapi/linux/if_link.h
-+++ b/include/uapi/linux/if_link.h
-@@ -319,6 +319,7 @@ enum {
- 	IFLA_BRPORT_MULTICAST_ROUTER,
- 	IFLA_BRPORT_PAD,
- 	IFLA_BRPORT_MCAST_FLOOD,
-+	IFLA_BRPORT_MCAST_TO_UCAST,
- 	__IFLA_BRPORT_MAX
- };
- #define IFLA_BRPORT_MAX (__IFLA_BRPORT_MAX - 1)
---- a/net/bridge/br_forward.c
-+++ b/net/bridge/br_forward.c
-@@ -173,6 +173,29 @@ out:
- 	return p;
- }
- 
-+static void maybe_deliver_addr(struct net_bridge_port *p, struct sk_buff *skb,
-+			       const unsigned char *addr, bool local_orig)
-+{
-+	struct net_device *dev = BR_INPUT_SKB_CB(skb)->brdev;
-+	const unsigned char *src = eth_hdr(skb)->h_source;
-+
-+	if (!should_deliver(p, skb))
-+		return;
-+
-+	/* Even with hairpin, no soliloquies - prevent breaking IPv6 DAD */
-+	if (skb->dev == p->dev && ether_addr_equal(src, addr))
-+		return;
-+
-+	skb = skb_copy(skb, GFP_ATOMIC);
-+	if (!skb) {
-+		dev->stats.tx_dropped++;
-+		return;
-+	}
-+
-+	memcpy(eth_hdr(skb)->h_dest, addr, ETH_ALEN);
-+	__br_forward(p, skb, local_orig);
-+}
-+
- /* called under rcu_read_lock */
- void br_flood(struct net_bridge *br, struct sk_buff *skb,
- 	      enum br_pkt_type pkt_type, bool local_rcv, bool local_orig)
-@@ -241,10 +264,20 @@ void br_multicast_flood(struct net_bridg
- 		rport = rp ? hlist_entry(rp, struct net_bridge_port, rlist) :
- 			     NULL;
- 
--		port = (unsigned long)lport > (unsigned long)rport ?
--		       lport : rport;
-+		if ((unsigned long)lport > (unsigned long)rport) {
-+			port = lport;
-+
-+			if (p->flags & MDB_PG_FLAGS_MCAST_TO_UCAST) {
-+				maybe_deliver_addr(lport, skb, p->eth_addr,
-+						   local_orig);
-+				goto delivered;
-+			}
-+		} else {
-+			port = rport;
-+		}
- 
- 		prev = maybe_deliver(prev, port, skb, local_orig);
-+delivered:
- 		if (IS_ERR(prev))
- 			goto out;
- 		if (prev == port)
---- a/net/bridge/br_mdb.c
-+++ b/net/bridge/br_mdb.c
-@@ -532,7 +532,7 @@ static int br_mdb_add_group(struct net_b
- 			break;
- 	}
- 
--	p = br_multicast_new_port_group(port, group, *pp, state);
-+	p = br_multicast_new_port_group(port, group, *pp, state, NULL);
- 	if (unlikely(!p))
- 		return -ENOMEM;
- 	rcu_assign_pointer(*pp, p);
---- a/net/bridge/br_multicast.c
-+++ b/net/bridge/br_multicast.c
-@@ -42,12 +42,14 @@ static void br_multicast_add_router(stru
- static void br_ip4_multicast_leave_group(struct net_bridge *br,
- 					 struct net_bridge_port *port,
- 					 __be32 group,
--					 __u16 vid);
-+					 __u16 vid,
-+					 const unsigned char *src);
-+
- #if IS_ENABLED(CONFIG_IPV6)
- static void br_ip6_multicast_leave_group(struct net_bridge *br,
- 					 struct net_bridge_port *port,
- 					 const struct in6_addr *group,
--					 __u16 vid);
-+					 __u16 vid, const unsigned char *src);
- #endif
- unsigned int br_mdb_rehash_seq;
- 
-@@ -658,7 +660,8 @@ struct net_bridge_port_group *br_multica
- 			struct net_bridge_port *port,
- 			struct br_ip *group,
- 			struct net_bridge_port_group __rcu *next,
--			unsigned char flags)
-+			unsigned char flags,
-+			const unsigned char *src)
- {
- 	struct net_bridge_port_group *p;
- 
-@@ -673,12 +676,39 @@ struct net_bridge_port_group *br_multica
- 	hlist_add_head(&p->mglist, &port->mglist);
- 	setup_timer(&p->timer, br_multicast_port_group_expired,
- 		    (unsigned long)p);
-+
-+	if ((port->flags & BR_MULTICAST_TO_UNICAST) && src) {
-+		memcpy(p->eth_addr, src, ETH_ALEN);
-+		p->flags |= MDB_PG_FLAGS_MCAST_TO_UCAST;
-+	}
-+
- 	return p;
- }
- 
-+static bool br_port_group_equal(struct net_bridge_port_group *p,
-+				struct net_bridge_port *port,
-+				const unsigned char *src)
-+{
-+	if (p->port != port)
-+		return false;
-+
-+	if (!(p->flags & MDB_PG_FLAGS_MCAST_TO_UCAST) !=
-+	    !(port->flags & BR_MULTICAST_TO_UNICAST))
-+		return false;
-+
-+	if (!(p->flags & MDB_PG_FLAGS_MCAST_TO_UCAST))
-+		return true;
-+
-+	if (!src)
-+		return false;
-+
-+	return ether_addr_equal(src, p->eth_addr);
-+}
-+
- static int br_multicast_add_group(struct net_bridge *br,
- 				  struct net_bridge_port *port,
--				  struct br_ip *group)
-+				  struct br_ip *group,
-+				  const unsigned char *src)
- {
- 	struct net_bridge_mdb_entry *mp;
- 	struct net_bridge_port_group *p;
-@@ -705,13 +735,13 @@ static int br_multicast_add_group(struct
- 	for (pp = &mp->ports;
- 	     (p = mlock_dereference(*pp, br)) != NULL;
- 	     pp = &p->next) {
--		if (p->port == port)
-+		if (br_port_group_equal(p, port, src))
- 			goto found;
- 		if ((unsigned long)p->port < (unsigned long)port)
- 			break;
- 	}
- 
--	p = br_multicast_new_port_group(port, group, *pp, 0);
-+	p = br_multicast_new_port_group(port, group, *pp, 0, src);
- 	if (unlikely(!p))
- 		goto err;
- 	rcu_assign_pointer(*pp, p);
-@@ -730,7 +760,8 @@ err:
- static int br_ip4_multicast_add_group(struct net_bridge *br,
- 				      struct net_bridge_port *port,
- 				      __be32 group,
--				      __u16 vid)
-+				      __u16 vid,
-+				      const unsigned char *src)
- {
- 	struct br_ip br_group;
- 
-@@ -741,14 +772,15 @@ static int br_ip4_multicast_add_group(st
- 	br_group.proto = htons(ETH_P_IP);
- 	br_group.vid = vid;
- 
--	return br_multicast_add_group(br, port, &br_group);
-+	return br_multicast_add_group(br, port, &br_group, src);
- }
- 
- #if IS_ENABLED(CONFIG_IPV6)
- static int br_ip6_multicast_add_group(struct net_bridge *br,
- 				      struct net_bridge_port *port,
- 				      const struct in6_addr *group,
--				      __u16 vid)
-+				      __u16 vid,
-+				      const unsigned char *src)
- {
- 	struct br_ip br_group;
- 
-@@ -759,7 +791,7 @@ static int br_ip6_multicast_add_group(st
- 	br_group.proto = htons(ETH_P_IPV6);
- 	br_group.vid = vid;
- 
--	return br_multicast_add_group(br, port, &br_group);
-+	return br_multicast_add_group(br, port, &br_group, src);
- }
- #endif
- 
-@@ -1028,6 +1060,7 @@ static int br_ip4_multicast_igmp3_report
- 					 struct sk_buff *skb,
- 					 u16 vid)
- {
-+	const unsigned char *src;
- 	struct igmpv3_report *ih;
- 	struct igmpv3_grec *grec;
- 	int i;
-@@ -1070,12 +1103,14 @@ static int br_ip4_multicast_igmp3_report
- 			continue;
- 		}
- 
-+		src = eth_hdr(skb)->h_source;
- 		if ((type == IGMPV3_CHANGE_TO_INCLUDE ||
- 		     type == IGMPV3_MODE_IS_INCLUDE) &&
- 		    nsrcs == 0) {
--			br_ip4_multicast_leave_group(br, port, group, vid);
-+			br_ip4_multicast_leave_group(br, port, group, vid, src);
- 		} else {
--			err = br_ip4_multicast_add_group(br, port, group, vid);
-+			err = br_ip4_multicast_add_group(br, port, group, vid,
-+							 src);
- 			if (err)
- 				break;
- 		}
-@@ -1090,6 +1125,7 @@ static int br_ip6_multicast_mld2_report(
- 					struct sk_buff *skb,
- 					u16 vid)
- {
-+	const unsigned char *src = eth_hdr(skb)->h_source;
- 	struct icmp6hdr *icmp6h;
- 	struct mld2_grec *grec;
- 	int i;
-@@ -1144,10 +1180,11 @@ static int br_ip6_multicast_mld2_report(
- 		     grec->grec_type == MLD2_MODE_IS_INCLUDE) &&
- 		    nsrcs == 0) {
- 			br_ip6_multicast_leave_group(br, port, &grec->grec_mca,
--						     vid);
-+						     vid, src);
- 		} else {
- 			err = br_ip6_multicast_add_group(br, port,
--							 &grec->grec_mca, vid);
-+							 &grec->grec_mca, vid,
-+							 src);
- 			if (err)
- 				break;
- 		}
-@@ -1462,7 +1499,8 @@ br_multicast_leave_group(struct net_brid
- 			 struct net_bridge_port *port,
- 			 struct br_ip *group,
- 			 struct bridge_mcast_other_query *other_query,
--			 struct bridge_mcast_own_query *own_query)
-+			 struct bridge_mcast_own_query *own_query,
-+			 const unsigned char *src)
- {
- 	struct net_bridge_mdb_htable *mdb;
- 	struct net_bridge_mdb_entry *mp;
-@@ -1486,7 +1524,7 @@ br_multicast_leave_group(struct net_brid
- 		for (pp = &mp->ports;
- 		     (p = mlock_dereference(*pp, br)) != NULL;
- 		     pp = &p->next) {
--			if (p->port != port)
-+			if (!br_port_group_equal(p, port, src))
- 				continue;
- 
- 			if (p->flags & MDB_PG_FLAGS_PERMANENT)
-@@ -1520,7 +1558,7 @@ br_multicast_leave_group(struct net_brid
- 		for (p = mlock_dereference(mp->ports, br);
- 		     p != NULL;
- 		     p = mlock_dereference(p->next, br)) {
--			if (p->port != port)
-+			if (!br_port_group_equal(p, port, src))
- 				continue;
- 
- 			if (!hlist_unhashed(&p->mglist) &&
-@@ -1571,7 +1609,8 @@ out:
- static void br_ip4_multicast_leave_group(struct net_bridge *br,
- 					 struct net_bridge_port *port,
- 					 __be32 group,
--					 __u16 vid)
-+					 __u16 vid,
-+					 const unsigned char *src)
- {
- 	struct br_ip br_group;
- 	struct bridge_mcast_own_query *own_query;
-@@ -1586,14 +1625,15 @@ static void br_ip4_multicast_leave_group
- 	br_group.vid = vid;
- 
- 	br_multicast_leave_group(br, port, &br_group, &br->ip4_other_query,
--				 own_query);
-+				 own_query, src);
- }
- 
- #if IS_ENABLED(CONFIG_IPV6)
- static void br_ip6_multicast_leave_group(struct net_bridge *br,
- 					 struct net_bridge_port *port,
- 					 const struct in6_addr *group,
--					 __u16 vid)
-+					 __u16 vid,
-+					 const unsigned char *src)
- {
- 	struct br_ip br_group;
- 	struct bridge_mcast_own_query *own_query;
-@@ -1608,7 +1648,7 @@ static void br_ip6_multicast_leave_group
- 	br_group.vid = vid;
- 
- 	br_multicast_leave_group(br, port, &br_group, &br->ip6_other_query,
--				 own_query);
-+				 own_query, src);
- }
- #endif
- 
-@@ -1651,6 +1691,7 @@ static int br_multicast_ipv4_rcv(struct
- 				 u16 vid)
- {
- 	struct sk_buff *skb_trimmed = NULL;
-+	const unsigned char *src;
- 	struct igmphdr *ih;
- 	int err;
- 
-@@ -1666,13 +1707,14 @@ static int br_multicast_ipv4_rcv(struct
- 	}
- 
- 	ih = igmp_hdr(skb);
-+	src = eth_hdr(skb)->h_source;
- 	BR_INPUT_SKB_CB(skb)->igmp = ih->type;
- 
- 	switch (ih->type) {
- 	case IGMP_HOST_MEMBERSHIP_REPORT:
- 	case IGMPV2_HOST_MEMBERSHIP_REPORT:
- 		BR_INPUT_SKB_CB(skb)->mrouters_only = 1;
--		err = br_ip4_multicast_add_group(br, port, ih->group, vid);
-+		err = br_ip4_multicast_add_group(br, port, ih->group, vid, src);
- 		break;
- 	case IGMPV3_HOST_MEMBERSHIP_REPORT:
- 		err = br_ip4_multicast_igmp3_report(br, port, skb_trimmed, vid);
-@@ -1681,7 +1723,7 @@ static int br_multicast_ipv4_rcv(struct
- 		err = br_ip4_multicast_query(br, port, skb_trimmed, vid);
- 		break;
- 	case IGMP_HOST_LEAVE_MESSAGE:
--		br_ip4_multicast_leave_group(br, port, ih->group, vid);
-+		br_ip4_multicast_leave_group(br, port, ih->group, vid, src);
- 		break;
- 	}
- 
-@@ -1701,6 +1743,7 @@ static int br_multicast_ipv6_rcv(struct
- 				 u16 vid)
- {
- 	struct sk_buff *skb_trimmed = NULL;
-+	const unsigned char *src;
- 	struct mld_msg *mld;
- 	int err;
- 
-@@ -1720,8 +1763,10 @@ static int br_multicast_ipv6_rcv(struct
- 
- 	switch (mld->mld_type) {
- 	case ICMPV6_MGM_REPORT:
-+		src = eth_hdr(skb)->h_source;
- 		BR_INPUT_SKB_CB(skb)->mrouters_only = 1;
--		err = br_ip6_multicast_add_group(br, port, &mld->mld_mca, vid);
-+		err = br_ip6_multicast_add_group(br, port, &mld->mld_mca, vid,
-+						 src);
- 		break;
- 	case ICMPV6_MLD2_REPORT:
- 		err = br_ip6_multicast_mld2_report(br, port, skb_trimmed, vid);
-@@ -1730,7 +1775,8 @@ static int br_multicast_ipv6_rcv(struct
- 		err = br_ip6_multicast_query(br, port, skb_trimmed, vid);
- 		break;
- 	case ICMPV6_MGM_REDUCTION:
--		br_ip6_multicast_leave_group(br, port, &mld->mld_mca, vid);
-+		src = eth_hdr(skb)->h_source;
-+		br_ip6_multicast_leave_group(br, port, &mld->mld_mca, vid, src);
- 		break;
- 	}
- 
---- a/net/bridge/br_netlink.c
-+++ b/net/bridge/br_netlink.c
-@@ -123,6 +123,7 @@ static inline size_t br_port_info_size(v
- 		+ nla_total_size(1)	/* IFLA_BRPORT_GUARD */
- 		+ nla_total_size(1)	/* IFLA_BRPORT_PROTECT */
- 		+ nla_total_size(1)	/* IFLA_BRPORT_FAST_LEAVE */
-+		+ nla_total_size(1)	/* IFLA_BRPORT_MCAST_TO_UCAST */
- 		+ nla_total_size(1)	/* IFLA_BRPORT_LEARNING */
- 		+ nla_total_size(1)	/* IFLA_BRPORT_UNICAST_FLOOD */
- 		+ nla_total_size(1)	/* IFLA_BRPORT_PROXYARP */
-@@ -173,6 +174,8 @@ static int br_port_fill_attrs(struct sk_
- 		       !!(p->flags & BR_ROOT_BLOCK)) ||
- 	    nla_put_u8(skb, IFLA_BRPORT_FAST_LEAVE,
- 		       !!(p->flags & BR_MULTICAST_FAST_LEAVE)) ||
-+	    nla_put_u8(skb, IFLA_BRPORT_MCAST_TO_UCAST,
-+		       !!(p->flags & BR_MULTICAST_TO_UNICAST)) ||
- 	    nla_put_u8(skb, IFLA_BRPORT_LEARNING, !!(p->flags & BR_LEARNING)) ||
- 	    nla_put_u8(skb, IFLA_BRPORT_UNICAST_FLOOD,
- 		       !!(p->flags & BR_FLOOD)) ||
-@@ -586,6 +589,7 @@ static const struct nla_policy br_port_p
- 	[IFLA_BRPORT_PROXYARP]	= { .type = NLA_U8 },
- 	[IFLA_BRPORT_PROXYARP_WIFI] = { .type = NLA_U8 },
- 	[IFLA_BRPORT_MULTICAST_ROUTER] = { .type = NLA_U8 },
-+	[IFLA_BRPORT_MCAST_TO_UCAST] = { .type = NLA_U8 },
- };
- 
- /* Change the state of the port and notify spanning tree */
-@@ -636,6 +640,7 @@ static int br_setport(struct net_bridge_
- 	br_set_port_flag(p, tb, IFLA_BRPORT_LEARNING, BR_LEARNING);
- 	br_set_port_flag(p, tb, IFLA_BRPORT_UNICAST_FLOOD, BR_FLOOD);
- 	br_set_port_flag(p, tb, IFLA_BRPORT_MCAST_FLOOD, BR_MCAST_FLOOD);
-+	br_set_port_flag(p, tb, IFLA_BRPORT_MCAST_TO_UCAST, BR_MULTICAST_TO_UNICAST);
- 	br_set_port_flag(p, tb, IFLA_BRPORT_PROXYARP, BR_PROXYARP);
- 	br_set_port_flag(p, tb, IFLA_BRPORT_PROXYARP_WIFI, BR_PROXYARP_WIFI);
- 
---- a/net/bridge/br_private.h
-+++ b/net/bridge/br_private.h
-@@ -166,8 +166,9 @@ struct net_bridge_fdb_entry
- 	struct rcu_head			rcu;
- };
- 
--#define MDB_PG_FLAGS_PERMANENT	BIT(0)
--#define MDB_PG_FLAGS_OFFLOAD	BIT(1)
-+#define MDB_PG_FLAGS_PERMANENT		BIT(0)
-+#define MDB_PG_FLAGS_OFFLOAD		BIT(1)
-+#define MDB_PG_FLAGS_MCAST_TO_UCAST	BIT(2)
- 
- struct net_bridge_port_group {
- 	struct net_bridge_port		*port;
-@@ -177,6 +178,7 @@ struct net_bridge_port_group {
- 	struct timer_list		timer;
- 	struct br_ip			addr;
- 	unsigned char			flags;
-+	unsigned char			eth_addr[ETH_ALEN];
- };
- 
- struct net_bridge_mdb_entry
-@@ -591,7 +593,7 @@ void br_multicast_free_pg(struct rcu_hea
- struct net_bridge_port_group *
- br_multicast_new_port_group(struct net_bridge_port *port, struct br_ip *group,
- 			    struct net_bridge_port_group __rcu *next,
--			    unsigned char flags);
-+			    unsigned char flags, const unsigned char *src);
- void br_mdb_init(void);
- void br_mdb_uninit(void);
- void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,
---- a/net/bridge/br_sysfs_if.c
-+++ b/net/bridge/br_sysfs_if.c
-@@ -188,6 +188,7 @@ static BRPORT_ATTR(multicast_router, S_I
- 		   store_multicast_router);
- 
- BRPORT_ATTR_FLAG(multicast_fast_leave, BR_MULTICAST_FAST_LEAVE);
-+BRPORT_ATTR_FLAG(multicast_to_unicast, BR_MULTICAST_TO_UNICAST);
- #endif
- 
- static const struct brport_attribute *brport_attrs[] = {
-@@ -214,6 +215,7 @@ static const struct brport_attribute *br
- #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
- 	&brport_attr_multicast_router,
- 	&brport_attr_multicast_fast_leave,
-+	&brport_attr_multicast_to_unicast,
- #endif
- 	&brport_attr_proxyarp,
- 	&brport_attr_proxyarp_wifi,
--- a/target/linux/generic/backport-4.9/022-net-add-devm-version-of-alloc_etherdev_mqs-function.patch	2022-03-22 08:54:47.075464449 +0800
+++ b/target/linux/generic/backport-4.9/022-net-add-devm-version-of-alloc_etherdev_mqs-function.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,69 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Sat, 28 Jan 2017 15:15:42 +0100
-Subject: [PATCH] net: add devm version of alloc_etherdev_mqs function
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-This patch adds devm_alloc_etherdev_mqs function and devm_alloc_etherdev
-macro. These can be used for simpler netdev allocation without having to
-care about calling free_netdev.
-
-Thanks to this change drivers, their error paths and removal paths may
-get simpler by a bit.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/include/linux/etherdevice.h
-+++ b/include/linux/etherdevice.h
-@@ -54,6 +54,11 @@ struct net_device *alloc_etherdev_mqs(in
- #define alloc_etherdev(sizeof_priv) alloc_etherdev_mq(sizeof_priv, 1)
- #define alloc_etherdev_mq(sizeof_priv, count) alloc_etherdev_mqs(sizeof_priv, count, count)
- 
-+struct net_device *devm_alloc_etherdev_mqs(struct device *dev, int sizeof_priv,
-+					   unsigned int txqs,
-+					   unsigned int rxqs);
-+#define devm_alloc_etherdev(dev, sizeof_priv) devm_alloc_etherdev_mqs(dev, sizeof_priv, 1, 1)
-+
- struct sk_buff **eth_gro_receive(struct sk_buff **head,
- 				 struct sk_buff *skb);
- int eth_gro_complete(struct sk_buff *skb, int nhoff);
---- a/net/ethernet/eth.c
-+++ b/net/ethernet/eth.c
-@@ -391,6 +391,34 @@ struct net_device *alloc_etherdev_mqs(in
- }
- EXPORT_SYMBOL(alloc_etherdev_mqs);
- 
-+static void devm_free_netdev(struct device *dev, void *res)
-+{
-+	free_netdev(*(struct net_device **)res);
-+}
-+
-+struct net_device *devm_alloc_etherdev_mqs(struct device *dev, int sizeof_priv,
-+					   unsigned int txqs, unsigned int rxqs)
-+{
-+	struct net_device **dr;
-+	struct net_device *netdev;
-+
-+	dr = devres_alloc(devm_free_netdev, sizeof(*dr), GFP_KERNEL);
-+	if (!dr)
-+		return NULL;
-+
-+	netdev = alloc_etherdev_mqs(sizeof_priv, txqs, rxqs);
-+	if (!netdev) {
-+		devres_free(dr);
-+		return NULL;
-+	}
-+
-+	*dr = netdev;
-+	devres_add(dev, dr);
-+
-+	return netdev;
-+}
-+EXPORT_SYMBOL(devm_alloc_etherdev_mqs);
-+
- ssize_t sysfs_format_mac(char *buf, const unsigned char *addr, int len)
- {
- 	return scnprintf(buf, PAGE_SIZE, "%*phC\n", len, addr);
--- a/target/linux/generic/backport-4.9/024-1-tcp-tsq-add-tsq_flags-tsq_enum.patch	2022-03-22 08:54:47.076464451 +0800
+++ b/target/linux/generic/backport-4.9/024-1-tcp-tsq-add-tsq_flags-tsq_enum.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,90 +0,0 @@
-From 40fc3423b983b864bf70b03199191260ae9b2ea6 Mon Sep 17 00:00:00 2001
-From: Eric Dumazet <edumazet@google.com>
-Date: Sat, 3 Dec 2016 11:14:50 -0800
-Subject: [PATCH 01/10] tcp: tsq: add tsq_flags / tsq_enum
-
-This is a cleanup, to ease code review of following patches.
-
-Old 'enum tsq_flags' is renamed, and a new enumeration is added
-with the flags used in cmpxchg() operations as opposed to
-single bit operations.
-
-Signed-off-by: Eric Dumazet <edumazet@google.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- include/linux/tcp.h   | 11 ++++++++++-
- net/ipv4/tcp_output.c | 16 ++++++++--------
- 2 files changed, 18 insertions(+), 9 deletions(-)
-
---- a/include/linux/tcp.h
-+++ b/include/linux/tcp.h
-@@ -368,7 +368,7 @@ struct tcp_sock {
- 	u32	*saved_syn;
- };
- 
--enum tsq_flags {
-+enum tsq_enum {
- 	TSQ_THROTTLED,
- 	TSQ_QUEUED,
- 	TCP_TSQ_DEFERRED,	   /* tcp_tasklet_func() found socket was owned */
-@@ -379,6 +379,15 @@ enum tsq_flags {
- 				    */
- };
- 
-+enum tsq_flags {
-+	TSQF_THROTTLED			= (1UL << TSQ_THROTTLED),
-+	TSQF_QUEUED			= (1UL << TSQ_QUEUED),
-+	TCPF_TSQ_DEFERRED		= (1UL << TCP_TSQ_DEFERRED),
-+	TCPF_WRITE_TIMER_DEFERRED	= (1UL << TCP_WRITE_TIMER_DEFERRED),
-+	TCPF_DELACK_TIMER_DEFERRED	= (1UL << TCP_DELACK_TIMER_DEFERRED),
-+	TCPF_MTU_REDUCED_DEFERRED	= (1UL << TCP_MTU_REDUCED_DEFERRED),
-+};
-+
- static inline struct tcp_sock *tcp_sk(const struct sock *sk)
- {
- 	return (struct tcp_sock *)sk;
---- a/net/ipv4/tcp_output.c
-+++ b/net/ipv4/tcp_output.c
-@@ -789,10 +789,10 @@ static void tcp_tasklet_func(unsigned lo
- 	}
- }
- 
--#define TCP_DEFERRED_ALL ((1UL << TCP_TSQ_DEFERRED) |		\
--			  (1UL << TCP_WRITE_TIMER_DEFERRED) |	\
--			  (1UL << TCP_DELACK_TIMER_DEFERRED) |	\
--			  (1UL << TCP_MTU_REDUCED_DEFERRED))
-+#define TCP_DEFERRED_ALL (TCPF_TSQ_DEFERRED |		\
-+			  TCPF_WRITE_TIMER_DEFERRED |	\
-+			  TCPF_DELACK_TIMER_DEFERRED |	\
-+			  TCPF_MTU_REDUCED_DEFERRED)
- /**
-  * tcp_release_cb - tcp release_sock() callback
-  * @sk: socket
-@@ -813,7 +813,7 @@ void tcp_release_cb(struct sock *sk)
- 		nflags = flags & ~TCP_DEFERRED_ALL;
- 	} while (cmpxchg(&tp->tsq_flags, flags, nflags) != flags);
- 
--	if (flags & (1UL << TCP_TSQ_DEFERRED))
-+	if (flags & TCPF_TSQ_DEFERRED)
- 		tcp_tsq_handler(sk);
- 
- 	/* Here begins the tricky part :
-@@ -827,15 +827,15 @@ void tcp_release_cb(struct sock *sk)
- 	 */
- 	sock_release_ownership(sk);
- 
--	if (flags & (1UL << TCP_WRITE_TIMER_DEFERRED)) {
-+	if (flags & TCPF_WRITE_TIMER_DEFERRED) {
- 		tcp_write_timer_handler(sk);
- 		__sock_put(sk);
- 	}
--	if (flags & (1UL << TCP_DELACK_TIMER_DEFERRED)) {
-+	if (flags & TCPF_DELACK_TIMER_DEFERRED) {
- 		tcp_delack_timer_handler(sk);
- 		__sock_put(sk);
- 	}
--	if (flags & (1UL << TCP_MTU_REDUCED_DEFERRED)) {
-+	if (flags & TCPF_MTU_REDUCED_DEFERRED) {
- 		inet_csk(sk)->icsk_af_ops->mtu_reduced(sk);
- 		__sock_put(sk);
- 	}
--- a/target/linux/generic/backport-4.9/024-2-tcp-tsq-remove-one-locked-operation-in-tcp_wfree.patch	2022-03-22 08:54:47.076464451 +0800
+++ b/target/linux/generic/backport-4.9/024-2-tcp-tsq-remove-one-locked-operation-in-tcp_wfree.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,48 +0,0 @@
-From 408f0a6c21e124cc4f6c7aa370b38aa47e55428d Mon Sep 17 00:00:00 2001
-From: Eric Dumazet <edumazet@google.com>
-Date: Sat, 3 Dec 2016 11:14:51 -0800
-Subject: [PATCH 02/10] tcp: tsq: remove one locked operation in tcp_wfree()
-
-Instead of atomically clear TSQ_THROTTLED and atomically set TSQ_QUEUED
-bits, use one cmpxchg() to perform a single locked operation.
-
-Since the following patch will also set TCP_TSQ_DEFERRED here,
-this cmpxchg() will make this addition free.
-
-Signed-off-by: Eric Dumazet <edumazet@google.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- net/ipv4/tcp_output.c | 13 ++++++++++---
- 1 file changed, 10 insertions(+), 3 deletions(-)
-
---- a/net/ipv4/tcp_output.c
-+++ b/net/ipv4/tcp_output.c
-@@ -865,6 +865,7 @@ void tcp_wfree(struct sk_buff *skb)
- {
- 	struct sock *sk = skb->sk;
- 	struct tcp_sock *tp = tcp_sk(sk);
-+	unsigned long flags, nval, oval;
- 	int wmem;
- 
- 	/* Keep one reference on sk_wmem_alloc.
-@@ -882,11 +883,17 @@ void tcp_wfree(struct sk_buff *skb)
- 	if (wmem >= SKB_TRUESIZE(1) && this_cpu_ksoftirqd() == current)
- 		goto out;
- 
--	if (test_and_clear_bit(TSQ_THROTTLED, &tp->tsq_flags) &&
--	    !test_and_set_bit(TSQ_QUEUED, &tp->tsq_flags)) {
--		unsigned long flags;
-+	for (oval = READ_ONCE(tp->tsq_flags);; oval = nval) {
- 		struct tsq_tasklet *tsq;
- 
-+		if (!(oval & TSQF_THROTTLED) || (oval & TSQF_QUEUED))
-+			goto out;
-+
-+		nval = (oval & ~TSQF_THROTTLED) | TSQF_QUEUED;
-+		nval = cmpxchg(&tp->tsq_flags, oval, nval);
-+		if (nval != oval)
-+			continue;
-+
- 		/* queue this socket to tasklet queue */
- 		local_irq_save(flags);
- 		tsq = this_cpu_ptr(&tsq_tasklet);
--- a/target/linux/generic/backport-4.9/024-3-tcp-tsq-add-shortcut-in-tcp_tasklet_func.patch	2022-03-22 08:54:47.076464451 +0800
+++ b/target/linux/generic/backport-4.9/024-3-tcp-tsq-add-shortcut-in-tcp_tasklet_func.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,71 +0,0 @@
-From b223feb9de2a65c533ff95c08e834fa732906ea5 Mon Sep 17 00:00:00 2001
-From: Eric Dumazet <edumazet@google.com>
-Date: Sat, 3 Dec 2016 11:14:52 -0800
-Subject: [PATCH 03/10] tcp: tsq: add shortcut in tcp_tasklet_func()
-
-Under high stress, I've seen tcp_tasklet_func() consuming
-~700 usec, handling ~150 tcp sockets.
-
-By setting TCP_TSQ_DEFERRED in tcp_wfree(), we give a chance
-for other cpus/threads entering tcp_write_xmit() to grab it,
-allowing tcp_tasklet_func() to skip sockets that already did
-an xmit cycle.
-
-In the future, we might give to ACK processing an increased
-budget to reduce even more tcp_tasklet_func() amount of work.
-
-Signed-off-by: Eric Dumazet <edumazet@google.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- net/ipv4/tcp_output.c | 22 ++++++++++++----------
- 1 file changed, 12 insertions(+), 10 deletions(-)
-
---- a/net/ipv4/tcp_output.c
-+++ b/net/ipv4/tcp_output.c
-@@ -772,19 +772,19 @@ static void tcp_tasklet_func(unsigned lo
- 	list_for_each_safe(q, n, &list) {
- 		tp = list_entry(q, struct tcp_sock, tsq_node);
- 		list_del(&tp->tsq_node);
-+		clear_bit(TSQ_QUEUED, &tp->tsq_flags);
- 
- 		sk = (struct sock *)tp;
--		bh_lock_sock(sk);
--
--		if (!sock_owned_by_user(sk)) {
--			tcp_tsq_handler(sk);
--		} else {
--			/* defer the work to tcp_release_cb() */
--			set_bit(TCP_TSQ_DEFERRED, &tp->tsq_flags);
-+		if (!sk->sk_lock.owned &&
-+		    test_bit(TCP_TSQ_DEFERRED, &tp->tsq_flags)) {
-+			bh_lock_sock(sk);
-+			if (!sock_owned_by_user(sk)) {
-+				clear_bit(TCP_TSQ_DEFERRED, &tp->tsq_flags);
-+				tcp_tsq_handler(sk);
-+			}
-+			bh_unlock_sock(sk);
- 		}
--		bh_unlock_sock(sk);
- 
--		clear_bit(TSQ_QUEUED, &tp->tsq_flags);
- 		sk_free(sk);
- 	}
- }
-@@ -889,7 +889,7 @@ void tcp_wfree(struct sk_buff *skb)
- 		if (!(oval & TSQF_THROTTLED) || (oval & TSQF_QUEUED))
- 			goto out;
- 
--		nval = (oval & ~TSQF_THROTTLED) | TSQF_QUEUED;
-+		nval = (oval & ~TSQF_THROTTLED) | TSQF_QUEUED | TCPF_TSQ_DEFERRED;
- 		nval = cmpxchg(&tp->tsq_flags, oval, nval);
- 		if (nval != oval)
- 			continue;
-@@ -2236,6 +2236,8 @@ static bool tcp_write_xmit(struct sock *
- 		    unlikely(tso_fragment(sk, skb, limit, mss_now, gfp)))
- 			break;
- 
-+		if (test_bit(TCP_TSQ_DEFERRED, &tp->tsq_flags))
-+			clear_bit(TCP_TSQ_DEFERRED, &tp->tsq_flags);
- 		if (tcp_small_queue_check(sk, skb, 0))
- 			break;
- 
--- a/target/linux/generic/backport-4.9/024-4-tcp-tsq-avoid-one-atomic-in-tcp_wfree.patch	2022-03-22 08:54:47.077464453 +0800
+++ b/target/linux/generic/backport-4.9/024-4-tcp-tsq-avoid-one-atomic-in-tcp_wfree.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,38 +0,0 @@
-From a9b204d1564702b704ad6fe74f10a102c7b87ba3 Mon Sep 17 00:00:00 2001
-From: Eric Dumazet <edumazet@google.com>
-Date: Sat, 3 Dec 2016 11:14:53 -0800
-Subject: [PATCH 04/10] tcp: tsq: avoid one atomic in tcp_wfree()
-
-Under high load, tcp_wfree() has an atomic operation trying
-to schedule a tasklet over and over.
-
-We can schedule it only if our per cpu list was empty.
-
-Signed-off-by: Eric Dumazet <edumazet@google.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- net/ipv4/tcp_output.c | 5 ++++-
- 1 file changed, 4 insertions(+), 1 deletion(-)
-
---- a/net/ipv4/tcp_output.c
-+++ b/net/ipv4/tcp_output.c
-@@ -885,6 +885,7 @@ void tcp_wfree(struct sk_buff *skb)
- 
- 	for (oval = READ_ONCE(tp->tsq_flags);; oval = nval) {
- 		struct tsq_tasklet *tsq;
-+		bool empty;
- 
- 		if (!(oval & TSQF_THROTTLED) || (oval & TSQF_QUEUED))
- 			goto out;
-@@ -897,8 +898,10 @@ void tcp_wfree(struct sk_buff *skb)
- 		/* queue this socket to tasklet queue */
- 		local_irq_save(flags);
- 		tsq = this_cpu_ptr(&tsq_tasklet);
-+		empty = list_empty(&tsq->head);
- 		list_add(&tp->tsq_node, &tsq->head);
--		tasklet_schedule(&tsq->tasklet);
-+		if (empty)
-+			tasklet_schedule(&tsq->tasklet);
- 		local_irq_restore(flags);
- 		return;
- 	}
--- a/target/linux/generic/backport-4.9/024-5-tcp-tsq-add-a-shortcut-in-tcp_small_queue_check.patch	2022-03-22 08:54:47.077464453 +0800
+++ b/target/linux/generic/backport-4.9/024-5-tcp-tsq-add-a-shortcut-in-tcp_small_queue_check.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,37 +0,0 @@
-From 75eefc6c59fd2c5f1ab95a3a113c217237d12a31 Mon Sep 17 00:00:00 2001
-From: Eric Dumazet <edumazet@google.com>
-Date: Sat, 3 Dec 2016 11:14:54 -0800
-Subject: [PATCH 05/10] tcp: tsq: add a shortcut in tcp_small_queue_check()
-
-Always allow the two first skbs in write queue to be sent,
-regardless of sk_wmem_alloc/sk_pacing_rate values.
-
-This helps a lot in situations where TX completions are delayed either
-because of driver latencies or softirq latencies.
-
-Test is done with no cache line misses.
-
-Signed-off-by: Eric Dumazet <edumazet@google.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- net/ipv4/tcp_output.c | 9 +++++++++
- 1 file changed, 9 insertions(+)
-
---- a/net/ipv4/tcp_output.c
-+++ b/net/ipv4/tcp_output.c
-@@ -2141,6 +2141,15 @@ static bool tcp_small_queue_check(struct
- 	limit <<= factor;
- 
- 	if (atomic_read(&sk->sk_wmem_alloc) > limit) {
-+		/* Always send the 1st or 2nd skb in write queue.
-+		 * No need to wait for TX completion to call us back,
-+		 * after softirq/tasklet schedule.
-+		 * This helps when TX completions are delayed too much.
-+		 */
-+		if (skb == sk->sk_write_queue.next ||
-+		    skb->prev == sk->sk_write_queue.next)
-+			return false;
-+
- 		set_bit(TSQ_THROTTLED, &tcp_sk(sk)->tsq_flags);
- 		/* It is possible TX completion already happened
- 		 * before we set TSQ_THROTTLED, so we must
--- a/target/linux/generic/backport-4.9/024-6-tcp-tcp_mtu_probe-is-likely-to-exit-early.patch	2022-03-22 08:54:47.077464453 +0800
+++ b/target/linux/generic/backport-4.9/024-6-tcp-tcp_mtu_probe-is-likely-to-exit-early.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,55 +0,0 @@
-From 12a59abc22d6664f7d3944f625ceefee92de8820 Mon Sep 17 00:00:00 2001
-From: Eric Dumazet <edumazet@google.com>
-Date: Sat, 3 Dec 2016 11:14:55 -0800
-Subject: [PATCH 06/10] tcp: tcp_mtu_probe() is likely to exit early
-
-Adding a likely() in tcp_mtu_probe() moves its code which used to
-be inlined in front of tcp_write_xmit()
-
-We still have a cache line miss to access icsk->icsk_mtup.enabled,
-we will probably have to reorganize fields to help data locality.
-
-Signed-off-by: Eric Dumazet <edumazet@google.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- net/ipv4/tcp_output.c | 18 +++++++++---------
- 1 file changed, 9 insertions(+), 9 deletions(-)
-
---- a/net/ipv4/tcp_output.c
-+++ b/net/ipv4/tcp_output.c
-@@ -1973,26 +1973,26 @@ static bool tcp_can_coalesce_send_queue_
-  */
- static int tcp_mtu_probe(struct sock *sk)
- {
--	struct tcp_sock *tp = tcp_sk(sk);
- 	struct inet_connection_sock *icsk = inet_csk(sk);
-+	struct tcp_sock *tp = tcp_sk(sk);
- 	struct sk_buff *skb, *nskb, *next;
- 	struct net *net = sock_net(sk);
--	int len;
- 	int probe_size;
- 	int size_needed;
--	int copy;
-+	int copy, len;
- 	int mss_now;
- 	int interval;
- 
- 	/* Not currently probing/verifying,
- 	 * not in recovery,
- 	 * have enough cwnd, and
--	 * not SACKing (the variable headers throw things off) */
--	if (!icsk->icsk_mtup.enabled ||
--	    icsk->icsk_mtup.probe_size ||
--	    inet_csk(sk)->icsk_ca_state != TCP_CA_Open ||
--	    tp->snd_cwnd < 11 ||
--	    tp->rx_opt.num_sacks || tp->rx_opt.dsack)
-+	 * not SACKing (the variable headers throw things off)
-+	 */
-+	if (likely(!icsk->icsk_mtup.enabled ||
-+		   icsk->icsk_mtup.probe_size ||
-+		   inet_csk(sk)->icsk_ca_state != TCP_CA_Open ||
-+		   tp->snd_cwnd < 11 ||
-+		   tp->rx_opt.num_sacks || tp->rx_opt.dsack))
- 		return -1;
- 
- 	/* Use binary search for probe_size between tcp_mss_base,
--- a/target/linux/generic/backport-4.9/024-7-net-reorganize-struct-sock-for-better-data-locality.patch	2022-03-22 08:54:47.078464454 +0800
+++ b/target/linux/generic/backport-4.9/024-7-net-reorganize-struct-sock-for-better-data-locality.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,158 +0,0 @@
-From 9115e8cd2a0c6eaaa900c462721f12e1d45f326c Mon Sep 17 00:00:00 2001
-From: Eric Dumazet <edumazet@google.com>
-Date: Sat, 3 Dec 2016 11:14:56 -0800
-Subject: [PATCH 07/10] net: reorganize struct sock for better data locality
-
-Group fields used in TX path, and keep some cache lines mostly read
-to permit sharing among cpus.
-
-Gained two 4 bytes holes on 64bit arches.
-
-Added a place holder for tcp tsq_flags, next to sk_wmem_alloc
-to speed up tcp_wfree() in the following patch.
-
-I have not added ____cacheline_aligned_in_smp, this might be done later.
-I prefer doing this once inet and tcp/udp sockets reorg is also done.
-
-Tested with both TCP and UDP.
-
-UDP receiver performance under flood increased by ~20 % :
-Accessing sk_filter/sk_wq/sk_napi_id no longer stalls because sk_drops
-was moved away from a critical cache line, now mostly read and shared.
-
-	/* --- cacheline 4 boundary (256 bytes) --- */
-	unsigned int               sk_napi_id;           /* 0x100   0x4 */
-	int                        sk_rcvbuf;            /* 0x104   0x4 */
-	struct sk_filter *         sk_filter;            /* 0x108   0x8 */
-	union {
-		struct socket_wq * sk_wq;                /*         0x8 */
-		struct socket_wq * sk_wq_raw;            /*         0x8 */
-	};                                               /* 0x110   0x8 */
-	struct xfrm_policy *       sk_policy[2];         /* 0x118  0x10 */
-	struct dst_entry *         sk_rx_dst;            /* 0x128   0x8 */
-	struct dst_entry *         sk_dst_cache;         /* 0x130   0x8 */
-	atomic_t                   sk_omem_alloc;        /* 0x138   0x4 */
-	int                        sk_sndbuf;            /* 0x13c   0x4 */
-	/* --- cacheline 5 boundary (320 bytes) --- */
-	int                        sk_wmem_queued;       /* 0x140   0x4 */
-	atomic_t                   sk_wmem_alloc;        /* 0x144   0x4 */
-	long unsigned int          sk_tsq_flags;         /* 0x148   0x8 */
-	struct sk_buff *           sk_send_head;         /* 0x150   0x8 */
-	struct sk_buff_head        sk_write_queue;       /* 0x158  0x18 */
-	__s32                      sk_peek_off;          /* 0x170   0x4 */
-	int                        sk_write_pending;     /* 0x174   0x4 */
-	long int                   sk_sndtimeo;          /* 0x178   0x8 */
-
-Signed-off-by: Eric Dumazet <edumazet@google.com>
-Tested-by: Paolo Abeni <pabeni@redhat.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- include/net/sock.h | 51 +++++++++++++++++++++++++++------------------------
- 1 file changed, 27 insertions(+), 24 deletions(-)
-
---- a/include/net/sock.h
-+++ b/include/net/sock.h
-@@ -344,6 +344,9 @@ struct sock {
- #define sk_rxhash		__sk_common.skc_rxhash
- 
- 	socket_lock_t		sk_lock;
-+	atomic_t		sk_drops;
-+	int			sk_rcvlowat;
-+	struct sk_buff_head	sk_error_queue;
- 	struct sk_buff_head	sk_receive_queue;
- 	/*
- 	 * The backlog queue is special, it is always used with
-@@ -360,14 +363,13 @@ struct sock {
- 		struct sk_buff	*tail;
- 	} sk_backlog;
- #define sk_rmem_alloc sk_backlog.rmem_alloc
--	int			sk_forward_alloc;
- 
--	__u32			sk_txhash;
-+	int			sk_forward_alloc;
- #ifdef CONFIG_NET_RX_BUSY_POLL
--	unsigned int		sk_napi_id;
- 	unsigned int		sk_ll_usec;
-+	/* ===== mostly read cache line ===== */
-+	unsigned int		sk_napi_id;
- #endif
--	atomic_t		sk_drops;
- 	int			sk_rcvbuf;
- 
- 	struct sk_filter __rcu	*sk_filter;
-@@ -380,11 +382,30 @@ struct sock {
- #endif
- 	struct dst_entry	*sk_rx_dst;
- 	struct dst_entry __rcu	*sk_dst_cache;
--	/* Note: 32bit hole on 64bit arches */
--	atomic_t		sk_wmem_alloc;
- 	atomic_t		sk_omem_alloc;
- 	int			sk_sndbuf;
-+
-+	/* ===== cache line for TX ===== */
-+	int			sk_wmem_queued;
-+	atomic_t		sk_wmem_alloc;
-+	unsigned long		sk_tsq_flags;
-+	struct sk_buff		*sk_send_head;
- 	struct sk_buff_head	sk_write_queue;
-+	__s32			sk_peek_off;
-+	int			sk_write_pending;
-+	long			sk_sndtimeo;
-+	struct timer_list	sk_timer;
-+	__u32			sk_priority;
-+	__u32			sk_mark;
-+	u32			sk_pacing_rate; /* bytes per second */
-+	u32			sk_max_pacing_rate;
-+	struct page_frag	sk_frag;
-+	netdev_features_t	sk_route_caps;
-+	netdev_features_t	sk_route_nocaps;
-+	int			sk_gso_type;
-+	unsigned int		sk_gso_max_size;
-+	gfp_t			sk_allocation;
-+	__u32			sk_txhash;
- 
- 	/*
- 	 * Because of non atomicity rules, all
-@@ -400,31 +421,17 @@ struct sock {
- #define SK_PROTOCOL_MAX U8_MAX
- 	kmemcheck_bitfield_end(flags);
- 
--	int			sk_wmem_queued;
--	gfp_t			sk_allocation;
--	u32			sk_pacing_rate; /* bytes per second */
--	u32			sk_max_pacing_rate;
--	netdev_features_t	sk_route_caps;
--	netdev_features_t	sk_route_nocaps;
--	int			sk_gso_type;
--	unsigned int		sk_gso_max_size;
- 	u16			sk_gso_max_segs;
--	int			sk_rcvlowat;
- 	unsigned long	        sk_lingertime;
--	struct sk_buff_head	sk_error_queue;
- 	struct proto		*sk_prot_creator;
- 	rwlock_t		sk_callback_lock;
- 	int			sk_err,
- 				sk_err_soft;
- 	u32			sk_ack_backlog;
- 	u32			sk_max_ack_backlog;
--	__u32			sk_priority;
--	__u32			sk_mark;
- 	struct pid		*sk_peer_pid;
- 	const struct cred	*sk_peer_cred;
- 	long			sk_rcvtimeo;
--	long			sk_sndtimeo;
--	struct timer_list	sk_timer;
- 	ktime_t			sk_stamp;
- #if BITS_PER_LONG==32
- 	seqlock_t		sk_stamp_seq;
-@@ -434,10 +441,6 @@ struct sock {
- 	u32			sk_tskey;
- 	struct socket		*sk_socket;
- 	void			*sk_user_data;
--	struct page_frag	sk_frag;
--	struct sk_buff		*sk_send_head;
--	__s32			sk_peek_off;
--	int			sk_write_pending;
- #ifdef CONFIG_SECURITY
- 	void			*sk_security;
- #endif
--- a/target/linux/generic/backport-4.9/024-8-tcp-tsq-move-tsq_flags-close-to-sk_wmem_alloc.patch	2022-03-22 08:54:47.078464454 +0800
+++ b/target/linux/generic/backport-4.9/024-8-tcp-tsq-move-tsq_flags-close-to-sk_wmem_alloc.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,176 +0,0 @@
-From 7aa5470c2c09265902b5e4289afa82e4e7c2987e Mon Sep 17 00:00:00 2001
-From: Eric Dumazet <edumazet@google.com>
-Date: Sat, 3 Dec 2016 11:14:57 -0800
-Subject: [PATCH 08/10] tcp: tsq: move tsq_flags close to sk_wmem_alloc
-
-tsq_flags being in the same cache line than sk_wmem_alloc
-makes a lot of sense. Both fields are changed from tcp_wfree()
-and more generally by various TSQ related functions.
-
-Prior patch made room in struct sock and added sk_tsq_flags,
-this patch deletes tsq_flags from struct tcp_sock.
-
-Signed-off-by: Eric Dumazet <edumazet@google.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- include/linux/tcp.h   |  1 -
- net/ipv4/tcp.c        |  4 ++--
- net/ipv4/tcp_ipv4.c   |  2 +-
- net/ipv4/tcp_output.c | 24 +++++++++++-------------
- net/ipv4/tcp_timer.c  |  4 ++--
- net/ipv6/tcp_ipv6.c   |  2 +-
- 6 files changed, 17 insertions(+), 20 deletions(-)
-
---- a/include/linux/tcp.h
-+++ b/include/linux/tcp.h
-@@ -192,7 +192,6 @@ struct tcp_sock {
- 	u32	tsoffset;	/* timestamp offset */
- 
- 	struct list_head tsq_node; /* anchor in tsq_tasklet.head list */
--	unsigned long	tsq_flags;
- 
- 	/* Data for direct copy to user */
- 	struct {
---- a/net/ipv4/tcp.c
-+++ b/net/ipv4/tcp.c
-@@ -665,9 +665,9 @@ static void tcp_push(struct sock *sk, in
- 	if (tcp_should_autocork(sk, skb, size_goal)) {
- 
- 		/* avoid atomic op if TSQ_THROTTLED bit is already set */
--		if (!test_bit(TSQ_THROTTLED, &tp->tsq_flags)) {
-+		if (!test_bit(TSQ_THROTTLED, &sk->sk_tsq_flags)) {
- 			NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPAUTOCORKING);
--			set_bit(TSQ_THROTTLED, &tp->tsq_flags);
-+			set_bit(TSQ_THROTTLED, &sk->sk_tsq_flags);
- 		}
- 		/* It is possible TX completion already happened
- 		 * before we set TSQ_THROTTLED.
---- a/net/ipv4/tcp_ipv4.c
-+++ b/net/ipv4/tcp_ipv4.c
-@@ -446,7 +446,7 @@ void tcp_v4_err(struct sk_buff *icmp_skb
- 			if (!sock_owned_by_user(sk)) {
- 				tcp_v4_mtu_reduced(sk);
- 			} else {
--				if (!test_and_set_bit(TCP_MTU_REDUCED_DEFERRED, &tp->tsq_flags))
-+				if (!test_and_set_bit(TCP_MTU_REDUCED_DEFERRED, &sk->sk_tsq_flags))
- 					sock_hold(sk);
- 			}
- 			goto out;
---- a/net/ipv4/tcp_output.c
-+++ b/net/ipv4/tcp_output.c
-@@ -772,14 +772,15 @@ static void tcp_tasklet_func(unsigned lo
- 	list_for_each_safe(q, n, &list) {
- 		tp = list_entry(q, struct tcp_sock, tsq_node);
- 		list_del(&tp->tsq_node);
--		clear_bit(TSQ_QUEUED, &tp->tsq_flags);
- 
- 		sk = (struct sock *)tp;
-+		clear_bit(TSQ_QUEUED, &sk->sk_tsq_flags);
-+
- 		if (!sk->sk_lock.owned &&
--		    test_bit(TCP_TSQ_DEFERRED, &tp->tsq_flags)) {
-+		    test_bit(TCP_TSQ_DEFERRED, &sk->sk_tsq_flags)) {
- 			bh_lock_sock(sk);
- 			if (!sock_owned_by_user(sk)) {
--				clear_bit(TCP_TSQ_DEFERRED, &tp->tsq_flags);
-+				clear_bit(TCP_TSQ_DEFERRED, &sk->sk_tsq_flags);
- 				tcp_tsq_handler(sk);
- 			}
- 			bh_unlock_sock(sk);
-@@ -802,16 +803,15 @@ static void tcp_tasklet_func(unsigned lo
-  */
- void tcp_release_cb(struct sock *sk)
- {
--	struct tcp_sock *tp = tcp_sk(sk);
- 	unsigned long flags, nflags;
- 
- 	/* perform an atomic operation only if at least one flag is set */
- 	do {
--		flags = tp->tsq_flags;
-+		flags = sk->sk_tsq_flags;
- 		if (!(flags & TCP_DEFERRED_ALL))
- 			return;
- 		nflags = flags & ~TCP_DEFERRED_ALL;
--	} while (cmpxchg(&tp->tsq_flags, flags, nflags) != flags);
-+	} while (cmpxchg(&sk->sk_tsq_flags, flags, nflags) != flags);
- 
- 	if (flags & TCPF_TSQ_DEFERRED)
- 		tcp_tsq_handler(sk);
-@@ -883,7 +883,7 @@ void tcp_wfree(struct sk_buff *skb)
- 	if (wmem >= SKB_TRUESIZE(1) && this_cpu_ksoftirqd() == current)
- 		goto out;
- 
--	for (oval = READ_ONCE(tp->tsq_flags);; oval = nval) {
-+	for (oval = READ_ONCE(sk->sk_tsq_flags);; oval = nval) {
- 		struct tsq_tasklet *tsq;
- 		bool empty;
- 
-@@ -891,7 +891,7 @@ void tcp_wfree(struct sk_buff *skb)
- 			goto out;
- 
- 		nval = (oval & ~TSQF_THROTTLED) | TSQF_QUEUED | TCPF_TSQ_DEFERRED;
--		nval = cmpxchg(&tp->tsq_flags, oval, nval);
-+		nval = cmpxchg(&sk->sk_tsq_flags, oval, nval);
- 		if (nval != oval)
- 			continue;
- 
-@@ -2150,7 +2150,7 @@ static bool tcp_small_queue_check(struct
- 		    skb->prev == sk->sk_write_queue.next)
- 			return false;
- 
--		set_bit(TSQ_THROTTLED, &tcp_sk(sk)->tsq_flags);
-+		set_bit(TSQ_THROTTLED, &sk->sk_tsq_flags);
- 		/* It is possible TX completion already happened
- 		 * before we set TSQ_THROTTLED, so we must
- 		 * test again the condition.
-@@ -2248,8 +2248,8 @@ static bool tcp_write_xmit(struct sock *
- 		    unlikely(tso_fragment(sk, skb, limit, mss_now, gfp)))
- 			break;
- 
--		if (test_bit(TCP_TSQ_DEFERRED, &tp->tsq_flags))
--			clear_bit(TCP_TSQ_DEFERRED, &tp->tsq_flags);
-+		if (test_bit(TCP_TSQ_DEFERRED, &sk->sk_tsq_flags))
-+			clear_bit(TCP_TSQ_DEFERRED, &sk->sk_tsq_flags);
- 		if (tcp_small_queue_check(sk, skb, 0))
- 			break;
- 
-@@ -3560,8 +3560,6 @@ void __tcp_send_ack(struct sock *sk, u32
- 	/* We do not want pure acks influencing TCP Small Queues or fq/pacing
- 	 * too much.
- 	 * SKB_TRUESIZE(max(1 .. 66, MAX_TCP_HEADER)) is unfortunately ~784
--	 * We also avoid tcp_wfree() overhead (cache line miss accessing
--	 * tp->tsq_flags) by using regular sock_wfree()
- 	 */
- 	skb_set_tcp_pure_ack(buff);
- 
---- a/net/ipv4/tcp_timer.c
-+++ b/net/ipv4/tcp_timer.c
-@@ -327,7 +327,7 @@ static void tcp_delack_timer(unsigned lo
- 		inet_csk(sk)->icsk_ack.blocked = 1;
- 		__NET_INC_STATS(sock_net(sk), LINUX_MIB_DELAYEDACKLOCKED);
- 		/* deleguate our work to tcp_release_cb() */
--		if (!test_and_set_bit(TCP_DELACK_TIMER_DEFERRED, &tcp_sk(sk)->tsq_flags))
-+		if (!test_and_set_bit(TCP_DELACK_TIMER_DEFERRED, &sk->sk_tsq_flags))
- 			sock_hold(sk);
- 	}
- 	bh_unlock_sock(sk);
-@@ -610,7 +610,7 @@ static void tcp_write_timer(unsigned lon
- 		tcp_write_timer_handler(sk);
- 	} else {
- 		/* delegate our work to tcp_release_cb() */
--		if (!test_and_set_bit(TCP_WRITE_TIMER_DEFERRED, &tcp_sk(sk)->tsq_flags))
-+		if (!test_and_set_bit(TCP_WRITE_TIMER_DEFERRED, &sk->sk_tsq_flags))
- 			sock_hold(sk);
- 	}
- 	bh_unlock_sock(sk);
---- a/net/ipv6/tcp_ipv6.c
-+++ b/net/ipv6/tcp_ipv6.c
-@@ -404,7 +404,7 @@ static void tcp_v6_err(struct sk_buff *s
- 		if (!sock_owned_by_user(sk))
- 			tcp_v6_mtu_reduced(sk);
- 		else if (!test_and_set_bit(TCP_MTU_REDUCED_DEFERRED,
--					   &tp->tsq_flags))
-+					   &sk->sk_tsq_flags))
- 			sock_hold(sk);
- 		goto out;
- 	}
--- a/target/linux/generic/backport-4.9/024-9-tcp-add-a-missing-barrier-in-tcp_tasklet_func.patch	2022-03-22 08:54:47.078464454 +0800
+++ b/target/linux/generic/backport-4.9/024-9-tcp-add-a-missing-barrier-in-tcp_tasklet_func.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,40 +0,0 @@
-From 0a9648f1293966c838dc570da73c15a76f4c89d6 Mon Sep 17 00:00:00 2001
-From: Eric Dumazet <edumazet@google.com>
-Date: Wed, 21 Dec 2016 05:42:43 -0800
-Subject: [PATCH 09/10] tcp: add a missing barrier in tcp_tasklet_func()
-
-Madalin reported crashes happening in tcp_tasklet_func() on powerpc64
-
-Before TSQ_QUEUED bit is cleared, we must ensure the changes done
-by list_del(&tp->tsq_node); are committed to memory, otherwise
-corruption might happen, as an other cpu could catch TSQ_QUEUED
-clearance too soon.
-
-We can notice that old kernels were immune to this bug, because
-TSQ_QUEUED was cleared after a bh_lock_sock(sk)/bh_unlock_sock(sk)
-section, but they could have missed a kick to write additional bytes,
-when NIC interrupts for a given flow are spread to multiple cpus.
-
-Affected TCP flows would need an incoming ACK or RTO timer to add more
-packets to the pipe. So overall situation should be better now.
-
-Fixes: b223feb9de2a ("tcp: tsq: add shortcut in tcp_tasklet_func()")
-Signed-off-by: Eric Dumazet <edumazet@google.com>
-Reported-by: Madalin Bucur <madalin.bucur@nxp.com>
-Tested-by: Madalin Bucur <madalin.bucur@nxp.com>
-Tested-by: Xing Lei <xing.lei@nxp.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- net/ipv4/tcp_output.c | 1 +
- 1 file changed, 1 insertion(+)
-
---- a/net/ipv4/tcp_output.c
-+++ b/net/ipv4/tcp_output.c
-@@ -774,6 +774,7 @@ static void tcp_tasklet_func(unsigned lo
- 		list_del(&tp->tsq_node);
- 
- 		sk = (struct sock *)tp;
-+		smp_mb__before_atomic();
- 		clear_bit(TSQ_QUEUED, &sk->sk_tsq_flags);
- 
- 		if (!sk->sk_lock.owned &&
--- a/target/linux/generic/backport-4.9/025-tcp-allow-drivers-to-tweak-TSQ-logic.patch	2022-03-22 08:54:47.079464456 +0800
+++ b/target/linux/generic/backport-4.9/025-tcp-allow-drivers-to-tweak-TSQ-logic.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,85 +0,0 @@
-From: Eric Dumazet <edumazet@google.com>
-Date: Sat, 11 Nov 2017 15:54:12 -0800
-Subject: [PATCH] tcp: allow drivers to tweak TSQ logic
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-I had many reports that TSQ logic breaks wifi aggregation.
-
-Current logic is to allow up to 1 ms of bytes to be queued into qdisc
-and drivers queues.
-
-But Wifi aggregation needs a bigger budget to allow bigger rates to
-be discovered by various TCP Congestion Controls algorithms.
-
-This patch adds an extra socket field, allowing wifi drivers to select
-another log scale to derive TCP Small Queue credit from current pacing
-rate.
-
-Initial value is 10, meaning that this patch does not change current
-behavior.
-
-We expect wifi drivers to set this field to smaller values (tests have
-been done with values from 6 to 9)
-
-They would have to use following template :
-
-if (skb->sk && skb->sk->sk_pacing_shift != MY_PACING_SHIFT)
-     skb->sk->sk_pacing_shift = MY_PACING_SHIFT;
-
-Ref: https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1670041
-Signed-off-by: Eric Dumazet <edumazet@google.com>
-Cc: Johannes Berg <johannes.berg@intel.com>
-Cc: Toke Hiland-Jrgensen <toke@toke.dk>
-Cc: Kir Kolyshkin <kir@openvz.org>
----
---- a/include/net/sock.h
-+++ b/include/net/sock.h
-@@ -260,6 +260,7 @@ struct sock_common {
-   *	@sk_gso_type: GSO type (e.g. %SKB_GSO_TCPV4)
-   *	@sk_gso_max_size: Maximum GSO segment size to build
-   *	@sk_gso_max_segs: Maximum number of GSO segments
-+  *	@sk_pacing_shift: scaling factor for TCP Small Queues
-   *	@sk_lingertime: %SO_LINGER l_linger setting
-   *	@sk_backlog: always used with the per-socket spinlock held
-   *	@sk_callback_lock: used with the callbacks in the end of this struct
-@@ -422,6 +423,8 @@ struct sock {
- 	kmemcheck_bitfield_end(flags);
- 
- 	u16			sk_gso_max_segs;
-+#define sk_pacing_shift sk_pacing_shift /* for backport checks */
-+	u8			sk_pacing_shift;
- 	unsigned long	        sk_lingertime;
- 	struct proto		*sk_prot_creator;
- 	rwlock_t		sk_callback_lock;
---- a/net/core/sock.c
-+++ b/net/core/sock.c
-@@ -2484,6 +2484,7 @@ void sock_init_data(struct socket *sock,
- 
- 	sk->sk_max_pacing_rate = ~0U;
- 	sk->sk_pacing_rate = ~0U;
-+	sk->sk_pacing_shift = 10;
- 	sk->sk_incoming_cpu = -1;
- 	/*
- 	 * Before updating sk_refcnt, we must commit prior changes to memory
---- a/net/ipv4/tcp_output.c
-+++ b/net/ipv4/tcp_output.c
-@@ -1606,7 +1606,7 @@ u32 tcp_tso_autosize(const struct sock *
- {
- 	u32 bytes, segs;
- 
--	bytes = min(sk->sk_pacing_rate >> 10,
-+	bytes = min(sk->sk_pacing_rate >> sk->sk_pacing_shift,
- 		    sk->sk_gso_max_size - 1 - MAX_TCP_HEADER);
- 
- 	/* Goal is to send at least one packet per ms,
-@@ -2137,7 +2137,7 @@ static bool tcp_small_queue_check(struct
- {
- 	unsigned int limit;
- 
--	limit = max(2 * skb->truesize, sk->sk_pacing_rate >> 10);
-+	limit = max(2 * skb->truesize, sk->sk_pacing_rate >> sk->sk_pacing_shift);
- 	limit = min_t(u32, limit, sysctl_tcp_limit_output_bytes);
- 	limit <<= factor;
- 
--- a/target/linux/generic/backport-4.9/030-01-ubifs-Drop-softlimit-and-delta-fields-from-struct-ub.patch	2022-03-22 08:54:47.079464456 +0800
+++ b/target/linux/generic/backport-4.9/030-01-ubifs-Drop-softlimit-and-delta-fields-from-struct-ub.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,82 +0,0 @@
-From 854826c9d526fd81077742c3b000e3f7fcaef3ce Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Tue, 20 Sep 2016 10:36:14 +0200
-Subject: [PATCH] ubifs: Drop softlimit and delta fields from struct ubifs_wbuf
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Values of these fields are set during init and never modified. They are
-used (read) in a single function only. There isn't really any reason to
-keep them in a struct. It only makes struct just a bit bigger without
-any visible gain.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Reviewed-by: Boris Brezillon <boris.brezillon@free-electrons.com>
-Signed-off-by: Richard Weinberger <richard@nod.at>
----
- fs/ubifs/io.c    | 18 ++++++++++--------
- fs/ubifs/ubifs.h |  5 -----
- 2 files changed, 10 insertions(+), 13 deletions(-)
-
---- a/fs/ubifs/io.c
-+++ b/fs/ubifs/io.c
-@@ -452,16 +452,22 @@ static enum hrtimer_restart wbuf_timer_c
-  */
- static void new_wbuf_timer_nolock(struct ubifs_wbuf *wbuf)
- {
-+	ktime_t softlimit = ktime_set(WBUF_TIMEOUT_SOFTLIMIT, 0);
-+	unsigned long long delta;
-+
-+	delta = WBUF_TIMEOUT_HARDLIMIT - WBUF_TIMEOUT_SOFTLIMIT;
-+	delta *= 1000000000ULL;
-+
- 	ubifs_assert(!hrtimer_active(&wbuf->timer));
-+	ubifs_assert(delta <= ULONG_MAX);
- 
- 	if (wbuf->no_timer)
- 		return;
- 	dbg_io("set timer for jhead %s, %llu-%llu millisecs",
- 	       dbg_jhead(wbuf->jhead),
--	       div_u64(ktime_to_ns(wbuf->softlimit), USEC_PER_SEC),
--	       div_u64(ktime_to_ns(wbuf->softlimit) + wbuf->delta,
--		       USEC_PER_SEC));
--	hrtimer_start_range_ns(&wbuf->timer, wbuf->softlimit, wbuf->delta,
-+	       div_u64(ktime_to_ns(softlimit), USEC_PER_SEC),
-+	       div_u64(ktime_to_ns(softlimit) + delta, USEC_PER_SEC));
-+	hrtimer_start_range_ns(&wbuf->timer, softlimit, delta,
- 			       HRTIMER_MODE_REL);
- }
- 
-@@ -1059,10 +1065,6 @@ int ubifs_wbuf_init(struct ubifs_info *c
- 
- 	hrtimer_init(&wbuf->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
- 	wbuf->timer.function = wbuf_timer_callback_nolock;
--	wbuf->softlimit = ktime_set(WBUF_TIMEOUT_SOFTLIMIT, 0);
--	wbuf->delta = WBUF_TIMEOUT_HARDLIMIT - WBUF_TIMEOUT_SOFTLIMIT;
--	wbuf->delta *= 1000000000ULL;
--	ubifs_assert(wbuf->delta <= ULONG_MAX);
- 	return 0;
- }
- 
---- a/fs/ubifs/ubifs.h
-+++ b/fs/ubifs/ubifs.h
-@@ -645,9 +645,6 @@ typedef int (*ubifs_lpt_scan_callback)(s
-  * @io_mutex: serializes write-buffer I/O
-  * @lock: serializes @buf, @lnum, @offs, @avail, @used, @next_ino and @inodes
-  *        fields
-- * @softlimit: soft write-buffer timeout interval
-- * @delta: hard and soft timeouts delta (the timer expire interval is @softlimit
-- *         and @softlimit + @delta)
-  * @timer: write-buffer timer
-  * @no_timer: non-zero if this write-buffer does not have a timer
-  * @need_sync: non-zero if the timer expired and the wbuf needs sync'ing
-@@ -676,8 +673,6 @@ struct ubifs_wbuf {
- 	int (*sync_callback)(struct ubifs_info *c, int lnum, int free, int pad);
- 	struct mutex io_mutex;
- 	spinlock_t lock;
--	ktime_t softlimit;
--	unsigned long long delta;
- 	struct hrtimer timer;
- 	unsigned int no_timer:1;
- 	unsigned int need_sync:1;
--- a/target/linux/generic/backport-4.9/030-02-ubifs-Use-dirty_writeback_interval-value-for-wbuf-ti.patch	2022-03-22 08:54:47.080464458 +0800
+++ b/target/linux/generic/backport-4.9/030-02-ubifs-Use-dirty_writeback_interval-value-for-wbuf-ti.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,66 +0,0 @@
-From 1b7fc2c0069f3864a3dda15430b7aded31c0bfcc Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Tue, 20 Sep 2016 10:36:15 +0200
-Subject: [PATCH] ubifs: Use dirty_writeback_interval value for wbuf timer
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Right now wbuf timer has hardcoded timeouts and there is no place for
-manual adjustments. Some projects / cases many need that though. Few
-file systems allow doing that by respecting dirty_writeback_interval
-that can be set using sysctl (dirty_writeback_centisecs).
-
-Lowering dirty_writeback_interval could be some way of dealing with user
-space apps lacking proper fsyncs. This is definitely *not* a perfect
-solution but we don't have ideal (user space) world. There were already
-advanced discussions on this matter, mostly when ext4 was introduced and
-it wasn't behaving as ext3. Anyway, the final decision was to add some
-hacks to the ext4, as trying to fix whole user space or adding new API
-was pointless.
-
-We can't (and shouldn't?) just follow ext4. We can't e.g. sync on close
-as this would cause too many commits and flash wearing. On the other
-hand we still should allow some trade-off between -o sync and default
-wbuf timeout. Respecting dirty_writeback_interval should allow some sane
-cutomizations if used warily.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Reviewed-by: Boris Brezillon <boris.brezillon@free-electrons.com>
-Signed-off-by: Richard Weinberger <richard@nod.at>
----
- fs/ubifs/io.c    | 8 ++++----
- fs/ubifs/ubifs.h | 4 ----
- 2 files changed, 4 insertions(+), 8 deletions(-)
-
---- a/fs/ubifs/io.c
-+++ b/fs/ubifs/io.c
-@@ -452,11 +452,11 @@ static enum hrtimer_restart wbuf_timer_c
-  */
- static void new_wbuf_timer_nolock(struct ubifs_wbuf *wbuf)
- {
--	ktime_t softlimit = ktime_set(WBUF_TIMEOUT_SOFTLIMIT, 0);
--	unsigned long long delta;
-+	ktime_t softlimit = ms_to_ktime(dirty_writeback_interval * 10);
-+	unsigned long long delta = dirty_writeback_interval;
- 
--	delta = WBUF_TIMEOUT_HARDLIMIT - WBUF_TIMEOUT_SOFTLIMIT;
--	delta *= 1000000000ULL;
-+	/* centi to milli, milli to nano, then 10% */
-+	delta *= 10ULL * NSEC_PER_MSEC / 10ULL;
- 
- 	ubifs_assert(!hrtimer_active(&wbuf->timer));
- 	ubifs_assert(delta <= ULONG_MAX);
---- a/fs/ubifs/ubifs.h
-+++ b/fs/ubifs/ubifs.h
-@@ -83,10 +83,6 @@
-  */
- #define BGT_NAME_PATTERN "ubifs_bgt%d_%d"
- 
--/* Write-buffer synchronization timeout interval in seconds */
--#define WBUF_TIMEOUT_SOFTLIMIT 3
--#define WBUF_TIMEOUT_HARDLIMIT 5
--
- /* Maximum possible inode number (only 32-bit inodes are supported now) */
- #define MAX_INUM 0xFFFFFFFF
- 
--- a/target/linux/generic/backport-4.9/040-mm-add-support-for-releasing-multiple-instances-of-a.patch	2022-03-22 08:54:47.080464458 +0800
+++ b/target/linux/generic/backport-4.9/040-mm-add-support-for-releasing-multiple-instances-of-a.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,75 +0,0 @@
-From: Alexander Duyck <alexander.h.duyck@intel.com>
-Date: Wed, 14 Dec 2016 15:05:26 -0800
-Subject: [PATCH] mm: add support for releasing multiple instances of a page
-
-Add a function that allows us to batch free a page that has multiple
-references outstanding.  Specifically this function can be used to drop
-a page being used in the page frag alloc cache.  With this drivers can
-make use of functionality similar to the page frag alloc cache without
-having to do any workarounds for the fact that there is no function that
-frees multiple references.
-
-Link: http://lkml.kernel.org/r/20161110113606.76501.70752.stgit@ahduyck-blue-test.jf.intel.com
-Signed-off-by: Alexander Duyck <alexander.h.duyck@intel.com>
-Cc: "David S. Miller" <davem@davemloft.net>
-Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
-Cc: Chris Metcalf <cmetcalf@mellanox.com>
-Cc: David Howells <dhowells@redhat.com>
-Cc: Geert Uytterhoeven <geert@linux-m68k.org>
-Cc: Hans-Christian Noren Egtvedt <egtvedt@samfundet.no>
-Cc: Helge Deller <deller@gmx.de>
-Cc: James Hogan <james.hogan@imgtec.com>
-Cc: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
-Cc: Jonas Bonn <jonas@southpole.se>
-Cc: Keguang Zhang <keguang.zhang@gmail.com>
-Cc: Ley Foon Tan <lftan@altera.com>
-Cc: Mark Salter <msalter@redhat.com>
-Cc: Max Filippov <jcmvbkbc@gmail.com>
-Cc: Michael Ellerman <mpe@ellerman.id.au>
-Cc: Michal Simek <monstr@monstr.eu>
-Cc: Ralf Baechle <ralf@linux-mips.org>
-Cc: Rich Felker <dalias@libc.org>
-Cc: Richard Kuo <rkuo@codeaurora.org>
-Cc: Russell King <linux@armlinux.org.uk>
-Cc: Steven Miao <realmz6@gmail.com>
-Cc: Tobias Klauser <tklauser@distanz.ch>
-Cc: Vineet Gupta <vgupta@synopsys.com>
-Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
-Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
-Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
----
-
---- a/include/linux/gfp.h
-+++ b/include/linux/gfp.h
-@@ -529,6 +529,8 @@ extern void free_hot_cold_page(struct pa
- extern void free_hot_cold_page_list(struct list_head *list, bool cold);
- 
- struct page_frag_cache;
-+extern void __page_frag_drain(struct page *page, unsigned int order,
-+			      unsigned int count);
- extern void *__alloc_page_frag(struct page_frag_cache *nc,
- 			       unsigned int fragsz, gfp_t gfp_mask);
- extern void __free_page_frag(void *addr);
---- a/mm/page_alloc.c
-+++ b/mm/page_alloc.c
-@@ -3935,6 +3935,20 @@ static struct page *__page_frag_refill(s
- 	return page;
- }
- 
-+void __page_frag_drain(struct page *page, unsigned int order,
-+		       unsigned int count)
-+{
-+	VM_BUG_ON_PAGE(page_ref_count(page) == 0, page);
-+
-+	if (page_ref_sub_and_test(page, count)) {
-+		if (order == 0)
-+			free_hot_cold_page(page, false);
-+		else
-+			__free_pages_ok(page, order);
-+	}
-+}
-+EXPORT_SYMBOL(__page_frag_drain);
-+
- void *__alloc_page_frag(struct page_frag_cache *nc,
- 			unsigned int fragsz, gfp_t gfp_mask)
- {
--- a/target/linux/generic/backport-4.9/041-mm-rename-__alloc_page_frag-to-page_frag_alloc-and-_.patch	2022-03-22 08:54:47.080464458 +0800
+++ b/target/linux/generic/backport-4.9/041-mm-rename-__alloc_page_frag-to-page_frag_alloc-and-_.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,137 +0,0 @@
-From: Alexander Duyck <alexander.h.duyck@intel.com>
-Date: Tue, 10 Jan 2017 16:58:06 -0800
-Subject: [PATCH] mm: rename __alloc_page_frag to page_frag_alloc and
- __free_page_frag to page_frag_free
-
-Patch series "Page fragment updates", v4.
-
-This patch series takes care of a few cleanups for the page fragments
-API.
-
-First we do some renames so that things are much more consistent.  First
-we move the page_frag_ portion of the name to the front of the functions
-names.  Secondly we split out the cache specific functions from the
-other page fragment functions by adding the word "cache" to the name.
-
-Finally I added a bit of documentation that will hopefully help to
-explain some of this.  I plan to revisit this later as we get things
-more ironed out in the near future with the changes planned for the DMA
-setup to support eXpress Data Path.
-
-This patch (of 3):
-
-This patch renames the page frag functions to be more consistent with
-other APIs.  Specifically we place the name page_frag first in the name
-and then have either an alloc or free call name that we append as the
-suffix.  This makes it a bit clearer in terms of naming.
-
-In addition we drop the leading double underscores since we are
-technically no longer a backing interface and instead the front end that
-is called from the networking APIs.
-
-Link: http://lkml.kernel.org/r/20170104023854.13451.67390.stgit@localhost.localdomain
-Signed-off-by: Alexander Duyck <alexander.h.duyck@intel.com>
-Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
-Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
----
-
---- a/include/linux/gfp.h
-+++ b/include/linux/gfp.h
-@@ -531,9 +531,9 @@ extern void free_hot_cold_page_list(stru
- struct page_frag_cache;
- extern void __page_frag_drain(struct page *page, unsigned int order,
- 			      unsigned int count);
--extern void *__alloc_page_frag(struct page_frag_cache *nc,
--			       unsigned int fragsz, gfp_t gfp_mask);
--extern void __free_page_frag(void *addr);
-+extern void *page_frag_alloc(struct page_frag_cache *nc,
-+			     unsigned int fragsz, gfp_t gfp_mask);
-+extern void page_frag_free(void *addr);
- 
- #define __free_page(page) __free_pages((page), 0)
- #define free_page(addr) free_pages((addr), 0)
---- a/include/linux/skbuff.h
-+++ b/include/linux/skbuff.h
-@@ -2477,7 +2477,7 @@ static inline struct sk_buff *netdev_all
- 
- static inline void skb_free_frag(void *addr)
- {
--	__free_page_frag(addr);
-+	page_frag_free(addr);
- }
- 
- void *napi_alloc_frag(unsigned int fragsz);
---- a/mm/page_alloc.c
-+++ b/mm/page_alloc.c
-@@ -3949,8 +3949,8 @@ void __page_frag_drain(struct page *page
- }
- EXPORT_SYMBOL(__page_frag_drain);
- 
--void *__alloc_page_frag(struct page_frag_cache *nc,
--			unsigned int fragsz, gfp_t gfp_mask)
-+void *page_frag_alloc(struct page_frag_cache *nc,
-+		      unsigned int fragsz, gfp_t gfp_mask)
- {
- 	unsigned int size = PAGE_SIZE;
- 	struct page *page;
-@@ -4001,19 +4001,19 @@ refill:
- 
- 	return nc->va + offset;
- }
--EXPORT_SYMBOL(__alloc_page_frag);
-+EXPORT_SYMBOL(page_frag_alloc);
- 
- /*
-  * Frees a page fragment allocated out of either a compound or order 0 page.
-  */
--void __free_page_frag(void *addr)
-+void page_frag_free(void *addr)
- {
- 	struct page *page = virt_to_head_page(addr);
- 
- 	if (unlikely(put_page_testzero(page)))
- 		__free_pages_ok(page, compound_order(page));
- }
--EXPORT_SYMBOL(__free_page_frag);
-+EXPORT_SYMBOL(page_frag_free);
- 
- static void *make_alloc_exact(unsigned long addr, unsigned int order,
- 		size_t size)
---- a/net/core/skbuff.c
-+++ b/net/core/skbuff.c
-@@ -369,7 +369,7 @@ static void *__netdev_alloc_frag(unsigne
- 
- 	local_irq_save(flags);
- 	nc = this_cpu_ptr(&netdev_alloc_cache);
--	data = __alloc_page_frag(nc, fragsz, gfp_mask);
-+	data = page_frag_alloc(nc, fragsz, gfp_mask);
- 	local_irq_restore(flags);
- 	return data;
- }
-@@ -393,7 +393,7 @@ static void *__napi_alloc_frag(unsigned
- {
- 	struct napi_alloc_cache *nc = this_cpu_ptr(&napi_alloc_cache);
- 
--	return __alloc_page_frag(&nc->page, fragsz, gfp_mask);
-+	return page_frag_alloc(&nc->page, fragsz, gfp_mask);
- }
- 
- void *napi_alloc_frag(unsigned int fragsz)
-@@ -445,7 +445,7 @@ struct sk_buff *__netdev_alloc_skb(struc
- 	local_irq_save(flags);
- 
- 	nc = this_cpu_ptr(&netdev_alloc_cache);
--	data = __alloc_page_frag(nc, len, gfp_mask);
-+	data = page_frag_alloc(nc, len, gfp_mask);
- 	pfmemalloc = nc->pfmemalloc;
- 
- 	local_irq_restore(flags);
-@@ -509,7 +509,7 @@ struct sk_buff *__napi_alloc_skb(struct
- 	if (sk_memalloc_socks())
- 		gfp_mask |= __GFP_MEMALLOC;
- 
--	data = __alloc_page_frag(&nc->page, len, gfp_mask);
-+	data = page_frag_alloc(&nc->page, len, gfp_mask);
- 	if (unlikely(!data))
- 		return NULL;
- 
--- a/target/linux/generic/backport-4.9/042-mm-rename-__page_frag-functions-to-__page_frag_cache.patch	2022-03-22 08:54:47.081464459 +0800
+++ b/target/linux/generic/backport-4.9/042-mm-rename-__page_frag-functions-to-__page_frag_cache.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,79 +0,0 @@
-From: Alexander Duyck <alexander.h.duyck@intel.com>
-Date: Tue, 10 Jan 2017 16:58:09 -0800
-Subject: [PATCH] mm: rename __page_frag functions to __page_frag_cache, drop
- order from drain
-
-This patch does two things.
-
-First it goes through and renames the __page_frag prefixed functions to
-__page_frag_cache so that we can be clear that we are draining or
-refilling the cache, not the frags themselves.
-
-Second we drop the order parameter from __page_frag_cache_drain since we
-don't actually need to pass it since all fragments are either order 0 or
-must be a compound page.
-
-Link: http://lkml.kernel.org/r/20170104023954.13451.5678.stgit@localhost.localdomain
-Signed-off-by: Alexander Duyck <alexander.h.duyck@intel.com>
-Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
-Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
----
-
---- a/include/linux/gfp.h
-+++ b/include/linux/gfp.h
-@@ -529,8 +529,7 @@ extern void free_hot_cold_page(struct pa
- extern void free_hot_cold_page_list(struct list_head *list, bool cold);
- 
- struct page_frag_cache;
--extern void __page_frag_drain(struct page *page, unsigned int order,
--			      unsigned int count);
-+extern void __page_frag_cache_drain(struct page *page, unsigned int count);
- extern void *page_frag_alloc(struct page_frag_cache *nc,
- 			     unsigned int fragsz, gfp_t gfp_mask);
- extern void page_frag_free(void *addr);
---- a/mm/page_alloc.c
-+++ b/mm/page_alloc.c
-@@ -3914,8 +3914,8 @@ EXPORT_SYMBOL(free_pages);
-  * drivers to provide a backing region of memory for use as either an
-  * sk_buff->head, or to be used in the "frags" portion of skb_shared_info.
-  */
--static struct page *__page_frag_refill(struct page_frag_cache *nc,
--				       gfp_t gfp_mask)
-+static struct page *__page_frag_cache_refill(struct page_frag_cache *nc,
-+					     gfp_t gfp_mask)
- {
- 	struct page *page = NULL;
- 	gfp_t gfp = gfp_mask;
-@@ -3935,19 +3935,20 @@ static struct page *__page_frag_refill(s
- 	return page;
- }
- 
--void __page_frag_drain(struct page *page, unsigned int order,
--		       unsigned int count)
-+void __page_frag_cache_drain(struct page *page, unsigned int count)
- {
- 	VM_BUG_ON_PAGE(page_ref_count(page) == 0, page);
- 
- 	if (page_ref_sub_and_test(page, count)) {
-+		unsigned int order = compound_order(page);
-+
- 		if (order == 0)
- 			free_hot_cold_page(page, false);
- 		else
- 			__free_pages_ok(page, order);
- 	}
- }
--EXPORT_SYMBOL(__page_frag_drain);
-+EXPORT_SYMBOL(__page_frag_cache_drain);
- 
- void *page_frag_alloc(struct page_frag_cache *nc,
- 		      unsigned int fragsz, gfp_t gfp_mask)
-@@ -3958,7 +3959,7 @@ void *page_frag_alloc(struct page_frag_c
- 
- 	if (unlikely(!nc->va)) {
- refill:
--		page = __page_frag_refill(nc, gfp_mask);
-+		page = __page_frag_cache_refill(nc, gfp_mask);
- 		if (!page)
- 			return NULL;
- 
--- a/target/linux/generic/backport-4.9/060-0002-mtd-bcm47xxsflash-use-platform_-set-get-_drvdata.patch	2022-03-22 08:54:47.081464459 +0800
+++ b/target/linux/generic/backport-4.9/060-0002-mtd-bcm47xxsflash-use-platform_-set-get-_drvdata.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,63 +0,0 @@
-From be5e5099183301fb7920f8f6b66bd3ac1f820a97 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Mon, 16 Jan 2017 17:28:18 +0100
-Subject: [PATCH] mtd: bcm47xxsflash: use platform_(set|get)_drvdata
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-We have generic place & helpers for storing platform driver data so
-there is no reason for using custom priv pointer.
-
-This allows cleaning up struct bcma_sflash from unneeded fields.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Acked-by: Kalle Valo <kvalo@codeaurora.org>
-Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com>
-Signed-off-by: Brian Norris <computersforpeace@gmail.com>
----
- drivers/mtd/devices/bcm47xxsflash.c         | 6 +++---
- include/linux/bcma/bcma_driver_chipcommon.h | 3 ---
- 2 files changed, 3 insertions(+), 6 deletions(-)
-
---- a/drivers/mtd/devices/bcm47xxsflash.c
-+++ b/drivers/mtd/devices/bcm47xxsflash.c
-@@ -284,7 +284,6 @@ static int bcm47xxsflash_bcma_probe(stru
- 	b47s = devm_kzalloc(dev, sizeof(*b47s), GFP_KERNEL);
- 	if (!b47s)
- 		return -ENOMEM;
--	sflash->priv = b47s;
- 
- 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
- 	if (!res) {
-@@ -320,6 +319,8 @@ static int bcm47xxsflash_bcma_probe(stru
- 	b47s->size = sflash->size;
- 	bcm47xxsflash_fill_mtd(b47s, &pdev->dev);
- 
-+	platform_set_drvdata(pdev, b47s);
-+
- 	err = mtd_device_parse_register(&b47s->mtd, probes, NULL, NULL, 0);
- 	if (err) {
- 		pr_err("Failed to register MTD device: %d\n", err);
-@@ -335,8 +336,7 @@ static int bcm47xxsflash_bcma_probe(stru
- 
- static int bcm47xxsflash_bcma_remove(struct platform_device *pdev)
- {
--	struct bcma_sflash *sflash = dev_get_platdata(&pdev->dev);
--	struct bcm47xxsflash *b47s = sflash->priv;
-+	struct bcm47xxsflash *b47s = platform_get_drvdata(pdev);
- 
- 	mtd_device_unregister(&b47s->mtd);
- 	iounmap(b47s->window);
---- a/include/linux/bcma/bcma_driver_chipcommon.h
-+++ b/include/linux/bcma/bcma_driver_chipcommon.h
-@@ -593,9 +593,6 @@ struct bcma_sflash {
- 	u32 blocksize;
- 	u16 numblocks;
- 	u32 size;
--
--	struct mtd_info *mtd;
--	void *priv;
- };
- #endif
- 
--- a/target/linux/generic/backport-4.9/060-0003-mtd-bcm47xxsflash-support-reading-flash-out-of-mappi.patch	2022-03-22 08:54:47.081464459 +0800
+++ b/target/linux/generic/backport-4.9/060-0003-mtd-bcm47xxsflash-support-reading-flash-out-of-mappi.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,81 +0,0 @@
-From ccc38234fdc70120be79e7fb2df5c27ca5cd4c8a Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Wed, 8 Feb 2017 23:53:44 +0100
-Subject: [PATCH] mtd: bcm47xxsflash: support reading flash out of mapping
- window
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-For reading flash content we use MMIO but it's possible to read only
-first 16 MiB this way. It's simply an arch design/limitation.
-To support flash sizes bigger than 16 MiB implement indirect access
-using ChipCommon registers.
-This has been tested using MX25L25635F.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Acked-by: Marek Vasut <marek.vasut@gmail.com>
-Signed-off-by: Brian Norris <computersforpeace@gmail.com>
----
- drivers/mtd/devices/bcm47xxsflash.c | 24 +++++++++++++++++++++---
- drivers/mtd/devices/bcm47xxsflash.h |  3 +++
- 2 files changed, 24 insertions(+), 3 deletions(-)
-
---- a/drivers/mtd/devices/bcm47xxsflash.c
-+++ b/drivers/mtd/devices/bcm47xxsflash.c
-@@ -105,15 +105,33 @@ static int bcm47xxsflash_read(struct mtd
- 			      size_t *retlen, u_char *buf)
- {
- 	struct bcm47xxsflash *b47s = mtd->priv;
-+	size_t orig_len = len;
- 
- 	/* Check address range */
- 	if ((from + len) > mtd->size)
- 		return -EINVAL;
- 
--	memcpy_fromio(buf, b47s->window + from, len);
--	*retlen = len;
-+	/* Read as much as possible using fast MMIO window */
-+	if (from < BCM47XXSFLASH_WINDOW_SZ) {
-+		size_t memcpy_len;
- 
--	return len;
-+		memcpy_len = min(len, (size_t)(BCM47XXSFLASH_WINDOW_SZ - from));
-+		memcpy_fromio(buf, b47s->window + from, memcpy_len);
-+		from += memcpy_len;
-+		len -= memcpy_len;
-+		buf += memcpy_len;
-+	}
-+
-+	/* Use indirect access for content out of the window */
-+	for (; len; len--) {
-+		b47s->cc_write(b47s, BCMA_CC_FLASHADDR, from++);
-+		bcm47xxsflash_cmd(b47s, OPCODE_ST_READ4B);
-+		*buf++ = b47s->cc_read(b47s, BCMA_CC_FLASHDATA);
-+	}
-+
-+	*retlen = orig_len;
-+
-+	return orig_len;
- }
- 
- static int bcm47xxsflash_write_st(struct mtd_info *mtd, u32 offset, size_t len,
---- a/drivers/mtd/devices/bcm47xxsflash.h
-+++ b/drivers/mtd/devices/bcm47xxsflash.h
-@@ -3,6 +3,8 @@
- 
- #include <linux/mtd/mtd.h>
- 
-+#define BCM47XXSFLASH_WINDOW_SZ			SZ_16M
-+
- /* Used for ST flashes only. */
- #define OPCODE_ST_WREN		0x0006		/* Write Enable */
- #define OPCODE_ST_WRDIS		0x0004		/* Write Disable */
-@@ -16,6 +18,7 @@
- #define OPCODE_ST_RES		0x03ab		/* Read Electronic Signature */
- #define OPCODE_ST_CSA		0x1000		/* Keep chip select asserted */
- #define OPCODE_ST_SSE		0x0220		/* Sub-sector Erase */
-+#define OPCODE_ST_READ4B	0x6313		/* Read Data Bytes in 4Byte addressing mode */
- 
- /* Used for Atmel flashes only. */
- #define OPCODE_AT_READ				0x07e8
--- a/target/linux/generic/backport-4.9/060-0004-mtd-bcm47xxpart-move-TRX-parsing-code-to-separated-f.patch	2022-03-22 08:54:47.082464461 +0800
+++ b/target/linux/generic/backport-4.9/060-0004-mtd-bcm47xxpart-move-TRX-parsing-code-to-separated-f.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,180 +0,0 @@
-From b522d7b0ebe3539340c2a6d46d787ae3d33bcb92 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Tue, 10 Jan 2017 23:15:24 +0100
-Subject: [PATCH] mtd: bcm47xxpart: move TRX parsing code to separated function
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-This change simplifies main parsing loop logic a bit. In future it may
-be useful for moving TRX support to separated module / parser (if we
-implement support for them at some point).
-Finally parsing TRX at the end puts us in a better position as we have
-better flash layout knowledge. It may be useful e.g. if it appears there
-is more than 1 TRX partition.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Acked-by: Marek Vasut <marek.vasut@gmail.com>
-Signed-off-by: Brian Norris <computersforpeace@gmail.com>
----
- drivers/mtd/bcm47xxpart.c | 121 ++++++++++++++++++++++++++++------------------
- 1 file changed, 74 insertions(+), 47 deletions(-)
-
---- a/drivers/mtd/bcm47xxpart.c
-+++ b/drivers/mtd/bcm47xxpart.c
-@@ -83,6 +83,67 @@ out_default:
- 	return "rootfs";
- }
- 
-+static int bcm47xxpart_parse_trx(struct mtd_info *master,
-+				 struct mtd_partition *trx,
-+				 struct mtd_partition *parts,
-+				 size_t parts_len)
-+{
-+	struct trx_header header;
-+	size_t bytes_read;
-+	int curr_part = 0;
-+	int i, err;
-+
-+	if (parts_len < 3) {
-+		pr_warn("No enough space to add TRX partitions!\n");
-+		return -ENOMEM;
-+	}
-+
-+	err = mtd_read(master, trx->offset, sizeof(header), &bytes_read,
-+		       (uint8_t *)&header);
-+	if (err && !mtd_is_bitflip(err)) {
-+		pr_err("mtd_read error while reading TRX header: %d\n", err);
-+		return err;
-+	}
-+
-+	i = 0;
-+
-+	/* We have LZMA loader if offset[2] points to sth */
-+	if (header.offset[2]) {
-+		bcm47xxpart_add_part(&parts[curr_part++], "loader",
-+				     trx->offset + header.offset[i], 0);
-+		i++;
-+	}
-+
-+	if (header.offset[i]) {
-+		bcm47xxpart_add_part(&parts[curr_part++], "linux",
-+				     trx->offset + header.offset[i], 0);
-+		i++;
-+	}
-+
-+	if (header.offset[i]) {
-+		size_t offset = trx->offset + header.offset[i];
-+		const char *name = bcm47xxpart_trx_data_part_name(master,
-+								  offset);
-+
-+		bcm47xxpart_add_part(&parts[curr_part++], name, offset, 0);
-+		i++;
-+	}
-+
-+	/*
-+	 * Assume that every partition ends at the beginning of the one it is
-+	 * followed by.
-+	 */
-+	for (i = 0; i < curr_part; i++) {
-+		u64 next_part_offset = (i < curr_part - 1) ?
-+					parts[i + 1].offset :
-+					trx->offset + trx->size;
-+
-+		parts[i].size = next_part_offset - parts[i].offset;
-+	}
-+
-+	return curr_part;
-+}
-+
- static int bcm47xxpart_parse(struct mtd_info *master,
- 			     const struct mtd_partition **pparts,
- 			     struct mtd_part_parser_data *data)
-@@ -93,9 +154,7 @@ static int bcm47xxpart_parse(struct mtd_
- 	size_t bytes_read;
- 	uint32_t offset;
- 	uint32_t blocksize = master->erasesize;
--	struct trx_header *trx;
- 	int trx_part = -1;
--	int last_trx_part = -1;
- 	int possible_nvram_sizes[] = { 0x8000, 0xF000, 0x10000, };
- 	int err;
- 
-@@ -182,54 +241,14 @@ static int bcm47xxpart_parse(struct mtd_
- 
- 		/* TRX */
- 		if (buf[0x000 / 4] == TRX_MAGIC) {
--			if (BCM47XXPART_MAX_PARTS - curr_part < 4) {
--				pr_warn("Not enough partitions left to register trx, scanning stopped!\n");
--				break;
--			}
--
--			trx = (struct trx_header *)buf;
-+			struct trx_header *trx;
- 
- 			trx_part = curr_part;
- 			bcm47xxpart_add_part(&parts[curr_part++], "firmware",
- 					     offset, 0);
- 
--			i = 0;
--			/* We have LZMA loader if offset[2] points to sth */
--			if (trx->offset[2]) {
--				bcm47xxpart_add_part(&parts[curr_part++],
--						     "loader",
--						     offset + trx->offset[i],
--						     0);
--				i++;
--			}
--
--			if (trx->offset[i]) {
--				bcm47xxpart_add_part(&parts[curr_part++],
--						     "linux",
--						     offset + trx->offset[i],
--						     0);
--				i++;
--			}
--
--			/*
--			 * Pure rootfs size is known and can be calculated as:
--			 * trx->length - trx->offset[i]. We don't fill it as
--			 * we want to have jffs2 (overlay) in the same mtd.
--			 */
--			if (trx->offset[i]) {
--				const char *name;
--
--				name = bcm47xxpart_trx_data_part_name(master, offset + trx->offset[i]);
--				bcm47xxpart_add_part(&parts[curr_part++],
--						     name,
--						     offset + trx->offset[i],
--						     0);
--				i++;
--			}
--
--			last_trx_part = curr_part - 1;
--
- 			/* Jump to the end of TRX */
-+			trx = (struct trx_header *)buf;
- 			offset = roundup(offset + trx->length, blocksize);
- 			/* Next loop iteration will increase the offset */
- 			offset -= blocksize;
-@@ -307,9 +326,17 @@ static int bcm47xxpart_parse(struct mtd_
- 				       parts[i + 1].offset : master->size;
- 
- 		parts[i].size = next_part_offset - parts[i].offset;
--		if (i == last_trx_part && trx_part >= 0)
--			parts[trx_part].size = next_part_offset -
--					       parts[trx_part].offset;
-+	}
-+
-+	/* If there was TRX parse it now */
-+	if (trx_part >= 0) {
-+		int num_parts;
-+
-+		num_parts = bcm47xxpart_parse_trx(master, &parts[trx_part],
-+						  parts + curr_part,
-+						  BCM47XXPART_MAX_PARTS - curr_part);
-+		if (num_parts > 0)
-+			curr_part += num_parts;
- 	}
- 
- 	*pparts = parts;
--- a/target/linux/generic/backport-4.9/060-0005-mtd-bcm47xxpart-support-layouts-with-multiple-TRX-pa.patch	2022-03-22 08:54:47.082464461 +0800
+++ b/target/linux/generic/backport-4.9/060-0005-mtd-bcm47xxpart-support-layouts-with-multiple-TRX-pa.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,112 +0,0 @@
-From 89a0d9a9f1941a086a82bc7cd73d275cec98ba14 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Tue, 10 Jan 2017 23:15:25 +0100
-Subject: [PATCH] mtd: bcm47xxpart: support layouts with multiple TRX
- partitions
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Some devices may have an extra TRX partition used as failsafe one. If
-we detect such partition we should set a proper name for it and don't
-parse it.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Acked-by: Marek Vasut <marek.vasut@gmail.com>
-Signed-off-by: Brian Norris <computersforpeace@gmail.com>
----
- drivers/mtd/bcm47xxpart.c | 56 ++++++++++++++++++++++++++++++++++++++---------
- 1 file changed, 46 insertions(+), 10 deletions(-)
-
---- a/drivers/mtd/bcm47xxpart.c
-+++ b/drivers/mtd/bcm47xxpart.c
-@@ -9,6 +9,7 @@
-  *
-  */
- 
-+#include <linux/bcm47xx_nvram.h>
- #include <linux/module.h>
- #include <linux/kernel.h>
- #include <linux/slab.h>
-@@ -144,6 +145,30 @@ static int bcm47xxpart_parse_trx(struct
- 	return curr_part;
- }
- 
-+/**
-+ * bcm47xxpart_bootpartition - gets index of TRX partition used by bootloader
-+ *
-+ * Some devices may have more than one TRX partition. In such case one of them
-+ * is the main one and another a failsafe one. Bootloader may fallback to the
-+ * failsafe firmware if it detects corruption of the main image.
-+ *
-+ * This function provides info about currently used TRX partition. It's the one
-+ * containing kernel started by the bootloader.
-+ */
-+static int bcm47xxpart_bootpartition(void)
-+{
-+	char buf[4];
-+	int bootpartition;
-+
-+	/* Check CFE environment variable */
-+	if (bcm47xx_nvram_getenv("bootpartition", buf, sizeof(buf)) > 0) {
-+		if (!kstrtoint(buf, 0, &bootpartition))
-+			return bootpartition;
-+	}
-+
-+	return 0;
-+}
-+
- static int bcm47xxpart_parse(struct mtd_info *master,
- 			     const struct mtd_partition **pparts,
- 			     struct mtd_part_parser_data *data)
-@@ -154,7 +179,8 @@ static int bcm47xxpart_parse(struct mtd_
- 	size_t bytes_read;
- 	uint32_t offset;
- 	uint32_t blocksize = master->erasesize;
--	int trx_part = -1;
-+	int trx_parts[2]; /* Array with indexes of TRX partitions */
-+	int trx_num = 0; /* Number of found TRX partitions */
- 	int possible_nvram_sizes[] = { 0x8000, 0xF000, 0x10000, };
- 	int err;
- 
-@@ -243,7 +269,11 @@ static int bcm47xxpart_parse(struct mtd_
- 		if (buf[0x000 / 4] == TRX_MAGIC) {
- 			struct trx_header *trx;
- 
--			trx_part = curr_part;
-+			if (trx_num >= ARRAY_SIZE(trx_parts))
-+				pr_warn("No enough space to store another TRX found at 0x%X\n",
-+					offset);
-+			else
-+				trx_parts[trx_num++] = curr_part;
- 			bcm47xxpart_add_part(&parts[curr_part++], "firmware",
- 					     offset, 0);
- 
-@@ -329,14 +359,20 @@ static int bcm47xxpart_parse(struct mtd_
- 	}
- 
- 	/* If there was TRX parse it now */
--	if (trx_part >= 0) {
--		int num_parts;
-+	for (i = 0; i < trx_num; i++) {
-+		struct mtd_partition *trx = &parts[trx_parts[i]];
- 
--		num_parts = bcm47xxpart_parse_trx(master, &parts[trx_part],
--						  parts + curr_part,
--						  BCM47XXPART_MAX_PARTS - curr_part);
--		if (num_parts > 0)
--			curr_part += num_parts;
-+		if (i == bcm47xxpart_bootpartition()) {
-+			int num_parts;
-+
-+			num_parts = bcm47xxpart_parse_trx(master, trx,
-+							  parts + curr_part,
-+							  BCM47XXPART_MAX_PARTS - curr_part);
-+			if (num_parts > 0)
-+				curr_part += num_parts;
-+		} else {
-+			trx->name = "failsafe";
-+		}
- 	}
- 
- 	*pparts = parts;
--- a/target/linux/generic/backport-4.9/061-v4.10-0001-mtd-spi-nor-add-Macronix-mx25u25635f-to-list-of-know.patch	2022-03-22 08:54:47.083464463 +0800
+++ b/target/linux/generic/backport-4.9/061-v4.10-0001-mtd-spi-nor-add-Macronix-mx25u25635f-to-list-of-know.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,22 +0,0 @@
-From 355445b86f0f61125409e1217be4f0a8ee362116 Mon Sep 17 00:00:00 2001
-From: Ash Benz <ash.benz@bk.ru>
-Date: Sat, 19 Nov 2016 07:51:49 +0800
-Subject: [PATCH] mtd: spi-nor: add Macronix mx25u25635f to list of known
- devices.
-
-Signed-off-by: Ash Benz <ash.benz@bk.ru>
-Signed-off-by: Cyrille Pitchen <cyrille.pitchen@atmel.com>
----
- drivers/mtd/spi-nor/spi-nor.c | 1 +
- 1 file changed, 1 insertion(+)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -878,6 +878,7 @@ static const struct flash_info spi_nor_i
- 	{ "mx25l12805d", INFO(0xc22018, 0, 64 * 1024, 256, 0) },
- 	{ "mx25l12855e", INFO(0xc22618, 0, 64 * 1024, 256, 0) },
- 	{ "mx25l25635e", INFO(0xc22019, 0, 64 * 1024, 512, 0) },
-+	{ "mx25u25635f", INFO(0xc22539, 0, 64 * 1024, 512, SECT_4K) },
- 	{ "mx25l25655e", INFO(0xc22619, 0, 64 * 1024, 512, 0) },
- 	{ "mx66l51235l", INFO(0xc2201a, 0, 64 * 1024, 1024, SPI_NOR_QUAD_READ) },
- 	{ "mx66l1g55g",  INFO(0xc2261b, 0, 64 * 1024, 2048, SPI_NOR_QUAD_READ) },
--- a/target/linux/generic/backport-4.9/061-v4.10-0002-mtd-spi-nor-fix-spansion-quad-enable.patch	2022-03-22 08:54:47.083464463 +0800
+++ b/target/linux/generic/backport-4.9/061-v4.10-0002-mtd-spi-nor-fix-spansion-quad-enable.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,42 +0,0 @@
-From 807c16253319ee6ccf8873ae64f070f7eb532cd5 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Jo=C3=ABl=20Esponde?= <joel.esponde@honeywell.com>
-Date: Wed, 23 Nov 2016 12:47:40 +0100
-Subject: [PATCH] mtd: spi-nor: fix spansion quad enable
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-With the S25FL127S nor flash part, each writing to the configuration
-register takes hundreds of ms. During that  time, no more accesses to
-the flash should be done (even reads).
-
-This commit adds a wait loop after the register writing until the flash
-finishes its work.
-
-This issue could make rootfs mounting fail when the latter was done too
-much closely to this quad enable bit setting step. And in this case, a
-driver as UBIFS may try to recover the filesystem and may broke it
-completely.
-
-Signed-off-by: Jol Esponde <joel.esponde@honeywell.com>
-Signed-off-by: Cyrille Pitchen <cyrille.pitchen@atmel.com>
----
- drivers/mtd/spi-nor/spi-nor.c | 7 +++++++
- 1 file changed, 7 insertions(+)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -1269,6 +1269,13 @@ static int spansion_quad_enable(struct s
- 		return ret;
- 	}
- 
-+	ret = spi_nor_wait_till_ready(nor);
-+	if (ret) {
-+		dev_err(nor->dev,
-+			"timeout while writing configuration register\n");
-+		return ret;
-+	}
-+
- 	/* read back and check it */
- 	ret = read_cr(nor);
- 	if (!(ret > 0 && (ret & CR_QUAD_EN_SPAN))) {
--- a/target/linux/generic/backport-4.9/061-v4.10-0003-mtd-spi-nor-fix-flags-for-s25fl128s.patch	2022-03-22 08:54:47.083464463 +0800
+++ b/target/linux/generic/backport-4.9/061-v4.10-0003-mtd-spi-nor-fix-flags-for-s25fl128s.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,28 +0,0 @@
-From 4287916d7bab2806305d3296b4cf261fa49d959b Mon Sep 17 00:00:00 2001
-From: Heiner Kallweit <hkallweit1@gmail.com>
-Date: Thu, 27 Oct 2016 23:13:26 +0200
-Subject: [PATCH] mtd: spi-nor: fix flags for s25fl128s
-
-The Spansion S25FL128S also supports dual read mode.
-In addition remove flag SECT_4K. 4K erases are supported,
-but not uniformly.
-
-Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
-Reviewed-by: Jagan Teki <jteki@openedev.com>
-Acked-by: Marek Vasut <marek.vasut@gmail.com>
-Signed-off-by: Cyrille Pitchen <cyrille.pitchen@atmel.com>
----
- drivers/mtd/spi-nor/spi-nor.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -912,7 +912,7 @@ static const struct flash_info spi_nor_i
- 	{ "s70fl01gs",  INFO(0x010221, 0x4d00, 256 * 1024, 256, 0) },
- 	{ "s25sl12800", INFO(0x012018, 0x0300, 256 * 1024,  64, 0) },
- 	{ "s25sl12801", INFO(0x012018, 0x0301,  64 * 1024, 256, 0) },
--	{ "s25fl128s",	INFO6(0x012018, 0x4d0180, 64 * 1024, 256, SECT_4K | SPI_NOR_QUAD_READ) },
-+	{ "s25fl128s",	INFO6(0x012018, 0x4d0180, 64 * 1024, 256, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
- 	{ "s25fl129p0", INFO(0x012018, 0x4d00, 256 * 1024,  64, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
- 	{ "s25fl129p1", INFO(0x012018, 0x4d01,  64 * 1024, 256, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
- 	{ "s25sl004a",  INFO(0x010212,      0,  64 * 1024,   8, 0) },
--- a/target/linux/generic/backport-4.9/061-v4.10-0004-mtd-spi-nor-add-support-for-s25fl208k.patch	2022-03-22 08:54:47.083464463 +0800
+++ b/target/linux/generic/backport-4.9/061-v4.10-0004-mtd-spi-nor-add-support-for-s25fl208k.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,23 +0,0 @@
-From 022a400f90ceeb26405edd5e077d56e2f38c8123 Mon Sep 17 00:00:00 2001
-From: Sean Nyekjaer <sean.nyekjaer@prevas.dk>
-Date: Wed, 5 Oct 2016 10:59:49 +0200
-Subject: [PATCH] mtd: spi-nor: add support for s25fl208k
-
-Signed-off-by: Sean Nyekjaer <sean.nyekjaer@prevas.dk>
-Reviewed-by: Jagan Teki <jagan@openedev.com>
-Acked-by: Marek Vasut <marex@denx.de>
-Signed-off-by: Cyrille Pitchen <cyrille.pitchen@atmel.com>
----
- drivers/mtd/spi-nor/spi-nor.c | 1 +
- 1 file changed, 1 insertion(+)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -928,6 +928,7 @@ static const struct flash_info spi_nor_i
- 	{ "s25fl132k",  INFO(0x014016,      0,  64 * 1024,  64, SECT_4K) },
- 	{ "s25fl164k",  INFO(0x014017,      0,  64 * 1024, 128, SECT_4K) },
- 	{ "s25fl204k",  INFO(0x014013,      0,  64 * 1024,   8, SECT_4K | SPI_NOR_DUAL_READ) },
-+	{ "s25fl208k",  INFO(0x014014,      0,  64 * 1024,  16, SECT_4K | SPI_NOR_DUAL_READ) },
- 
- 	/* SST -- large erase sizes are "overlays", "sectors" are 4K */
- 	{ "sst25vf040b", INFO(0xbf258d, 0, 64 * 1024,  8, SECT_4K | SST_WRITE) },
--- a/target/linux/generic/backport-4.9/061-v4.10-0005-mtd-spi-nor-Add-at25df321-spi-nor-flash-support.patch	2022-03-22 08:54:47.084464464 +0800
+++ b/target/linux/generic/backport-4.9/061-v4.10-0005-mtd-spi-nor-Add-at25df321-spi-nor-flash-support.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,26 +0,0 @@
-From b08618c929b289699a496b8d45a4e1a014187e56 Mon Sep 17 00:00:00 2001
-From: Jagan Teki <jteki@openedev.com>
-Date: Tue, 26 Jul 2016 14:07:54 +0530
-Subject: [PATCH] mtd: spi-nor: Add at25df321 spi-nor flash support
-
-Add Atmel at25df321 spi-nor flash to the list of spi_nor_ids.
-
-Cc: Brian Norris <computersforpeace@gmail.com>
-Cc: Wenyou Yang <wenyou.yang@atmel.com>
-Signed-off-by: Jagan Teki <jteki@openedev.com>
-Acked-by: Wenyou Yang <wenyou.yang@atmel.com>
-Signed-off-by: Cyrille Pitchen <cyrille.pitchen@atmel.com>
----
- drivers/mtd/spi-nor/spi-nor.c | 1 +
- 1 file changed, 1 insertion(+)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -799,6 +799,7 @@ static const struct flash_info spi_nor_i
- 	{ "at25fs040",  INFO(0x1f6604, 0, 64 * 1024,   8, SECT_4K) },
- 
- 	{ "at25df041a", INFO(0x1f4401, 0, 64 * 1024,   8, SECT_4K) },
-+	{ "at25df321",  INFO(0x1f4700, 0, 64 * 1024,  64, SECT_4K) },
- 	{ "at25df321a", INFO(0x1f4701, 0, 64 * 1024,  64, SECT_4K) },
- 	{ "at25df641",  INFO(0x1f4800, 0, 64 * 1024, 128, SECT_4K) },
- 
--- a/target/linux/generic/backport-4.9/061-v4.10-0006-mtd-spi-nor-Add-support-for-N25Q016A.patch	2022-03-22 08:54:47.084464464 +0800
+++ b/target/linux/generic/backport-4.9/061-v4.10-0006-mtd-spi-nor-Add-support-for-N25Q016A.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,29 +0,0 @@
-From 61e4611864b396c7e9040b7335f25d3921bc87cd Mon Sep 17 00:00:00 2001
-From: Moritz Fischer <moritz.fischer@ettus.com>
-Date: Fri, 15 Jul 2016 10:03:48 -0700
-Subject: [PATCH] mtd: spi-nor: Add support for N25Q016A
-
-This commit adds support in the spi-nor driver for the
-N25Q016A, a 16Mbit SPI NOR flash from Micron.
-
-Cc: David Woodhouse <dwmw2@infradead.org>
-Cc: Brian Norris <computersforpeace@gmail.com>
-Cc: Jagan Teki <jteki@openedev.com>
-
-Signed-off-by: Moritz Fischer <moritz.fischer@ettus.com>
-Reviewed-by: Jagan Teki <jteki@openedev.com>
-Signed-off-by: Cyrille Pitchen <cyrille.pitchen@atmel.com>
----
- drivers/mtd/spi-nor/spi-nor.c | 1 +
- 1 file changed, 1 insertion(+)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -885,6 +885,7 @@ static const struct flash_info spi_nor_i
- 	{ "mx66l1g55g",  INFO(0xc2261b, 0, 64 * 1024, 2048, SPI_NOR_QUAD_READ) },
- 
- 	/* Micron */
-+	{ "n25q016a",	 INFO(0x20bb15, 0, 64 * 1024,   32, SECT_4K | SPI_NOR_QUAD_READ) },
- 	{ "n25q032",	 INFO(0x20ba16, 0, 64 * 1024,   64, SPI_NOR_QUAD_READ) },
- 	{ "n25q032a",	 INFO(0x20bb16, 0, 64 * 1024,   64, SPI_NOR_QUAD_READ) },
- 	{ "n25q064",     INFO(0x20ba17, 0, 64 * 1024,  128, SECT_4K | SPI_NOR_QUAD_READ) },
--- a/target/linux/generic/backport-4.9/061-v4.10-0007-mtd-spi-nor-Add-support-for-mr25h40.patch	2022-03-22 08:54:47.084464464 +0800
+++ b/target/linux/generic/backport-4.9/061-v4.10-0007-mtd-spi-nor-Add-support-for-mr25h40.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,25 +0,0 @@
-From edd0c8f4932dbf3e21036cb443ba5bdf7449d02b Mon Sep 17 00:00:00 2001
-From: IWAMOTO Masahiko <iwamoto@allied-telesis.co.jp>
-Date: Wed, 5 Oct 2016 08:22:52 +0000
-Subject: [PATCH] mtd: spi-nor: Add support for mr25h40
-
-Add Everspin mr25h40 512KB MRAM to the list of supported chips.
-
-Signed-off-by: Masahiko Iwamoto <iwamoto@allied-telesis.co.jp>
-Reviewed-by: Jagan Teki <jagan@openedev.com>
-Acked-by: Marek Vasut <marex@denx.de>
-Signed-off-by: Cyrille Pitchen <cyrille.pitchen@atmel.com>
----
- drivers/mtd/spi-nor/spi-nor.c | 1 +
- 1 file changed, 1 insertion(+)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -826,6 +826,7 @@ static const struct flash_info spi_nor_i
- 	/* Everspin */
- 	{ "mr25h256", CAT25_INFO( 32 * 1024, 1, 256, 2, SPI_NOR_NO_ERASE | SPI_NOR_NO_FR) },
- 	{ "mr25h10",  CAT25_INFO(128 * 1024, 1, 256, 3, SPI_NOR_NO_ERASE | SPI_NOR_NO_FR) },
-+	{ "mr25h40",  CAT25_INFO(512 * 1024, 1, 256, 3, SPI_NOR_NO_ERASE | SPI_NOR_NO_FR) },
- 
- 	/* Fujitsu */
- 	{ "mb85rs1mt", INFO(0x047f27, 0, 128 * 1024, 1, SPI_NOR_NO_ERASE) },
--- a/target/linux/generic/backport-4.9/062-v4.11-0001-mtd-spi-nor-Add-support-for-S3AN-spi-nor-devices.patch	2022-03-22 08:54:47.085464466 +0800
+++ b/target/linux/generic/backport-4.9/062-v4.11-0001-mtd-spi-nor-Add-support-for-S3AN-spi-nor-devices.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,312 +0,0 @@
-From 61cba34bd6c1bddfc38f94cc3f80bdfefcc3393b Mon Sep 17 00:00:00 2001
-From: Ricardo Ribalda <ricardo.ribalda@gmail.com>
-Date: Fri, 2 Dec 2016 12:31:44 +0100
-Subject: [PATCH] mtd: spi-nor: Add support for S3AN spi-nor devices
-
-Xilinx Spartan-3AN FPGAs contain an In-System Flash where they keep
-their configuration data and (optionally) some user data.
-
-The protocol of this flash follows most of the spi-nor standard. With
-the following differences:
-
-- Page size might not be a power of two.
-- The address calculation (default addressing mode).
-- The spi nor commands used.
-
-Protocol is described on Xilinx User Guide UG333
-
-Signed-off-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
-Cc: Boris Brezillon <boris.brezillon@free-electrons.com>
-Cc: Brian Norris <computersforpeace@gmail.com>
-Cc: Marek Vasut <marek.vasut@gmail.com>
-Reviewed-by: Marek Vasut <marek.vasut@gmail.com>
-Signed-off-by: Cyrille Pitchen <cyrille.pitchen@atmel.com>
----
- drivers/mtd/spi-nor/spi-nor.c | 154 ++++++++++++++++++++++++++++++++++++++++--
- include/linux/mtd/spi-nor.h   |  12 ++++
- 2 files changed, 161 insertions(+), 5 deletions(-)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -75,6 +75,12 @@ struct flash_info {
- 					 * bit. Must be used with
- 					 * SPI_NOR_HAS_LOCK.
- 					 */
-+#define	SPI_S3AN		BIT(10)	/*
-+					 * Xilinx Spartan 3AN In-System Flash
-+					 * (MFR cannot be used for probing
-+					 * because it has the same value as
-+					 * ATMEL flashes)
-+					*/
- };
- 
- #define JEDEC_MFR(info)	((info)->id[0])
-@@ -217,6 +223,21 @@ static inline int set_4byte(struct spi_n
- 		return nor->write_reg(nor, SPINOR_OP_BRWR, nor->cmd_buf, 1);
- 	}
- }
-+
-+static int s3an_sr_ready(struct spi_nor *nor)
-+{
-+	int ret;
-+	u8 val;
-+
-+	ret = nor->read_reg(nor, SPINOR_OP_XRDSR, &val, 1);
-+	if (ret < 0) {
-+		dev_err(nor->dev, "error %d reading XRDSR\n", (int) ret);
-+		return ret;
-+	}
-+
-+	return !!(val & XSR_RDY);
-+}
-+
- static inline int spi_nor_sr_ready(struct spi_nor *nor)
- {
- 	int sr = read_sr(nor);
-@@ -238,7 +259,11 @@ static inline int spi_nor_fsr_ready(stru
- static int spi_nor_ready(struct spi_nor *nor)
- {
- 	int sr, fsr;
--	sr = spi_nor_sr_ready(nor);
-+
-+	if (nor->flags & SNOR_F_READY_XSR_RDY)
-+		sr = s3an_sr_ready(nor);
-+	else
-+		sr = spi_nor_sr_ready(nor);
- 	if (sr < 0)
- 		return sr;
- 	fsr = nor->flags & SNOR_F_USE_FSR ? spi_nor_fsr_ready(nor) : 1;
-@@ -320,6 +345,24 @@ static void spi_nor_unlock_and_unprep(st
- }
- 
- /*
-+ * This code converts an address to the Default Address Mode, that has non
-+ * power of two page sizes. We must support this mode because it is the default
-+ * mode supported by Xilinx tools, it can access the whole flash area and
-+ * changing over to the Power-of-two mode is irreversible and corrupts the
-+ * original data.
-+ * Addr can safely be unsigned int, the biggest S3AN device is smaller than
-+ * 4 MiB.
-+ */
-+static loff_t spi_nor_s3an_addr_convert(struct spi_nor *nor, unsigned int addr)
-+{
-+	unsigned int offset = addr;
-+
-+	offset %= nor->page_size;
-+
-+	return ((addr - offset) << 1) | offset;
-+}
-+
-+/*
-  * Initiate the erasure of a single sector
-  */
- static int spi_nor_erase_sector(struct spi_nor *nor, u32 addr)
-@@ -327,6 +370,9 @@ static int spi_nor_erase_sector(struct s
- 	u8 buf[SPI_NOR_MAX_ADDR_WIDTH];
- 	int i;
- 
-+	if (nor->flags & SNOR_F_S3AN_ADDR_DEFAULT)
-+		addr = spi_nor_s3an_addr_convert(nor, addr);
-+
- 	if (nor->erase)
- 		return nor->erase(nor, addr);
- 
-@@ -368,7 +414,7 @@ static int spi_nor_erase(struct mtd_info
- 		return ret;
- 
- 	/* whole-chip erase? */
--	if (len == mtd->size) {
-+	if (len == mtd->size && !(nor->flags & SNOR_F_NO_OP_CHIP_ERASE)) {
- 		unsigned long timeout;
- 
- 		write_enable(nor);
-@@ -782,6 +828,19 @@ static int spi_nor_is_locked(struct mtd_
- 		.addr_width = (_addr_width),				\
- 		.flags = (_flags),
- 
-+#define S3AN_INFO(_jedec_id, _n_sectors, _page_size)			\
-+		.id = {							\
-+			((_jedec_id) >> 16) & 0xff,			\
-+			((_jedec_id) >> 8) & 0xff,			\
-+			(_jedec_id) & 0xff				\
-+			},						\
-+		.id_len = 3,						\
-+		.sector_size = (8*_page_size),				\
-+		.n_sectors = (_n_sectors),				\
-+		.page_size = _page_size,				\
-+		.addr_width = 3,					\
-+		.flags = SPI_NOR_NO_FR | SPI_S3AN,
-+
- /* NOTE: double check command sets and memory organization when you add
-  * more nor chips.  This current list focusses on newer chips, which
-  * have been converging on command sets which including JEDEC ID.
-@@ -1020,6 +1079,13 @@ static const struct flash_info spi_nor_i
- 	{ "cat25c09", CAT25_INFO( 128, 8, 32, 2, SPI_NOR_NO_ERASE | SPI_NOR_NO_FR) },
- 	{ "cat25c17", CAT25_INFO( 256, 8, 32, 2, SPI_NOR_NO_ERASE | SPI_NOR_NO_FR) },
- 	{ "cat25128", CAT25_INFO(2048, 8, 64, 2, SPI_NOR_NO_ERASE | SPI_NOR_NO_FR) },
-+
-+	/* Xilinx S3AN Internal Flash */
-+	{ "3S50AN", S3AN_INFO(0x1f2200, 64, 264) },
-+	{ "3S200AN", S3AN_INFO(0x1f2400, 256, 264) },
-+	{ "3S400AN", S3AN_INFO(0x1f2400, 256, 264) },
-+	{ "3S700AN", S3AN_INFO(0x1f2500, 512, 264) },
-+	{ "3S1400AN", S3AN_INFO(0x1f2600, 512, 528) },
- 	{ },
- };
- 
-@@ -1060,7 +1126,12 @@ static int spi_nor_read(struct mtd_info
- 		return ret;
- 
- 	while (len) {
--		ret = nor->read(nor, from, len, buf);
-+		loff_t addr = from;
-+
-+		if (nor->flags & SNOR_F_S3AN_ADDR_DEFAULT)
-+			addr = spi_nor_s3an_addr_convert(nor, addr);
-+
-+		ret = nor->read(nor, addr, len, buf);
- 		if (ret == 0) {
- 			/* We shouldn't see 0-length reads */
- 			ret = -EIO;
-@@ -1181,8 +1252,23 @@ static int spi_nor_write(struct mtd_info
- 
- 	for (i = 0; i < len; ) {
- 		ssize_t written;
-+		loff_t addr = to + i;
- 
--		page_offset = (to + i) & (nor->page_size - 1);
-+		/*
-+		 * If page_size is a power of two, the offset can be quickly
-+		 * calculated with an AND operation. On the other cases we
-+		 * need to do a modulus operation (more expensive).
-+		 * Power of two numbers have only one bit set and we can use
-+		 * the instruction hweight32 to detect if we need to do a
-+		 * modulus (do_div()) or not.
-+		 */
-+		if (hweight32(nor->page_size) == 1) {
-+			page_offset = addr & (nor->page_size - 1);
-+		} else {
-+			uint64_t aux = addr;
-+
-+			page_offset = do_div(aux, nor->page_size);
-+		}
- 		WARN_ONCE(page_offset,
- 			  "Writing at offset %zu into a NOR page. Writing partial pages may decrease reliability and increase wear of NOR flash.",
- 			  page_offset);
-@@ -1190,8 +1276,11 @@ static int spi_nor_write(struct mtd_info
- 		page_remain = min_t(size_t,
- 				    nor->page_size - page_offset, len - i);
- 
-+		if (nor->flags & SNOR_F_S3AN_ADDR_DEFAULT)
-+			addr = spi_nor_s3an_addr_convert(nor, addr);
-+
- 		write_enable(nor);
--		ret = nor->write(nor, to + i, page_remain, buf + i);
-+		ret = nor->write(nor, addr, page_remain, buf + i);
- 		if (ret < 0)
- 			goto write_err;
- 		written = ret;
-@@ -1325,6 +1414,47 @@ static int spi_nor_check(struct spi_nor
- 	return 0;
- }
- 
-+static int s3an_nor_scan(const struct flash_info *info, struct spi_nor *nor)
-+{
-+	int ret;
-+	u8 val;
-+
-+	ret = nor->read_reg(nor, SPINOR_OP_XRDSR, &val, 1);
-+	if (ret < 0) {
-+		dev_err(nor->dev, "error %d reading XRDSR\n", (int) ret);
-+		return ret;
-+	}
-+
-+	nor->erase_opcode = SPINOR_OP_XSE;
-+	nor->program_opcode = SPINOR_OP_XPP;
-+	nor->read_opcode = SPINOR_OP_READ;
-+	nor->flags |= SNOR_F_NO_OP_CHIP_ERASE;
-+
-+	/*
-+	 * This flashes have a page size of 264 or 528 bytes (known as
-+	 * Default addressing mode). It can be changed to a more standard
-+	 * Power of two mode where the page size is 256/512. This comes
-+	 * with a price: there is 3% less of space, the data is corrupted
-+	 * and the page size cannot be changed back to default addressing
-+	 * mode.
-+	 *
-+	 * The current addressing mode can be read from the XRDSR register
-+	 * and should not be changed, because is a destructive operation.
-+	 */
-+	if (val & XSR_PAGESIZE) {
-+		/* Flash in Power of 2 mode */
-+		nor->page_size = (nor->page_size == 264) ? 256 : 512;
-+		nor->mtd.writebufsize = nor->page_size;
-+		nor->mtd.size = 8 * nor->page_size * info->n_sectors;
-+		nor->mtd.erasesize = 8 * nor->page_size;
-+	} else {
-+		/* Flash in Default addressing mode */
-+		nor->flags |= SNOR_F_S3AN_ADDR_DEFAULT;
-+	}
-+
-+	return 0;
-+}
-+
- int spi_nor_scan(struct spi_nor *nor, const char *name, enum read_mode mode)
- {
- 	const struct flash_info *info = NULL;
-@@ -1373,6 +1503,14 @@ int spi_nor_scan(struct spi_nor *nor, co
- 	mutex_init(&nor->lock);
- 
- 	/*
-+	 * Make sure the XSR_RDY flag is set before calling
-+	 * spi_nor_wait_till_ready(). Xilinx S3AN share MFR
-+	 * with Atmel spi-nor
-+	 */
-+	if (info->flags & SPI_S3AN)
-+		nor->flags |=  SNOR_F_READY_XSR_RDY;
-+
-+	/*
- 	 * Atmel, SST, Intel/Numonyx, and others serial NOR tend to power up
- 	 * with the software protection bits set
- 	 */
-@@ -1530,6 +1668,12 @@ int spi_nor_scan(struct spi_nor *nor, co
- 
- 	nor->read_dummy = spi_nor_read_dummy_cycles(nor);
- 
-+	if (info->flags & SPI_S3AN) {
-+		ret = s3an_nor_scan(info, nor);
-+		if (ret)
-+			return ret;
-+	}
-+
- 	dev_info(dev, "%s (%lld Kbytes)\n", info->name,
- 			(long long)mtd->size >> 10);
- 
---- a/include/linux/mtd/spi-nor.h
-+++ b/include/linux/mtd/spi-nor.h
-@@ -68,6 +68,15 @@
- #define SPINOR_OP_WRDI		0x04	/* Write disable */
- #define SPINOR_OP_AAI_WP	0xad	/* Auto address increment word program */
- 
-+/* Used for S3AN flashes only */
-+#define SPINOR_OP_XSE		0x50	/* Sector erase */
-+#define SPINOR_OP_XPP		0x82	/* Page program */
-+#define SPINOR_OP_XRDSR		0xd7	/* Read status register */
-+
-+#define XSR_PAGESIZE		BIT(0)	/* Page size in Po2 or Linear */
-+#define XSR_RDY			BIT(7)	/* Ready */
-+
-+
- /* Used for Macronix and Winbond flashes. */
- #define SPINOR_OP_EN4B		0xb7	/* Enter 4-byte mode */
- #define SPINOR_OP_EX4B		0xe9	/* Exit 4-byte mode */
-@@ -119,6 +128,9 @@ enum spi_nor_ops {
- enum spi_nor_option_flags {
- 	SNOR_F_USE_FSR		= BIT(0),
- 	SNOR_F_HAS_SR_TB	= BIT(1),
-+	SNOR_F_NO_OP_CHIP_ERASE	= BIT(2),
-+	SNOR_F_S3AN_ADDR_DEFAULT = BIT(3),
-+	SNOR_F_READY_XSR_RDY	= BIT(4),
- };
- 
- /**
--- a/target/linux/generic/backport-4.9/062-v4.11-0002-mtd-spi-nor-improve-macronix_quad_enable.patch	2022-03-22 08:54:47.085464466 +0800
+++ b/target/linux/generic/backport-4.9/062-v4.11-0002-mtd-spi-nor-improve-macronix_quad_enable.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,28 +0,0 @@
-From 1e99d0d51ec97bf48edd277658004ce030543d98 Mon Sep 17 00:00:00 2001
-From: Cyrille Pitchen <cyrille.pitchen@atmel.com>
-Date: Tue, 6 Dec 2016 17:01:41 +0100
-Subject: [PATCH] mtd: spi-nor: improve macronix_quad_enable()
-
-The patch checks whether the Quad Enable bit is already set in the Status
-Register. If so, the function exits immediately with a successful return
-code.
-
-Signed-off-by: Cyrille Pitchen <cyrille.pitchen@atmel.com>
-Reviewed-by: Jagan Teki <jagan@openedev.com>
-Acked-by: Marek Vasut <marek.vasut@gmail.com>
----
- drivers/mtd/spi-nor/spi-nor.c | 3 +++
- 1 file changed, 3 insertions(+)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -1311,6 +1311,9 @@ static int macronix_quad_enable(struct s
- 	val = read_sr(nor);
- 	if (val < 0)
- 		return val;
-+	if (val & SR_QUAD_EN_MX)
-+		return 0;
-+
- 	write_enable(nor);
- 
- 	write_sr(nor, val | SR_QUAD_EN_MX);
--- a/target/linux/generic/backport-4.9/062-v4.11-0003-mtd-spi-nor-remove-WARN_ONCE-message-in-spi_nor_writ.patch	2022-03-22 08:54:47.085464466 +0800
+++ b/target/linux/generic/backport-4.9/062-v4.11-0003-mtd-spi-nor-remove-WARN_ONCE-message-in-spi_nor_writ.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,33 +0,0 @@
-From dc176595bf184e89bf28fdf91cbc1d050dfe63b3 Mon Sep 17 00:00:00 2001
-From: Cyrille Pitchen <cyrille.pitchen@atmel.com>
-Date: Tue, 6 Dec 2016 18:14:24 +0100
-Subject: [PATCH] mtd: spi-nor: remove WARN_ONCE() message in spi_nor_write()
-
-This patch removes the WARN_ONCE() test in spi_nor_write().
-This macro triggers the display of a warning message almost every time we
-use a UBI file-system because a write operation is performed at offset 64,
-which is in the middle of the SPI NOR memory page. This is a valid
-operation for ubifs.
-
-Hence this warning is pretty annoying and useless so we just remove it.
-
-Signed-off-by: Cyrille Pitchen <cyrille.pitchen@atmel.com>
-Suggested-by: Richard Weinberger <richard@nod.at>
-Suggested-by: Andras Szemzo <szemzo.andras@gmail.com>
-Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com>
----
- drivers/mtd/spi-nor/spi-nor.c | 3 ---
- 1 file changed, 3 deletions(-)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -1269,9 +1269,6 @@ static int spi_nor_write(struct mtd_info
- 
- 			page_offset = do_div(aux, nor->page_size);
- 		}
--		WARN_ONCE(page_offset,
--			  "Writing at offset %zu into a NOR page. Writing partial pages may decrease reliability and increase wear of NOR flash.",
--			  page_offset);
- 		/* the size of data remaining on the first page */
- 		page_remain = min_t(size_t,
- 				    nor->page_size - page_offset, len - i);
--- a/target/linux/generic/backport-4.9/062-v4.11-0004-mtd-spi-nor-rename-SPINOR_OP_-macros-of-the-4-byte-a.patch	2022-03-22 08:54:47.086464468 +0800
+++ b/target/linux/generic/backport-4.9/062-v4.11-0004-mtd-spi-nor-rename-SPINOR_OP_-macros-of-the-4-byte-a.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,187 +0,0 @@
-From 05aba5763dcf35eddc58aaf99c9f16d19730e0a8 Mon Sep 17 00:00:00 2001
-From: Cyrille Pitchen <cyrille.pitchen@atmel.com>
-Date: Thu, 27 Oct 2016 11:55:39 +0200
-Subject: [PATCH] mtd: spi-nor: rename SPINOR_OP_* macros of the 4-byte address
- op codes
-
-This patch renames the SPINOR_OP_* macros of the 4-byte address
-instruction set so the new names all share a common pattern: the 4-byte
-address name is built from the 3-byte address name appending the "_4B"
-suffix.
-
-The patch also introduces new op codes to support other SPI protocols such
-as SPI 1-4-4 and SPI 1-2-2.
-
-This is a transitional patch and will help a later patch of spi-nor.c
-to automate the translation from the 3-byte address op codes into their
-4-byte address version.
-
-Signed-off-by: Cyrille Pitchen <cyrille.pitchen@atmel.com>
-Acked-by: Mark Brown <broonie@kernel.org>
-Acked-by: Marek Vasut <marek.vasut@gmail.com>
----
- drivers/mtd/devices/serial_flash_cmds.h |  7 -------
- drivers/mtd/devices/st_spi_fsm.c        | 28 ++++++++++++++--------------
- drivers/mtd/spi-nor/spi-nor.c           |  8 ++++----
- drivers/spi/spi-bcm-qspi.c              |  6 +++---
- include/linux/mtd/spi-nor.h             | 22 ++++++++++++++++------
- 5 files changed, 37 insertions(+), 34 deletions(-)
-
---- a/drivers/mtd/devices/serial_flash_cmds.h
-+++ b/drivers/mtd/devices/serial_flash_cmds.h
-@@ -18,19 +18,12 @@
- #define SPINOR_OP_RDVCR		0x85
- 
- /* JEDEC Standard - Serial Flash Discoverable Parmeters (SFDP) Commands */
--#define SPINOR_OP_READ_1_2_2	0xbb	/* DUAL I/O READ */
--#define SPINOR_OP_READ_1_4_4	0xeb	/* QUAD I/O READ */
--
- #define SPINOR_OP_WRITE		0x02	/* PAGE PROGRAM */
- #define SPINOR_OP_WRITE_1_1_2	0xa2	/* DUAL INPUT PROGRAM */
- #define SPINOR_OP_WRITE_1_2_2	0xd2	/* DUAL INPUT EXT PROGRAM */
- #define SPINOR_OP_WRITE_1_1_4	0x32	/* QUAD INPUT PROGRAM */
- #define SPINOR_OP_WRITE_1_4_4	0x12	/* QUAD INPUT EXT PROGRAM */
- 
--/* READ commands with 32-bit addressing */
--#define SPINOR_OP_READ4_1_2_2	0xbc
--#define SPINOR_OP_READ4_1_4_4	0xec
--
- /* Configuration flags */
- #define FLASH_FLAG_SINGLE	0x000000ff
- #define FLASH_FLAG_READ_WRITE	0x00000001
---- a/drivers/mtd/devices/st_spi_fsm.c
-+++ b/drivers/mtd/devices/st_spi_fsm.c
-@@ -507,13 +507,13 @@ static struct seq_rw_config n25q_read3_c
-  *	- 'FAST' variants configured for 8 dummy cycles (see note above.)
-  */
- static struct seq_rw_config n25q_read4_configs[] = {
--	{FLASH_FLAG_READ_1_4_4, SPINOR_OP_READ4_1_4_4,	0, 4, 4, 0x00, 0, 8},
--	{FLASH_FLAG_READ_1_1_4, SPINOR_OP_READ4_1_1_4,	0, 1, 4, 0x00, 0, 8},
--	{FLASH_FLAG_READ_1_2_2, SPINOR_OP_READ4_1_2_2,	0, 2, 2, 0x00, 0, 8},
--	{FLASH_FLAG_READ_1_1_2, SPINOR_OP_READ4_1_1_2,	0, 1, 2, 0x00, 0, 8},
--	{FLASH_FLAG_READ_FAST,	SPINOR_OP_READ4_FAST,	0, 1, 1, 0x00, 0, 8},
--	{FLASH_FLAG_READ_WRITE, SPINOR_OP_READ4,	0, 1, 1, 0x00, 0, 0},
--	{0x00,			0,			0, 0, 0, 0x00, 0, 0},
-+	{FLASH_FLAG_READ_1_4_4, SPINOR_OP_READ_1_4_4_4B, 0, 4, 4, 0x00, 0, 8},
-+	{FLASH_FLAG_READ_1_1_4, SPINOR_OP_READ_1_1_4_4B, 0, 1, 4, 0x00, 0, 8},
-+	{FLASH_FLAG_READ_1_2_2, SPINOR_OP_READ_1_2_2_4B, 0, 2, 2, 0x00, 0, 8},
-+	{FLASH_FLAG_READ_1_1_2, SPINOR_OP_READ_1_1_2_4B, 0, 1, 2, 0x00, 0, 8},
-+	{FLASH_FLAG_READ_FAST,	SPINOR_OP_READ_FAST_4B,  0, 1, 1, 0x00, 0, 8},
-+	{FLASH_FLAG_READ_WRITE, SPINOR_OP_READ_4B,       0, 1, 1, 0x00, 0, 0},
-+	{0x00,			0,                       0, 0, 0, 0x00, 0, 0},
- };
- 
- /*
-@@ -553,13 +553,13 @@ static int stfsm_mx25_en_32bit_addr_seq(
-  * entering a state that is incompatible with the SPIBoot Controller.
-  */
- static struct seq_rw_config stfsm_s25fl_read4_configs[] = {
--	{FLASH_FLAG_READ_1_4_4,  SPINOR_OP_READ4_1_4_4,  0, 4, 4, 0x00, 2, 4},
--	{FLASH_FLAG_READ_1_1_4,  SPINOR_OP_READ4_1_1_4,  0, 1, 4, 0x00, 0, 8},
--	{FLASH_FLAG_READ_1_2_2,  SPINOR_OP_READ4_1_2_2,  0, 2, 2, 0x00, 4, 0},
--	{FLASH_FLAG_READ_1_1_2,  SPINOR_OP_READ4_1_1_2,  0, 1, 2, 0x00, 0, 8},
--	{FLASH_FLAG_READ_FAST,   SPINOR_OP_READ4_FAST,   0, 1, 1, 0x00, 0, 8},
--	{FLASH_FLAG_READ_WRITE,  SPINOR_OP_READ4,        0, 1, 1, 0x00, 0, 0},
--	{0x00,                   0,                      0, 0, 0, 0x00, 0, 0},
-+	{FLASH_FLAG_READ_1_4_4,  SPINOR_OP_READ_1_4_4_4B,  0, 4, 4, 0x00, 2, 4},
-+	{FLASH_FLAG_READ_1_1_4,  SPINOR_OP_READ_1_1_4_4B,  0, 1, 4, 0x00, 0, 8},
-+	{FLASH_FLAG_READ_1_2_2,  SPINOR_OP_READ_1_2_2_4B,  0, 2, 2, 0x00, 4, 0},
-+	{FLASH_FLAG_READ_1_1_2,  SPINOR_OP_READ_1_1_2_4B,  0, 1, 2, 0x00, 0, 8},
-+	{FLASH_FLAG_READ_FAST,   SPINOR_OP_READ_FAST_4B,   0, 1, 1, 0x00, 0, 8},
-+	{FLASH_FLAG_READ_WRITE,  SPINOR_OP_READ_4B,        0, 1, 1, 0x00, 0, 0},
-+	{0x00,                   0,                        0, 0, 0, 0x00, 0, 0},
- };
- 
- static struct seq_rw_config stfsm_s25fl_write4_configs[] = {
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -1638,16 +1638,16 @@ int spi_nor_scan(struct spi_nor *nor, co
- 			/* Dedicated 4-byte command set */
- 			switch (nor->flash_read) {
- 			case SPI_NOR_QUAD:
--				nor->read_opcode = SPINOR_OP_READ4_1_1_4;
-+				nor->read_opcode = SPINOR_OP_READ_1_1_4_4B;
- 				break;
- 			case SPI_NOR_DUAL:
--				nor->read_opcode = SPINOR_OP_READ4_1_1_2;
-+				nor->read_opcode = SPINOR_OP_READ_1_1_2_4B;
- 				break;
- 			case SPI_NOR_FAST:
--				nor->read_opcode = SPINOR_OP_READ4_FAST;
-+				nor->read_opcode = SPINOR_OP_READ_FAST_4B;
- 				break;
- 			case SPI_NOR_NORMAL:
--				nor->read_opcode = SPINOR_OP_READ4;
-+				nor->read_opcode = SPINOR_OP_READ_4B;
- 				break;
- 			}
- 			nor->program_opcode = SPINOR_OP_PP_4B;
---- a/drivers/spi/spi-bcm-qspi.c
-+++ b/drivers/spi/spi-bcm-qspi.c
-@@ -371,7 +371,7 @@ static int bcm_qspi_bspi_set_flex_mode(s
- 			/* default mode, does not need flex_cmd */
- 			flex_mode = 0;
- 		else
--			command = SPINOR_OP_READ4_FAST;
-+			command = SPINOR_OP_READ_FAST_4B;
- 		break;
- 	case SPI_NBITS_DUAL:
- 		bpc = 0x00000001;
-@@ -384,7 +384,7 @@ static int bcm_qspi_bspi_set_flex_mode(s
- 		} else {
- 			command = SPINOR_OP_READ_1_1_2;
- 			if (spans_4byte)
--				command = SPINOR_OP_READ4_1_1_2;
-+				command = SPINOR_OP_READ_1_1_2_4B;
- 		}
- 		break;
- 	case SPI_NBITS_QUAD:
-@@ -399,7 +399,7 @@ static int bcm_qspi_bspi_set_flex_mode(s
- 		} else {
- 			command = SPINOR_OP_READ_1_1_4;
- 			if (spans_4byte)
--				command = SPINOR_OP_READ4_1_1_4;
-+				command = SPINOR_OP_READ_1_1_4_4B;
- 		}
- 		break;
- 	default:
---- a/include/linux/mtd/spi-nor.h
-+++ b/include/linux/mtd/spi-nor.h
-@@ -43,9 +43,13 @@
- #define SPINOR_OP_WRSR		0x01	/* Write status register 1 byte */
- #define SPINOR_OP_READ		0x03	/* Read data bytes (low frequency) */
- #define SPINOR_OP_READ_FAST	0x0b	/* Read data bytes (high frequency) */
--#define SPINOR_OP_READ_1_1_2	0x3b	/* Read data bytes (Dual SPI) */
--#define SPINOR_OP_READ_1_1_4	0x6b	/* Read data bytes (Quad SPI) */
-+#define SPINOR_OP_READ_1_1_2	0x3b	/* Read data bytes (Dual Output SPI) */
-+#define SPINOR_OP_READ_1_2_2	0xbb	/* Read data bytes (Dual I/O SPI) */
-+#define SPINOR_OP_READ_1_1_4	0x6b	/* Read data bytes (Quad Output SPI) */
-+#define SPINOR_OP_READ_1_4_4	0xeb	/* Read data bytes (Quad I/O SPI) */
- #define SPINOR_OP_PP		0x02	/* Page program (up to 256 bytes) */
-+#define SPINOR_OP_PP_1_1_4	0x32	/* Quad page program */
-+#define SPINOR_OP_PP_1_4_4	0x38	/* Quad page program */
- #define SPINOR_OP_BE_4K		0x20	/* Erase 4KiB block */
- #define SPINOR_OP_BE_4K_PMC	0xd7	/* Erase 4KiB block on PMC chips */
- #define SPINOR_OP_BE_32K	0x52	/* Erase 32KiB block */
-@@ -56,11 +60,17 @@
- #define SPINOR_OP_RDFSR		0x70	/* Read flag status register */
- 
- /* 4-byte address opcodes - used on Spansion and some Macronix flashes. */
--#define SPINOR_OP_READ4		0x13	/* Read data bytes (low frequency) */
--#define SPINOR_OP_READ4_FAST	0x0c	/* Read data bytes (high frequency) */
--#define SPINOR_OP_READ4_1_1_2	0x3c	/* Read data bytes (Dual SPI) */
--#define SPINOR_OP_READ4_1_1_4	0x6c	/* Read data bytes (Quad SPI) */
-+#define SPINOR_OP_READ_4B	0x13	/* Read data bytes (low frequency) */
-+#define SPINOR_OP_READ_FAST_4B	0x0c	/* Read data bytes (high frequency) */
-+#define SPINOR_OP_READ_1_1_2_4B	0x3c	/* Read data bytes (Dual Output SPI) */
-+#define SPINOR_OP_READ_1_2_2_4B	0xbc	/* Read data bytes (Dual I/O SPI) */
-+#define SPINOR_OP_READ_1_1_4_4B	0x6c	/* Read data bytes (Quad Output SPI) */
-+#define SPINOR_OP_READ_1_4_4_4B	0xec	/* Read data bytes (Quad I/O SPI) */
- #define SPINOR_OP_PP_4B		0x12	/* Page program (up to 256 bytes) */
-+#define SPINOR_OP_PP_1_1_4_4B	0x34	/* Quad page program */
-+#define SPINOR_OP_PP_1_4_4_4B	0x3e	/* Quad page program */
-+#define SPINOR_OP_BE_4K_4B	0x21	/* Erase 4KiB block */
-+#define SPINOR_OP_BE_32K_4B	0x5c	/* Erase 32KiB block */
- #define SPINOR_OP_SE_4B		0xdc	/* Sector erase (usually 64KiB) */
- 
- /* Used for SST flashes only. */
--- a/target/linux/generic/backport-4.9/062-v4.11-0005-mtd-spi-nor-add-a-stateless-method-to-support-memory.patch	2022-03-22 08:54:47.086464468 +0800
+++ b/target/linux/generic/backport-4.9/062-v4.11-0005-mtd-spi-nor-add-a-stateless-method-to-support-memory.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,150 +0,0 @@
-From 3274ba26f27becfc4193ec6e229288140651f240 Mon Sep 17 00:00:00 2001
-From: Cyrille Pitchen <cyrille.pitchen@atmel.com>
-Date: Thu, 27 Oct 2016 12:03:57 +0200
-Subject: [PATCH] mtd: spi-nor: add a stateless method to support memory size
- above 128Mib
-
-This patch provides an alternative mean to support memory above 16MiB
-(128Mib) by replacing 3byte address op codes by their associated 4byte
-address versions.
-
-Using the dedicated 4byte address op codes doesn't change the internal
-state of the SPI NOR memory as opposed to using other means such as
-updating a Base Address Register (BAR) and sending command to enter/leave
-the 4byte mode.
-
-Hence when a CPU reset occurs, early bootloaders don't need to be aware
-of BAR value or 4byte mode being enabled: they can still access the first
-16MiB of the SPI NOR memory using the regular 3byte address op codes.
-
-Signed-off-by: Cyrille Pitchen <cyrille.pitchen@atmel.com>
-Tested-by: Vignesh R <vigneshr@ti.com>
-Acked-by: Marek Vasut <marek.vasut@gmail.com>
----
- drivers/mtd/spi-nor/spi-nor.c | 101 +++++++++++++++++++++++++++++++++---------
- 1 file changed, 80 insertions(+), 21 deletions(-)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -81,6 +81,10 @@ struct flash_info {
- 					 * because it has the same value as
- 					 * ATMEL flashes)
- 					*/
-+#define SPI_NOR_4B_OPCODES	BIT(11)	/*
-+					 * Use dedicated 4byte address op codes
-+					 * to support memory size above 128Mib.
-+					 */
- };
- 
- #define JEDEC_MFR(info)	((info)->id[0])
-@@ -194,6 +198,78 @@ static inline struct spi_nor *mtd_to_spi
- 	return mtd->priv;
- }
- 
-+
-+static u8 spi_nor_convert_opcode(u8 opcode, const u8 table[][2], size_t size)
-+{
-+	size_t i;
-+
-+	for (i = 0; i < size; i++)
-+		if (table[i][0] == opcode)
-+			return table[i][1];
-+
-+	/* No conversion found, keep input op code. */
-+	return opcode;
-+}
-+
-+static inline u8 spi_nor_convert_3to4_read(u8 opcode)
-+{
-+	static const u8 spi_nor_3to4_read[][2] = {
-+		{ SPINOR_OP_READ,	SPINOR_OP_READ_4B },
-+		{ SPINOR_OP_READ_FAST,	SPINOR_OP_READ_FAST_4B },
-+		{ SPINOR_OP_READ_1_1_2,	SPINOR_OP_READ_1_1_2_4B },
-+		{ SPINOR_OP_READ_1_2_2,	SPINOR_OP_READ_1_2_2_4B },
-+		{ SPINOR_OP_READ_1_1_4,	SPINOR_OP_READ_1_1_4_4B },
-+		{ SPINOR_OP_READ_1_4_4,	SPINOR_OP_READ_1_4_4_4B },
-+	};
-+
-+	return spi_nor_convert_opcode(opcode, spi_nor_3to4_read,
-+				      ARRAY_SIZE(spi_nor_3to4_read));
-+}
-+
-+static inline u8 spi_nor_convert_3to4_program(u8 opcode)
-+{
-+	static const u8 spi_nor_3to4_program[][2] = {
-+		{ SPINOR_OP_PP,		SPINOR_OP_PP_4B },
-+		{ SPINOR_OP_PP_1_1_4,	SPINOR_OP_PP_1_1_4_4B },
-+		{ SPINOR_OP_PP_1_4_4,	SPINOR_OP_PP_1_4_4_4B },
-+	};
-+
-+	return spi_nor_convert_opcode(opcode, spi_nor_3to4_program,
-+				      ARRAY_SIZE(spi_nor_3to4_program));
-+}
-+
-+static inline u8 spi_nor_convert_3to4_erase(u8 opcode)
-+{
-+	static const u8 spi_nor_3to4_erase[][2] = {
-+		{ SPINOR_OP_BE_4K,	SPINOR_OP_BE_4K_4B },
-+		{ SPINOR_OP_BE_32K,	SPINOR_OP_BE_32K_4B },
-+		{ SPINOR_OP_SE,		SPINOR_OP_SE_4B },
-+	};
-+
-+	return spi_nor_convert_opcode(opcode, spi_nor_3to4_erase,
-+				      ARRAY_SIZE(spi_nor_3to4_erase));
-+}
-+
-+static void spi_nor_set_4byte_opcodes(struct spi_nor *nor,
-+				      const struct flash_info *info)
-+{
-+	/* Do some manufacturer fixups first */
-+	switch (JEDEC_MFR(info)) {
-+	case SNOR_MFR_SPANSION:
-+		/* No small sector erase for 4-byte command set */
-+		nor->erase_opcode = SPINOR_OP_SE;
-+		nor->mtd.erasesize = info->sector_size;
-+		break;
-+
-+	default:
-+		break;
-+	}
-+
-+	nor->read_opcode = spi_nor_convert_3to4_read(nor->read_opcode);
-+	nor->program_opcode = spi_nor_convert_3to4_program(nor->program_opcode);
-+	nor->erase_opcode = spi_nor_convert_3to4_erase(nor->erase_opcode);
-+}
-+
- /* Enable/disable 4-byte addressing mode. */
- static inline int set_4byte(struct spi_nor *nor, const struct flash_info *info,
- 			    int enable)
-@@ -1634,27 +1710,10 @@ int spi_nor_scan(struct spi_nor *nor, co
- 	else if (mtd->size > 0x1000000) {
- 		/* enable 4-byte addressing if the device exceeds 16MiB */
- 		nor->addr_width = 4;
--		if (JEDEC_MFR(info) == SNOR_MFR_SPANSION) {
--			/* Dedicated 4-byte command set */
--			switch (nor->flash_read) {
--			case SPI_NOR_QUAD:
--				nor->read_opcode = SPINOR_OP_READ_1_1_4_4B;
--				break;
--			case SPI_NOR_DUAL:
--				nor->read_opcode = SPINOR_OP_READ_1_1_2_4B;
--				break;
--			case SPI_NOR_FAST:
--				nor->read_opcode = SPINOR_OP_READ_FAST_4B;
--				break;
--			case SPI_NOR_NORMAL:
--				nor->read_opcode = SPINOR_OP_READ_4B;
--				break;
--			}
--			nor->program_opcode = SPINOR_OP_PP_4B;
--			/* No small sector erase for 4-byte command set */
--			nor->erase_opcode = SPINOR_OP_SE_4B;
--			mtd->erasesize = info->sector_size;
--		} else
-+		if (JEDEC_MFR(info) == SNOR_MFR_SPANSION ||
-+		    info->flags & SPI_NOR_4B_OPCODES)
-+			spi_nor_set_4byte_opcodes(nor, info);
-+		else
- 			set_4byte(nor, info, 1);
- 	} else {
- 		nor->addr_width = 3;
--- a/target/linux/generic/backport-4.9/062-v4.11-0006-mtd-spi-nor-Add-lock-unlock-support-for-f25l32pa.patch	2022-03-22 08:54:47.087464469 +0800
+++ b/target/linux/generic/backport-4.9/062-v4.11-0006-mtd-spi-nor-Add-lock-unlock-support-for-f25l32pa.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,26 +0,0 @@
-From 252c36bb9c7b98b356f033d16ea83d20fb8b4d3e Mon Sep 17 00:00:00 2001
-From: Victor Shyba <victor1984@riseup.net>
-Date: Mon, 2 Jan 2017 22:34:30 -0300
-Subject: [PATCH] mtd: spi-nor: Add lock/unlock support for f25l32pa
-
-This chip has write protection enabled on power-up,
-so this flag is necessary to support write operations.
-
-Signed-off-by: Victor Shyba <victor1984@riseup.net>
-Acked-by: Marek Vasut <marek.vasut@gmail.com>
-Signed-off-by: Cyrille Pitchen <cyrille.pitchen@atmel.com>
----
- drivers/mtd/spi-nor/spi-nor.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -956,7 +956,7 @@ static const struct flash_info spi_nor_i
- 	{ "en25s64",	INFO(0x1c3817, 0, 64 * 1024,  128, SECT_4K) },
- 
- 	/* ESMT */
--	{ "f25l32pa", INFO(0x8c2016, 0, 64 * 1024, 64, SECT_4K) },
-+	{ "f25l32pa", INFO(0x8c2016, 0, 64 * 1024, 64, SECT_4K | SPI_NOR_HAS_LOCK) },
- 
- 	/* Everspin */
- 	{ "mr25h256", CAT25_INFO( 32 * 1024, 1, 256, 2, SPI_NOR_NO_ERASE | SPI_NOR_NO_FR) },
--- a/target/linux/generic/backport-4.9/062-v4.11-0007-mtd-spi-nor-Fix-S3AN-addressing-calculation.patch	2022-03-22 08:54:47.087464469 +0800
+++ b/target/linux/generic/backport-4.9/062-v4.11-0007-mtd-spi-nor-Fix-S3AN-addressing-calculation.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,35 +0,0 @@
-From 5f0e0758efddef5b06994a76d8c7f0b8a4c1daae Mon Sep 17 00:00:00 2001
-From: Ricardo Ribalda <ricardo.ribalda@gmail.com>
-Date: Wed, 18 Jan 2017 17:40:16 +0100
-Subject: [PATCH] mtd: spi-nor: Fix S3AN addressing calculation
-
-The page calculation under spi_nor_s3an_addr_convert() was wrong. On
-Default Address Mode we need to perform a divide by page_size.
-
-Signed-off-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
-Acked-by: Marek Vasut <marek.vasut@gmail.com>
-Signed-off-by: Cyrille Pitchen <cyrille.pitchen@atmel.com>
----
- drivers/mtd/spi-nor/spi-nor.c | 9 ++++++---
- 1 file changed, 6 insertions(+), 3 deletions(-)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -431,11 +431,14 @@ static void spi_nor_unlock_and_unprep(st
-  */
- static loff_t spi_nor_s3an_addr_convert(struct spi_nor *nor, unsigned int addr)
- {
--	unsigned int offset = addr;
-+	unsigned int offset;
-+	unsigned int page;
- 
--	offset %= nor->page_size;
-+	offset = addr % nor->page_size;
-+	page = addr / nor->page_size;
-+	page <<= (nor->page_size > 512) ? 10 : 9;
- 
--	return ((addr - offset) << 1) | offset;
-+	return page | offset;
- }
- 
- /*
--- a/target/linux/generic/backport-4.9/062-v4.11-0008-mtd-spi-nor-Add-support-for-gd25q16.patch	2022-03-22 08:54:47.087464469 +0800
+++ b/target/linux/generic/backport-4.9/062-v4.11-0008-mtd-spi-nor-Add-support-for-gd25q16.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,28 +0,0 @@
-From 4c5747a390acc9d1da3b332507c8bae7a8ddfc48 Mon Sep 17 00:00:00 2001
-From: Kamal Dasu <kdasu.kdev@gmail.com>
-Date: Fri, 20 Jan 2017 14:25:51 -0500
-Subject: [PATCH] mtd: spi-nor: Add support for gd25q16
-
-Add GigaDevice GD25Q16 (16M-bit) to supported list.
-
-Signed-off-by: Kamal Dasu <kdasu.kdev@gmail.com>
-Acked-by: Marek Vasut <marek.vasut@gmail.com>
-Signed-off-by: Cyrille Pitchen <cyrille.pitchen@atmel.com>
----
- drivers/mtd/spi-nor/spi-nor.c | 5 +++++
- 1 file changed, 5 insertions(+)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -971,6 +971,11 @@ static const struct flash_info spi_nor_i
- 
- 	/* GigaDevice */
- 	{
-+		"gd25q16", INFO(0xc84015, 0, 64 * 1024,  32,
-+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
-+			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
-+	},
-+	{
- 		"gd25q32", INFO(0xc84016, 0, 64 * 1024,  64,
- 			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
- 			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
--- a/target/linux/generic/backport-4.9/063-v4.11-0001-mtd-nand-Add-Winbond-manufacturer-id.patch	2022-03-22 08:54:47.088464471 +0800
+++ b/target/linux/generic/backport-4.9/063-v4.11-0001-mtd-nand-Add-Winbond-manufacturer-id.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,34 +0,0 @@
-From a4077ce5871304f8a78f80b74b18b6052a410f1a Mon Sep 17 00:00:00 2001
-From: "Andrey Jr. Melnikov" <temnota.am@gmail.com>
-Date: Thu, 8 Dec 2016 19:57:08 +0300
-Subject: [PATCH] mtd: nand: Add Winbond manufacturer id
-
-Add WINBOND manufacturer id.
-
-Signed-off-by: Andrey Jr. Melnikov <temnota.am@gmail.com>
-Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
----
- drivers/mtd/nand/nand_ids.c | 1 +
- include/linux/mtd/nand.h    | 1 +
- 2 files changed, 2 insertions(+)
-
---- a/drivers/mtd/nand/nand_ids.c
-+++ b/drivers/mtd/nand/nand_ids.c
-@@ -182,6 +182,7 @@ struct nand_manufacturers nand_manuf_ids
- 	{NAND_MFR_SANDISK, "SanDisk"},
- 	{NAND_MFR_INTEL, "Intel"},
- 	{NAND_MFR_ATO, "ATO"},
-+	{NAND_MFR_WINBOND, "Winbond"},
- 	{0x0, "Unknown"}
- };
- 
---- a/include/linux/mtd/nand.h
-+++ b/include/linux/mtd/nand.h
-@@ -928,6 +928,7 @@ static inline void nand_set_controller_d
- #define NAND_MFR_SANDISK	0x45
- #define NAND_MFR_INTEL		0x89
- #define NAND_MFR_ATO		0x9b
-+#define NAND_MFR_WINBOND	0xef
- 
- /* The maximum expected count of bytes in the NAND ID sequence */
- #define NAND_MAX_ID_LEN 8
--- a/target/linux/generic/backport-4.9/063-v4.11-0002-mtd-introduce-function-max_bad_blocks.patch	2022-03-22 08:54:47.088464471 +0800
+++ b/target/linux/generic/backport-4.9/063-v4.11-0002-mtd-introduce-function-max_bad_blocks.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,73 +0,0 @@
-From 6080ef6e7c0a0592cbcca11200d879faf65e27d4 Mon Sep 17 00:00:00 2001
-From: Jeff Westfahl <jeff.westfahl@ni.com>
-Date: Tue, 10 Jan 2017 13:30:17 -0600
-Subject: [PATCH] mtd: introduce function max_bad_blocks
-
-If implemented, 'max_bad_blocks' returns the maximum number of bad
-blocks to reserve for a MTD. An implementation for NAND is coming soon.
-
-Signed-off-by: Jeff Westfahl <jeff.westfahl@ni.com>
-Signed-off-by: Zach Brown <zach.brown@ni.com>
-Acked-by: Boris Brezillon <boris.brezillon@free-electron.com>
-Acked-by: Brian Norris <computersforpeace@gmail.com>
-Signed-off-by: Brian Norris <computersforpeace@gmail.com>
----
- drivers/mtd/mtdpart.c   | 10 ++++++++++
- include/linux/mtd/mtd.h | 13 +++++++++++++
- 2 files changed, 23 insertions(+)
-
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -349,6 +349,14 @@ static const struct mtd_ooblayout_ops pa
- 	.free = part_ooblayout_free,
- };
- 
-+static int part_max_bad_blocks(struct mtd_info *mtd, loff_t ofs, size_t len)
-+{
-+	struct mtd_part *part = mtd_to_part(mtd);
-+
-+	return part->master->_max_bad_blocks(part->master,
-+					     ofs + part->offset, len);
-+}
-+
- static inline void free_partition(struct mtd_part *p)
- {
- 	kfree(p->mtd.name);
-@@ -475,6 +483,8 @@ static struct mtd_part *allocate_partiti
- 		slave->mtd._block_isbad = part_block_isbad;
- 	if (master->_block_markbad)
- 		slave->mtd._block_markbad = part_block_markbad;
-+	if (master->_max_bad_blocks)
-+		slave->mtd._max_bad_blocks = part_max_bad_blocks;
- 
- 	if (master->_get_device)
- 		slave->mtd._get_device = part_get_device;
---- a/include/linux/mtd/mtd.h
-+++ b/include/linux/mtd/mtd.h
-@@ -322,6 +322,7 @@ struct mtd_info {
- 	int (*_block_isreserved) (struct mtd_info *mtd, loff_t ofs);
- 	int (*_block_isbad) (struct mtd_info *mtd, loff_t ofs);
- 	int (*_block_markbad) (struct mtd_info *mtd, loff_t ofs);
-+	int (*_max_bad_blocks) (struct mtd_info *mtd, loff_t ofs, size_t len);
- 	int (*_suspend) (struct mtd_info *mtd);
- 	void (*_resume) (struct mtd_info *mtd);
- 	void (*_reboot) (struct mtd_info *mtd);
-@@ -397,6 +398,18 @@ static inline int mtd_oobavail(struct mt
- 	return ops->mode == MTD_OPS_AUTO_OOB ? mtd->oobavail : mtd->oobsize;
- }
- 
-+static inline int mtd_max_bad_blocks(struct mtd_info *mtd,
-+				     loff_t ofs, size_t len)
-+{
-+	if (!mtd->_max_bad_blocks)
-+		return -ENOTSUPP;
-+
-+	if (mtd->size < (len + ofs) || ofs < 0)
-+		return -EINVAL;
-+
-+	return mtd->_max_bad_blocks(mtd, ofs, len);
-+}
-+
- int mtd_wunit_to_pairing_info(struct mtd_info *mtd, int wunit,
- 			      struct mtd_pairing_info *info);
- int mtd_pairing_info_to_wunit(struct mtd_info *mtd,
--- a/target/linux/generic/backport-4.9/063-v4.11-0003-mtd-Add-partition-device-node-to-mtd-partition-devic.patch	2022-03-22 08:54:47.088464471 +0800
+++ b/target/linux/generic/backport-4.9/063-v4.11-0003-mtd-Add-partition-device-node-to-mtd-partition-devic.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,50 +0,0 @@
-From 42e9401bd1467d22c4dc4d2c637347b874e6a80b Mon Sep 17 00:00:00 2001
-From: Sascha Hauer <s.hauer@pengutronix.de>
-Date: Thu, 9 Feb 2017 11:50:24 +0100
-Subject: [PATCH] mtd: Add partition device node to mtd partition devices
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-The user visible change here is that mtd partitions get an of_node link
-in sysfs.
-
-Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
-Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
-Signed-off-by: Brian Norris <computersforpeace@gmail.com>
----
- drivers/mtd/mtdpart.c          | 1 +
- drivers/mtd/ofpart.c           | 1 +
- include/linux/mtd/partitions.h | 1 +
- 3 files changed, 3 insertions(+)
-
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -432,6 +432,7 @@ static struct mtd_part *allocate_partiti
- 	slave->mtd.dev.parent = IS_ENABLED(CONFIG_MTD_PARTITIONED_MASTER) ?
- 				&master->dev :
- 				master->dev.parent;
-+	slave->mtd.dev.of_node = part->of_node;
- 
- 	slave->mtd._read = part_read;
- 	slave->mtd._write = part_write;
---- a/drivers/mtd/ofpart.c
-+++ b/drivers/mtd/ofpart.c
-@@ -108,6 +108,7 @@ static int parse_ofpart_partitions(struc
- 
- 		parts[i].offset = of_read_number(reg, a_cells);
- 		parts[i].size = of_read_number(reg + a_cells, s_cells);
-+		parts[i].of_node = pp;
- 
- 		partname = of_get_property(pp, "label", &len);
- 		if (!partname)
---- a/include/linux/mtd/partitions.h
-+++ b/include/linux/mtd/partitions.h
-@@ -41,6 +41,7 @@ struct mtd_partition {
- 	uint64_t size;			/* partition size */
- 	uint64_t offset;		/* offset within the master MTD space */
- 	uint32_t mask_flags;		/* master MTD flags to mask out for this partition */
-+	struct device_node *of_node;
- };
- 
- #define MTDPART_OFS_RETAIN	(-3)
--- a/target/linux/generic/backport-4.9/064-v4.12-mtd-spi-nor-enable-stateless-4b-op-codes-for-mx25u25.patch	2022-03-22 08:54:47.088464471 +0800
+++ b/target/linux/generic/backport-4.9/064-v4.12-mtd-spi-nor-enable-stateless-4b-op-codes-for-mx25u25.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,29 +0,0 @@
-From b0fcb4b413028376894feaaaf62bcb09ab1b52f2 Mon Sep 17 00:00:00 2001
-From: Mathias Kresin <dev@kresin.me>
-Date: Thu, 13 Apr 2017 09:23:54 +0200
-Subject: [PATCH] mtd: spi-nor: enable stateless 4b op codes for mx25u25635f
-
-All required stateless 4-byte op codes are supported by this flash
-chip. The stateless 4-byte support can't be autodetected due to a
-missing 4-byte Address Instruction Table in SFDP.
-
-Fixes hangs on reboot for SoCs expecting the flash chip in 3byte mode.
-
-Signed-off-by: Mathias Kresin <dev@kresin.me>
-Acked-by: Marek Vasut <marek.vasut@gmail.com>
-Signed-off-by: Cyrille Pitchen <cyrille.pitchen@atmel.com>
----
- drivers/mtd/spi-nor/spi-nor.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -1023,7 +1023,7 @@ static const struct flash_info spi_nor_i
- 	{ "mx25l12805d", INFO(0xc22018, 0, 64 * 1024, 256, 0) },
- 	{ "mx25l12855e", INFO(0xc22618, 0, 64 * 1024, 256, 0) },
- 	{ "mx25l25635e", INFO(0xc22019, 0, 64 * 1024, 512, 0) },
--	{ "mx25u25635f", INFO(0xc22539, 0, 64 * 1024, 512, SECT_4K) },
-+	{ "mx25u25635f", INFO(0xc22539, 0, 64 * 1024, 512, SECT_4K | SPI_NOR_4B_OPCODES) },
- 	{ "mx25l25655e", INFO(0xc22619, 0, 64 * 1024, 512, 0) },
- 	{ "mx66l51235l", INFO(0xc2201a, 0, 64 * 1024, 1024, SPI_NOR_QUAD_READ) },
- 	{ "mx66l1g55g",  INFO(0xc2261b, 0, 64 * 1024, 2048, SPI_NOR_QUAD_READ) },
--- a/target/linux/generic/backport-4.9/065-v4.13-0001-mtd-handle-partitioning-on-devices-with-0-erasesize.patch	2022-03-22 08:54:47.089464473 +0800
+++ b/target/linux/generic/backport-4.9/065-v4.13-0001-mtd-handle-partitioning-on-devices-with-0-erasesize.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,77 +0,0 @@
-From 1eeef2d7483a7e3f8d2dd2a5b9939b3b814dc549 Mon Sep 17 00:00:00 2001
-From: Chris Packham <chris.packham@alliedtelesis.co.nz>
-Date: Fri, 9 Jun 2017 15:58:31 +1200
-Subject: [PATCH] mtd: handle partitioning on devices with 0 erasesize
-
-erasesize is meaningful for flash devices but for SRAM there is no
-concept of an erase block so erasesize is set to 0. When partitioning
-these devices instead of ensuring partitions fall on erasesize
-boundaries we ensure they fall on writesize boundaries.
-
-Helped-by: Boris Brezillon <boris.brezillon@free-electrons.com>
-Signed-off-by: Chris Packham <chris.packham@alliedtelesis.co.nz>
-Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com>
-Signed-off-by: Brian Norris <computersforpeace@gmail.com>
----
- drivers/mtd/mtdpart.c | 26 +++++++++++++++++---------
- 1 file changed, 17 insertions(+), 9 deletions(-)
-
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -393,8 +393,12 @@ static struct mtd_part *allocate_partiti
- 			const struct mtd_partition *part, int partno,
- 			uint64_t cur_offset)
- {
-+	int wr_alignment = (master->flags & MTD_NO_ERASE) ? master->writesize:
-+							    master->erasesize;
- 	struct mtd_part *slave;
-+	u32 remainder;
- 	char *name;
-+	u64 tmp;
- 
- 	/* allocate the partition structure */
- 	slave = kzalloc(sizeof(*slave), GFP_KERNEL);
-@@ -499,10 +503,11 @@ static struct mtd_part *allocate_partiti
- 	if (slave->offset == MTDPART_OFS_APPEND)
- 		slave->offset = cur_offset;
- 	if (slave->offset == MTDPART_OFS_NXTBLK) {
-+		tmp = cur_offset;
- 		slave->offset = cur_offset;
--		if (mtd_mod_by_eb(cur_offset, master) != 0) {
--			/* Round up to next erasesize */
--			slave->offset = (mtd_div_by_eb(cur_offset, master) + 1) * master->erasesize;
-+		remainder = do_div(tmp, wr_alignment);
-+		if (remainder) {
-+			slave->offset += wr_alignment - remainder;
- 			printk(KERN_NOTICE "Moving partition %d: "
- 			       "0x%012llx -> 0x%012llx\n", partno,
- 			       (unsigned long long)cur_offset, (unsigned long long)slave->offset);
-@@ -567,19 +572,22 @@ static struct mtd_part *allocate_partiti
- 		slave->mtd.erasesize = master->erasesize;
- 	}
- 
--	if ((slave->mtd.flags & MTD_WRITEABLE) &&
--	    mtd_mod_by_eb(slave->offset, &slave->mtd)) {
-+	tmp = slave->offset;
-+	remainder = do_div(tmp, wr_alignment);
-+	if ((slave->mtd.flags & MTD_WRITEABLE) && remainder) {
- 		/* Doesn't start on a boundary of major erase size */
- 		/* FIXME: Let it be writable if it is on a boundary of
- 		 * _minor_ erase size though */
- 		slave->mtd.flags &= ~MTD_WRITEABLE;
--		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase block boundary -- force read-only\n",
-+		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase/write block boundary -- force read-only\n",
- 			part->name);
- 	}
--	if ((slave->mtd.flags & MTD_WRITEABLE) &&
--	    mtd_mod_by_eb(slave->mtd.size, &slave->mtd)) {
-+
-+	tmp = slave->mtd.size;
-+	remainder = do_div(tmp, wr_alignment);
-+	if ((slave->mtd.flags & MTD_WRITEABLE) && remainder) {
- 		slave->mtd.flags &= ~MTD_WRITEABLE;
--		printk(KERN_WARNING"mtd: partition \"%s\" doesn't end on an erase block -- force read-only\n",
-+		printk(KERN_WARNING"mtd: partition \"%s\" doesn't end on an erase/write block -- force read-only\n",
- 			part->name);
- 	}
- 
--- a/target/linux/generic/backport-4.9/065-v4.13-0002-mtd-partitions-factor-out-code-calling-parser.patch	2022-03-22 08:54:47.089464473 +0800
+++ b/target/linux/generic/backport-4.9/065-v4.13-0002-mtd-partitions-factor-out-code-calling-parser.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,68 +0,0 @@
-From 01f9c7240a900d5676a8496496f2974dd36996b1 Mon Sep 17 00:00:00 2001
-From: Brian Norris <computersforpeace@gmail.com>
-Date: Tue, 23 May 2017 07:30:20 +0200
-Subject: [PATCH] mtd: partitions: factor out code calling parser
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-This code is going to be reused for parsers matched using OF so let's
-factor it out to make this easier.
-
-Signed-off-by: Brian Norris <computersforpeace@gmail.com>
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Acked-by: Brian Norris <computersforpeace@gmail.com>
----
- drivers/mtd/mtdpart.c | 33 ++++++++++++++++++++++++---------
- 1 file changed, 24 insertions(+), 9 deletions(-)
-
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -832,6 +832,27 @@ static const char * const default_mtd_pa
- 	NULL
- };
- 
-+static int mtd_part_do_parse(struct mtd_part_parser *parser,
-+			     struct mtd_info *master,
-+			     struct mtd_partitions *pparts,
-+			     struct mtd_part_parser_data *data)
-+{
-+	int ret;
-+
-+	ret = (*parser->parse_fn)(master, &pparts->parts, data);
-+	pr_debug("%s: parser %s: %i\n", master->name, parser->name, ret);
-+	if (ret <= 0)
-+		return ret;
-+
-+	pr_notice("%d %s partitions found on MTD device %s\n", ret,
-+		  parser->name, master->name);
-+
-+	pparts->nr_parts = ret;
-+	pparts->parser = parser;
-+
-+	return ret;
-+}
-+
- /**
-  * parse_mtd_partitions - parse MTD partitions
-  * @master: the master partition (describes whole MTD device)
-@@ -872,16 +893,10 @@ int parse_mtd_partitions(struct mtd_info
- 			 parser ? parser->name : NULL);
- 		if (!parser)
- 			continue;
--		ret = (*parser->parse_fn)(master, &pparts->parts, data);
--		pr_debug("%s: parser %s: %i\n",
--			 master->name, parser->name, ret);
--		if (ret > 0) {
--			printk(KERN_NOTICE "%d %s partitions found on MTD device %s\n",
--			       ret, parser->name, master->name);
--			pparts->nr_parts = ret;
--			pparts->parser = parser;
-+		ret = mtd_part_do_parse(parser, master, pparts, data);
-+		/* Found partitions! */
-+		if (ret > 0)
- 			return 0;
--		}
- 		mtd_part_parser_put(parser);
- 		/*
- 		 * Stash the first error we see; only report it if no parser
--- a/target/linux/generic/backport-4.9/065-v4.13-0003-mtd-partitions-add-helper-for-deleting-partition.patch	2022-03-22 08:54:47.089464473 +0800
+++ b/target/linux/generic/backport-4.9/065-v4.13-0003-mtd-partitions-add-helper-for-deleting-partition.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,119 +0,0 @@
-From 08263a9ae664b24fa777d20b365601534842b236 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Wed, 21 Jun 2017 08:26:42 +0200
-Subject: [PATCH] mtd: partitions: add helper for deleting partition
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-There are two similar functions handling deletion. One handles single
-partition and another the whole MTD flash device. They share (duplicate)
-some code so it makes sense to add a small helper for that part.
-
-Function del_mtd_partitions has been moved a bit to keep all deleting
-stuff together.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Signed-off-by: Brian Norris <computersforpeace@gmail.com>
----
- drivers/mtd/mtdpart.c | 75 +++++++++++++++++++++++++++++----------------------
- 1 file changed, 43 insertions(+), 32 deletions(-)
-
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -363,32 +363,6 @@ static inline void free_partition(struct
- 	kfree(p);
- }
- 
--/*
-- * This function unregisters and destroy all slave MTD objects which are
-- * attached to the given master MTD object.
-- */
--
--int del_mtd_partitions(struct mtd_info *master)
--{
--	struct mtd_part *slave, *next;
--	int ret, err = 0;
--
--	mutex_lock(&mtd_partitions_mutex);
--	list_for_each_entry_safe(slave, next, &mtd_partitions, list)
--		if (slave->master == master) {
--			ret = del_mtd_device(&slave->mtd);
--			if (ret < 0) {
--				err = ret;
--				continue;
--			}
--			list_del(&slave->list);
--			free_partition(slave);
--		}
--	mutex_unlock(&mtd_partitions_mutex);
--
--	return err;
--}
--
- static struct mtd_part *allocate_partition(struct mtd_info *master,
- 			const struct mtd_partition *part, int partno,
- 			uint64_t cur_offset)
-@@ -686,6 +660,48 @@ err_remove_part:
- }
- EXPORT_SYMBOL_GPL(mtd_add_partition);
- 
-+/**
-+ * __mtd_del_partition - delete MTD partition
-+ *
-+ * @priv: internal MTD struct for partition to be deleted
-+ *
-+ * This function must be called with the partitions mutex locked.
-+ */
-+static int __mtd_del_partition(struct mtd_part *priv)
-+{
-+	int err;
-+
-+	err = del_mtd_device(&priv->mtd);
-+	if (err)
-+		return err;
-+
-+	list_del(&priv->list);
-+	free_partition(priv);
-+
-+	return 0;
-+}
-+
-+/*
-+ * This function unregisters and destroy all slave MTD objects which are
-+ * attached to the given master MTD object.
-+ */
-+int del_mtd_partitions(struct mtd_info *master)
-+{
-+	struct mtd_part *slave, *next;
-+	int ret, err = 0;
-+
-+	mutex_lock(&mtd_partitions_mutex);
-+	list_for_each_entry_safe(slave, next, &mtd_partitions, list)
-+		if (slave->master == master) {
-+			ret = __mtd_del_partition(slave);
-+			if (ret < 0)
-+				err = ret;
-+		}
-+	mutex_unlock(&mtd_partitions_mutex);
-+
-+	return err;
-+}
-+
- int mtd_del_partition(struct mtd_info *master, int partno)
- {
- 	struct mtd_part *slave, *next;
-@@ -697,12 +713,7 @@ int mtd_del_partition(struct mtd_info *m
- 		    (slave->mtd.index == partno)) {
- 			sysfs_remove_files(&slave->mtd.dev.kobj,
- 					   mtd_partition_attrs);
--			ret = del_mtd_device(&slave->mtd);
--			if (ret < 0)
--				break;
--
--			list_del(&slave->list);
--			free_partition(slave);
-+			ret = __mtd_del_partition(slave);
- 			break;
- 		}
- 	mutex_unlock(&mtd_partitions_mutex);
--- a/target/linux/generic/backport-4.9/065-v4.13-0004-mtd-partitions-remove-sysfs-files-when-deleting-all-.patch	2022-03-22 08:54:47.090464474 +0800
+++ b/target/linux/generic/backport-4.9/065-v4.13-0004-mtd-partitions-remove-sysfs-files-when-deleting-all-.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,45 +0,0 @@
-From c5ceaba74083daf619bdb34d4871e297a177eebf Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Wed, 21 Jun 2017 08:26:43 +0200
-Subject: [PATCH] mtd: partitions: remove sysfs files when deleting all
- master's partitions
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-When support for sysfs "offset" file was added it missed to update the
-del_mtd_partitions function. It deletes partitions just like
-mtd_del_partition does so both should also take care of removing sysfs
-files.
-
-This change moves sysfs_remove_files call to the shared function to fix
-this issue.
-
-Fixes: a62c24d755291 ("mtd: part: Add sysfs variable for offset of partition")
-Cc: Dan Ehrenberg <dehrenberg@chromium.org>
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Signed-off-by: Brian Norris <computersforpeace@gmail.com>
----
- drivers/mtd/mtdpart.c | 4 ++--
- 1 file changed, 2 insertions(+), 2 deletions(-)
-
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -671,6 +671,8 @@ static int __mtd_del_partition(struct mt
- {
- 	int err;
- 
-+	sysfs_remove_files(&priv->mtd.dev.kobj, mtd_partition_attrs);
-+
- 	err = del_mtd_device(&priv->mtd);
- 	if (err)
- 		return err;
-@@ -711,8 +713,6 @@ int mtd_del_partition(struct mtd_info *m
- 	list_for_each_entry_safe(slave, next, &mtd_partitions, list)
- 		if ((slave->master == master) &&
- 		    (slave->mtd.index == partno)) {
--			sysfs_remove_files(&slave->mtd.dev.kobj,
--					   mtd_partition_attrs);
- 			ret = __mtd_del_partition(slave);
- 			break;
- 		}
--- a/target/linux/generic/backport-4.9/065-v4.13-0005-mtd-partitions-rename-master-to-the-parent-where-app.patch	2022-03-22 08:54:47.091464476 +0800
+++ b/target/linux/generic/backport-4.9/065-v4.13-0005-mtd-partitions-rename-master-to-the-parent-where-app.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,606 +0,0 @@
-From 0a9d72b69da6d8dae1abd7990c6c4c749846ef3e Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Wed, 21 Jun 2017 08:26:44 +0200
-Subject: [PATCH] mtd: partitions: rename "master" to the "parent" where
- appropriate
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-This prepares mtd subsystem for the new feature: subpartitions. In some
-cases flash device partition can be a container with extra subpartitions
-(volumes).
-
-So far there was a flat structure implemented. One master (flash device)
-could be partitioned into few partitions. Every partition got its master
-and it was enough to get things running.
-
-To support subpartitions we need to store pointer to the parent for each
-partition. This is required to implement more natural tree structure and
-handle all recursion and offsets calculation.
-
-To make code consistent this patch renamed "master" to the "parent" in
-places where we can be dealing with subpartitions.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Signed-off-by: Brian Norris <computersforpeace@gmail.com>
----
- drivers/mtd/mtdpart.c | 204 ++++++++++++++++++++++++++------------------------
- 1 file changed, 105 insertions(+), 99 deletions(-)
-
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -37,10 +37,16 @@
- static LIST_HEAD(mtd_partitions);
- static DEFINE_MUTEX(mtd_partitions_mutex);
- 
--/* Our partition node structure */
-+/**
-+ * struct mtd_part - our partition node structure
-+ *
-+ * @mtd: struct holding partition details
-+ * @parent: parent mtd - flash device or another partition
-+ * @offset: partition offset relative to the *flash device*
-+ */
- struct mtd_part {
- 	struct mtd_info mtd;
--	struct mtd_info *master;
-+	struct mtd_info *parent;
- 	uint64_t offset;
- 	struct list_head list;
- };
-@@ -67,15 +73,15 @@ static int part_read(struct mtd_info *mt
- 	struct mtd_ecc_stats stats;
- 	int res;
- 
--	stats = part->master->ecc_stats;
--	res = part->master->_read(part->master, from + part->offset, len,
-+	stats = part->parent->ecc_stats;
-+	res = part->parent->_read(part->parent, from + part->offset, len,
- 				  retlen, buf);
- 	if (unlikely(mtd_is_eccerr(res)))
- 		mtd->ecc_stats.failed +=
--			part->master->ecc_stats.failed - stats.failed;
-+			part->parent->ecc_stats.failed - stats.failed;
- 	else
- 		mtd->ecc_stats.corrected +=
--			part->master->ecc_stats.corrected - stats.corrected;
-+			part->parent->ecc_stats.corrected - stats.corrected;
- 	return res;
- }
- 
-@@ -84,7 +90,7 @@ static int part_point(struct mtd_info *m
- {
- 	struct mtd_part *part = mtd_to_part(mtd);
- 
--	return part->master->_point(part->master, from + part->offset, len,
-+	return part->parent->_point(part->parent, from + part->offset, len,
- 				    retlen, virt, phys);
- }
- 
-@@ -92,7 +98,7 @@ static int part_unpoint(struct mtd_info
- {
- 	struct mtd_part *part = mtd_to_part(mtd);
- 
--	return part->master->_unpoint(part->master, from + part->offset, len);
-+	return part->parent->_unpoint(part->parent, from + part->offset, len);
- }
- 
- static unsigned long part_get_unmapped_area(struct mtd_info *mtd,
-@@ -103,7 +109,7 @@ static unsigned long part_get_unmapped_a
- 	struct mtd_part *part = mtd_to_part(mtd);
- 
- 	offset += part->offset;
--	return part->master->_get_unmapped_area(part->master, len, offset,
-+	return part->parent->_get_unmapped_area(part->parent, len, offset,
- 						flags);
- }
- 
-@@ -132,7 +138,7 @@ static int part_read_oob(struct mtd_info
- 			return -EINVAL;
- 	}
- 
--	res = part->master->_read_oob(part->master, from + part->offset, ops);
-+	res = part->parent->_read_oob(part->parent, from + part->offset, ops);
- 	if (unlikely(res)) {
- 		if (mtd_is_bitflip(res))
- 			mtd->ecc_stats.corrected++;
-@@ -146,7 +152,7 @@ static int part_read_user_prot_reg(struc
- 		size_t len, size_t *retlen, u_char *buf)
- {
- 	struct mtd_part *part = mtd_to_part(mtd);
--	return part->master->_read_user_prot_reg(part->master, from, len,
-+	return part->parent->_read_user_prot_reg(part->parent, from, len,
- 						 retlen, buf);
- }
- 
-@@ -154,7 +160,7 @@ static int part_get_user_prot_info(struc
- 				   size_t *retlen, struct otp_info *buf)
- {
- 	struct mtd_part *part = mtd_to_part(mtd);
--	return part->master->_get_user_prot_info(part->master, len, retlen,
-+	return part->parent->_get_user_prot_info(part->parent, len, retlen,
- 						 buf);
- }
- 
-@@ -162,7 +168,7 @@ static int part_read_fact_prot_reg(struc
- 		size_t len, size_t *retlen, u_char *buf)
- {
- 	struct mtd_part *part = mtd_to_part(mtd);
--	return part->master->_read_fact_prot_reg(part->master, from, len,
-+	return part->parent->_read_fact_prot_reg(part->parent, from, len,
- 						 retlen, buf);
- }
- 
-@@ -170,7 +176,7 @@ static int part_get_fact_prot_info(struc
- 				   size_t *retlen, struct otp_info *buf)
- {
- 	struct mtd_part *part = mtd_to_part(mtd);
--	return part->master->_get_fact_prot_info(part->master, len, retlen,
-+	return part->parent->_get_fact_prot_info(part->parent, len, retlen,
- 						 buf);
- }
- 
-@@ -178,7 +184,7 @@ static int part_write(struct mtd_info *m
- 		size_t *retlen, const u_char *buf)
- {
- 	struct mtd_part *part = mtd_to_part(mtd);
--	return part->master->_write(part->master, to + part->offset, len,
-+	return part->parent->_write(part->parent, to + part->offset, len,
- 				    retlen, buf);
- }
- 
-@@ -186,7 +192,7 @@ static int part_panic_write(struct mtd_i
- 		size_t *retlen, const u_char *buf)
- {
- 	struct mtd_part *part = mtd_to_part(mtd);
--	return part->master->_panic_write(part->master, to + part->offset, len,
-+	return part->parent->_panic_write(part->parent, to + part->offset, len,
- 					  retlen, buf);
- }
- 
-@@ -199,14 +205,14 @@ static int part_write_oob(struct mtd_inf
- 		return -EINVAL;
- 	if (ops->datbuf && to + ops->len > mtd->size)
- 		return -EINVAL;
--	return part->master->_write_oob(part->master, to + part->offset, ops);
-+	return part->parent->_write_oob(part->parent, to + part->offset, ops);
- }
- 
- static int part_write_user_prot_reg(struct mtd_info *mtd, loff_t from,
- 		size_t len, size_t *retlen, u_char *buf)
- {
- 	struct mtd_part *part = mtd_to_part(mtd);
--	return part->master->_write_user_prot_reg(part->master, from, len,
-+	return part->parent->_write_user_prot_reg(part->parent, from, len,
- 						  retlen, buf);
- }
- 
-@@ -214,14 +220,14 @@ static int part_lock_user_prot_reg(struc
- 		size_t len)
- {
- 	struct mtd_part *part = mtd_to_part(mtd);
--	return part->master->_lock_user_prot_reg(part->master, from, len);
-+	return part->parent->_lock_user_prot_reg(part->parent, from, len);
- }
- 
- static int part_writev(struct mtd_info *mtd, const struct kvec *vecs,
- 		unsigned long count, loff_t to, size_t *retlen)
- {
- 	struct mtd_part *part = mtd_to_part(mtd);
--	return part->master->_writev(part->master, vecs, count,
-+	return part->parent->_writev(part->parent, vecs, count,
- 				     to + part->offset, retlen);
- }
- 
-@@ -231,7 +237,7 @@ static int part_erase(struct mtd_info *m
- 	int ret;
- 
- 	instr->addr += part->offset;
--	ret = part->master->_erase(part->master, instr);
-+	ret = part->parent->_erase(part->parent, instr);
- 	if (ret) {
- 		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
- 			instr->fail_addr -= part->offset;
-@@ -257,51 +263,51 @@ EXPORT_SYMBOL_GPL(mtd_erase_callback);
- static int part_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
- {
- 	struct mtd_part *part = mtd_to_part(mtd);
--	return part->master->_lock(part->master, ofs + part->offset, len);
-+	return part->parent->_lock(part->parent, ofs + part->offset, len);
- }
- 
- static int part_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
- {
- 	struct mtd_part *part = mtd_to_part(mtd);
--	return part->master->_unlock(part->master, ofs + part->offset, len);
-+	return part->parent->_unlock(part->parent, ofs + part->offset, len);
- }
- 
- static int part_is_locked(struct mtd_info *mtd, loff_t ofs, uint64_t len)
- {
- 	struct mtd_part *part = mtd_to_part(mtd);
--	return part->master->_is_locked(part->master, ofs + part->offset, len);
-+	return part->parent->_is_locked(part->parent, ofs + part->offset, len);
- }
- 
- static void part_sync(struct mtd_info *mtd)
- {
- 	struct mtd_part *part = mtd_to_part(mtd);
--	part->master->_sync(part->master);
-+	part->parent->_sync(part->parent);
- }
- 
- static int part_suspend(struct mtd_info *mtd)
- {
- 	struct mtd_part *part = mtd_to_part(mtd);
--	return part->master->_suspend(part->master);
-+	return part->parent->_suspend(part->parent);
- }
- 
- static void part_resume(struct mtd_info *mtd)
- {
- 	struct mtd_part *part = mtd_to_part(mtd);
--	part->master->_resume(part->master);
-+	part->parent->_resume(part->parent);
- }
- 
- static int part_block_isreserved(struct mtd_info *mtd, loff_t ofs)
- {
- 	struct mtd_part *part = mtd_to_part(mtd);
- 	ofs += part->offset;
--	return part->master->_block_isreserved(part->master, ofs);
-+	return part->parent->_block_isreserved(part->parent, ofs);
- }
- 
- static int part_block_isbad(struct mtd_info *mtd, loff_t ofs)
- {
- 	struct mtd_part *part = mtd_to_part(mtd);
- 	ofs += part->offset;
--	return part->master->_block_isbad(part->master, ofs);
-+	return part->parent->_block_isbad(part->parent, ofs);
- }
- 
- static int part_block_markbad(struct mtd_info *mtd, loff_t ofs)
-@@ -310,7 +316,7 @@ static int part_block_markbad(struct mtd
- 	int res;
- 
- 	ofs += part->offset;
--	res = part->master->_block_markbad(part->master, ofs);
-+	res = part->parent->_block_markbad(part->parent, ofs);
- 	if (!res)
- 		mtd->ecc_stats.badblocks++;
- 	return res;
-@@ -319,13 +325,13 @@ static int part_block_markbad(struct mtd
- static int part_get_device(struct mtd_info *mtd)
- {
- 	struct mtd_part *part = mtd_to_part(mtd);
--	return part->master->_get_device(part->master);
-+	return part->parent->_get_device(part->parent);
- }
- 
- static void part_put_device(struct mtd_info *mtd)
- {
- 	struct mtd_part *part = mtd_to_part(mtd);
--	part->master->_put_device(part->master);
-+	part->parent->_put_device(part->parent);
- }
- 
- static int part_ooblayout_ecc(struct mtd_info *mtd, int section,
-@@ -333,7 +339,7 @@ static int part_ooblayout_ecc(struct mtd
- {
- 	struct mtd_part *part = mtd_to_part(mtd);
- 
--	return mtd_ooblayout_ecc(part->master, section, oobregion);
-+	return mtd_ooblayout_ecc(part->parent, section, oobregion);
- }
- 
- static int part_ooblayout_free(struct mtd_info *mtd, int section,
-@@ -341,7 +347,7 @@ static int part_ooblayout_free(struct mt
- {
- 	struct mtd_part *part = mtd_to_part(mtd);
- 
--	return mtd_ooblayout_free(part->master, section, oobregion);
-+	return mtd_ooblayout_free(part->parent, section, oobregion);
- }
- 
- static const struct mtd_ooblayout_ops part_ooblayout_ops = {
-@@ -353,7 +359,7 @@ static int part_max_bad_blocks(struct mt
- {
- 	struct mtd_part *part = mtd_to_part(mtd);
- 
--	return part->master->_max_bad_blocks(part->master,
-+	return part->parent->_max_bad_blocks(part->parent,
- 					     ofs + part->offset, len);
- }
- 
-@@ -363,12 +369,12 @@ static inline void free_partition(struct
- 	kfree(p);
- }
- 
--static struct mtd_part *allocate_partition(struct mtd_info *master,
-+static struct mtd_part *allocate_partition(struct mtd_info *parent,
- 			const struct mtd_partition *part, int partno,
- 			uint64_t cur_offset)
- {
--	int wr_alignment = (master->flags & MTD_NO_ERASE) ? master->writesize:
--							    master->erasesize;
-+	int wr_alignment = (parent->flags & MTD_NO_ERASE) ? parent->writesize:
-+							    parent->erasesize;
- 	struct mtd_part *slave;
- 	u32 remainder;
- 	char *name;
-@@ -379,25 +385,25 @@ static struct mtd_part *allocate_partiti
- 	name = kstrdup(part->name, GFP_KERNEL);
- 	if (!name || !slave) {
- 		printk(KERN_ERR"memory allocation error while creating partitions for \"%s\"\n",
--		       master->name);
-+		       parent->name);
- 		kfree(name);
- 		kfree(slave);
- 		return ERR_PTR(-ENOMEM);
- 	}
- 
- 	/* set up the MTD object for this partition */
--	slave->mtd.type = master->type;
--	slave->mtd.flags = master->flags & ~part->mask_flags;
-+	slave->mtd.type = parent->type;
-+	slave->mtd.flags = parent->flags & ~part->mask_flags;
- 	slave->mtd.size = part->size;
--	slave->mtd.writesize = master->writesize;
--	slave->mtd.writebufsize = master->writebufsize;
--	slave->mtd.oobsize = master->oobsize;
--	slave->mtd.oobavail = master->oobavail;
--	slave->mtd.subpage_sft = master->subpage_sft;
--	slave->mtd.pairing = master->pairing;
-+	slave->mtd.writesize = parent->writesize;
-+	slave->mtd.writebufsize = parent->writebufsize;
-+	slave->mtd.oobsize = parent->oobsize;
-+	slave->mtd.oobavail = parent->oobavail;
-+	slave->mtd.subpage_sft = parent->subpage_sft;
-+	slave->mtd.pairing = parent->pairing;
- 
- 	slave->mtd.name = name;
--	slave->mtd.owner = master->owner;
-+	slave->mtd.owner = parent->owner;
- 
- 	/* NOTE: Historically, we didn't arrange MTDs as a tree out of
- 	 * concern for showing the same data in multiple partitions.
-@@ -408,70 +414,70 @@ static struct mtd_part *allocate_partiti
- 	 * distinguish between the master and the partition in sysfs.
- 	 */
- 	slave->mtd.dev.parent = IS_ENABLED(CONFIG_MTD_PARTITIONED_MASTER) ?
--				&master->dev :
--				master->dev.parent;
-+				&parent->dev :
-+				parent->dev.parent;
- 	slave->mtd.dev.of_node = part->of_node;
- 
- 	slave->mtd._read = part_read;
- 	slave->mtd._write = part_write;
- 
--	if (master->_panic_write)
-+	if (parent->_panic_write)
- 		slave->mtd._panic_write = part_panic_write;
- 
--	if (master->_point && master->_unpoint) {
-+	if (parent->_point && parent->_unpoint) {
- 		slave->mtd._point = part_point;
- 		slave->mtd._unpoint = part_unpoint;
- 	}
- 
--	if (master->_get_unmapped_area)
-+	if (parent->_get_unmapped_area)
- 		slave->mtd._get_unmapped_area = part_get_unmapped_area;
--	if (master->_read_oob)
-+	if (parent->_read_oob)
- 		slave->mtd._read_oob = part_read_oob;
--	if (master->_write_oob)
-+	if (parent->_write_oob)
- 		slave->mtd._write_oob = part_write_oob;
--	if (master->_read_user_prot_reg)
-+	if (parent->_read_user_prot_reg)
- 		slave->mtd._read_user_prot_reg = part_read_user_prot_reg;
--	if (master->_read_fact_prot_reg)
-+	if (parent->_read_fact_prot_reg)
- 		slave->mtd._read_fact_prot_reg = part_read_fact_prot_reg;
--	if (master->_write_user_prot_reg)
-+	if (parent->_write_user_prot_reg)
- 		slave->mtd._write_user_prot_reg = part_write_user_prot_reg;
--	if (master->_lock_user_prot_reg)
-+	if (parent->_lock_user_prot_reg)
- 		slave->mtd._lock_user_prot_reg = part_lock_user_prot_reg;
--	if (master->_get_user_prot_info)
-+	if (parent->_get_user_prot_info)
- 		slave->mtd._get_user_prot_info = part_get_user_prot_info;
--	if (master->_get_fact_prot_info)
-+	if (parent->_get_fact_prot_info)
- 		slave->mtd._get_fact_prot_info = part_get_fact_prot_info;
--	if (master->_sync)
-+	if (parent->_sync)
- 		slave->mtd._sync = part_sync;
--	if (!partno && !master->dev.class && master->_suspend &&
--	    master->_resume) {
-+	if (!partno && !parent->dev.class && parent->_suspend &&
-+	    parent->_resume) {
- 			slave->mtd._suspend = part_suspend;
- 			slave->mtd._resume = part_resume;
- 	}
--	if (master->_writev)
-+	if (parent->_writev)
- 		slave->mtd._writev = part_writev;
--	if (master->_lock)
-+	if (parent->_lock)
- 		slave->mtd._lock = part_lock;
--	if (master->_unlock)
-+	if (parent->_unlock)
- 		slave->mtd._unlock = part_unlock;
--	if (master->_is_locked)
-+	if (parent->_is_locked)
- 		slave->mtd._is_locked = part_is_locked;
--	if (master->_block_isreserved)
-+	if (parent->_block_isreserved)
- 		slave->mtd._block_isreserved = part_block_isreserved;
--	if (master->_block_isbad)
-+	if (parent->_block_isbad)
- 		slave->mtd._block_isbad = part_block_isbad;
--	if (master->_block_markbad)
-+	if (parent->_block_markbad)
- 		slave->mtd._block_markbad = part_block_markbad;
--	if (master->_max_bad_blocks)
-+	if (parent->_max_bad_blocks)
- 		slave->mtd._max_bad_blocks = part_max_bad_blocks;
- 
--	if (master->_get_device)
-+	if (parent->_get_device)
- 		slave->mtd._get_device = part_get_device;
--	if (master->_put_device)
-+	if (parent->_put_device)
- 		slave->mtd._put_device = part_put_device;
- 
- 	slave->mtd._erase = part_erase;
--	slave->master = master;
-+	slave->parent = parent;
- 	slave->offset = part->offset;
- 
- 	if (slave->offset == MTDPART_OFS_APPEND)
-@@ -489,25 +495,25 @@ static struct mtd_part *allocate_partiti
- 	}
- 	if (slave->offset == MTDPART_OFS_RETAIN) {
- 		slave->offset = cur_offset;
--		if (master->size - slave->offset >= slave->mtd.size) {
--			slave->mtd.size = master->size - slave->offset
-+		if (parent->size - slave->offset >= slave->mtd.size) {
-+			slave->mtd.size = parent->size - slave->offset
- 							- slave->mtd.size;
- 		} else {
- 			printk(KERN_ERR "mtd partition \"%s\" doesn't have enough space: %#llx < %#llx, disabled\n",
--				part->name, master->size - slave->offset,
-+				part->name, parent->size - slave->offset,
- 				slave->mtd.size);
- 			/* register to preserve ordering */
- 			goto out_register;
- 		}
- 	}
- 	if (slave->mtd.size == MTDPART_SIZ_FULL)
--		slave->mtd.size = master->size - slave->offset;
-+		slave->mtd.size = parent->size - slave->offset;
- 
- 	printk(KERN_NOTICE "0x%012llx-0x%012llx : \"%s\"\n", (unsigned long long)slave->offset,
- 		(unsigned long long)(slave->offset + slave->mtd.size), slave->mtd.name);
- 
- 	/* let's do some sanity checks */
--	if (slave->offset >= master->size) {
-+	if (slave->offset >= parent->size) {
- 		/* let's register it anyway to preserve ordering */
- 		slave->offset = 0;
- 		slave->mtd.size = 0;
-@@ -515,16 +521,16 @@ static struct mtd_part *allocate_partiti
- 			part->name);
- 		goto out_register;
- 	}
--	if (slave->offset + slave->mtd.size > master->size) {
--		slave->mtd.size = master->size - slave->offset;
-+	if (slave->offset + slave->mtd.size > parent->size) {
-+		slave->mtd.size = parent->size - slave->offset;
- 		printk(KERN_WARNING"mtd: partition \"%s\" extends beyond the end of device \"%s\" -- size truncated to %#llx\n",
--			part->name, master->name, (unsigned long long)slave->mtd.size);
-+			part->name, parent->name, (unsigned long long)slave->mtd.size);
- 	}
--	if (master->numeraseregions > 1) {
-+	if (parent->numeraseregions > 1) {
- 		/* Deal with variable erase size stuff */
--		int i, max = master->numeraseregions;
-+		int i, max = parent->numeraseregions;
- 		u64 end = slave->offset + slave->mtd.size;
--		struct mtd_erase_region_info *regions = master->eraseregions;
-+		struct mtd_erase_region_info *regions = parent->eraseregions;
- 
- 		/* Find the first erase regions which is part of this
- 		 * partition. */
-@@ -543,7 +549,7 @@ static struct mtd_part *allocate_partiti
- 		BUG_ON(slave->mtd.erasesize == 0);
- 	} else {
- 		/* Single erase size */
--		slave->mtd.erasesize = master->erasesize;
-+		slave->mtd.erasesize = parent->erasesize;
- 	}
- 
- 	tmp = slave->offset;
-@@ -566,17 +572,17 @@ static struct mtd_part *allocate_partiti
- 	}
- 
- 	mtd_set_ooblayout(&slave->mtd, &part_ooblayout_ops);
--	slave->mtd.ecc_step_size = master->ecc_step_size;
--	slave->mtd.ecc_strength = master->ecc_strength;
--	slave->mtd.bitflip_threshold = master->bitflip_threshold;
-+	slave->mtd.ecc_step_size = parent->ecc_step_size;
-+	slave->mtd.ecc_strength = parent->ecc_strength;
-+	slave->mtd.bitflip_threshold = parent->bitflip_threshold;
- 
--	if (master->_block_isbad) {
-+	if (parent->_block_isbad) {
- 		uint64_t offs = 0;
- 
- 		while (offs < slave->mtd.size) {
--			if (mtd_block_isreserved(master, offs + slave->offset))
-+			if (mtd_block_isreserved(parent, offs + slave->offset))
- 				slave->mtd.ecc_stats.bbtblocks++;
--			else if (mtd_block_isbad(master, offs + slave->offset))
-+			else if (mtd_block_isbad(parent, offs + slave->offset))
- 				slave->mtd.ecc_stats.badblocks++;
- 			offs += slave->mtd.erasesize;
- 		}
-@@ -610,7 +616,7 @@ static int mtd_add_partition_attrs(struc
- 	return ret;
- }
- 
--int mtd_add_partition(struct mtd_info *master, const char *name,
-+int mtd_add_partition(struct mtd_info *parent, const char *name,
- 		      long long offset, long long length)
- {
- 	struct mtd_partition part;
-@@ -623,7 +629,7 @@ int mtd_add_partition(struct mtd_info *m
- 		return -EINVAL;
- 
- 	if (length == MTDPART_SIZ_FULL)
--		length = master->size - offset;
-+		length = parent->size - offset;
- 
- 	if (length <= 0)
- 		return -EINVAL;
-@@ -633,7 +639,7 @@ int mtd_add_partition(struct mtd_info *m
- 	part.size = length;
- 	part.offset = offset;
- 
--	new = allocate_partition(master, &part, -1, offset);
-+	new = allocate_partition(parent, &part, -1, offset);
- 	if (IS_ERR(new))
- 		return PTR_ERR(new);
- 
-@@ -694,7 +700,7 @@ int del_mtd_partitions(struct mtd_info *
- 
- 	mutex_lock(&mtd_partitions_mutex);
- 	list_for_each_entry_safe(slave, next, &mtd_partitions, list)
--		if (slave->master == master) {
-+		if (slave->parent == master) {
- 			ret = __mtd_del_partition(slave);
- 			if (ret < 0)
- 				err = ret;
-@@ -711,7 +717,7 @@ int mtd_del_partition(struct mtd_info *m
- 
- 	mutex_lock(&mtd_partitions_mutex);
- 	list_for_each_entry_safe(slave, next, &mtd_partitions, list)
--		if ((slave->master == master) &&
-+		if ((slave->parent == master) &&
- 		    (slave->mtd.index == partno)) {
- 			ret = __mtd_del_partition(slave);
- 			break;
-@@ -958,6 +964,6 @@ uint64_t mtd_get_device_size(const struc
- 	if (!mtd_is_partition(mtd))
- 		return mtd->size;
- 
--	return mtd_to_part(mtd)->master->size;
-+	return mtd_to_part(mtd)->parent->size;
- }
- EXPORT_SYMBOL_GPL(mtd_get_device_size);
--- a/target/linux/generic/backport-4.9/065-v4.13-0006-mtd-partitions-add-support-for-subpartitions.patch	2022-03-22 08:54:47.091464476 +0800
+++ b/target/linux/generic/backport-4.9/065-v4.13-0006-mtd-partitions-add-support-for-subpartitions.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,96 +0,0 @@
-From 97519dc52b44af054d7654776e78eaa211cf1842 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Wed, 21 Jun 2017 08:26:45 +0200
-Subject: [PATCH] mtd: partitions: add support for subpartitions
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Some flash device partitions can be containers with extra subpartitions
-(volumes). All callbacks are already capable of this additional level of
-indirection.
-
-This patch makes sure we always display subpartitions using a tree
-structure and takes care of deleting subpartitions when parent gets
-removed.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Signed-off-by: Brian Norris <computersforpeace@gmail.com>
----
- drivers/mtd/mtdpart.c | 23 ++++++++++++++++-------
- 1 file changed, 16 insertions(+), 7 deletions(-)
-
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -413,7 +413,7 @@ static struct mtd_part *allocate_partiti
- 	 * parent conditional on that option. Note, this is a way to
- 	 * distinguish between the master and the partition in sysfs.
- 	 */
--	slave->mtd.dev.parent = IS_ENABLED(CONFIG_MTD_PARTITIONED_MASTER) ?
-+	slave->mtd.dev.parent = IS_ENABLED(CONFIG_MTD_PARTITIONED_MASTER) || mtd_is_partition(parent) ?
- 				&parent->dev :
- 				parent->dev.parent;
- 	slave->mtd.dev.of_node = part->of_node;
-@@ -675,8 +675,17 @@ EXPORT_SYMBOL_GPL(mtd_add_partition);
-  */
- static int __mtd_del_partition(struct mtd_part *priv)
- {
-+	struct mtd_part *child, *next;
- 	int err;
- 
-+	list_for_each_entry_safe(child, next, &mtd_partitions, list) {
-+		if (child->parent == &priv->mtd) {
-+			err = __mtd_del_partition(child);
-+			if (err)
-+				return err;
-+		}
-+	}
-+
- 	sysfs_remove_files(&priv->mtd.dev.kobj, mtd_partition_attrs);
- 
- 	err = del_mtd_device(&priv->mtd);
-@@ -691,16 +700,16 @@ static int __mtd_del_partition(struct mt
- 
- /*
-  * This function unregisters and destroy all slave MTD objects which are
-- * attached to the given master MTD object.
-+ * attached to the given MTD object.
-  */
--int del_mtd_partitions(struct mtd_info *master)
-+int del_mtd_partitions(struct mtd_info *mtd)
- {
- 	struct mtd_part *slave, *next;
- 	int ret, err = 0;
- 
- 	mutex_lock(&mtd_partitions_mutex);
- 	list_for_each_entry_safe(slave, next, &mtd_partitions, list)
--		if (slave->parent == master) {
-+		if (slave->parent == mtd) {
- 			ret = __mtd_del_partition(slave);
- 			if (ret < 0)
- 				err = ret;
-@@ -710,14 +719,14 @@ int del_mtd_partitions(struct mtd_info *
- 	return err;
- }
- 
--int mtd_del_partition(struct mtd_info *master, int partno)
-+int mtd_del_partition(struct mtd_info *mtd, int partno)
- {
- 	struct mtd_part *slave, *next;
- 	int ret = -EINVAL;
- 
- 	mutex_lock(&mtd_partitions_mutex);
- 	list_for_each_entry_safe(slave, next, &mtd_partitions, list)
--		if ((slave->parent == master) &&
-+		if ((slave->parent == mtd) &&
- 		    (slave->mtd.index == partno)) {
- 			ret = __mtd_del_partition(slave);
- 			break;
-@@ -964,6 +973,6 @@ uint64_t mtd_get_device_size(const struc
- 	if (!mtd_is_partition(mtd))
- 		return mtd->size;
- 
--	return mtd_to_part(mtd)->parent->size;
-+	return mtd_get_device_size(mtd_to_part(mtd)->parent);
- }
- EXPORT_SYMBOL_GPL(mtd_get_device_size);
--- a/target/linux/generic/backport-4.9/065-v4.13-0007-mtd-partitions-add-support-for-partition-parsers.patch	2022-03-22 08:54:47.091464476 +0800
+++ b/target/linux/generic/backport-4.9/065-v4.13-0007-mtd-partitions-add-support-for-partition-parsers.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,110 +0,0 @@
-From 1a0915be192606fee64830b9c5d70b7ed59426b6 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Wed, 21 Jun 2017 08:26:46 +0200
-Subject: [PATCH] mtd: partitions: add support for partition parsers
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Some devices have partitions that are kind of containers with extra
-subpartitions / volumes instead of e.g. a simple filesystem data. To
-support such cases we need to first create normal flash device
-partitions and then take care of these special ones.
-
-It's very common case for home routers. Depending on the vendor there
-are formats like TRX, Seama, TP-Link, WRGG & more. All of them are used
-to embed few partitions into a single one / single firmware file.
-
-Ideally all vendors would use some well documented / standardized format
-like UBI (and some probably start doing so), but there are still
-countless devices on the market using these poor vendor specific
-formats.
-
-This patch extends MTD subsystem by allowing to specify list of parsers
-that should be tried for a given partition. Supporting such poor formats
-is highly unlikely to be the top priority so these changes try to
-minimize maintenance cost to the minimum. It reuses existing code for
-these new parsers and just adds a one property and one new function.
-
-This implementation requires setting partition parsers in a flash
-parser. A proper change of bcm47xxpart will follow and in the future we
-will hopefully also find a solution for doing it with ofpart
-("fixed-partitions").
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Signed-off-by: Brian Norris <computersforpeace@gmail.com>
----
- drivers/mtd/mtdpart.c          | 31 +++++++++++++++++++++++++++++++
- include/linux/mtd/partitions.h |  7 +++++++
- 2 files changed, 38 insertions(+)
-
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -369,6 +369,35 @@ static inline void free_partition(struct
- 	kfree(p);
- }
- 
-+/**
-+ * mtd_parse_part - parse MTD partition looking for subpartitions
-+ *
-+ * @slave: part that is supposed to be a container and should be parsed
-+ * @types: NULL-terminated array with names of partition parsers to try
-+ *
-+ * Some partitions are kind of containers with extra subpartitions (volumes).
-+ * There can be various formats of such containers. This function tries to use
-+ * specified parsers to analyze given partition and registers found
-+ * subpartitions on success.
-+ */
-+static int mtd_parse_part(struct mtd_part *slave, const char *const *types)
-+{
-+	struct mtd_partitions parsed;
-+	int err;
-+
-+	err = parse_mtd_partitions(&slave->mtd, types, &parsed, NULL);
-+	if (err)
-+		return err;
-+	else if (!parsed.nr_parts)
-+		return -ENOENT;
-+
-+	err = add_mtd_partitions(&slave->mtd, parsed.parts, parsed.nr_parts);
-+
-+	mtd_part_parser_cleanup(&parsed);
-+
-+	return err;
-+}
-+
- static struct mtd_part *allocate_partition(struct mtd_info *parent,
- 			const struct mtd_partition *part, int partno,
- 			uint64_t cur_offset)
-@@ -778,6 +807,8 @@ int add_mtd_partitions(struct mtd_info *
- 		}
- 
- 		mtd_add_partition_attrs(slave);
-+		if (parts[i].types)
-+			mtd_parse_part(slave, parts[i].types);
- 
- 		cur_offset = slave->offset + slave->mtd.size;
- 	}
---- a/include/linux/mtd/partitions.h
-+++ b/include/linux/mtd/partitions.h
-@@ -20,6 +20,12 @@
-  *
-  * For each partition, these fields are available:
-  * name: string that will be used to label the partition's MTD device.
-+ * types: some partitions can be containers using specific format to describe
-+ *	embedded subpartitions / volumes. E.g. many home routers use "firmware"
-+ *	partition that contains at least kernel and rootfs. In such case an
-+ *	extra parser is needed that will detect these dynamic partitions and
-+ *	report them to the MTD subsystem. If set this property stores an array
-+ *	of parser names to use when looking for subpartitions.
-  * size: the partition size; if defined as MTDPART_SIZ_FULL, the partition
-  * 	will extend to the end of the master MTD device.
-  * offset: absolute starting position within the master MTD device; if
-@@ -38,6 +44,7 @@
- 
- struct mtd_partition {
- 	const char *name;		/* identifier string */
-+	const char *const *types;	/* names of parsers to use if any */
- 	uint64_t size;			/* partition size */
- 	uint64_t offset;		/* offset within the master MTD space */
- 	uint32_t mask_flags;		/* master MTD flags to mask out for this partition */
--- a/target/linux/generic/backport-4.9/065-v4.13-0008-mtd-extract-TRX-parser-out-of-bcm47xxpart-into-a-sep.patch	2022-03-22 08:54:47.092464478 +0800
+++ b/target/linux/generic/backport-4.9/065-v4.13-0008-mtd-extract-TRX-parser-out-of-bcm47xxpart-into-a-sep.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,320 +0,0 @@
-From 99352afe8f169c95b294b6b9a8d0e18cd9e3c2a0 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Wed, 21 Jun 2017 08:26:47 +0200
-Subject: [PATCH] mtd: extract TRX parser out of bcm47xxpart into a separated
- module
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-This makes TRX parsing code reusable with other platforms and parsers.
-
-Please note this patch doesn't really change anything in the existing
-code, just moves it. There is still some place for improvement (e.g.
-working on non-hacky method of checking rootfs format) but it's not
-really a subject of this change.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Signed-off-by: Brian Norris <computersforpeace@gmail.com>
----
- drivers/mtd/Kconfig              |   4 ++
- drivers/mtd/Makefile             |   1 +
- drivers/mtd/bcm47xxpart.c        |  99 ++----------------------------
- drivers/mtd/parsers/Kconfig      |   8 +++
- drivers/mtd/parsers/Makefile     |   1 +
- drivers/mtd/parsers/parser_trx.c | 126 +++++++++++++++++++++++++++++++++++++++
- 6 files changed, 145 insertions(+), 94 deletions(-)
- create mode 100644 drivers/mtd/parsers/Kconfig
- create mode 100644 drivers/mtd/parsers/Makefile
- create mode 100644 drivers/mtd/parsers/parser_trx.c
-
---- a/drivers/mtd/Kconfig
-+++ b/drivers/mtd/Kconfig
-@@ -155,6 +155,10 @@ config MTD_BCM47XX_PARTS
- 	  This provides partitions parser for devices based on BCM47xx
- 	  boards.
- 
-+menu "Partition parsers"
-+source "drivers/mtd/parsers/Kconfig"
-+endmenu
-+
- comment "User Modules And Translation Layers"
- 
- #
---- a/drivers/mtd/Makefile
-+++ b/drivers/mtd/Makefile
-@@ -13,6 +13,7 @@ obj-$(CONFIG_MTD_AFS_PARTS)	+= afs.o
- obj-$(CONFIG_MTD_AR7_PARTS)	+= ar7part.o
- obj-$(CONFIG_MTD_BCM63XX_PARTS)	+= bcm63xxpart.o
- obj-$(CONFIG_MTD_BCM47XX_PARTS)	+= bcm47xxpart.o
-+obj-y				+= parsers/
- 
- # 'Users' - code which presents functionality to userspace.
- obj-$(CONFIG_MTD_BLKDEVS)	+= mtd_blkdevs.o
---- a/drivers/mtd/bcm47xxpart.c
-+++ b/drivers/mtd/bcm47xxpart.c
-@@ -43,7 +43,8 @@
- #define ML_MAGIC2			0x26594131
- #define TRX_MAGIC			0x30524448
- #define SHSQ_MAGIC			0x71736873	/* shsq (weird ZTE H218N endianness) */
--#define UBI_EC_MAGIC			0x23494255	/* UBI# */
-+
-+static const char * const trx_types[] = { "trx", NULL };
- 
- struct trx_header {
- 	uint32_t magic;
-@@ -62,89 +63,6 @@ static void bcm47xxpart_add_part(struct
- 	part->mask_flags = mask_flags;
- }
- 
--static const char *bcm47xxpart_trx_data_part_name(struct mtd_info *master,
--						  size_t offset)
--{
--	uint32_t buf;
--	size_t bytes_read;
--	int err;
--
--	err  = mtd_read(master, offset, sizeof(buf), &bytes_read,
--			(uint8_t *)&buf);
--	if (err && !mtd_is_bitflip(err)) {
--		pr_err("mtd_read error while parsing (offset: 0x%X): %d\n",
--			offset, err);
--		goto out_default;
--	}
--
--	if (buf == UBI_EC_MAGIC)
--		return "ubi";
--
--out_default:
--	return "rootfs";
--}
--
--static int bcm47xxpart_parse_trx(struct mtd_info *master,
--				 struct mtd_partition *trx,
--				 struct mtd_partition *parts,
--				 size_t parts_len)
--{
--	struct trx_header header;
--	size_t bytes_read;
--	int curr_part = 0;
--	int i, err;
--
--	if (parts_len < 3) {
--		pr_warn("No enough space to add TRX partitions!\n");
--		return -ENOMEM;
--	}
--
--	err = mtd_read(master, trx->offset, sizeof(header), &bytes_read,
--		       (uint8_t *)&header);
--	if (err && !mtd_is_bitflip(err)) {
--		pr_err("mtd_read error while reading TRX header: %d\n", err);
--		return err;
--	}
--
--	i = 0;
--
--	/* We have LZMA loader if offset[2] points to sth */
--	if (header.offset[2]) {
--		bcm47xxpart_add_part(&parts[curr_part++], "loader",
--				     trx->offset + header.offset[i], 0);
--		i++;
--	}
--
--	if (header.offset[i]) {
--		bcm47xxpart_add_part(&parts[curr_part++], "linux",
--				     trx->offset + header.offset[i], 0);
--		i++;
--	}
--
--	if (header.offset[i]) {
--		size_t offset = trx->offset + header.offset[i];
--		const char *name = bcm47xxpart_trx_data_part_name(master,
--								  offset);
--
--		bcm47xxpart_add_part(&parts[curr_part++], name, offset, 0);
--		i++;
--	}
--
--	/*
--	 * Assume that every partition ends at the beginning of the one it is
--	 * followed by.
--	 */
--	for (i = 0; i < curr_part; i++) {
--		u64 next_part_offset = (i < curr_part - 1) ?
--					parts[i + 1].offset :
--					trx->offset + trx->size;
--
--		parts[i].size = next_part_offset - parts[i].offset;
--	}
--
--	return curr_part;
--}
--
- /**
-  * bcm47xxpart_bootpartition - gets index of TRX partition used by bootloader
-  *
-@@ -362,17 +280,10 @@ static int bcm47xxpart_parse(struct mtd_
- 	for (i = 0; i < trx_num; i++) {
- 		struct mtd_partition *trx = &parts[trx_parts[i]];
- 
--		if (i == bcm47xxpart_bootpartition()) {
--			int num_parts;
--
--			num_parts = bcm47xxpart_parse_trx(master, trx,
--							  parts + curr_part,
--							  BCM47XXPART_MAX_PARTS - curr_part);
--			if (num_parts > 0)
--				curr_part += num_parts;
--		} else {
-+		if (i == bcm47xxpart_bootpartition())
-+			trx->types = trx_types;
-+		else
- 			trx->name = "failsafe";
--		}
- 	}
- 
- 	*pparts = parts;
---- /dev/null
-+++ b/drivers/mtd/parsers/Kconfig
-@@ -0,0 +1,8 @@
-+config MTD_PARSER_TRX
-+	tristate "Parser for TRX format partitions"
-+	depends on MTD && (BCM47XX || ARCH_BCM_5301X || COMPILE_TEST)
-+	help
-+	  TRX is a firmware format used by Broadcom on their devices. It
-+	  may contain up to 3/4 partitions (depending on the version).
-+	  This driver will parse TRX header and report at least two partitions:
-+	  kernel and rootfs.
---- /dev/null
-+++ b/drivers/mtd/parsers/Makefile
-@@ -0,0 +1 @@
-+obj-$(CONFIG_MTD_PARSER_TRX)		+= parser_trx.o
---- /dev/null
-+++ b/drivers/mtd/parsers/parser_trx.c
-@@ -0,0 +1,126 @@
-+/*
-+ * Parser for TRX format partitions
-+ *
-+ * Copyright (C) 2012 - 2017 Rafa Miecki <rafal@milecki.pl>
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License version 2 as
-+ * published by the Free Software Foundation.
-+ *
-+ */
-+
-+#include <linux/module.h>
-+#include <linux/slab.h>
-+#include <linux/mtd/mtd.h>
-+#include <linux/mtd/partitions.h>
-+
-+#define TRX_PARSER_MAX_PARTS		4
-+
-+/* Magics */
-+#define TRX_MAGIC			0x30524448
-+#define UBI_EC_MAGIC			0x23494255	/* UBI# */
-+
-+struct trx_header {
-+	uint32_t magic;
-+	uint32_t length;
-+	uint32_t crc32;
-+	uint16_t flags;
-+	uint16_t version;
-+	uint32_t offset[3];
-+} __packed;
-+
-+static const char *parser_trx_data_part_name(struct mtd_info *master,
-+					     size_t offset)
-+{
-+	uint32_t buf;
-+	size_t bytes_read;
-+	int err;
-+
-+	err  = mtd_read(master, offset, sizeof(buf), &bytes_read,
-+			(uint8_t *)&buf);
-+	if (err && !mtd_is_bitflip(err)) {
-+		pr_err("mtd_read error while parsing (offset: 0x%X): %d\n",
-+			offset, err);
-+		goto out_default;
-+	}
-+
-+	if (buf == UBI_EC_MAGIC)
-+		return "ubi";
-+
-+out_default:
-+	return "rootfs";
-+}
-+
-+static int parser_trx_parse(struct mtd_info *mtd,
-+			    const struct mtd_partition **pparts,
-+			    struct mtd_part_parser_data *data)
-+{
-+	struct mtd_partition *parts;
-+	struct mtd_partition *part;
-+	struct trx_header trx;
-+	size_t bytes_read;
-+	uint8_t curr_part = 0, i = 0;
-+	int err;
-+
-+	parts = kzalloc(sizeof(struct mtd_partition) * TRX_PARSER_MAX_PARTS,
-+			GFP_KERNEL);
-+	if (!parts)
-+		return -ENOMEM;
-+
-+	err = mtd_read(mtd, 0, sizeof(trx), &bytes_read, (uint8_t *)&trx);
-+	if (err) {
-+		pr_err("MTD reading error: %d\n", err);
-+		kfree(parts);
-+		return err;
-+	}
-+
-+	if (trx.magic != TRX_MAGIC) {
-+		kfree(parts);
-+		return -ENOENT;
-+	}
-+
-+	/* We have LZMA loader if there is address in offset[2] */
-+	if (trx.offset[2]) {
-+		part = &parts[curr_part++];
-+		part->name = "loader";
-+		part->offset = trx.offset[i];
-+		i++;
-+	}
-+
-+	if (trx.offset[i]) {
-+		part = &parts[curr_part++];
-+		part->name = "linux";
-+		part->offset = trx.offset[i];
-+		i++;
-+	}
-+
-+	if (trx.offset[i]) {
-+		part = &parts[curr_part++];
-+		part->name = parser_trx_data_part_name(mtd, trx.offset[i]);
-+		part->offset = trx.offset[i];
-+		i++;
-+	}
-+
-+	/*
-+	 * Assume that every partition ends at the beginning of the one it is
-+	 * followed by.
-+	 */
-+	for (i = 0; i < curr_part; i++) {
-+		u64 next_part_offset = (i < curr_part - 1) ?
-+				       parts[i + 1].offset : mtd->size;
-+
-+		parts[i].size = next_part_offset - parts[i].offset;
-+	}
-+
-+	*pparts = parts;
-+	return i;
-+};
-+
-+static struct mtd_part_parser mtd_parser_trx = {
-+	.parse_fn = parser_trx_parse,
-+	.name = "trx",
-+};
-+module_mtd_part_parser(mtd_parser_trx);
-+
-+MODULE_LICENSE("GPL v2");
-+MODULE_DESCRIPTION("Parser for TRX format partitions");
--- a/target/linux/generic/backport-4.9/066-v4.17-0001-mtd-move-code-adding-master-MTD-out-of-mtd_add_devic.patch	2022-03-22 08:54:47.092464478 +0800
+++ b/target/linux/generic/backport-4.9/066-v4.17-0001-mtd-move-code-adding-master-MTD-out-of-mtd_add_devic.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,74 +0,0 @@
-From 2c77c57d22adb05b21cdb333a0c42bdfa0e19835 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Tue, 16 Jan 2018 16:45:41 +0100
-Subject: [PATCH] mtd: move code adding master MTD out of
- mtd_add_device_partitions()
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-This change is a small cleanup of mtd_device_parse_register(). When
-using MTD_PARTITIONED_MASTER it makes sure a master MTD is registered
-before dealing with partitions. The advantage of this is not mixing
-code handling master MTD with code handling partitions.
-
-This commit doesn't change any behavior except from a slightly different
-failure code path. The new code may need to call del_mtd_device when
-something goes wrong.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
----
- drivers/mtd/mtdcore.c | 25 +++++++++++++------------
- 1 file changed, 13 insertions(+), 12 deletions(-)
-
---- a/drivers/mtd/mtdcore.c
-+++ b/drivers/mtd/mtdcore.c
-@@ -631,20 +631,12 @@ static int mtd_add_device_partitions(str
- {
- 	const struct mtd_partition *real_parts = parts->parts;
- 	int nbparts = parts->nr_parts;
--	int ret;
- 
--	if (nbparts == 0 || IS_ENABLED(CONFIG_MTD_PARTITIONED_MASTER)) {
--		ret = add_mtd_device(mtd);
--		if (ret)
--			return ret;
--	}
-+	if (!nbparts && !device_is_registered(&mtd->dev))
-+		return add_mtd_device(mtd);
- 
--	if (nbparts > 0) {
--		ret = add_mtd_partitions(mtd, real_parts, nbparts);
--		if (ret && IS_ENABLED(CONFIG_MTD_PARTITIONED_MASTER))
--			del_mtd_device(mtd);
--		return ret;
--	}
-+	if (nbparts > 0)
-+		return add_mtd_partitions(mtd, real_parts, nbparts);
- 
- 	return 0;
- }
-@@ -704,6 +696,12 @@ int mtd_device_parse_register(struct mtd
- 
- 	mtd_set_dev_defaults(mtd);
- 
-+	if (IS_ENABLED(CONFIG_MTD_PARTITIONED_MASTER)) {
-+		ret = add_mtd_device(mtd);
-+		if (ret)
-+			return ret;
-+	}
-+
- 	memset(&parsed, 0, sizeof(parsed));
- 
- 	ret = parse_mtd_partitions(mtd, types, &parsed, parser_data);
-@@ -743,6 +741,9 @@ int mtd_device_parse_register(struct mtd
- out:
- 	/* Cleanup any parsed partitions */
- 	mtd_part_parser_cleanup(&parsed);
-+	if (ret && device_is_registered(&mtd->dev))
-+		del_mtd_device(mtd);
-+
- 	return ret;
- }
- EXPORT_SYMBOL_GPL(mtd_device_parse_register);
--- a/target/linux/generic/backport-4.9/066-v4.17-0002-mtd-get-rid-of-the-mtd_add_device_partitions.patch	2022-03-22 08:54:47.093464479 +0800
+++ b/target/linux/generic/backport-4.9/066-v4.17-0002-mtd-get-rid-of-the-mtd_add_device_partitions.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,93 +0,0 @@
-From 0dbe4ea78d69756efeb0bba0764f6bd4a9ee9567 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Tue, 16 Jan 2018 16:45:42 +0100
-Subject: [PATCH] mtd: get rid of the mtd_add_device_partitions()
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-This simplifies code a bit by:
-1) Avoiding an extra (tiny) function
-2) Checking for amount of parsed (found) partitions just once
-3) Avoiding clearing/filling struct mtd_partitions manually
-
-With this commit proper functions are called directly from the
-mtd_device_parse_register(). It doesn't need to use minor tricks like
-memsetting struct to 0 to trigger an expected
-mtd_add_device_partitions() behavior.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
----
- drivers/mtd/mtdcore.c | 43 ++++++++++++-------------------------------
- 1 file changed, 12 insertions(+), 31 deletions(-)
-
---- a/drivers/mtd/mtdcore.c
-+++ b/drivers/mtd/mtdcore.c
-@@ -626,21 +626,6 @@ out_error:
- 	return ret;
- }
- 
--static int mtd_add_device_partitions(struct mtd_info *mtd,
--				     struct mtd_partitions *parts)
--{
--	const struct mtd_partition *real_parts = parts->parts;
--	int nbparts = parts->nr_parts;
--
--	if (!nbparts && !device_is_registered(&mtd->dev))
--		return add_mtd_device(mtd);
--
--	if (nbparts > 0)
--		return add_mtd_partitions(mtd, real_parts, nbparts);
--
--	return 0;
--}
--
- /*
-  * Set a few defaults based on the parent devices, if not provided by the
-  * driver
-@@ -691,7 +676,7 @@ int mtd_device_parse_register(struct mtd
- 			      const struct mtd_partition *parts,
- 			      int nr_parts)
- {
--	struct mtd_partitions parsed;
-+	struct mtd_partitions parsed = { };
- 	int ret;
- 
- 	mtd_set_dev_defaults(mtd);
-@@ -702,24 +687,20 @@ int mtd_device_parse_register(struct mtd
- 			return ret;
- 	}
- 
--	memset(&parsed, 0, sizeof(parsed));
--
-+	/* Prefer parsed partitions over driver-provided fallback */
- 	ret = parse_mtd_partitions(mtd, types, &parsed, parser_data);
--	if ((ret < 0 || parsed.nr_parts == 0) && parts && nr_parts) {
--		/* Fall back to driver-provided partitions */
--		parsed = (struct mtd_partitions){
--			.parts		= parts,
--			.nr_parts	= nr_parts,
--		};
--	} else if (ret < 0) {
--		/* Didn't come up with parsed OR fallback partitions */
--		pr_info("mtd: failed to find partitions; one or more parsers reports errors (%d)\n",
--			ret);
--		/* Don't abort on errors; we can still use unpartitioned MTD */
--		memset(&parsed, 0, sizeof(parsed));
-+	if (!ret && parsed.nr_parts) {
-+		parts = parsed.parts;
-+		nr_parts = parsed.nr_parts;
- 	}
- 
--	ret = mtd_add_device_partitions(mtd, &parsed);
-+	if (nr_parts)
-+		ret = add_mtd_partitions(mtd, parts, nr_parts);
-+	else if (!device_is_registered(&mtd->dev))
-+		ret = add_mtd_device(mtd);
-+	else
-+		ret = 0;
-+
- 	if (ret)
- 		goto out;
- 
--- a/target/linux/generic/backport-4.9/067-v4.17-0001-mtd-partitions-add-of_match_table-parser-matching-fo.patch	2022-03-22 08:54:47.093464479 +0800
+++ b/target/linux/generic/backport-4.9/067-v4.17-0001-mtd-partitions-add-of_match_table-parser-matching-fo.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,200 +0,0 @@
-From 5b644aa012f67fd211138a067b9f351f30bdcc60 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Wed, 14 Mar 2018 13:10:42 +0100
-Subject: [PATCH] mtd: partitions: add of_match_table parser matching for the
- "ofpart" type
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-In order to properly support compatibility strings as described in the
-bindings/mtd/partition.txt "ofpart" type should be treated as an
-indication for looking into OF. MTD should check "compatible" property
-and search for a matching parser rather than blindly trying the one
-supporting "fixed-partitions".
-
-It also means that existing "fixed-partitions" parser should get renamed
-to use a more meaningful name.
-
-This commit achievies that aim by introducing a new mtd_part_of_parse().
-It works by looking for a matching parser for every string in the
-"compatibility" property (starting with the most specific one).
-
-Please note that driver-specified parsers still take a precedence. It's
-assumed that driver providing a parser type has a good reason for that
-(e.g. having platform data with device-specific info). Also doing
-otherwise could break existing setups. The same applies to using default
-parsers (including "cmdlinepart") as some overwrite DT data with cmdline
-argument.
-
-Partition parsers can now provide an of_match_table to enable
-flash<-->parser matching via device tree as documented in the
-mtd/partition.txt.
-
-This support is currently limited to built-in parsers as it uses
-request_module() and friends. This should be sufficient for most cases
-though as compiling parsers as modules isn't a common choice.
-
-Signed-off-by: Brian Norris <computersforpeace@gmail.com>
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Tested-by: Peter Rosin <peda@axentia.se>
-Reviewed-by: Richard Weinberger <richard@nod.at>
-Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
----
- drivers/mtd/mtdpart.c          | 116 +++++++++++++++++++++++++++++++++++++----
- include/linux/mtd/partitions.h |   1 +
- 2 files changed, 108 insertions(+), 9 deletions(-)
-
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -30,6 +30,7 @@
- #include <linux/mtd/mtd.h>
- #include <linux/mtd/partitions.h>
- #include <linux/err.h>
-+#include <linux/of.h>
- 
- #include "mtdcore.h"
- 
-@@ -911,6 +912,92 @@ static int mtd_part_do_parse(struct mtd_
- }
- 
- /**
-+ * mtd_part_get_compatible_parser - find MTD parser by a compatible string
-+ *
-+ * @compat: compatible string describing partitions in a device tree
-+ *
-+ * MTD parsers can specify supported partitions by providing a table of
-+ * compatibility strings. This function finds a parser that advertises support
-+ * for a passed value of "compatible".
-+ */
-+static struct mtd_part_parser *mtd_part_get_compatible_parser(const char *compat)
-+{
-+	struct mtd_part_parser *p, *ret = NULL;
-+
-+	spin_lock(&part_parser_lock);
-+
-+	list_for_each_entry(p, &part_parsers, list) {
-+		const struct of_device_id *matches;
-+
-+		matches = p->of_match_table;
-+		if (!matches)
-+			continue;
-+
-+		for (; matches->compatible[0]; matches++) {
-+			if (!strcmp(matches->compatible, compat) &&
-+			    try_module_get(p->owner)) {
-+				ret = p;
-+				break;
-+			}
-+		}
-+
-+		if (ret)
-+			break;
-+	}
-+
-+	spin_unlock(&part_parser_lock);
-+
-+	return ret;
-+}
-+
-+static int mtd_part_of_parse(struct mtd_info *master,
-+			     struct mtd_partitions *pparts)
-+{
-+	struct mtd_part_parser *parser;
-+	struct device_node *np;
-+	struct property *prop;
-+	const char *compat;
-+	const char *fixed = "ofpart";
-+	int ret, err = 0;
-+
-+	np = of_get_child_by_name(mtd_get_of_node(master), "partitions");
-+	of_property_for_each_string(np, "compatible", prop, compat) {
-+		parser = mtd_part_get_compatible_parser(compat);
-+		if (!parser)
-+			continue;
-+		ret = mtd_part_do_parse(parser, master, pparts, NULL);
-+		if (ret > 0) {
-+			of_node_put(np);
-+			return ret;
-+		}
-+		mtd_part_parser_put(parser);
-+		if (ret < 0 && !err)
-+			err = ret;
-+	}
-+	of_node_put(np);
-+
-+	/*
-+	 * For backward compatibility we have to try the "ofpart"
-+	 * parser. It supports old DT format with partitions specified as a
-+	 * direct subnodes of a flash device DT node without any compatibility
-+	 * specified we could match.
-+	 */
-+	parser = mtd_part_parser_get(fixed);
-+	if (!parser && !request_module("%s", fixed))
-+		parser = mtd_part_parser_get(fixed);
-+	if (parser) {
-+		ret = mtd_part_do_parse(parser, master, pparts, NULL);
-+		if (ret > 0)
-+			return ret;
-+		mtd_part_parser_put(parser);
-+		if (ret < 0 && !err)
-+			err = ret;
-+	}
-+
-+	return err;
-+}
-+
-+/**
-  * parse_mtd_partitions - parse MTD partitions
-  * @master: the master partition (describes whole MTD device)
-  * @types: names of partition parsers to try or %NULL
-@@ -942,19 +1029,30 @@ int parse_mtd_partitions(struct mtd_info
- 		types = default_mtd_part_types;
- 
- 	for ( ; *types; types++) {
--		pr_debug("%s: parsing partitions %s\n", master->name, *types);
--		parser = mtd_part_parser_get(*types);
--		if (!parser && !request_module("%s", *types))
-+		/*
-+		 * ofpart is a special type that means OF partitioning info
-+		 * should be used. It requires a bit different logic so it is
-+		 * handled in a separated function.
-+		 */
-+		if (!strcmp(*types, "ofpart")) {
-+			ret = mtd_part_of_parse(master, pparts);
-+		} else {
-+			pr_debug("%s: parsing partitions %s\n", master->name,
-+				 *types);
- 			parser = mtd_part_parser_get(*types);
--		pr_debug("%s: got parser %s\n", master->name,
--			 parser ? parser->name : NULL);
--		if (!parser)
--			continue;
--		ret = mtd_part_do_parse(parser, master, pparts, data);
-+			if (!parser && !request_module("%s", *types))
-+				parser = mtd_part_parser_get(*types);
-+			pr_debug("%s: got parser %s\n", master->name,
-+				parser ? parser->name : NULL);
-+			if (!parser)
-+				continue;
-+			ret = mtd_part_do_parse(parser, master, pparts, data);
-+			if (ret <= 0)
-+				mtd_part_parser_put(parser);
-+		}
- 		/* Found partitions! */
- 		if (ret > 0)
- 			return 0;
--		mtd_part_parser_put(parser);
- 		/*
- 		 * Stash the first error we see; only report it if no parser
- 		 * succeeds
---- a/include/linux/mtd/partitions.h
-+++ b/include/linux/mtd/partitions.h
-@@ -77,6 +77,7 @@ struct mtd_part_parser {
- 	struct list_head list;
- 	struct module *owner;
- 	const char *name;
-+	const struct of_device_id *of_match_table;
- 	int (*parse_fn)(struct mtd_info *, const struct mtd_partition **,
- 			struct mtd_part_parser_data *);
- 	void (*cleanup)(const struct mtd_partition *pparts, int nr_parts);
--- a/target/linux/generic/backport-4.9/067-v4.17-0002-mtd-rename-ofpart-parser-to-fixed-partitions-as-it-f.patch	2022-03-22 08:54:47.094464481 +0800
+++ b/target/linux/generic/backport-4.9/067-v4.17-0002-mtd-rename-ofpart-parser-to-fixed-partitions-as-it-f.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,74 +0,0 @@
-From c0faf43482e7f7dfb6d61847cb93d17748560b24 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Wed, 14 Mar 2018 13:10:43 +0100
-Subject: [PATCH] mtd: rename "ofpart" parser to "fixed-partitions" as it fits
- it better
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Type "ofpart" means that OF should be used to get partitioning info and
-this driver supports "fixed-partitions" binding only. Renaming it should
-lead to less confusion especially when parsers for new compatibility
-strings start to appear.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Reviewed-by: Richard Weinberger <richard@nod.at>
-Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
----
- drivers/mtd/mtdpart.c |  4 ++--
- drivers/mtd/ofpart.c  | 11 ++++++-----
- 2 files changed, 8 insertions(+), 7 deletions(-)
-
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -957,7 +957,7 @@ static int mtd_part_of_parse(struct mtd_
- 	struct device_node *np;
- 	struct property *prop;
- 	const char *compat;
--	const char *fixed = "ofpart";
-+	const char *fixed = "fixed-partitions";
- 	int ret, err = 0;
- 
- 	np = of_get_child_by_name(mtd_get_of_node(master), "partitions");
-@@ -977,7 +977,7 @@ static int mtd_part_of_parse(struct mtd_
- 	of_node_put(np);
- 
- 	/*
--	 * For backward compatibility we have to try the "ofpart"
-+	 * For backward compatibility we have to try the "fixed-partitions"
- 	 * parser. It supports old DT format with partitions specified as a
- 	 * direct subnodes of a flash device DT node without any compatibility
- 	 * specified we could match.
---- a/drivers/mtd/ofpart.c
-+++ b/drivers/mtd/ofpart.c
-@@ -25,9 +25,9 @@ static bool node_has_compatible(struct d
- 	return of_get_property(pp, "compatible", NULL);
- }
- 
--static int parse_ofpart_partitions(struct mtd_info *master,
--				   const struct mtd_partition **pparts,
--				   struct mtd_part_parser_data *data)
-+static int parse_fixed_partitions(struct mtd_info *master,
-+				  const struct mtd_partition **pparts,
-+				  struct mtd_part_parser_data *data)
- {
- 	struct mtd_partition *parts;
- 	struct device_node *mtd_node;
-@@ -141,8 +141,8 @@ ofpart_none:
- }
- 
- static struct mtd_part_parser ofpart_parser = {
--	.parse_fn = parse_ofpart_partitions,
--	.name = "ofpart",
-+	.parse_fn = parse_fixed_partitions,
-+	.name = "fixed-partitions",
- };
- 
- static int parse_ofoldpart_partitions(struct mtd_info *master,
-@@ -230,4 +230,5 @@ MODULE_AUTHOR("Vitaly Wool, David Gibson
-  * with the same name. Since we provide the ofoldpart parser, we should have
-  * the corresponding alias.
-  */
-+MODULE_ALIAS("fixed-partitions");
- MODULE_ALIAS("ofoldpart");
--- a/target/linux/generic/backport-4.9/067-v4.17-0003-mtd-ofpart-add-of_match_table-with-fixed-partitions.patch	2022-03-22 08:54:47.094464481 +0800
+++ b/target/linux/generic/backport-4.9/067-v4.17-0003-mtd-ofpart-add-of_match_table-with-fixed-partitions.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,44 +0,0 @@
-From 97b0c7c0df3efd7048ed39d7e2dee34cafd55887 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Wed, 14 Mar 2018 13:10:44 +0100
-Subject: [PATCH] mtd: ofpart: add of_match_table with "fixed-partitions"
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-This allows using this parser with any flash driver that takes care of
-setting of_node (using mtd_set_of_node helper) correctly. Up to now
-support for "fixed-partitions" DT compatibility string was working only
-with flash drivers that were specifying "ofpart" (manually or by letting
-mtd use the default set of parsers).
-
-This matches existing bindings documentation.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Reviewed-by: Brian Norris <computersforpeace@gmail.com>
-Tested-by: Brian Norris <computersforpeace@gmail.com>
-Reviewed-by: Richard Weinberger <richard@nod.at>
-Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
----
- drivers/mtd/ofpart.c | 7 +++++++
- 1 file changed, 7 insertions(+)
-
---- a/drivers/mtd/ofpart.c
-+++ b/drivers/mtd/ofpart.c
-@@ -140,9 +140,16 @@ ofpart_none:
- 	return ret;
- }
- 
-+static const struct of_device_id parse_ofpart_match_table[] = {
-+	{ .compatible = "fixed-partitions" },
-+	{},
-+};
-+MODULE_DEVICE_TABLE(of, parse_ofpart_match_table);
-+
- static struct mtd_part_parser ofpart_parser = {
- 	.parse_fn = parse_fixed_partitions,
- 	.name = "fixed-partitions",
-+	.of_match_table = parse_ofpart_match_table,
- };
- 
- static int parse_ofoldpart_partitions(struct mtd_info *master,
--- a/target/linux/generic/backport-4.9/068-v4.18-0001-mtd-move-code-adding-registering-partitions-to-the-p.patch	2022-03-22 08:54:47.095464483 +0800
+++ b/target/linux/generic/backport-4.9/068-v4.18-0001-mtd-move-code-adding-registering-partitions-to-the-p.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,168 +0,0 @@
-From 5ac67ce36cfe38b4c104a42ce52c5c8d526f1c95 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Tue, 27 Mar 2018 22:35:41 +0200
-Subject: [PATCH] mtd: move code adding (registering) partitions to the
- parse_mtd_partitions()
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-This commit slightly simplifies the code. Every parse_mtd_partitions()
-caller (out of two existing ones) had to add partitions & cleanup parser
-on its own. This moves that responsibility into the function.
-
-That change also allows dropping struct mtd_partitions argument.
-
-There is one minor behavior change caused by this cleanup. If
-parse_mtd_partitions() fails to add partitions (add_mtd_partitions()
-return an error) then mtd_device_parse_register() will still try to
-add (register) fallback partitions. It's a real corner case affecting
-one of uncommon error paths and shouldn't cause any harm.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
----
- drivers/mtd/mtdcore.c | 14 ++++----------
- drivers/mtd/mtdcore.h |  1 -
- drivers/mtd/mtdpart.c | 44 ++++++++++++++++----------------------------
- 3 files changed, 20 insertions(+), 39 deletions(-)
-
---- a/drivers/mtd/mtdcore.c
-+++ b/drivers/mtd/mtdcore.c
-@@ -676,7 +676,6 @@ int mtd_device_parse_register(struct mtd
- 			      const struct mtd_partition *parts,
- 			      int nr_parts)
- {
--	struct mtd_partitions parsed = { };
- 	int ret;
- 
- 	mtd_set_dev_defaults(mtd);
-@@ -688,13 +687,10 @@ int mtd_device_parse_register(struct mtd
- 	}
- 
- 	/* Prefer parsed partitions over driver-provided fallback */
--	ret = parse_mtd_partitions(mtd, types, &parsed, parser_data);
--	if (!ret && parsed.nr_parts) {
--		parts = parsed.parts;
--		nr_parts = parsed.nr_parts;
--	}
--
--	if (nr_parts)
-+	ret = parse_mtd_partitions(mtd, types, parser_data);
-+	if (ret > 0)
-+		ret = 0;
-+	else if (nr_parts)
- 		ret = add_mtd_partitions(mtd, parts, nr_parts);
- 	else if (!device_is_registered(&mtd->dev))
- 		ret = add_mtd_device(mtd);
-@@ -720,8 +716,6 @@ int mtd_device_parse_register(struct mtd
- 	}
- 
- out:
--	/* Cleanup any parsed partitions */
--	mtd_part_parser_cleanup(&parsed);
- 	if (ret && device_is_registered(&mtd->dev))
- 		del_mtd_device(mtd);
- 
---- a/drivers/mtd/mtdcore.h
-+++ b/drivers/mtd/mtdcore.h
-@@ -14,7 +14,6 @@ int del_mtd_partitions(struct mtd_info *
- struct mtd_partitions;
- 
- int parse_mtd_partitions(struct mtd_info *master, const char * const *types,
--			 struct mtd_partitions *pparts,
- 			 struct mtd_part_parser_data *data);
- 
- void mtd_part_parser_cleanup(struct mtd_partitions *parts);
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -383,20 +383,7 @@ static inline void free_partition(struct
-  */
- static int mtd_parse_part(struct mtd_part *slave, const char *const *types)
- {
--	struct mtd_partitions parsed;
--	int err;
--
--	err = parse_mtd_partitions(&slave->mtd, types, &parsed, NULL);
--	if (err)
--		return err;
--	else if (!parsed.nr_parts)
--		return -ENOENT;
--
--	err = add_mtd_partitions(&slave->mtd, parsed.parts, parsed.nr_parts);
--
--	mtd_part_parser_cleanup(&parsed);
--
--	return err;
-+	return parse_mtd_partitions(&slave->mtd, types, NULL);
- }
- 
- static struct mtd_part *allocate_partition(struct mtd_info *parent,
-@@ -998,30 +985,27 @@ static int mtd_part_of_parse(struct mtd_
- }
- 
- /**
-- * parse_mtd_partitions - parse MTD partitions
-+ * parse_mtd_partitions - parse and register MTD partitions
-+ *
-  * @master: the master partition (describes whole MTD device)
-  * @types: names of partition parsers to try or %NULL
-- * @pparts: info about partitions found is returned here
-  * @data: MTD partition parser-specific data
-  *
-- * This function tries to find partition on MTD device @master. It uses MTD
-- * partition parsers, specified in @types. However, if @types is %NULL, then
-- * the default list of parsers is used. The default list contains only the
-+ * This function tries to find & register partitions on MTD device @master. It
-+ * uses MTD partition parsers, specified in @types. However, if @types is %NULL,
-+ * then the default list of parsers is used. The default list contains only the
-  * "cmdlinepart" and "ofpart" parsers ATM.
-  * Note: If there are more then one parser in @types, the kernel only takes the
-  * partitions parsed out by the first parser.
-  *
-  * This function may return:
-  * o a negative error code in case of failure
-- * o zero otherwise, and @pparts will describe the partitions, number of
-- *   partitions, and the parser which parsed them. Caller must release
-- *   resources with mtd_part_parser_cleanup() when finished with the returned
-- *   data.
-+ * o number of found partitions otherwise
-  */
- int parse_mtd_partitions(struct mtd_info *master, const char *const *types,
--			 struct mtd_partitions *pparts,
- 			 struct mtd_part_parser_data *data)
- {
-+	struct mtd_partitions pparts = { };
- 	struct mtd_part_parser *parser;
- 	int ret, err = 0;
- 
-@@ -1035,7 +1019,7 @@ int parse_mtd_partitions(struct mtd_info
- 		 * handled in a separated function.
- 		 */
- 		if (!strcmp(*types, "ofpart")) {
--			ret = mtd_part_of_parse(master, pparts);
-+			ret = mtd_part_of_parse(master, &pparts);
- 		} else {
- 			pr_debug("%s: parsing partitions %s\n", master->name,
- 				 *types);
-@@ -1046,13 +1030,17 @@ int parse_mtd_partitions(struct mtd_info
- 				parser ? parser->name : NULL);
- 			if (!parser)
- 				continue;
--			ret = mtd_part_do_parse(parser, master, pparts, data);
-+			ret = mtd_part_do_parse(parser, master, &pparts, data);
- 			if (ret <= 0)
- 				mtd_part_parser_put(parser);
- 		}
- 		/* Found partitions! */
--		if (ret > 0)
--			return 0;
-+		if (ret > 0) {
-+			err = add_mtd_partitions(master, pparts.parts,
-+						 pparts.nr_parts);
-+			mtd_part_parser_cleanup(&pparts);
-+			return err ? err : pparts.nr_parts;
-+		}
- 		/*
- 		 * Stash the first error we see; only report it if no parser
- 		 * succeeds
--- a/target/linux/generic/backport-4.9/069-v4.18-mtd-bcm47xxpart-improve-handling-TRX-partition-size.patch	2022-03-22 08:54:47.095464483 +0800
+++ b/target/linux/generic/backport-4.9/069-v4.18-mtd-bcm47xxpart-improve-handling-TRX-partition-size.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,70 +0,0 @@
-From 237ea0d4762cc14d0fc80e80d61f0f08e1050c7f Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Thu, 12 Apr 2018 07:24:52 +0200
-Subject: [PATCH] mtd: bcm47xxpart: improve handling TRX partition size
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-When bcm47xxpart finds a TRX partition (container) it's supposed to jump
-to the end of it and keep looking for more partitions. TRX and its
-subpartitions are handled by a separate parser.
-
-The problem with old code was relying on the length specified in a TRX
-header. That isn't reliable as TRX is commonly modified to have checksum
-cover only non-changing subpartitions. Otherwise modifying e.g. a rootfs
-would result in CRC32 mismatch and bootloader refusing to boot a
-firmware.
-
-Fix it by trying better to figure out a real TRX size. We can securely
-assume that TRX has to cover all subpartitions and the last one is at
-least of a block size in size. Then compare it with a length field.
-
-This makes code more optimal & reliable thanks to skipping data that
-shouldn't be parsed.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
----
- drivers/mtd/bcm47xxpart.c | 22 ++++++++++++++++++----
- 1 file changed, 18 insertions(+), 4 deletions(-)
-
---- a/drivers/mtd/bcm47xxpart.c
-+++ b/drivers/mtd/bcm47xxpart.c
-@@ -186,6 +186,8 @@ static int bcm47xxpart_parse(struct mtd_
- 		/* TRX */
- 		if (buf[0x000 / 4] == TRX_MAGIC) {
- 			struct trx_header *trx;
-+			uint32_t last_subpart;
-+			uint32_t trx_size;
- 
- 			if (trx_num >= ARRAY_SIZE(trx_parts))
- 				pr_warn("No enough space to store another TRX found at 0x%X\n",
-@@ -195,11 +197,23 @@ static int bcm47xxpart_parse(struct mtd_
- 			bcm47xxpart_add_part(&parts[curr_part++], "firmware",
- 					     offset, 0);
- 
--			/* Jump to the end of TRX */
-+			/*
-+			 * Try to find TRX size. The "length" field isn't fully
-+			 * reliable as it could be decreased to make CRC32 cover
-+			 * only part of TRX data. It's commonly used as checksum
-+			 * can't cover e.g. ever-changing rootfs partition.
-+			 * Use offsets as helpers for assuming min TRX size.
-+			 */
- 			trx = (struct trx_header *)buf;
--			offset = roundup(offset + trx->length, blocksize);
--			/* Next loop iteration will increase the offset */
--			offset -= blocksize;
-+			last_subpart = max3(trx->offset[0], trx->offset[1],
-+					    trx->offset[2]);
-+			trx_size = max(trx->length, last_subpart + blocksize);
-+
-+			/*
-+			 * Skip the TRX data. Decrease offset by block size as
-+			 * the next loop iteration will increase it.
-+			 */
-+			offset += roundup(trx_size, blocksize) - blocksize;
- 			continue;
- 		}
- 
--- a/target/linux/generic/backport-4.9/070-bcma-from-4.11.patch	2022-03-22 08:54:47.096464484 +0800
+++ b/target/linux/generic/backport-4.9/070-bcma-from-4.11.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,85 +0,0 @@
---- a/drivers/bcma/main.c
-+++ b/drivers/bcma/main.c
-@@ -136,17 +136,17 @@ static bool bcma_is_core_needed_early(u1
- 	return false;
- }
- 
--static struct device_node *bcma_of_find_child_device(struct platform_device *parent,
-+static struct device_node *bcma_of_find_child_device(struct device *parent,
- 						     struct bcma_device *core)
- {
- 	struct device_node *node;
- 	u64 size;
- 	const __be32 *reg;
- 
--	if (!parent || !parent->dev.of_node)
-+	if (!parent->of_node)
- 		return NULL;
- 
--	for_each_child_of_node(parent->dev.of_node, node) {
-+	for_each_child_of_node(parent->of_node, node) {
- 		reg = of_get_address(node, 0, &size, NULL);
- 		if (!reg)
- 			continue;
-@@ -156,7 +156,7 @@ static struct device_node *bcma_of_find_
- 	return NULL;
- }
- 
--static int bcma_of_irq_parse(struct platform_device *parent,
-+static int bcma_of_irq_parse(struct device *parent,
- 			     struct bcma_device *core,
- 			     struct of_phandle_args *out_irq, int num)
- {
-@@ -169,7 +169,7 @@ static int bcma_of_irq_parse(struct plat
- 			return rc;
- 	}
- 
--	out_irq->np = parent->dev.of_node;
-+	out_irq->np = parent->of_node;
- 	out_irq->args_count = 1;
- 	out_irq->args[0] = num;
- 
-@@ -177,13 +177,13 @@ static int bcma_of_irq_parse(struct plat
- 	return of_irq_parse_raw(laddr, out_irq);
- }
- 
--static unsigned int bcma_of_get_irq(struct platform_device *parent,
-+static unsigned int bcma_of_get_irq(struct device *parent,
- 				    struct bcma_device *core, int num)
- {
- 	struct of_phandle_args out_irq;
- 	int ret;
- 
--	if (!IS_ENABLED(CONFIG_OF_IRQ) || !parent || !parent->dev.of_node)
-+	if (!IS_ENABLED(CONFIG_OF_IRQ) || !parent->of_node)
- 		return 0;
- 
- 	ret = bcma_of_irq_parse(parent, core, &out_irq, num);
-@@ -196,7 +196,7 @@ static unsigned int bcma_of_get_irq(stru
- 	return irq_create_of_mapping(&out_irq);
- }
- 
--static void bcma_of_fill_device(struct platform_device *parent,
-+static void bcma_of_fill_device(struct device *parent,
- 				struct bcma_device *core)
- {
- 	struct device_node *node;
-@@ -227,7 +227,7 @@ unsigned int bcma_core_irq(struct bcma_d
- 			return mips_irq <= 4 ? mips_irq + 2 : 0;
- 		}
- 		if (bus->host_pdev)
--			return bcma_of_get_irq(bus->host_pdev, core, num);
-+			return bcma_of_get_irq(&bus->host_pdev->dev, core, num);
- 		return 0;
- 	case BCMA_HOSTTYPE_SDIO:
- 		return 0;
-@@ -253,7 +253,8 @@ void bcma_prepare_core(struct bcma_bus *
- 		if (IS_ENABLED(CONFIG_OF) && bus->host_pdev) {
- 			core->dma_dev = &bus->host_pdev->dev;
- 			core->dev.parent = &bus->host_pdev->dev;
--			bcma_of_fill_device(bus->host_pdev, core);
-+			if (core->dev.parent)
-+				bcma_of_fill_device(core->dev.parent, core);
- 		} else {
- 			core->dev.dma_mask = &core->dev.coherent_dma_mask;
- 			core->dma_dev = &core->dev;
--- a/target/linux/generic/backport-4.9/071-v4.10-0001-net-bgmac-allocate-struct-bgmac-just-once-don-t-copy.patch	2022-03-22 08:54:47.096464484 +0800
+++ b/target/linux/generic/backport-4.9/071-v4.10-0001-net-bgmac-allocate-struct-bgmac-just-once-don-t-copy.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,139 +0,0 @@
-From 34a5102c3235c470a6c77fba16cb971964d9c136 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Tue, 31 Jan 2017 19:37:54 +0100
-Subject: [PATCH 1/3] net: bgmac: allocate struct bgmac just once & don't copy
- it
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-So far were were allocating struct bgmac in 3 places: platform code,
-bcma code and shared bgmac_enet_probe function. The reason for this was
-bgmac_enet_probe:
-1) Requiring early-filled struct bgmac
-2) Calling alloc_etherdev on its own in order to use netdev_priv later
-
-This solution got few drawbacks:
-1) Was duplicating allocating code
-2) Required copying early-filled struct
-3) Resulted in platform/bcma code having access only to unused struct
-
-Solve this situation by simply extracting some probe code into the new
-bgmac_alloc function.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- drivers/net/ethernet/broadcom/bgmac-bcma.c     |  4 +---
- drivers/net/ethernet/broadcom/bgmac-platform.c |  2 +-
- drivers/net/ethernet/broadcom/bgmac.c          | 25 +++++++++++++++++--------
- drivers/net/ethernet/broadcom/bgmac.h          |  3 ++-
- 4 files changed, 21 insertions(+), 13 deletions(-)
-
---- a/drivers/net/ethernet/broadcom/bgmac-bcma.c
-+++ b/drivers/net/ethernet/broadcom/bgmac-bcma.c
-@@ -100,12 +100,11 @@ static int bgmac_probe(struct bcma_devic
- 	const u8 *mac = NULL;
- 	int err;
- 
--	bgmac = kzalloc(sizeof(*bgmac), GFP_KERNEL);
-+	bgmac = bgmac_alloc(&core->dev);
- 	if (!bgmac)
- 		return -ENOMEM;
- 
- 	bgmac->bcma.core = core;
--	bgmac->dev = &core->dev;
- 	bgmac->dma_dev = core->dma_dev;
- 	bgmac->irq = core->irq;
- 
-@@ -292,7 +291,6 @@ static int bgmac_probe(struct bcma_devic
- err1:
- 	bcma_mdio_mii_unregister(bgmac->mii_bus);
- err:
--	kfree(bgmac);
- 	bcma_set_drvdata(core, NULL);
- 
- 	return err;
---- a/drivers/net/ethernet/broadcom/bgmac-platform.c
-+++ b/drivers/net/ethernet/broadcom/bgmac-platform.c
-@@ -93,7 +93,7 @@ static int bgmac_probe(struct platform_d
- 	struct resource *regs;
- 	const u8 *mac_addr;
- 
--	bgmac = devm_kzalloc(&pdev->dev, sizeof(*bgmac), GFP_KERNEL);
-+	bgmac = bgmac_alloc(&pdev->dev);
- 	if (!bgmac)
- 		return -ENOMEM;
- 
---- a/drivers/net/ethernet/broadcom/bgmac.c
-+++ b/drivers/net/ethernet/broadcom/bgmac.c
-@@ -1460,22 +1460,32 @@ static int bgmac_phy_connect(struct bgma
- 	return 0;
- }
- 
--int bgmac_enet_probe(struct bgmac *info)
-+struct bgmac *bgmac_alloc(struct device *dev)
- {
- 	struct net_device *net_dev;
- 	struct bgmac *bgmac;
--	int err;
- 
- 	/* Allocation and references */
--	net_dev = alloc_etherdev(sizeof(*bgmac));
-+	net_dev = devm_alloc_etherdev(dev, sizeof(*bgmac));
- 	if (!net_dev)
--		return -ENOMEM;
-+		return NULL;
- 
- 	net_dev->netdev_ops = &bgmac_netdev_ops;
- 	net_dev->ethtool_ops = &bgmac_ethtool_ops;
-+
- 	bgmac = netdev_priv(net_dev);
--	memcpy(bgmac, info, sizeof(*bgmac));
-+	bgmac->dev = dev;
- 	bgmac->net_dev = net_dev;
-+
-+	return bgmac;
-+}
-+EXPORT_SYMBOL_GPL(bgmac_alloc);
-+
-+int bgmac_enet_probe(struct bgmac *bgmac)
-+{
-+	struct net_device *net_dev = bgmac->net_dev;
-+	int err;
-+
- 	net_dev->irq = bgmac->irq;
- 	SET_NETDEV_DEV(net_dev, bgmac->dev);
- 
-@@ -1502,7 +1512,7 @@ int bgmac_enet_probe(struct bgmac *info)
- 	err = bgmac_dma_alloc(bgmac);
- 	if (err) {
- 		dev_err(bgmac->dev, "Unable to alloc memory for DMA\n");
--		goto err_netdev_free;
-+		goto err_out;
- 	}
- 
- 	bgmac->int_mask = BGMAC_IS_ERRMASK | BGMAC_IS_RX | BGMAC_IS_TX_MASK;
-@@ -1538,8 +1548,7 @@ err_phy_disconnect:
- 	phy_disconnect(net_dev->phydev);
- err_dma_free:
- 	bgmac_dma_free(bgmac);
--err_netdev_free:
--	free_netdev(net_dev);
-+err_out:
- 
- 	return err;
- }
---- a/drivers/net/ethernet/broadcom/bgmac.h
-+++ b/drivers/net/ethernet/broadcom/bgmac.h
-@@ -515,7 +515,8 @@ struct bgmac {
- 			      u32 set);
- };
- 
--int bgmac_enet_probe(struct bgmac *info);
-+struct bgmac *bgmac_alloc(struct device *dev);
-+int bgmac_enet_probe(struct bgmac *bgmac);
- void bgmac_enet_remove(struct bgmac *bgmac);
- 
- struct mii_bus *bcma_mdio_mii_register(struct bcma_device *core, u8 phyaddr);
--- a/target/linux/generic/backport-4.9/071-v4.10-0002-net-bgmac-drop-struct-bcma_mdio-we-don-t-need-anymor.patch	2022-03-22 08:54:47.097464486 +0800
+++ b/target/linux/generic/backport-4.9/071-v4.10-0002-net-bgmac-drop-struct-bcma_mdio-we-don-t-need-anymor.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,261 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Tue, 31 Jan 2017 19:37:55 +0100
-Subject: [PATCH] net: bgmac: drop struct bcma_mdio we don't need anymore
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Adding struct bcma_mdio was a workaround for bcma code not having access
-to the struct bgmac used in the core code. Now we don't duplicate this
-struct we can just use it internally in bcma code.
-
-This simplifies code & allows access to all bgmac driver details from
-all places in bcma code.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/drivers/net/ethernet/broadcom/bgmac-bcma.c
-+++ b/drivers/net/ethernet/broadcom/bgmac-bcma.c
-@@ -166,7 +166,7 @@ static int bgmac_probe(struct bcma_devic
- 
- 	if (!bgmac_is_bcm4707_family(core) &&
- 	    !(ci->id == BCMA_CHIP_ID_BCM53573 && core->core_unit == 1)) {
--		mii_bus = bcma_mdio_mii_register(core, bgmac->phyaddr);
-+		mii_bus = bcma_mdio_mii_register(bgmac);
- 		if (IS_ERR(mii_bus)) {
- 			err = PTR_ERR(mii_bus);
- 			goto err;
---- a/drivers/net/ethernet/broadcom/bgmac-bcma-mdio.c
-+++ b/drivers/net/ethernet/broadcom/bgmac-bcma-mdio.c
-@@ -12,11 +12,6 @@
- #include <linux/brcmphy.h>
- #include "bgmac.h"
- 
--struct bcma_mdio {
--	struct bcma_device *core;
--	u8 phyaddr;
--};
--
- static bool bcma_mdio_wait_value(struct bcma_device *core, u16 reg, u32 mask,
- 				 u32 value, int timeout)
- {
-@@ -37,7 +32,7 @@ static bool bcma_mdio_wait_value(struct
-  * PHY ops
-  **************************************************/
- 
--static u16 bcma_mdio_phy_read(struct bcma_mdio *bcma_mdio, u8 phyaddr, u8 reg)
-+static u16 bcma_mdio_phy_read(struct bgmac *bgmac, u8 phyaddr, u8 reg)
- {
- 	struct bcma_device *core;
- 	u16 phy_access_addr;
-@@ -56,12 +51,12 @@ static u16 bcma_mdio_phy_read(struct bcm
- 	BUILD_BUG_ON(BGMAC_PC_MCT_SHIFT != BCMA_GMAC_CMN_PC_MCT_SHIFT);
- 	BUILD_BUG_ON(BGMAC_PC_MTE != BCMA_GMAC_CMN_PC_MTE);
- 
--	if (bcma_mdio->core->id.id == BCMA_CORE_4706_MAC_GBIT) {
--		core = bcma_mdio->core->bus->drv_gmac_cmn.core;
-+	if (bgmac->bcma.core->id.id == BCMA_CORE_4706_MAC_GBIT) {
-+		core = bgmac->bcma.core->bus->drv_gmac_cmn.core;
- 		phy_access_addr = BCMA_GMAC_CMN_PHY_ACCESS;
- 		phy_ctl_addr = BCMA_GMAC_CMN_PHY_CTL;
- 	} else {
--		core = bcma_mdio->core;
-+		core = bgmac->bcma.core;
- 		phy_access_addr = BGMAC_PHY_ACCESS;
- 		phy_ctl_addr = BGMAC_PHY_CNTL;
- 	}
-@@ -87,7 +82,7 @@ static u16 bcma_mdio_phy_read(struct bcm
- }
- 
- /* http://bcm-v4.sipsolutions.net/mac-gbit/gmac/chipphywr */
--static int bcma_mdio_phy_write(struct bcma_mdio *bcma_mdio, u8 phyaddr, u8 reg,
-+static int bcma_mdio_phy_write(struct bgmac *bgmac, u8 phyaddr, u8 reg,
- 			       u16 value)
- {
- 	struct bcma_device *core;
-@@ -95,12 +90,12 @@ static int bcma_mdio_phy_write(struct bc
- 	u16 phy_ctl_addr;
- 	u32 tmp;
- 
--	if (bcma_mdio->core->id.id == BCMA_CORE_4706_MAC_GBIT) {
--		core = bcma_mdio->core->bus->drv_gmac_cmn.core;
-+	if (bgmac->bcma.core->id.id == BCMA_CORE_4706_MAC_GBIT) {
-+		core = bgmac->bcma.core->bus->drv_gmac_cmn.core;
- 		phy_access_addr = BCMA_GMAC_CMN_PHY_ACCESS;
- 		phy_ctl_addr = BCMA_GMAC_CMN_PHY_CTL;
- 	} else {
--		core = bcma_mdio->core;
-+		core = bgmac->bcma.core;
- 		phy_access_addr = BGMAC_PHY_ACCESS;
- 		phy_ctl_addr = BGMAC_PHY_CNTL;
- 	}
-@@ -110,8 +105,8 @@ static int bcma_mdio_phy_write(struct bc
- 	tmp |= phyaddr;
- 	bcma_write32(core, phy_ctl_addr, tmp);
- 
--	bcma_write32(bcma_mdio->core, BGMAC_INT_STATUS, BGMAC_IS_MDIO);
--	if (bcma_read32(bcma_mdio->core, BGMAC_INT_STATUS) & BGMAC_IS_MDIO)
-+	bcma_write32(bgmac->bcma.core, BGMAC_INT_STATUS, BGMAC_IS_MDIO);
-+	if (bcma_read32(bgmac->bcma.core, BGMAC_INT_STATUS) & BGMAC_IS_MDIO)
- 		dev_warn(&core->dev, "Error setting MDIO int\n");
- 
- 	tmp = BGMAC_PA_START;
-@@ -132,39 +127,39 @@ static int bcma_mdio_phy_write(struct bc
- }
- 
- /* http://bcm-v4.sipsolutions.net/mac-gbit/gmac/chipphyinit */
--static void bcma_mdio_phy_init(struct bcma_mdio *bcma_mdio)
-+static void bcma_mdio_phy_init(struct bgmac *bgmac)
- {
--	struct bcma_chipinfo *ci = &bcma_mdio->core->bus->chipinfo;
-+	struct bcma_chipinfo *ci = &bgmac->bcma.core->bus->chipinfo;
- 	u8 i;
- 
- 	if (ci->id == BCMA_CHIP_ID_BCM5356) {
- 		for (i = 0; i < 5; i++) {
--			bcma_mdio_phy_write(bcma_mdio, i, 0x1f, 0x008b);
--			bcma_mdio_phy_write(bcma_mdio, i, 0x15, 0x0100);
--			bcma_mdio_phy_write(bcma_mdio, i, 0x1f, 0x000f);
--			bcma_mdio_phy_write(bcma_mdio, i, 0x12, 0x2aaa);
--			bcma_mdio_phy_write(bcma_mdio, i, 0x1f, 0x000b);
-+			bcma_mdio_phy_write(bgmac, i, 0x1f, 0x008b);
-+			bcma_mdio_phy_write(bgmac, i, 0x15, 0x0100);
-+			bcma_mdio_phy_write(bgmac, i, 0x1f, 0x000f);
-+			bcma_mdio_phy_write(bgmac, i, 0x12, 0x2aaa);
-+			bcma_mdio_phy_write(bgmac, i, 0x1f, 0x000b);
- 		}
- 	}
- 	if ((ci->id == BCMA_CHIP_ID_BCM5357 && ci->pkg != 10) ||
- 	    (ci->id == BCMA_CHIP_ID_BCM4749 && ci->pkg != 10) ||
- 	    (ci->id == BCMA_CHIP_ID_BCM53572 && ci->pkg != 9)) {
--		struct bcma_drv_cc *cc = &bcma_mdio->core->bus->drv_cc;
-+		struct bcma_drv_cc *cc = &bgmac->bcma.core->bus->drv_cc;
- 
- 		bcma_chipco_chipctl_maskset(cc, 2, ~0xc0000000, 0);
- 		bcma_chipco_chipctl_maskset(cc, 4, ~0x80000000, 0);
- 		for (i = 0; i < 5; i++) {
--			bcma_mdio_phy_write(bcma_mdio, i, 0x1f, 0x000f);
--			bcma_mdio_phy_write(bcma_mdio, i, 0x16, 0x5284);
--			bcma_mdio_phy_write(bcma_mdio, i, 0x1f, 0x000b);
--			bcma_mdio_phy_write(bcma_mdio, i, 0x17, 0x0010);
--			bcma_mdio_phy_write(bcma_mdio, i, 0x1f, 0x000f);
--			bcma_mdio_phy_write(bcma_mdio, i, 0x16, 0x5296);
--			bcma_mdio_phy_write(bcma_mdio, i, 0x17, 0x1073);
--			bcma_mdio_phy_write(bcma_mdio, i, 0x17, 0x9073);
--			bcma_mdio_phy_write(bcma_mdio, i, 0x16, 0x52b6);
--			bcma_mdio_phy_write(bcma_mdio, i, 0x17, 0x9273);
--			bcma_mdio_phy_write(bcma_mdio, i, 0x1f, 0x000b);
-+			bcma_mdio_phy_write(bgmac, i, 0x1f, 0x000f);
-+			bcma_mdio_phy_write(bgmac, i, 0x16, 0x5284);
-+			bcma_mdio_phy_write(bgmac, i, 0x1f, 0x000b);
-+			bcma_mdio_phy_write(bgmac, i, 0x17, 0x0010);
-+			bcma_mdio_phy_write(bgmac, i, 0x1f, 0x000f);
-+			bcma_mdio_phy_write(bgmac, i, 0x16, 0x5296);
-+			bcma_mdio_phy_write(bgmac, i, 0x17, 0x1073);
-+			bcma_mdio_phy_write(bgmac, i, 0x17, 0x9073);
-+			bcma_mdio_phy_write(bgmac, i, 0x16, 0x52b6);
-+			bcma_mdio_phy_write(bgmac, i, 0x17, 0x9273);
-+			bcma_mdio_phy_write(bgmac, i, 0x1f, 0x000b);
- 		}
- 	}
- }
-@@ -172,17 +167,17 @@ static void bcma_mdio_phy_init(struct bc
- /* http://bcm-v4.sipsolutions.net/mac-gbit/gmac/chipphyreset */
- static int bcma_mdio_phy_reset(struct mii_bus *bus)
- {
--	struct bcma_mdio *bcma_mdio = bus->priv;
--	u8 phyaddr = bcma_mdio->phyaddr;
-+	struct bgmac *bgmac = bus->priv;
-+	u8 phyaddr = bgmac->phyaddr;
- 
--	if (bcma_mdio->phyaddr == BGMAC_PHY_NOREGS)
-+	if (phyaddr == BGMAC_PHY_NOREGS)
- 		return 0;
- 
--	bcma_mdio_phy_write(bcma_mdio, phyaddr, MII_BMCR, BMCR_RESET);
-+	bcma_mdio_phy_write(bgmac, phyaddr, MII_BMCR, BMCR_RESET);
- 	udelay(100);
--	if (bcma_mdio_phy_read(bcma_mdio, phyaddr, MII_BMCR) & BMCR_RESET)
--		dev_err(&bcma_mdio->core->dev, "PHY reset failed\n");
--	bcma_mdio_phy_init(bcma_mdio);
-+	if (bcma_mdio_phy_read(bgmac, phyaddr, MII_BMCR) & BMCR_RESET)
-+		dev_err(bgmac->dev, "PHY reset failed\n");
-+	bcma_mdio_phy_init(bgmac);
- 
- 	return 0;
- }
-@@ -202,16 +197,12 @@ static int bcma_mdio_mii_write(struct mi
- 	return bcma_mdio_phy_write(bus->priv, mii_id, regnum, value);
- }
- 
--struct mii_bus *bcma_mdio_mii_register(struct bcma_device *core, u8 phyaddr)
-+struct mii_bus *bcma_mdio_mii_register(struct bgmac *bgmac)
- {
--	struct bcma_mdio *bcma_mdio;
-+	struct bcma_device *core = bgmac->bcma.core;
- 	struct mii_bus *mii_bus;
- 	int err;
- 
--	bcma_mdio = kzalloc(sizeof(*bcma_mdio), GFP_KERNEL);
--	if (!bcma_mdio)
--		return ERR_PTR(-ENOMEM);
--
- 	mii_bus = mdiobus_alloc();
- 	if (!mii_bus) {
- 		err = -ENOMEM;
-@@ -221,15 +212,12 @@ struct mii_bus *bcma_mdio_mii_register(s
- 	mii_bus->name = "bcma_mdio mii bus";
- 	sprintf(mii_bus->id, "%s-%d-%d", "bcma_mdio", core->bus->num,
- 		core->core_unit);
--	mii_bus->priv = bcma_mdio;
-+	mii_bus->priv = bgmac;
- 	mii_bus->read = bcma_mdio_mii_read;
- 	mii_bus->write = bcma_mdio_mii_write;
- 	mii_bus->reset = bcma_mdio_phy_reset;
- 	mii_bus->parent = &core->dev;
--	mii_bus->phy_mask = ~(1 << phyaddr);
--
--	bcma_mdio->core = core;
--	bcma_mdio->phyaddr = phyaddr;
-+	mii_bus->phy_mask = ~(1 << bgmac->phyaddr);
- 
- 	err = mdiobus_register(mii_bus);
- 	if (err) {
-@@ -242,23 +230,17 @@ struct mii_bus *bcma_mdio_mii_register(s
- err_free_bus:
- 	mdiobus_free(mii_bus);
- err:
--	kfree(bcma_mdio);
- 	return ERR_PTR(err);
- }
- EXPORT_SYMBOL_GPL(bcma_mdio_mii_register);
- 
- void bcma_mdio_mii_unregister(struct mii_bus *mii_bus)
- {
--	struct bcma_mdio *bcma_mdio;
--
- 	if (!mii_bus)
- 		return;
- 
--	bcma_mdio = mii_bus->priv;
--
- 	mdiobus_unregister(mii_bus);
- 	mdiobus_free(mii_bus);
--	kfree(bcma_mdio);
- }
- EXPORT_SYMBOL_GPL(bcma_mdio_mii_unregister);
- 
---- a/drivers/net/ethernet/broadcom/bgmac.h
-+++ b/drivers/net/ethernet/broadcom/bgmac.h
-@@ -519,7 +519,7 @@ struct bgmac *bgmac_alloc(struct device
- int bgmac_enet_probe(struct bgmac *bgmac);
- void bgmac_enet_remove(struct bgmac *bgmac);
- 
--struct mii_bus *bcma_mdio_mii_register(struct bcma_device *core, u8 phyaddr);
-+struct mii_bus *bcma_mdio_mii_register(struct bgmac *bgmac);
- void bcma_mdio_mii_unregister(struct mii_bus *mii_bus);
- 
- static inline u32 bgmac_read(struct bgmac *bgmac, u16 offset)
--- a/target/linux/generic/backport-4.9/071-v4.10-0003-net-bgmac-use-PHY-subsystem-for-initializing-PHY.patch	2022-03-22 08:54:47.097464486 +0800
+++ b/target/linux/generic/backport-4.9/071-v4.10-0003-net-bgmac-use-PHY-subsystem-for-initializing-PHY.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,53 +0,0 @@
-From 8e6f31baba7e2c13ab7e954fe6179420a7545a8b Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Tue, 31 Jan 2017 19:37:56 +0100
-Subject: [PATCH 3/3] net: bgmac: use PHY subsystem for initializing PHY
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-This adds support for using bgmac with PHYs supported by standalone PHY
-drivers. Having any PHY initialization in bgmac is hacky and shouldn't
-be extended but rather removed if anyone has hardware to test it.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- drivers/net/ethernet/broadcom/bgmac-bcma-mdio.c | 10 ++++++++++
- 1 file changed, 10 insertions(+)
-
---- a/drivers/net/ethernet/broadcom/bgmac-bcma-mdio.c
-+++ b/drivers/net/ethernet/broadcom/bgmac-bcma-mdio.c
-@@ -132,6 +132,10 @@ static void bcma_mdio_phy_init(struct bg
- 	struct bcma_chipinfo *ci = &bgmac->bcma.core->bus->chipinfo;
- 	u8 i;
- 
-+	/* For some legacy hardware we do chipset-based PHY initialization here
-+	 * without even detecting PHY ID. It's hacky and should be cleaned as
-+	 * soon as someone can test it.
-+	 */
- 	if (ci->id == BCMA_CHIP_ID_BCM5356) {
- 		for (i = 0; i < 5; i++) {
- 			bcma_mdio_phy_write(bgmac, i, 0x1f, 0x008b);
-@@ -140,6 +144,7 @@ static void bcma_mdio_phy_init(struct bg
- 			bcma_mdio_phy_write(bgmac, i, 0x12, 0x2aaa);
- 			bcma_mdio_phy_write(bgmac, i, 0x1f, 0x000b);
- 		}
-+		return;
- 	}
- 	if ((ci->id == BCMA_CHIP_ID_BCM5357 && ci->pkg != 10) ||
- 	    (ci->id == BCMA_CHIP_ID_BCM4749 && ci->pkg != 10) ||
-@@ -161,7 +166,12 @@ static void bcma_mdio_phy_init(struct bg
- 			bcma_mdio_phy_write(bgmac, i, 0x17, 0x9273);
- 			bcma_mdio_phy_write(bgmac, i, 0x1f, 0x000b);
- 		}
-+		return;
- 	}
-+
-+	/* For all other hw do initialization using PHY subsystem. */
-+	if (bgmac->net_dev && bgmac->net_dev->phydev)
-+		phy_init_hw(bgmac->net_dev->phydev);
- }
- 
- /* http://bcm-v4.sipsolutions.net/mac-gbit/gmac/chipphyreset */
--- a/target/linux/generic/backport-4.9/071-v4.15-0001-net-bgmac-enable-master-mode-for-BCM54210E-and-B5021.patch	2022-03-22 08:54:47.097464486 +0800
+++ b/target/linux/generic/backport-4.9/071-v4.15-0001-net-bgmac-enable-master-mode-for-BCM54210E-and-B5021.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,50 +0,0 @@
-From 12acd136913ccdf394eeb2bc8686ff5505368119 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Thu, 12 Oct 2017 10:21:26 +0200
-Subject: [PATCH] net: bgmac: enable master mode for BCM54210E and B50212E PHYs
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-There are 4 very similar PHYs:
-0x600d84a1: BCM54210E (rev B0)
-0x600d84a2: BCM54210E (rev B1)
-0x600d84a5: B50212E (rev B0)
-0x600d84a6: B50212E (rev B1)
-that need setting master mode manually. It's because they run in slave
-mode by default with Automatic Slave/Master configuration disabled which
-can lead to unreliable connection with massive ping loss.
-
-So far it was reported for a board with BCM47189 SoC and B50212E B1 PHY
-connected to the bgmac supported ethernet device. Telling PHY driver to
-setup PHY properly solves this issue.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- drivers/net/ethernet/broadcom/bgmac-bcma.c | 8 +++++++-
- 1 file changed, 7 insertions(+), 1 deletion(-)
-
---- a/drivers/net/ethernet/broadcom/bgmac-bcma.c
-+++ b/drivers/net/ethernet/broadcom/bgmac-bcma.c
-@@ -166,13 +166,19 @@ static int bgmac_probe(struct bcma_devic
- 
- 	if (!bgmac_is_bcm4707_family(core) &&
- 	    !(ci->id == BCMA_CHIP_ID_BCM53573 && core->core_unit == 1)) {
-+		struct phy_device *phydev;
-+
- 		mii_bus = bcma_mdio_mii_register(bgmac);
- 		if (IS_ERR(mii_bus)) {
- 			err = PTR_ERR(mii_bus);
- 			goto err;
- 		}
--
- 		bgmac->mii_bus = mii_bus;
-+
-+		phydev = mdiobus_get_phy(bgmac->mii_bus, bgmac->phyaddr);
-+		if (ci->id == BCMA_CHIP_ID_BCM53573 && phydev &&
-+		    (phydev->drv->phy_id & phydev->drv->phy_id_mask) == PHY_ID_BCM54210E)
-+			phydev->dev_flags |= PHY_BRCM_EN_MASTER_MODE;
- 	}
- 
- 	if (core->bus->hosttype == BCMA_HOSTTYPE_PCI) {
--- a/target/linux/generic/backport-4.9/072-bcma-from-4.12.patch	2022-03-22 08:54:47.098464488 +0800
+++ b/target/linux/generic/backport-4.9/072-bcma-from-4.12.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,47 +0,0 @@
---- a/drivers/bcma/driver_gpio.c
-+++ b/drivers/bcma/driver_gpio.c
-@@ -185,8 +185,7 @@ int bcma_gpio_init(struct bcma_drv_cc *c
- 	chip->owner		= THIS_MODULE;
- 	chip->parent		= bcma_bus_get_host_dev(bus);
- #if IS_BUILTIN(CONFIG_OF)
--	if (cc->core->bus->hosttype == BCMA_HOSTTYPE_SOC)
--		chip->of_node	= cc->core->dev.of_node;
-+	chip->of_node		= cc->core->dev.of_node;
- #endif
- 	switch (bus->chipinfo.id) {
- 	case BCMA_CHIP_ID_BCM4707:
---- a/drivers/bcma/main.c
-+++ b/drivers/bcma/main.c
-@@ -201,9 +201,6 @@ static void bcma_of_fill_device(struct d
- {
- 	struct device_node *node;
- 
--	if (!IS_ENABLED(CONFIG_OF_IRQ))
--		return;
--
- 	node = bcma_of_find_child_device(parent, core);
- 	if (node)
- 		core->dev.of_node = node;
-@@ -242,19 +239,18 @@ void bcma_prepare_core(struct bcma_bus *
- 	core->dev.release = bcma_release_core_dev;
- 	core->dev.bus = &bcma_bus_type;
- 	dev_set_name(&core->dev, "bcma%d:%d", bus->num, core->core_index);
-+	core->dev.parent = bcma_bus_get_host_dev(bus);
-+	if (core->dev.parent)
-+		bcma_of_fill_device(core->dev.parent, core);
- 
- 	switch (bus->hosttype) {
- 	case BCMA_HOSTTYPE_PCI:
--		core->dev.parent = &bus->host_pci->dev;
- 		core->dma_dev = &bus->host_pci->dev;
- 		core->irq = bus->host_pci->irq;
- 		break;
- 	case BCMA_HOSTTYPE_SOC:
- 		if (IS_ENABLED(CONFIG_OF) && bus->host_pdev) {
- 			core->dma_dev = &bus->host_pdev->dev;
--			core->dev.parent = &bus->host_pdev->dev;
--			if (core->dev.parent)
--				bcma_of_fill_device(core->dev.parent, core);
- 		} else {
- 			core->dev.dma_mask = &core->dev.coherent_dma_mask;
- 			core->dma_dev = &core->dev;
--- a/target/linux/generic/backport-4.9/075-v4.10-0001-net-phy-broadcom-Update-Auxiliary-Control-Register-m.patch	2022-03-22 08:54:47.098464488 +0800
+++ b/target/linux/generic/backport-4.9/075-v4.10-0001-net-phy-broadcom-Update-Auxiliary-Control-Register-m.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,34 +0,0 @@
-From: Xo Wang <xow@google.com>
-Date: Fri, 21 Oct 2016 10:20:12 -0700
-Subject: [PATCH] net: phy: broadcom: Update Auxiliary Control Register macros
-
-Add the RXD-to-RXC skew (delay) time bit in the Miscellaneous Control
-shadow register and a mask for the shadow selector field.
-
-Remove a re-definition of MII_BCM54XX_AUXCTL_SHDWSEL_AUXCTL.
-
-Signed-off-by: Xo Wang <xow@google.com>
-Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
-Reviewed-by: Joel Stanley <joel@jms.id.au>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/include/linux/brcmphy.h
-+++ b/include/linux/brcmphy.h
-@@ -101,6 +101,7 @@
-  * AUXILIARY CONTROL SHADOW ACCESS REGISTERS.  (PHY REG 0x18)
-  */
- #define MII_BCM54XX_AUXCTL_SHDWSEL_AUXCTL	0x0000
-+#define MII_BCM54XX_AUXCTL_MISC_RXD_RXC_SKEW	0x0100
- #define MII_BCM54XX_AUXCTL_ACTL_TX_6DB		0x0400
- #define MII_BCM54XX_AUXCTL_ACTL_SMDSP_ENA	0x0800
- 
-@@ -109,7 +110,7 @@
- #define MII_BCM54XX_AUXCTL_MISC_RDSEL_MISC	0x7000
- #define MII_BCM54XX_AUXCTL_SHDWSEL_MISC	0x0007
- 
--#define MII_BCM54XX_AUXCTL_SHDWSEL_AUXCTL	0x0000
-+#define MII_BCM54XX_AUXCTL_SHDWSEL_MASK	0x0007
- 
- /*
-  * Broadcom LED source encodings.  These are used in BCM5461, BCM5481,
--- a/target/linux/generic/backport-4.9/075-v4.10-0002-net-phy-broadcom-Add-support-for-BCM54612E.patch	2022-03-22 08:54:47.098464488 +0800
+++ b/target/linux/generic/backport-4.9/075-v4.10-0002-net-phy-broadcom-Add-support-for-BCM54612E.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,94 +0,0 @@
-From: Xo Wang <xow@google.com>
-Date: Fri, 21 Oct 2016 10:20:13 -0700
-Subject: [PATCH] net: phy: broadcom: Add support for BCM54612E
-
-This PHY has internal delays enabled after reset. This clears the
-internal delay enables unless the interface specifically requests them.
-
-Signed-off-by: Xo Wang <xow@google.com>
-Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
-Reviewed-by: Joel Stanley <joel@jms.id.au>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/drivers/net/phy/broadcom.c
-+++ b/drivers/net/phy/broadcom.c
-@@ -337,6 +337,41 @@ static int bcm5481_config_aneg(struct ph
- 	return ret;
- }
- 
-+static int bcm54612e_config_aneg(struct phy_device *phydev)
-+{
-+	int ret;
-+
-+	/* First, auto-negotiate. */
-+	ret = genphy_config_aneg(phydev);
-+
-+	/* Clear TX internal delay unless requested. */
-+	if ((phydev->interface != PHY_INTERFACE_MODE_RGMII_ID) &&
-+	    (phydev->interface != PHY_INTERFACE_MODE_RGMII_TXID)) {
-+		/* Disable TXD to GTXCLK clock delay (default set) */
-+		/* Bit 9 is the only field in shadow register 00011 */
-+		bcm_phy_write_shadow(phydev, 0x03, 0);
-+	}
-+
-+	/* Clear RX internal delay unless requested. */
-+	if ((phydev->interface != PHY_INTERFACE_MODE_RGMII_ID) &&
-+	    (phydev->interface != PHY_INTERFACE_MODE_RGMII_RXID)) {
-+		u16 reg;
-+
-+		/* Errata: reads require filling in the write selector field */
-+		bcm54xx_auxctl_write(phydev, MII_BCM54XX_AUXCTL_SHDWSEL_MISC,
-+				     MII_BCM54XX_AUXCTL_MISC_RDSEL_MISC);
-+		reg = phy_read(phydev, MII_BCM54XX_AUX_CTL);
-+		/* Disable RXD to RXC delay (default set) */
-+		reg &= ~MII_BCM54XX_AUXCTL_MISC_RXD_RXC_SKEW;
-+		/* Clear shadow selector field */
-+		reg &= ~MII_BCM54XX_AUXCTL_SHDWSEL_MASK;
-+		bcm54xx_auxctl_write(phydev, MII_BCM54XX_AUXCTL_SHDWSEL_MISC,
-+				     MII_BCM54XX_AUXCTL_MISC_WREN | reg);
-+	}
-+
-+	return ret;
-+}
-+
- static int brcm_phy_setbits(struct phy_device *phydev, int reg, int set)
- {
- 	int val;
-@@ -485,6 +520,18 @@ static struct phy_driver broadcom_driver
- 	.ack_interrupt	= bcm_phy_ack_intr,
- 	.config_intr	= bcm_phy_config_intr,
- }, {
-+	.phy_id		= PHY_ID_BCM54612E,
-+	.phy_id_mask	= 0xfffffff0,
-+	.name		= "Broadcom BCM54612E",
-+	.features	= PHY_GBIT_FEATURES |
-+			  SUPPORTED_Pause | SUPPORTED_Asym_Pause,
-+	.flags		= PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
-+	.config_init	= bcm54xx_config_init,
-+	.config_aneg	= bcm54612e_config_aneg,
-+	.read_status	= genphy_read_status,
-+	.ack_interrupt	= bcm_phy_ack_intr,
-+	.config_intr	= bcm_phy_config_intr,
-+}, {
- 	.phy_id		= PHY_ID_BCM54616S,
- 	.phy_id_mask	= 0xfffffff0,
- 	.name		= "Broadcom BCM54616S",
-@@ -600,6 +647,7 @@ static struct mdio_device_id __maybe_unu
- 	{ PHY_ID_BCM5411, 0xfffffff0 },
- 	{ PHY_ID_BCM5421, 0xfffffff0 },
- 	{ PHY_ID_BCM5461, 0xfffffff0 },
-+	{ PHY_ID_BCM54612E, 0xfffffff0 },
- 	{ PHY_ID_BCM54616S, 0xfffffff0 },
- 	{ PHY_ID_BCM5464, 0xfffffff0 },
- 	{ PHY_ID_BCM5481, 0xfffffff0 },
---- a/include/linux/brcmphy.h
-+++ b/include/linux/brcmphy.h
-@@ -18,6 +18,7 @@
- #define PHY_ID_BCM5421			0x002060e0
- #define PHY_ID_BCM5464			0x002060b0
- #define PHY_ID_BCM5461			0x002060c0
-+#define PHY_ID_BCM54612E		0x03625e60
- #define PHY_ID_BCM54616S		0x03625d10
- #define PHY_ID_BCM57780			0x03625d90
- 
--- a/target/linux/generic/backport-4.9/075-v4.10-0003-net-phy-broadcom-add-bcm54xx_auxctl_read.patch	2022-03-22 08:54:47.099464489 +0800
+++ b/target/linux/generic/backport-4.9/075-v4.10-0003-net-phy-broadcom-add-bcm54xx_auxctl_read.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,41 +0,0 @@
-From: Jon Mason <jon.mason@broadcom.com>
-Date: Fri, 4 Nov 2016 01:10:56 -0400
-Subject: [PATCH] net: phy: broadcom: add bcm54xx_auxctl_read
-
-Add a helper function to read the AUXCTL register for the BCM54xx.  This
-mirrors the bcm54xx_auxctl_write function already present in the code.
-
-Signed-off-by: Jon Mason <jon.mason@broadcom.com>
-Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/drivers/net/phy/broadcom.c
-+++ b/drivers/net/phy/broadcom.c
-@@ -30,6 +30,16 @@ MODULE_DESCRIPTION("Broadcom PHY driver"
- MODULE_AUTHOR("Maciej W. Rozycki");
- MODULE_LICENSE("GPL");
- 
-+static int bcm54xx_auxctl_read(struct phy_device *phydev, u16 regnum)
-+{
-+	/* The register must be written to both the Shadow Register Select and
-+	 * the Shadow Read Register Selector
-+	 */
-+	phy_write(phydev, MII_BCM54XX_AUX_CTL, regnum |
-+		  regnum << MII_BCM54XX_AUXCTL_SHDWSEL_READ_SHIFT);
-+	return phy_read(phydev, MII_BCM54XX_AUX_CTL);
-+}
-+
- static int bcm54xx_auxctl_write(struct phy_device *phydev, u16 regnum, u16 val)
- {
- 	return phy_write(phydev, MII_BCM54XX_AUX_CTL, regnum | val);
---- a/include/linux/brcmphy.h
-+++ b/include/linux/brcmphy.h
-@@ -110,6 +110,7 @@
- #define MII_BCM54XX_AUXCTL_MISC_FORCE_AMDIX	0x0200
- #define MII_BCM54XX_AUXCTL_MISC_RDSEL_MISC	0x7000
- #define MII_BCM54XX_AUXCTL_SHDWSEL_MISC	0x0007
-+#define MII_BCM54XX_AUXCTL_SHDWSEL_READ_SHIFT	12
- 
- #define MII_BCM54XX_AUXCTL_SHDWSEL_MASK	0x0007
- 
--- a/target/linux/generic/backport-4.9/075-v4.10-0004-net-phy-broadcom-Add-BCM54810-PHY-entry.patch	2022-03-22 08:54:47.099464489 +0800
+++ b/target/linux/generic/backport-4.9/075-v4.10-0004-net-phy-broadcom-Add-BCM54810-PHY-entry.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,176 +0,0 @@
-From: Jon Mason <jon.mason@broadcom.com>
-Date: Fri, 4 Nov 2016 01:10:58 -0400
-Subject: [PATCH] net: phy: broadcom: Add BCM54810 PHY entry
-
-The BCM54810 PHY requires some semi-unique configuration, which results
-in some additional configuration in addition to the standard config.
-Also, some users of the BCM54810 require the PHY lanes to be swapped.
-Since there is no way to detect this, add a device tree query to see if
-it is applicable.
-
-Inspired-by: Vikas Soni <vsoni@broadcom.com>
-Signed-off-by: Jon Mason <jon.mason@broadcom.com>
-Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
-Reviewed-by: Andrew Lunn <andrew@lunn.ch>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/drivers/net/phy/broadcom.c
-+++ b/drivers/net/phy/broadcom.c
-@@ -18,7 +18,7 @@
- #include <linux/module.h>
- #include <linux/phy.h>
- #include <linux/brcmphy.h>
--
-+#include <linux/of.h>
- 
- #define BRCM_PHY_MODEL(phydev) \
- 	((phydev)->drv->phy_id & (phydev)->drv->phy_id_mask)
-@@ -45,6 +45,34 @@ static int bcm54xx_auxctl_write(struct p
- 	return phy_write(phydev, MII_BCM54XX_AUX_CTL, regnum | val);
- }
- 
-+static int bcm54810_config(struct phy_device *phydev)
-+{
-+	int rc, val;
-+
-+	val = bcm_phy_read_exp(phydev, BCM54810_EXP_BROADREACH_LRE_MISC_CTL);
-+	val &= ~BCM54810_EXP_BROADREACH_LRE_MISC_CTL_EN;
-+	rc = bcm_phy_write_exp(phydev, BCM54810_EXP_BROADREACH_LRE_MISC_CTL,
-+			       val);
-+	if (rc < 0)
-+		return rc;
-+
-+	val = bcm54xx_auxctl_read(phydev, MII_BCM54XX_AUXCTL_SHDWSEL_MISC);
-+	val &= ~MII_BCM54XX_AUXCTL_SHDWSEL_MISC_RGMII_SKEW_EN;
-+	val |= MII_BCM54XX_AUXCTL_MISC_WREN;
-+	rc = bcm54xx_auxctl_write(phydev, MII_BCM54XX_AUXCTL_SHDWSEL_MISC,
-+				  val);
-+	if (rc < 0)
-+		return rc;
-+
-+	val = bcm_phy_read_shadow(phydev, BCM54810_SHD_CLK_CTL);
-+	val &= ~BCM54810_SHD_CLK_CTL_GTXCLK_EN;
-+	rc = bcm_phy_write_shadow(phydev, BCM54810_SHD_CLK_CTL, val);
-+	if (rc < 0)
-+		return rc;
-+
-+	return 0;
-+}
-+
- /* Needs SMDSP clock enabled via bcm54xx_phydsp_config() */
- static int bcm50610_a0_workaround(struct phy_device *phydev)
- {
-@@ -217,6 +245,12 @@ static int bcm54xx_config_init(struct ph
- 	    (phydev->dev_flags & PHY_BRCM_AUTO_PWRDWN_ENABLE))
- 		bcm54xx_adjust_rxrefclk(phydev);
- 
-+	if (BRCM_PHY_MODEL(phydev) == PHY_ID_BCM54810) {
-+		err = bcm54810_config(phydev);
-+		if (err)
-+			return err;
-+	}
-+
- 	bcm54xx_phydsp_config(phydev);
- 
- 	return 0;
-@@ -314,6 +348,7 @@ static int bcm5482_read_status(struct ph
- 
- static int bcm5481_config_aneg(struct phy_device *phydev)
- {
-+	struct device_node *np = phydev->mdio.dev.of_node;
- 	int ret;
- 
- 	/* Aneg firsly. */
-@@ -344,6 +379,14 @@ static int bcm5481_config_aneg(struct ph
- 		phy_write(phydev, 0x18, reg);
- 	}
- 
-+	if (of_property_read_bool(np, "enet-phy-lane-swap")) {
-+		/* Lane Swap - Undocumented register...magic! */
-+		ret = bcm_phy_write_exp(phydev, MII_BCM54XX_EXP_SEL_ER + 0x9,
-+					0x11B);
-+		if (ret < 0)
-+			return ret;
-+	}
-+
- 	return ret;
- }
- 
-@@ -578,6 +621,18 @@ static struct phy_driver broadcom_driver
- 	.ack_interrupt	= bcm_phy_ack_intr,
- 	.config_intr	= bcm_phy_config_intr,
- }, {
-+	.phy_id         = PHY_ID_BCM54810,
-+	.phy_id_mask    = 0xfffffff0,
-+	.name           = "Broadcom BCM54810",
-+	.features       = PHY_GBIT_FEATURES |
-+			  SUPPORTED_Pause | SUPPORTED_Asym_Pause,
-+	.flags          = PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
-+	.config_init    = bcm54xx_config_init,
-+	.config_aneg    = bcm5481_config_aneg,
-+	.read_status    = genphy_read_status,
-+	.ack_interrupt  = bcm_phy_ack_intr,
-+	.config_intr    = bcm_phy_config_intr,
-+}, {
- 	.phy_id		= PHY_ID_BCM5482,
- 	.phy_id_mask	= 0xfffffff0,
- 	.name		= "Broadcom BCM5482",
-@@ -661,6 +716,7 @@ static struct mdio_device_id __maybe_unu
- 	{ PHY_ID_BCM54616S, 0xfffffff0 },
- 	{ PHY_ID_BCM5464, 0xfffffff0 },
- 	{ PHY_ID_BCM5481, 0xfffffff0 },
-+	{ PHY_ID_BCM54810, 0xfffffff0 },
- 	{ PHY_ID_BCM5482, 0xfffffff0 },
- 	{ PHY_ID_BCM50610, 0xfffffff0 },
- 	{ PHY_ID_BCM50610M, 0xfffffff0 },
---- a/drivers/net/phy/Kconfig
-+++ b/drivers/net/phy/Kconfig
-@@ -204,7 +204,7 @@ config BROADCOM_PHY
- 	select BCM_NET_PHYLIB
- 	---help---
- 	  Currently supports the BCM5411, BCM5421, BCM5461, BCM54616S, BCM5464,
--	  BCM5481 and BCM5482 PHYs.
-+	  BCM5481, BCM54810 and BCM5482 PHYs.
- 
- config CICADA_PHY
- 	tristate "Cicada PHYs"
---- a/include/linux/brcmphy.h
-+++ b/include/linux/brcmphy.h
-@@ -13,6 +13,7 @@
- #define PHY_ID_BCM5241			0x0143bc30
- #define PHY_ID_BCMAC131			0x0143bc70
- #define PHY_ID_BCM5481			0x0143bca0
-+#define PHY_ID_BCM54810			0x03625d00
- #define PHY_ID_BCM5482			0x0143bcb0
- #define PHY_ID_BCM5411			0x00206070
- #define PHY_ID_BCM5421			0x002060e0
-@@ -56,6 +57,7 @@
- #define PHY_BRCM_EXT_IBND_TX_ENABLE	0x00002000
- #define PHY_BRCM_CLEAR_RGMII_MODE	0x00004000
- #define PHY_BRCM_DIS_TXCRXC_NOENRGY	0x00008000
-+
- /* Broadcom BCM7xxx specific workarounds */
- #define PHY_BRCM_7XXX_REV(x)		(((x) >> 8) & 0xff)
- #define PHY_BRCM_7XXX_PATCH(x)		((x) & 0xff)
-@@ -111,6 +113,7 @@
- #define MII_BCM54XX_AUXCTL_MISC_RDSEL_MISC	0x7000
- #define MII_BCM54XX_AUXCTL_SHDWSEL_MISC	0x0007
- #define MII_BCM54XX_AUXCTL_SHDWSEL_READ_SHIFT	12
-+#define MII_BCM54XX_AUXCTL_SHDWSEL_MISC_RGMII_SKEW_EN	(1 << 8)
- 
- #define MII_BCM54XX_AUXCTL_SHDWSEL_MASK	0x0007
- 
-@@ -192,6 +195,12 @@
- #define BCM5482_SSD_SGMII_SLAVE_EN	0x0002	/* Slave mode enable */
- #define BCM5482_SSD_SGMII_SLAVE_AD	0x0001	/* Slave auto-detection */
- 
-+/* BCM54810 Registers */
-+#define BCM54810_EXP_BROADREACH_LRE_MISC_CTL	(MII_BCM54XX_EXP_SEL_ER + 0x90)
-+#define BCM54810_EXP_BROADREACH_LRE_MISC_CTL_EN	(1 << 0)
-+#define BCM54810_SHD_CLK_CTL			0x3
-+#define BCM54810_SHD_CLK_CTL_GTXCLK_EN		(1 << 9)
-+
- 
- /*****************************************************************************/
- /* Fast Ethernet Transceiver definitions. */
--- a/target/linux/generic/backport-4.9/075-v4.10-0005-net-phy-broadcom-Move-bcm54xx_auxctl_-read-write-to-.patch	2022-03-22 08:54:47.099464489 +0800
+++ b/target/linux/generic/backport-4.9/075-v4.10-0005-net-phy-broadcom-Move-bcm54xx_auxctl_-read-write-to-.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,74 +0,0 @@
-From: Florian Fainelli <f.fainelli@gmail.com>
-Date: Tue, 22 Nov 2016 11:40:54 -0800
-Subject: [PATCH] net: phy: broadcom: Move bcm54xx_auxctl_{read, write} to
- common library
-
-We are going to need these functions to implement support for Broadcom
-Wirespeed, aka downshift.
-
-Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/drivers/net/phy/bcm-phy-lib.c
-+++ b/drivers/net/phy/bcm-phy-lib.c
-@@ -50,6 +50,23 @@ int bcm_phy_read_exp(struct phy_device *
- }
- EXPORT_SYMBOL_GPL(bcm_phy_read_exp);
- 
-+int bcm54xx_auxctl_read(struct phy_device *phydev, u16 regnum)
-+{
-+	/* The register must be written to both the Shadow Register Select and
-+	 * the Shadow Read Register Selector
-+	 */
-+	phy_write(phydev, MII_BCM54XX_AUX_CTL, regnum |
-+		  regnum << MII_BCM54XX_AUXCTL_SHDWSEL_READ_SHIFT);
-+	return phy_read(phydev, MII_BCM54XX_AUX_CTL);
-+}
-+EXPORT_SYMBOL_GPL(bcm54xx_auxctl_read);
-+
-+int bcm54xx_auxctl_write(struct phy_device *phydev, u16 regnum, u16 val)
-+{
-+	return phy_write(phydev, MII_BCM54XX_AUX_CTL, regnum | val);
-+}
-+EXPORT_SYMBOL(bcm54xx_auxctl_write);
-+
- int bcm_phy_write_misc(struct phy_device *phydev,
- 		       u16 reg, u16 chl, u16 val)
- {
---- a/drivers/net/phy/bcm-phy-lib.h
-+++ b/drivers/net/phy/bcm-phy-lib.h
-@@ -26,6 +26,9 @@ static inline int bcm_phy_write_exp_sel(
- 	return bcm_phy_write_exp(phydev, reg | MII_BCM54XX_EXP_SEL_ER, val);
- }
- 
-+int bcm54xx_auxctl_write(struct phy_device *phydev, u16 regnum, u16 val);
-+int bcm54xx_auxctl_read(struct phy_device *phydev, u16 regnum);
-+
- int bcm_phy_write_misc(struct phy_device *phydev,
- 		       u16 reg, u16 chl, u16 value);
- int bcm_phy_read_misc(struct phy_device *phydev,
---- a/drivers/net/phy/broadcom.c
-+++ b/drivers/net/phy/broadcom.c
-@@ -30,21 +30,6 @@ MODULE_DESCRIPTION("Broadcom PHY driver"
- MODULE_AUTHOR("Maciej W. Rozycki");
- MODULE_LICENSE("GPL");
- 
--static int bcm54xx_auxctl_read(struct phy_device *phydev, u16 regnum)
--{
--	/* The register must be written to both the Shadow Register Select and
--	 * the Shadow Read Register Selector
--	 */
--	phy_write(phydev, MII_BCM54XX_AUX_CTL, regnum |
--		  regnum << MII_BCM54XX_AUXCTL_SHDWSEL_READ_SHIFT);
--	return phy_read(phydev, MII_BCM54XX_AUX_CTL);
--}
--
--static int bcm54xx_auxctl_write(struct phy_device *phydev, u16 regnum, u16 val)
--{
--	return phy_write(phydev, MII_BCM54XX_AUX_CTL, regnum | val);
--}
--
- static int bcm54810_config(struct phy_device *phydev)
- {
- 	int rc, val;
--- a/target/linux/generic/backport-4.9/076-v4.11-0001-net-phy-broadcom-Allow-enabling-or-disabling-of-EEE.patch	2022-03-22 08:54:47.100464491 +0800
+++ b/target/linux/generic/backport-4.9/076-v4.11-0001-net-phy-broadcom-Allow-enabling-or-disabling-of-EEE.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,87 +0,0 @@
-From: Florian Fainelli <f.fainelli@gmail.com>
-Date: Tue, 22 Nov 2016 11:40:56 -0800
-Subject: [PATCH] net: phy: broadcom: Allow enabling or disabling of EEE
-
-In preparation for adding support for Wirespeed/downshift, we need to
-change bcm_phy_eee_enable() to allow enabling or disabling EEE, so make
-the function take an extra enable/disable boolean parameter and rename
-it to illustrate it sets EEE, not necessarily just enables it.
-
-Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/drivers/net/phy/bcm7xxx.c
-+++ b/drivers/net/phy/bcm7xxx.c
-@@ -199,7 +199,7 @@ static int bcm7xxx_28nm_config_init(stru
- 	if (ret)
- 		return ret;
- 
--	ret = bcm_phy_enable_eee(phydev);
-+	ret = bcm_phy_set_eee(phydev, true);
- 	if (ret)
- 		return ret;
- 
---- a/drivers/net/phy/bcm-cygnus.c
-+++ b/drivers/net/phy/bcm-cygnus.c
-@@ -104,7 +104,7 @@ static int bcm_cygnus_config_init(struct
- 		return rc;
- 
- 	/* Advertise EEE */
--	rc = bcm_phy_enable_eee(phydev);
-+	rc = bcm_phy_set_eee(phydev, true);
- 	if (rc)
- 		return rc;
- 
---- a/drivers/net/phy/bcm-phy-lib.c
-+++ b/drivers/net/phy/bcm-phy-lib.c
-@@ -195,7 +195,7 @@ int bcm_phy_enable_apd(struct phy_device
- }
- EXPORT_SYMBOL_GPL(bcm_phy_enable_apd);
- 
--int bcm_phy_enable_eee(struct phy_device *phydev)
-+int bcm_phy_set_eee(struct phy_device *phydev, bool enable)
- {
- 	int val;
- 
-@@ -205,7 +205,10 @@ int bcm_phy_enable_eee(struct phy_device
- 	if (val < 0)
- 		return val;
- 
--	val |= LPI_FEATURE_EN | LPI_FEATURE_EN_DIG1000X;
-+	if (enable)
-+		val |= LPI_FEATURE_EN | LPI_FEATURE_EN_DIG1000X;
-+	else
-+		val &= ~(LPI_FEATURE_EN | LPI_FEATURE_EN_DIG1000X);
- 
- 	phy_write_mmd_indirect(phydev, BRCM_CL45VEN_EEE_CONTROL,
- 			       MDIO_MMD_AN, (u32)val);
-@@ -216,14 +219,17 @@ int bcm_phy_enable_eee(struct phy_device
- 	if (val < 0)
- 		return val;
- 
--	val |= (MDIO_AN_EEE_ADV_100TX | MDIO_AN_EEE_ADV_1000T);
-+	if (enable)
-+		val |= (MDIO_AN_EEE_ADV_100TX | MDIO_AN_EEE_ADV_1000T);
-+	else
-+		val &= ~(MDIO_AN_EEE_ADV_100TX | MDIO_AN_EEE_ADV_1000T);
- 
- 	phy_write_mmd_indirect(phydev, BCM_CL45VEN_EEE_ADV,
- 			       MDIO_MMD_AN, (u32)val);
- 
- 	return 0;
- }
--EXPORT_SYMBOL_GPL(bcm_phy_enable_eee);
-+EXPORT_SYMBOL_GPL(bcm_phy_set_eee);
- 
- MODULE_DESCRIPTION("Broadcom PHY Library");
- MODULE_LICENSE("GPL v2");
---- a/drivers/net/phy/bcm-phy-lib.h
-+++ b/drivers/net/phy/bcm-phy-lib.h
-@@ -43,5 +43,5 @@ int bcm_phy_config_intr(struct phy_devic
- 
- int bcm_phy_enable_apd(struct phy_device *phydev, bool dll_pwr_down);
- 
--int bcm_phy_enable_eee(struct phy_device *phydev);
-+int bcm_phy_set_eee(struct phy_device *phydev, bool enable);
- #endif /* _LINUX_BCM_PHY_LIB_H */
--- a/target/linux/generic/backport-4.9/076-v4.11-0002-net-phy-broadcom-Add-support-code-for-reading-PHY-co.patch	2022-03-22 08:54:47.100464491 +0800
+++ b/target/linux/generic/backport-4.9/076-v4.11-0002-net-phy-broadcom-Add-support-code-for-reading-PHY-co.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,125 +0,0 @@
-From: Florian Fainelli <f.fainelli@gmail.com>
-Date: Tue, 29 Nov 2016 09:57:17 -0800
-Subject: [PATCH] net: phy: broadcom: Add support code for reading PHY counters
-
-Broadcom PHYs expose a number of PHY error counters: receive errors,
-false carrier sense, SerDes BER count, local and remote receive errors.
-Add support code to allow retrieving these error counters. Since the
-Broadcom PHY library code is used by several drivers, make it possible
-for them to specify the storage for the software copy of the statistics.
-
-Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/drivers/net/phy/bcm-phy-lib.c
-+++ b/drivers/net/phy/bcm-phy-lib.c
-@@ -17,6 +17,7 @@
- #include <linux/mdio.h>
- #include <linux/module.h>
- #include <linux/phy.h>
-+#include <linux/ethtool.h>
- 
- #define MII_BCM_CHANNEL_WIDTH     0x2000
- #define BCM_CL45VEN_EEE_ADV       0x3c
-@@ -231,6 +232,75 @@ int bcm_phy_set_eee(struct phy_device *p
- }
- EXPORT_SYMBOL_GPL(bcm_phy_set_eee);
- 
-+struct bcm_phy_hw_stat {
-+	const char *string;
-+	u8 reg;
-+	u8 shift;
-+	u8 bits;
-+};
-+
-+/* Counters freeze at either 0xffff or 0xff, better than nothing */
-+static const struct bcm_phy_hw_stat bcm_phy_hw_stats[] = {
-+	{ "phy_receive_errors", MII_BRCM_CORE_BASE12, 0, 16 },
-+	{ "phy_serdes_ber_errors", MII_BRCM_CORE_BASE13, 8, 8 },
-+	{ "phy_false_carrier_sense_errors", MII_BRCM_CORE_BASE13, 0, 8 },
-+	{ "phy_local_rcvr_nok", MII_BRCM_CORE_BASE14, 8, 8 },
-+	{ "phy_remote_rcv_nok", MII_BRCM_CORE_BASE14, 0, 8 },
-+};
-+
-+int bcm_phy_get_sset_count(struct phy_device *phydev)
-+{
-+	return ARRAY_SIZE(bcm_phy_hw_stats);
-+}
-+EXPORT_SYMBOL_GPL(bcm_phy_get_sset_count);
-+
-+void bcm_phy_get_strings(struct phy_device *phydev, u8 *data)
-+{
-+	unsigned int i;
-+
-+	for (i = 0; i < ARRAY_SIZE(bcm_phy_hw_stats); i++)
-+		memcpy(data + i * ETH_GSTRING_LEN,
-+		       bcm_phy_hw_stats[i].string, ETH_GSTRING_LEN);
-+}
-+EXPORT_SYMBOL_GPL(bcm_phy_get_strings);
-+
-+#ifndef UINT64_MAX
-+#define UINT64_MAX              (u64)(~((u64)0))
-+#endif
-+
-+/* Caller is supposed to provide appropriate storage for the library code to
-+ * access the shadow copy
-+ */
-+static u64 bcm_phy_get_stat(struct phy_device *phydev, u64 *shadow,
-+			    unsigned int i)
-+{
-+	struct bcm_phy_hw_stat stat = bcm_phy_hw_stats[i];
-+	int val;
-+	u64 ret;
-+
-+	val = phy_read(phydev, stat.reg);
-+	if (val < 0) {
-+		ret = UINT64_MAX;
-+	} else {
-+		val >>= stat.shift;
-+		val = val & ((1 << stat.bits) - 1);
-+		shadow[i] += val;
-+		ret = shadow[i];
-+	}
-+
-+	return ret;
-+}
-+
-+void bcm_phy_get_stats(struct phy_device *phydev, u64 *shadow,
-+		       struct ethtool_stats *stats, u64 *data)
-+{
-+	unsigned int i;
-+
-+	for (i = 0; i < ARRAY_SIZE(bcm_phy_hw_stats); i++)
-+		data[i] = bcm_phy_get_stat(phydev, shadow, i);
-+}
-+EXPORT_SYMBOL_GPL(bcm_phy_get_stats);
-+
- MODULE_DESCRIPTION("Broadcom PHY Library");
- MODULE_LICENSE("GPL v2");
- MODULE_AUTHOR("Broadcom Corporation");
---- a/drivers/net/phy/bcm-phy-lib.h
-+++ b/drivers/net/phy/bcm-phy-lib.h
-@@ -44,4 +44,10 @@ int bcm_phy_config_intr(struct phy_devic
- int bcm_phy_enable_apd(struct phy_device *phydev, bool dll_pwr_down);
- 
- int bcm_phy_set_eee(struct phy_device *phydev, bool enable);
-+
-+int bcm_phy_get_sset_count(struct phy_device *phydev);
-+void bcm_phy_get_strings(struct phy_device *phydev, u8 *data);
-+void bcm_phy_get_stats(struct phy_device *phydev, u64 *shadow,
-+		       struct ethtool_stats *stats, u64 *data);
-+
- #endif /* _LINUX_BCM_PHY_LIB_H */
---- a/include/linux/brcmphy.h
-+++ b/include/linux/brcmphy.h
-@@ -234,6 +234,9 @@
- #define LPI_FEATURE_EN_DIG1000X		0x4000
- 
- /* Core register definitions*/
-+#define MII_BRCM_CORE_BASE12	0x12
-+#define MII_BRCM_CORE_BASE13	0x13
-+#define MII_BRCM_CORE_BASE14	0x14
- #define MII_BRCM_CORE_BASE1E	0x1E
- #define MII_BRCM_CORE_EXPB0	0xB0
- #define MII_BRCM_CORE_EXPB1	0xB1
--- a/target/linux/generic/backport-4.9/076-v4.11-0003-net-phy-bcm7xxx-Add-entry-for-BCM7278.patch	2022-03-22 08:54:47.100464491 +0800
+++ b/target/linux/generic/backport-4.9/076-v4.11-0003-net-phy-bcm7xxx-Add-entry-for-BCM7278.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,38 +0,0 @@
-From: Florian Fainelli <f.fainelli@gmail.com>
-Date: Fri, 20 Jan 2017 12:36:33 -0800
-Subject: [PATCH] net: phy: bcm7xxx: Add entry for BCM7278
-
-Add support for the BCM7278 28nm process Gigabit Ethernet PHY.
-
-Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/drivers/net/phy/bcm7xxx.c
-+++ b/drivers/net/phy/bcm7xxx.c
-@@ -334,6 +334,7 @@ static int bcm7xxx_suspend(struct phy_de
- 
- static struct phy_driver bcm7xxx_driver[] = {
- 	BCM7XXX_28NM_GPHY(PHY_ID_BCM7250, "Broadcom BCM7250"),
-+	BCM7XXX_28NM_GPHY(PHY_ID_BCM7278, "Broadcom BCM7278"),
- 	BCM7XXX_28NM_GPHY(PHY_ID_BCM7364, "Broadcom BCM7364"),
- 	BCM7XXX_28NM_GPHY(PHY_ID_BCM7366, "Broadcom BCM7366"),
- 	BCM7XXX_28NM_GPHY(PHY_ID_BCM7439, "Broadcom BCM7439"),
-@@ -348,6 +349,7 @@ static struct phy_driver bcm7xxx_driver[
- 
- static struct mdio_device_id __maybe_unused bcm7xxx_tbl[] = {
- 	{ PHY_ID_BCM7250, 0xfffffff0, },
-+	{ PHY_ID_BCM7278, 0xfffffff0, },
- 	{ PHY_ID_BCM7364, 0xfffffff0, },
- 	{ PHY_ID_BCM7366, 0xfffffff0, },
- 	{ PHY_ID_BCM7346, 0xfffffff0, },
---- a/include/linux/brcmphy.h
-+++ b/include/linux/brcmphy.h
-@@ -24,6 +24,7 @@
- #define PHY_ID_BCM57780			0x03625d90
- 
- #define PHY_ID_BCM7250			0xae025280
-+#define PHY_ID_BCM7278			0xae0251a0
- #define PHY_ID_BCM7364			0xae025260
- #define PHY_ID_BCM7366			0x600d8490
- #define PHY_ID_BCM7346			0x600d8650
--- a/target/linux/generic/backport-4.9/076-v4.11-0004-net-phy-bcm7xxx-Implement-EGPHY-workaround-for-7278.patch	2022-03-22 08:54:47.101464493 +0800
+++ b/target/linux/generic/backport-4.9/076-v4.11-0004-net-phy-bcm7xxx-Implement-EGPHY-workaround-for-7278.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,68 +0,0 @@
-From: Florian Fainelli <f.fainelli@gmail.com>
-Date: Fri, 20 Jan 2017 12:36:34 -0800
-Subject: [PATCH] net: phy: bcm7xxx: Implement EGPHY workaround for 7278
-
-Implement the HW design team recommended workaround in for 7278. Since
-the GPHY now returns its revision information in MII_PHYS_ID[23] we need
-to check whether the revision provided in flags is 0 or not.
-
-Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/drivers/net/phy/bcm7xxx.c
-+++ b/drivers/net/phy/bcm7xxx.c
-@@ -163,12 +163,43 @@ static int bcm7xxx_28nm_e0_plus_afe_conf
- 	return 0;
- }
- 
-+static int bcm7xxx_28nm_a0_patch_afe_config_init(struct phy_device *phydev)
-+{
-+	/* +1 RC_CAL codes for RL centering for both LT and HT conditions */
-+	bcm_phy_write_misc(phydev, AFE_RXCONFIG_2, 0xd003);
-+
-+	/* Cut master bias current by 2% to compensate for RC_CAL offset */
-+	bcm_phy_write_misc(phydev, DSP_TAP10, 0x791b);
-+
-+	/* Improve hybrid leakage */
-+	bcm_phy_write_misc(phydev, AFE_HPF_TRIM_OTHERS, 0x10e3);
-+
-+	/* Change rx_on_tune 8 to 0xf */
-+	bcm_phy_write_misc(phydev, 0x21, 0x2, 0x87f6);
-+
-+	/* Change 100Tx EEE bandwidth */
-+	bcm_phy_write_misc(phydev, 0x22, 0x2, 0x017d);
-+
-+	/* Enable ffe zero detection for Vitesse interoperability */
-+	bcm_phy_write_misc(phydev, 0x26, 0x2, 0x0015);
-+
-+	r_rc_cal_reset(phydev);
-+
-+	return 0;
-+}
-+
- static int bcm7xxx_28nm_config_init(struct phy_device *phydev)
- {
- 	u8 rev = PHY_BRCM_7XXX_REV(phydev->dev_flags);
- 	u8 patch = PHY_BRCM_7XXX_PATCH(phydev->dev_flags);
- 	int ret = 0;
- 
-+	/* Newer devices have moved the revision information back into a
-+	 * standard location in MII_PHYS_ID[23]
-+	 */
-+	if (rev == 0)
-+		rev = phydev->phy_id & ~phydev->drv->phy_id_mask;
-+
- 	pr_info_once("%s: %s PHY revision: 0x%02x, patch: %d\n",
- 		     phydev_name(phydev), phydev->drv->name, rev, patch);
- 
-@@ -192,6 +223,9 @@ static int bcm7xxx_28nm_config_init(stru
- 	case 0x10:
- 		ret = bcm7xxx_28nm_e0_plus_afe_config_init(phydev);
- 		break;
-+	case 0x01:
-+		ret = bcm7xxx_28nm_a0_patch_afe_config_init(phydev);
-+		break;
- 	default:
- 		break;
- 	}
--- a/target/linux/generic/backport-4.9/076-v4.11-0005-net-phy-broadcom-use-auxctl-reading-helper-in-BCM546.patch	2022-03-22 08:54:47.101464493 +0800
+++ b/target/linux/generic/backport-4.9/076-v4.11-0005-net-phy-broadcom-use-auxctl-reading-helper-in-BCM546.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,45 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Wed, 25 Jan 2017 21:00:25 +0100
-Subject: [PATCH] net: phy: broadcom: use auxctl reading helper in BCM54612E
- code
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Starting with commit 5b4e29005123 ("net: phy: broadcom: add
-bcm54xx_auxctl_read") we have a reading helper so use it and avoid code
-duplication.
-It also means we don't need MII_BCM54XX_AUXCTL_SHDWSEL_MISC define as
-it's the same as MII_BCM54XX_AUXCTL_SHDWSEL_MISC just for reading needs
-(same value shifted by 12 bits).
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/drivers/net/phy/broadcom.c
-+++ b/drivers/net/phy/broadcom.c
-@@ -395,10 +395,8 @@ static int bcm54612e_config_aneg(struct
- 	    (phydev->interface != PHY_INTERFACE_MODE_RGMII_RXID)) {
- 		u16 reg;
- 
--		/* Errata: reads require filling in the write selector field */
--		bcm54xx_auxctl_write(phydev, MII_BCM54XX_AUXCTL_SHDWSEL_MISC,
--				     MII_BCM54XX_AUXCTL_MISC_RDSEL_MISC);
--		reg = phy_read(phydev, MII_BCM54XX_AUX_CTL);
-+		reg = bcm54xx_auxctl_read(phydev,
-+					  MII_BCM54XX_AUXCTL_SHDWSEL_MISC);
- 		/* Disable RXD to RXC delay (default set) */
- 		reg &= ~MII_BCM54XX_AUXCTL_MISC_RXD_RXC_SKEW;
- 		/* Clear shadow selector field */
---- a/include/linux/brcmphy.h
-+++ b/include/linux/brcmphy.h
-@@ -111,7 +111,6 @@
- 
- #define MII_BCM54XX_AUXCTL_MISC_WREN	0x8000
- #define MII_BCM54XX_AUXCTL_MISC_FORCE_AMDIX	0x0200
--#define MII_BCM54XX_AUXCTL_MISC_RDSEL_MISC	0x7000
- #define MII_BCM54XX_AUXCTL_SHDWSEL_MISC	0x0007
- #define MII_BCM54XX_AUXCTL_SHDWSEL_READ_SHIFT	12
- #define MII_BCM54XX_AUXCTL_SHDWSEL_MISC_RGMII_SKEW_EN	(1 << 8)
--- a/target/linux/generic/backport-4.9/076-v4.11-0006-net-phy-broadcom-add-support-for-BCM54210E.patch	2022-03-22 08:54:47.101464493 +0800
+++ b/target/linux/generic/backport-4.9/076-v4.11-0006-net-phy-broadcom-add-support-for-BCM54210E.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,89 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Fri, 27 Jan 2017 14:07:01 +0100
-Subject: [PATCH] net: phy: broadcom: add support for BCM54210E
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-It's Broadcom PHY simply described as single-port
-RGMII 10/100/1000BASE-T PHY. It requires disabling delay skew and GTXCLK
-bits.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/drivers/net/phy/broadcom.c
-+++ b/drivers/net/phy/broadcom.c
-@@ -30,6 +30,22 @@ MODULE_DESCRIPTION("Broadcom PHY driver"
- MODULE_AUTHOR("Maciej W. Rozycki");
- MODULE_LICENSE("GPL");
- 
-+static int bcm54210e_config_init(struct phy_device *phydev)
-+{
-+	int val;
-+
-+	val = bcm54xx_auxctl_read(phydev, MII_BCM54XX_AUXCTL_SHDWSEL_MISC);
-+	val &= ~MII_BCM54XX_AUXCTL_SHDWSEL_MISC_RGMII_SKEW_EN;
-+	val |= MII_BCM54XX_AUXCTL_MISC_WREN;
-+	bcm54xx_auxctl_write(phydev, MII_BCM54XX_AUXCTL_SHDWSEL_MISC, val);
-+
-+	val = bcm_phy_read_shadow(phydev, BCM54810_SHD_CLK_CTL);
-+	val &= ~BCM54810_SHD_CLK_CTL_GTXCLK_EN;
-+	bcm_phy_write_shadow(phydev, BCM54810_SHD_CLK_CTL, val);
-+
-+	return 0;
-+}
-+
- static int bcm54810_config(struct phy_device *phydev)
- {
- 	int rc, val;
-@@ -230,7 +246,11 @@ static int bcm54xx_config_init(struct ph
- 	    (phydev->dev_flags & PHY_BRCM_AUTO_PWRDWN_ENABLE))
- 		bcm54xx_adjust_rxrefclk(phydev);
- 
--	if (BRCM_PHY_MODEL(phydev) == PHY_ID_BCM54810) {
-+	if (BRCM_PHY_MODEL(phydev) == PHY_ID_BCM54210E) {
-+		err = bcm54210e_config_init(phydev);
-+		if (err)
-+			return err;
-+	} else if (BRCM_PHY_MODEL(phydev) == PHY_ID_BCM54810) {
- 		err = bcm54810_config(phydev);
- 		if (err)
- 			return err;
-@@ -544,6 +564,17 @@ static struct phy_driver broadcom_driver
- 	.ack_interrupt	= bcm_phy_ack_intr,
- 	.config_intr	= bcm_phy_config_intr,
- }, {
-+	.phy_id		= PHY_ID_BCM54210E,
-+	.phy_id_mask	= 0xfffffff0,
-+	.name		= "Broadcom BCM54210E",
-+	.features	= PHY_GBIT_FEATURES,
-+	.flags		= PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
-+	.config_init	= bcm54xx_config_init,
-+	.config_aneg	= genphy_config_aneg,
-+	.read_status	= genphy_read_status,
-+	.ack_interrupt	= bcm_phy_ack_intr,
-+	.config_intr	= bcm_phy_config_intr,
-+}, {
- 	.phy_id		= PHY_ID_BCM5461,
- 	.phy_id_mask	= 0xfffffff0,
- 	.name		= "Broadcom BCM5461",
-@@ -694,6 +725,7 @@ module_phy_driver(broadcom_drivers);
- static struct mdio_device_id __maybe_unused broadcom_tbl[] = {
- 	{ PHY_ID_BCM5411, 0xfffffff0 },
- 	{ PHY_ID_BCM5421, 0xfffffff0 },
-+	{ PHY_ID_BCM54210E, 0xfffffff0 },
- 	{ PHY_ID_BCM5461, 0xfffffff0 },
- 	{ PHY_ID_BCM54612E, 0xfffffff0 },
- 	{ PHY_ID_BCM54616S, 0xfffffff0 },
---- a/include/linux/brcmphy.h
-+++ b/include/linux/brcmphy.h
-@@ -17,6 +17,7 @@
- #define PHY_ID_BCM5482			0x0143bcb0
- #define PHY_ID_BCM5411			0x00206070
- #define PHY_ID_BCM5421			0x002060e0
-+#define PHY_ID_BCM54210E		0x600d84a0
- #define PHY_ID_BCM5464			0x002060b0
- #define PHY_ID_BCM5461			0x002060c0
- #define PHY_ID_BCM54612E		0x03625e60
--- a/target/linux/generic/backport-4.9/076-v4.11-0007-net-phy-broadcom-rehook-BCM54612E-specific-init.patch	2022-03-22 08:54:47.102464494 +0800
+++ b/target/linux/generic/backport-4.9/076-v4.11-0007-net-phy-broadcom-rehook-BCM54612E-specific-init.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,121 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Tue, 31 Jan 2017 22:54:54 +0100
-Subject: [PATCH] net: phy: broadcom: rehook BCM54612E specific init
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-This extra BCM54612E code in PHY driver isn't really aneg specific. Even
-without it aneg works OK but the problem is no packets pass through PHY.
-
-Moreover putting this code inside config_aneg callback didn't allow
-resuming PHY correctly. When driver called phy_stop and phy_start it was
-putting PHY machine into RESUMING state. After that machine was
-switching into AN and NOLINK without ever calling phy_start_aneg. This
-prevented this extra setup from being called and PHY didn't work.
-
-This change has been verified to fix network on BCM47186B0 SoC device
-with BCM54612E.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/drivers/net/phy/broadcom.c
-+++ b/drivers/net/phy/broadcom.c
-@@ -46,6 +46,34 @@ static int bcm54210e_config_init(struct
- 	return 0;
- }
- 
-+static int bcm54612e_config_init(struct phy_device *phydev)
-+{
-+	/* Clear TX internal delay unless requested. */
-+	if ((phydev->interface != PHY_INTERFACE_MODE_RGMII_ID) &&
-+	    (phydev->interface != PHY_INTERFACE_MODE_RGMII_TXID)) {
-+		/* Disable TXD to GTXCLK clock delay (default set) */
-+		/* Bit 9 is the only field in shadow register 00011 */
-+		bcm_phy_write_shadow(phydev, 0x03, 0);
-+	}
-+
-+	/* Clear RX internal delay unless requested. */
-+	if ((phydev->interface != PHY_INTERFACE_MODE_RGMII_ID) &&
-+	    (phydev->interface != PHY_INTERFACE_MODE_RGMII_RXID)) {
-+		u16 reg;
-+
-+		reg = bcm54xx_auxctl_read(phydev,
-+					  MII_BCM54XX_AUXCTL_SHDWSEL_MISC);
-+		/* Disable RXD to RXC delay (default set) */
-+		reg &= ~MII_BCM54XX_AUXCTL_SHDWSEL_MISC_RGMII_SKEW_EN;
-+		/* Clear shadow selector field */
-+		reg &= ~MII_BCM54XX_AUXCTL_SHDWSEL_MASK;
-+		bcm54xx_auxctl_write(phydev, MII_BCM54XX_AUXCTL_SHDWSEL_MISC,
-+				     MII_BCM54XX_AUXCTL_MISC_WREN | reg);
-+	}
-+
-+	return 0;
-+}
-+
- static int bcm54810_config(struct phy_device *phydev)
- {
- 	int rc, val;
-@@ -250,6 +278,10 @@ static int bcm54xx_config_init(struct ph
- 		err = bcm54210e_config_init(phydev);
- 		if (err)
- 			return err;
-+	} else if (BRCM_PHY_MODEL(phydev) == PHY_ID_BCM54612E) {
-+		err = bcm54612e_config_init(phydev);
-+		if (err)
-+			return err;
- 	} else if (BRCM_PHY_MODEL(phydev) == PHY_ID_BCM54810) {
- 		err = bcm54810_config(phydev);
- 		if (err)
-@@ -395,39 +427,6 @@ static int bcm5481_config_aneg(struct ph
- 	return ret;
- }
- 
--static int bcm54612e_config_aneg(struct phy_device *phydev)
--{
--	int ret;
--
--	/* First, auto-negotiate. */
--	ret = genphy_config_aneg(phydev);
--
--	/* Clear TX internal delay unless requested. */
--	if ((phydev->interface != PHY_INTERFACE_MODE_RGMII_ID) &&
--	    (phydev->interface != PHY_INTERFACE_MODE_RGMII_TXID)) {
--		/* Disable TXD to GTXCLK clock delay (default set) */
--		/* Bit 9 is the only field in shadow register 00011 */
--		bcm_phy_write_shadow(phydev, 0x03, 0);
--	}
--
--	/* Clear RX internal delay unless requested. */
--	if ((phydev->interface != PHY_INTERFACE_MODE_RGMII_ID) &&
--	    (phydev->interface != PHY_INTERFACE_MODE_RGMII_RXID)) {
--		u16 reg;
--
--		reg = bcm54xx_auxctl_read(phydev,
--					  MII_BCM54XX_AUXCTL_SHDWSEL_MISC);
--		/* Disable RXD to RXC delay (default set) */
--		reg &= ~MII_BCM54XX_AUXCTL_MISC_RXD_RXC_SKEW;
--		/* Clear shadow selector field */
--		reg &= ~MII_BCM54XX_AUXCTL_SHDWSEL_MASK;
--		bcm54xx_auxctl_write(phydev, MII_BCM54XX_AUXCTL_SHDWSEL_MISC,
--				     MII_BCM54XX_AUXCTL_MISC_WREN | reg);
--	}
--
--	return ret;
--}
--
- static int brcm_phy_setbits(struct phy_device *phydev, int reg, int set)
- {
- 	int val;
-@@ -594,7 +593,7 @@ static struct phy_driver broadcom_driver
- 			  SUPPORTED_Pause | SUPPORTED_Asym_Pause,
- 	.flags		= PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
- 	.config_init	= bcm54xx_config_init,
--	.config_aneg	= bcm54612e_config_aneg,
-+	.config_aneg	= genphy_config_aneg,
- 	.read_status	= genphy_read_status,
- 	.ack_interrupt	= bcm_phy_ack_intr,
- 	.config_intr	= bcm_phy_config_intr,
--- a/target/linux/generic/backport-4.9/076-v4.15-0001-net-phy-broadcom-support-new-device-flag-for-setting.patch	2022-03-22 08:54:47.102464494 +0800
+++ b/target/linux/generic/backport-4.9/076-v4.15-0001-net-phy-broadcom-support-new-device-flag-for-setting.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,54 +0,0 @@
-From 2355a6546a053b1c16ebefd6ce1f0cccc00e1da5 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Thu, 12 Oct 2017 10:21:25 +0200
-Subject: [PATCH] net: phy: broadcom: support new device flag for setting
- master mode
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Some of Broadcom's PHYs run by default in slave mode with Automatic
-Slave/Master configuration disabled. It stops them from working properly
-with some devices.
-
-So far it has been verified for BCM54210E and BCM50212E which don't
-work well with Intel's I217-LM and I218-LM:
-http://ark.intel.com/products/60019/Intel-Ethernet-Connection-I217-LM
-http://ark.intel.com/products/71307/Intel-Ethernet-Connection-I218-LM
-I was told there is massive ping loss.
-
-This commit adds support for a new flag which can be set by an ethernet
-driver to fixup PHY setup.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- drivers/net/phy/broadcom.c | 6 ++++++
- include/linux/brcmphy.h    | 1 +
- 2 files changed, 7 insertions(+)
-
---- a/drivers/net/phy/broadcom.c
-+++ b/drivers/net/phy/broadcom.c
-@@ -43,6 +43,12 @@ static int bcm54210e_config_init(struct
- 	val &= ~BCM54810_SHD_CLK_CTL_GTXCLK_EN;
- 	bcm_phy_write_shadow(phydev, BCM54810_SHD_CLK_CTL, val);
- 
-+	if (phydev->dev_flags & PHY_BRCM_EN_MASTER_MODE) {
-+		val = phy_read(phydev, MII_CTRL1000);
-+		val |= CTL1000_AS_MASTER | CTL1000_ENABLE_MASTER;
-+		phy_write(phydev, MII_CTRL1000, val);
-+	}
-+
- 	return 0;
- }
- 
---- a/include/linux/brcmphy.h
-+++ b/include/linux/brcmphy.h
-@@ -59,6 +59,7 @@
- #define PHY_BRCM_EXT_IBND_TX_ENABLE	0x00002000
- #define PHY_BRCM_CLEAR_RGMII_MODE	0x00004000
- #define PHY_BRCM_DIS_TXCRXC_NOENRGY	0x00008000
-+#define PHY_BRCM_EN_MASTER_MODE		0x00010000
- 
- /* Broadcom BCM7xxx specific workarounds */
- #define PHY_BRCM_7XXX_REV(x)		(((x) >> 8) & 0xff)
--- a/target/linux/generic/backport-4.9/080-0001-leds-core-add-OF-variants-of-LED-registering-functio.patch	2022-03-22 08:54:47.102464494 +0800
+++ b/target/linux/generic/backport-4.9/080-0001-leds-core-add-OF-variants-of-LED-registering-functio.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,120 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Mon, 6 Mar 2017 06:19:44 +0100
-Subject: [PATCH] leds: core: add OF variants of LED registering functions
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-These new functions allow passing an additional device_node argument
-that will be internally set for created LED device. Thanks to this LED
-core code and triggers will be able to access DT node for reading extra
-info.
-
-The easiest solution for achieving this was reworking old functions to
-more generic ones & adding simple defines for API compatibility.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Acked-by: Pavel Machek <pavel@ucw.cz>
-Signed-off-by: Jacek Anaszewski <jacek.anaszewski@gmail.com>
----
- drivers/leds/led-class.c | 26 ++++++++++++++++----------
- include/linux/leds.h     | 14 ++++++++++----
- 2 files changed, 26 insertions(+), 14 deletions(-)
-
---- a/drivers/leds/led-class.c
-+++ b/drivers/leds/led-class.c
-@@ -181,11 +181,14 @@ static int led_classdev_next_name(const
- }
- 
- /**
-- * led_classdev_register - register a new object of led_classdev class.
-- * @parent: The device to register.
-+ * of_led_classdev_register - register a new object of led_classdev class.
-+ *
-+ * @parent: parent of LED device
-  * @led_cdev: the led_classdev structure for this device.
-+ * @np: DT node describing this LED
-  */
--int led_classdev_register(struct device *parent, struct led_classdev *led_cdev)
-+int of_led_classdev_register(struct device *parent, struct device_node *np,
-+			    struct led_classdev *led_cdev)
- {
- 	char name[64];
- 	int ret;
-@@ -198,6 +201,7 @@ int led_classdev_register(struct device
- 				led_cdev, led_cdev->groups, "%s", name);
- 	if (IS_ERR(led_cdev->dev))
- 		return PTR_ERR(led_cdev->dev);
-+	led_cdev->dev->of_node = np;
- 
- 	if (ret)
- 		dev_warn(parent, "Led %s renamed to %s due to name collision",
-@@ -228,7 +232,7 @@ int led_classdev_register(struct device
- 
- 	return 0;
- }
--EXPORT_SYMBOL_GPL(led_classdev_register);
-+EXPORT_SYMBOL_GPL(of_led_classdev_register);
- 
- /**
-  * led_classdev_unregister - unregisters a object of led_properties class.
-@@ -270,12 +274,14 @@ static void devm_led_classdev_release(st
- }
- 
- /**
-- * devm_led_classdev_register - resource managed led_classdev_register()
-- * @parent: The device to register.
-+ * devm_of_led_classdev_register - resource managed led_classdev_register()
-+ *
-+ * @parent: parent of LED device
-  * @led_cdev: the led_classdev structure for this device.
-  */
--int devm_led_classdev_register(struct device *parent,
--			       struct led_classdev *led_cdev)
-+int devm_of_led_classdev_register(struct device *parent,
-+				  struct device_node *np,
-+				  struct led_classdev *led_cdev)
- {
- 	struct led_classdev **dr;
- 	int rc;
-@@ -284,7 +290,7 @@ int devm_led_classdev_register(struct de
- 	if (!dr)
- 		return -ENOMEM;
- 
--	rc = led_classdev_register(parent, led_cdev);
-+	rc = of_led_classdev_register(parent, np, led_cdev);
- 	if (rc) {
- 		devres_free(dr);
- 		return rc;
-@@ -295,7 +301,7 @@ int devm_led_classdev_register(struct de
- 
- 	return 0;
- }
--EXPORT_SYMBOL_GPL(devm_led_classdev_register);
-+EXPORT_SYMBOL_GPL(devm_of_led_classdev_register);
- 
- static int devm_led_classdev_match(struct device *dev, void *res, void *data)
- {
---- a/include/linux/leds.h
-+++ b/include/linux/leds.h
-@@ -109,10 +109,16 @@ struct led_classdev {
- 	struct mutex		led_access;
- };
- 
--extern int led_classdev_register(struct device *parent,
--				 struct led_classdev *led_cdev);
--extern int devm_led_classdev_register(struct device *parent,
--				      struct led_classdev *led_cdev);
-+extern int of_led_classdev_register(struct device *parent,
-+				    struct device_node *np,
-+				    struct led_classdev *led_cdev);
-+#define led_classdev_register(parent, led_cdev)				\
-+	of_led_classdev_register(parent, NULL, led_cdev)
-+extern int devm_of_led_classdev_register(struct device *parent,
-+					 struct device_node *np,
-+					 struct led_classdev *led_cdev);
-+#define devm_led_classdev_register(parent, led_cdev)			\
-+	devm_of_led_classdev_register(parent, NULL, led_cdev)
- extern void led_classdev_unregister(struct led_classdev *led_cdev);
- extern void devm_led_classdev_unregister(struct device *parent,
- 					 struct led_classdev *led_cdev);
--- a/target/linux/generic/backport-4.9/080-0002-leds-gpio-use-OF-variant-of-LED-registering-function.patch	2022-03-22 08:54:47.103464496 +0800
+++ b/target/linux/generic/backport-4.9/080-0002-leds-gpio-use-OF-variant-of-LED-registering-function.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,60 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Mon, 6 Mar 2017 06:19:45 +0100
-Subject: [PATCH] leds: gpio: use OF variant of LED registering function
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-In leds-gpio we support LEDs specified in DT so we should use
-(devm_)of_led_classdev_register. This allows passing DT node as argument
-for use by the LED subsystem.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Acked-by: Pavel Machek <pavel@ucw.cz>
-Signed-off-by: Jacek Anaszewski <jacek.anaszewski@gmail.com>
----
- drivers/leds/leds-gpio.c | 12 ++++++------
- 1 file changed, 6 insertions(+), 6 deletions(-)
-
---- a/drivers/leds/leds-gpio.c
-+++ b/drivers/leds/leds-gpio.c
-@@ -77,7 +77,7 @@ static int gpio_blink_set(struct led_cla
- 
- static int create_gpio_led(const struct gpio_led *template,
- 	struct gpio_led_data *led_dat, struct device *parent,
--	gpio_blink_set_t blink_set)
-+	struct device_node *np, gpio_blink_set_t blink_set)
- {
- 	int ret, state;
- 
-@@ -139,7 +139,7 @@ static int create_gpio_led(const struct
- 	if (ret < 0)
- 		return ret;
- 
--	return devm_led_classdev_register(parent, &led_dat->cdev);
-+	return devm_of_led_classdev_register(parent, np, &led_dat->cdev);
- }
- 
- struct gpio_leds_priv {
-@@ -206,7 +206,7 @@ static struct gpio_leds_priv *gpio_leds_
- 		if (fwnode_property_present(child, "panic-indicator"))
- 			led.panic_indicator = 1;
- 
--		ret = create_gpio_led(&led, led_dat, dev, NULL);
-+		ret = create_gpio_led(&led, led_dat, dev, np, NULL);
- 		if (ret < 0) {
- 			fwnode_handle_put(child);
- 			return ERR_PTR(ret);
-@@ -240,9 +240,9 @@ static int gpio_led_probe(struct platfor
- 
- 		priv->num_leds = pdata->num_leds;
- 		for (i = 0; i < priv->num_leds; i++) {
--			ret = create_gpio_led(&pdata->leds[i],
--					      &priv->leds[i],
--					      &pdev->dev, pdata->gpio_blink_set);
-+			ret = create_gpio_led(&pdata->leds[i], &priv->leds[i],
-+					      &pdev->dev, NULL,
-+					      pdata->gpio_blink_set);
- 			if (ret < 0)
- 				return ret;
- 		}
--- a/target/linux/generic/backport-4.9/081-0001-thermal-bcm2835-add-thermal-driver-for-bcm2835-SoC.patch	2022-03-22 08:54:47.103464496 +0800
+++ b/target/linux/generic/backport-4.9/081-0001-thermal-bcm2835-add-thermal-driver-for-bcm2835-SoC.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,365 +0,0 @@
-From bcb7dd9ef206f7d646ed8dac6fe7772083714253 Mon Sep 17 00:00:00 2001
-From: Stefan Wahren <stefan.wahren@i2se.com>
-Date: Fri, 31 Mar 2017 20:03:06 +0000
-Subject: [PATCH] thermal: bcm2835: add thermal driver for bcm2835 SoC
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Add basic thermal driver for bcm2835 SoC.
-
-This driver currently make sure that tsense HW block is set up
-correctly.
-
-Tested-by: Rafa Miecki <rafal@milecki.pl>
-Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
-Signed-off-by: Stefan Wahren <stefan.wahren@i2se.com>
-Acked-by: Eric Anholt <eric@anholt.net>
-Acked-by: Eduardo Valentin <edubezval@gmail.com>
-Signed-off-by: Eduardo Valentin <edubezval@gmail.com>
----
- drivers/thermal/Kconfig           |   8 +
- drivers/thermal/Makefile          |   1 +
- drivers/thermal/bcm2835_thermal.c | 314 ++++++++++++++++++++++++++++++++++++++
- 3 files changed, 323 insertions(+)
- create mode 100644 drivers/thermal/bcm2835_thermal.c
-
---- a/drivers/thermal/Kconfig
-+++ b/drivers/thermal/Kconfig
-@@ -434,4 +434,12 @@ depends on (ARCH_QCOM && OF) || COMPILE_
- source "drivers/thermal/qcom/Kconfig"
- endmenu
- 
-+config BCM2835_THERMAL
-+	tristate "Thermal sensors on bcm2835 SoC"
-+	depends on ARCH_BCM2835 || COMPILE_TEST
-+	depends on HAS_IOMEM
-+	depends on THERMAL_OF
-+	help
-+	  Support for thermal sensors on Broadcom bcm2835 SoCs.
-+
- endif
---- a/drivers/thermal/Makefile
-+++ b/drivers/thermal/Makefile
-@@ -55,3 +55,4 @@ obj-$(CONFIG_TEGRA_SOCTHERM)	+= tegra/
- obj-$(CONFIG_HISI_THERMAL)     += hisi_thermal.o
- obj-$(CONFIG_MTK_THERMAL)	+= mtk_thermal.o
- obj-$(CONFIG_GENERIC_ADC_THERMAL)	+= thermal-generic-adc.o
-+obj-$(CONFIG_BCM2835_THERMAL) += bcm2835_thermal.o
---- /dev/null
-+++ b/drivers/thermal/bcm2835_thermal.c
-@@ -0,0 +1,314 @@
-+/*
-+ * Driver for Broadcom BCM2835 SoC temperature sensor
-+ *
-+ * Copyright (C) 2016 Martin Sperl
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License as published by
-+ * the Free Software Foundation; either version 2 of the License, or
-+ * (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful,
-+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-+ * GNU General Public License for more details.
-+ */
-+
-+#include <linux/clk.h>
-+#include <linux/debugfs.h>
-+#include <linux/device.h>
-+#include <linux/err.h>
-+#include <linux/io.h>
-+#include <linux/kernel.h>
-+#include <linux/module.h>
-+#include <linux/of.h>
-+#include <linux/of_address.h>
-+#include <linux/of_device.h>
-+#include <linux/platform_device.h>
-+#include <linux/thermal.h>
-+
-+#define BCM2835_TS_TSENSCTL			0x00
-+#define BCM2835_TS_TSENSSTAT			0x04
-+
-+#define BCM2835_TS_TSENSCTL_PRWDW		BIT(0)
-+#define BCM2835_TS_TSENSCTL_RSTB		BIT(1)
-+
-+/*
-+ * bandgap reference voltage in 6 mV increments
-+ * 000b = 1178 mV, 001b = 1184 mV, ... 111b = 1220 mV
-+ */
-+#define BCM2835_TS_TSENSCTL_CTRL_BITS		3
-+#define BCM2835_TS_TSENSCTL_CTRL_SHIFT		2
-+#define BCM2835_TS_TSENSCTL_CTRL_MASK		    \
-+	GENMASK(BCM2835_TS_TSENSCTL_CTRL_BITS +     \
-+		BCM2835_TS_TSENSCTL_CTRL_SHIFT - 1, \
-+		BCM2835_TS_TSENSCTL_CTRL_SHIFT)
-+#define BCM2835_TS_TSENSCTL_CTRL_DEFAULT	1
-+#define BCM2835_TS_TSENSCTL_EN_INT		BIT(5)
-+#define BCM2835_TS_TSENSCTL_DIRECT		BIT(6)
-+#define BCM2835_TS_TSENSCTL_CLR_INT		BIT(7)
-+#define BCM2835_TS_TSENSCTL_THOLD_SHIFT		8
-+#define BCM2835_TS_TSENSCTL_THOLD_BITS		10
-+#define BCM2835_TS_TSENSCTL_THOLD_MASK		     \
-+	GENMASK(BCM2835_TS_TSENSCTL_THOLD_BITS +     \
-+		BCM2835_TS_TSENSCTL_THOLD_SHIFT - 1, \
-+		BCM2835_TS_TSENSCTL_THOLD_SHIFT)
-+/*
-+ * time how long the block to be asserted in reset
-+ * which based on a clock counter (TSENS clock assumed)
-+ */
-+#define BCM2835_TS_TSENSCTL_RSTDELAY_SHIFT	18
-+#define BCM2835_TS_TSENSCTL_RSTDELAY_BITS	8
-+#define BCM2835_TS_TSENSCTL_REGULEN		BIT(26)
-+
-+#define BCM2835_TS_TSENSSTAT_DATA_BITS		10
-+#define BCM2835_TS_TSENSSTAT_DATA_SHIFT		0
-+#define BCM2835_TS_TSENSSTAT_DATA_MASK		     \
-+	GENMASK(BCM2835_TS_TSENSSTAT_DATA_BITS +     \
-+		BCM2835_TS_TSENSSTAT_DATA_SHIFT - 1, \
-+		BCM2835_TS_TSENSSTAT_DATA_SHIFT)
-+#define BCM2835_TS_TSENSSTAT_VALID		BIT(10)
-+#define BCM2835_TS_TSENSSTAT_INTERRUPT		BIT(11)
-+
-+struct bcm2835_thermal_data {
-+	struct thermal_zone_device *tz;
-+	void __iomem *regs;
-+	struct clk *clk;
-+	struct dentry *debugfsdir;
-+};
-+
-+static int bcm2835_thermal_adc2temp(u32 adc, int offset, int slope)
-+{
-+	return offset + slope * adc;
-+}
-+
-+static int bcm2835_thermal_temp2adc(int temp, int offset, int slope)
-+{
-+	temp -= offset;
-+	temp /= slope;
-+
-+	if (temp < 0)
-+		temp = 0;
-+	if (temp >= BIT(BCM2835_TS_TSENSSTAT_DATA_BITS))
-+		temp = BIT(BCM2835_TS_TSENSSTAT_DATA_BITS) - 1;
-+
-+	return temp;
-+}
-+
-+static int bcm2835_thermal_get_temp(void *d, int *temp)
-+{
-+	struct bcm2835_thermal_data *data = d;
-+	u32 val = readl(data->regs + BCM2835_TS_TSENSSTAT);
-+
-+	if (!(val & BCM2835_TS_TSENSSTAT_VALID))
-+		return -EIO;
-+
-+	val &= BCM2835_TS_TSENSSTAT_DATA_MASK;
-+
-+	*temp = bcm2835_thermal_adc2temp(
-+		val,
-+		thermal_zone_get_offset(data->tz),
-+		thermal_zone_get_slope(data->tz));
-+
-+	return 0;
-+}
-+
-+static const struct debugfs_reg32 bcm2835_thermal_regs[] = {
-+	{
-+		.name = "ctl",
-+		.offset = 0
-+	},
-+	{
-+		.name = "stat",
-+		.offset = 4
-+	}
-+};
-+
-+static void bcm2835_thermal_debugfs(struct platform_device *pdev)
-+{
-+	struct thermal_zone_device *tz = platform_get_drvdata(pdev);
-+	struct bcm2835_thermal_data *data = tz->devdata;
-+	struct debugfs_regset32 *regset;
-+
-+	data->debugfsdir = debugfs_create_dir("bcm2835_thermal", NULL);
-+	if (!data->debugfsdir)
-+		return;
-+
-+	regset = devm_kzalloc(&pdev->dev, sizeof(*regset), GFP_KERNEL);
-+	if (!regset)
-+		return;
-+
-+	regset->regs = bcm2835_thermal_regs;
-+	regset->nregs = ARRAY_SIZE(bcm2835_thermal_regs);
-+	regset->base = data->regs;
-+
-+	debugfs_create_regset32("regset", 0444, data->debugfsdir, regset);
-+}
-+
-+static struct thermal_zone_of_device_ops bcm2835_thermal_ops = {
-+	.get_temp = bcm2835_thermal_get_temp,
-+};
-+
-+/*
-+ * Note: as per Raspberry Foundation FAQ
-+ * (https://www.raspberrypi.org/help/faqs/#performanceOperatingTemperature)
-+ * the recommended temperature range for the SoC -40C to +85C
-+ * so the trip limit is set to 80C.
-+ * this applies to all the BCM283X SoC
-+ */
-+
-+static const struct of_device_id bcm2835_thermal_of_match_table[] = {
-+	{
-+		.compatible = "brcm,bcm2835-thermal",
-+	},
-+	{
-+		.compatible = "brcm,bcm2836-thermal",
-+	},
-+	{
-+		.compatible = "brcm,bcm2837-thermal",
-+	},
-+	{},
-+};
-+MODULE_DEVICE_TABLE(of, bcm2835_thermal_of_match_table);
-+
-+static int bcm2835_thermal_probe(struct platform_device *pdev)
-+{
-+	const struct of_device_id *match;
-+	struct thermal_zone_device *tz;
-+	struct bcm2835_thermal_data *data;
-+	struct resource *res;
-+	int err = 0;
-+	u32 val;
-+	unsigned long rate;
-+
-+	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
-+	if (!data)
-+		return -ENOMEM;
-+
-+	match = of_match_device(bcm2835_thermal_of_match_table,
-+				&pdev->dev);
-+	if (!match)
-+		return -EINVAL;
-+
-+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-+	data->regs = devm_ioremap_resource(&pdev->dev, res);
-+	if (IS_ERR(data->regs)) {
-+		err = PTR_ERR(data->regs);
-+		dev_err(&pdev->dev, "Could not get registers: %d\n", err);
-+		return err;
-+	}
-+
-+	data->clk = devm_clk_get(&pdev->dev, NULL);
-+	if (IS_ERR(data->clk)) {
-+		err = PTR_ERR(data->clk);
-+		if (err != -EPROBE_DEFER)
-+			dev_err(&pdev->dev, "Could not get clk: %d\n", err);
-+		return err;
-+	}
-+
-+	err = clk_prepare_enable(data->clk);
-+	if (err)
-+		return err;
-+
-+	rate = clk_get_rate(data->clk);
-+	if ((rate < 1920000) || (rate > 5000000))
-+		dev_warn(&pdev->dev,
-+			 "Clock %pCn running at %pCr Hz is outside of the recommended range: 1.92 to 5MHz\n",
-+			 data->clk, data->clk);
-+
-+	/* register of thermal sensor and get info from DT */
-+	tz = thermal_zone_of_sensor_register(&pdev->dev, 0, data,
-+					     &bcm2835_thermal_ops);
-+	if (IS_ERR(tz)) {
-+		err = PTR_ERR(tz);
-+		dev_err(&pdev->dev,
-+			"Failed to register the thermal device: %d\n",
-+			err);
-+		goto err_clk;
-+	}
-+
-+	/*
-+	 * right now the FW does set up the HW-block, so we are not
-+	 * touching the configuration registers.
-+	 * But if the HW is not enabled, then set it up
-+	 * using "sane" values used by the firmware right now.
-+	 */
-+	val = readl(data->regs + BCM2835_TS_TSENSCTL);
-+	if (!(val & BCM2835_TS_TSENSCTL_RSTB)) {
-+		int trip_temp, offset, slope;
-+
-+		slope = thermal_zone_get_slope(tz);
-+		offset = thermal_zone_get_offset(tz);
-+		/*
-+		 * For now we deal only with critical, otherwise
-+		 * would need to iterate
-+		 */
-+		err = tz->ops->get_trip_temp(tz, 0, &trip_temp);
-+		if (err < 0) {
-+			err = PTR_ERR(tz);
-+			dev_err(&pdev->dev,
-+				"Not able to read trip_temp: %d\n",
-+				err);
-+			goto err_tz;
-+		}
-+
-+		/* set bandgap reference voltage and enable voltage regulator */
-+		val = (BCM2835_TS_TSENSCTL_CTRL_DEFAULT <<
-+		       BCM2835_TS_TSENSCTL_CTRL_SHIFT) |
-+		      BCM2835_TS_TSENSCTL_REGULEN;
-+
-+		/* use the recommended reset duration */
-+		val |= (0xFE << BCM2835_TS_TSENSCTL_RSTDELAY_SHIFT);
-+
-+		/*  trip_adc value from info */
-+		val |= bcm2835_thermal_temp2adc(trip_temp,
-+						offset,
-+						slope)
-+			<< BCM2835_TS_TSENSCTL_THOLD_SHIFT;
-+
-+		/* write the value back to the register as 2 steps */
-+		writel(val, data->regs + BCM2835_TS_TSENSCTL);
-+		val |= BCM2835_TS_TSENSCTL_RSTB;
-+		writel(val, data->regs + BCM2835_TS_TSENSCTL);
-+	}
-+
-+	data->tz = tz;
-+
-+	platform_set_drvdata(pdev, tz);
-+
-+	bcm2835_thermal_debugfs(pdev);
-+
-+	return 0;
-+err_tz:
-+	thermal_zone_of_sensor_unregister(&pdev->dev, tz);
-+err_clk:
-+	clk_disable_unprepare(data->clk);
-+
-+	return err;
-+}
-+
-+static int bcm2835_thermal_remove(struct platform_device *pdev)
-+{
-+	struct thermal_zone_device *tz = platform_get_drvdata(pdev);
-+	struct bcm2835_thermal_data *data = tz->devdata;
-+
-+	debugfs_remove_recursive(data->debugfsdir);
-+	thermal_zone_of_sensor_unregister(&pdev->dev, tz);
-+	clk_disable_unprepare(data->clk);
-+
-+	return 0;
-+}
-+
-+static struct platform_driver bcm2835_thermal_driver = {
-+	.probe = bcm2835_thermal_probe,
-+	.remove = bcm2835_thermal_remove,
-+	.driver = {
-+		.name = "bcm2835_thermal",
-+		.of_match_table = bcm2835_thermal_of_match_table,
-+	},
-+};
-+module_platform_driver(bcm2835_thermal_driver);
-+
-+MODULE_AUTHOR("Martin Sperl");
-+MODULE_DESCRIPTION("Thermal driver for bcm2835 chip");
-+MODULE_LICENSE("GPL");
--- a/target/linux/generic/backport-4.9/081-0002-thermal-broadcom-add-Northstar-thermal-driver.patch	2022-03-22 08:54:47.104464498 +0800
+++ b/target/linux/generic/backport-4.9/081-0002-thermal-broadcom-add-Northstar-thermal-driver.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,173 +0,0 @@
-From a94cb7eeecc4104a6874339f90c5d0647359c102 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Mon, 3 Apr 2017 17:48:29 +0200
-Subject: [PATCH] thermal: broadcom: add Northstar thermal driver
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Northstar is a SoC family commonly used in home routers. This commit
-adds a driver for checking CPU temperature. As Northstar Plus seems to
-also have this IP block this new symbol gets ARCH_BCM_IPROC dependency.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Signed-off-by: Jon Mason <jon.mason@broadcom.com>
-Signed-off-by: Eduardo Valentin <edubezval@gmail.com>
----
- drivers/thermal/Kconfig               |   5 ++
- drivers/thermal/Makefile              |   1 +
- drivers/thermal/broadcom/Kconfig      |   8 +++
- drivers/thermal/broadcom/Makefile     |   1 +
- drivers/thermal/broadcom/ns-thermal.c | 105 ++++++++++++++++++++++++++++++++++
- 5 files changed, 120 insertions(+)
- create mode 100644 drivers/thermal/broadcom/Kconfig
- create mode 100644 drivers/thermal/broadcom/Makefile
- create mode 100644 drivers/thermal/broadcom/ns-thermal.c
-
---- a/drivers/thermal/Kconfig
-+++ b/drivers/thermal/Kconfig
-@@ -381,6 +381,11 @@ config MTK_THERMAL
- 	  Enable this option if you want to have support for thermal management
- 	  controller present in Mediatek SoCs
- 
-+menu "Broadcom thermal drivers"
-+depends on ARCH_BCM || COMPILE_TEST
-+source "drivers/thermal/broadcom/Kconfig"
-+endmenu
-+
- menu "Texas Instruments thermal drivers"
- depends on ARCH_HAS_BANDGAP || COMPILE_TEST
- depends on HAS_IOMEM
---- a/drivers/thermal/Makefile
-+++ b/drivers/thermal/Makefile
-@@ -26,6 +26,7 @@ thermal_sys-$(CONFIG_CLOCK_THERMAL)	+= c
- thermal_sys-$(CONFIG_DEVFREQ_THERMAL) += devfreq_cooling.o
- 
- # platform thermal drivers
-+obj-y				+= broadcom/
- obj-$(CONFIG_QCOM_SPMI_TEMP_ALARM)	+= qcom-spmi-temp-alarm.o
- obj-$(CONFIG_SPEAR_THERMAL)	+= spear_thermal.o
- obj-$(CONFIG_ROCKCHIP_THERMAL)	+= rockchip_thermal.o
---- /dev/null
-+++ b/drivers/thermal/broadcom/Kconfig
-@@ -0,0 +1,8 @@
-+config BCM_NS_THERMAL
-+	tristate "Northstar thermal driver"
-+	depends on ARCH_BCM_IPROC || COMPILE_TEST
-+	help
-+	  Northstar is a family of SoCs that includes e.g. BCM4708, BCM47081,
-+	  BCM4709 and BCM47094. It contains DMU (Device Management Unit) block
-+	  with a thermal sensor that allows checking CPU temperature. This
-+	  driver provides support for it.
---- /dev/null
-+++ b/drivers/thermal/broadcom/Makefile
-@@ -0,0 +1 @@
-+obj-$(CONFIG_BCM_NS_THERMAL)		+= ns-thermal.o
---- /dev/null
-+++ b/drivers/thermal/broadcom/ns-thermal.c
-@@ -0,0 +1,105 @@
-+/*
-+ * Copyright (C) 2017 Rafa Miecki <rafal@milecki.pl>
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License version 2 as
-+ * published by the Free Software Foundation.
-+ */
-+
-+#include <linux/module.h>
-+#include <linux/of_address.h>
-+#include <linux/platform_device.h>
-+#include <linux/thermal.h>
-+
-+#define PVTMON_CONTROL0					0x00
-+#define PVTMON_CONTROL0_SEL_MASK			0x0000000e
-+#define PVTMON_CONTROL0_SEL_TEMP_MONITOR		0x00000000
-+#define PVTMON_CONTROL0_SEL_TEST_MODE			0x0000000e
-+#define PVTMON_STATUS					0x08
-+
-+struct ns_thermal {
-+	struct thermal_zone_device *tz;
-+	void __iomem *pvtmon;
-+};
-+
-+static int ns_thermal_get_temp(void *data, int *temp)
-+{
-+	struct ns_thermal *ns_thermal = data;
-+	int offset = thermal_zone_get_offset(ns_thermal->tz);
-+	int slope = thermal_zone_get_slope(ns_thermal->tz);
-+	u32 val;
-+
-+	val = readl(ns_thermal->pvtmon + PVTMON_CONTROL0);
-+	if ((val & PVTMON_CONTROL0_SEL_MASK) != PVTMON_CONTROL0_SEL_TEMP_MONITOR) {
-+		/* Clear current mode selection */
-+		val &= ~PVTMON_CONTROL0_SEL_MASK;
-+
-+		/* Set temp monitor mode (it's the default actually) */
-+		val |= PVTMON_CONTROL0_SEL_TEMP_MONITOR;
-+
-+		writel(val, ns_thermal->pvtmon + PVTMON_CONTROL0);
-+	}
-+
-+	val = readl(ns_thermal->pvtmon + PVTMON_STATUS);
-+	*temp = slope * val + offset;
-+
-+	return 0;
-+}
-+
-+static const struct thermal_zone_of_device_ops ns_thermal_ops = {
-+	.get_temp = ns_thermal_get_temp,
-+};
-+
-+static int ns_thermal_probe(struct platform_device *pdev)
-+{
-+	struct device *dev = &pdev->dev;
-+	struct ns_thermal *ns_thermal;
-+
-+	ns_thermal = devm_kzalloc(dev, sizeof(*ns_thermal), GFP_KERNEL);
-+	if (!ns_thermal)
-+		return -ENOMEM;
-+
-+	ns_thermal->pvtmon = of_iomap(dev_of_node(dev), 0);
-+	if (WARN_ON(!ns_thermal->pvtmon))
-+		return -ENOENT;
-+
-+	ns_thermal->tz = devm_thermal_zone_of_sensor_register(dev, 0,
-+							      ns_thermal,
-+							      &ns_thermal_ops);
-+	if (IS_ERR(ns_thermal->tz)) {
-+		iounmap(ns_thermal->pvtmon);
-+		return PTR_ERR(ns_thermal->tz);
-+	}
-+
-+	platform_set_drvdata(pdev, ns_thermal);
-+
-+	return 0;
-+}
-+
-+static int ns_thermal_remove(struct platform_device *pdev)
-+{
-+	struct ns_thermal *ns_thermal = platform_get_drvdata(pdev);
-+
-+	iounmap(ns_thermal->pvtmon);
-+
-+	return 0;
-+}
-+
-+static const struct of_device_id ns_thermal_of_match[] = {
-+	{ .compatible = "brcm,ns-thermal", },
-+	{},
-+};
-+MODULE_DEVICE_TABLE(of, ns_thermal_of_match);
-+
-+static struct platform_driver ns_thermal_driver = {
-+	.probe		= ns_thermal_probe,
-+	.remove		= ns_thermal_remove,
-+	.driver = {
-+		.name = "ns-thermal",
-+		.of_match_table = ns_thermal_of_match,
-+	},
-+};
-+module_platform_driver(ns_thermal_driver);
-+
-+MODULE_DESCRIPTION("Northstar thermal driver");
-+MODULE_LICENSE("GPL v2");
--- a/target/linux/generic/backport-4.9/082-0001-usb-core-read-USB-ports-from-DT-in-the-usbport-LED-t.patch	2022-03-22 08:54:47.104464498 +0800
+++ b/target/linux/generic/backport-4.9/082-0001-usb-core-read-USB-ports-from-DT-in-the-usbport-LED-t.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,106 +0,0 @@
-From 4f04c210d031667e503d6538a72345a36f3b5d71 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Thu, 8 Jun 2017 18:08:32 +0200
-Subject: [PATCH] usb: core: read USB ports from DT in the usbport LED trigger
- driver
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-This uses DT info to read relation description of LEDs and USB ports. If
-DT has properly described LEDs, trigger will know when to turn them on.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
----
- drivers/usb/core/ledtrig-usbport.c | 56 ++++++++++++++++++++++++++++++++++++++
- 1 file changed, 56 insertions(+)
-
---- a/drivers/usb/core/ledtrig-usbport.c
-+++ b/drivers/usb/core/ledtrig-usbport.c
-@@ -11,8 +11,10 @@
- #include <linux/device.h>
- #include <linux/leds.h>
- #include <linux/module.h>
-+#include <linux/of.h>
- #include <linux/slab.h>
- #include <linux/usb.h>
-+#include <linux/usb/of.h>
- 
- struct usbport_trig_data {
- 	struct led_classdev *led_cdev;
-@@ -123,6 +125,57 @@ static const struct attribute_group port
-  * Adding & removing ports
-  ***************************************/
- 
-+/**
-+ * usbport_trig_port_observed - Check if port should be observed
-+ */
-+static bool usbport_trig_port_observed(struct usbport_trig_data *usbport_data,
-+				       struct usb_device *usb_dev, int port1)
-+{
-+	struct device *dev = usbport_data->led_cdev->dev;
-+	struct device_node *led_np = dev->of_node;
-+	struct of_phandle_args args;
-+	struct device_node *port_np;
-+	int count, i;
-+
-+	if (!led_np)
-+		return false;
-+
-+	/* Get node of port being added */
-+	port_np = usb_of_get_child_node(usb_dev->dev.of_node, port1);
-+	if (!port_np)
-+		return false;
-+
-+	/* Amount of trigger sources for this LED */
-+	count = of_count_phandle_with_args(led_np, "trigger-sources",
-+					   "#trigger-source-cells");
-+	if (count < 0) {
-+		dev_warn(dev, "Failed to get trigger sources for %s\n",
-+			 led_np->full_name);
-+		return false;
-+	}
-+
-+	/* Check list of sources for this specific port */
-+	for (i = 0; i < count; i++) {
-+		int err;
-+
-+		err = of_parse_phandle_with_args(led_np, "trigger-sources",
-+						 "#trigger-source-cells", i,
-+						 &args);
-+		if (err) {
-+			dev_err(dev, "Failed to get trigger source phandle at index %d: %d\n",
-+				i, err);
-+			continue;
-+		}
-+
-+		of_node_put(args.np);
-+
-+		if (args.np == port_np)
-+			return true;
-+	}
-+
-+	return false;
-+}
-+
- static int usbport_trig_add_port(struct usbport_trig_data *usbport_data,
- 				 struct usb_device *usb_dev,
- 				 const char *hub_name, int portnum)
-@@ -141,6 +194,8 @@ static int usbport_trig_add_port(struct
- 	port->data = usbport_data;
- 	port->hub = usb_dev;
- 	port->portnum = portnum;
-+	port->observed = usbport_trig_port_observed(usbport_data, usb_dev,
-+						    portnum);
- 
- 	len = strlen(hub_name) + 8;
- 	port->port_name = kzalloc(len, GFP_KERNEL);
-@@ -255,6 +310,7 @@ static void usbport_trig_activate(struct
- 	if (err)
- 		goto err_free;
- 	usb_for_each_dev(usbport_data, usbport_trig_add_usb_dev_ports);
-+	usbport_trig_update_count(usbport_data);
- 
- 	/* Notifications */
- 	usbport_data->nb.notifier_call = usbport_trig_notify,
--- a/target/linux/generic/backport-4.9/085-v4.16-0001-i2c-gpio-Enable-working-over-slow-can_sleep-GPIOs.patch	2022-03-22 08:54:47.105464499 +0800
+++ b/target/linux/generic/backport-4.9/085-v4.16-0001-i2c-gpio-Enable-working-over-slow-can_sleep-GPIOs.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,84 +0,0 @@
-From f11a04464ae57e8db1bb7634547842b43e36a898 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Jan=20Kundr=C3=A1t?= <jan.kundrat@cesnet.cz>
-Date: Fri, 22 Dec 2017 22:47:16 +0100
-Subject: i2c: gpio: Enable working over slow can_sleep GPIOs
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-"Slow" GPIOs (usually those connected over an SPI or an I2C bus) are,
-well, slow in their operation. It is generally a good idea to avoid
-using them for time-critical operation, but sometimes the hardware just
-sucks, and the software has to cope. In addition to that, the I2C bus
-itself does not actually define any strict timing limits; the bus is
-free to go all the way down to DC. The timeouts (and therefore the
-slowest acceptable frequency) are present only in SMBus.
-
-The `can_sleep` is IMHO a wrong concept to use here. My SPI-to-quad-UART
-chip (MAX14830) is connected via a 26MHz SPI bus, and it happily drives
-SCL at 200kHz (5s pulses) during my benchmarks. That's faster than the
-maximal allowed speed of the traditional I2C.
-
-The previous version of this code did not really block operation over
-slow GPIO pins, anyway. Instead, it just resorted to printing a warning
-with a backtrace each time a GPIO pin was accessed, thereby slowing
-things down even more.
-
-Finally, it's not just me. A similar patch was originally submitted in
-2015 [1].
-
-[1] https://patchwork.ozlabs.org/patch/450956/
-
-Signed-off-by: Jan Kundrt <jan.kundrat@cesnet.cz>
-Acked-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
-Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
----
- drivers/i2c/busses/i2c-gpio.c | 11 +++++++----
- 1 file changed, 7 insertions(+), 4 deletions(-)
-
---- a/drivers/i2c/busses/i2c-gpio.c
-+++ b/drivers/i2c/busses/i2c-gpio.c
-@@ -44,7 +44,7 @@ static void i2c_gpio_setsda_val(void *da
- {
- 	struct i2c_gpio_platform_data *pdata = data;
- 
--	gpio_set_value(pdata->sda_pin, state);
-+	gpio_set_value_cansleep(pdata->sda_pin, state);
- }
- 
- /* Toggle SCL by changing the direction of the pin. */
-@@ -68,21 +68,21 @@ static void i2c_gpio_setscl_val(void *da
- {
- 	struct i2c_gpio_platform_data *pdata = data;
- 
--	gpio_set_value(pdata->scl_pin, state);
-+	gpio_set_value_cansleep(pdata->scl_pin, state);
- }
- 
- static int i2c_gpio_getsda(void *data)
- {
- 	struct i2c_gpio_platform_data *pdata = data;
- 
--	return gpio_get_value(pdata->sda_pin);
-+	return gpio_get_value_cansleep(pdata->sda_pin);
- }
- 
- static int i2c_gpio_getscl(void *data)
- {
- 	struct i2c_gpio_platform_data *pdata = data;
- 
--	return gpio_get_value(pdata->scl_pin);
-+	return gpio_get_value_cansleep(pdata->scl_pin);
- }
- 
- static int of_i2c_gpio_get_pins(struct device_node *np,
-@@ -175,6 +175,9 @@ static int i2c_gpio_probe(struct platfor
- 		memcpy(pdata, dev_get_platdata(&pdev->dev), sizeof(*pdata));
- 	}
- 
-+	if (gpiod_cansleep(gpio_to_desc(pdata->sda_pin)) || gpiod_cansleep(gpio_to_desc(pdata->scl_pin)))
-+		dev_warn(&pdev->dev, "Slow GPIO pins might wreak havoc into I2C/SMBus bus timing");
-+
- 	if (pdata->sda_is_open_drain) {
- 		gpio_direction_output(pdata->sda_pin, 1);
- 		bit_data->setsda = i2c_gpio_setsda_val;
--- a/target/linux/generic/backport-4.9/087-regmap-make-LZO-cache-optional.patch	2022-03-22 08:54:47.105464499 +0800
+++ b/target/linux/generic/backport-4.9/087-regmap-make-LZO-cache-optional.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,69 +0,0 @@
-From de88e9b0354c2e3ff8eae3f97afe43a34f5ed239 Mon Sep 17 00:00:00 2001
-From: Jonas Gorski <jonas.gorski@gmail.com>
-Date: Sat, 13 May 2017 13:03:21 +0200
-Subject: [PATCH] regmap: make LZO cache optional
-
-Commit 2cbbb579bcbe3 ("regmap: Add the LZO cache support") added support
-for LZO compression in regcache, but there were never any users added
-afterwards. Since LZO support itself has its own size, it currently is
-rather a deoptimization.
-
-So make it optional by introducing a symbol that can be selected by
-drivers wanting to make use of it.
-
-Saves e.g. ~46 kB on MIPS (size of LZO support + regcache LZO code).
-
-Signed-off-by: Jonas Gorski <jonas.gorski@gmail.com>
----
-I tried using google to find any users (even out-of-tree ones), but at
-best I found a single driver submission that was switched to RBTREE in
-subsequent resubmissions (MFD_SMSC).
-
-One could maybe also just drop the code because of no users for 5 years,
-but that would be up to the maintainer(s) to decide.
-
- drivers/base/regmap/Kconfig    | 5 ++++-
- drivers/base/regmap/Makefile   | 3 ++-
- drivers/base/regmap/regcache.c | 2 ++
- 3 files changed, 8 insertions(+), 2 deletions(-)
-
---- a/drivers/base/regmap/Kconfig
-+++ b/drivers/base/regmap/Kconfig
-@@ -4,9 +4,12 @@
- 
- config REGMAP
- 	default y if (REGMAP_I2C || REGMAP_SPI || REGMAP_SPMI || REGMAP_AC97 || REGMAP_MMIO || REGMAP_IRQ)
-+	select IRQ_DOMAIN if REGMAP_IRQ
-+	bool
-+
-+config REGCACHE_COMPRESSED
- 	select LZO_COMPRESS
- 	select LZO_DECOMPRESS
--	select IRQ_DOMAIN if REGMAP_IRQ
- 	bool
- 
- config REGMAP_AC97
---- a/drivers/base/regmap/Makefile
-+++ b/drivers/base/regmap/Makefile
-@@ -2,7 +2,8 @@
- CFLAGS_regmap.o := -I$(src)
- 
- obj-$(CONFIG_REGMAP) += regmap.o regcache.o
--obj-$(CONFIG_REGMAP) += regcache-rbtree.o regcache-lzo.o regcache-flat.o
-+obj-$(CONFIG_REGMAP) += regcache-rbtree.o regcache-flat.o
-+obj-$(CONFIG_REGCACHE_COMPRESSED) += regcache-lzo.o
- obj-$(CONFIG_DEBUG_FS) += regmap-debugfs.o
- obj-$(CONFIG_REGMAP_AC97) += regmap-ac97.o
- obj-$(CONFIG_REGMAP_I2C) += regmap-i2c.o
---- a/drivers/base/regmap/regcache.c
-+++ b/drivers/base/regmap/regcache.c
-@@ -21,7 +21,9 @@
- 
- static const struct regcache_ops *cache_types[] = {
- 	&regcache_rbtree_ops,
-+#if IS_ENABLED(CONFIG_REGCACHE_COMPRESSED)
- 	&regcache_lzo_ops,
-+#endif
- 	&regcache_flat_ops,
- };
- 
--- a/target/linux/generic/backport-4.9/090-net-generalize-napi_complete_done.patch	2022-03-22 08:54:47.107464503 +0800
+++ b/target/linux/generic/backport-4.9/090-net-generalize-napi_complete_done.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,1412 +0,0 @@
-From 6ad20165d376fa07919a70e4f43dfae564601829 Mon Sep 17 00:00:00 2001
-From: Eric Dumazet <edumazet@google.com>
-Date: Mon, 30 Jan 2017 08:22:01 -0800
-Subject: drivers: net: generalize napi_complete_done()
-
-napi_complete_done() allows to opt-in for gro_flush_timeout,
-added back in linux-3.19, commit 3b47d30396ba
-("net: gro: add a per device gro flush timer")
-
-This allows for more efficient GRO aggregation without
-sacrifying latencies.
-
-Signed-off-by: Eric Dumazet <edumazet@google.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- drivers/net/can/at91_can.c                          |  2 +-
- drivers/net/can/c_can/c_can.c                       |  2 +-
- drivers/net/can/flexcan.c                           |  2 +-
- drivers/net/can/ifi_canfd/ifi_canfd.c               |  2 +-
- drivers/net/can/janz-ican3.c                        |  2 +-
- drivers/net/can/m_can/m_can.c                       |  2 +-
- drivers/net/can/rcar/rcar_can.c                     |  2 +-
- drivers/net/can/rcar/rcar_canfd.c                   |  2 +-
- drivers/net/can/xilinx_can.c                        |  2 +-
- drivers/net/ethernet/3com/typhoon.c                 |  2 +-
- drivers/net/ethernet/adi/bfin_mac.c                 |  2 +-
- drivers/net/ethernet/agere/et131x.c                 |  2 +-
- drivers/net/ethernet/altera/altera_tse_main.c       |  2 +-
- drivers/net/ethernet/apm/xgene/xgene_enet_main.c    |  2 +-
- drivers/net/ethernet/aquantia/atlantic/aq_vec.c     |  2 +-
- drivers/net/ethernet/arc/emac_main.c                |  2 +-
- drivers/net/ethernet/atheros/alx/main.c             |  2 +-
- drivers/net/ethernet/atheros/atl1c/atl1c_main.c     |  2 +-
- drivers/net/ethernet/atheros/atl1e/atl1e_main.c     |  2 +-
- drivers/net/ethernet/atheros/atlx/atl1.c            |  2 +-
- drivers/net/ethernet/broadcom/b44.c                 |  2 +-
- drivers/net/ethernet/broadcom/bcm63xx_enet.c        |  2 +-
- drivers/net/ethernet/broadcom/bgmac.c               |  2 +-
- drivers/net/ethernet/broadcom/bnx2.c                |  4 ++--
- drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c     |  2 +-
- drivers/net/ethernet/broadcom/bnxt/bnxt.c           |  2 +-
- drivers/net/ethernet/broadcom/sb1250-mac.c          |  2 +-
- drivers/net/ethernet/brocade/bna/bnad.c             |  2 +-
- drivers/net/ethernet/cadence/macb.c                 |  2 +-
- drivers/net/ethernet/calxeda/xgmac.c                |  2 +-
- drivers/net/ethernet/cavium/liquidio/lio_main.c     |  2 +-
- drivers/net/ethernet/cavium/liquidio/lio_vf_main.c  |  2 +-
- drivers/net/ethernet/cavium/octeon/octeon_mgmt.c    |  2 +-
- drivers/net/ethernet/cavium/thunder/nicvf_main.c    |  2 +-
- drivers/net/ethernet/chelsio/cxgb/sge.c             |  2 +-
- drivers/net/ethernet/chelsio/cxgb3/sge.c            |  4 ++--
- drivers/net/ethernet/chelsio/cxgb4vf/sge.c          |  2 +-
- drivers/net/ethernet/cisco/enic/enic_main.c         |  4 ++--
- drivers/net/ethernet/dec/tulip/interrupt.c          |  6 +++---
- drivers/net/ethernet/dnet.c                         |  2 +-
- drivers/net/ethernet/emulex/benet/be_main.c         |  2 +-
- drivers/net/ethernet/ethoc.c                        |  2 +-
- drivers/net/ethernet/ezchip/nps_enet.c              |  2 +-
- drivers/net/ethernet/freescale/dpaa/dpaa_eth.c      |  2 +-
- drivers/net/ethernet/freescale/fec_main.c           |  2 +-
- .../net/ethernet/freescale/fs_enet/fs_enet-main.c   |  2 +-
- drivers/net/ethernet/freescale/gianfar.c            |  4 ++--
- drivers/net/ethernet/freescale/ucc_geth.c           |  2 +-
- drivers/net/ethernet/hisilicon/hip04_eth.c          |  2 +-
- drivers/net/ethernet/hisilicon/hisi_femac.c         |  2 +-
- drivers/net/ethernet/hisilicon/hix5hd2_gmac.c       |  2 +-
- drivers/net/ethernet/ibm/ibmveth.c                  |  2 +-
- drivers/net/ethernet/ibm/ibmvnic.c                  |  2 +-
- drivers/net/ethernet/intel/e100.c                   |  2 +-
- drivers/net/ethernet/intel/ixgb/ixgb_main.c         |  2 +-
- drivers/net/ethernet/korina.c                       |  2 +-
- drivers/net/ethernet/lantiq_etop.c                  | 21 +++++++++------------
- drivers/net/ethernet/marvell/mv643xx_eth.c          |  2 +-
- drivers/net/ethernet/marvell/mvneta.c               |  6 ++----
- drivers/net/ethernet/marvell/mvpp2.c                |  2 +-
- drivers/net/ethernet/marvell/pxa168_eth.c           |  2 +-
- drivers/net/ethernet/moxa/moxart_ether.c            |  2 +-
- drivers/net/ethernet/myricom/myri10ge/myri10ge.c    |  2 +-
- drivers/net/ethernet/natsemi/natsemi.c              |  2 +-
- drivers/net/ethernet/neterion/s2io.c                |  4 ++--
- drivers/net/ethernet/neterion/vxge/vxge-main.c      |  6 +++---
- drivers/net/ethernet/nvidia/forcedeth.c             |  2 +-
- drivers/net/ethernet/nxp/lpc_eth.c                  |  2 +-
- .../net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c    |  2 +-
- drivers/net/ethernet/pasemi/pasemi_mac.c            |  2 +-
- .../net/ethernet/qlogic/netxen/netxen_nic_main.c    |  2 +-
- drivers/net/ethernet/qlogic/qede/qede_fp.c          |  2 +-
- drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c      | 10 +++++-----
- drivers/net/ethernet/qlogic/qlge/qlge_main.c        |  2 +-
- drivers/net/ethernet/qualcomm/emac/emac.c           |  2 +-
- drivers/net/ethernet/realtek/r8169.c                |  2 +-
- drivers/net/ethernet/rocker/rocker_main.c           |  2 +-
- drivers/net/ethernet/samsung/sxgbe/sxgbe_main.c     |  2 +-
- drivers/net/ethernet/sfc/efx.c                      |  2 +-
- drivers/net/ethernet/sfc/falcon/efx.c               |  2 +-
- drivers/net/ethernet/smsc/smsc9420.c                |  2 +-
- drivers/net/ethernet/stmicro/stmmac/stmmac_main.c   |  2 +-
- drivers/net/ethernet/sun/niu.c                      |  2 +-
- drivers/net/ethernet/sun/sungem.c                   |  2 +-
- drivers/net/ethernet/sun/sunvnet_common.c           |  2 +-
- drivers/net/ethernet/tehuti/tehuti.c                |  2 +-
- drivers/net/ethernet/ti/cpsw.c                      |  2 +-
- drivers/net/ethernet/ti/davinci_emac.c              |  2 +-
- drivers/net/ethernet/ti/netcp_core.c                |  2 +-
- drivers/net/ethernet/tile/tilegx.c                  |  2 +-
- drivers/net/ethernet/tile/tilepro.c                 |  2 +-
- drivers/net/ethernet/toshiba/ps3_gelic_net.c        |  2 +-
- drivers/net/ethernet/toshiba/spider_net.c           |  2 +-
- drivers/net/ethernet/toshiba/tc35815.c              |  2 +-
- drivers/net/ethernet/tundra/tsi108_eth.c            |  2 +-
- drivers/net/ethernet/via/via-rhine.c                |  2 +-
- drivers/net/ethernet/via/via-velocity.c             |  2 +-
- drivers/net/ethernet/wiznet/w5100.c                 |  2 +-
- drivers/net/ethernet/wiznet/w5300.c                 |  2 +-
- drivers/net/fjes/fjes_main.c                        |  2 +-
- drivers/net/vmxnet3/vmxnet3_drv.c                   |  4 ++--
- drivers/net/wan/fsl_ucc_hdlc.c                      |  2 +-
- drivers/net/wan/hd64572.c                           |  2 +-
- drivers/net/wireless/ath/ath10k/pci.c               |  2 +-
- drivers/net/wireless/ath/wil6210/netdev.c           |  2 +-
- drivers/net/xen-netback/interface.c                 |  2 +-
- drivers/net/xen-netfront.c                          |  2 +-
- drivers/staging/octeon/ethernet-rx.c                |  2 +-
- drivers/staging/unisys/visornic/visornic_main.c     |  2 +-
- 109 files changed, 132 insertions(+), 137 deletions(-)
-
---- a/drivers/net/can/at91_can.c
-+++ b/drivers/net/can/at91_can.c
-@@ -813,7 +813,7 @@ static int at91_poll(struct napi_struct
- 		u32 reg_ier = AT91_IRQ_ERR_FRAME;
- 		reg_ier |= get_irq_mb_rx(priv) & ~AT91_MB_MASK(priv->rx_next);
- 
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		at91_write(priv, AT91_IER, reg_ier);
- 	}
- 
---- a/drivers/net/can/c_can/c_can.c
-+++ b/drivers/net/can/c_can/c_can.c
-@@ -1105,7 +1105,7 @@ static int c_can_poll(struct napi_struct
- 
- end:
- 	if (work_done < quota) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		/* enable all IRQs if we are not in bus off state */
- 		if (priv->can.state != CAN_STATE_BUS_OFF)
- 			c_can_irq_control(priv, true);
---- a/drivers/net/can/flexcan.c
-+++ b/drivers/net/can/flexcan.c
-@@ -703,7 +703,7 @@ static int flexcan_poll(struct napi_stru
- 		work_done += flexcan_poll_bus_err(dev, reg_esr);
- 
- 	if (work_done < quota) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		/* enable IRQs */
- 		flexcan_write(FLEXCAN_IFLAG_DEFAULT, &regs->imask1);
- 		flexcan_write(priv->reg_ctrl_default, &regs->ctrl);
---- a/drivers/net/can/ifi_canfd/ifi_canfd.c
-+++ b/drivers/net/can/ifi_canfd/ifi_canfd.c
-@@ -589,7 +589,7 @@ static int ifi_canfd_poll(struct napi_st
- 		work_done += ifi_canfd_do_rx_poll(ndev, quota - work_done);
- 
- 	if (work_done < quota) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		ifi_canfd_irq_enable(ndev, 1);
- 	}
- 
---- a/drivers/net/can/janz-ican3.c
-+++ b/drivers/net/can/janz-ican3.c
-@@ -1475,7 +1475,7 @@ static int ican3_napi(struct napi_struct
- 	/* We have processed all packets that the adapter had, but it
- 	 * was less than our budget, stop polling */
- 	if (received < budget)
--		napi_complete(napi);
-+		napi_complete_done(napi, received);
- 
- 	spin_lock_irqsave(&mod->lock, flags);
- 
---- a/drivers/net/can/m_can/m_can.c
-+++ b/drivers/net/can/m_can/m_can.c
-@@ -730,7 +730,7 @@ static int m_can_poll(struct napi_struct
- 		work_done += m_can_do_rx_poll(dev, (quota - work_done));
- 
- 	if (work_done < quota) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		m_can_enable_all_interrupts(priv);
- 	}
- 
---- a/drivers/net/can/rcar/rcar_can.c
-+++ b/drivers/net/can/rcar/rcar_can.c
-@@ -698,7 +698,7 @@ static int rcar_can_rx_poll(struct napi_
- 	}
- 	/* All packets processed */
- 	if (num_pkts < quota) {
--		napi_complete(napi);
-+		napi_complete_done(napi, num_pkts);
- 		priv->ier |= RCAR_CAN_IER_RXFIE;
- 		writeb(priv->ier, &priv->regs->ier);
- 	}
---- a/drivers/net/can/rcar/rcar_canfd.c
-+++ b/drivers/net/can/rcar/rcar_canfd.c
-@@ -1512,7 +1512,7 @@ static int rcar_canfd_rx_poll(struct nap
- 
- 	/* All packets processed */
- 	if (num_pkts < quota) {
--		napi_complete(napi);
-+		napi_complete_done(napi, num_pkts);
- 		/* Enable Rx FIFO interrupts */
- 		rcar_canfd_set_bit(priv->base, RCANFD_RFCC(ridx),
- 				   RCANFD_RFCC_RFIE);
---- a/drivers/net/can/xilinx_can.c
-+++ b/drivers/net/can/xilinx_can.c
-@@ -838,7 +838,7 @@ static int xcan_rx_poll(struct napi_stru
- 	}
- 
- 	if (work_done < quota) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		ier = priv->read_reg(priv, XCAN_IER_OFFSET);
- 		ier |= XCAN_IXR_RXNEMP_MASK;
- 		priv->write_reg(priv, XCAN_IER_OFFSET, ier);
---- a/drivers/net/ethernet/3com/typhoon.c
-+++ b/drivers/net/ethernet/3com/typhoon.c
-@@ -1748,7 +1748,7 @@ typhoon_poll(struct napi_struct *napi, i
- 	}
- 
- 	if (work_done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		iowrite32(TYPHOON_INTR_NONE,
- 				tp->ioaddr + TYPHOON_REG_INTR_MASK);
- 		typhoon_post_pci_writes(tp->ioaddr);
---- a/drivers/net/ethernet/adi/bfin_mac.c
-+++ b/drivers/net/ethernet/adi/bfin_mac.c
-@@ -1274,7 +1274,7 @@ static int bfin_mac_poll(struct napi_str
- 	}
- 
- 	if (i < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, i);
- 		if (test_and_clear_bit(BFIN_MAC_RX_IRQ_DISABLED, &lp->flags))
- 			enable_irq(IRQ_MAC_RX);
- 	}
---- a/drivers/net/ethernet/agere/et131x.c
-+++ b/drivers/net/ethernet/agere/et131x.c
-@@ -3573,7 +3573,7 @@ static int et131x_poll(struct napi_struc
- 	et131x_handle_send_pkts(adapter);
- 
- 	if (work_done < budget) {
--		napi_complete(&adapter->napi);
-+		napi_complete_done(&adapter->napi, work_done);
- 		et131x_enable_interrupts(adapter);
- 	}
- 
---- a/drivers/net/ethernet/altera/altera_tse_main.c
-+++ b/drivers/net/ethernet/altera/altera_tse_main.c
-@@ -491,7 +491,7 @@ static int tse_poll(struct napi_struct *
- 
- 	if (rxcomplete < budget) {
- 
--		napi_complete(napi);
-+		napi_complete_done(napi, rxcomplete);
- 
- 		netdev_dbg(priv->dev,
- 			   "NAPI Complete, did %d packets with budget %d\n",
---- a/drivers/net/ethernet/apm/xgene/xgene_enet_main.c
-+++ b/drivers/net/ethernet/apm/xgene/xgene_enet_main.c
-@@ -655,7 +655,7 @@ static int xgene_enet_napi(struct napi_s
- 	processed = xgene_enet_process_ring(ring, budget);
- 
- 	if (processed != budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, processed);
- 		enable_irq(ring->irq);
- 	}
- 
---- a/drivers/net/ethernet/arc/emac_main.c
-+++ b/drivers/net/ethernet/arc/emac_main.c
-@@ -284,7 +284,7 @@ static int arc_emac_poll(struct napi_str
- 
- 	work_done = arc_emac_rx(ndev, budget);
- 	if (work_done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		arc_reg_or(priv, R_ENABLE, RXINT_MASK | TXINT_MASK);
- 	}
- 
---- a/drivers/net/ethernet/atheros/alx/main.c
-+++ b/drivers/net/ethernet/atheros/alx/main.c
-@@ -292,7 +292,7 @@ static int alx_poll(struct napi_struct *
- 	if (!tx_complete || work == budget)
- 		return budget;
- 
--	napi_complete(&alx->napi);
-+	napi_complete_done(&alx->napi, work);
- 
- 	/* enable interrupt */
- 	if (alx->flags & ALX_FLAG_USING_MSIX) {
---- a/drivers/net/ethernet/atheros/atl1c/atl1c_main.c
-+++ b/drivers/net/ethernet/atheros/atl1c/atl1c_main.c
-@@ -1886,7 +1886,7 @@ static int atl1c_clean(struct napi_struc
- 
- 	if (work_done < budget) {
- quit_polling:
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		adapter->hw.intr_mask |= ISR_RX_PKT;
- 		AT_WRITE_REG(&adapter->hw, REG_IMR, adapter->hw.intr_mask);
- 	}
---- a/drivers/net/ethernet/atheros/atl1e/atl1e_main.c
-+++ b/drivers/net/ethernet/atheros/atl1e/atl1e_main.c
-@@ -1534,7 +1534,7 @@ static int atl1e_clean(struct napi_struc
- 	/* If no Tx and not enough Rx work done, exit the polling mode */
- 	if (work_done < budget) {
- quit_polling:
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		imr_data = AT_READ_REG(&adapter->hw, REG_IMR);
- 		AT_WRITE_REG(&adapter->hw, REG_IMR, imr_data | ISR_RX_EVENT);
- 		/* test debug */
---- a/drivers/net/ethernet/atheros/atlx/atl1.c
-+++ b/drivers/net/ethernet/atheros/atlx/atl1.c
-@@ -2457,7 +2457,7 @@ static int atl1_rings_clean(struct napi_
- 	if (work_done >= budget)
- 		return work_done;
- 
--	napi_complete(napi);
-+	napi_complete_done(napi, work_done);
- 	/* re-enable Interrupt */
- 	if (likely(adapter->int_enabled))
- 		atlx_imr_set(adapter, IMR_NORMAL_MASK);
---- a/drivers/net/ethernet/broadcom/b44.c
-+++ b/drivers/net/ethernet/broadcom/b44.c
-@@ -902,7 +902,7 @@ static int b44_poll(struct napi_struct *
- 	}
- 
- 	if (work_done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		b44_enable_ints(bp);
- 	}
- 
---- a/drivers/net/ethernet/broadcom/bcm63xx_enet.c
-+++ b/drivers/net/ethernet/broadcom/bcm63xx_enet.c
-@@ -511,7 +511,7 @@ static int bcm_enet_poll(struct napi_str
- 
- 	/* no more packet in rx/tx queue, remove device from poll
- 	 * queue */
--	napi_complete(napi);
-+	napi_complete_done(napi, rx_work_done);
- 
- 	/* restore rx/tx interrupt */
- 	enet_dmac_writel(priv, priv->dma_chan_int_mask,
---- a/drivers/net/ethernet/broadcom/bgmac.c
-+++ b/drivers/net/ethernet/broadcom/bgmac.c
-@@ -1146,7 +1146,7 @@ static int bgmac_poll(struct napi_struct
- 		return weight;
- 
- 	if (handled < weight) {
--		napi_complete(napi);
-+		napi_complete_done(napi, handled);
- 		bgmac_chip_intrs_on(bgmac);
- 	}
- 
---- a/drivers/net/ethernet/broadcom/bnx2.c
-+++ b/drivers/net/ethernet/broadcom/bnx2.c
-@@ -3522,7 +3522,7 @@ static int bnx2_poll_msix(struct napi_st
- 		rmb();
- 		if (likely(!bnx2_has_fast_work(bnapi))) {
- 
--			napi_complete(napi);
-+			napi_complete_done(napi, work_done);
- 			BNX2_WR(bp, BNX2_PCICFG_INT_ACK_CMD, bnapi->int_num |
- 				BNX2_PCICFG_INT_ACK_CMD_INDEX_VALID |
- 				bnapi->last_status_idx);
-@@ -3559,7 +3559,7 @@ static int bnx2_poll(struct napi_struct
- 
- 		rmb();
- 		if (likely(!bnx2_has_work(bnapi))) {
--			napi_complete(napi);
-+			napi_complete_done(napi, work_done);
- 			if (likely(bp->flags & BNX2_FLAG_USING_MSI_OR_MSIX)) {
- 				BNX2_WR(bp, BNX2_PCICFG_INT_ACK_CMD,
- 					BNX2_PCICFG_INT_ACK_CMD_INDEX_VALID |
---- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c
-+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c
-@@ -3240,7 +3240,7 @@ static int bnx2x_poll(struct napi_struct
- 		 * has been updated when NAPI was scheduled.
- 		 */
- 		if (IS_FCOE_FP(fp)) {
--			napi_complete(napi);
-+			napi_complete_done(napi, rx_work_done);
- 		} else {
- 			bnx2x_update_fpsb_idx(fp);
- 			/* bnx2x_has_rx_work() reads the status block,
---- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
-+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
-@@ -1799,7 +1799,7 @@ static int bnxt_poll_nitroa0(struct napi
- 	}
- 
- 	if (!bnxt_has_work(bp, cpr) && rx_pkts < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, rx_pkts);
- 		BNXT_CP_DB_REARM(cpr->cp_doorbell, cpr->cp_raw_cons);
- 	}
- 	return rx_pkts;
---- a/drivers/net/ethernet/broadcom/sb1250-mac.c
-+++ b/drivers/net/ethernet/broadcom/sb1250-mac.c
-@@ -2545,7 +2545,7 @@ static int sbmac_poll(struct napi_struct
- 	sbdma_tx_process(sc, &(sc->sbm_txdma), 1);
- 
- 	if (work_done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 
- #ifdef CONFIG_SBMAC_COALESCE
- 		__raw_writeq(((M_MAC_INT_EOP_COUNT | M_MAC_INT_EOP_TIMER) << S_MAC_TX_CH0) |
---- a/drivers/net/ethernet/brocade/bna/bnad.c
-+++ b/drivers/net/ethernet/brocade/bna/bnad.c
-@@ -1881,7 +1881,7 @@ bnad_napi_poll_rx(struct napi_struct *na
- 		return rcvd;
- 
- poll_exit:
--	napi_complete(napi);
-+	napi_complete_done(napi, rcvd);
- 
- 	rx_ctrl->rx_complete++;
- 
---- a/drivers/net/ethernet/cadence/macb.c
-+++ b/drivers/net/ethernet/cadence/macb.c
-@@ -1069,7 +1069,7 @@ static int macb_poll(struct napi_struct
- 
- 	work_done = bp->macbgem_ops.mog_rx(bp, budget);
- 	if (work_done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 
- 		/* Packets received while interrupts were disabled */
- 		status = macb_readl(bp, RSR);
---- a/drivers/net/ethernet/calxeda/xgmac.c
-+++ b/drivers/net/ethernet/calxeda/xgmac.c
-@@ -1247,7 +1247,7 @@ static int xgmac_poll(struct napi_struct
- 	work_done = xgmac_rx(priv, budget);
- 
- 	if (work_done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		__raw_writel(DMA_INTR_DEFAULT_MASK, priv->base + XGMAC_DMA_INTR_ENA);
- 	}
- 	return work_done;
---- a/drivers/net/ethernet/cavium/liquidio/lio_main.c
-+++ b/drivers/net/ethernet/cavium/liquidio/lio_main.c
-@@ -2433,7 +2433,7 @@ static int liquidio_napi_poll(struct nap
- 	}
- 
- 	if ((work_done < budget) && (tx_done)) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		octeon_process_droq_poll_cmd(droq->oct_dev, droq->q_no,
- 					     POLL_EVENT_ENABLE_INTR, 0);
- 		return 0;
---- a/drivers/net/ethernet/cavium/octeon/octeon_mgmt.c
-+++ b/drivers/net/ethernet/cavium/octeon/octeon_mgmt.c
-@@ -501,7 +501,7 @@ static int octeon_mgmt_napi_poll(struct
- 
- 	if (work_done < budget) {
- 		/* We stopped because no more packets were available. */
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		octeon_mgmt_enable_rx_irq(p);
- 	}
- 	octeon_mgmt_update_rx_stats(netdev);
---- a/drivers/net/ethernet/cavium/thunder/nicvf_main.c
-+++ b/drivers/net/ethernet/cavium/thunder/nicvf_main.c
-@@ -748,7 +748,7 @@ static int nicvf_poll(struct napi_struct
- 
- 	if (work_done < budget) {
- 		/* Slow packet rate, exit polling */
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		/* Re-enable interrupts */
- 		cq_head = nicvf_queue_reg_read(nic, NIC_QSET_CQ_0_7_HEAD,
- 					       cq->cq_idx);
---- a/drivers/net/ethernet/chelsio/cxgb/sge.c
-+++ b/drivers/net/ethernet/chelsio/cxgb/sge.c
-@@ -1605,7 +1605,7 @@ int t1_poll(struct napi_struct *napi, in
- 	int work_done = process_responses(adapter, budget);
- 
- 	if (likely(work_done < budget)) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		writel(adapter->sge->respQ.cidx,
- 		       adapter->regs + A_SG_SLEEPING);
- 	}
---- a/drivers/net/ethernet/chelsio/cxgb3/sge.c
-+++ b/drivers/net/ethernet/chelsio/cxgb3/sge.c
-@@ -1843,7 +1843,7 @@ static int ofld_poll(struct napi_struct
- 		__skb_queue_head_init(&queue);
- 		skb_queue_splice_init(&q->rx_queue, &queue);
- 		if (skb_queue_empty(&queue)) {
--			napi_complete(napi);
-+			napi_complete_done(napi, work_done);
- 			spin_unlock_irq(&q->lock);
- 			return work_done;
- 		}
-@@ -2414,7 +2414,7 @@ static int napi_rx_handler(struct napi_s
- 	int work_done = process_responses(adap, qs, budget);
- 
- 	if (likely(work_done < budget)) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 
- 		/*
- 		 * Because we don't atomically flush the following
---- a/drivers/net/ethernet/chelsio/cxgb4vf/sge.c
-+++ b/drivers/net/ethernet/chelsio/cxgb4vf/sge.c
-@@ -1889,7 +1889,7 @@ static int napi_rx_handler(struct napi_s
- 	u32 val;
- 
- 	if (likely(work_done < budget)) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		intr_params = rspq->next_intr_params;
- 		rspq->next_intr_params = rspq->intr_params;
- 	} else
---- a/drivers/net/ethernet/cisco/enic/enic_main.c
-+++ b/drivers/net/ethernet/cisco/enic/enic_main.c
-@@ -1339,7 +1339,7 @@ static int enic_poll(struct napi_struct
- 		 * exit polling
- 		 */
- 
--		napi_complete(napi);
-+		napi_complete_done(napi, rq_work_done);
- 		if (enic->rx_coalesce_setting.use_adaptive_rx_coalesce)
- 			enic_set_int_moderation(enic, &enic->rq[0]);
- 		vnic_intr_unmask(&enic->intr[intr]);
-@@ -1496,7 +1496,7 @@ static int enic_poll_msix_rq(struct napi
- 		 * exit polling
- 		 */
- 
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		if (enic->rx_coalesce_setting.use_adaptive_rx_coalesce)
- 			enic_set_int_moderation(enic, &enic->rq[rq]);
- 		vnic_intr_unmask(&enic->intr[intr]);
---- a/drivers/net/ethernet/dec/tulip/interrupt.c
-+++ b/drivers/net/ethernet/dec/tulip/interrupt.c
-@@ -319,8 +319,8 @@ int tulip_poll(struct napi_struct *napi,
- 
-          /* Remove us from polling list and enable RX intr. */
- 
--         napi_complete(napi);
--         iowrite32(tulip_tbl[tp->chip_id].valid_intrs, tp->base_addr+CSR7);
-+	napi_complete_done(napi, work_done);
-+	iowrite32(tulip_tbl[tp->chip_id].valid_intrs, tp->base_addr+CSR7);
- 
-          /* The last op happens after poll completion. Which means the following:
-           * 1. it can race with disabling irqs in irq handler
-@@ -355,7 +355,7 @@ int tulip_poll(struct napi_struct *napi,
-           * before we did napi_complete(). See? We would lose it. */
- 
-          /* remove ourselves from the polling list */
--         napi_complete(napi);
-+         napi_complete_done(napi, work_done);
- 
-          return work_done;
- }
---- a/drivers/net/ethernet/dnet.c
-+++ b/drivers/net/ethernet/dnet.c
-@@ -415,7 +415,7 @@ static int dnet_poll(struct napi_struct
- 		/* We processed all packets available.  Tell NAPI it can
- 		 * stop polling then re-enable rx interrupts.
- 		 */
--		napi_complete(napi);
-+		napi_complete_done(napi, npackets);
- 		int_enable = dnet_readl(bp, INTR_ENB);
- 		int_enable |= DNET_INTR_SRC_RX_CMDFIFOAF;
- 		dnet_writel(bp, int_enable, INTR_ENB);
---- a/drivers/net/ethernet/emulex/benet/be_main.c
-+++ b/drivers/net/ethernet/emulex/benet/be_main.c
-@@ -3344,7 +3344,7 @@ int be_poll(struct napi_struct *napi, in
- 		be_process_mcc(adapter);
- 
- 	if (max_work < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, max_work);
- 
- 		/* Skyhawk EQ_DB has a provision to set the rearm to interrupt
- 		 * delay via a delay multiplier encoding value
---- a/drivers/net/ethernet/ethoc.c
-+++ b/drivers/net/ethernet/ethoc.c
-@@ -614,7 +614,7 @@ static int ethoc_poll(struct napi_struct
- 	tx_work_done = ethoc_tx(priv->netdev, budget);
- 
- 	if (rx_work_done < budget && tx_work_done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, rx_work_done);
- 		ethoc_enable_irq(priv, INT_MASK_TX | INT_MASK_RX);
- 	}
- 
---- a/drivers/net/ethernet/ezchip/nps_enet.c
-+++ b/drivers/net/ethernet/ezchip/nps_enet.c
-@@ -192,7 +192,7 @@ static int nps_enet_poll(struct napi_str
- 	if (work_done < budget) {
- 		u32 buf_int_enable_value = 0;
- 
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 
- 		/* set tx_done and rx_rdy bits */
- 		buf_int_enable_value |= NPS_ENET_ENABLE << RX_RDY_SHIFT;
---- a/drivers/net/ethernet/freescale/fec_main.c
-+++ b/drivers/net/ethernet/freescale/fec_main.c
-@@ -1623,7 +1623,7 @@ static int fec_enet_rx_napi(struct napi_
- 	fec_enet_tx(ndev);
- 
- 	if (pkts < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, pkts);
- 		writel(FEC_DEFAULT_IMASK, fep->hwp + FEC_IMASK);
- 	}
- 	return pkts;
---- a/drivers/net/ethernet/freescale/fs_enet/fs_enet-main.c
-+++ b/drivers/net/ethernet/freescale/fs_enet/fs_enet-main.c
-@@ -301,7 +301,7 @@ static int fs_enet_napi(struct napi_stru
- 
- 	if (received < budget && tx_left) {
- 		/* done */
--		napi_complete(napi);
-+		napi_complete_done(napi, received);
- 		(*fep->ops->napi_enable)(dev);
- 
- 		return received;
---- a/drivers/net/ethernet/freescale/gianfar.c
-+++ b/drivers/net/ethernet/freescale/gianfar.c
-@@ -3197,7 +3197,7 @@ static int gfar_poll_rx_sq(struct napi_s
- 
- 	if (work_done < budget) {
- 		u32 imask;
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		/* Clear the halt bit in RSTAT */
- 		gfar_write(&regs->rstat, gfargrp->rstat);
- 
-@@ -3286,7 +3286,7 @@ static int gfar_poll_rx(struct napi_stru
- 
- 	if (!num_act_queues) {
- 		u32 imask;
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 
- 		/* Clear the halt bit in RSTAT */
- 		gfar_write(&regs->rstat, gfargrp->rstat);
---- a/drivers/net/ethernet/freescale/ucc_geth.c
-+++ b/drivers/net/ethernet/freescale/ucc_geth.c
-@@ -3303,7 +3303,7 @@ static int ucc_geth_poll(struct napi_str
- 		howmany += ucc_geth_rx(ugeth, i, budget - howmany);
- 
- 	if (howmany < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, howmany);
- 		setbits32(ugeth->uccf->p_uccm, UCCE_RX_EVENTS | UCCE_TX_EVENTS);
- 	}
- 
---- a/drivers/net/ethernet/hisilicon/hip04_eth.c
-+++ b/drivers/net/ethernet/hisilicon/hip04_eth.c
-@@ -561,7 +561,7 @@ refill:
- 		priv->reg_inten |= RCV_INT;
- 		writel_relaxed(priv->reg_inten, priv->base + PPE_INTEN);
- 	}
--	napi_complete(napi);
-+	napi_complete_done(napi, rx);
- done:
- 	/* start a new timer if necessary */
- 	if (rx < budget && tx_remaining)
---- a/drivers/net/ethernet/hisilicon/hisi_femac.c
-+++ b/drivers/net/ethernet/hisilicon/hisi_femac.c
-@@ -330,7 +330,7 @@ static int hisi_femac_poll(struct napi_s
- 	} while (ints & DEF_INT_MASK);
- 
- 	if (work_done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		hisi_femac_irq_enable(priv, DEF_INT_MASK &
- 					(~IRQ_INT_TX_PER_PACKET));
- 	}
---- a/drivers/net/ethernet/hisilicon/hix5hd2_gmac.c
-+++ b/drivers/net/ethernet/hisilicon/hix5hd2_gmac.c
-@@ -578,7 +578,7 @@ static int hix5hd2_poll(struct napi_stru
- 	} while (ints & DEF_INT_MASK);
- 
- 	if (work_done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		hix5hd2_irq_enable(priv);
- 	}
- 
---- a/drivers/net/ethernet/ibm/ibmveth.c
-+++ b/drivers/net/ethernet/ibm/ibmveth.c
-@@ -1323,7 +1323,7 @@ static int ibmveth_poll(struct napi_stru
- 	ibmveth_replenish_task(adapter);
- 
- 	if (frames_processed < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, frames_processed);
- 
- 		/* We think we are done - reenable interrupts,
- 		 * then check once more to make sure we are done.
---- a/drivers/net/ethernet/ibm/ibmvnic.c
-+++ b/drivers/net/ethernet/ibm/ibmvnic.c
-@@ -1028,7 +1028,7 @@ restart_poll:
- 
- 	if (frames_processed < budget) {
- 		enable_scrq_irq(adapter, adapter->rx_scrq[scrq_num]);
--		napi_complete(napi);
-+		napi_complete_done(napi, frames_processed);
- 		if (pending_scrq(adapter, adapter->rx_scrq[scrq_num]) &&
- 		    napi_reschedule(napi)) {
- 			disable_scrq_irq(adapter, adapter->rx_scrq[scrq_num]);
---- a/drivers/net/ethernet/intel/e100.c
-+++ b/drivers/net/ethernet/intel/e100.c
-@@ -2253,7 +2253,7 @@ static int e100_poll(struct napi_struct
- 
- 	/* If budget not fully consumed, exit the polling mode */
- 	if (work_done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		e100_enable_irq(nic);
- 	}
- 
---- a/drivers/net/ethernet/intel/ixgb/ixgb_main.c
-+++ b/drivers/net/ethernet/intel/ixgb/ixgb_main.c
-@@ -1825,7 +1825,7 @@ ixgb_clean(struct napi_struct *napi, int
- 
- 	/* If budget not fully consumed, exit the polling mode */
- 	if (work_done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		if (!test_bit(__IXGB_DOWN, &adapter->flags))
- 			ixgb_irq_enable(adapter);
- 	}
---- a/drivers/net/ethernet/korina.c
-+++ b/drivers/net/ethernet/korina.c
-@@ -464,7 +464,7 @@ static int korina_poll(struct napi_struc
- 
- 	work_done = korina_rx(dev, budget);
- 	if (work_done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 
- 		writel(readl(&lp->rx_dma_regs->dmasm) &
- 			~(DMA_STAT_DONE | DMA_STAT_HALT | DMA_STAT_ERR),
---- a/drivers/net/ethernet/lantiq_etop.c
-+++ b/drivers/net/ethernet/lantiq_etop.c
-@@ -156,24 +156,21 @@ ltq_etop_poll_rx(struct napi_struct *nap
- {
- 	struct ltq_etop_chan *ch = container_of(napi,
- 				struct ltq_etop_chan, napi);
--	int rx = 0;
--	int complete = 0;
-+	int work_done = 0;
- 
--	while ((rx < budget) && !complete) {
-+	while (work_done < budget) {
- 		struct ltq_dma_desc *desc = &ch->dma.desc_base[ch->dma.desc];
- 
--		if ((desc->ctl & (LTQ_DMA_OWN | LTQ_DMA_C)) == LTQ_DMA_C) {
--			ltq_etop_hw_receive(ch);
--			rx++;
--		} else {
--			complete = 1;
--		}
-+		if ((desc->ctl & (LTQ_DMA_OWN | LTQ_DMA_C)) != LTQ_DMA_C)
-+			break;
-+		ltq_etop_hw_receive(ch);
-+		work_done++;
- 	}
--	if (complete || !rx) {
--		napi_complete(&ch->napi);
-+	if (work_done < budget) {
-+		napi_complete_done(&ch->napi, work_done);
- 		ltq_dma_ack_irq(&ch->dma);
- 	}
--	return rx;
-+	return work_done;
- }
- 
- static int
---- a/drivers/net/ethernet/marvell/mv643xx_eth.c
-+++ b/drivers/net/ethernet/marvell/mv643xx_eth.c
-@@ -2312,7 +2312,7 @@ static int mv643xx_eth_poll(struct napi_
- 	if (work_done < budget) {
- 		if (mp->oom)
- 			mod_timer(&mp->rx_oom, jiffies + (HZ / 10));
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		wrlp(mp, INT_MASK, mp->int_mask);
- 	}
- 
---- a/drivers/net/ethernet/marvell/mvneta.c
-+++ b/drivers/net/ethernet/marvell/mvneta.c
-@@ -2702,11 +2702,9 @@ static int mvneta_poll(struct napi_struc
- 			rx_done = mvneta_rx_swbm(pp, budget, &pp->rxqs[rx_queue]);
- 	}
- 
--	budget -= rx_done;
--
--	if (budget > 0) {
-+	if (rx_done < budget) {
- 		cause_rx_tx = 0;
--		napi_complete(&port->napi);
-+		napi_complete_done(&port->napi, rx_done);
- 		enable_percpu_irq(pp->dev->irq, 0);
- 	}
- 
---- a/drivers/net/ethernet/marvell/mvpp2.c
-+++ b/drivers/net/ethernet/marvell/mvpp2.c
-@@ -5404,7 +5404,7 @@ static int mvpp2_poll(struct napi_struct
- 
- 	if (budget > 0) {
- 		cause_rx = 0;
--		napi_complete(napi);
-+		napi_complete_done(napi, rx_done);
- 
- 		mvpp2_interrupts_enable(port);
- 	}
---- a/drivers/net/ethernet/marvell/pxa168_eth.c
-+++ b/drivers/net/ethernet/marvell/pxa168_eth.c
-@@ -1264,7 +1264,7 @@ static int pxa168_rx_poll(struct napi_st
- 	}
- 	work_done = rxq_process(dev, budget);
- 	if (work_done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		wrl(pep, INT_MASK, ALL_INTS);
- 	}
- 
---- a/drivers/net/ethernet/moxa/moxart_ether.c
-+++ b/drivers/net/ethernet/moxa/moxart_ether.c
-@@ -270,7 +270,7 @@ rx_next:
- 	}
- 
- 	if (rx < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, rx);
- 	}
- 
- 	priv->reg_imr |= RPKT_FINISH_M;
---- a/drivers/net/ethernet/myricom/myri10ge/myri10ge.c
-+++ b/drivers/net/ethernet/myricom/myri10ge/myri10ge.c
-@@ -1678,7 +1678,7 @@ static int myri10ge_poll(struct napi_str
- 
- 	myri10ge_ss_unlock_napi(ss);
- 	if (work_done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		put_be32(htonl(3), ss->irq_claim);
- 	}
- 	return work_done;
---- a/drivers/net/ethernet/natsemi/natsemi.c
-+++ b/drivers/net/ethernet/natsemi/natsemi.c
-@@ -2261,7 +2261,7 @@ static int natsemi_poll(struct napi_stru
- 		np->intr_status = readl(ioaddr + IntrStatus);
- 	} while (np->intr_status);
- 
--	napi_complete(napi);
-+	napi_complete_done(napi, work_done);
- 
- 	/* Reenable interrupts providing nothing is trying to shut
- 	 * the chip down. */
---- a/drivers/net/ethernet/neterion/s2io.c
-+++ b/drivers/net/ethernet/neterion/s2io.c
-@@ -2783,7 +2783,7 @@ static int s2io_poll_msix(struct napi_st
- 	s2io_chk_rx_buffers(nic, ring);
- 
- 	if (pkts_processed < budget_org) {
--		napi_complete(napi);
-+		napi_complete_done(napi, pkts_processed);
- 		/*Re Enable MSI-Rx Vector*/
- 		addr = (u8 __iomem *)&bar0->xmsi_mask_reg;
- 		addr += 7 - ring->ring_no;
-@@ -2817,7 +2817,7 @@ static int s2io_poll_inta(struct napi_st
- 			break;
- 	}
- 	if (pkts_processed < budget_org) {
--		napi_complete(napi);
-+		napi_complete_done(napi, pkts_processed);
- 		/* Re enable the Rx interrupts for the ring */
- 		writeq(0, &bar0->rx_traffic_mask);
- 		readl(&bar0->rx_traffic_mask);
---- a/drivers/net/ethernet/neterion/vxge/vxge-main.c
-+++ b/drivers/net/ethernet/neterion/vxge/vxge-main.c
-@@ -1823,8 +1823,8 @@ static int vxge_poll_msix(struct napi_st
- 	vxge_hw_vpath_poll_rx(ring->handle);
- 	pkts_processed = ring->pkts_processed;
- 
--	if (ring->pkts_processed < budget_org) {
--		napi_complete(napi);
-+	if (pkts_processed < budget_org) {
-+		napi_complete_done(napi, pkts_processed);
- 
- 		/* Re enable the Rx interrupts for the vpath */
- 		vxge_hw_channel_msix_unmask(
-@@ -1863,7 +1863,7 @@ static int vxge_poll_inta(struct napi_st
- 	VXGE_COMPLETE_ALL_TX(vdev);
- 
- 	if (pkts_processed < budget_org) {
--		napi_complete(napi);
-+		napi_complete_done(napi, pkts_processed);
- 		/* Re enable the Rx interrupts for the ring */
- 		vxge_hw_device_unmask_all(hldev);
- 		vxge_hw_device_flush_io(hldev);
---- a/drivers/net/ethernet/nvidia/forcedeth.c
-+++ b/drivers/net/ethernet/nvidia/forcedeth.c
-@@ -3756,7 +3756,7 @@ static int nv_napi_poll(struct napi_stru
- 	if (rx_work < budget) {
- 		/* re-enable interrupts
- 		   (msix not enabled in napi) */
--		napi_complete(napi);
-+		napi_complete_done(napi, rx_work);
- 
- 		writel(np->irqmask, base + NvRegIrqMask);
- 	}
---- a/drivers/net/ethernet/nxp/lpc_eth.c
-+++ b/drivers/net/ethernet/nxp/lpc_eth.c
-@@ -999,7 +999,7 @@ static int lpc_eth_poll(struct napi_stru
- 	rx_done = __lpc_handle_recv(ndev, budget);
- 
- 	if (rx_done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, rx_done);
- 		lpc_eth_enable_int(pldat->net_base);
- 	}
- 
---- a/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c
-+++ b/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c
-@@ -2391,7 +2391,7 @@ static int pch_gbe_napi_poll(struct napi
- 		poll_end_flag = true;
- 
- 	if (poll_end_flag) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		pch_gbe_irq_enable(adapter);
- 	}
- 
---- a/drivers/net/ethernet/pasemi/pasemi_mac.c
-+++ b/drivers/net/ethernet/pasemi/pasemi_mac.c
-@@ -1575,7 +1575,7 @@ static int pasemi_mac_poll(struct napi_s
- 	pkts = pasemi_mac_clean_rx(rx_ring(mac), budget);
- 	if (pkts < budget) {
- 		/* all done, no more packets present */
--		napi_complete(napi);
-+		napi_complete_done(napi, pkts);
- 
- 		pasemi_mac_restart_rx_intr(mac);
- 		pasemi_mac_restart_tx_intr(mac);
---- a/drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c
-+++ b/drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c
-@@ -2391,7 +2391,7 @@ static int netxen_nic_poll(struct napi_s
- 		work_done = budget;
- 
- 	if (work_done < budget) {
--		napi_complete(&sds_ring->napi);
-+		napi_complete_done(&sds_ring->napi, work_done);
- 		if (test_bit(__NX_DEV_UP, &adapter->state))
- 			netxen_nic_enable_int(sds_ring);
- 	}
---- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c
-+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c
-@@ -975,7 +975,7 @@ static int qlcnic_poll(struct napi_struc
- 		work_done = budget;
- 
- 	if (work_done < budget) {
--		napi_complete(&sds_ring->napi);
-+		napi_complete_done(&sds_ring->napi, work_done);
- 		if (test_bit(__QLCNIC_DEV_UP, &adapter->state)) {
- 			qlcnic_enable_sds_intr(adapter, sds_ring);
- 			qlcnic_enable_tx_intr(adapter, tx_ring);
-@@ -1019,7 +1019,7 @@ static int qlcnic_rx_poll(struct napi_st
- 	work_done = qlcnic_process_rcv_ring(sds_ring, budget);
- 
- 	if (work_done < budget) {
--		napi_complete(&sds_ring->napi);
-+		napi_complete_done(&sds_ring->napi, work_done);
- 		if (test_bit(__QLCNIC_DEV_UP, &adapter->state))
- 			qlcnic_enable_sds_intr(adapter, sds_ring);
- 	}
-@@ -1966,7 +1966,7 @@ static int qlcnic_83xx_msix_sriov_vf_pol
- 		work_done = budget;
- 
- 	if (work_done < budget) {
--		napi_complete(&sds_ring->napi);
-+		napi_complete_done(&sds_ring->napi, work_done);
- 		qlcnic_enable_sds_intr(adapter, sds_ring);
- 	}
- 
-@@ -1994,7 +1994,7 @@ static int qlcnic_83xx_poll(struct napi_
- 		work_done = budget;
- 
- 	if (work_done < budget) {
--		napi_complete(&sds_ring->napi);
-+		napi_complete_done(&sds_ring->napi, work_done);
- 		qlcnic_enable_sds_intr(adapter, sds_ring);
- 	}
- 
-@@ -2032,7 +2032,7 @@ static int qlcnic_83xx_rx_poll(struct na
- 	adapter = sds_ring->adapter;
- 	work_done = qlcnic_83xx_process_rcv_ring(sds_ring, budget);
- 	if (work_done < budget) {
--		napi_complete(&sds_ring->napi);
-+		napi_complete_done(&sds_ring->napi, work_done);
- 		if (test_bit(__QLCNIC_DEV_UP, &adapter->state))
- 			qlcnic_enable_sds_intr(adapter, sds_ring);
- 	}
---- a/drivers/net/ethernet/qlogic/qlge/qlge_main.c
-+++ b/drivers/net/ethernet/qlogic/qlge/qlge_main.c
-@@ -2334,7 +2334,7 @@ static int ql_napi_poll_msix(struct napi
- 	}
- 
- 	if (work_done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		ql_enable_completion_interrupt(qdev, rx_ring->irq);
- 	}
- 	return work_done;
---- a/drivers/net/ethernet/qualcomm/emac/emac.c
-+++ b/drivers/net/ethernet/qualcomm/emac/emac.c
-@@ -129,7 +129,7 @@ static int emac_napi_rtx(struct napi_str
- 	emac_mac_rx_process(adpt, rx_q, &work_done, budget);
- 
- 	if (work_done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 
- 		irq->mask |= rx_q->intr;
- 		writel(irq->mask, adpt->base + EMAC_INT_MASK);
---- a/drivers/net/ethernet/realtek/r8169.c
-+++ b/drivers/net/ethernet/realtek/r8169.c
-@@ -7578,7 +7578,7 @@ static int rtl8169_poll(struct napi_stru
- 	}
- 
- 	if (work_done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 
- 		rtl_irq_enable(tp, enable_mask);
- 		mmiowb();
---- a/drivers/net/ethernet/rocker/rocker_main.c
-+++ b/drivers/net/ethernet/rocker/rocker_main.c
-@@ -2480,7 +2480,7 @@ static int rocker_port_poll_rx(struct na
- 	}
- 
- 	if (credits < budget)
--		napi_complete(napi);
-+		napi_complete_done(napi, credits);
- 
- 	rocker_dma_ring_credits_set(rocker, &rocker_port->rx_ring, credits);
- 
---- a/drivers/net/ethernet/samsung/sxgbe/sxgbe_main.c
-+++ b/drivers/net/ethernet/samsung/sxgbe/sxgbe_main.c
-@@ -1578,7 +1578,7 @@ static int sxgbe_poll(struct napi_struct
- 
- 	work_done = sxgbe_rx(priv, budget);
- 	if (work_done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		priv->hw->dma->enable_dma_irq(priv->ioaddr, qnum);
- 	}
- 
---- a/drivers/net/ethernet/sfc/efx.c
-+++ b/drivers/net/ethernet/sfc/efx.c
-@@ -332,7 +332,7 @@ static int efx_poll(struct napi_struct *
- 		 * since efx_nic_eventq_read_ack() will have no effect if
- 		 * interrupts have already been disabled.
- 		 */
--		napi_complete(napi);
-+		napi_complete_done(napi, spent);
- 		efx_nic_eventq_read_ack(channel);
- 	}
- 
---- a/drivers/net/ethernet/smsc/smsc9420.c
-+++ b/drivers/net/ethernet/smsc/smsc9420.c
-@@ -869,7 +869,7 @@ static int smsc9420_rx_poll(struct napi_
- 	smsc9420_pci_flush_write(pd);
- 
- 	if (work_done < budget) {
--		napi_complete(&pd->napi);
-+		napi_complete_done(&pd->napi, work_done);
- 
- 		/* re-enable RX DMA interrupts */
- 		dma_intr_ena = smsc9420_reg_read(pd, DMAC_INTR_ENA);
---- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
-+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
-@@ -2700,7 +2700,7 @@ static int stmmac_poll(struct napi_struc
- 
- 	work_done = stmmac_rx(priv, budget);
- 	if (work_done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		stmmac_enable_dma_irq(priv);
- 	}
- 	return work_done;
---- a/drivers/net/ethernet/sun/niu.c
-+++ b/drivers/net/ethernet/sun/niu.c
-@@ -3785,7 +3785,7 @@ static int niu_poll(struct napi_struct *
- 	work_done = niu_poll_core(np, lp, budget);
- 
- 	if (work_done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		niu_ldg_rearm(np, lp, 1);
- 	}
- 	return work_done;
---- a/drivers/net/ethernet/sun/sungem.c
-+++ b/drivers/net/ethernet/sun/sungem.c
-@@ -924,7 +924,7 @@ static int gem_poll(struct napi_struct *
- 		gp->status = readl(gp->regs + GREG_STAT);
- 	} while (gp->status & GREG_STAT_NAPI);
- 
--	napi_complete(napi);
-+	napi_complete_done(napi, work_done);
- 	gem_enable_ints(gp);
- 
- 	return work_done;
---- a/drivers/net/ethernet/sun/sunvnet_common.c
-+++ b/drivers/net/ethernet/sun/sunvnet_common.c
-@@ -850,7 +850,7 @@ int sunvnet_poll_common(struct napi_stru
- 	int processed = vnet_event_napi(port, budget);
- 
- 	if (processed < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, processed);
- 		port->rx_event &= ~LDC_EVENT_DATA_READY;
- 		vio_set_intr(vio->vdev->rx_ino, HV_INTR_ENABLED);
- 	}
---- a/drivers/net/ethernet/tehuti/tehuti.c
-+++ b/drivers/net/ethernet/tehuti/tehuti.c
-@@ -303,7 +303,7 @@ static int bdx_poll(struct napi_struct *
- 		 * device lock and allow waiting tasks (eg rmmod) to advance) */
- 		priv->napi_stop = 0;
- 
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		bdx_enable_interrupts(priv);
- 	}
- 	return work_done;
---- a/drivers/net/ethernet/ti/cpsw.c
-+++ b/drivers/net/ethernet/ti/cpsw.c
-@@ -844,7 +844,7 @@ static int cpsw_rx_poll(struct napi_stru
- 	}
- 
- 	if (num_rx < budget) {
--		napi_complete(napi_rx);
-+		napi_complete_done(napi_rx, num_rx);
- 		writel(0xff, &cpsw->wr_regs->rx_en);
- 		if (cpsw->quirk_irq && cpsw->rx_irq_disabled) {
- 			cpsw->rx_irq_disabled = false;
---- a/drivers/net/ethernet/ti/davinci_emac.c
-+++ b/drivers/net/ethernet/ti/davinci_emac.c
-@@ -1295,7 +1295,7 @@ static int emac_poll(struct napi_struct
- 					&emac_rxhost_errcodes[cause][0], ch);
- 		}
- 	} else if (num_rx_pkts < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, num_rx_pkts);
- 		emac_int_enable(priv);
- 	}
- 
---- a/drivers/net/ethernet/ti/netcp_core.c
-+++ b/drivers/net/ethernet/ti/netcp_core.c
-@@ -939,7 +939,7 @@ static int netcp_rx_poll(struct napi_str
- 
- 	netcp_rxpool_refill(netcp);
- 	if (packets < budget) {
--		napi_complete(&netcp->rx_napi);
-+		napi_complete_done(&netcp->rx_napi, packets);
- 		knav_queue_enable_notify(netcp->rx_queue);
- 	}
- 
---- a/drivers/net/ethernet/tile/tilegx.c
-+++ b/drivers/net/ethernet/tile/tilegx.c
-@@ -678,7 +678,7 @@ static int tile_net_poll(struct napi_str
- 	}
- 
- 	/* There are no packets left. */
--	napi_complete(&info_mpipe->napi);
-+	napi_complete_done(&info_mpipe->napi, work);
- 
- 	md = &mpipe_data[instance];
- 	/* Re-enable hypervisor interrupts. */
---- a/drivers/net/ethernet/tile/tilepro.c
-+++ b/drivers/net/ethernet/tile/tilepro.c
-@@ -842,7 +842,7 @@ static int tile_net_poll(struct napi_str
- 		}
- 	}
- 
--	napi_complete(&info->napi);
-+	napi_complete_done(&info->napi, work);
- 
- 	if (!priv->active)
- 		goto done;
---- a/drivers/net/ethernet/toshiba/ps3_gelic_net.c
-+++ b/drivers/net/ethernet/toshiba/ps3_gelic_net.c
-@@ -1109,7 +1109,7 @@ static int gelic_net_poll(struct napi_st
- 	}
- 
- 	if (packets_done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, packets_done);
- 		gelic_card_rx_irq_on(card);
- 	}
- 	return packets_done;
---- a/drivers/net/ethernet/toshiba/spider_net.c
-+++ b/drivers/net/ethernet/toshiba/spider_net.c
-@@ -1270,7 +1270,7 @@ static int spider_net_poll(struct napi_s
- 	/* if all packets are in the stack, enable interrupts and return 0 */
- 	/* if not, return 1 */
- 	if (packets_done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, packets_done);
- 		spider_net_rx_irq_on(card);
- 		card->ignore_rx_ramfull = 0;
- 	}
---- a/drivers/net/ethernet/toshiba/tc35815.c
-+++ b/drivers/net/ethernet/toshiba/tc35815.c
-@@ -1641,7 +1641,7 @@ static int tc35815_poll(struct napi_stru
- 	spin_unlock(&lp->rx_lock);
- 
- 	if (received < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, received);
- 		/* enable interrupts */
- 		tc_writel(tc_readl(&tr->DMA_Ctl) & ~DMA_IntMask, &tr->DMA_Ctl);
- 	}
---- a/drivers/net/ethernet/tundra/tsi108_eth.c
-+++ b/drivers/net/ethernet/tundra/tsi108_eth.c
-@@ -888,7 +888,7 @@ static int tsi108_poll(struct napi_struc
- 
- 	if (num_received < budget) {
- 		data->rxpending = 0;
--		napi_complete(napi);
-+		napi_complete_done(napi, num_received);
- 
- 		TSI_WRITE(TSI108_EC_INTMASK,
- 				     TSI_READ(TSI108_EC_INTMASK)
---- a/drivers/net/ethernet/via/via-rhine.c
-+++ b/drivers/net/ethernet/via/via-rhine.c
-@@ -861,7 +861,7 @@ static int rhine_napipoll(struct napi_st
- 	}
- 
- 	if (work_done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		iowrite16(enable_mask, ioaddr + IntrEnable);
- 		mmiowb();
- 	}
---- a/drivers/net/ethernet/via/via-velocity.c
-+++ b/drivers/net/ethernet/via/via-velocity.c
-@@ -2160,7 +2160,7 @@ static int velocity_poll(struct napi_str
- 	velocity_tx_srv(vptr);
- 	/* If budget not fully consumed, exit the polling mode */
- 	if (rx_done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, rx_done);
- 		mac_enable_int(vptr->mac_regs);
- 	}
- 	spin_unlock_irqrestore(&vptr->lock, flags);
---- a/drivers/net/ethernet/wiznet/w5100.c
-+++ b/drivers/net/ethernet/wiznet/w5100.c
-@@ -915,7 +915,7 @@ static int w5100_napi_poll(struct napi_s
- 	}
- 
- 	if (rx_count < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, rx_count);
- 		w5100_enable_intr(priv);
- 	}
- 
---- a/drivers/net/ethernet/wiznet/w5300.c
-+++ b/drivers/net/ethernet/wiznet/w5300.c
-@@ -417,7 +417,7 @@ static int w5300_napi_poll(struct napi_s
- 	}
- 
- 	if (rx_count < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, rx_count);
- 		w5300_write(priv, W5300_IMR, IR_S0);
- 		mmiowb();
- 	}
---- a/drivers/net/fjes/fjes_main.c
-+++ b/drivers/net/fjes/fjes_main.c
-@@ -1122,7 +1122,7 @@ static int fjes_poll(struct napi_struct
- 	}
- 
- 	if (work_done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 
- 		if (adapter->unset_rx_last) {
- 			adapter->rx_last_jiffies = jiffies;
---- a/drivers/net/vmxnet3/vmxnet3_drv.c
-+++ b/drivers/net/vmxnet3/vmxnet3_drv.c
-@@ -1873,7 +1873,7 @@ vmxnet3_poll(struct napi_struct *napi, i
- 	rxd_done = vmxnet3_do_poll(rx_queue->adapter, budget);
- 
- 	if (rxd_done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, rxd_done);
- 		vmxnet3_enable_all_intrs(rx_queue->adapter);
- 	}
- 	return rxd_done;
-@@ -1904,7 +1904,7 @@ vmxnet3_poll_rx_only(struct napi_struct
- 	rxd_done = vmxnet3_rq_rx_complete(rq, adapter, budget);
- 
- 	if (rxd_done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, rxd_done);
- 		vmxnet3_enable_intr(adapter, rq->comp_ring.intr_idx);
- 	}
- 	return rxd_done;
---- a/drivers/net/wan/fsl_ucc_hdlc.c
-+++ b/drivers/net/wan/fsl_ucc_hdlc.c
-@@ -573,7 +573,7 @@ static int ucc_hdlc_poll(struct napi_str
- 	howmany += hdlc_rx_done(priv, budget - howmany);
- 
- 	if (howmany < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, howmany);
- 		qe_setbits32(priv->uccf->p_uccm,
- 			     (UCCE_HDLC_RX_EVENTS | UCCE_HDLC_TX_EVENTS) << 16);
- 	}
---- a/drivers/net/wan/hd64572.c
-+++ b/drivers/net/wan/hd64572.c
-@@ -341,7 +341,7 @@ static int sca_poll(struct napi_struct *
- 		received = sca_rx_done(port, budget);
- 
- 	if (received < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, received);
- 		enable_intr(port);
- 	}
- 
---- a/drivers/net/wireless/ath/ath10k/pci.c
-+++ b/drivers/net/wireless/ath/ath10k/pci.c
-@@ -2803,7 +2803,7 @@ static int ath10k_pci_napi_poll(struct n
- 	done = ath10k_htt_txrx_compl_task(ar, budget);
- 
- 	if (done < budget) {
--		napi_complete(ctx);
-+		napi_complete_done(ctx, done);
- 		/* In case of MSI, it is possible that interrupts are received
- 		 * while NAPI poll is inprogress. So pending interrupts that are
- 		 * received after processing all copy engine pipes by NAPI poll
---- a/drivers/net/wireless/ath/wil6210/netdev.c
-+++ b/drivers/net/wireless/ath/wil6210/netdev.c
-@@ -84,7 +84,7 @@ static int wil6210_netdev_poll_rx(struct
- 	done = budget - quota;
- 
- 	if (done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, done);
- 		wil6210_unmask_irq_rx(wil);
- 		wil_dbg_txrx(wil, "NAPI RX complete\n");
- 	}
---- a/drivers/net/xen-netback/interface.c
-+++ b/drivers/net/xen-netback/interface.c
-@@ -104,7 +104,7 @@ static int xenvif_poll(struct napi_struc
- 	work_done = xenvif_tx_action(queue, budget);
- 
- 	if (work_done < budget) {
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 		/* If the queue is rate-limited, it shall be
- 		 * rescheduled in the timer callback.
- 		 */
---- a/drivers/net/xen-netfront.c
-+++ b/drivers/net/xen-netfront.c
-@@ -1071,7 +1071,7 @@ err:
- 	if (work_done < budget) {
- 		int more_to_do = 0;
- 
--		napi_complete(napi);
-+		napi_complete_done(napi, work_done);
- 
- 		RING_FINAL_CHECK_FOR_RESPONSES(&queue->rx, more_to_do);
- 		if (more_to_do)
---- a/drivers/staging/octeon/ethernet-rx.c
-+++ b/drivers/staging/octeon/ethernet-rx.c
-@@ -429,7 +429,7 @@ static int cvm_oct_napi_poll(struct napi
- 
- 	if (rx_count < budget) {
- 		/* No more work */
--		napi_complete(napi);
-+		napi_complete_done(napi, rx_count);
- 		enable_irq(rx_group->irq);
- 	}
- 	return rx_count;
---- a/drivers/staging/unisys/visornic/visornic_main.c
-+++ b/drivers/staging/unisys/visornic/visornic_main.c
-@@ -1657,7 +1657,7 @@ static int visornic_poll(struct napi_str
- 
- 	/* If there aren't any more packets to receive stop the poll */
- 	if (rx_count < budget)
--		napi_complete(napi);
-+		napi_complete_done(napi, rx_count);
- 
- 	return rx_count;
- }
--- a/target/linux/generic/backport-4.9/094-v4.12-0001-ip6_tunnel-Fix-missing-tunnel-encapsulation-limit-op.patch	2022-03-22 08:54:47.107464503 +0800
+++ b/target/linux/generic/backport-4.9/094-v4.12-0001-ip6_tunnel-Fix-missing-tunnel-encapsulation-limit-op.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,50 +0,0 @@
-From 89a23c8b528bd2c89f3981573d6cd7d23840c8a6 Mon Sep 17 00:00:00 2001
-From: Craig Gallek <cgallek@google.com>
-Date: Wed, 26 Apr 2017 14:37:45 -0400
-Subject: [PATCH] ip6_tunnel: Fix missing tunnel encapsulation limit option
-
-The IPv6 tunneling code tries to insert IPV6_TLV_TNL_ENCAP_LIMIT and
-IPV6_TLV_PADN options when an encapsulation limit is defined (the
-default is a limit of 4).  An MTU adjustment is done to account for
-these options as well.  However, the options are never present in the
-generated packets.
-
-The issue appears to be a subtlety between IPV6_DSTOPTS and
-IPV6_RTHDRDSTOPTS defined in RFC 3542.  When the IPIP tunnel driver was
-written, the encap limit options were included as IPV6_RTHDRDSTOPTS in
-dst0opt of struct ipv6_txoptions.  Later, ipv6_push_nfrags_opts was
-(correctly) updated to require IPV6_RTHDR options when IPV6_RTHDRDSTOPTS
-are to be used.  This caused the options to no longer be included in v6
-encapsulated packets.
-
-The fix is to use IPV6_DSTOPTS (in dst1opt of struct ipv6_txoptions)
-instead.  IPV6_DSTOPTS do not have the additional IPV6_RTHDR requirement.
-
-Fixes: 1df64a8569c7: ("[IPV6]: Add ip6ip6 tunnel driver.")
-Fixes: 333fad5364d6: ("[IPV6]: Support several new sockopt / ancillary data in Advanced API (RFC3542)")
-Signed-off-by: Craig Gallek <kraig@google.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- net/ipv6/ip6_tunnel.c | 4 ++--
- 1 file changed, 2 insertions(+), 2 deletions(-)
-
---- a/net/ipv6/ip6_tunnel.c
-+++ b/net/ipv6/ip6_tunnel.c
-@@ -958,7 +958,7 @@ static void init_tel_txopt(struct ipv6_t
- 	opt->dst_opt[5] = IPV6_TLV_PADN;
- 	opt->dst_opt[6] = 1;
- 
--	opt->ops.dst0opt = (struct ipv6_opt_hdr *) opt->dst_opt;
-+	opt->ops.dst1opt = (struct ipv6_opt_hdr *) opt->dst_opt;
- 	opt->ops.opt_nflen = 8;
- }
- 
-@@ -1200,7 +1200,7 @@ route_lookup:
- 
- 	if (encap_limit >= 0) {
- 		init_tel_txopt(&opt, encap_limit);
--		ipv6_push_nfrag_opts(skb, &opt.ops, &proto, NULL);
-+		ipv6_push_frag_opts(skb, &opt.ops, &proto);
- 	}
- 
- 	skb_push(skb, sizeof(struct ipv6hdr));
--- a/target/linux/generic/backport-4.9/094-v4.12-0002-ipv6-Need-to-export-ipv6_push_frag_opts-for-tunnelin.patch	2022-03-22 08:54:47.108464504 +0800
+++ b/target/linux/generic/backport-4.9/094-v4.12-0002-ipv6-Need-to-export-ipv6_push_frag_opts-for-tunnelin.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,31 +0,0 @@
-From 5b8481fa42ac58484d633b558579e302aead64c1 Mon Sep 17 00:00:00 2001
-From: "David S. Miller" <davem@davemloft.net>
-Date: Mon, 1 May 2017 15:10:20 -0400
-Subject: [PATCH] ipv6: Need to export ipv6_push_frag_opts for tunneling now.
-
-Since that change also made the nfrag function not necessary
-for exports, remove it.
-
-Fixes: 89a23c8b528b ("ip6_tunnel: Fix missing tunnel encapsulation limit option")
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- net/ipv6/exthdrs.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/net/ipv6/exthdrs.c
-+++ b/net/ipv6/exthdrs.c
-@@ -729,13 +729,13 @@ void ipv6_push_nfrag_opts(struct sk_buff
- 	if (opt->hopopt)
- 		ipv6_push_exthdr(skb, proto, NEXTHDR_HOP, opt->hopopt);
- }
--EXPORT_SYMBOL(ipv6_push_nfrag_opts);
- 
- void ipv6_push_frag_opts(struct sk_buff *skb, struct ipv6_txoptions *opt, u8 *proto)
- {
- 	if (opt->dst1opt)
- 		ipv6_push_exthdr(skb, proto, NEXTHDR_DEST, opt->dst1opt);
- }
-+EXPORT_SYMBOL(ipv6_push_frag_opts);
- 
- struct ipv6_txoptions *
- ipv6_dup_options(struct sock *sk, struct ipv6_txoptions *opt)
--- a/target/linux/generic/backport-4.9/095-Allow-class-e-address-assignment-via-ifconfig-ioctl.patch	2022-03-22 08:54:47.108464504 +0800
+++ b/target/linux/generic/backport-4.9/095-Allow-class-e-address-assignment-via-ifconfig-ioctl.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,79 +0,0 @@
-From 46bf067870156abd61fe24d14c2486d15b8b502c Mon Sep 17 00:00:00 2001
-From: Dave Taht <dave@taht.net>
-Date: Fri, 14 Dec 2018 18:38:40 +0000
-Subject: [PATCH 1/1] Allow class-e address assignment in ifconfig and early
- boot
-
-While the linux kernel became mostly "class-e clean" a decade ago,
-and most distributions long ago switched to the iproute2 suite
-of utilities, which allow class-e (240.0.0.0/4) address assignment,
-distributions relying on busybox, toybox and other forms of
-ifconfig cannot assign class-e addresses without this kernel patch.
-
-With this patch, also, a boot command line on these addresses is feasible:
-(ip=248.0.1.2::248.0.1.1:255.255.255.0).
-
-While CIDR has been obsolete for 2 decades, and a survey of all the
-userspace open source code in the world shows most IN_whatever macros
-are also obsolete... rather than obsolete CIDR from this ioctl entirely,
-this patch merely enables class-e assignment, sanely.
-
-H/T to Vince Fuller and his original patch here:
-    https://lkml.org/lkml/2008/1/7/370
-
-Signed-off-by: Dave Taht <dave.taht@gmail.com>
-Reviewed-by: John Gilmore <gnu@toad.com>
----
- include/uapi/linux/in.h | 8 ++++++--
- net/ipv4/devinet.c      | 4 +++-
- net/ipv4/ipconfig.c     | 2 ++
- 3 files changed, 11 insertions(+), 3 deletions(-)
-
---- a/include/uapi/linux/in.h
-+++ b/include/uapi/linux/in.h
-@@ -266,8 +266,12 @@ struct sockaddr_in {
- #define	IN_MULTICAST(a)		IN_CLASSD(a)
- #define IN_MULTICAST_NET	0xF0000000
- 
--#define	IN_EXPERIMENTAL(a)	((((long int) (a)) & 0xf0000000) == 0xf0000000)
--#define	IN_BADCLASS(a)		IN_EXPERIMENTAL((a))
-+#define	IN_BADCLASS(a)		(((long int) (a) ) == (long int)0xffffffff)
-+#define	IN_EXPERIMENTAL(a)	IN_BADCLASS((a))
-+
-+#define	IN_CLASSE(a)		((((long int) (a)) & 0xf0000000) == 0xf0000000)
-+#define	IN_CLASSE_NET		0xffffffff
-+#define	IN_CLASSE_NSHIFT	0
- 
- /* Address to accept any incoming messages. */
- #define	INADDR_ANY		((unsigned long int) 0x00000000)
---- a/net/ipv4/devinet.c
-+++ b/net/ipv4/devinet.c
-@@ -906,7 +906,7 @@ static int inet_abc_len(__be32 addr)
- {
- 	int rc = -1;	/* Something else, probably a multicast. */
- 
--	if (ipv4_is_zeronet(addr))
-+	if (ipv4_is_zeronet(addr) || ipv4_is_lbcast(addr))
- 		rc = 0;
- 	else {
- 		__u32 haddr = ntohl(addr);
-@@ -917,6 +917,8 @@ static int inet_abc_len(__be32 addr)
- 			rc = 16;
- 		else if (IN_CLASSC(haddr))
- 			rc = 24;
-+		else if (IN_CLASSE(haddr))
-+			rc = 32;
- 	}
- 
- 	return rc;
---- a/net/ipv4/ipconfig.c
-+++ b/net/ipv4/ipconfig.c
-@@ -455,6 +455,8 @@ static int __init ic_defaults(void)
- 			ic_netmask = htonl(IN_CLASSB_NET);
- 		else if (IN_CLASSC(ntohl(ic_myaddr)))
- 			ic_netmask = htonl(IN_CLASSC_NET);
-+		else if (IN_CLASSE(ntohl(ic_myaddr)))
-+			ic_netmask = htonl(IN_CLASSE_NET);
- 		else {
- 			pr_err("IP-Config: Unable to guess netmask for address %pI4\n",
- 			       &ic_myaddr);
--- a/target/linux/generic/backport-4.9/095-v4.13-0001-rtc-ds1307-add-ds1308-variant.patch	2022-03-22 08:54:47.108464504 +0800
+++ b/target/linux/generic/backport-4.9/095-v4.13-0001-rtc-ds1307-add-ds1308-variant.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,51 +0,0 @@
-From 300a7735becf55f7fd18f8cd3dc3b945a0cab712 Mon Sep 17 00:00:00 2001
-From: Sean Nyekjaer <sean.nyekjaer@prevas.dk>
-Date: Thu, 8 Jun 2017 12:36:54 +0200
-Subject: rtc: ds1307: add ds1308 variant
-
-The ds1308 variant is very similar to the already supported ds1338
-variant, it have more debug registers and a square wave clock output.
-
-Signed-off-by: Sean Nyekjaer <sean.nyekjaer@prevas.dk>
-Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
----
- drivers/rtc/rtc-ds1307.c | 12 ++++++++++++
- 1 file changed, 12 insertions(+)
-
---- a/drivers/rtc/rtc-ds1307.c
-+++ b/drivers/rtc/rtc-ds1307.c
-@@ -31,6 +31,7 @@
-  */
- enum ds_type {
- 	ds_1307,
-+	ds_1308,
- 	ds_1337,
- 	ds_1338,
- 	ds_1339,
-@@ -144,6 +145,10 @@ static struct chip_desc chips[last_ds_ty
- 		.nvram_offset	= 8,
- 		.nvram_size	= 56,
- 	},
-+	[ds_1308] = {
-+		.nvram_offset	= 8,
-+		.nvram_size	= 56,
-+	},
- 	[ds_1337] = {
- 		.alarm		= 1,
- 	},
-@@ -175,6 +180,7 @@ static struct chip_desc chips[last_ds_ty
- 
- static const struct i2c_device_id ds1307_id[] = {
- 	{ "ds1307", ds_1307 },
-+	{ "ds1308", ds_1308 },
- 	{ "ds1337", ds_1337 },
- 	{ "ds1338", ds_1338 },
- 	{ "ds1339", ds_1339 },
-@@ -1488,6 +1494,7 @@ read_rtc:
- 			goto read_rtc;
- 		}
- 		break;
-+	case ds_1308:
- 	case ds_1338:
- 		/* clock halted?  turn it on, so clock can tick. */
- 		if (tmp & DS1307_BIT_CH)
--- a/target/linux/generic/backport-4.9/096-v4.20-netfilter-ipv6-Preserve-link-scope-traffic-original-.patch	2022-03-22 08:54:47.109464506 +0800
+++ b/target/linux/generic/backport-4.9/096-v4.20-netfilter-ipv6-Preserve-link-scope-traffic-original-.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,32 +0,0 @@
-From 508b09046c0f21678652fb66fd1e9959d55591d2 Mon Sep 17 00:00:00 2001
-From: Alin Nastac <alin.nastac@gmail.com>
-Date: Wed, 21 Nov 2018 14:00:30 +0100
-Subject: [PATCH] netfilter: ipv6: Preserve link scope traffic original oif
-
-When ip6_route_me_harder is invoked, it resets outgoing interface of:
-  - link-local scoped packets sent by neighbor discovery
-  - multicast packets sent by MLD host
-  - multicast packets send by MLD proxy daemon that sets outgoing
-    interface through IPV6_PKTINFO ipi6_ifindex
-
-Link-local and multicast packets must keep their original oif after
-ip6_route_me_harder is called.
-
-Signed-off-by: Alin Nastac <alin.nastac@gmail.com>
-Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
----
- net/ipv6/netfilter.c | 3 ++-
- 1 file changed, 2 insertions(+), 1 deletion(-)
-
---- a/net/ipv6/netfilter.c
-+++ b/net/ipv6/netfilter.c
-@@ -24,7 +24,8 @@ int ip6_route_me_harder(struct net *net,
- 	unsigned int hh_len;
- 	struct dst_entry *dst;
- 	struct flowi6 fl6 = {
--		.flowi6_oif = skb->sk ? skb->sk->sk_bound_dev_if : 0,
-+		.flowi6_oif = skb->sk && skb->sk->sk_bound_dev_if ? skb->sk->sk_bound_dev_if :
-+			rt6_need_strict(&iph->daddr) ? skb_dst(skb)->dev->ifindex : 0,
- 		.flowi6_mark = skb->mark,
- 		.daddr = iph->daddr,
- 		.saddr = iph->saddr,
--- a/target/linux/generic/backport-4.9/101-arm-cns3xxx-use-actual-size-reads-for-PCIe.patch	2022-03-22 08:54:47.109464506 +0800
+++ b/target/linux/generic/backport-4.9/101-arm-cns3xxx-use-actual-size-reads-for-PCIe.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,46 +0,0 @@
-From 4cc30de79d293f1e8c5f50ae3a9c005def9564a0 Mon Sep 17 00:00:00 2001
-From: Koen Vandeputte <koen.vandeputte@ncentric.com>
-Date: Mon, 7 Jan 2019 14:14:27 +0100
-Subject: [PATCH 2/2] arm: cns3xxx: use actual size reads for PCIe
-
-commit 802b7c06adc7 ("ARM: cns3xxx: Convert PCI to use generic config accessors")
-reimplemented cns3xxx_pci_read_config() using pci_generic_config_read32(),
-which preserved the property of only doing 32-bit reads.
-
-It also replaced cns3xxx_pci_write_config() with pci_generic_config_write(),
-so it changed writes from always being 32 bits to being the actual size,
-which works just fine.
-
-Due to:
-- The documentation does not mention that only 32 bit access is allowed.
-- Writes are already executed using the actual size
-- Extensive testing shows that 8b, 16b and 32b reads work as intended
-
-It makes perfectly sense to also swap 32 bit reading in favor of actual size.
-
-Fixes: 802b7c06adc7 ("ARM: cns3xxx: Convert PCI to use generic config accessors")
-Suggested-by: Bjorn Helgaas <bhelgaas@google.com>
-Signed-off-by: Koen Vandeputte <koen.vandeputte@ncentric.com>
-CC: Arnd Bergmann <arnd@arndb.de>
-CC: Krzysztof Halasa <khalasa@piap.pl>
-CC: Olof Johansson <olof@lixom.net>
-CC: Robin Leblon <robin.leblon@ncentric.com>
-CC: Rob Herring <robh@kernel.org>
-CC: Russell King <linux@armlinux.org.uk>
-CC: Tim Harvey <tharvey@gateworks.com>
-CC: stable@vger.kernel.org # v4.0+
----
- arch/arm/mach-cns3xxx/pcie.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/arch/arm/mach-cns3xxx/pcie.c
-+++ b/arch/arm/mach-cns3xxx/pcie.c
-@@ -93,7 +93,7 @@ static int cns3xxx_pci_read_config(struc
- 	u32 mask = (0x1ull << (size * 8)) - 1;
- 	int shift = (where % 4) * 8;
- 
--	ret = pci_generic_config_read32(bus, devfn, where, size, val);
-+	ret = pci_generic_config_read(bus, devfn, where, size, val);
- 
- 	if (ret == PCIBIOS_SUCCESSFUL && !bus->number && !devfn &&
- 	    (where & 0xffc) == PCI_CLASS_REVISION)
--- a/target/linux/generic/backport-4.9/400-v4.16-leds-trigger-Introduce-a-NETDEV-trigger.patch	2022-03-22 08:54:47.110464508 +0800
+++ b/target/linux/generic/backport-4.9/400-v4.16-leds-trigger-Introduce-a-NETDEV-trigger.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,588 +0,0 @@
-From 06f502f57d0d7728f9fa0f157ec5e4111ddb98f6 Mon Sep 17 00:00:00 2001
-From: Ben Whitten <ben.whitten@gmail.com>
-Date: Sun, 10 Dec 2017 21:17:55 +0000
-Subject: [PATCH] leds: trigger: Introduce a NETDEV trigger
-
-This commit introduces a NETDEV trigger for named device
-activity. Available triggers are link, rx, and tx.
-
-Signed-off-by: Ben Whitten <ben.whitten@gmail.com>
-Acked-by: Pavel Machek <pavel@ucw.cz>
-Signed-off-by: Jacek Anaszewski <jacek.anaszewski@gmail.com>
----
- .../ABI/testing/sysfs-class-led-trigger-netdev     |  45 ++
- drivers/leds/trigger/Kconfig                       |   7 +
- drivers/leds/trigger/Makefile                      |   1 +
- drivers/leds/trigger/ledtrig-netdev.c              | 496 +++++++++++++++++++++
- 4 files changed, 549 insertions(+)
- create mode 100644 Documentation/ABI/testing/sysfs-class-led-trigger-netdev
- create mode 100644 drivers/leds/trigger/ledtrig-netdev.c
-
---- /dev/null
-+++ b/Documentation/ABI/testing/sysfs-class-led-trigger-netdev
-@@ -0,0 +1,45 @@
-+What:		/sys/class/leds/<led>/device_name
-+Date:		Dec 2017
-+KernelVersion:	4.16
-+Contact:	linux-leds@vger.kernel.org
-+Description:
-+		Specifies the network device name to monitor.
-+
-+What:		/sys/class/leds/<led>/interval
-+Date:		Dec 2017
-+KernelVersion:	4.16
-+Contact:	linux-leds@vger.kernel.org
-+Description:
-+		Specifies the duration of the LED blink in milliseconds.
-+		Defaults to 50 ms.
-+
-+What:		/sys/class/leds/<led>/link
-+Date:		Dec 2017
-+KernelVersion:	4.16
-+Contact:	linux-leds@vger.kernel.org
-+Description:
-+		Signal the link state of the named network device.
-+		If set to 0 (default), the LED's normal state is off.
-+		If set to 1, the LED's normal state reflects the link state
-+		of the named network device.
-+		Setting this value also immediately changes the LED state.
-+
-+What:		/sys/class/leds/<led>/tx
-+Date:		Dec 2017
-+KernelVersion:	4.16
-+Contact:	linux-leds@vger.kernel.org
-+Description:
-+		Signal transmission of data on the named network device.
-+		If set to 0 (default), the LED will not blink on transmission.
-+		If set to 1, the LED will blink for the milliseconds specified
-+		in interval to signal transmission.
-+
-+What:		/sys/class/leds/<led>/rx
-+Date:		Dec 2017
-+KernelVersion:	4.16
-+Contact:	linux-leds@vger.kernel.org
-+Description:
-+		Signal reception of data on the named network device.
-+		If set to 0 (default), the LED will not blink on reception.
-+		If set to 1, the LED will blink for the milliseconds specified
-+		in interval to signal reception.
---- a/drivers/leds/trigger/Kconfig
-+++ b/drivers/leds/trigger/Kconfig
-@@ -126,4 +126,11 @@ config LEDS_TRIGGER_PANIC
- 	  a different trigger.
- 	  If unsure, say Y.
- 
-+config LEDS_TRIGGER_NETDEV
-+	tristate "LED Netdev Trigger"
-+	depends on NET && LEDS_TRIGGERS
-+	help
-+	  This allows LEDs to be controlled by network device activity.
-+	  If unsure, say Y.
-+
- endif # LEDS_TRIGGERS
---- a/drivers/leds/trigger/Makefile
-+++ b/drivers/leds/trigger/Makefile
-@@ -10,3 +10,4 @@ obj-$(CONFIG_LEDS_TRIGGER_DEFAULT_ON)	+=
- obj-$(CONFIG_LEDS_TRIGGER_TRANSIENT)	+= ledtrig-transient.o
- obj-$(CONFIG_LEDS_TRIGGER_CAMERA)	+= ledtrig-camera.o
- obj-$(CONFIG_LEDS_TRIGGER_PANIC)	+= ledtrig-panic.o
-+obj-$(CONFIG_LEDS_TRIGGER_NETDEV)	+= ledtrig-netdev.o
---- /dev/null
-+++ b/drivers/leds/trigger/ledtrig-netdev.c
-@@ -0,0 +1,496 @@
-+// SPDX-License-Identifier: GPL-2.0
-+// Copyright 2017 Ben Whitten <ben.whitten@gmail.com>
-+// Copyright 2007 Oliver Jowett <oliver@opencloud.com>
-+//
-+// LED Kernel Netdev Trigger
-+//
-+// Toggles the LED to reflect the link and traffic state of a named net device
-+//
-+// Derived from ledtrig-timer.c which is:
-+//  Copyright 2005-2006 Openedhand Ltd.
-+//  Author: Richard Purdie <rpurdie@openedhand.com>
-+
-+#include <linux/atomic.h>
-+#include <linux/ctype.h>
-+#include <linux/device.h>
-+#include <linux/init.h>
-+#include <linux/jiffies.h>
-+#include <linux/kernel.h>
-+#include <linux/leds.h>
-+#include <linux/list.h>
-+#include <linux/module.h>
-+#include <linux/netdevice.h>
-+#include <linux/spinlock.h>
-+#include <linux/timer.h>
-+#include "../leds.h"
-+
-+/*
-+ * Configurable sysfs attributes:
-+ *
-+ * device_name - network device name to monitor
-+ * interval - duration of LED blink, in milliseconds
-+ * link -  LED's normal state reflects whether the link is up
-+ *         (has carrier) or not
-+ * tx -  LED blinks on transmitted data
-+ * rx -  LED blinks on receive data
-+ *
-+ */
-+
-+struct led_netdev_data {
-+	spinlock_t lock;
-+
-+	struct delayed_work work;
-+	struct notifier_block notifier;
-+
-+	struct led_classdev *led_cdev;
-+	struct net_device *net_dev;
-+
-+	char device_name[IFNAMSIZ];
-+	atomic_t interval;
-+	unsigned int last_activity;
-+
-+	unsigned long mode;
-+#define NETDEV_LED_LINK	0
-+#define NETDEV_LED_TX	1
-+#define NETDEV_LED_RX	2
-+#define NETDEV_LED_MODE_LINKUP	3
-+};
-+
-+enum netdev_led_attr {
-+	NETDEV_ATTR_LINK,
-+	NETDEV_ATTR_TX,
-+	NETDEV_ATTR_RX
-+};
-+
-+static void set_baseline_state(struct led_netdev_data *trigger_data)
-+{
-+	int current_brightness;
-+	struct led_classdev *led_cdev = trigger_data->led_cdev;
-+
-+	current_brightness = led_cdev->brightness;
-+	if (current_brightness)
-+		led_cdev->blink_brightness = current_brightness;
-+	if (!led_cdev->blink_brightness)
-+		led_cdev->blink_brightness = led_cdev->max_brightness;
-+
-+	if (!test_bit(NETDEV_LED_MODE_LINKUP, &trigger_data->mode))
-+		led_set_brightness(led_cdev, LED_OFF);
-+	else {
-+		if (test_bit(NETDEV_LED_LINK, &trigger_data->mode))
-+			led_set_brightness(led_cdev,
-+					   led_cdev->blink_brightness);
-+		else
-+			led_set_brightness(led_cdev, LED_OFF);
-+
-+		/* If we are looking for RX/TX start periodically
-+		 * checking stats
-+		 */
-+		if (test_bit(NETDEV_LED_TX, &trigger_data->mode) ||
-+		    test_bit(NETDEV_LED_RX, &trigger_data->mode))
-+			schedule_delayed_work(&trigger_data->work, 0);
-+	}
-+}
-+
-+static ssize_t device_name_show(struct device *dev,
-+				struct device_attribute *attr, char *buf)
-+{
-+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
-+	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
-+	ssize_t len;
-+
-+	spin_lock_bh(&trigger_data->lock);
-+	len = sprintf(buf, "%s\n", trigger_data->device_name);
-+	spin_unlock_bh(&trigger_data->lock);
-+
-+	return len;
-+}
-+
-+static ssize_t device_name_store(struct device *dev,
-+				 struct device_attribute *attr, const char *buf,
-+				 size_t size)
-+{
-+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
-+	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
-+
-+	if (size >= IFNAMSIZ)
-+		return -EINVAL;
-+
-+	cancel_delayed_work_sync(&trigger_data->work);
-+
-+	spin_lock_bh(&trigger_data->lock);
-+
-+	if (trigger_data->net_dev) {
-+		dev_put(trigger_data->net_dev);
-+		trigger_data->net_dev = NULL;
-+	}
-+
-+	strncpy(trigger_data->device_name, buf, size);
-+	if (size > 0 && trigger_data->device_name[size - 1] == '\n')
-+		trigger_data->device_name[size - 1] = 0;
-+
-+	if (trigger_data->device_name[0] != 0)
-+		trigger_data->net_dev =
-+		    dev_get_by_name(&init_net, trigger_data->device_name);
-+
-+	clear_bit(NETDEV_LED_MODE_LINKUP, &trigger_data->mode);
-+	if (trigger_data->net_dev != NULL)
-+		if (netif_carrier_ok(trigger_data->net_dev))
-+			set_bit(NETDEV_LED_MODE_LINKUP, &trigger_data->mode);
-+
-+	trigger_data->last_activity = 0;
-+
-+	set_baseline_state(trigger_data);
-+	spin_unlock_bh(&trigger_data->lock);
-+
-+	return size;
-+}
-+
-+static DEVICE_ATTR_RW(device_name);
-+
-+static ssize_t netdev_led_attr_show(struct device *dev, char *buf,
-+	enum netdev_led_attr attr)
-+{
-+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
-+	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
-+	int bit;
-+
-+	switch (attr) {
-+	case NETDEV_ATTR_LINK:
-+		bit = NETDEV_LED_LINK;
-+		break;
-+	case NETDEV_ATTR_TX:
-+		bit = NETDEV_LED_TX;
-+		break;
-+	case NETDEV_ATTR_RX:
-+		bit = NETDEV_LED_RX;
-+		break;
-+	default:
-+		return -EINVAL;
-+	}
-+
-+	return sprintf(buf, "%u\n", test_bit(bit, &trigger_data->mode));
-+}
-+
-+static ssize_t netdev_led_attr_store(struct device *dev, const char *buf,
-+	size_t size, enum netdev_led_attr attr)
-+{
-+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
-+	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
-+	unsigned long state;
-+	int ret;
-+	int bit;
-+
-+	ret = kstrtoul(buf, 0, &state);
-+	if (ret)
-+		return ret;
-+
-+	switch (attr) {
-+	case NETDEV_ATTR_LINK:
-+		bit = NETDEV_LED_LINK;
-+		break;
-+	case NETDEV_ATTR_TX:
-+		bit = NETDEV_LED_TX;
-+		break;
-+	case NETDEV_ATTR_RX:
-+		bit = NETDEV_LED_RX;
-+		break;
-+	default:
-+		return -EINVAL;
-+	}
-+
-+	cancel_delayed_work_sync(&trigger_data->work);
-+
-+	if (state)
-+		set_bit(bit, &trigger_data->mode);
-+	else
-+		clear_bit(bit, &trigger_data->mode);
-+
-+	set_baseline_state(trigger_data);
-+
-+	return size;
-+}
-+
-+static ssize_t link_show(struct device *dev,
-+	struct device_attribute *attr, char *buf)
-+{
-+	return netdev_led_attr_show(dev, buf, NETDEV_ATTR_LINK);
-+}
-+
-+static ssize_t link_store(struct device *dev,
-+	struct device_attribute *attr, const char *buf, size_t size)
-+{
-+	return netdev_led_attr_store(dev, buf, size, NETDEV_ATTR_LINK);
-+}
-+
-+static DEVICE_ATTR_RW(link);
-+
-+static ssize_t tx_show(struct device *dev,
-+	struct device_attribute *attr, char *buf)
-+{
-+	return netdev_led_attr_show(dev, buf, NETDEV_ATTR_TX);
-+}
-+
-+static ssize_t tx_store(struct device *dev,
-+	struct device_attribute *attr, const char *buf, size_t size)
-+{
-+	return netdev_led_attr_store(dev, buf, size, NETDEV_ATTR_TX);
-+}
-+
-+static DEVICE_ATTR_RW(tx);
-+
-+static ssize_t rx_show(struct device *dev,
-+	struct device_attribute *attr, char *buf)
-+{
-+	return netdev_led_attr_show(dev, buf, NETDEV_ATTR_RX);
-+}
-+
-+static ssize_t rx_store(struct device *dev,
-+	struct device_attribute *attr, const char *buf, size_t size)
-+{
-+	return netdev_led_attr_store(dev, buf, size, NETDEV_ATTR_RX);
-+}
-+
-+static DEVICE_ATTR_RW(rx);
-+
-+static ssize_t interval_show(struct device *dev,
-+			     struct device_attribute *attr, char *buf)
-+{
-+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
-+	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
-+
-+	return sprintf(buf, "%u\n",
-+		       jiffies_to_msecs(atomic_read(&trigger_data->interval)));
-+}
-+
-+static ssize_t interval_store(struct device *dev,
-+			      struct device_attribute *attr, const char *buf,
-+			      size_t size)
-+{
-+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
-+	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
-+	unsigned long value;
-+	int ret;
-+
-+	ret = kstrtoul(buf, 0, &value);
-+	if (ret)
-+		return ret;
-+
-+	/* impose some basic bounds on the timer interval */
-+	if (value >= 5 && value <= 10000) {
-+		cancel_delayed_work_sync(&trigger_data->work);
-+
-+		atomic_set(&trigger_data->interval, msecs_to_jiffies(value));
-+		set_baseline_state(trigger_data);	/* resets timer */
-+	}
-+
-+	return size;
-+}
-+
-+static DEVICE_ATTR_RW(interval);
-+
-+static int netdev_trig_notify(struct notifier_block *nb,
-+			      unsigned long evt, void *dv)
-+{
-+	struct net_device *dev =
-+		netdev_notifier_info_to_dev((struct netdev_notifier_info *)dv);
-+	struct led_netdev_data *trigger_data = container_of(nb,
-+							    struct
-+							    led_netdev_data,
-+							    notifier);
-+
-+	if (evt != NETDEV_UP && evt != NETDEV_DOWN && evt != NETDEV_CHANGE
-+	    && evt != NETDEV_REGISTER && evt != NETDEV_UNREGISTER
-+	    && evt != NETDEV_CHANGENAME)
-+		return NOTIFY_DONE;
-+
-+	if (strcmp(dev->name, trigger_data->device_name))
-+		return NOTIFY_DONE;
-+
-+	cancel_delayed_work_sync(&trigger_data->work);
-+
-+	spin_lock_bh(&trigger_data->lock);
-+
-+	clear_bit(NETDEV_LED_MODE_LINKUP, &trigger_data->mode);
-+	switch (evt) {
-+	case NETDEV_REGISTER:
-+		if (trigger_data->net_dev)
-+			dev_put(trigger_data->net_dev);
-+		dev_hold(dev);
-+		trigger_data->net_dev = dev;
-+		break;
-+	case NETDEV_CHANGENAME:
-+	case NETDEV_UNREGISTER:
-+		if (trigger_data->net_dev) {
-+			dev_put(trigger_data->net_dev);
-+			trigger_data->net_dev = NULL;
-+		}
-+		break;
-+	case NETDEV_UP:
-+	case NETDEV_CHANGE:
-+		if (netif_carrier_ok(dev))
-+			set_bit(NETDEV_LED_MODE_LINKUP, &trigger_data->mode);
-+		break;
-+	}
-+
-+	set_baseline_state(trigger_data);
-+
-+	spin_unlock_bh(&trigger_data->lock);
-+
-+	return NOTIFY_DONE;
-+}
-+
-+/* here's the real work! */
-+static void netdev_trig_work(struct work_struct *work)
-+{
-+	struct led_netdev_data *trigger_data = container_of(work,
-+							    struct
-+							    led_netdev_data,
-+							    work.work);
-+	struct rtnl_link_stats64 *dev_stats;
-+	unsigned int new_activity;
-+	struct rtnl_link_stats64 temp;
-+	unsigned long interval;
-+	int invert;
-+
-+	/* If we dont have a device, insure we are off */
-+	if (!trigger_data->net_dev) {
-+		led_set_brightness(trigger_data->led_cdev, LED_OFF);
-+		return;
-+	}
-+
-+	/* If we are not looking for RX/TX then return  */
-+	if (!test_bit(NETDEV_LED_TX, &trigger_data->mode) &&
-+	    !test_bit(NETDEV_LED_RX, &trigger_data->mode))
-+		return;
-+
-+	dev_stats = dev_get_stats(trigger_data->net_dev, &temp);
-+	new_activity =
-+	    (test_bit(NETDEV_LED_TX, &trigger_data->mode) ?
-+		dev_stats->tx_packets : 0) +
-+	    (test_bit(NETDEV_LED_RX, &trigger_data->mode) ?
-+		dev_stats->rx_packets : 0);
-+
-+	if (trigger_data->last_activity != new_activity) {
-+		led_stop_software_blink(trigger_data->led_cdev);
-+
-+		invert = test_bit(NETDEV_LED_LINK, &trigger_data->mode);
-+		interval = jiffies_to_msecs(
-+				atomic_read(&trigger_data->interval));
-+		/* base state is ON (link present) */
-+		led_blink_set_oneshot(trigger_data->led_cdev,
-+				      &interval,
-+				      &interval,
-+				      invert);
-+		trigger_data->last_activity = new_activity;
-+	}
-+
-+	schedule_delayed_work(&trigger_data->work,
-+			(atomic_read(&trigger_data->interval)*2));
-+}
-+
-+static void netdev_trig_activate(struct led_classdev *led_cdev)
-+{
-+	struct led_netdev_data *trigger_data;
-+	int rc;
-+
-+	trigger_data = kzalloc(sizeof(struct led_netdev_data), GFP_KERNEL);
-+	if (!trigger_data)
-+		return;
-+
-+	spin_lock_init(&trigger_data->lock);
-+
-+	trigger_data->notifier.notifier_call = netdev_trig_notify;
-+	trigger_data->notifier.priority = 10;
-+
-+	INIT_DELAYED_WORK(&trigger_data->work, netdev_trig_work);
-+
-+	trigger_data->led_cdev = led_cdev;
-+	trigger_data->net_dev = NULL;
-+	trigger_data->device_name[0] = 0;
-+
-+	trigger_data->mode = 0;
-+	atomic_set(&trigger_data->interval, msecs_to_jiffies(50));
-+	trigger_data->last_activity = 0;
-+
-+	led_cdev->trigger_data = trigger_data;
-+
-+	rc = device_create_file(led_cdev->dev, &dev_attr_device_name);
-+	if (rc)
-+		goto err_out;
-+	rc = device_create_file(led_cdev->dev, &dev_attr_link);
-+	if (rc)
-+		goto err_out_device_name;
-+	rc = device_create_file(led_cdev->dev, &dev_attr_rx);
-+	if (rc)
-+		goto err_out_link;
-+	rc = device_create_file(led_cdev->dev, &dev_attr_tx);
-+	if (rc)
-+		goto err_out_rx;
-+	rc = device_create_file(led_cdev->dev, &dev_attr_interval);
-+	if (rc)
-+		goto err_out_tx;
-+	rc = register_netdevice_notifier(&trigger_data->notifier);
-+	if (rc)
-+		goto err_out_interval;
-+	return;
-+
-+err_out_interval:
-+	device_remove_file(led_cdev->dev, &dev_attr_interval);
-+err_out_tx:
-+	device_remove_file(led_cdev->dev, &dev_attr_tx);
-+err_out_rx:
-+	device_remove_file(led_cdev->dev, &dev_attr_rx);
-+err_out_link:
-+	device_remove_file(led_cdev->dev, &dev_attr_link);
-+err_out_device_name:
-+	device_remove_file(led_cdev->dev, &dev_attr_device_name);
-+err_out:
-+	led_cdev->trigger_data = NULL;
-+	kfree(trigger_data);
-+}
-+
-+static void netdev_trig_deactivate(struct led_classdev *led_cdev)
-+{
-+	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
-+
-+	if (trigger_data) {
-+		unregister_netdevice_notifier(&trigger_data->notifier);
-+
-+		device_remove_file(led_cdev->dev, &dev_attr_device_name);
-+		device_remove_file(led_cdev->dev, &dev_attr_link);
-+		device_remove_file(led_cdev->dev, &dev_attr_rx);
-+		device_remove_file(led_cdev->dev, &dev_attr_tx);
-+		device_remove_file(led_cdev->dev, &dev_attr_interval);
-+
-+		cancel_delayed_work_sync(&trigger_data->work);
-+
-+		if (trigger_data->net_dev)
-+			dev_put(trigger_data->net_dev);
-+
-+		kfree(trigger_data);
-+	}
-+}
-+
-+static struct led_trigger netdev_led_trigger = {
-+	.name = "netdev",
-+	.activate = netdev_trig_activate,
-+	.deactivate = netdev_trig_deactivate,
-+};
-+
-+static int __init netdev_trig_init(void)
-+{
-+	return led_trigger_register(&netdev_led_trigger);
-+}
-+
-+static void __exit netdev_trig_exit(void)
-+{
-+	led_trigger_unregister(&netdev_led_trigger);
-+}
-+
-+module_init(netdev_trig_init);
-+module_exit(netdev_trig_exit);
-+
-+MODULE_AUTHOR("Ben Whitten <ben.whitten@gmail.com>");
-+MODULE_AUTHOR("Oliver Jowett <oliver@opencloud.com>");
-+MODULE_DESCRIPTION("Netdev LED trigger");
-+MODULE_LICENSE("GPL v2");
--- a/target/linux/generic/backport-4.9/400-v4.18-mtd-bcm47xxpart-add-of_match_table-with-a-new-DT-bin.patch	2022-03-22 08:54:47.110464508 +0800
+++ b/target/linux/generic/backport-4.9/400-v4.18-mtd-bcm47xxpart-add-of_match_table-with-a-new-DT-bin.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,47 +0,0 @@
-From cf589ce71e84d3b8811c65740645af254c5248c0 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Wed, 9 May 2018 10:17:29 +0200
-Subject: [PATCH] mtd: bcm47xxpart: add of_match_table with a new DT binding
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-This allows using bcm47xxpart parser to find partitions on flash
-described in DT using the "brcm,bcm947xx-cfe-partitions" compatible
-property. It means this parser doesn't have to be explicitly selected by
-a flash driver anymore. It can be used e.g. together with a generic
-m25p80 / spi-nor if device is just properly described.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
----
- drivers/mtd/bcm47xxpart.c | 7 +++++++
- 1 file changed, 7 insertions(+)
-
---- a/drivers/mtd/bcm47xxpart.c
-+++ b/drivers/mtd/bcm47xxpart.c
-@@ -15,6 +15,7 @@
- #include <linux/slab.h>
- #include <linux/mtd/mtd.h>
- #include <linux/mtd/partitions.h>
-+#include <linux/mod_devicetable.h>
- 
- #include <uapi/linux/magic.h>
- 
-@@ -304,9 +305,16 @@ static int bcm47xxpart_parse(struct mtd_
- 	return curr_part;
- };
- 
-+static const struct of_device_id bcm47xxpart_of_match_table[] = {
-+	{ .compatible = "brcm,bcm947xx-cfe-partitions" },
-+	{},
-+};
-+MODULE_DEVICE_TABLE(of, bcm47xxpart_of_match_table);
-+
- static struct mtd_part_parser bcm47xxpart_mtd_parser = {
- 	.parse_fn = bcm47xxpart_parse,
- 	.name = "bcm47xxpart",
-+	.of_match_table = bcm47xxpart_of_match_table,
- };
- module_mtd_part_parser(bcm47xxpart_mtd_parser);
- 
--- a/target/linux/generic/backport-4.9/401-v4.19-mtd-parsers-trx-add-of_match_table-with-the-new-DT-b.patch	2022-03-22 08:54:47.110464508 +0800
+++ b/target/linux/generic/backport-4.9/401-v4.19-mtd-parsers-trx-add-of_match_table-with-the-new-DT-b.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,45 +0,0 @@
-From 98534a58c8a40cdc9e3bcb04d74719fbcedfeb52 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Tue, 26 Jun 2018 00:05:08 +0200
-Subject: [PATCH] mtd: parsers: trx: add of_match_table with the new DT binding
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-This allows using TRX parser to find TRX partitions on flash device
-described in DT using a proper binding. It's useful for devices storing
-firmware on a separated flash and having rootfs partition in it.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
----
- drivers/mtd/parsers/parser_trx.c | 7 +++++++
- 1 file changed, 7 insertions(+)
-
---- a/drivers/mtd/parsers/parser_trx.c
-+++ b/drivers/mtd/parsers/parser_trx.c
-@@ -13,6 +13,7 @@
- #include <linux/slab.h>
- #include <linux/mtd/mtd.h>
- #include <linux/mtd/partitions.h>
-+#include <linux/mod_devicetable.h>
- 
- #define TRX_PARSER_MAX_PARTS		4
- 
-@@ -116,9 +117,16 @@ static int parser_trx_parse(struct mtd_i
- 	return i;
- };
- 
-+static const struct of_device_id mtd_parser_trx_of_match_table[] = {
-+	{ .compatible = "brcm,trx" },
-+	{},
-+};
-+MODULE_DEVICE_TABLE(of, mtd_parser_trx_of_match_table);
-+
- static struct mtd_part_parser mtd_parser_trx = {
- 	.parse_fn = parser_trx_parse,
- 	.name = "trx",
-+	.of_match_table = mtd_parser_trx_of_match_table,
- };
- module_mtd_part_parser(mtd_parser_trx);
- 
--- a/target/linux/generic/backport-4.9/402-v4.19-mtd-partitions-use-DT-info-for-parsing-partitions-wi.patch	2022-03-22 08:54:47.111464509 +0800
+++ b/target/linux/generic/backport-4.9/402-v4.19-mtd-partitions-use-DT-info-for-parsing-partitions-wi.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,102 +0,0 @@
-From 76a832254ab05502c9394cc51ded6f0abe0e0bee Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Fri, 13 Jul 2018 16:32:21 +0200
-Subject: [PATCH] mtd: partitions: use DT info for parsing partitions with
- "compatible" prop
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-So far only flash devices could be described in DT regarding partitions
-parsing. That could be done with "partitions" subnode and a proper
-"compatible" string.
-
-Some devices may use hierarchical (multi-level) layouts and may mix used
-layouts (fixed and dynamic). Describing that in DT is done by specifying
-"compatible" for DT-represented partition plus optionally more
-properties and/or subnodes.
-
-To support such layouts each DT partition has to be checked for
-additional description.
-
-Please note this implementation will work in parallel with support for
-partition type specified for non-DT setups. That already works since
-commit 1a0915be1926 ("mtd: partitions: add support for partition
-parsers").
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
-Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
----
- drivers/mtd/mtdpart.c | 33 +++++++++++++--------------------
- 1 file changed, 13 insertions(+), 20 deletions(-)
-
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -370,22 +370,6 @@ static inline void free_partition(struct
- 	kfree(p);
- }
- 
--/**
-- * mtd_parse_part - parse MTD partition looking for subpartitions
-- *
-- * @slave: part that is supposed to be a container and should be parsed
-- * @types: NULL-terminated array with names of partition parsers to try
-- *
-- * Some partitions are kind of containers with extra subpartitions (volumes).
-- * There can be various formats of such containers. This function tries to use
-- * specified parsers to analyze given partition and registers found
-- * subpartitions on success.
-- */
--static int mtd_parse_part(struct mtd_part *slave, const char *const *types)
--{
--	return parse_mtd_partitions(&slave->mtd, types, NULL);
--}
--
- static struct mtd_part *allocate_partition(struct mtd_info *parent,
- 			const struct mtd_partition *part, int partno,
- 			uint64_t cur_offset)
-@@ -795,8 +779,8 @@ int add_mtd_partitions(struct mtd_info *
- 		}
- 
- 		mtd_add_partition_attrs(slave);
--		if (parts[i].types)
--			mtd_parse_part(slave, parts[i].types);
-+		/* Look for subpartitions */
-+		parse_mtd_partitions(&slave->mtd, parts[i].types, NULL);
- 
- 		cur_offset = slave->offset + slave->mtd.size;
- 	}
-@@ -877,6 +861,12 @@ static const char * const default_mtd_pa
- 	NULL
- };
- 
-+/* Check DT only when looking for subpartitions. */
-+static const char * const default_subpartition_types[] = {
-+	"ofpart",
-+	NULL
-+};
-+
- static int mtd_part_do_parse(struct mtd_part_parser *parser,
- 			     struct mtd_info *master,
- 			     struct mtd_partitions *pparts,
-@@ -947,7 +937,9 @@ static int mtd_part_of_parse(struct mtd_
- 	const char *fixed = "fixed-partitions";
- 	int ret, err = 0;
- 
--	np = of_get_child_by_name(mtd_get_of_node(master), "partitions");
-+	np = mtd_get_of_node(master);
-+	if (!mtd_is_partition(master))
-+		np = of_get_child_by_name(np, "partitions");
- 	of_property_for_each_string(np, "compatible", prop, compat) {
- 		parser = mtd_part_get_compatible_parser(compat);
- 		if (!parser)
-@@ -1010,7 +1002,8 @@ int parse_mtd_partitions(struct mtd_info
- 	int ret, err = 0;
- 
- 	if (!types)
--		types = default_mtd_part_types;
-+		types = mtd_is_partition(master) ? default_subpartition_types :
-+			default_mtd_part_types;
- 
- 	for ( ; *types; types++) {
- 		/*
--- a/target/linux/generic/config-3.18	2022-03-22 08:54:47.115464516 +0800
+++ b/target/linux/generic/config-3.18	1970-01-01 08:00:00.000000000 +0800
@@ -1,4656 +0,0 @@
-CONFIG_32BIT=y
-# CONFIG_6LOWPAN is not set
-# CONFIG_6PACK is not set
-# CONFIG_8139CP is not set
-# CONFIG_8139TOO is not set
-# CONFIG_9P_FS is not set
-# CONFIG_AB3100_CORE is not set
-# CONFIG_AB8500_CORE is not set
-# CONFIG_ABX500_CORE is not set
-# CONFIG_ACCESSIBILITY is not set
-# CONFIG_ACENIC is not set
-# CONFIG_ACERHDF is not set
-# CONFIG_ACORN_PARTITION is not set
-# CONFIG_ACPI_APEI is not set
-# CONFIG_ACPI_BUTTON is not set
-# CONFIG_ACPI_CUSTOM_METHOD is not set
-# CONFIG_ACPI_EXTLOG is not set
-# CONFIG_ACPI_HED is not set
-# CONFIG_ACPI_INT3403_THERMAL is not set
-# CONFIG_ACPI_POWER_METER is not set
-# CONFIG_ACPI_QUICKSTART is not set
-# CONFIG_ACPI_REDUCED_HARDWARE_ONLY is not set
-# CONFIG_AD2S1200 is not set
-# CONFIG_AD2S1210 is not set
-# CONFIG_AD2S90 is not set
-# CONFIG_AD5064 is not set
-# CONFIG_AD525X_DPOT is not set
-# CONFIG_AD5360 is not set
-# CONFIG_AD5380 is not set
-# CONFIG_AD5421 is not set
-# CONFIG_AD5446 is not set
-# CONFIG_AD5449 is not set
-# CONFIG_AD5504 is not set
-# CONFIG_AD5624R_SPI is not set
-# CONFIG_AD5686 is not set
-# CONFIG_AD5755 is not set
-# CONFIG_AD5764 is not set
-# CONFIG_AD5791 is not set
-# CONFIG_AD5930 is not set
-# CONFIG_AD5933 is not set
-# CONFIG_AD7150 is not set
-# CONFIG_AD7152 is not set
-# CONFIG_AD7192 is not set
-# CONFIG_AD7266 is not set
-# CONFIG_AD7280 is not set
-# CONFIG_AD7291 is not set
-# CONFIG_AD7298 is not set
-# CONFIG_AD7303 is not set
-# CONFIG_AD7476 is not set
-# CONFIG_AD7606 is not set
-# CONFIG_AD7746 is not set
-# CONFIG_AD7780 is not set
-# CONFIG_AD7791 is not set
-# CONFIG_AD7793 is not set
-# CONFIG_AD7816 is not set
-# CONFIG_AD7887 is not set
-# CONFIG_AD7923 is not set
-# CONFIG_AD799X is not set
-# CONFIG_AD8366 is not set
-# CONFIG_AD9523 is not set
-# CONFIG_AD9832 is not set
-# CONFIG_AD9834 is not set
-# CONFIG_AD9850 is not set
-# CONFIG_AD9852 is not set
-# CONFIG_AD9910 is not set
-# CONFIG_AD9951 is not set
-# CONFIG_ADAPTEC_STARFIRE is not set
-# CONFIG_ADE7753 is not set
-# CONFIG_ADE7754 is not set
-# CONFIG_ADE7758 is not set
-# CONFIG_ADE7759 is not set
-# CONFIG_ADE7854 is not set
-# CONFIG_ADF4350 is not set
-# CONFIG_ADFS_FS is not set
-# CONFIG_ADIS16060 is not set
-# CONFIG_ADIS16080 is not set
-# CONFIG_ADIS16130 is not set
-# CONFIG_ADIS16136 is not set
-# CONFIG_ADIS16201 is not set
-# CONFIG_ADIS16203 is not set
-# CONFIG_ADIS16204 is not set
-# CONFIG_ADIS16209 is not set
-# CONFIG_ADIS16220 is not set
-# CONFIG_ADIS16240 is not set
-# CONFIG_ADIS16255 is not set
-# CONFIG_ADIS16260 is not set
-# CONFIG_ADIS16400 is not set
-# CONFIG_ADIS16480 is not set
-# CONFIG_ADJD_S311 is not set
-# CONFIG_ADM6996_PHY is not set
-# CONFIG_ADM8211 is not set
-# CONFIG_ADT7316 is not set
-CONFIG_ADVISE_SYSCALLS=y
-# CONFIG_ADXRS450 is not set
-CONFIG_AEABI=y
-# CONFIG_AFFS_FS is not set
-# CONFIG_AFS_FS is not set
-# CONFIG_AF_RXRPC is not set
-# CONFIG_AGP is not set
-# CONFIG_AHCI_MVEBU is not set
-CONFIG_AIO=y
-# CONFIG_AIRO is not set
-# CONFIG_AIRO_CS is not set
-# CONFIG_AIX_PARTITION is not set
-# CONFIG_AK09911 is not set
-# CONFIG_AK8975 is not set
-# CONFIG_AL3320A is not set
-# CONFIG_ALCHEMY_GPIO_INDIRECT is not set
-# CONFIG_ALIM7101_WDT is not set
-CONFIG_ALLOW_DEV_COREDUMP=y
-# CONFIG_ALTERA_STAPL is not set
-# CONFIG_ALTERA_TSE is not set
-# CONFIG_ALX is not set
-# CONFIG_AM335X_PHY_USB is not set
-# CONFIG_AMD8111_ETH is not set
-# CONFIG_AMD_PHY is not set
-# CONFIG_AMD_XGBE is not set
-# CONFIG_AMD_XGBE_PHY is not set
-# CONFIG_AMIGA_PARTITION is not set
-# CONFIG_AMILO_RFKILL is not set
-# CONFIG_ANDROID is not set
-CONFIG_ANON_INODES=y
-# CONFIG_APDS9300 is not set
-# CONFIG_APDS9802ALS is not set
-# CONFIG_APM8018X is not set
-# CONFIG_APPLICOM is not set
-# CONFIG_AR5523 is not set
-# CONFIG_AR7 is not set
-# CONFIG_AR8216_PHY is not set
-# CONFIG_AR8216_PHY_LEDS is not set
-# CONFIG_ARCH_AT91 is not set
-# CONFIG_ARCH_BCM is not set
-# CONFIG_ARCH_BCM2835 is not set
-# CONFIG_ARCH_BCMRING is not set
-# CONFIG_ARCH_BERLIN is not set
-# CONFIG_ARCH_CLPS711X is not set
-# CONFIG_ARCH_CNS3XXX is not set
-# CONFIG_ARCH_DAVINCI is not set
-# CONFIG_ARCH_DMA_ADDR_T_64BIT is not set
-# CONFIG_ARCH_DOVE is not set
-# CONFIG_ARCH_EBSA110 is not set
-# CONFIG_ARCH_EP93XX is not set
-# CONFIG_ARCH_EXYNOS is not set
-CONFIG_ARCH_FLATMEM_ENABLE=y
-# CONFIG_ARCH_FOOTBRIDGE is not set
-# CONFIG_ARCH_GEMINI is not set
-# CONFIG_ARCH_H720X is not set
-# CONFIG_ARCH_HAS_ILOG2_U32 is not set
-# CONFIG_ARCH_HAS_ILOG2_U64 is not set
-# CONFIG_ARCH_HI3xxx is not set
-# CONFIG_ARCH_HIGHBANK is not set
-# CONFIG_ARCH_HISI is not set
-# CONFIG_ARCH_INTEGRATOR is not set
-# CONFIG_ARCH_IOP13XX is not set
-# CONFIG_ARCH_IOP32X is not set
-# CONFIG_ARCH_IOP33X is not set
-# CONFIG_ARCH_IXP2000 is not set
-# CONFIG_ARCH_IXP23XX is not set
-# CONFIG_ARCH_IXP4XX is not set
-# CONFIG_ARCH_KEYSTONE is not set
-# CONFIG_ARCH_KIRKWOOD is not set
-# CONFIG_ARCH_KS8695 is not set
-# CONFIG_ARCH_LPC32XX is not set
-# CONFIG_ARCH_MEDIATEK is not set
-# CONFIG_ARCH_MESON is not set
-# CONFIG_ARCH_MMP is not set
-# CONFIG_ARCH_MSM is not set
-# CONFIG_ARCH_MSM_DT is not set
-# CONFIG_ARCH_MSM_NODT is not set
-# CONFIG_ARCH_MULTIPLATFORM is not set
-# CONFIG_ARCH_MULTI_V6 is not set
-# CONFIG_ARCH_MULTI_V7 is not set
-# CONFIG_ARCH_MV78XX0 is not set
-# CONFIG_ARCH_MVEBU is not set
-# CONFIG_ARCH_MXC is not set
-# CONFIG_ARCH_MXS is not set
-# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
-# CONFIG_ARCH_NETX is not set
-# CONFIG_ARCH_NOMADIK is not set
-# CONFIG_ARCH_NSPIRE is not set
-# CONFIG_ARCH_NUC93X is not set
-# CONFIG_ARCH_OMAP is not set
-# CONFIG_ARCH_OMAP1 is not set
-# CONFIG_ARCH_OMAP2PLUS is not set
-# CONFIG_ARCH_OMAP3 is not set
-# CONFIG_ARCH_OMAP4 is not set
-# CONFIG_ARCH_ORION5X is not set
-# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
-# CONFIG_ARCH_PICOXCELL is not set
-# CONFIG_ARCH_PNX4008 is not set
-# CONFIG_ARCH_PRIMA2 is not set
-# CONFIG_ARCH_PXA is not set
-# CONFIG_ARCH_QCOM is not set
-# CONFIG_ARCH_REALVIEW is not set
-# CONFIG_ARCH_ROCKCHIP is not set
-# CONFIG_ARCH_RPC is not set
-# CONFIG_ARCH_S3C24XX is not set
-# CONFIG_ARCH_S3C64XX is not set
-# CONFIG_ARCH_S5P64X0 is not set
-# CONFIG_ARCH_S5PC100 is not set
-# CONFIG_ARCH_S5PV210 is not set
-# CONFIG_ARCH_SA1100 is not set
-# CONFIG_ARCH_SHARK is not set
-# CONFIG_ARCH_SHMOBILE is not set
-# CONFIG_ARCH_SHMOBILE_LEGACY is not set
-# CONFIG_ARCH_SHMOBILE_MULTI is not set
-# CONFIG_ARCH_SIRF is not set
-# CONFIG_ARCH_SOCFPGA is not set
-# CONFIG_ARCH_STI is not set
-# CONFIG_ARCH_SUNXI is not set
-# CONFIG_ARCH_SUPPORTS_MSI is not set
-# CONFIG_ARCH_TCC_926 is not set
-# CONFIG_ARCH_TEGRA is not set
-# CONFIG_ARCH_U300 is not set
-# CONFIG_ARCH_U8500 is not set
-# CONFIG_ARCH_VERSATILE is not set
-# CONFIG_ARCH_VEXPRESS is not set
-# CONFIG_ARCH_VIRT is not set
-# CONFIG_ARCH_VT8500 is not set
-# CONFIG_ARCH_W90X900 is not set
-# CONFIG_ARCH_WM8505 is not set
-# CONFIG_ARCH_WM8850 is not set
-# CONFIG_ARCH_ZYNQ is not set
-# CONFIG_ARCNET is not set
-# CONFIG_ARC_EMAC is not set
-# CONFIG_ARM_APPENDED_DTB is not set
-# CONFIG_ARM_ARCH_TIMER is not set
-# CONFIG_ARM_AT91_ETHER is not set
-# CONFIG_ARM_CCI is not set
-# CONFIG_ARM_CCN is not set
-CONFIG_ARM_CPU_TOPOLOGY=y
-CONFIG_ARM_DMA_MEM_BUFFERABLE=y
-# CONFIG_ARM_ERRATA_326103 is not set
-# CONFIG_ARM_ERRATA_364296 is not set
-# CONFIG_ARM_ERRATA_411920 is not set
-# CONFIG_ARM_ERRATA_430973 is not set
-# CONFIG_ARM_ERRATA_458693 is not set
-# CONFIG_ARM_ERRATA_460075 is not set
-# CONFIG_ARM_ERRATA_643719 is not set
-# CONFIG_ARM_ERRATA_720789 is not set
-# CONFIG_ARM_ERRATA_742230 is not set
-# CONFIG_ARM_ERRATA_742231 is not set
-# CONFIG_ARM_ERRATA_743622 is not set
-# CONFIG_ARM_ERRATA_751472 is not set
-# CONFIG_ARM_ERRATA_754322 is not set
-# CONFIG_ARM_ERRATA_754327 is not set
-# CONFIG_ARM_ERRATA_764369 is not set
-# CONFIG_ARM_ERRATA_773022 is not set
-# CONFIG_ARM_ERRATA_775420 is not set
-# CONFIG_ARM_ERRATA_798181 is not set
-# CONFIG_ARM_KPROBES_TEST is not set
-# CONFIG_ARM_PATCH_PHYS_VIRT is not set
-# CONFIG_ARM_PSCI is not set
-# CONFIG_ARM_PTDUMP is not set
-# CONFIG_ARM_UNWIND is not set
-# CONFIG_ARM_VIRT_EXT is not set
-CONFIG_ARPD=y
-# CONFIG_ARTHUR is not set
-# CONFIG_AS3935 is not set
-# CONFIG_ASUS_OLED is not set
-# CONFIG_ASYMMETRIC_KEY_TYPE is not set
-# CONFIG_ASYNC_RAID6_TEST is not set
-# CONFIG_ASYNC_TX_DMA is not set
-# CONFIG_AT76C50X_USB is not set
-# CONFIG_AT803X_PHY is not set
-# CONFIG_ATA is not set
-# CONFIG_ATAGS is not set
-CONFIG_ATAGS_PROC=y
-# CONFIG_ATALK is not set
-# CONFIG_ATARI_PARTITION is not set
-# CONFIG_ATA_ACPI is not set
-CONFIG_ATA_BMDMA=y
-# CONFIG_ATA_GENERIC is not set
-# CONFIG_ATA_NONSTANDARD is not set
-# CONFIG_ATA_OVER_ETH is not set
-# CONFIG_ATA_PIIX is not set
-CONFIG_ATA_SFF=y
-# CONFIG_ATA_VERBOSE_ERROR is not set
-# CONFIG_ATH10K is not set
-# CONFIG_ATH5K is not set
-# CONFIG_ATH6KL is not set
-# CONFIG_ATH6K_LEGACY is not set
-# CONFIG_ATH79 is not set
-# CONFIG_ATH9K is not set
-# CONFIG_ATH9K_HTC is not set
-# CONFIG_ATH_CARDS is not set
-# CONFIG_ATH_DEBUG is not set
-# CONFIG_ATL1 is not set
-# CONFIG_ATL1C is not set
-# CONFIG_ATL1E is not set
-# CONFIG_ATL2 is not set
-# CONFIG_ATM is not set
-# CONFIG_ATMEL is not set
-# CONFIG_ATMEL_PIT is not set
-# CONFIG_ATMEL_PWM is not set
-# CONFIG_ATMEL_SSC is not set
-# CONFIG_ATM_AMBASSADOR is not set
-# CONFIG_ATM_BR2684 is not set
-CONFIG_ATM_BR2684_IPFILTER=y
-# CONFIG_ATM_CLIP is not set
-CONFIG_ATM_CLIP_NO_ICMP=y
-# CONFIG_ATM_DRIVERS is not set
-# CONFIG_ATM_DUMMY is not set
-# CONFIG_ATM_ENI is not set
-# CONFIG_ATM_FIRESTREAM is not set
-# CONFIG_ATM_FORE200E is not set
-# CONFIG_ATM_HE is not set
-# CONFIG_ATM_HORIZON is not set
-# CONFIG_ATM_IA is not set
-# CONFIG_ATM_IDT77252 is not set
-# CONFIG_ATM_LANAI is not set
-# CONFIG_ATM_LANE is not set
-# CONFIG_ATM_MPOA is not set
-# CONFIG_ATM_NICSTAR is not set
-# CONFIG_ATM_SOLOS is not set
-# CONFIG_ATM_TCP is not set
-# CONFIG_ATM_ZATM is not set
-# CONFIG_ATOMIC64_SELFTEST is not set
-# CONFIG_ATP is not set
-# CONFIG_AUDIT is not set
-# CONFIG_AUDIT_ARCH_COMPAT_GENERIC is not set
-# CONFIG_AUDIT_LOGINUID_IMMUTABLE is not set
-# CONFIG_AUTOFS4_FS is not set
-# CONFIG_AUTO_ZRELADDR is not set
-# CONFIG_AUXDISPLAY is not set
-# CONFIG_AVERAGE is not set
-# CONFIG_AX25 is not set
-# CONFIG_AX25_DAMA_SLAVE is not set
-# CONFIG_AX88796 is not set
-# CONFIG_B43 is not set
-# CONFIG_B43LEGACY is not set
-# CONFIG_B44 is not set
-# CONFIG_BACKLIGHT_BD6107 is not set
-# CONFIG_BACKLIGHT_GPIO is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
-# CONFIG_BACKLIGHT_LM3630 is not set
-# CONFIG_BACKLIGHT_LM3630A is not set
-# CONFIG_BACKLIGHT_LM3639 is not set
-# CONFIG_BACKLIGHT_LP855X is not set
-# CONFIG_BACKLIGHT_LV5207LP is not set
-# CONFIG_BACKLIGHT_PANDORA is not set
-# CONFIG_BACKLIGHT_SAHARA is not set
-# CONFIG_BACKTRACE_SELF_TEST is not set
-CONFIG_BASE_FULL=y
-CONFIG_BASE_SMALL=0
-# CONFIG_BATMAN_ADV is not set
-# CONFIG_BATTERY_BQ27x00 is not set
-# CONFIG_BATTERY_DS2760 is not set
-# CONFIG_BATTERY_DS2780 is not set
-# CONFIG_BATTERY_DS2781 is not set
-# CONFIG_BATTERY_DS2782 is not set
-# CONFIG_BATTERY_GOLDFISH is not set
-# CONFIG_BATTERY_MAX17040 is not set
-# CONFIG_BATTERY_MAX17042 is not set
-# CONFIG_BATTERY_SBS is not set
-# CONFIG_BAYCOM_EPP is not set
-# CONFIG_BAYCOM_PAR is not set
-# CONFIG_BAYCOM_SER_FDX is not set
-# CONFIG_BAYCOM_SER_HDX is not set
-# CONFIG_BCACHE is not set
-# CONFIG_BCM47XX is not set
-# CONFIG_BCM63XX is not set
-# CONFIG_BCM63XX_PHY is not set
-# CONFIG_BCM7XXX_PHY is not set
-# CONFIG_BCM87XX_PHY is not set
-# CONFIG_BCMA is not set
-# CONFIG_BCMA_DRIVER_GPIO is not set
-CONFIG_BCMA_POSSIBLE=y
-# CONFIG_BCMGENET is not set
-# CONFIG_BCM_KONA_USB2_PHY is not set
-# CONFIG_BCM_WIMAX is not set
-# CONFIG_BDI_SWITCH is not set
-# CONFIG_BE2ISCSI is not set
-# CONFIG_BE2NET is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_BGMAC is not set
-# CONFIG_BIG_KEYS is not set
-# CONFIG_BIG_LITTLE is not set
-# CONFIG_BINARY_PRINTF is not set
-# CONFIG_BINFMT_AOUT is not set
-CONFIG_BINFMT_ELF=y
-# CONFIG_BINFMT_MISC is not set
-CONFIG_BINFMT_SCRIPT=y
-CONFIG_BITREVERSE=y
-# CONFIG_BLK_CMDLINE_PARSER is not set
-# CONFIG_BLK_CPQ_CISS_DA is not set
-# CONFIG_BLK_CPQ_DA is not set
-CONFIG_BLK_DEV=y
-# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
-# CONFIG_BLK_DEV_4DRIVES is not set
-# CONFIG_BLK_DEV_AEC62XX is not set
-# CONFIG_BLK_DEV_ALI14XX is not set
-# CONFIG_BLK_DEV_ALI15X3 is not set
-# CONFIG_BLK_DEV_AMD74XX is not set
-# CONFIG_BLK_DEV_ATIIXP is not set
-# CONFIG_BLK_DEV_BSG is not set
-# CONFIG_BLK_DEV_BSGLIB is not set
-# CONFIG_BLK_DEV_CMD640 is not set
-# CONFIG_BLK_DEV_CMD64X is not set
-# CONFIG_BLK_DEV_COW_COMMON is not set
-# CONFIG_BLK_DEV_CRYPTOLOOP is not set
-# CONFIG_BLK_DEV_CS5520 is not set
-# CONFIG_BLK_DEV_CS5530 is not set
-# CONFIG_BLK_DEV_CS5535 is not set
-# CONFIG_BLK_DEV_CS5536 is not set
-# CONFIG_BLK_DEV_CY82C693 is not set
-# CONFIG_BLK_DEV_DAC960 is not set
-# CONFIG_BLK_DEV_DELKIN is not set
-# CONFIG_BLK_DEV_DRBD is not set
-# CONFIG_BLK_DEV_DTC2278 is not set
-# CONFIG_BLK_DEV_FD is not set
-# CONFIG_BLK_DEV_GENERIC is not set
-# CONFIG_BLK_DEV_HD is not set
-# CONFIG_BLK_DEV_HPT366 is not set
-# CONFIG_BLK_DEV_HT6560B is not set
-# CONFIG_BLK_DEV_IDEACPI is not set
-# CONFIG_BLK_DEV_IDECD is not set
-# CONFIG_BLK_DEV_IDECS is not set
-# CONFIG_BLK_DEV_IDEPCI is not set
-# CONFIG_BLK_DEV_IDEPNP is not set
-# CONFIG_BLK_DEV_IDETAPE is not set
-# CONFIG_BLK_DEV_IDE_AU1XXX is not set
-# CONFIG_BLK_DEV_IDE_SATA is not set
-CONFIG_BLK_DEV_INITRD=y
-# CONFIG_BLK_DEV_INTEGRITY is not set
-# CONFIG_BLK_DEV_IO_TRACE is not set
-# CONFIG_BLK_DEV_IT8172 is not set
-# CONFIG_BLK_DEV_IT8213 is not set
-# CONFIG_BLK_DEV_IT821X is not set
-# CONFIG_BLK_DEV_JMICRON is not set
-# CONFIG_BLK_DEV_LOOP is not set
-CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
-# CONFIG_BLK_DEV_NBD is not set
-# CONFIG_BLK_DEV_NS87415 is not set
-# CONFIG_BLK_DEV_NULL_BLK is not set
-# CONFIG_BLK_DEV_NVME is not set
-# CONFIG_BLK_DEV_OFFBOARD is not set
-# CONFIG_BLK_DEV_OPTI621 is not set
-# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
-# CONFIG_BLK_DEV_PDC202XX_NEW is not set
-# CONFIG_BLK_DEV_PDC202XX_OLD is not set
-# CONFIG_BLK_DEV_PIIX is not set
-# CONFIG_BLK_DEV_PLATFORM is not set
-# CONFIG_BLK_DEV_QD65XX is not set
-# CONFIG_BLK_DEV_RAM is not set
-# CONFIG_BLK_DEV_RBD is not set
-# CONFIG_BLK_DEV_RSXX is not set
-# CONFIG_BLK_DEV_RZ1000 is not set
-# CONFIG_BLK_DEV_SC1200 is not set
-# CONFIG_BLK_DEV_SD is not set
-# CONFIG_BLK_DEV_SIIMAGE is not set
-# CONFIG_BLK_DEV_SIS5513 is not set
-# CONFIG_BLK_DEV_SKD is not set
-# CONFIG_BLK_DEV_SL82C105 is not set
-# CONFIG_BLK_DEV_SLC90E66 is not set
-# CONFIG_BLK_DEV_SR is not set
-# CONFIG_BLK_DEV_SVWKS is not set
-# CONFIG_BLK_DEV_SX8 is not set
-# CONFIG_BLK_DEV_TC86C001 is not set
-# CONFIG_BLK_DEV_THROTTLING is not set
-# CONFIG_BLK_DEV_TRIFLEX is not set
-# CONFIG_BLK_DEV_TRM290 is not set
-# CONFIG_BLK_DEV_UB is not set
-# CONFIG_BLK_DEV_UMC8672 is not set
-# CONFIG_BLK_DEV_UMEM is not set
-# CONFIG_BLK_DEV_VIA82CXXX is not set
-# CONFIG_BLK_DEV_XIP is not set
-CONFIG_BLOCK=y
-# CONFIG_BMA180 is not set
-# CONFIG_BMC150_ACCEL is not set
-# CONFIG_BMG160 is not set
-# CONFIG_BMP085 is not set
-# CONFIG_BMP085_I2C is not set
-# CONFIG_BMP085_SPI is not set
-# CONFIG_BNA is not set
-# CONFIG_BNX2 is not set
-# CONFIG_BNX2X is not set
-# CONFIG_BONDING is not set
-# CONFIG_BOOKE_WDT is not set
-CONFIG_BOOKE_WDT_DEFAULT_TIMEOUT=3
-# CONFIG_BOOT_PRINTK_DELAY is not set
-CONFIG_BOOT_RAW=y
-# CONFIG_BPCTL is not set
-CONFIG_BPF=y
-# CONFIG_BPF_JIT is not set
-CONFIG_BPF_SYSCALL=y
-# CONFIG_BPQETHER is not set
-CONFIG_BQL=y
-CONFIG_BRANCH_PROFILE_NONE=y
-# CONFIG_BRCMFMAC is not set
-# CONFIG_BRCMSMAC is not set
-# CONFIG_BRCMSTB_GISB_ARB is not set
-CONFIG_BRIDGE=y
-# CONFIG_BRIDGE_EBT_802_3 is not set
-# CONFIG_BRIDGE_EBT_AMONG is not set
-# CONFIG_BRIDGE_EBT_ARP is not set
-# CONFIG_BRIDGE_EBT_ARPREPLY is not set
-# CONFIG_BRIDGE_EBT_BROUTE is not set
-# CONFIG_BRIDGE_EBT_DNAT is not set
-# CONFIG_BRIDGE_EBT_IP is not set
-# CONFIG_BRIDGE_EBT_IP6 is not set
-# CONFIG_BRIDGE_EBT_LIMIT is not set
-# CONFIG_BRIDGE_EBT_LOG is not set
-# CONFIG_BRIDGE_EBT_MARK is not set
-# CONFIG_BRIDGE_EBT_MARK_T is not set
-# CONFIG_BRIDGE_EBT_NFLOG is not set
-# CONFIG_BRIDGE_EBT_PKTTYPE is not set
-# CONFIG_BRIDGE_EBT_REDIRECT is not set
-# CONFIG_BRIDGE_EBT_SNAT is not set
-# CONFIG_BRIDGE_EBT_STP is not set
-# CONFIG_BRIDGE_EBT_T_FILTER is not set
-# CONFIG_BRIDGE_EBT_T_NAT is not set
-# CONFIG_BRIDGE_EBT_ULOG is not set
-# CONFIG_BRIDGE_EBT_VLAN is not set
-CONFIG_BRIDGE_IGMP_SNOOPING=y
-# CONFIG_BRIDGE_NETFILTER is not set
-# CONFIG_BRIDGE_NF_EBTABLES is not set
-# CONFIG_BRIDGE_VLAN_FILTERING is not set
-# CONFIG_BROADCOM_PHY is not set
-CONFIG_BROKEN_ON_SMP=y
-# CONFIG_BSD_DISKLABEL is not set
-# CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_BSD_PROCESS_ACCT_V3 is not set
-# CONFIG_BT is not set
-# CONFIG_BTRFS_ASSERT is not set
-# CONFIG_BTRFS_DEBUG is not set
-# CONFIG_BTRFS_FS is not set
-# CONFIG_BTRFS_FS_POSIX_ACL is not set
-# CONFIG_BTRFS_FS_RUN_SANITY_TESTS is not set
-# CONFIG_BT_ATH3K is not set
-# CONFIG_BT_BNEP is not set
-CONFIG_BT_BNEP_MC_FILTER=y
-CONFIG_BT_BNEP_PROTO_FILTER=y
-# CONFIG_BT_CMTP is not set
-# CONFIG_BT_HCIBCM203X is not set
-# CONFIG_BT_HCIBFUSB is not set
-# CONFIG_BT_HCIBLUECARD is not set
-# CONFIG_BT_HCIBPA10X is not set
-# CONFIG_BT_HCIBT3C is not set
-# CONFIG_BT_HCIBTSDIO is not set
-# CONFIG_BT_HCIBTUART is not set
-# CONFIG_BT_HCIBTUSB is not set
-# CONFIG_BT_HCIDTL1 is not set
-# CONFIG_BT_HCIUART is not set
-# CONFIG_BT_HCIUART_3WIRE is not set
-# CONFIG_BT_HCIUART_ATH3K is not set
-CONFIG_BT_HCIUART_BCSP=y
-CONFIG_BT_HCIUART_H4=y
-# CONFIG_BT_HCIUART_LL is not set
-# CONFIG_BT_HCIVHCI is not set
-# CONFIG_BT_HIDP is not set
-CONFIG_BT_L2CAP=y
-# CONFIG_BT_MRVL is not set
-# CONFIG_BT_RFCOMM is not set
-CONFIG_BT_RFCOMM_TTY=y
-CONFIG_BT_SCO=y
-CONFIG_BUG=y
-CONFIG_BUILDTIME_EXTABLE_SORT=y
-# CONFIG_BUILD_BIN2C is not set
-# CONFIG_C2PORT is not set
-# CONFIG_CADENCE_WATCHDOG is not set
-# CONFIG_CAIF is not set
-# CONFIG_CAN is not set
-# CONFIG_CAN_GS_USB is not set
-# CONFIG_CAN_M_CAN is not set
-# CONFIG_CAN_RCAR is not set
-# CONFIG_CAPI_AVM is not set
-# CONFIG_CAPI_EICON is not set
-# CONFIG_CAPI_TRACE is not set
-CONFIG_CARDBUS=y
-# CONFIG_CARDMAN_4000 is not set
-# CONFIG_CARDMAN_4040 is not set
-# CONFIG_CARL9170 is not set
-# CONFIG_CARMA_FPGA is not set
-# CONFIG_CARMA_FPGA_PROGRAM is not set
-# CONFIG_CASSINI is not set
-CONFIG_CAVIUM_OCTEON_HELPER=y
-# CONFIG_CAVIUM_OCTEON_REFERENCE_BOARD is not set
-# CONFIG_CAVIUM_OCTEON_SIMULATOR is not set
-# CONFIG_CAVIUM_OCTEON_SOC is not set
-# CONFIG_CB710_CORE is not set
-# CONFIG_CC_STACKPROTECTOR is not set
-CONFIG_CC_STACKPROTECTOR_NONE=y
-# CONFIG_CC_STACKPROTECTOR_REGULAR is not set
-# CONFIG_CC_STACKPROTECTOR_STRONG is not set
-# CONFIG_CDROM_PKTCDVD is not set
-# CONFIG_CED1401 is not set
-# CONFIG_CEPH_FS is not set
-# CONFIG_CEPH_LIB is not set
-# CONFIG_CFG80211 is not set
-# CONFIG_CFG80211_CERTIFICATION_ONUS is not set
-# CONFIG_CFG80211_DEBUGFS is not set
-# CONFIG_CFG80211_DEFAULT_PS is not set
-# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
-# CONFIG_CFG80211_INTERNAL_REGDB is not set
-# CONFIG_CFG80211_REG_DEBUG is not set
-# CONFIG_CFG80211_WEXT is not set
-# CONFIG_CGROUPS is not set
-# CONFIG_CGROUP_DEBUG is not set
-# CONFIG_CGROUP_NET_PRIO is not set
-# CONFIG_CHARGER_BQ2415X is not set
-# CONFIG_CHARGER_BQ24190 is not set
-# CONFIG_CHARGER_BQ24735 is not set
-# CONFIG_CHARGER_GPIO is not set
-# CONFIG_CHARGER_ISP1704 is not set
-# CONFIG_CHARGER_LP8727 is not set
-# CONFIG_CHARGER_MANAGER is not set
-# CONFIG_CHARGER_MAX8903 is not set
-# CONFIG_CHARGER_SMB347 is not set
-# CONFIG_CHARGER_TWL4030 is not set
-# CONFIG_CHECKPOINT_RESTORE is not set
-# CONFIG_CHELSIO_T1 is not set
-# CONFIG_CHELSIO_T3 is not set
-# CONFIG_CHELSIO_T4 is not set
-# CONFIG_CHELSIO_T4VF is not set
-# CONFIG_CHROME_PLATFORMS is not set
-# CONFIG_CHR_DEV_OSST is not set
-# CONFIG_CHR_DEV_SCH is not set
-# CONFIG_CHR_DEV_SG is not set
-# CONFIG_CHR_DEV_ST is not set
-# CONFIG_CICADA_PHY is not set
-# CONFIG_CIFS is not set
-# CONFIG_CIFS_ACL is not set
-# CONFIG_CIFS_DEBUG is not set
-# CONFIG_CIFS_DEBUG2 is not set
-# CONFIG_CIFS_FSCACHE is not set
-# CONFIG_CIFS_NFSD_EXPORT is not set
-CONFIG_CIFS_POSIX=y
-# CONFIG_CIFS_SMB2 is not set
-CONFIG_CIFS_STATS=y
-# CONFIG_CIFS_STATS2 is not set
-# CONFIG_CIFS_WEAK_PW_HASH is not set
-# CONFIG_CIFS_XATTR is not set
-# CONFIG_CLEANCACHE is not set
-# CONFIG_CLKSRC_VERSATILE is not set
-CONFIG_CLS_U32_MARK=y
-# CONFIG_CLS_U32_PERF is not set
-# CONFIG_CM32181 is not set
-# CONFIG_CM36651 is not set
-# CONFIG_CMA is not set
-CONFIG_CMDLINE=""
-# CONFIG_CMDLINE_BOOL is not set
-# CONFIG_CMDLINE_EXTEND is not set
-# CONFIG_CMDLINE_FORCE is not set
-# CONFIG_CMDLINE_FROM_BOOTLOADER is not set
-# CONFIG_CMDLINE_PARTITION is not set
-# CONFIG_CNIC is not set
-# CONFIG_CODA_FS is not set
-# CONFIG_CODE_PATCHING_SELFTEST is not set
-# CONFIG_COMEDI is not set
-# CONFIG_COMMON_CLK_DEBUG is not set
-# CONFIG_COMMON_CLK_PXA is not set
-# CONFIG_COMMON_CLK_QCOM is not set
-# CONFIG_COMMON_CLK_SI5351 is not set
-# CONFIG_COMMON_CLK_SI570 is not set
-CONFIG_COMPACTION=y
-# CONFIG_COMPAL_LAPTOP is not set
-# CONFIG_COMPAT_BRK is not set
-# CONFIG_COMPILE_TEST is not set
-# CONFIG_CONFIGFS_FS is not set
-# CONFIG_CONNECTOR is not set
-CONFIG_CONSTRUCTORS=y
-# CONFIG_CONTEXT_SWITCH_TRACER is not set
-# CONFIG_COPS is not set
-# CONFIG_CORDIC is not set
-# CONFIG_COREDUMP is not set
-# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
-# CONFIG_CPA_DEBUG is not set
-# CONFIG_CPU_DCACHE_DISABLE is not set
-# CONFIG_CPU_FREQ is not set
-# CONFIG_CPU_IDLE is not set
-# CONFIG_CPU_IDLE_GOV_MENU is not set
-# CONFIG_CPU_IDLE_MULTIPLE_DRIVERS is not set
-# CONFIG_CRAMFS is not set
-CONFIG_CRASHLOG=y
-# CONFIG_CRASH_DUMP is not set
-# CONFIG_CRC16 is not set
-CONFIG_CRC32=y
-# CONFIG_CRC32_BIT is not set
-CONFIG_CRC32_SARWATE=y
-# CONFIG_CRC32_SELFTEST is not set
-# CONFIG_CRC32_SLICEBY4 is not set
-# CONFIG_CRC32_SLICEBY8 is not set
-# CONFIG_CRC7 is not set
-# CONFIG_CRC8 is not set
-# CONFIG_CRC_CCITT is not set
-# CONFIG_CRC_ITU_T is not set
-# CONFIG_CRC_T10DIF is not set
-CONFIG_CROSS_COMPILE=""
-# CONFIG_CROSS_MEMORY_ATTACH is not set
-CONFIG_CRYPTO=y
-# CONFIG_CRYPTO_AEAD is not set
-CONFIG_CRYPTO_AES=y
-# CONFIG_CRYPTO_AES_586 is not set
-# CONFIG_CRYPTO_AES_ARM is not set
-# CONFIG_CRYPTO_AES_ARM_BS is not set
-# CONFIG_CRYPTO_AES_NI_INTEL is not set
-CONFIG_CRYPTO_ALGAPI=y
-CONFIG_CRYPTO_ALGAPI2=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-# CONFIG_CRYPTO_ANUBIS is not set
-CONFIG_CRYPTO_ARC4=y
-# CONFIG_CRYPTO_AUTHENC is not set
-CONFIG_CRYPTO_BLKCIPHER=y
-CONFIG_CRYPTO_BLKCIPHER2=y
-# CONFIG_CRYPTO_BLOWFISH is not set
-# CONFIG_CRYPTO_CAMELLIA is not set
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
-# CONFIG_CRYPTO_CBC is not set
-# CONFIG_CRYPTO_CCM is not set
-# CONFIG_CRYPTO_CMAC is not set
-# CONFIG_CRYPTO_CRC32 is not set
-# CONFIG_CRYPTO_CRC32C is not set
-# CONFIG_CRYPTO_CRC32C_INTEL is not set
-# CONFIG_CRYPTO_CRCT10DIF is not set
-# CONFIG_CRYPTO_CRYPTD is not set
-# CONFIG_CRYPTO_CTR is not set
-# CONFIG_CRYPTO_CTS is not set
-# CONFIG_CRYPTO_DEFLATE is not set
-# CONFIG_CRYPTO_DES is not set
-# CONFIG_CRYPTO_DEV_ATMEL_AES is not set
-# CONFIG_CRYPTO_DEV_ATMEL_SHA is not set
-# CONFIG_CRYPTO_DEV_ATMEL_TDES is not set
-# CONFIG_CRYPTO_DEV_CCP is not set
-# CONFIG_CRYPTO_DEV_FSL_CAAM is not set
-# CONFIG_CRYPTO_DEV_HIFN_795X is not set
-# CONFIG_CRYPTO_DEV_MV_CESA is not set
-# CONFIG_CRYPTO_DEV_QAT_DH895xCC is not set
-# CONFIG_CRYPTO_DEV_QCE is not set
-# CONFIG_CRYPTO_DEV_SAHARA is not set
-# CONFIG_CRYPTO_DEV_TALITOS is not set
-# CONFIG_CRYPTO_DRBG_CTR is not set
-# CONFIG_CRYPTO_DRBG_MENU is not set
-# CONFIG_CRYPTO_ECB is not set
-# CONFIG_CRYPTO_FCRYPT is not set
-# CONFIG_CRYPTO_FIPS is not set
-# CONFIG_CRYPTO_GCM is not set
-# CONFIG_CRYPTO_GF128MUL is not set
-# CONFIG_CRYPTO_GHASH is not set
-# CONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL is not set
-# CONFIG_CRYPTO_HASH is not set
-# CONFIG_CRYPTO_HMAC is not set
-# CONFIG_CRYPTO_HW is not set
-# CONFIG_CRYPTO_KHAZAD is not set
-# CONFIG_CRYPTO_LRW is not set
-# CONFIG_CRYPTO_LZ4 is not set
-# CONFIG_CRYPTO_LZ4HC is not set
-# CONFIG_CRYPTO_LZO is not set
-# CONFIG_CRYPTO_MANAGER is not set
-# CONFIG_CRYPTO_MANAGER2 is not set
-CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
-# CONFIG_CRYPTO_MCRYPTD is not set
-# CONFIG_CRYPTO_MD4 is not set
-# CONFIG_CRYPTO_MD5 is not set
-# CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_NULL is not set
-# CONFIG_CRYPTO_PCBC is not set
-# CONFIG_CRYPTO_PCOMP is not set
-# CONFIG_CRYPTO_PCOMP2 is not set
-CONFIG_CRYPTO_PCRYPT=y
-# CONFIG_CRYPTO_RMD128 is not set
-# CONFIG_CRYPTO_RMD160 is not set
-# CONFIG_CRYPTO_RMD256 is not set
-# CONFIG_CRYPTO_RMD320 is not set
-# CONFIG_CRYPTO_RNG is not set
-# CONFIG_CRYPTO_SALSA20 is not set
-# CONFIG_CRYPTO_SALSA20_586 is not set
-# CONFIG_CRYPTO_SEED is not set
-# CONFIG_CRYPTO_SEQIV is not set
-# CONFIG_CRYPTO_SERPENT is not set
-# CONFIG_CRYPTO_SHA1 is not set
-# CONFIG_CRYPTO_SHA1_ARM is not set
-# CONFIG_CRYPTO_SHA256 is not set
-# CONFIG_CRYPTO_SHA512 is not set
-# CONFIG_CRYPTO_TEA is not set
-# CONFIG_CRYPTO_TEST is not set
-# CONFIG_CRYPTO_TGR192 is not set
-# CONFIG_CRYPTO_TWOFISH is not set
-# CONFIG_CRYPTO_TWOFISH_586 is not set
-# CONFIG_CRYPTO_TWOFISH_COMMON is not set
-# CONFIG_CRYPTO_USER is not set
-# CONFIG_CRYPTO_USER_API_HASH is not set
-# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
-# CONFIG_CRYPTO_VMAC is not set
-# CONFIG_CRYPTO_WP512 is not set
-# CONFIG_CRYPTO_XCBC is not set
-# CONFIG_CRYPTO_XTS is not set
-# CONFIG_CRYPTO_ZLIB is not set
-# CONFIG_CRYSTALHD is not set
-# CONFIG_CS5535_MFGPT is not set
-# CONFIG_CS89x0 is not set
-# CONFIG_CUSE is not set
-# CONFIG_CW1200 is not set
-# CONFIG_CXL_BASE is not set
-# CONFIG_CXT1E1 is not set
-# CONFIG_CYPRESS_FIRMWARE is not set
-# CONFIG_DAVICOM_PHY is not set
-# CONFIG_DCB is not set
-# CONFIG_DDR is not set
-# CONFIG_DE600 is not set
-# CONFIG_DE620 is not set
-# CONFIG_DEBUG_ATOMIC_SLEEP is not set
-# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
-# CONFIG_DEBUG_BUGVERBOSE is not set
-# CONFIG_DEBUG_CREDENTIALS is not set
-# CONFIG_DEBUG_DEVRES is not set
-# CONFIG_DEBUG_DRIVER is not set
-# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
-CONFIG_DEBUG_FS=y
-# CONFIG_DEBUG_GPIO is not set
-# CONFIG_DEBUG_HIGHMEM is not set
-# CONFIG_DEBUG_ICEDCC is not set
-# CONFIG_DEBUG_INFO is not set
-# CONFIG_DEBUG_INFO_DWARF4 is not set
-CONFIG_DEBUG_INFO_REDUCED=y
-# CONFIG_DEBUG_INFO_SPLIT is not set
-CONFIG_DEBUG_KERNEL=y
-# CONFIG_DEBUG_KMEMLEAK is not set
-# CONFIG_DEBUG_KOBJECT is not set
-# CONFIG_DEBUG_KOBJECT_RELEASE is not set
-# CONFIG_DEBUG_LIST is not set
-# CONFIG_DEBUG_LL is not set
-# CONFIG_DEBUG_LL_UART_8250 is not set
-# CONFIG_DEBUG_LL_UART_PL01X is not set
-# CONFIG_DEBUG_LOCKDEP is not set
-# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
-# CONFIG_DEBUG_LOCK_ALLOC is not set
-# CONFIG_DEBUG_MEMORY_INIT is not set
-# CONFIG_DEBUG_MUTEXES is not set
-# CONFIG_DEBUG_NOTIFIERS is not set
-# CONFIG_DEBUG_NX_TEST is not set
-# CONFIG_DEBUG_OBJECTS is not set
-# CONFIG_DEBUG_PAGEALLOC is not set
-# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
-# CONFIG_DEBUG_PER_CPU_MAPS is not set
-# CONFIG_DEBUG_PINCTRL is not set
-# CONFIG_DEBUG_PI_LIST is not set
-# CONFIG_DEBUG_PREEMPT is not set
-# CONFIG_DEBUG_RODATA is not set
-# CONFIG_DEBUG_RT_MUTEXES is not set
-# CONFIG_DEBUG_SECTION_MISMATCH is not set
-# CONFIG_DEBUG_SEMIHOSTING is not set
-# CONFIG_DEBUG_SET_MODULE_RONX is not set
-# CONFIG_DEBUG_SG is not set
-# CONFIG_DEBUG_SHIRQ is not set
-# CONFIG_DEBUG_SLAB is not set
-# CONFIG_DEBUG_SPINLOCK is not set
-# CONFIG_DEBUG_STACKOVERFLOW is not set
-# CONFIG_DEBUG_STACK_USAGE is not set
-# CONFIG_DEBUG_STRICT_USER_COPY_CHECKS is not set
-# CONFIG_DEBUG_UART_BCM63XX is not set
-# CONFIG_DEBUG_VM is not set
-# CONFIG_DEBUG_WRITECOUNT is not set
-# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
-# CONFIG_DEBUG_ZBOOT is not set
-# CONFIG_DECNET is not set
-CONFIG_DEFAULT_CUBIC=y
-CONFIG_DEFAULT_DEADLINE=y
-CONFIG_DEFAULT_HOSTNAME="(none)"
-CONFIG_DEFAULT_IOSCHED="deadline"
-CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
-CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
-# CONFIG_DEFAULT_NOOP is not set
-# CONFIG_DEFAULT_RENO is not set
-CONFIG_DEFAULT_SECURITY=""
-CONFIG_DEFAULT_SECURITY_DAC=y
-CONFIG_DEFAULT_TCP_CONG="cubic"
-CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
-# CONFIG_DELL_SMO8800 is not set
-# CONFIG_DEPRECATED_PARAM_STRUCT is not set
-# CONFIG_DETECT_HUNG_TASK is not set
-# CONFIG_DEVKMEM is not set
-CONFIG_DEVPORT=y
-# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
-# CONFIG_DEVTMPFS is not set
-# CONFIG_DEVTMPFS_MOUNT is not set
-# CONFIG_DGAP is not set
-# CONFIG_DGNC is not set
-# CONFIG_DGRP is not set
-# CONFIG_DHT11 is not set
-CONFIG_DISABLE_DEV_COREDUMP=y
-# CONFIG_DISCONTIGMEM_MANUAL is not set
-# CONFIG_DISPLAY_CONNECTOR_ANALOG_TV is not set
-# CONFIG_DISPLAY_CONNECTOR_DVI is not set
-# CONFIG_DISPLAY_CONNECTOR_HDMI is not set
-# CONFIG_DISPLAY_ENCODER_TFP410 is not set
-# CONFIG_DISPLAY_ENCODER_TPD12S015 is not set
-# CONFIG_DISPLAY_PANEL_DPI is not set
-# CONFIG_DISPLAY_PANEL_LGPHILIPS_LB035Q02 is not set
-# CONFIG_DISPLAY_PANEL_TPO_TD028TTEC1 is not set
-# CONFIG_DISPLAY_PANEL_TPO_TD043MTEA1 is not set
-# CONFIG_DISPLAY_SUPPORT is not set
-# CONFIG_DL2K is not set
-# CONFIG_DLM is not set
-# CONFIG_DM9000 is not set
-# CONFIG_DMADEVICES is not set
-# CONFIG_DMADEVICES_DEBUG is not set
-# CONFIG_DMASCC is not set
-# CONFIG_DMATEST is not set
-# CONFIG_DMA_API_DEBUG is not set
-# CONFIG_DMA_ENGINE is not set
-# CONFIG_DMA_SHARED_BUFFER is not set
-# CONFIG_DM_CACHE is not set
-# CONFIG_DM_DEBUG is not set
-# CONFIG_DM_DELAY is not set
-# CONFIG_DM_ERA is not set
-# CONFIG_DM_FLAKEY is not set
-# CONFIG_DM_LOG_USERSPACE is not set
-# CONFIG_DM_MULTIPATH is not set
-# CONFIG_DM_RAID is not set
-# CONFIG_DM_SWITCH is not set
-# CONFIG_DM_THIN_PROVISIONING is not set
-# CONFIG_DM_UEVENT is not set
-# CONFIG_DM_VERITY is not set
-# CONFIG_DM_ZERO is not set
-# CONFIG_DNET is not set
-# CONFIG_DNOTIFY is not set
-# CONFIG_DNS_RESOLVER is not set
-CONFIG_DOUBLEFAULT=y
-CONFIG_DQL=y
-# CONFIG_DRAGONRISE_FF is not set
-# CONFIG_DRM is not set
-# CONFIG_DS1682 is not set
-# CONFIG_DTLK is not set
-# CONFIG_DUMMY is not set
-CONFIG_DUMMY_CONSOLE_COLUMNS=80
-CONFIG_DUMMY_CONSOLE_ROWS=25
-# CONFIG_DUMMY_IRQ is not set
-# CONFIG_DVB_AU8522_V4L is not set
-# CONFIG_DVB_CORE is not set
-# CONFIG_DVB_DUMMY_FE is not set
-# CONFIG_DVB_TUNER_DIB0070 is not set
-# CONFIG_DVB_TUNER_DIB0090 is not set
-# CONFIG_DWC3_HOST_USB3_LPM_ENABLE is not set
-# CONFIG_DW_DMAC is not set
-# CONFIG_DW_WATCHDOG is not set
-# CONFIG_DX_SEP is not set
-# CONFIG_DYNAMIC_DEBUG is not set
-# CONFIG_E100 is not set
-# CONFIG_E1000 is not set
-# CONFIG_E1000E is not set
-# CONFIG_E2100 is not set
-# CONFIG_EARLY_PRINTK_8250 is not set
-# CONFIG_EASYCAP is not set
-# CONFIG_ECHO is not set
-# CONFIG_ECONET is not set
-# CONFIG_ECRYPT_FS is not set
-# CONFIG_EDAC is not set
-# CONFIG_EEPROM_93CX6 is not set
-# CONFIG_EEPROM_93XX46 is not set
-# CONFIG_EEPROM_AT24 is not set
-# CONFIG_EEPROM_AT25 is not set
-# CONFIG_EEPROM_DIGSY_MTC_CFG is not set
-# CONFIG_EEPROM_LEGACY is not set
-# CONFIG_EEPROM_MAX6875 is not set
-# CONFIG_EEXPRESS is not set
-# CONFIG_EEXPRESS_PRO is not set
-CONFIG_EFI_PARTITION=y
-# CONFIG_EFS_FS is not set
-# CONFIG_ELF_CORE is not set
-# CONFIG_EMAC_ROCKCHIP is not set
-CONFIG_EMBEDDED=y
-# CONFIG_EM_TIMER_STI is not set
-# CONFIG_ENABLE_MUST_CHECK is not set
-CONFIG_ENABLE_WARN_DEPRECATED=y
-# CONFIG_ENC28J60 is not set
-# CONFIG_ENCLOSURE_SERVICES is not set
-# CONFIG_ENCRYPTED_KEYS is not set
-# CONFIG_ENIC is not set
-# CONFIG_EPAPR_PARAVIRT is not set
-# CONFIG_EPIC100 is not set
-CONFIG_EPOLL=y
-# CONFIG_EQUALIZER is not set
-# CONFIG_ET131X is not set
-# CONFIG_ETH16I is not set
-CONFIG_ETHERNET=y
-# CONFIG_ETHOC is not set
-CONFIG_EVENTFD=y
-# CONFIG_EVENT_POWER_TRACING_DEPRECATED is not set
-# CONFIG_EWRK3 is not set
-CONFIG_EXPERIMENTAL=y
-CONFIG_EXPERT=y
-# CONFIG_EXPORTFS is not set
-# CONFIG_EXT2_FS is not set
-# CONFIG_EXT2_FS_XATTR is not set
-# CONFIG_EXT2_FS_XIP is not set
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-# CONFIG_EXT3_FS is not set
-# CONFIG_EXT3_FS_XATTR is not set
-# CONFIG_EXT4_DEBUG is not set
-# CONFIG_EXT4_FS is not set
-# CONFIG_EXT4_FS_POSIX_ACL is not set
-# CONFIG_EXT4_FS_SECURITY is not set
-CONFIG_EXT4_FS_XATTR=y
-CONFIG_EXT4_USE_FOR_EXT23=y
-# CONFIG_EXTCON is not set
-CONFIG_EXTRA_FIRMWARE=""
-CONFIG_EXTRA_TARGETS=""
-# CONFIG_EXYNOS_ADC is not set
-# CONFIG_EXYNOS_VIDEO is not set
-# CONFIG_EZX_PCAP is not set
-# CONFIG_F2FS_FS is not set
-# CONFIG_F2FS_FS_POSIX_ACL is not set
-# CONFIG_FAIR_GROUP_SCHED is not set
-# CONFIG_FANOTIFY is not set
-CONFIG_FAT_DEFAULT_CODEPAGE=437
-CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
-# CONFIG_FAT_FS is not set
-# CONFIG_FAULT_INJECTION is not set
-# CONFIG_FB is not set
-# CONFIG_FB_3DFX is not set
-# CONFIG_FB_ARC is not set
-# CONFIG_FB_ARK is not set
-# CONFIG_FB_ARMCLCD is not set
-# CONFIG_FB_ASILIANT is not set
-# CONFIG_FB_ATY is not set
-# CONFIG_FB_ATY128 is not set
-# CONFIG_FB_AUO_K190X is not set
-# CONFIG_FB_BACKLIGHT is not set
-# CONFIG_FB_BOOT_VESA_SUPPORT is not set
-# CONFIG_FB_BROADSHEET is not set
-# CONFIG_FB_CARMINE is not set
-# CONFIG_FB_CFB_COPYAREA is not set
-# CONFIG_FB_CFB_FILLRECT is not set
-# CONFIG_FB_CFB_IMAGEBLIT is not set
-# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
-# CONFIG_FB_CIRRUS is not set
-# CONFIG_FB_CYBER2000 is not set
-# CONFIG_FB_DA8XX is not set
-# CONFIG_FB_DDC is not set
-# CONFIG_FB_FOREIGN_ENDIAN is not set
-# CONFIG_FB_GEODE is not set
-# CONFIG_FB_GOLDFISH is not set
-# CONFIG_FB_HGA is not set
-# CONFIG_FB_I740 is not set
-# CONFIG_FB_IBM_GXT4500 is not set
-# CONFIG_FB_IMSTT is not set
-# CONFIG_FB_IMX is not set
-# CONFIG_FB_KYRO is not set
-# CONFIG_FB_LE80578 is not set
-# CONFIG_FB_MACMODES is not set
-# CONFIG_FB_MATROX is not set
-# CONFIG_FB_MB862XX is not set
-# CONFIG_FB_METRONOME is not set
-# CONFIG_FB_MODE_HELPERS is not set
-# CONFIG_FB_MXS is not set
-# CONFIG_FB_N411 is not set
-# CONFIG_FB_NEOMAGIC is not set
-# CONFIG_FB_NVIDIA is not set
-# CONFIG_FB_OF is not set
-# CONFIG_FB_OPENCORES is not set
-# CONFIG_FB_PM2 is not set
-# CONFIG_FB_PM3 is not set
-# CONFIG_FB_PS3 is not set
-# CONFIG_FB_PXA is not set
-# CONFIG_FB_RADEON is not set
-# CONFIG_FB_RIVA is not set
-# CONFIG_FB_S1D13XXX is not set
-# CONFIG_FB_S3 is not set
-# CONFIG_FB_SAVAGE is not set
-# CONFIG_FB_SIMPLE is not set
-# CONFIG_FB_SIS is not set
-# CONFIG_FB_SM7XX is not set
-# CONFIG_FB_SMSCUFX is not set
-# CONFIG_FB_SSD1307 is not set
-# CONFIG_FB_SVGALIB is not set
-# CONFIG_FB_SYS_COPYAREA is not set
-# CONFIG_FB_SYS_FILLRECT is not set
-# CONFIG_FB_SYS_FOPS is not set
-# CONFIG_FB_SYS_IMAGEBLIT is not set
-# CONFIG_FB_TILEBLITTING is not set
-# CONFIG_FB_TMIO is not set
-# CONFIG_FB_TRIDENT is not set
-# CONFIG_FB_UDL is not set
-# CONFIG_FB_UVESA is not set
-# CONFIG_FB_VGA16 is not set
-# CONFIG_FB_VIA is not set
-# CONFIG_FB_VIRTUAL is not set
-# CONFIG_FB_VOODOO1 is not set
-# CONFIG_FB_VT8623 is not set
-# CONFIG_FB_XGI is not set
-# CONFIG_FCOE is not set
-# CONFIG_FCOE_FNIC is not set
-# CONFIG_FDDI is not set
-# CONFIG_FEALNX is not set
-# CONFIG_FENCE_TRACE is not set
-# CONFIG_FHANDLE is not set
-CONFIG_FIB_RULES=y
-CONFIG_FILE_LOCKING=y
-# CONFIG_FIREWIRE is not set
-# CONFIG_FIREWIRE_NOSY is not set
-# CONFIG_FIREWIRE_SERIAL is not set
-# CONFIG_FIRMWARE_EDID is not set
-# CONFIG_FIRMWARE_IN_KERNEL is not set
-# CONFIG_FIRMWARE_MEMMAP is not set
-# CONFIG_FIXED_PHY is not set
-CONFIG_FLATMEM=y
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_FLAT_NODE_MEM_MAP=y
-# CONFIG_FM10K is not set
-# CONFIG_FMC is not set
-# CONFIG_FORCEDETH is not set
-CONFIG_FORCE_MAX_ZONEORDER=11
-# CONFIG_FRAMEBUFFER_CONSOLE is not set
-# CONFIG_FRAME_POINTER is not set
-CONFIG_FRAME_WARN=1024
-# CONFIG_FREEZER is not set
-# CONFIG_FRONTSWAP is not set
-# CONFIG_FSCACHE is not set
-# CONFIG_FSL_EDMA is not set
-# CONFIG_FSL_XGMAC_MDIO is not set
-CONFIG_FSNOTIFY=y
-# CONFIG_FS_POSIX_ACL is not set
-# CONFIG_FT1000 is not set
-# CONFIG_FTGMAC100 is not set
-# CONFIG_FTL is not set
-# CONFIG_FTMAC100 is not set
-# CONFIG_FTRACE is not set
-# CONFIG_FTRACE_STARTUP_TEST is not set
-# CONFIG_FTR_FIXUP_SELFTEST is not set
-# CONFIG_FUJITSU_TABLET is not set
-# CONFIG_FUNCTION_TRACER is not set
-# CONFIG_FUSE_FS is not set
-# CONFIG_FUSION is not set
-# CONFIG_FUSION_FC is not set
-# CONFIG_FUSION_SAS is not set
-# CONFIG_FUSION_SPI is not set
-CONFIG_FUTEX=y
-CONFIG_FW_LOADER=y
-CONFIG_FW_LOADER_USER_HELPER=y
-CONFIG_FW_LOADER_USER_HELPER_FALLBACK=y
-CONFIG_GACT_PROB=y
-# CONFIG_GADGET_UAC1 is not set
-# CONFIG_GAMEPORT is not set
-# CONFIG_GATEWORKS_GW16083 is not set
-# CONFIG_GCOV is not set
-# CONFIG_GCOV_KERNEL is not set
-# CONFIG_GENERIC_ADC_BATTERY is not set
-CONFIG_GENERIC_CALIBRATE_DELAY=y
-# CONFIG_GENERIC_CPU_DEVICES is not set
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_HWEIGHT=y
-CONFIG_GENERIC_IRQ_PROBE=y
-CONFIG_GENERIC_NET_UTILS=y
-# CONFIG_GENERIC_PHY is not set
-CONFIG_GENERIC_TIME=y
-# CONFIG_GENEVE is not set
-# CONFIG_GENWQE is not set
-# CONFIG_GFS2_FS is not set
-# CONFIG_GIGASET_CAPI is not set
-# CONFIG_GIGASET_DEBUG is not set
-# CONFIG_GLOB_SELFTEST is not set
-# CONFIG_GP2AP020A00F is not set
-# CONFIG_GPIOLIB is not set
-# CONFIG_GPIO_74X164 is not set
-# CONFIG_GPIO_ADNP is not set
-# CONFIG_GPIO_ADP5588 is not set
-# CONFIG_GPIO_AMD8111 is not set
-# CONFIG_GPIO_BCM_KONA is not set
-# CONFIG_GPIO_BT8XX is not set
-# CONFIG_GPIO_CS5535 is not set
-# CONFIG_GPIO_DWAPB is not set
-# CONFIG_GPIO_EM is not set
-# CONFIG_GPIO_GENERIC_PLATFORM is not set
-# CONFIG_GPIO_GRGPIO is not set
-# CONFIG_GPIO_ICH is not set
-# CONFIG_GPIO_IT8761E is not set
-# CONFIG_GPIO_LANGWELL is not set
-# CONFIG_GPIO_MAX7300 is not set
-# CONFIG_GPIO_MAX7301 is not set
-# CONFIG_GPIO_MAX732X is not set
-# CONFIG_GPIO_MC33880 is not set
-# CONFIG_GPIO_MCP23S08 is not set
-# CONFIG_GPIO_ML_IOH is not set
-# CONFIG_GPIO_PCA953X is not set
-# CONFIG_GPIO_PCF857X is not set
-# CONFIG_GPIO_PCH is not set
-# CONFIG_GPIO_PL061 is not set
-# CONFIG_GPIO_RCAR is not set
-# CONFIG_GPIO_RDC321X is not set
-# CONFIG_GPIO_SCH is not set
-# CONFIG_GPIO_SCH311X is not set
-# CONFIG_GPIO_SX150X is not set
-# CONFIG_GPIO_SYSCON is not set
-# CONFIG_GPIO_SYSFS is not set
-# CONFIG_GPIO_TS5500 is not set
-# CONFIG_GPIO_VX855 is not set
-# CONFIG_GPIO_WATCHDOG is not set
-# CONFIG_GPIO_WDT is not set
-# CONFIG_GPIO_XILINX is not set
-# CONFIG_GPIO_ZEVIO is not set
-# CONFIG_GREENASIA_FF is not set
-# CONFIG_GS_FPGABOOT is not set
-# CONFIG_HAMACHI is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_HAPPYMEAL is not set
-# CONFIG_HARDLOCKUP_DETECTOR is not set
-# CONFIG_HAVE_AOUT is not set
-# CONFIG_HAVE_ARM_ARCH_TIMER is not set
-CONFIG_HAVE_KPROBES=y
-CONFIG_HAVE_KRETPROBES=y
-# CONFIG_HCALL_STATS is not set
-# CONFIG_HDLC is not set
-# CONFIG_HDLC_CISCO is not set
-# CONFIG_HDLC_FR is not set
-# CONFIG_HDLC_PPP is not set
-# CONFIG_HDLC_RAW is not set
-# CONFIG_HDLC_RAW_ETH is not set
-# CONFIG_HDQ_MASTER_OMAP is not set
-# CONFIG_HEADERS_CHECK is not set
-# CONFIG_HERMES is not set
-# CONFIG_HFSPLUS_FS is not set
-# CONFIG_HFSPLUS_FS_POSIX_ACL is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_HFS_FS_POSIX_ACL is not set
-# CONFIG_HIBERNATION is not set
-# CONFIG_HID is not set
-# CONFIG_HIDRAW is not set
-# CONFIG_HID_A4TECH is not set
-# CONFIG_HID_ACRUX is not set
-# CONFIG_HID_ACRUX_FF is not set
-# CONFIG_HID_APPLE is not set
-# CONFIG_HID_APPLEIR is not set
-# CONFIG_HID_AUREAL is not set
-# CONFIG_HID_BELKIN is not set
-# CONFIG_HID_CHERRY is not set
-# CONFIG_HID_CHICONY is not set
-# CONFIG_HID_CP2112 is not set
-# CONFIG_HID_CYPRESS is not set
-# CONFIG_HID_DRAGONRISE is not set
-# CONFIG_HID_ELECOM is not set
-# CONFIG_HID_ELO is not set
-# CONFIG_HID_EMS_FF is not set
-# CONFIG_HID_EZKEY is not set
-# CONFIG_HID_GENERIC is not set
-# CONFIG_HID_GREENASIA is not set
-# CONFIG_HID_GT683R is not set
-# CONFIG_HID_GYRATION is not set
-# CONFIG_HID_HOLTEK is not set
-# CONFIG_HID_HUION is not set
-# CONFIG_HID_ICADE is not set
-# CONFIG_HID_KENSINGTON is not set
-# CONFIG_HID_KEYTOUCH is not set
-# CONFIG_HID_KYE is not set
-# CONFIG_HID_LCPOWER is not set
-# CONFIG_HID_LENOVO is not set
-# CONFIG_HID_LENOVO_TPKBD is not set
-# CONFIG_HID_LOGITECH is not set
-# CONFIG_HID_LOGITECH_DJ is not set
-# CONFIG_HID_LOGITECH_HIDPP is not set
-# CONFIG_HID_MAGICMOUSE is not set
-# CONFIG_HID_MICROSOFT is not set
-# CONFIG_HID_MONTEREY is not set
-# CONFIG_HID_MULTITOUCH is not set
-# CONFIG_HID_NTRIG is not set
-# CONFIG_HID_ORTEK is not set
-# CONFIG_HID_PANTHERLORD is not set
-# CONFIG_HID_PENMOUNT is not set
-# CONFIG_HID_PETALYNX is not set
-# CONFIG_HID_PICOLCD is not set
-# CONFIG_HID_PID is not set
-# CONFIG_HID_PRIMAX is not set
-# CONFIG_HID_PRODIKEYS is not set
-# CONFIG_HID_PS3REMOTE is not set
-# CONFIG_HID_QUANTA is not set
-# CONFIG_HID_RMI is not set
-# CONFIG_HID_ROCCAT is not set
-# CONFIG_HID_ROCCAT_ARVO is not set
-# CONFIG_HID_ROCCAT_KONE is not set
-# CONFIG_HID_ROCCAT_KONEPLUS is not set
-# CONFIG_HID_ROCCAT_KOVAPLUS is not set
-# CONFIG_HID_ROCCAT_PYRA is not set
-# CONFIG_HID_SAITEK is not set
-# CONFIG_HID_SAMSUNG is not set
-# CONFIG_HID_SENSOR_HUB is not set
-# CONFIG_HID_SMARTJOYPLUS is not set
-# CONFIG_HID_SONY is not set
-# CONFIG_HID_SPEEDLINK is not set
-# CONFIG_HID_STEELSERIES is not set
-# CONFIG_HID_SUNPLUS is not set
-# CONFIG_HID_SUPPORT is not set
-# CONFIG_HID_THINGM is not set
-# CONFIG_HID_THRUSTMASTER is not set
-# CONFIG_HID_TIVO is not set
-# CONFIG_HID_TOPSEED is not set
-# CONFIG_HID_TWINHAN is not set
-# CONFIG_HID_UCLOGIC is not set
-# CONFIG_HID_WACOM is not set
-# CONFIG_HID_WALTOP is not set
-# CONFIG_HID_WIIMOTE is not set
-# CONFIG_HID_XINMO is not set
-# CONFIG_HID_ZEROPLUS is not set
-# CONFIG_HID_ZYDACRON is not set
-# CONFIG_HIGHMEM is not set
-CONFIG_HIGH_RES_TIMERS=y
-# CONFIG_HIPPI is not set
-# CONFIG_HIX5HD2_GMAC is not set
-# CONFIG_HMC6352 is not set
-# CONFIG_HOSTAP is not set
-# CONFIG_HOSTAP_CS is not set
-# CONFIG_HOSTAP_PCI is not set
-# CONFIG_HOSTAP_PLX is not set
-CONFIG_HOTPLUG=y
-# CONFIG_HOTPLUG_CPU is not set
-# CONFIG_HOTPLUG_PCI is not set
-# CONFIG_HP100 is not set
-CONFIG_HPET_MMAP_DEFAULT=y
-# CONFIG_HPFS_FS is not set
-# CONFIG_HPLAN is not set
-# CONFIG_HPLAN_PLUS is not set
-# CONFIG_HP_ILO is not set
-# CONFIG_HP_WIRELESS is not set
-# CONFIG_HSI is not set
-# CONFIG_HSR is not set
-# CONFIG_HTC_EGPIO is not set
-# CONFIG_HTC_I2CPLD is not set
-# CONFIG_HTC_PASIC3 is not set
-# CONFIG_HUGETLB_PAGE is not set
-# CONFIG_HVC_DCC is not set
-# CONFIG_HVC_UDBG is not set
-# CONFIG_HWMON is not set
-# CONFIG_HWMON_DEBUG_CHIP is not set
-# CONFIG_HWMON_VID is not set
-# CONFIG_HWSPINLOCK_OMAP is not set
-CONFIG_HW_PERF_EVENTS=y
-# CONFIG_HW_RANDOM is not set
-# CONFIG_HW_RANDOM_AMD is not set
-# CONFIG_HW_RANDOM_ATMEL is not set
-# CONFIG_HW_RANDOM_EXYNOS is not set
-# CONFIG_HW_RANDOM_GEODE is not set
-# CONFIG_HW_RANDOM_INTEL is not set
-# CONFIG_HW_RANDOM_OMAP3_ROM is not set
-# CONFIG_HW_RANDOM_PPC4XX is not set
-# CONFIG_HW_RANDOM_TIMERIOMEM is not set
-# CONFIG_HW_RANDOM_TPM is not set
-# CONFIG_HW_RANDOM_VIA is not set
-# CONFIG_HYPERV is not set
-# CONFIG_HYSDN is not set
-CONFIG_HZ=100
-CONFIG_HZ_100=y
-# CONFIG_HZ_1000 is not set
-# CONFIG_HZ_1024 is not set
-# CONFIG_HZ_128 is not set
-# CONFIG_HZ_200 is not set
-# CONFIG_HZ_250 is not set
-# CONFIG_HZ_256 is not set
-# CONFIG_HZ_300 is not set
-# CONFIG_HZ_48 is not set
-# CONFIG_HZ_500 is not set
-# CONFIG_HZ_PERIODIC is not set
-# CONFIG_I2C is not set
-# CONFIG_I2C_ALGOBIT is not set
-# CONFIG_I2C_ALGOPCA is not set
-# CONFIG_I2C_ALGOPCF is not set
-# CONFIG_I2C_ALI1535 is not set
-# CONFIG_I2C_ALI1563 is not set
-# CONFIG_I2C_ALI15X3 is not set
-# CONFIG_I2C_AMD756 is not set
-# CONFIG_I2C_AMD8111 is not set
-# CONFIG_I2C_ARB_GPIO_CHALLENGE is not set
-# CONFIG_I2C_AU1550 is not set
-# CONFIG_I2C_BCM2835 is not set
-# CONFIG_I2C_CBUS_GPIO is not set
-# CONFIG_I2C_CHARDEV is not set
-# CONFIG_I2C_COMPAT is not set
-# CONFIG_I2C_DEBUG_ALGO is not set
-# CONFIG_I2C_DEBUG_BUS is not set
-# CONFIG_I2C_DEBUG_CORE is not set
-# CONFIG_I2C_DESIGNWARE is not set
-# CONFIG_I2C_DESIGNWARE_PCI is not set
-# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
-# CONFIG_I2C_DIOLAN_U2C is not set
-# CONFIG_I2C_EG20T is not set
-# CONFIG_I2C_ELEKTOR is not set
-# CONFIG_I2C_GPIO is not set
-# CONFIG_I2C_HELPER_AUTO is not set
-# CONFIG_I2C_HID is not set
-# CONFIG_I2C_I801 is not set
-# CONFIG_I2C_IBM_IIC is not set
-# CONFIG_I2C_INTEL_MID is not set
-# CONFIG_I2C_ISCH is not set
-# CONFIG_I2C_ISMT is not set
-# CONFIG_I2C_MPC is not set
-# CONFIG_I2C_MUX is not set
-# CONFIG_I2C_MUX_PINCTRL is not set
-# CONFIG_I2C_MV64XXX is not set
-# CONFIG_I2C_NFORCE2 is not set
-# CONFIG_I2C_NOMADIK is not set
-# CONFIG_I2C_OCORES is not set
-# CONFIG_I2C_OCTEON is not set
-# CONFIG_I2C_PARPORT is not set
-# CONFIG_I2C_PARPORT_LIGHT is not set
-# CONFIG_I2C_PCA_ISA is not set
-# CONFIG_I2C_PCA_PLATFORM is not set
-# CONFIG_I2C_PIIX4 is not set
-# CONFIG_I2C_PXA_PCI is not set
-# CONFIG_I2C_RCAR is not set
-# CONFIG_I2C_RK3X is not set
-# CONFIG_I2C_ROBOTFUZZ_OSIF is not set
-# CONFIG_I2C_SCMI is not set
-# CONFIG_I2C_SH_MOBILE is not set
-# CONFIG_I2C_SIMTEC is not set
-# CONFIG_I2C_SIS5595 is not set
-# CONFIG_I2C_SIS630 is not set
-# CONFIG_I2C_SIS96X is not set
-# CONFIG_I2C_SMBUS is not set
-# CONFIG_I2C_STUB is not set
-# CONFIG_I2C_TAOS_EVM is not set
-# CONFIG_I2C_TINY_USB is not set
-# CONFIG_I2C_VERSATILE is not set
-# CONFIG_I2C_VIA is not set
-# CONFIG_I2C_VIAPRO is not set
-# CONFIG_I2C_XILINX is not set
-# CONFIG_I2O is not set
-# CONFIG_I40E is not set
-# CONFIG_I40EVF is not set
-# CONFIG_I6300ESB_WDT is not set
-# CONFIG_I82092 is not set
-# CONFIG_I82365 is not set
-# CONFIG_IBM_ASM is not set
-# CONFIG_IBM_EMAC_DEBUG is not set
-# CONFIG_IBM_EMAC_EMAC4 is not set
-# CONFIG_IBM_EMAC_MAL_CLR_ICINTSTAT is not set
-# CONFIG_IBM_EMAC_MAL_COMMON_ERR is not set
-# CONFIG_IBM_EMAC_NO_FLOW_CTRL is not set
-# CONFIG_IBM_EMAC_RGMII is not set
-# CONFIG_IBM_EMAC_TAH is not set
-# CONFIG_IBM_EMAC_ZMII is not set
-# CONFIG_ICPLUS_PHY is not set
-# CONFIG_ICS932S401 is not set
-# CONFIG_IDE is not set
-# CONFIG_IDEAPAD_LAPTOP is not set
-# CONFIG_IDE_GD is not set
-# CONFIG_IDE_PHISON is not set
-# CONFIG_IDE_PROC_FS is not set
-# CONFIG_IDE_TASK_IOCTL is not set
-# CONFIG_IEEE802154 is not set
-# CONFIG_IEEE802154_FAKEHARD is not set
-# CONFIG_IFB is not set
-# CONFIG_IGB is not set
-# CONFIG_IGBVF is not set
-# CONFIG_IIO is not set
-# CONFIG_IIO_BUFFER_CB is not set
-CONFIG_IIO_CONSUMERS_PER_TRIGGER=2
-# CONFIG_IIO_GPIO_TRIGGER is not set
-# CONFIG_IIO_INTERRUPT_TRIGGER is not set
-# CONFIG_IIO_PERIODIC_RTC_TRIGGER is not set
-# CONFIG_IIO_SIMPLE_DUMMY is not set
-# CONFIG_IIO_ST_ACCEL_3AXIS is not set
-# CONFIG_IIO_ST_GYRO_3AXIS is not set
-# CONFIG_IIO_ST_MAGN_3AXIS is not set
-# CONFIG_IIO_ST_PRESS is not set
-# CONFIG_IIO_SYSFS_TRIGGER is not set
-# CONFIG_IKCONFIG is not set
-# CONFIG_IKCONFIG_PROC is not set
-# CONFIG_IMAGE_CMDLINE_HACK is not set
-# CONFIG_IMX_IPUV3_CORE is not set
-CONFIG_INET=y
-# CONFIG_INET6_AH is not set
-# CONFIG_INET6_ESP is not set
-# CONFIG_INET6_IPCOMP is not set
-# CONFIG_INET6_TUNNEL is not set
-# CONFIG_INET6_XFRM_MODE_BEET is not set
-# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
-# CONFIG_INET6_XFRM_MODE_TRANSPORT is not set
-# CONFIG_INET6_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET6_XFRM_TUNNEL is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_DIAG is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_LRO is not set
-# CONFIG_INET_TCP_DIAG is not set
-# CONFIG_INET_TUNNEL is not set
-# CONFIG_INET_UDP_DIAG is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_TUNNEL is not set
-# CONFIG_INFINIBAND is not set
-# CONFIG_INFTL is not set
-# CONFIG_INITRAMFS_COMPRESSION_BZIP2 is not set
-# CONFIG_INITRAMFS_COMPRESSION_GZIP is not set
-# CONFIG_INITRAMFS_COMPRESSION_LZMA is not set
-CONFIG_INITRAMFS_COMPRESSION_NONE=y
-CONFIG_INIT_ENV_ARG_LIMIT=32
-# CONFIG_INLINE_READ_LOCK is not set
-# CONFIG_INLINE_READ_LOCK_BH is not set
-# CONFIG_INLINE_READ_LOCK_IRQ is not set
-# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
-# CONFIG_INLINE_READ_TRYLOCK is not set
-CONFIG_INLINE_READ_UNLOCK=y
-# CONFIG_INLINE_READ_UNLOCK_BH is not set
-CONFIG_INLINE_READ_UNLOCK_IRQ=y
-# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
-# CONFIG_INLINE_SPIN_LOCK is not set
-# CONFIG_INLINE_SPIN_LOCK_BH is not set
-# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
-# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
-# CONFIG_INLINE_SPIN_TRYLOCK is not set
-# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
-CONFIG_INLINE_SPIN_UNLOCK=y
-# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
-CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
-# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
-# CONFIG_INLINE_WRITE_LOCK is not set
-# CONFIG_INLINE_WRITE_LOCK_BH is not set
-# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
-# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
-# CONFIG_INLINE_WRITE_TRYLOCK is not set
-CONFIG_INLINE_WRITE_UNLOCK=y
-# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
-CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
-# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
-CONFIG_INOTIFY_USER=y
-# CONFIG_INPUT is not set
-# CONFIG_INPUT_AD714X is not set
-# CONFIG_INPUT_ADXL34X is not set
-# CONFIG_INPUT_APANEL is not set
-# CONFIG_INPUT_ATI_REMOTE is not set
-# CONFIG_INPUT_ATI_REMOTE2 is not set
-# CONFIG_INPUT_ATLAS_BTNS is not set
-# CONFIG_INPUT_BMA150 is not set
-# CONFIG_INPUT_CM109 is not set
-# CONFIG_INPUT_CMA3000 is not set
-# CONFIG_INPUT_DRV260X_HAPTICS is not set
-# CONFIG_INPUT_DRV2667_HAPTICS is not set
-# CONFIG_INPUT_EVBUG is not set
-# CONFIG_INPUT_EVDEV is not set
-# CONFIG_INPUT_FF_MEMLESS is not set
-# CONFIG_INPUT_GP2A is not set
-# CONFIG_INPUT_GPIO_BEEPER is not set
-# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
-# CONFIG_INPUT_GPIO_TILT_POLLED is not set
-# CONFIG_INPUT_IDEAPAD_SLIDEBAR is not set
-# CONFIG_INPUT_IMS_PCU is not set
-# CONFIG_INPUT_JOYDEV is not set
-# CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_KEYSPAN_REMOTE is not set
-# CONFIG_INPUT_KXTJ9 is not set
-# CONFIG_INPUT_MATRIXKMAP is not set
-CONFIG_INPUT_MISC=y
-# CONFIG_INPUT_MMA8450 is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_MPU3050 is not set
-# CONFIG_INPUT_PCF8574 is not set
-# CONFIG_INPUT_PCSPKR is not set
-# CONFIG_INPUT_POLLDEV is not set
-# CONFIG_INPUT_POWERMATE is not set
-# CONFIG_INPUT_PWM_BEEPER is not set
-# CONFIG_INPUT_SOC_BUTTON_ARRAY is not set
-# CONFIG_INPUT_SPARSEKMAP is not set
-# CONFIG_INPUT_TABLET is not set
-# CONFIG_INPUT_TOUCHSCREEN is not set
-# CONFIG_INPUT_UINPUT is not set
-# CONFIG_INPUT_WISTRON_BTNS is not set
-# CONFIG_INPUT_YEALINK is not set
-# CONFIG_INT340X_THERMAL is not set
-# CONFIG_INTEL_IDLE is not set
-# CONFIG_INTEL_MEI is not set
-# CONFIG_INTEL_MEI_ME is not set
-# CONFIG_INTEL_MEI_TXE is not set
-# CONFIG_INTEL_MIC_CARD is not set
-# CONFIG_INTEL_MIC_HOST is not set
-# CONFIG_INTEL_MID_PTI is not set
-# CONFIG_INTEL_OAKTRAIL is not set
-# CONFIG_INTEL_RST is not set
-# CONFIG_INTEL_SMARTCONNECT is not set
-# CONFIG_INTEL_SOC_PMIC is not set
-# CONFIG_INTERVAL_TREE_TEST is not set
-# CONFIG_INV_MPU6050_IIO is not set
-# CONFIG_IOMMU_SUPPORT is not set
-# CONFIG_IOSCHED_CFQ is not set
-CONFIG_IOSCHED_DEADLINE=y
-CONFIG_IOSCHED_NOOP=y
-# CONFIG_IP1000 is not set
-# CONFIG_IP17XX_PHY is not set
-# CONFIG_IP6_NF_FILTER is not set
-# CONFIG_IP6_NF_IPTABLES is not set
-# CONFIG_IP6_NF_MANGLE is not set
-# CONFIG_IP6_NF_MATCH_AH is not set
-# CONFIG_IP6_NF_MATCH_EUI64 is not set
-# CONFIG_IP6_NF_MATCH_FRAG is not set
-# CONFIG_IP6_NF_MATCH_HL is not set
-# CONFIG_IP6_NF_MATCH_IPV6HEADER is not set
-# CONFIG_IP6_NF_MATCH_MH is not set
-# CONFIG_IP6_NF_MATCH_OPTS is not set
-# CONFIG_IP6_NF_MATCH_RPFILTER is not set
-# CONFIG_IP6_NF_MATCH_RT is not set
-# CONFIG_IP6_NF_NAT is not set
-# CONFIG_IP6_NF_QUEUE is not set
-# CONFIG_IP6_NF_RAW is not set
-# CONFIG_IP6_NF_TARGET_HL is not set
-# CONFIG_IP6_NF_TARGET_LOG is not set
-# CONFIG_IP6_NF_TARGET_REJECT is not set
-# CONFIG_IP6_NF_TARGET_SYNPROXY is not set
-# CONFIG_IPACK_BUS is not set
-# CONFIG_IPC_NS is not set
-# CONFIG_IPMI_HANDLER is not set
-# CONFIG_IPV6 is not set
-# CONFIG_IPV6_MIP6 is not set
-# CONFIG_IPV6_MROUTE is not set
-# CONFIG_IPV6_MROUTE_MULTIPLE_TABLES is not set
-# CONFIG_IPV6_MULTIPLE_TABLES is not set
-CONFIG_IPV6_NDISC_NODETYPE=y
-# CONFIG_IPV6_OPTIMISTIC_DAD is not set
-# CONFIG_IPV6_PRIVACY is not set
-# CONFIG_IPV6_ROUTER_PREF is not set
-# CONFIG_IPV6_ROUTE_INFO is not set
-# CONFIG_IPV6_SIT is not set
-# CONFIG_IPV6_SIT_6RD is not set
-# CONFIG_IPV6_TUNNEL is not set
-# CONFIG_IPV6_VTI is not set
-# CONFIG_IPW2100 is not set
-# CONFIG_IPW2100_DEBUG is not set
-CONFIG_IPW2100_MONITOR=y
-# CONFIG_IPW2200 is not set
-# CONFIG_IPW2200_DEBUG is not set
-CONFIG_IPW2200_MONITOR=y
-# CONFIG_IPW2200_PROMISCUOUS is not set
-# CONFIG_IPW2200_QOS is not set
-# CONFIG_IPW2200_RADIOTAP is not set
-# CONFIG_IPWIRELESS is not set
-# CONFIG_IPX is not set
-CONFIG_IP_ADVANCED_ROUTER=y
-# CONFIG_IP_DCCP is not set
-# CONFIG_IP_FIB_TRIE_STATS is not set
-# CONFIG_IP_MROUTE is not set
-CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
-CONFIG_IP_MULTICAST=y
-CONFIG_IP_MULTIPLE_TABLES=y
-# CONFIG_IP_NF_ARPFILTER is not set
-# CONFIG_IP_NF_ARPTABLES is not set
-# CONFIG_IP_NF_ARP_MANGLE is not set
-# CONFIG_IP_NF_FILTER is not set
-# CONFIG_IP_NF_IPTABLES is not set
-# CONFIG_IP_NF_MANGLE is not set
-# CONFIG_IP_NF_MATCH_AH is not set
-# CONFIG_IP_NF_MATCH_ECN is not set
-# CONFIG_IP_NF_MATCH_RPFILTER is not set
-# CONFIG_IP_NF_MATCH_TTL is not set
-# CONFIG_IP_NF_QUEUE is not set
-# CONFIG_IP_NF_RAW is not set
-# CONFIG_IP_NF_SECURITY is not set
-# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
-# CONFIG_IP_NF_TARGET_ECN is not set
-# CONFIG_IP_NF_TARGET_LOG is not set
-# CONFIG_IP_NF_TARGET_MASQUERADE is not set
-# CONFIG_IP_NF_TARGET_NETMAP is not set
-# CONFIG_IP_NF_TARGET_REDIRECT is not set
-# CONFIG_IP_NF_TARGET_REJECT is not set
-# CONFIG_IP_NF_TARGET_SYNPROXY is not set
-# CONFIG_IP_NF_TARGET_TTL is not set
-# CONFIG_IP_NF_TARGET_ULOG is not set
-# CONFIG_IP_PIMSM_V1 is not set
-# CONFIG_IP_PIMSM_V2 is not set
-# CONFIG_IP_PNP is not set
-CONFIG_IP_ROUTE_MULTIPATH=y
-CONFIG_IP_ROUTE_VERBOSE=y
-# CONFIG_IP_SCTP is not set
-# CONFIG_IP_SET is not set
-# CONFIG_IP_VS is not set
-# CONFIG_IRDA is not set
-# CONFIG_IRQSOFF_TRACER is not set
-# CONFIG_IRQ_ALL_CPUS is not set
-# CONFIG_IRQ_DOMAIN_DEBUG is not set
-# CONFIG_IRQ_TIME_ACCOUNTING is not set
-# CONFIG_IR_GPIO_CIR is not set
-# CONFIG_IR_HIX5HD2 is not set
-# CONFIG_IR_IGUANA is not set
-# CONFIG_IR_IMG is not set
-# CONFIG_IR_IMON is not set
-# CONFIG_IR_JVC_DECODER is not set
-# CONFIG_IR_LIRC_CODEC is not set
-# CONFIG_IR_MCEUSB is not set
-# CONFIG_IR_NEC_DECODER is not set
-# CONFIG_IR_RC5_DECODER is not set
-# CONFIG_IR_RC5_SZ_DECODER is not set
-# CONFIG_IR_RC6_DECODER is not set
-# CONFIG_IR_REDRAT3 is not set
-# CONFIG_IR_SONY_DECODER is not set
-# CONFIG_IR_STREAMZAP is not set
-# CONFIG_IR_TTUSBIR is not set
-# CONFIG_ISCSI_BOOT_SYSFS is not set
-# CONFIG_ISCSI_TCP is not set
-CONFIG_ISDN=y
-# CONFIG_ISDN_AUDIO is not set
-# CONFIG_ISDN_CAPI is not set
-# CONFIG_ISDN_CAPI_CAPIDRV is not set
-# CONFIG_ISDN_DIVERSION is not set
-# CONFIG_ISDN_DRV_ACT2000 is not set
-# CONFIG_ISDN_DRV_AVMB1_VERBOSE_REASON is not set
-# CONFIG_ISDN_DRV_GIGASET is not set
-# CONFIG_ISDN_DRV_HISAX is not set
-# CONFIG_ISDN_DRV_ICN is not set
-# CONFIG_ISDN_DRV_LOOP is not set
-# CONFIG_ISDN_DRV_PCBIT is not set
-# CONFIG_ISDN_DRV_SC is not set
-# CONFIG_ISDN_I4L is not set
-# CONFIG_ISL29003 is not set
-# CONFIG_ISL29020 is not set
-# CONFIG_ISL29125 is not set
-# CONFIG_ISO9660_FS is not set
-# CONFIG_ISS4xx is not set
-# CONFIG_ITG3200 is not set
-# CONFIG_IWL3945 is not set
-# CONFIG_IWLAGN is not set
-# CONFIG_IWLWIFI is not set
-# CONFIG_IWMC3200TOP is not set
-# CONFIG_IXGB is not set
-# CONFIG_IXGBE is not set
-# CONFIG_IXGBEVF is not set
-# CONFIG_JBD is not set
-# CONFIG_JBD2_DEBUG is not set
-# CONFIG_JBD_DEBUG is not set
-# CONFIG_JFFS2_CMODE_FAVOURLZO is not set
-# CONFIG_JFFS2_CMODE_NONE is not set
-CONFIG_JFFS2_CMODE_PRIORITY=y
-# CONFIG_JFFS2_CMODE_SIZE is not set
-CONFIG_JFFS2_COMPRESSION_OPTIONS=y
-CONFIG_JFFS2_FS=y
-CONFIG_JFFS2_FS_DEBUG=0
-# CONFIG_JFFS2_FS_POSIX_ACL is not set
-# CONFIG_JFFS2_FS_SECURITY is not set
-# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
-CONFIG_JFFS2_FS_WRITEBUFFER=y
-CONFIG_JFFS2_FS_XATTR=y
-CONFIG_JFFS2_LZMA=y
-# CONFIG_JFFS2_LZO is not set
-CONFIG_JFFS2_RTIME=y
-# CONFIG_JFFS2_RUBIN is not set
-CONFIG_JFFS2_SUMMARY=y
-# CONFIG_JFFS2_ZLIB is not set
-# CONFIG_JFS_DEBUG is not set
-# CONFIG_JFS_FS is not set
-# CONFIG_JFS_POSIX_ACL is not set
-# CONFIG_JFS_SECURITY is not set
-# CONFIG_JFS_STATISTICS is not set
-# CONFIG_JME is not set
-CONFIG_JOLIET=y
-# CONFIG_JUMP_LABEL is not set
-# CONFIG_KALLSYMS is not set
-# CONFIG_KALLSYMS_ALL is not set
-# CONFIG_KALLSYMS_UNCOMPRESSED is not set
-# CONFIG_KARMA_PARTITION is not set
-# CONFIG_KERNEL_BZIP2 is not set
-# CONFIG_KERNEL_GZIP is not set
-# CONFIG_KERNEL_LZ4 is not set
-# CONFIG_KERNEL_LZMA is not set
-# CONFIG_KERNEL_LZO is not set
-CONFIG_KERNEL_MODE_NEON=y
-CONFIG_KERNEL_XZ=y
-CONFIG_KERNFS=y
-# CONFIG_KEXEC is not set
-# CONFIG_KEYBOARD_ADP5588 is not set
-# CONFIG_KEYBOARD_ADP5589 is not set
-# CONFIG_KEYBOARD_ATKBD is not set
-# CONFIG_KEYBOARD_CAP1106 is not set
-# CONFIG_KEYBOARD_GPIO_POLLED is not set
-# CONFIG_KEYBOARD_LKKBD is not set
-# CONFIG_KEYBOARD_LM8323 is not set
-# CONFIG_KEYBOARD_LM8333 is not set
-# CONFIG_KEYBOARD_MATRIX is not set
-# CONFIG_KEYBOARD_MAX7359 is not set
-# CONFIG_KEYBOARD_MCS is not set
-# CONFIG_KEYBOARD_MPR121 is not set
-# CONFIG_KEYBOARD_NEWTON is not set
-# CONFIG_KEYBOARD_OMAP4 is not set
-# CONFIG_KEYBOARD_OPENCORES is not set
-# CONFIG_KEYBOARD_PXA27x is not set
-# CONFIG_KEYBOARD_QT1070 is not set
-# CONFIG_KEYBOARD_QT2160 is not set
-# CONFIG_KEYBOARD_SAMSUNG is not set
-# CONFIG_KEYBOARD_SH_KEYSC is not set
-# CONFIG_KEYBOARD_STOWAWAY is not set
-# CONFIG_KEYBOARD_SUNKBD is not set
-# CONFIG_KEYBOARD_TCA6416 is not set
-# CONFIG_KEYBOARD_TCA8418 is not set
-# CONFIG_KEYBOARD_XTKBD is not set
-# CONFIG_KEYS is not set
-# CONFIG_KEYS_DEBUG_PROC_KEYS is not set
-# CONFIG_KGDB is not set
-# CONFIG_KMEMCHECK is not set
-# CONFIG_KPROBES is not set
-# CONFIG_KPROBES_SANITY_TEST is not set
-# CONFIG_KS8842 is not set
-# CONFIG_KS8851 is not set
-# CONFIG_KS8851_MLL is not set
-# CONFIG_KSM is not set
-# CONFIG_KSZ884X_PCI is not set
-CONFIG_KUSER_HELPERS=y
-# CONFIG_KVM_GUEST is not set
-# CONFIG_KXCJK1013 is not set
-# CONFIG_KXSD9 is not set
-# CONFIG_L2TP is not set
-# CONFIG_L2TP_ETH is not set
-# CONFIG_L2TP_IP is not set
-# CONFIG_L2TP_V3 is not set
-# CONFIG_LANMEDIA is not set
-# CONFIG_LANTIQ is not set
-# CONFIG_LAPB is not set
-# CONFIG_LASAT is not set
-# CONFIG_LATENCYTOP is not set
-# CONFIG_LATTICE_ECP3_CONFIG is not set
-CONFIG_LBDAF=y
-# CONFIG_LCD_HX8357 is not set
-# CONFIG_LCD_ILI922X is not set
-# CONFIG_LCD_ILI9320 is not set
-# CONFIG_LCD_LMS501KF03 is not set
-# CONFIG_LDM_PARTITION is not set
-# CONFIG_LEDS_ATMEL_PWM is not set
-# CONFIG_LEDS_BD2802 is not set
-# CONFIG_LEDS_BLINKM is not set
-CONFIG_LEDS_CLASS=y
-# CONFIG_LEDS_DAC124S085 is not set
-# CONFIG_LEDS_GPIO is not set
-CONFIG_LEDS_GPIO_OF=y
-CONFIG_LEDS_GPIO_PLATFORM=y
-# CONFIG_LEDS_INTEL_SS4200 is not set
-# CONFIG_LEDS_LM3530 is not set
-# CONFIG_LEDS_LM3556 is not set
-# CONFIG_LEDS_LM355x is not set
-# CONFIG_LEDS_LM3642 is not set
-# CONFIG_LEDS_LP3944 is not set
-# CONFIG_LEDS_LP5521 is not set
-# CONFIG_LEDS_LP5523 is not set
-# CONFIG_LEDS_LP5562 is not set
-# CONFIG_LEDS_LP8501 is not set
-# CONFIG_LEDS_LT3593 is not set
-# CONFIG_LEDS_NET5501 is not set
-# CONFIG_LEDS_OT200 is not set
-# CONFIG_LEDS_PCA9532 is not set
-# CONFIG_LEDS_PCA955X is not set
-# CONFIG_LEDS_PCA9633 is not set
-# CONFIG_LEDS_PCA963X is not set
-# CONFIG_LEDS_PCA9685 is not set
-# CONFIG_LEDS_PWM is not set
-# CONFIG_LEDS_RENESAS_TPU is not set
-# CONFIG_LEDS_SYSCON is not set
-# CONFIG_LEDS_TCA6507 is not set
-CONFIG_LEDS_TRIGGERS=y
-# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
-# CONFIG_LEDS_TRIGGER_CAMERA is not set
-# CONFIG_LEDS_TRIGGER_CPU is not set
-CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
-# CONFIG_LEDS_TRIGGER_GPIO is not set
-# CONFIG_LEDS_TRIGGER_HEARTBEAT is not set
-# CONFIG_LEDS_TRIGGER_IDE_DISK is not set
-CONFIG_LEDS_TRIGGER_NETDEV=y
-# CONFIG_LEDS_TRIGGER_ONESHOT is not set
-CONFIG_LEDS_TRIGGER_TIMER=y
-# CONFIG_LEDS_TRIGGER_TRANSIENT is not set
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_LIB80211 is not set
-# CONFIG_LIB80211_CRYPT_CCMP is not set
-# CONFIG_LIB80211_CRYPT_TKIP is not set
-# CONFIG_LIB80211_CRYPT_WEP is not set
-# CONFIG_LIB80211_DEBUG is not set
-# CONFIG_LIBCRC32C is not set
-# CONFIG_LIBERTAS is not set
-# CONFIG_LIBERTAS_THINFIRM is not set
-# CONFIG_LIBERTAS_USB is not set
-# CONFIG_LIBFC is not set
-# CONFIG_LIBFCOE is not set
-# CONFIG_LIBIPW_DEBUG is not set
-# CONFIG_LINE6_USB is not set
-# CONFIG_LIRC_STAGING is not set
-# CONFIG_LIS3L02DQ is not set
-# CONFIG_LKDTM is not set
-CONFIG_LLC=y
-# CONFIG_LLC2 is not set
-CONFIG_LOCALVERSION=""
-# CONFIG_LOCALVERSION_AUTO is not set
-# CONFIG_LOCKD is not set
-CONFIG_LOCKDEP_SUPPORT=y
-CONFIG_LOCKD_V4=y
-# CONFIG_LOCKUP_DETECTOR is not set
-# CONFIG_LOCK_STAT is not set
-# CONFIG_LOCK_TORTURE_TEST is not set
-# CONFIG_LOGFS is not set
-# CONFIG_LOGIG940_FF is not set
-# CONFIG_LOGIRUMBLEPAD2_FF is not set
-# CONFIG_LOGITECH_FF is not set
-# CONFIG_LOGIWHEELS_FF is not set
-# CONFIG_LOGO is not set
-CONFIG_LOG_BUF_SHIFT=17
-CONFIG_LOG_CPU_MAX_BUF_SHIFT=12
-# CONFIG_LOONGSON_MC146818 is not set
-# CONFIG_LP486E is not set
-# CONFIG_LPC_ICH is not set
-# CONFIG_LPC_SCH is not set
-# CONFIG_LP_CONSOLE is not set
-# CONFIG_LSI_ET1011C_PHY is not set
-# CONFIG_LTE_GDM724X is not set
-# CONFIG_LTPC is not set
-# CONFIG_LTR501 is not set
-# CONFIG_LUSTRE_FS is not set
-# CONFIG_LXT_PHY is not set
-# CONFIG_LZ4HC_COMPRESS is not set
-# CONFIG_LZ4_COMPRESS is not set
-# CONFIG_LZ4_DECOMPRESS is not set
-CONFIG_LZMA_COMPRESS=y
-CONFIG_LZMA_DECOMPRESS=y
-# CONFIG_LZO_COMPRESS is not set
-# CONFIG_LZO_DECOMPRESS is not set
-# CONFIG_M25PXX_PREFER_SMALL_SECTOR_ERASE is not set
-# CONFIG_MAC80211 is not set
-# CONFIG_MAC80211_MESSAGE_TRACING is not set
-# CONFIG_MACB is not set
-# CONFIG_MACH_DECSTATION is not set
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_JZ4740 is not set
-# CONFIG_MACH_LOONGSON is not set
-# CONFIG_MACH_LOONGSON1 is not set
-# CONFIG_MACH_NO_WESTBRIDGE is not set
-# CONFIG_MACH_TX39XX is not set
-# CONFIG_MACH_TX49XX is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_MACINTOSH_DRIVERS is not set
-# CONFIG_MACVLAN is not set
-# CONFIG_MACVTAP is not set
-# CONFIG_MAC_EMUMOUSEBTN is not set
-# CONFIG_MAC_PARTITION is not set
-# CONFIG_MAG3110 is not set
-# CONFIG_MAGIC_SYSRQ is not set
-CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x1
-# CONFIG_MAILBOX is not set
-# CONFIG_MANGLE_BOOTARGS is not set
-# CONFIG_MARVELL_PHY is not set
-# CONFIG_MAX1027 is not set
-# CONFIG_MAX1363 is not set
-# CONFIG_MAX517 is not set
-# CONFIG_MAX5821 is not set
-# CONFIG_MAX63XX_WATCHDOG is not set
-# CONFIG_MCB is not set
-# CONFIG_MCP320X is not set
-# CONFIG_MCP3422 is not set
-# CONFIG_MCP4725 is not set
-# CONFIG_MCP4922 is not set
-# CONFIG_MCPM is not set
-# CONFIG_MD is not set
-# CONFIG_MDIO_BCM_UNIMAC is not set
-# CONFIG_MDIO_BITBANG is not set
-# CONFIG_MDIO_BUS_MUX_GPIO is not set
-# CONFIG_MDIO_BUS_MUX_MMIOREG is not set
-# CONFIG_MD_FAULTY is not set
-# CONFIG_MEDIA_ANALOG_TV_SUPPORT is not set
-# CONFIG_MEDIA_ATTACH is not set
-# CONFIG_MEDIA_CAMERA_SUPPORT is not set
-# CONFIG_MEDIA_CONTROLLER is not set
-# CONFIG_MEDIA_DIGITAL_TV_SUPPORT is not set
-# CONFIG_MEDIA_PARPORT_SUPPORT is not set
-# CONFIG_MEDIA_PCI_SUPPORT is not set
-# CONFIG_MEDIA_RADIO_SUPPORT is not set
-# CONFIG_MEDIA_RC_SUPPORT is not set
-# CONFIG_MEDIA_SDR_SUPPORT is not set
-# CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
-# CONFIG_MEDIA_SUPPORT is not set
-# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
-# CONFIG_MEDIA_USB_SUPPORT is not set
-# CONFIG_MEGARAID_LEGACY is not set
-# CONFIG_MEGARAID_NEWGEN is not set
-# CONFIG_MEGARAID_SAS is not set
-# CONFIG_MEMORY is not set
-# CONFIG_MEMORY_FAILURE is not set
-# CONFIG_MEMSTICK is not set
-# CONFIG_MEN_A21_WDT is not set
-CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
-# CONFIG_MFD_88PM800 is not set
-# CONFIG_MFD_88PM805 is not set
-# CONFIG_MFD_88PM860X is not set
-# CONFIG_MFD_AAT2870_CORE is not set
-# CONFIG_MFD_ARIZONA_I2C is not set
-# CONFIG_MFD_ARIZONA_SPI is not set
-# CONFIG_MFD_AS3711 is not set
-# CONFIG_MFD_AS3722 is not set
-# CONFIG_MFD_ASIC3 is not set
-# CONFIG_MFD_AXP20X is not set
-# CONFIG_MFD_BCM590XX is not set
-# CONFIG_MFD_CORE is not set
-# CONFIG_MFD_CROS_EC is not set
-# CONFIG_MFD_CS5535 is not set
-# CONFIG_MFD_DA9052_I2C is not set
-# CONFIG_MFD_DA9052_SPI is not set
-# CONFIG_MFD_DA9055 is not set
-# CONFIG_MFD_DA9063 is not set
-# CONFIG_MFD_HI6421_PMIC is not set
-# CONFIG_MFD_JANZ_CMODIO is not set
-# CONFIG_MFD_KEMPLD is not set
-# CONFIG_MFD_LM3533 is not set
-# CONFIG_MFD_LP3943 is not set
-# CONFIG_MFD_LP8788 is not set
-# CONFIG_MFD_MAX14577 is not set
-# CONFIG_MFD_MAX77686 is not set
-# CONFIG_MFD_MAX77693 is not set
-# CONFIG_MFD_MAX8907 is not set
-# CONFIG_MFD_MAX8925 is not set
-# CONFIG_MFD_MAX8997 is not set
-# CONFIG_MFD_MAX8998 is not set
-# CONFIG_MFD_MC13783 is not set
-# CONFIG_MFD_MC13XXX is not set
-# CONFIG_MFD_MC13XXX_I2C is not set
-# CONFIG_MFD_MC13XXX_SPI is not set
-# CONFIG_MFD_MENF21BMC is not set
-# CONFIG_MFD_OMAP_USB_HOST is not set
-# CONFIG_MFD_PALMAS is not set
-# CONFIG_MFD_PCF50633 is not set
-# CONFIG_MFD_PM8921_CORE is not set
-# CONFIG_MFD_RC5T583 is not set
-# CONFIG_MFD_RDC321X is not set
-# CONFIG_MFD_RETU is not set
-# CONFIG_MFD_RK808 is not set
-# CONFIG_MFD_RN5T618 is not set
-# CONFIG_MFD_RTSX_PCI is not set
-# CONFIG_MFD_RTSX_USB is not set
-# CONFIG_MFD_S5M_CORE is not set
-# CONFIG_MFD_SEC_CORE is not set
-# CONFIG_MFD_SI476X_CORE is not set
-# CONFIG_MFD_SM501 is not set
-# CONFIG_MFD_SMSC is not set
-# CONFIG_MFD_STMPE is not set
-CONFIG_MFD_SUPPORT=y
-# CONFIG_MFD_SYSCON is not set
-# CONFIG_MFD_T7L66XB is not set
-# CONFIG_MFD_TC3589X is not set
-# CONFIG_MFD_TC6387XB is not set
-# CONFIG_MFD_TC6393XB is not set
-# CONFIG_MFD_TIMBERDALE is not set
-# CONFIG_MFD_TI_AM335X_TSCADC is not set
-# CONFIG_MFD_TMIO is not set
-# CONFIG_MFD_TPS65090 is not set
-# CONFIG_MFD_TPS65217 is not set
-# CONFIG_MFD_TPS65218 is not set
-# CONFIG_MFD_TPS6586X is not set
-# CONFIG_MFD_TPS65910 is not set
-# CONFIG_MFD_TPS65912 is not set
-# CONFIG_MFD_TPS65912_I2C is not set
-# CONFIG_MFD_TPS65912_SPI is not set
-# CONFIG_MFD_TPS80031 is not set
-# CONFIG_MFD_VIPERBOARD is not set
-# CONFIG_MFD_VX855 is not set
-# CONFIG_MFD_WL1273_CORE is not set
-# CONFIG_MFD_WM831X is not set
-# CONFIG_MFD_WM831X_I2C is not set
-# CONFIG_MFD_WM831X_SPI is not set
-# CONFIG_MFD_WM8350_I2C is not set
-# CONFIG_MFD_WM8400 is not set
-# CONFIG_MFD_WM8994 is not set
-# CONFIG_MG_DISK is not set
-# CONFIG_MICREL_KS8995MA is not set
-# CONFIG_MICREL_PHY is not set
-# CONFIG_MIGRATION is not set
-CONFIG_MII=y
-# CONFIG_MIKROTIK_RB532 is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_MINIX_FS_NATIVE_ENDIAN is not set
-# CONFIG_MINIX_SUBPARTITION is not set
-# CONFIG_MIPS_ALCHEMY is not set
-# CONFIG_MIPS_COBALT is not set
-# CONFIG_MIPS_FPU_EMULATOR is not set
-# CONFIG_MIPS_MALTA is not set
-# CONFIG_MIPS_O32_FP64_SUPPORT is not set
-# CONFIG_MIPS_PARAVIRT is not set
-# CONFIG_MIPS_SEAD3 is not set
-# CONFIG_MIPS_SIM is not set
-CONFIG_MISC_DEVICES=y
-CONFIG_MISC_FILESYSTEMS=y
-# CONFIG_MISDN is not set
-# CONFIG_MISDN_AVMFRITZ is not set
-# CONFIG_MISDN_HFCPCI is not set
-# CONFIG_MISDN_HFCUSB is not set
-# CONFIG_MISDN_INFINEON is not set
-# CONFIG_MISDN_NETJET is not set
-# CONFIG_MISDN_SPEEDFAX is not set
-# CONFIG_MISDN_W6692 is not set
-# CONFIG_MKISS is not set
-# CONFIG_MLX4_CORE is not set
-# CONFIG_MLX4_EN is not set
-# CONFIG_MLX5_CORE is not set
-# CONFIG_MLX90614 is not set
-# CONFIG_MMA8452 is not set
-# CONFIG_MMC is not set
-# CONFIG_MMC_ARMMMCI is not set
-# CONFIG_MMC_AU1X is not set
-# CONFIG_MMC_BLOCK is not set
-CONFIG_MMC_BLOCK_BOUNCE=y
-CONFIG_MMC_BLOCK_MINORS=8
-# CONFIG_MMC_CB710 is not set
-# CONFIG_MMC_CLKGATE is not set
-# CONFIG_MMC_DEBUG is not set
-# CONFIG_MMC_DW is not set
-# CONFIG_MMC_MVSDIO is not set
-# CONFIG_MMC_S3C is not set
-# CONFIG_MMC_SDHCI is not set
-# CONFIG_MMC_SDHCI_ACPI is not set
-# CONFIG_MMC_SDHCI_BCM_KONA is not set
-# CONFIG_MMC_SDHCI_MSM is not set
-# CONFIG_MMC_SDHCI_OF_ARASAN is not set
-# CONFIG_MMC_SDHCI_OF_ESDHC is not set
-# CONFIG_MMC_SDHCI_OF_HLWD is not set
-# CONFIG_MMC_SDHCI_PXAV2 is not set
-# CONFIG_MMC_SDHCI_PXAV3 is not set
-# CONFIG_MMC_SDRICOH_CS is not set
-# CONFIG_MMC_SPI is not set
-# CONFIG_MMC_TEST is not set
-# CONFIG_MMC_UNSAFE_RESUME is not set
-# CONFIG_MMC_USDHI6ROL0 is not set
-# CONFIG_MMC_USHC is not set
-# CONFIG_MMC_VIA_SDMMC is not set
-# CONFIG_MMC_VUB300 is not set
-# CONFIG_MMIOTRACE is not set
-CONFIG_MMU=y
-CONFIG_MODULES=y
-# CONFIG_MODULE_COMPRESS is not set
-# CONFIG_MODULE_FORCE_LOAD is not set
-# CONFIG_MODULE_FORCE_UNLOAD is not set
-# CONFIG_MODULE_SIG is not set
-# CONFIG_MODULE_SRCVERSION_ALL is not set
-CONFIG_MODULE_STRIPPED=y
-CONFIG_MODULE_UNLOAD=y
-# CONFIG_MODVERSIONS is not set
-# CONFIG_MOUSE_APPLETOUCH is not set
-# CONFIG_MOUSE_GPIO is not set
-# CONFIG_MOUSE_INPORT is not set
-# CONFIG_MOUSE_LOGIBM is not set
-# CONFIG_MOUSE_PC110PAD is not set
-# CONFIG_MOUSE_PS2_SENTELIC is not set
-# CONFIG_MOUSE_SYNAPTICS_I2C is not set
-# CONFIG_MOUSE_SYNAPTICS_USB is not set
-# CONFIG_MPL115 is not set
-# CONFIG_MPL3115 is not set
-# CONFIG_MSDOS_FS is not set
-CONFIG_MSDOS_PARTITION=y
-# CONFIG_MSI_BITMAP_SELFTEST is not set
-# CONFIG_MSI_LAPTOP is not set
-CONFIG_MTD=y
-# CONFIG_MTD_ABSENT is not set
-# CONFIG_MTD_AFS_PARTS is not set
-# CONFIG_MTD_ALAUDA is not set
-# CONFIG_MTD_AR7_PARTS is not set
-# CONFIG_MTD_ARM_INTEGRATOR is not set
-CONFIG_MTD_BLKDEVS=y
-CONFIG_MTD_BLOCK=y
-# CONFIG_MTD_BLOCK2MTD is not set
-CONFIG_MTD_CFI=y
-# CONFIG_MTD_CFI_ADV_OPTIONS is not set
-CONFIG_MTD_CFI_AMDSTD=y
-# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
-CONFIG_MTD_CFI_I1=y
-CONFIG_MTD_CFI_I2=y
-# CONFIG_MTD_CFI_I4 is not set
-# CONFIG_MTD_CFI_I8 is not set
-CONFIG_MTD_CFI_INTELEXT=y
-# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
-CONFIG_MTD_CFI_NOSWAP=y
-# CONFIG_MTD_CFI_STAA is not set
-CONFIG_MTD_CFI_UTIL=y
-CONFIG_MTD_CHAR=y
-# CONFIG_MTD_CMDLINE_PARTS is not set
-CONFIG_MTD_COMPLEX_MAPPINGS=y
-# CONFIG_MTD_DATAFLASH is not set
-# CONFIG_MTD_DEBUG is not set
-# CONFIG_MTD_DOC2000 is not set
-# CONFIG_MTD_DOC2001 is not set
-# CONFIG_MTD_DOC2001PLUS is not set
-# CONFIG_MTD_DOCG3 is not set
-CONFIG_MTD_GEN_PROBE=y
-# CONFIG_MTD_GPIO_ADDR is not set
-# CONFIG_MTD_INTEL_VR_NOR is not set
-# CONFIG_MTD_JEDECPROBE is not set
-# CONFIG_MTD_LATCH_ADDR is not set
-# CONFIG_MTD_LPDDR is not set
-# CONFIG_MTD_LPDDR2_NVM is not set
-# CONFIG_MTD_M25P80 is not set
-CONFIG_MTD_MAP_BANK_WIDTH_1=y
-# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
-CONFIG_MTD_MAP_BANK_WIDTH_2=y
-# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
-CONFIG_MTD_MAP_BANK_WIDTH_4=y
-# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
-# CONFIG_MTD_MTDRAM is not set
-# CONFIG_MTD_MYLOADER_PARTS is not set
-# CONFIG_MTD_NAND is not set
-# CONFIG_MTD_NAND_AMS_DELTA is not set
-# CONFIG_MTD_NAND_AR934X is not set
-# CONFIG_MTD_NAND_AR934X_HW_ECC is not set
-# CONFIG_MTD_NAND_ATMEL is not set
-# CONFIG_MTD_NAND_AU1550 is not set
-# CONFIG_MTD_NAND_AUTCPU12 is not set
-# CONFIG_MTD_NAND_BCH is not set
-# CONFIG_MTD_NAND_BCM_UMI is not set
-# CONFIG_MTD_NAND_BF5XX is not set
-# CONFIG_MTD_NAND_CAFE is not set
-# CONFIG_MTD_NAND_CM_X270 is not set
-# CONFIG_MTD_NAND_CS553X is not set
-# CONFIG_MTD_NAND_DAVINCI is not set
-# CONFIG_MTD_NAND_DENALI is not set
-CONFIG_MTD_NAND_DENALI_SCRATCH_REG_ADDR=0xff108018
-# CONFIG_MTD_NAND_DISKONCHIP is not set
-# CONFIG_MTD_NAND_DOCG4 is not set
-# CONFIG_MTD_NAND_ECC is not set
-# CONFIG_MTD_NAND_ECC_BCH is not set
-# CONFIG_MTD_NAND_ECC_SMC is not set
-# CONFIG_MTD_NAND_FSL_ELBC is not set
-# CONFIG_MTD_NAND_FSL_IFC is not set
-# CONFIG_MTD_NAND_FSL_UPM is not set
-# CONFIG_MTD_NAND_FSMC is not set
-# CONFIG_MTD_NAND_GPIO is not set
-# CONFIG_MTD_NAND_GPMI_NAND is not set
-# CONFIG_MTD_NAND_H1900 is not set
-CONFIG_MTD_NAND_IDS=y
-# CONFIG_MTD_NAND_JZ4740 is not set
-# CONFIG_MTD_NAND_MPC5121_NFC is not set
-# CONFIG_MTD_NAND_MUSEUM_IDS is not set
-# CONFIG_MTD_NAND_MXC is not set
-# CONFIG_MTD_NAND_NANDSIM is not set
-# CONFIG_MTD_NAND_NDFC is not set
-# CONFIG_MTD_NAND_NOMADIK is not set
-# CONFIG_MTD_NAND_NUC900 is not set
-# CONFIG_MTD_NAND_OMAP2 is not set
-# CONFIG_MTD_NAND_OMAP_BCH_BUILD is not set
-# CONFIG_MTD_NAND_ORION is not set
-# CONFIG_MTD_NAND_PASEMI is not set
-# CONFIG_MTD_NAND_PLATFORM is not set
-# CONFIG_MTD_NAND_PPCHAMELEONEVB is not set
-# CONFIG_MTD_NAND_PXA3xx is not set
-# CONFIG_MTD_NAND_RB4XX is not set
-# CONFIG_MTD_NAND_RB750 is not set
-# CONFIG_MTD_NAND_RICOH is not set
-# CONFIG_MTD_NAND_RTC_FROM4 is not set
-# CONFIG_MTD_NAND_S3C2410 is not set
-# CONFIG_MTD_NAND_SHARPSL is not set
-# CONFIG_MTD_NAND_SH_FLCTL is not set
-# CONFIG_MTD_NAND_SOCRATES is not set
-# CONFIG_MTD_NAND_SPIA is not set
-# CONFIG_MTD_NAND_TMIO is not set
-# CONFIG_MTD_NAND_TXX9NDFMC is not set
-# CONFIG_MTD_NAND_VERIFY_WRITE is not set
-CONFIG_MTD_OF_PARTS=y
-# CONFIG_MTD_ONENAND is not set
-# CONFIG_MTD_OOPS is not set
-# CONFIG_MTD_OTP is not set
-# CONFIG_MTD_PCI is not set
-# CONFIG_MTD_PCMCIA is not set
-# CONFIG_MTD_PHRAM is not set
-# CONFIG_MTD_PHYSMAP is not set
-# CONFIG_MTD_PHYSMAP_COMPAT is not set
-CONFIG_MTD_PHYSMAP_OF=y
-# CONFIG_MTD_PLATRAM is not set
-# CONFIG_MTD_PMC551 is not set
-# CONFIG_MTD_RAM is not set
-CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK=-1
-# CONFIG_MTD_REDBOOT_PARTS is not set
-# CONFIG_MTD_REDBOOT_PARTS_READONLY is not set
-# CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED is not set
-# CONFIG_MTD_ROM is not set
-CONFIG_MTD_ROOTFS_ROOT_DEV=y
-CONFIG_MTD_ROOTFS_SPLIT=y
-# CONFIG_MTD_SLRAM is not set
-# CONFIG_MTD_SM_COMMON is not set
-# CONFIG_MTD_SPINAND_MT29F is not set
-# CONFIG_MTD_SPI_NOR is not set
-# CONFIG_MTD_SPI_NOR_USE_4K_SECTORS is not set
-CONFIG_MTD_SPLIT=y
-# CONFIG_MTD_SPLIT_BRNIMAGE_FW is not set
-# CONFIG_MTD_SPLIT_EVA_FW is not set
-# CONFIG_MTD_SPLIT_FIRMWARE is not set
-CONFIG_MTD_SPLIT_FIRMWARE_NAME="firmware"
-# CONFIG_MTD_SPLIT_FIT_FW is not set
-# CONFIG_MTD_SPLIT_JIMAGE_FW is not set
-# CONFIG_MTD_SPLIT_LZMA_FW is not set
-# CONFIG_MTD_SPLIT_MINOR_FW is not set
-# CONFIG_MTD_SPLIT_SEAMA_FW is not set
-CONFIG_MTD_SPLIT_SQUASHFS_ROOT=y
-CONFIG_MTD_SPLIT_SUPPORT=y
-# CONFIG_MTD_SPLIT_TPLINK_FW is not set
-# CONFIG_MTD_SPLIT_TRX_FW is not set
-# CONFIG_MTD_SPLIT_UIMAGE_FW is not set
-# CONFIG_MTD_SPLIT_WRGG_FW is not set
-# CONFIG_MTD_SST25L is not set
-# CONFIG_MTD_SWAP is not set
-# CONFIG_MTD_TESTS is not set
-# CONFIG_MTD_UBI is not set
-# CONFIG_MTD_UIMAGE_SPLIT is not set
-# CONFIG_MUTEX_SPIN_ON_OWNER is not set
-# CONFIG_MV643XX_ETH is not set
-# CONFIG_MVMDIO is not set
-# CONFIG_MVSW6171_PHY is not set
-# CONFIG_MVSW61XX_PHY is not set
-# CONFIG_MVSWITCH_PHY is not set
-# CONFIG_MWAVE is not set
-# CONFIG_MWIFIEX is not set
-# CONFIG_MWL8K is not set
-# CONFIG_MYRI10GE is not set
-# CONFIG_NAMESPACES is not set
-# CONFIG_NATIONAL_PHY is not set
-# CONFIG_NATSEMI is not set
-# CONFIG_NAU7802 is not set
-# CONFIG_NBPFAXI_DMA is not set
-# CONFIG_NCP_FS is not set
-# CONFIG_NE2000 is not set
-# CONFIG_NE2K_PCI is not set
-# CONFIG_NEC_MARKEINS is not set
-CONFIG_NET=y
-# CONFIG_NETCONSOLE is not set
-CONFIG_NETDEVICES=y
-CONFIG_NETDEV_1000=y
-# CONFIG_NETDEV_10000 is not set
-# CONFIG_NETFILTER is not set
-# CONFIG_NETFILTER_ADVANCED is not set
-# CONFIG_NETFILTER_DEBUG is not set
-# CONFIG_NETFILTER_NETLINK is not set
-# CONFIG_NETFILTER_NETLINK_ACCT is not set
-# CONFIG_NETFILTER_NETLINK_LOG is not set
-# CONFIG_NETFILTER_NETLINK_QUEUE is not set
-# CONFIG_NETFILTER_NETLINK_QUEUE_CT is not set
-# CONFIG_NETFILTER_TPROXY is not set
-# CONFIG_NETFILTER_XTABLES is not set
-# CONFIG_NETFILTER_XT_CONNMARK is not set
-# CONFIG_NETFILTER_XT_MARK is not set
-# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
-# CONFIG_NETFILTER_XT_MATCH_BPF is not set
-# CONFIG_NETFILTER_XT_MATCH_CGROUP is not set
-# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
-# CONFIG_NETFILTER_XT_MATCH_COMMENT is not set
-# CONFIG_NETFILTER_XT_MATCH_CONNBYTES is not set
-# CONFIG_NETFILTER_XT_MATCH_CONNLABEL is not set
-# CONFIG_NETFILTER_XT_MATCH_CONNLIMIT is not set
-# CONFIG_NETFILTER_XT_MATCH_CONNMARK is not set
-# CONFIG_NETFILTER_XT_MATCH_CONNTRACK is not set
-# CONFIG_NETFILTER_XT_MATCH_CPU is not set
-# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
-# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
-# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
-# CONFIG_NETFILTER_XT_MATCH_ECN is not set
-# CONFIG_NETFILTER_XT_MATCH_ESP is not set
-# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
-# CONFIG_NETFILTER_XT_MATCH_HELPER is not set
-# CONFIG_NETFILTER_XT_MATCH_HL is not set
-# CONFIG_NETFILTER_XT_MATCH_IPCOMP is not set
-# CONFIG_NETFILTER_XT_MATCH_IPRANGE is not set
-# CONFIG_NETFILTER_XT_MATCH_L2TP is not set
-# CONFIG_NETFILTER_XT_MATCH_LAYER7 is not set
-# CONFIG_NETFILTER_XT_MATCH_LAYER7_DEBUG is not set
-# CONFIG_NETFILTER_XT_MATCH_LENGTH is not set
-# CONFIG_NETFILTER_XT_MATCH_LIMIT is not set
-# CONFIG_NETFILTER_XT_MATCH_MAC is not set
-# CONFIG_NETFILTER_XT_MATCH_MARK is not set
-# CONFIG_NETFILTER_XT_MATCH_MULTIPORT is not set
-# CONFIG_NETFILTER_XT_MATCH_NFACCT is not set
-# CONFIG_NETFILTER_XT_MATCH_OSF is not set
-# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
-# CONFIG_NETFILTER_XT_MATCH_PHYSDEV is not set
-# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
-# CONFIG_NETFILTER_XT_MATCH_POLICY is not set
-# CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
-# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
-# CONFIG_NETFILTER_XT_MATCH_REALM is not set
-# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
-# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
-# CONFIG_NETFILTER_XT_MATCH_SOCKET is not set
-# CONFIG_NETFILTER_XT_MATCH_STATE is not set
-# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
-# CONFIG_NETFILTER_XT_MATCH_STRING is not set
-# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
-# CONFIG_NETFILTER_XT_MATCH_TIME is not set
-# CONFIG_NETFILTER_XT_MATCH_U32 is not set
-# CONFIG_NETFILTER_XT_TARGET_AUDIT is not set
-# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
-# CONFIG_NETFILTER_XT_TARGET_CLASSIFY is not set
-# CONFIG_NETFILTER_XT_TARGET_CONNMARK is not set
-# CONFIG_NETFILTER_XT_TARGET_CT is not set
-# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
-# CONFIG_NETFILTER_XT_TARGET_HL is not set
-# CONFIG_NETFILTER_XT_TARGET_HMARK is not set
-# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
-# CONFIG_NETFILTER_XT_TARGET_LED is not set
-# CONFIG_NETFILTER_XT_TARGET_LOG is not set
-# CONFIG_NETFILTER_XT_TARGET_MARK is not set
-# CONFIG_NETFILTER_XT_TARGET_NETMAP is not set
-# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
-# CONFIG_NETFILTER_XT_TARGET_NFQUEUE is not set
-# CONFIG_NETFILTER_XT_TARGET_NOTRACK is not set
-# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
-# CONFIG_NETFILTER_XT_TARGET_REDIRECT is not set
-# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
-# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
-# CONFIG_NETFILTER_XT_TARGET_TEE is not set
-# CONFIG_NETFILTER_XT_TARGET_TPROXY is not set
-# CONFIG_NETFILTER_XT_TARGET_TRACE is not set
-# CONFIG_NETLINK_DIAG is not set
-# CONFIG_NETLINK_MMAP is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NETROM is not set
-CONFIG_NETWORK_FILESYSTEMS=y
-# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
-# CONFIG_NETWORK_SECMARK is not set
-# CONFIG_NETXEN_NIC is not set
-# CONFIG_NET_9P is not set
-# CONFIG_NET_ACT_CSUM is not set
-# CONFIG_NET_ACT_GACT is not set
-# CONFIG_NET_ACT_IPT is not set
-# CONFIG_NET_ACT_MIRRED is not set
-# CONFIG_NET_ACT_NAT is not set
-# CONFIG_NET_ACT_PEDIT is not set
-# CONFIG_NET_ACT_POLICE is not set
-# CONFIG_NET_ACT_SIMP is not set
-# CONFIG_NET_ACT_SKBEDIT is not set
-CONFIG_NET_CADENCE=y
-# CONFIG_NET_CALXEDA_XGMAC is not set
-CONFIG_NET_CLS=y
-# CONFIG_NET_CLS_ACT is not set
-# CONFIG_NET_CLS_BASIC is not set
-# CONFIG_NET_CLS_BPF is not set
-# CONFIG_NET_CLS_FLOW is not set
-# CONFIG_NET_CLS_FW is not set
-CONFIG_NET_CLS_IND=y
-# CONFIG_NET_CLS_ROUTE4 is not set
-# CONFIG_NET_CLS_RSVP is not set
-# CONFIG_NET_CLS_RSVP6 is not set
-# CONFIG_NET_CLS_TCINDEX is not set
-# CONFIG_NET_CLS_U32 is not set
-CONFIG_NET_CORE=y
-# CONFIG_NET_DROP_MONITOR is not set
-# CONFIG_NET_DSA is not set
-# CONFIG_NET_DSA_BCM_SF2 is not set
-# CONFIG_NET_DSA_MV88E6060 is not set
-# CONFIG_NET_DSA_MV88E6123_61_65 is not set
-# CONFIG_NET_DSA_MV88E6131 is not set
-# CONFIG_NET_DSA_MV88E6171 is not set
-# CONFIG_NET_DSA_MV88E6XXX is not set
-# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
-# CONFIG_NET_DSA_TAG_DSA is not set
-# CONFIG_NET_DSA_TAG_EDSA is not set
-# CONFIG_NET_EMATCH is not set
-# CONFIG_NET_EMATCH_CMP is not set
-# CONFIG_NET_EMATCH_META is not set
-# CONFIG_NET_EMATCH_NBYTE is not set
-CONFIG_NET_EMATCH_STACK=32
-# CONFIG_NET_EMATCH_TEXT is not set
-# CONFIG_NET_EMATCH_U32 is not set
-CONFIG_NET_ETHERNET=y
-# CONFIG_NET_FC is not set
-# CONFIG_NET_FOU is not set
-# CONFIG_NET_IPGRE is not set
-CONFIG_NET_IPGRE_BROADCAST=y
-# CONFIG_NET_IPGRE_DEMUX is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPVTI is not set
-# CONFIG_NET_IP_TUNNEL is not set
-# CONFIG_NET_ISA is not set
-# CONFIG_NET_KEY is not set
-# CONFIG_NET_KEY_MIGRATE is not set
-# CONFIG_NET_MPLS_GSO is not set
-# CONFIG_NET_PACKET_ENGINE is not set
-CONFIG_NET_PCI=y
-# CONFIG_NET_PCMCIA is not set
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NET_POCKET is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_NET_PTP_CLASSIFY is not set
-CONFIG_NET_RX_BUSY_POLL=y
-# CONFIG_NET_SB1000 is not set
-CONFIG_NET_SCHED=y
-# CONFIG_NET_SCH_ATM is not set
-# CONFIG_NET_SCH_CBQ is not set
-# CONFIG_NET_SCH_CHOKE is not set
-# CONFIG_NET_SCH_CODEL is not set
-# CONFIG_NET_SCH_DRR is not set
-# CONFIG_NET_SCH_DSMARK is not set
-CONFIG_NET_SCH_FIFO=y
-# CONFIG_NET_SCH_FQ is not set
-CONFIG_NET_SCH_FQ_CODEL=y
-# CONFIG_NET_SCH_GRED is not set
-# CONFIG_NET_SCH_HFSC is not set
-# CONFIG_NET_SCH_HHF is not set
-# CONFIG_NET_SCH_HTB is not set
-# CONFIG_NET_SCH_INGRESS is not set
-# CONFIG_NET_SCH_MQPRIO is not set
-# CONFIG_NET_SCH_MULTIQ is not set
-# CONFIG_NET_SCH_NETEM is not set
-# CONFIG_NET_SCH_PIE is not set
-# CONFIG_NET_SCH_PLUG is not set
-# CONFIG_NET_SCH_PRIO is not set
-# CONFIG_NET_SCH_QFQ is not set
-# CONFIG_NET_SCH_RED is not set
-# CONFIG_NET_SCH_SFB is not set
-# CONFIG_NET_SCH_SFQ is not set
-# CONFIG_NET_SCH_TBF is not set
-# CONFIG_NET_SCH_TEQL is not set
-# CONFIG_NET_SCTPPROBE is not set
-# CONFIG_NET_TCPPROBE is not set
-# CONFIG_NET_TEAM is not set
-# CONFIG_NET_TULIP is not set
-# CONFIG_NET_UDP_TUNNEL is not set
-CONFIG_NET_VENDOR_3COM=y
-CONFIG_NET_VENDOR_8390=y
-CONFIG_NET_VENDOR_ADAPTEC=y
-CONFIG_NET_VENDOR_AGERE=y
-CONFIG_NET_VENDOR_ALTEON=y
-CONFIG_NET_VENDOR_AMD=y
-CONFIG_NET_VENDOR_ARC=y
-CONFIG_NET_VENDOR_ATHEROS=y
-CONFIG_NET_VENDOR_BROADCOM=y
-CONFIG_NET_VENDOR_BROCADE=y
-CONFIG_NET_VENDOR_CHELSIO=y
-CONFIG_NET_VENDOR_CIRRUS=y
-CONFIG_NET_VENDOR_CISCO=y
-CONFIG_NET_VENDOR_DEC=y
-CONFIG_NET_VENDOR_DLINK=y
-CONFIG_NET_VENDOR_EMULEX=y
-CONFIG_NET_VENDOR_EXAR=y
-CONFIG_NET_VENDOR_FARADAY=y
-CONFIG_NET_VENDOR_FREESCALE=y
-CONFIG_NET_VENDOR_FUJITSU=y
-CONFIG_NET_VENDOR_HISILICON=y
-CONFIG_NET_VENDOR_HP=y
-CONFIG_NET_VENDOR_I825XX=y
-CONFIG_NET_VENDOR_IBM=y
-CONFIG_NET_VENDOR_INTEL=y
-CONFIG_NET_VENDOR_MARVELL=y
-CONFIG_NET_VENDOR_MELLANOX=y
-CONFIG_NET_VENDOR_MICREL=y
-CONFIG_NET_VENDOR_MICROCHIP=y
-CONFIG_NET_VENDOR_MYRI=y
-CONFIG_NET_VENDOR_NATSEMI=y
-CONFIG_NET_VENDOR_NVIDIA=y
-CONFIG_NET_VENDOR_OKI=y
-CONFIG_NET_VENDOR_QLOGIC=y
-CONFIG_NET_VENDOR_QUALCOMM=y
-CONFIG_NET_VENDOR_RDC=y
-CONFIG_NET_VENDOR_REALTEK=y
-CONFIG_NET_VENDOR_SAMSUNG=y
-CONFIG_NET_VENDOR_SEEQ=y
-CONFIG_NET_VENDOR_SILAN=y
-CONFIG_NET_VENDOR_SILICOM=y
-CONFIG_NET_VENDOR_SIS=y
-CONFIG_NET_VENDOR_SMSC=y
-CONFIG_NET_VENDOR_STMICRO=y
-CONFIG_NET_VENDOR_SUN=y
-CONFIG_NET_VENDOR_TEHUTI=y
-CONFIG_NET_VENDOR_TI=y
-CONFIG_NET_VENDOR_TOSHIBA=y
-CONFIG_NET_VENDOR_VIA=y
-# CONFIG_NET_VENDOR_WIZNET is not set
-CONFIG_NET_VENDOR_XILINX=y
-CONFIG_NET_VENDOR_XIRCOM=y
-# CONFIG_NET_XGENE is not set
-CONFIG_NEW_LEDS=y
-# CONFIG_NFC is not set
-# CONFIG_NFC_DEVICES is not set
-# CONFIG_NFSD is not set
-# CONFIG_NFSD_DEPRECATED is not set
-# CONFIG_NFSD_V2_ACL is not set
-CONFIG_NFSD_V3=y
-# CONFIG_NFSD_V3_ACL is not set
-# CONFIG_NFSD_V4 is not set
-# CONFIG_NFS_ACL_SUPPORT is not set
-CONFIG_NFS_COMMON=y
-# CONFIG_NFS_FS is not set
-# CONFIG_NFS_FSCACHE is not set
-# CONFIG_NFS_SWAP is not set
-# CONFIG_NFS_V2 is not set
-CONFIG_NFS_V3=y
-# CONFIG_NFS_V3_ACL is not set
-# CONFIG_NFS_V4 is not set
-# CONFIG_NFS_V4_1 is not set
-# CONFIG_NFTL is not set
-# CONFIG_NF_CONNTRACK is not set
-# CONFIG_NF_CONNTRACK_AMANDA is not set
-# CONFIG_NF_CONNTRACK_EVENTS is not set
-# CONFIG_NF_CONNTRACK_FTP is not set
-# CONFIG_NF_CONNTRACK_H323 is not set
-# CONFIG_NF_CONNTRACK_IPV4 is not set
-# CONFIG_NF_CONNTRACK_IPV6 is not set
-# CONFIG_NF_CONNTRACK_IRC is not set
-# CONFIG_NF_CONNTRACK_MARK is not set
-# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
-# CONFIG_NF_CONNTRACK_PPTP is not set
-CONFIG_NF_CONNTRACK_PROCFS=y
-# CONFIG_NF_CONNTRACK_PROC_COMPAT is not set
-# CONFIG_NF_CONNTRACK_RTSP is not set
-# CONFIG_NF_CONNTRACK_SANE is not set
-# CONFIG_NF_CONNTRACK_SIP is not set
-# CONFIG_NF_CONNTRACK_SNMP is not set
-# CONFIG_NF_CONNTRACK_TFTP is not set
-# CONFIG_NF_CONNTRACK_TIMEOUT is not set
-# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
-# CONFIG_NF_CONNTRACK_ZONES is not set
-# CONFIG_NF_CT_NETLINK is not set
-# CONFIG_NF_CT_NETLINK_TIMEOUT is not set
-# CONFIG_NF_CT_PROTO_DCCP is not set
-# CONFIG_NF_CT_PROTO_GRE is not set
-# CONFIG_NF_CT_PROTO_SCTP is not set
-# CONFIG_NF_CT_PROTO_UDPLITE is not set
-# CONFIG_NF_DEFRAG_IPV4 is not set
-# CONFIG_NF_LOG_ARP is not set
-# CONFIG_NF_LOG_IPV4 is not set
-# CONFIG_NF_NAT is not set
-# CONFIG_NF_NAT_AMANDA is not set
-# CONFIG_NF_NAT_FTP is not set
-# CONFIG_NF_NAT_H323 is not set
-# CONFIG_NF_NAT_IPV6 is not set
-# CONFIG_NF_NAT_IRC is not set
-# CONFIG_NF_NAT_MASQUERADE_IPV4 is not set
-# CONFIG_NF_NAT_MASQUERADE_IPV6 is not set
-# CONFIG_NF_NAT_NEEDED is not set
-# CONFIG_NF_NAT_PPTP is not set
-# CONFIG_NF_NAT_PROTO_GRE is not set
-# CONFIG_NF_NAT_RTSP is not set
-# CONFIG_NF_NAT_SIP is not set
-# CONFIG_NF_NAT_SNMP_BASIC is not set
-# CONFIG_NF_NAT_TFTP is not set
-# CONFIG_NF_REJECT_IPV4 is not set
-# CONFIG_NF_REJECT_IPV6 is not set
-# CONFIG_NF_TABLES is not set
-# CONFIG_NI52 is not set
-# CONFIG_NI65 is not set
-# CONFIG_NILFS2_FS is not set
-# CONFIG_NIU is not set
-# CONFIG_NL80211_TESTMODE is not set
-CONFIG_NLATTR=y
-# CONFIG_NLMON is not set
-# CONFIG_NLM_XLP_BOARD is not set
-# CONFIG_NLM_XLR_BOARD is not set
-# CONFIG_NLS is not set
-# CONFIG_NLS_ASCII is not set
-# CONFIG_NLS_CODEPAGE_1250 is not set
-# CONFIG_NLS_CODEPAGE_1251 is not set
-# CONFIG_NLS_CODEPAGE_437 is not set
-# CONFIG_NLS_CODEPAGE_737 is not set
-# CONFIG_NLS_CODEPAGE_775 is not set
-# CONFIG_NLS_CODEPAGE_850 is not set
-# CONFIG_NLS_CODEPAGE_852 is not set
-# CONFIG_NLS_CODEPAGE_855 is not set
-# CONFIG_NLS_CODEPAGE_857 is not set
-# CONFIG_NLS_CODEPAGE_860 is not set
-# CONFIG_NLS_CODEPAGE_861 is not set
-# CONFIG_NLS_CODEPAGE_862 is not set
-# CONFIG_NLS_CODEPAGE_863 is not set
-# CONFIG_NLS_CODEPAGE_864 is not set
-# CONFIG_NLS_CODEPAGE_865 is not set
-# CONFIG_NLS_CODEPAGE_866 is not set
-# CONFIG_NLS_CODEPAGE_869 is not set
-# CONFIG_NLS_CODEPAGE_874 is not set
-# CONFIG_NLS_CODEPAGE_932 is not set
-# CONFIG_NLS_CODEPAGE_936 is not set
-# CONFIG_NLS_CODEPAGE_949 is not set
-# CONFIG_NLS_CODEPAGE_950 is not set
-CONFIG_NLS_DEFAULT="iso8859-1"
-# CONFIG_NLS_ISO8859_1 is not set
-# CONFIG_NLS_ISO8859_13 is not set
-# CONFIG_NLS_ISO8859_14 is not set
-# CONFIG_NLS_ISO8859_15 is not set
-# CONFIG_NLS_ISO8859_2 is not set
-# CONFIG_NLS_ISO8859_3 is not set
-# CONFIG_NLS_ISO8859_4 is not set
-# CONFIG_NLS_ISO8859_5 is not set
-# CONFIG_NLS_ISO8859_6 is not set
-# CONFIG_NLS_ISO8859_7 is not set
-# CONFIG_NLS_ISO8859_8 is not set
-# CONFIG_NLS_ISO8859_9 is not set
-# CONFIG_NLS_KOI8_R is not set
-# CONFIG_NLS_KOI8_U is not set
-# CONFIG_NLS_MAC_CELTIC is not set
-# CONFIG_NLS_MAC_CENTEURO is not set
-# CONFIG_NLS_MAC_CROATIAN is not set
-# CONFIG_NLS_MAC_CYRILLIC is not set
-# CONFIG_NLS_MAC_GAELIC is not set
-# CONFIG_NLS_MAC_GREEK is not set
-# CONFIG_NLS_MAC_ICELAND is not set
-# CONFIG_NLS_MAC_INUIT is not set
-# CONFIG_NLS_MAC_ROMAN is not set
-# CONFIG_NLS_MAC_ROMANIAN is not set
-# CONFIG_NLS_MAC_TURKISH is not set
-# CONFIG_NLS_UTF8 is not set
-# CONFIG_NOP_USB_XCEIV is not set
-# CONFIG_NORTEL_HERMES is not set
-# CONFIG_NOTIFIER_ERROR_INJECTION is not set
-# CONFIG_NOZOMI is not set
-# CONFIG_NO_BOOTMEM is not set
-# CONFIG_NO_HZ is not set
-# CONFIG_NO_HZ_FULL is not set
-# CONFIG_NO_HZ_IDLE is not set
-# CONFIG_NO_IOPORT is not set
-# CONFIG_NS83820 is not set
-# CONFIG_NTFS_DEBUG is not set
-# CONFIG_NTFS_FS is not set
-# CONFIG_NTFS_RW is not set
-# CONFIG_NTP_PPS is not set
-# CONFIG_NVRAM is not set
-# CONFIG_NV_TCO is not set
-# CONFIG_NXP_STB220 is not set
-# CONFIG_NXP_STB225 is not set
-# CONFIG_N_GSM is not set
-# CONFIG_OABI_COMPAT is not set
-# CONFIG_OBS600 is not set
-# CONFIG_OCFS2_FS is not set
-# CONFIG_OC_ETM is not set
-# CONFIG_OF_SELFTEST is not set
-# CONFIG_OMAP2_DSS_DEBUG is not set
-# CONFIG_OMAP2_DSS_DEBUGFS is not set
-# CONFIG_OMAP2_DSS_SDI is not set
-# CONFIG_OMAP_CONTROL_USB is not set
-# CONFIG_OMAP_OCP2SCP is not set
-# CONFIG_OMAP_USB2 is not set
-# CONFIG_OMAP_USB3 is not set
-# CONFIG_OMFS_FS is not set
-# CONFIG_OPENVSWITCH is not set
-# CONFIG_OPROFILE is not set
-# CONFIG_OPROFILE_EVENT_MULTIPLEX is not set
-# CONFIG_ORION_WATCHDOG is not set
-# CONFIG_OSF_PARTITION is not set
-CONFIG_OVERLAY_FS=y
-# CONFIG_P54_COMMON is not set
-CONFIG_PACKET=y
-# CONFIG_PACKET_DIAG is not set
-# CONFIG_PAGE_POISONING is not set
-# CONFIG_PAGE_SIZE_16KB is not set
-# CONFIG_PAGE_SIZE_32KB is not set
-CONFIG_PAGE_SIZE_4KB=y
-# CONFIG_PAGE_SIZE_64KB is not set
-# CONFIG_PAGE_SIZE_8KB is not set
-# CONFIG_PANEL is not set
-CONFIG_PANIC_ON_OOPS=y
-CONFIG_PANIC_ON_OOPS_VALUE=1
-CONFIG_PANIC_TIMEOUT=1
-# CONFIG_PANTHERLORD_FF is not set
-# CONFIG_PARPORT is not set
-# CONFIG_PARPORT_1284 is not set
-# CONFIG_PARPORT_AX88796 is not set
-# CONFIG_PARPORT_PC is not set
-CONFIG_PARTITION_ADVANCED=y
-# CONFIG_PATA_ALI is not set
-# CONFIG_PATA_AMD is not set
-# CONFIG_PATA_ARASAN_CF is not set
-# CONFIG_PATA_ARTOP is not set
-# CONFIG_PATA_ATIIXP is not set
-# CONFIG_PATA_ATP867X is not set
-# CONFIG_PATA_CMD640_PCI is not set
-# CONFIG_PATA_CMD64X is not set
-# CONFIG_PATA_CS5520 is not set
-# CONFIG_PATA_CS5530 is not set
-# CONFIG_PATA_CS5535 is not set
-# CONFIG_PATA_CS5536 is not set
-# CONFIG_PATA_CYPRESS is not set
-# CONFIG_PATA_EFAR is not set
-# CONFIG_PATA_HPT366 is not set
-# CONFIG_PATA_HPT37X is not set
-# CONFIG_PATA_HPT3X2N is not set
-# CONFIG_PATA_HPT3X3 is not set
-# CONFIG_PATA_ISAPNP is not set
-# CONFIG_PATA_IT8213 is not set
-# CONFIG_PATA_IT821X is not set
-# CONFIG_PATA_JMICRON is not set
-# CONFIG_PATA_LEGACY is not set
-# CONFIG_PATA_MARVELL is not set
-# CONFIG_PATA_MPIIX is not set
-# CONFIG_PATA_NETCELL is not set
-# CONFIG_PATA_NINJA32 is not set
-# CONFIG_PATA_NS87410 is not set
-# CONFIG_PATA_NS87415 is not set
-# CONFIG_PATA_OCTEON_CF is not set
-# CONFIG_PATA_OF_PLATFORM is not set
-# CONFIG_PATA_OLDPIIX is not set
-# CONFIG_PATA_OPTI is not set
-# CONFIG_PATA_OPTIDMA is not set
-# CONFIG_PATA_PCMCIA is not set
-# CONFIG_PATA_PDC2027X is not set
-# CONFIG_PATA_PDC_OLD is not set
-# CONFIG_PATA_PLATFORM is not set
-# CONFIG_PATA_QDI is not set
-# CONFIG_PATA_RADISYS is not set
-# CONFIG_PATA_RDC is not set
-# CONFIG_PATA_RZ1000 is not set
-# CONFIG_PATA_SC1200 is not set
-# CONFIG_PATA_SCH is not set
-# CONFIG_PATA_SERVERWORKS is not set
-# CONFIG_PATA_SIL680 is not set
-# CONFIG_PATA_SIS is not set
-# CONFIG_PATA_TOSHIBA is not set
-# CONFIG_PATA_TRIFLEX is not set
-# CONFIG_PATA_VIA is not set
-# CONFIG_PATA_WINBOND is not set
-# CONFIG_PATA_WINBOND_VLB is not set
-# CONFIG_PC300TOO is not set
-# CONFIG_PCCARD is not set
-# CONFIG_PCH_GBE is not set
-# CONFIG_PCH_PHUB is not set
-# CONFIG_PCI200SYN is not set
-# CONFIG_PCIEAER_INJECT is not set
-# CONFIG_PCIEASPM is not set
-# CONFIG_PCIEPORTBUS is not set
-# CONFIG_PCIE_ECRC is not set
-# CONFIG_PCIPCWATCHDOG is not set
-# CONFIG_PCI_ATMEL is not set
-# CONFIG_PCI_CNB20LE_QUIRK is not set
-# CONFIG_PCI_DEBUG is not set
-# CONFIG_PCI_DISABLE_COMMON_QUIRKS is not set
-# CONFIG_PCI_HERMES is not set
-# CONFIG_PCI_HOST_GENERIC is not set
-# CONFIG_PCI_IOV is not set
-# CONFIG_PCI_MSI is not set
-# CONFIG_PCI_PASID is not set
-# CONFIG_PCI_PRI is not set
-CONFIG_PCI_QUIRKS=y
-# CONFIG_PCI_REALLOC_ENABLE_AUTO is not set
-# CONFIG_PCI_STUB is not set
-CONFIG_PCI_SYSCALL=y
-# CONFIG_PCMCIA is not set
-# CONFIG_PCMCIA_3C574 is not set
-# CONFIG_PCMCIA_3C589 is not set
-# CONFIG_PCMCIA_AHA152X is not set
-# CONFIG_PCMCIA_ATMEL is not set
-# CONFIG_PCMCIA_AXNET is not set
-# CONFIG_PCMCIA_DEBUG is not set
-# CONFIG_PCMCIA_FDOMAIN is not set
-# CONFIG_PCMCIA_FMVJ18X is not set
-# CONFIG_PCMCIA_HERMES is not set
-# CONFIG_PCMCIA_LOAD_CIS is not set
-# CONFIG_PCMCIA_NINJA_SCSI is not set
-# CONFIG_PCMCIA_NMCLAN is not set
-# CONFIG_PCMCIA_PCNET is not set
-# CONFIG_PCMCIA_QLOGIC is not set
-# CONFIG_PCMCIA_RAYCS is not set
-# CONFIG_PCMCIA_SMC91C92 is not set
-# CONFIG_PCMCIA_SPECTRUM is not set
-# CONFIG_PCMCIA_SYM53C500 is not set
-# CONFIG_PCMCIA_WL3501 is not set
-# CONFIG_PCMCIA_XIRC2PS is not set
-# CONFIG_PCMCIA_XIRCOM is not set
-# CONFIG_PCNET32 is not set
-# CONFIG_PCSPKR_PLATFORM is not set
-# CONFIG_PD6729 is not set
-# CONFIG_PDA_POWER is not set
-# CONFIG_PDC_ADMA is not set
-# CONFIG_PERCPU_TEST is not set
-# CONFIG_PERF_COUNTERS is not set
-# CONFIG_PERF_EVENTS is not set
-# CONFIG_PERSISTENT_KEYRINGS is not set
-# CONFIG_PHANTOM is not set
-# CONFIG_PHONE is not set
-# CONFIG_PHONET is not set
-# CONFIG_PHYLIB is not set
-# CONFIG_PHYS_ADDR_T_64BIT is not set
-# CONFIG_PHY_EXYNOS_DP_VIDEO is not set
-# CONFIG_PHY_EXYNOS_MIPI_VIDEO is not set
-# CONFIG_PHY_QCOM_DWC3 is not set
-# CONFIG_PHY_SAMSUNG_USB2 is not set
-# CONFIG_PID_IN_CONTEXTIDR is not set
-# CONFIG_PID_NS is not set
-CONFIG_PINCONF=y
-# CONFIG_PINCTRL is not set
-# CONFIG_PINCTRL_CAPRI is not set
-# CONFIG_PINCTRL_EXYNOS is not set
-# CONFIG_PINCTRL_EXYNOS5440 is not set
-# CONFIG_PINCTRL_MSM8X74 is not set
-CONFIG_PINCTRL_SINGLE=y
-CONFIG_PINMUX=y
-# CONFIG_PLAT_SPEAR is not set
-# CONFIG_PLIP is not set
-# CONFIG_PLX_HERMES is not set
-# CONFIG_PM is not set
-# CONFIG_PMBUS is not set
-# CONFIG_PMC_MSP is not set
-# CONFIG_PMC_YOSEMITE is not set
-# CONFIG_PMIC_ADP5520 is not set
-# CONFIG_PMIC_DA903X is not set
-# CONFIG_PM_AUTOSLEEP is not set
-# CONFIG_PM_DEVFREQ is not set
-# CONFIG_PM_RUNTIME is not set
-# CONFIG_PM_WAKELOCKS is not set
-# CONFIG_PNX8550_JBS is not set
-# CONFIG_PNX8550_STB810 is not set
-# CONFIG_POHMELFS is not set
-# CONFIG_POSIX_MQUEUE is not set
-# CONFIG_POWERCAP is not set
-# CONFIG_POWERTV is not set
-# CONFIG_POWER_AVS is not set
-# CONFIG_POWER_RESET is not set
-# CONFIG_POWER_RESET_RESTART is not set
-# CONFIG_POWER_RESET_VERSATILE is not set
-# CONFIG_POWER_SUPPLY is not set
-# CONFIG_POWER_SUPPLY_DEBUG is not set
-# CONFIG_PPC4xx_GPIO is not set
-# CONFIG_PPC_16K_PAGES is not set
-# CONFIG_PPC_256K_PAGES is not set
-CONFIG_PPC_4K_PAGES=y
-# CONFIG_PPC_64K_PAGES is not set
-# CONFIG_PPC_DISABLE_WERROR is not set
-# CONFIG_PPC_EMULATED_STATS is not set
-# CONFIG_PPC_EPAPR_HV_BYTECHAN is not set
-# CONFIG_PPP is not set
-# CONFIG_PPPOATM is not set
-# CONFIG_PPPOE is not set
-# CONFIG_PPPOL2TP is not set
-# CONFIG_PPP_ASYNC is not set
-# CONFIG_PPP_BSDCOMP is not set
-# CONFIG_PPP_DEFLATE is not set
-CONFIG_PPP_FILTER=y
-# CONFIG_PPP_MPPE is not set
-CONFIG_PPP_MULTILINK=y
-# CONFIG_PPP_SYNC_TTY is not set
-# CONFIG_PPS is not set
-# CONFIG_PPS_CLIENT_GPIO is not set
-# CONFIG_PPS_CLIENT_KTIMER is not set
-# CONFIG_PPS_CLIENT_LDISC is not set
-# CONFIG_PPS_CLIENT_PARPORT is not set
-# CONFIG_PPS_DEBUG is not set
-# CONFIG_PPTP is not set
-# CONFIG_PREEMPT is not set
-CONFIG_PREEMPT_NONE=y
-# CONFIG_PREEMPT_TRACER is not set
-# CONFIG_PREEMPT_VOLUNTARY is not set
-CONFIG_PREVENT_FIRMWARE_BUILD=y
-CONFIG_PRINTK=y
-# CONFIG_PRINTK_TIME is not set
-CONFIG_PRINT_STACK_DEPTH=64
-# CONFIG_PRISM2_USB is not set
-# CONFIG_PRISM54 is not set
-# CONFIG_PROBE_INITRD_HEADER is not set
-CONFIG_PROC_FS=y
-# CONFIG_PROC_KCORE is not set
-# CONFIG_PROC_PAGE_MONITOR is not set
-CONFIG_PROC_STRIPPED=y
-CONFIG_PROC_SYSCTL=y
-# CONFIG_PROFILE_ALL_BRANCHES is not set
-# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
-# CONFIG_PROFILING is not set
-# CONFIG_PROVE_LOCKING is not set
-# CONFIG_PROVE_RCU is not set
-# CONFIG_PROVE_RCU_DELAY is not set
-# CONFIG_PSB6970_PHY is not set
-# CONFIG_PSTORE is not set
-# CONFIG_PTP_1588_CLOCK is not set
-# CONFIG_PTP_1588_CLOCK_IXP46X is not set
-# CONFIG_PTP_1588_CLOCK_PCH is not set
-# CONFIG_PWM is not set
-# CONFIG_PWM_PCA9685 is not set
-# CONFIG_QCA7000 is not set
-# CONFIG_QLA3XXX is not set
-# CONFIG_QLCNIC is not set
-# CONFIG_QLGE is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_QNX6FS_FS is not set
-# CONFIG_QSEMI_PHY is not set
-# CONFIG_QUOTA is not set
-# CONFIG_QUOTACTL is not set
-# CONFIG_QUOTA_DEBUG is not set
-# CONFIG_R3964 is not set
-# CONFIG_R6040 is not set
-# CONFIG_R8169 is not set
-# CONFIG_R8187SE is not set
-# CONFIG_R8188EU is not set
-# CONFIG_R8712U is not set
-# CONFIG_R8723AU is not set
-# CONFIG_RADIO_ADAPTERS is not set
-# CONFIG_RADIO_AZTECH is not set
-# CONFIG_RADIO_CADET is not set
-# CONFIG_RADIO_GEMTEK is not set
-# CONFIG_RADIO_MAXIRADIO is not set
-# CONFIG_RADIO_RTRACK is not set
-# CONFIG_RADIO_RTRACK2 is not set
-# CONFIG_RADIO_SF16FMI is not set
-# CONFIG_RADIO_SF16FMR2 is not set
-# CONFIG_RADIO_TERRATEC is not set
-# CONFIG_RADIO_TRUST is not set
-# CONFIG_RADIO_TYPHOON is not set
-# CONFIG_RADIO_ZOLTRIX is not set
-# CONFIG_RAID_ATTRS is not set
-# CONFIG_RALINK is not set
-# CONFIG_RAMOOPS is not set
-# CONFIG_RANDOM32_SELFTEST is not set
-# CONFIG_RAPIDIO is not set
-# CONFIG_RAR_REGISTER is not set
-# CONFIG_RAW_DRIVER is not set
-# CONFIG_RBTREE_TEST is not set
-# CONFIG_RCU_CPU_STALL_INFO is not set
-CONFIG_RCU_CPU_STALL_TIMEOUT=60
-CONFIG_RCU_FANOUT=32
-# CONFIG_RCU_FANOUT_EXACT is not set
-CONFIG_RCU_FANOUT_LEAF=16
-# CONFIG_RCU_FAST_NO_HZ is not set
-# CONFIG_RCU_NOCB_CPU is not set
-# CONFIG_RCU_TORTURE_TEST is not set
-# CONFIG_RCU_TRACE is not set
-# CONFIG_RCU_USER_QS is not set
-# CONFIG_RC_ATI_REMOTE is not set
-# CONFIG_RC_CORE is not set
-# CONFIG_RC_DECODERS is not set
-# CONFIG_RC_LOOPBACK is not set
-# CONFIG_RC_MAP is not set
-# CONFIG_RDS is not set
-# CONFIG_RD_BZIP2 is not set
-# CONFIG_RD_GZIP is not set
-# CONFIG_RD_LZ4 is not set
-# CONFIG_RD_LZMA is not set
-# CONFIG_RD_LZO is not set
-# CONFIG_RD_XZ is not set
-# CONFIG_READABLE_ASM is not set
-# CONFIG_REALTEK_PHY is not set
-# CONFIG_REDWOOD is not set
-# CONFIG_REGMAP is not set
-# CONFIG_REGMAP_I2C is not set
-# CONFIG_REGMAP_MMIO is not set
-# CONFIG_REGMAP_SPI is not set
-# CONFIG_REGULATOR is not set
-# CONFIG_REGULATOR_ACT8865 is not set
-# CONFIG_REGULATOR_AD5398 is not set
-# CONFIG_REGULATOR_ANATOP is not set
-# CONFIG_REGULATOR_BQ24022 is not set
-# CONFIG_REGULATOR_DA9210 is not set
-# CONFIG_REGULATOR_DA9211 is not set
-# CONFIG_REGULATOR_FAN53555 is not set
-# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
-# CONFIG_REGULATOR_GPIO is not set
-# CONFIG_REGULATOR_ISL6271A is not set
-# CONFIG_REGULATOR_ISL9305 is not set
-# CONFIG_REGULATOR_LP3971 is not set
-# CONFIG_REGULATOR_LP3972 is not set
-# CONFIG_REGULATOR_LP872X is not set
-# CONFIG_REGULATOR_LP8755 is not set
-# CONFIG_REGULATOR_LTC3589 is not set
-# CONFIG_REGULATOR_MAX1586 is not set
-# CONFIG_REGULATOR_MAX8649 is not set
-# CONFIG_REGULATOR_MAX8660 is not set
-# CONFIG_REGULATOR_MAX8952 is not set
-# CONFIG_REGULATOR_MAX8973 is not set
-# CONFIG_REGULATOR_PFUZE100 is not set
-# CONFIG_REGULATOR_TI_ABB is not set
-# CONFIG_REGULATOR_TPS51632 is not set
-# CONFIG_REGULATOR_TPS62360 is not set
-# CONFIG_REGULATOR_TPS65023 is not set
-# CONFIG_REGULATOR_TPS6507X is not set
-# CONFIG_REGULATOR_TPS6524X is not set
-# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
-# CONFIG_REISERFS_CHECK is not set
-# CONFIG_REISERFS_FS is not set
-# CONFIG_REISERFS_FS_POSIX_ACL is not set
-# CONFIG_REISERFS_FS_SECURITY is not set
-# CONFIG_REISERFS_FS_XATTR is not set
-# CONFIG_REISERFS_PROC_INFO is not set
-# CONFIG_RELAY is not set
-# CONFIG_RESET_CONTROLLER is not set
-# CONFIG_RFD_FTL is not set
-# CONFIG_RFKILL is not set
-# CONFIG_RFKILL_INPUT is not set
-# CONFIG_RFKILL_REGULATOR is not set
-# CONFIG_RING_BUFFER_BENCHMARK is not set
-# CONFIG_RING_BUFFER_STARTUP_TEST is not set
-# CONFIG_ROMFS_FS is not set
-# CONFIG_ROSE is not set
-# CONFIG_RPCSEC_GSS_KRB5 is not set
-# CONFIG_RT2X00 is not set
-# CONFIG_RTC_CLASS is not set
-# CONFIG_RTC_DEBUG is not set
-# CONFIG_RTC_DRV_AU1XXX is not set
-# CONFIG_RTC_DRV_BQ32K is not set
-# CONFIG_RTC_DRV_BQ4802 is not set
-CONFIG_RTC_DRV_CMOS=y
-# CONFIG_RTC_DRV_DS1286 is not set
-# CONFIG_RTC_DRV_DS1305 is not set
-# CONFIG_RTC_DRV_DS1307 is not set
-# CONFIG_RTC_DRV_DS1343 is not set
-# CONFIG_RTC_DRV_DS1347 is not set
-# CONFIG_RTC_DRV_DS1374 is not set
-# CONFIG_RTC_DRV_DS1390 is not set
-# CONFIG_RTC_DRV_DS1511 is not set
-# CONFIG_RTC_DRV_DS1553 is not set
-# CONFIG_RTC_DRV_DS1672 is not set
-# CONFIG_RTC_DRV_DS1742 is not set
-# CONFIG_RTC_DRV_DS2404 is not set
-# CONFIG_RTC_DRV_DS3232 is not set
-# CONFIG_RTC_DRV_DS3234 is not set
-# CONFIG_RTC_DRV_EM3027 is not set
-# CONFIG_RTC_DRV_EP93XX is not set
-# CONFIG_RTC_DRV_FM3130 is not set
-# CONFIG_RTC_DRV_GENERIC is not set
-# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
-# CONFIG_RTC_DRV_HYM8563 is not set
-# CONFIG_RTC_DRV_ISL12022 is not set
-# CONFIG_RTC_DRV_ISL12057 is not set
-# CONFIG_RTC_DRV_ISL1208 is not set
-# CONFIG_RTC_DRV_M41T80 is not set
-# CONFIG_RTC_DRV_M41T93 is not set
-# CONFIG_RTC_DRV_M41T94 is not set
-# CONFIG_RTC_DRV_M48T35 is not set
-# CONFIG_RTC_DRV_M48T59 is not set
-# CONFIG_RTC_DRV_M48T86 is not set
-# CONFIG_RTC_DRV_MAX6900 is not set
-# CONFIG_RTC_DRV_MAX6902 is not set
-# CONFIG_RTC_DRV_MCP795 is not set
-# CONFIG_RTC_DRV_MOXART is not set
-# CONFIG_RTC_DRV_MPC5121 is not set
-# CONFIG_RTC_DRV_MSM6242 is not set
-# CONFIG_RTC_DRV_OMAP is not set
-# CONFIG_RTC_DRV_PCF2123 is not set
-# CONFIG_RTC_DRV_PCF2127 is not set
-# CONFIG_RTC_DRV_PCF85063 is not set
-# CONFIG_RTC_DRV_PCF8523 is not set
-# CONFIG_RTC_DRV_PCF8563 is not set
-# CONFIG_RTC_DRV_PCF8583 is not set
-# CONFIG_RTC_DRV_PL030 is not set
-# CONFIG_RTC_DRV_PL031 is not set
-# CONFIG_RTC_DRV_PS3 is not set
-# CONFIG_RTC_DRV_PT7C4338 is not set
-# CONFIG_RTC_DRV_R9701 is not set
-# CONFIG_RTC_DRV_RP5C01 is not set
-# CONFIG_RTC_DRV_RS5C348 is not set
-# CONFIG_RTC_DRV_RS5C372 is not set
-# CONFIG_RTC_DRV_RTC7301 is not set
-# CONFIG_RTC_DRV_RV3029C2 is not set
-# CONFIG_RTC_DRV_RX4581 is not set
-# CONFIG_RTC_DRV_RX8025 is not set
-# CONFIG_RTC_DRV_RX8581 is not set
-# CONFIG_RTC_DRV_S35390A is not set
-# CONFIG_RTC_DRV_SNVS is not set
-# CONFIG_RTC_DRV_STK17TA8 is not set
-# CONFIG_RTC_DRV_SUN6I is not set
-# CONFIG_RTC_DRV_TEST is not set
-# CONFIG_RTC_DRV_V3020 is not set
-# CONFIG_RTC_DRV_X1205 is not set
-# CONFIG_RTC_DRV_XGENE is not set
-CONFIG_RTC_HCTOSYS=y
-CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
-CONFIG_RTC_INTF_DEV=y
-# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
-CONFIG_RTC_INTF_PROC=y
-CONFIG_RTC_INTF_SYSFS=y
-CONFIG_RTC_LIB=y
-CONFIG_RTC_SYSTOHC=y
-# CONFIG_RTL8180 is not set
-# CONFIG_RTL8187 is not set
-# CONFIG_RTL8192E is not set
-# CONFIG_RTL8192U is not set
-# CONFIG_RTL8306_PHY is not set
-# CONFIG_RTL8366RB_PHY is not set
-# CONFIG_RTL8366S_PHY is not set
-# CONFIG_RTL8366_SMI is not set
-# CONFIG_RTL8366_SMI_DEBUG_FS is not set
-# CONFIG_RTL8367B_PHY is not set
-# CONFIG_RTL8367_PHY is not set
-# CONFIG_RTLLIB is not set
-# CONFIG_RTL_CARDS is not set
-# CONFIG_RTS5139 is not set
-# CONFIG_RTS5208 is not set
-# CONFIG_RTS_PSTOR is not set
-CONFIG_RT_MUTEXES=y
-# CONFIG_RT_MUTEX_TESTER is not set
-# CONFIG_RUNTIME_DEBUG is not set
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-# CONFIG_S2IO is not set
-# CONFIG_SAMPLES is not set
-# CONFIG_SAMSUNG_LAPTOP is not set
-# CONFIG_SAMSUNG_USB2PHY is not set
-# CONFIG_SAMSUNG_USB3PHY is not set
-# CONFIG_SATA_ACARD_AHCI is not set
-# CONFIG_SATA_AHCI is not set
-# CONFIG_SATA_AHCI_PLATFORM is not set
-# CONFIG_SATA_DWC is not set
-# CONFIG_SATA_FSL is not set
-# CONFIG_SATA_HIGHBANK is not set
-# CONFIG_SATA_INIC162X is not set
-# CONFIG_SATA_MV is not set
-# CONFIG_SATA_NV is not set
-# CONFIG_SATA_PMP is not set
-# CONFIG_SATA_PROMISE is not set
-# CONFIG_SATA_QSTOR is not set
-# CONFIG_SATA_RCAR is not set
-# CONFIG_SATA_SIL is not set
-# CONFIG_SATA_SIL24 is not set
-# CONFIG_SATA_SIS is not set
-# CONFIG_SATA_SVW is not set
-# CONFIG_SATA_SX4 is not set
-# CONFIG_SATA_ULI is not set
-# CONFIG_SATA_VIA is not set
-# CONFIG_SATA_VITESSE is not set
-# CONFIG_SBC_FITPC2_WATCHDOG is not set
-# CONFIG_SBE_2T3E3 is not set
-# CONFIG_SBYPASS is not set
-# CONFIG_SC92031 is not set
-# CONFIG_SCA3000 is not set
-# CONFIG_SCC is not set
-# CONFIG_SCHEDSTATS is not set
-# CONFIG_SCHED_AUTOGROUP is not set
-# CONFIG_SCHED_DEBUG is not set
-# CONFIG_SCHED_MC is not set
-CONFIG_SCHED_OMIT_FRAME_POINTER=y
-# CONFIG_SCHED_SMT is not set
-# CONFIG_SCHED_STACK_END_CHECK is not set
-# CONFIG_SCHED_TRACER is not set
-# CONFIG_SCSI is not set
-# CONFIG_SCSI_3W_9XXX is not set
-# CONFIG_SCSI_3W_SAS is not set
-# CONFIG_SCSI_7000FASST is not set
-# CONFIG_SCSI_AACRAID is not set
-# CONFIG_SCSI_ACARD is not set
-# CONFIG_SCSI_ADVANSYS is not set
-# CONFIG_SCSI_AHA152X is not set
-# CONFIG_SCSI_AHA1542 is not set
-# CONFIG_SCSI_AIC79XX is not set
-# CONFIG_SCSI_AIC7XXX is not set
-# CONFIG_SCSI_AIC7XXX_OLD is not set
-# CONFIG_SCSI_AIC94XX is not set
-# CONFIG_SCSI_ARCMSR is not set
-# CONFIG_SCSI_BFA_FC is not set
-# CONFIG_SCSI_BNX2X_FCOE is not set
-# CONFIG_SCSI_BNX2_ISCSI is not set
-# CONFIG_SCSI_BUSLOGIC is not set
-# CONFIG_SCSI_CHELSIO_FCOE is not set
-# CONFIG_SCSI_CONSTANTS is not set
-# CONFIG_SCSI_CXGB3_ISCSI is not set
-# CONFIG_SCSI_CXGB4_ISCSI is not set
-# CONFIG_SCSI_DC390T is not set
-# CONFIG_SCSI_DC395x is not set
-# CONFIG_SCSI_DEBUG is not set
-# CONFIG_SCSI_DH is not set
-CONFIG_SCSI_DMA=y
-# CONFIG_SCSI_DMX3191D is not set
-# CONFIG_SCSI_DPT_I2O is not set
-# CONFIG_SCSI_DTC3280 is not set
-# CONFIG_SCSI_EATA is not set
-# CONFIG_SCSI_ESAS2R is not set
-# CONFIG_SCSI_FC_ATTRS is not set
-# CONFIG_SCSI_FUTURE_DOMAIN is not set
-# CONFIG_SCSI_GDTH is not set
-# CONFIG_SCSI_GENERIC_NCR5380 is not set
-# CONFIG_SCSI_GENERIC_NCR5380_MMIO is not set
-# CONFIG_SCSI_HPSA is not set
-# CONFIG_SCSI_HPTIOP is not set
-# CONFIG_SCSI_IN2000 is not set
-# CONFIG_SCSI_INIA100 is not set
-# CONFIG_SCSI_INITIO is not set
-# CONFIG_SCSI_IPR is not set
-# CONFIG_SCSI_IPS is not set
-# CONFIG_SCSI_ISCI is not set
-# CONFIG_SCSI_ISCSI_ATTRS is not set
-# CONFIG_SCSI_LOGGING is not set
-CONFIG_SCSI_LOWLEVEL=y
-# CONFIG_SCSI_LOWLEVEL_PCMCIA is not set
-# CONFIG_SCSI_LPFC is not set
-CONFIG_SCSI_MOD=y
-# CONFIG_SCSI_MPT2SAS is not set
-# CONFIG_SCSI_MPT3SAS is not set
-# CONFIG_SCSI_MQ_DEFAULT is not set
-CONFIG_SCSI_MULTI_LUN=y
-# CONFIG_SCSI_MVSAS is not set
-# CONFIG_SCSI_MVSAS_DEBUG is not set
-# CONFIG_SCSI_MVUMI is not set
-# CONFIG_SCSI_NCR53C406A is not set
-# CONFIG_SCSI_NETLINK is not set
-# CONFIG_SCSI_NSP32 is not set
-# CONFIG_SCSI_OSD_INITIATOR is not set
-# CONFIG_SCSI_PAS16 is not set
-# CONFIG_SCSI_PM8001 is not set
-# CONFIG_SCSI_PMCRAID is not set
-CONFIG_SCSI_PROC_FS=y
-# CONFIG_SCSI_QLA_FC is not set
-# CONFIG_SCSI_QLA_ISCSI is not set
-# CONFIG_SCSI_QLOGIC_1280 is not set
-# CONFIG_SCSI_QLOGIC_FAS is not set
-# CONFIG_SCSI_SAS_ATTRS is not set
-# CONFIG_SCSI_SAS_LIBSAS is not set
-# CONFIG_SCSI_SCAN_ASYNC is not set
-# CONFIG_SCSI_SPI_ATTRS is not set
-# CONFIG_SCSI_SRP is not set
-# CONFIG_SCSI_SRP_ATTRS is not set
-# CONFIG_SCSI_STEX is not set
-# CONFIG_SCSI_SYM53C416 is not set
-# CONFIG_SCSI_SYM53C8XX_2 is not set
-# CONFIG_SCSI_T128 is not set
-# CONFIG_SCSI_TGT is not set
-# CONFIG_SCSI_U14_34F is not set
-# CONFIG_SCSI_UFSHCD is not set
-# CONFIG_SCSI_ULTRASTOR is not set
-# CONFIG_SCSI_VIRTIO is not set
-# CONFIG_SCx200_ACB is not set
-# CONFIG_SDIO_UART is not set
-# CONFIG_SECCOMP is not set
-# CONFIG_SECURITY is not set
-# CONFIG_SECURITYFS is not set
-CONFIG_SECURITY_DMESG_RESTRICT=y
-# CONFIG_SEEQ8005 is not set
-CONFIG_SELECT_MEMORY_MODEL=y
-# CONFIG_SENSORS_ABITUGURU is not set
-# CONFIG_SENSORS_ABITUGURU3 is not set
-# CONFIG_SENSORS_ACPI_POWER is not set
-# CONFIG_SENSORS_AD7314 is not set
-# CONFIG_SENSORS_AD7414 is not set
-# CONFIG_SENSORS_AD7418 is not set
-# CONFIG_SENSORS_ADC128D818 is not set
-# CONFIG_SENSORS_ADCXX is not set
-# CONFIG_SENSORS_ADM1021 is not set
-# CONFIG_SENSORS_ADM1025 is not set
-# CONFIG_SENSORS_ADM1026 is not set
-# CONFIG_SENSORS_ADM1029 is not set
-# CONFIG_SENSORS_ADM1031 is not set
-# CONFIG_SENSORS_ADM9240 is not set
-# CONFIG_SENSORS_ADS1015 is not set
-# CONFIG_SENSORS_ADS7828 is not set
-# CONFIG_SENSORS_ADS7871 is not set
-# CONFIG_SENSORS_ADT7310 is not set
-# CONFIG_SENSORS_ADT7410 is not set
-# CONFIG_SENSORS_ADT7411 is not set
-# CONFIG_SENSORS_ADT7462 is not set
-# CONFIG_SENSORS_ADT7470 is not set
-# CONFIG_SENSORS_ADT7475 is not set
-# CONFIG_SENSORS_AMC6821 is not set
-# CONFIG_SENSORS_APDS990X is not set
-# CONFIG_SENSORS_APPLESMC is not set
-# CONFIG_SENSORS_ASB100 is not set
-# CONFIG_SENSORS_ASC7621 is not set
-# CONFIG_SENSORS_ATK0110 is not set
-# CONFIG_SENSORS_ATXP1 is not set
-# CONFIG_SENSORS_BH1770 is not set
-# CONFIG_SENSORS_BH1780 is not set
-# CONFIG_SENSORS_CORETEMP is not set
-# CONFIG_SENSORS_DME1737 is not set
-# CONFIG_SENSORS_DS1621 is not set
-# CONFIG_SENSORS_DS620 is not set
-# CONFIG_SENSORS_EMC1403 is not set
-# CONFIG_SENSORS_EMC2103 is not set
-# CONFIG_SENSORS_EMC6W201 is not set
-# CONFIG_SENSORS_F71805F is not set
-# CONFIG_SENSORS_F71882FG is not set
-# CONFIG_SENSORS_F75375S is not set
-# CONFIG_SENSORS_FAM15H_POWER is not set
-# CONFIG_SENSORS_FSCHMD is not set
-# CONFIG_SENSORS_G760A is not set
-# CONFIG_SENSORS_G762 is not set
-# CONFIG_SENSORS_GL518SM is not set
-# CONFIG_SENSORS_GL520SM is not set
-# CONFIG_SENSORS_GPIO_FAN is not set
-# CONFIG_SENSORS_GSC is not set
-# CONFIG_SENSORS_HDAPS is not set
-# CONFIG_SENSORS_HIH6130 is not set
-# CONFIG_SENSORS_HMC5843 is not set
-# CONFIG_SENSORS_HMC5843_I2C is not set
-# CONFIG_SENSORS_HMC5843_SPI is not set
-# CONFIG_SENSORS_HTU21 is not set
-# CONFIG_SENSORS_I5500 is not set
-# CONFIG_SENSORS_I5K_AMB is not set
-# CONFIG_SENSORS_IIO_HWMON is not set
-# CONFIG_SENSORS_INA209 is not set
-# CONFIG_SENSORS_INA2XX is not set
-# CONFIG_SENSORS_ISL29018 is not set
-# CONFIG_SENSORS_ISL29028 is not set
-# CONFIG_SENSORS_IT87 is not set
-# CONFIG_SENSORS_JC42 is not set
-# CONFIG_SENSORS_JZ4740 is not set
-# CONFIG_SENSORS_K10TEMP is not set
-# CONFIG_SENSORS_K8TEMP is not set
-# CONFIG_SENSORS_LINEAGE is not set
-# CONFIG_SENSORS_LIS3LV02D is not set
-# CONFIG_SENSORS_LIS3_I2C is not set
-# CONFIG_SENSORS_LIS3_SPI is not set
-# CONFIG_SENSORS_LM63 is not set
-# CONFIG_SENSORS_LM70 is not set
-# CONFIG_SENSORS_LM73 is not set
-# CONFIG_SENSORS_LM75 is not set
-# CONFIG_SENSORS_LM77 is not set
-# CONFIG_SENSORS_LM78 is not set
-# CONFIG_SENSORS_LM80 is not set
-# CONFIG_SENSORS_LM83 is not set
-# CONFIG_SENSORS_LM85 is not set
-# CONFIG_SENSORS_LM87 is not set
-# CONFIG_SENSORS_LM90 is not set
-# CONFIG_SENSORS_LM92 is not set
-# CONFIG_SENSORS_LM93 is not set
-# CONFIG_SENSORS_LM95234 is not set
-# CONFIG_SENSORS_LM95241 is not set
-# CONFIG_SENSORS_LM95245 is not set
-# CONFIG_SENSORS_LTC2945 is not set
-# CONFIG_SENSORS_LTC4151 is not set
-# CONFIG_SENSORS_LTC4215 is not set
-# CONFIG_SENSORS_LTC4222 is not set
-# CONFIG_SENSORS_LTC4245 is not set
-# CONFIG_SENSORS_LTC4260 is not set
-# CONFIG_SENSORS_LTC4261 is not set
-# CONFIG_SENSORS_MAX1111 is not set
-# CONFIG_SENSORS_MAX16065 is not set
-# CONFIG_SENSORS_MAX1619 is not set
-# CONFIG_SENSORS_MAX1668 is not set
-# CONFIG_SENSORS_MAX197 is not set
-# CONFIG_SENSORS_MAX6639 is not set
-# CONFIG_SENSORS_MAX6642 is not set
-# CONFIG_SENSORS_MAX6650 is not set
-# CONFIG_SENSORS_MAX6697 is not set
-# CONFIG_SENSORS_MCP3021 is not set
-# CONFIG_SENSORS_NCT6683 is not set
-# CONFIG_SENSORS_NCT6775 is not set
-# CONFIG_SENSORS_NTC_THERMISTOR is not set
-# CONFIG_SENSORS_PC87360 is not set
-# CONFIG_SENSORS_PC87427 is not set
-# CONFIG_SENSORS_PCF8591 is not set
-# CONFIG_SENSORS_POWR1220 is not set
-# CONFIG_SENSORS_SCH5627 is not set
-# CONFIG_SENSORS_SCH5636 is not set
-# CONFIG_SENSORS_SCH56XX_COMMON is not set
-# CONFIG_SENSORS_SHT15 is not set
-# CONFIG_SENSORS_SHT21 is not set
-# CONFIG_SENSORS_SHTC1 is not set
-# CONFIG_SENSORS_SIS5595 is not set
-# CONFIG_SENSORS_SMM665 is not set
-# CONFIG_SENSORS_SMSC47B397 is not set
-# CONFIG_SENSORS_SMSC47M1 is not set
-# CONFIG_SENSORS_SMSC47M192 is not set
-# CONFIG_SENSORS_THMC50 is not set
-# CONFIG_SENSORS_TMP102 is not set
-# CONFIG_SENSORS_TMP103 is not set
-# CONFIG_SENSORS_TMP401 is not set
-# CONFIG_SENSORS_TMP421 is not set
-# CONFIG_SENSORS_TSL2550 is not set
-# CONFIG_SENSORS_TSL2563 is not set
-# CONFIG_SENSORS_VEXPRESS is not set
-# CONFIG_SENSORS_VIA686A is not set
-# CONFIG_SENSORS_VIA_CPUTEMP is not set
-# CONFIG_SENSORS_VT1211 is not set
-# CONFIG_SENSORS_VT8231 is not set
-# CONFIG_SENSORS_W83627EHF is not set
-# CONFIG_SENSORS_W83627HF is not set
-# CONFIG_SENSORS_W83781D is not set
-# CONFIG_SENSORS_W83791D is not set
-# CONFIG_SENSORS_W83792D is not set
-# CONFIG_SENSORS_W83793 is not set
-# CONFIG_SENSORS_W83795 is not set
-# CONFIG_SENSORS_W83L785TS is not set
-# CONFIG_SENSORS_W83L786NG is not set
-CONFIG_SERIAL_8250=y
-# CONFIG_SERIAL_8250_ACCENT is not set
-# CONFIG_SERIAL_8250_BOCA is not set
-CONFIG_SERIAL_8250_CONSOLE=y
-# CONFIG_SERIAL_8250_CS is not set
-# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
-# CONFIG_SERIAL_8250_DETECT_IRQ is not set
-CONFIG_SERIAL_8250_DMA=y
-# CONFIG_SERIAL_8250_DW is not set
-# CONFIG_SERIAL_8250_EM is not set
-# CONFIG_SERIAL_8250_EXAR_ST16C554 is not set
-# CONFIG_SERIAL_8250_EXTENDED is not set
-# CONFIG_SERIAL_8250_FINTEK is not set
-# CONFIG_SERIAL_8250_FOURPORT is not set
-# CONFIG_SERIAL_8250_HUB6 is not set
-# CONFIG_SERIAL_8250_MANY_PORTS is not set
-CONFIG_SERIAL_8250_NR_UARTS=2
-# CONFIG_SERIAL_8250_PCI is not set
-# CONFIG_SERIAL_8250_RSA is not set
-CONFIG_SERIAL_8250_RUNTIME_UARTS=2
-# CONFIG_SERIAL_8250_SYSRQ is not set
-# CONFIG_SERIAL_ALTERA_JTAGUART is not set
-# CONFIG_SERIAL_ALTERA_UART is not set
-# CONFIG_SERIAL_ARC is not set
-CONFIG_SERIAL_CORE=y
-CONFIG_SERIAL_CORE_CONSOLE=y
-CONFIG_SERIAL_EARLYCON=y
-# CONFIG_SERIAL_EARLYCON_ARM_SEMIHOST is not set
-# CONFIG_SERIAL_FSL_LPUART is not set
-# CONFIG_SERIAL_GRLIB_GAISLER_APBUART is not set
-# CONFIG_SERIAL_IFX6X60 is not set
-# CONFIG_SERIAL_JSM is not set
-# CONFIG_SERIAL_MAX3100 is not set
-# CONFIG_SERIAL_MAX3107 is not set
-# CONFIG_SERIAL_MAX310X is not set
-# CONFIG_SERIAL_MFD_HSU is not set
-# CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_SERIAL_OF_PLATFORM is not set
-# CONFIG_SERIAL_OF_PLATFORM_NWPSERIAL is not set
-# CONFIG_SERIAL_PCH_UART is not set
-# CONFIG_SERIAL_RP2 is not set
-# CONFIG_SERIAL_SC16IS7XX is not set
-# CONFIG_SERIAL_SCCNXP is not set
-# CONFIG_SERIAL_SH_SCI is not set
-# CONFIG_SERIAL_ST_ASC is not set
-# CONFIG_SERIAL_TIMBERDALE is not set
-# CONFIG_SERIAL_UARTLITE is not set
-# CONFIG_SERIAL_XILINX_PS_UART is not set
-# CONFIG_SERIO is not set
-# CONFIG_SERIO_ALTERA_PS2 is not set
-# CONFIG_SERIO_AMBAKMI is not set
-# CONFIG_SERIO_ARC_PS2 is not set
-# CONFIG_SERIO_I8042 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-# CONFIG_SERIO_PARKBD is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_PS2MULT is not set
-# CONFIG_SERIO_RAW is not set
-# CONFIG_SERIO_SERPORT is not set
-# CONFIG_SFC is not set
-# CONFIG_SFI is not set
-# CONFIG_SGETMASK_SYSCALL is not set
-# CONFIG_SGI_IOC4 is not set
-# CONFIG_SGI_IP22 is not set
-# CONFIG_SGI_IP27 is not set
-# CONFIG_SGI_IP28 is not set
-# CONFIG_SGI_IP32 is not set
-# CONFIG_SGI_PARTITION is not set
-CONFIG_SHMEM=y
-# CONFIG_SH_ETH is not set
-# CONFIG_SH_TIMER_CMT is not set
-# CONFIG_SH_TIMER_MTU2 is not set
-# CONFIG_SH_TIMER_TMU is not set
-# CONFIG_SI7005 is not set
-# CONFIG_SIBYTE_BIGSUR is not set
-# CONFIG_SIBYTE_CARMEL is not set
-# CONFIG_SIBYTE_CRHINE is not set
-# CONFIG_SIBYTE_CRHONE is not set
-# CONFIG_SIBYTE_LITTLESUR is not set
-# CONFIG_SIBYTE_RHONE is not set
-# CONFIG_SIBYTE_SENTOSA is not set
-# CONFIG_SIBYTE_SWARM is not set
-# CONFIG_SIGMA is not set
-CONFIG_SIGNALFD=y
-# CONFIG_SIMPLE_GPIO is not set
-# CONFIG_SIS190 is not set
-# CONFIG_SIS900 is not set
-# CONFIG_SKGE is not set
-# CONFIG_SKY2 is not set
-# CONFIG_SKY2_DEBUG is not set
-CONFIG_SLAB=y
-CONFIG_SLABINFO=y
-# CONFIG_SLHC is not set
-# CONFIG_SLICOSS is not set
-# CONFIG_SLIP is not set
-# CONFIG_SLOB is not set
-# CONFIG_SLUB is not set
-# CONFIG_SLUB_DEBUG is not set
-# CONFIG_SLUB_STATS is not set
-# CONFIG_SMARTJOYPLUS_FF is not set
-# CONFIG_SMC911X is not set
-# CONFIG_SMC9194 is not set
-# CONFIG_SMC91X is not set
-# CONFIG_SMP is not set
-# CONFIG_SMSC911X is not set
-# CONFIG_SMSC9420 is not set
-# CONFIG_SMSC_PHY is not set
-# CONFIG_SM_FTL is not set
-# CONFIG_SND is not set
-# CONFIG_SND_AC97_POWER_SAVE is not set
-# CONFIG_SND_AD1816A is not set
-# CONFIG_SND_AD1848 is not set
-# CONFIG_SND_AD1889 is not set
-# CONFIG_SND_ADLIB is not set
-# CONFIG_SND_ALI5451 is not set
-# CONFIG_SND_ALOOP is not set
-# CONFIG_SND_ALS100 is not set
-# CONFIG_SND_ALS300 is not set
-# CONFIG_SND_ALS4000 is not set
-# CONFIG_SND_ARM is not set
-# CONFIG_SND_ASIHPI is not set
-# CONFIG_SND_ATIIXP is not set
-# CONFIG_SND_ATIIXP_MODEM is not set
-# CONFIG_SND_ATMEL_AC97C is not set
-# CONFIG_SND_ATMEL_SOC is not set
-# CONFIG_SND_AU8810 is not set
-# CONFIG_SND_AU8820 is not set
-# CONFIG_SND_AU8830 is not set
-# CONFIG_SND_AW2 is not set
-# CONFIG_SND_AZT2320 is not set
-# CONFIG_SND_AZT3328 is not set
-# CONFIG_SND_BCD2000 is not set
-# CONFIG_SND_BT87X is not set
-# CONFIG_SND_CA0106 is not set
-# CONFIG_SND_CMI8330 is not set
-# CONFIG_SND_CMIPCI is not set
-# CONFIG_SND_CS4231 is not set
-# CONFIG_SND_CS4236 is not set
-# CONFIG_SND_CS4281 is not set
-# CONFIG_SND_CS46XX is not set
-# CONFIG_SND_CS5530 is not set
-# CONFIG_SND_CS5535AUDIO is not set
-# CONFIG_SND_CTXFI is not set
-# CONFIG_SND_DARLA20 is not set
-# CONFIG_SND_DARLA24 is not set
-# CONFIG_SND_DEBUG is not set
-# CONFIG_SND_DESIGNWARE_I2S is not set
-CONFIG_SND_DRIVERS=y
-# CONFIG_SND_DUMMY is not set
-# CONFIG_SND_DYNAMIC_MINORS is not set
-# CONFIG_SND_ECHO3G is not set
-# CONFIG_SND_EMU10K1 is not set
-# CONFIG_SND_EMU10K1X is not set
-# CONFIG_SND_ENS1370 is not set
-# CONFIG_SND_ENS1371 is not set
-# CONFIG_SND_ES1688 is not set
-# CONFIG_SND_ES18XX is not set
-# CONFIG_SND_ES1938 is not set
-# CONFIG_SND_ES1968 is not set
-# CONFIG_SND_FIREWIRE is not set
-# CONFIG_SND_FM801 is not set
-# CONFIG_SND_GINA20 is not set
-# CONFIG_SND_GINA24 is not set
-# CONFIG_SND_GUSCLASSIC is not set
-# CONFIG_SND_GUSEXTREME is not set
-# CONFIG_SND_GUSMAX is not set
-# CONFIG_SND_HDA_INPUT_JACK is not set
-# CONFIG_SND_HDA_INTEL is not set
-CONFIG_SND_HDA_POWER_SAVE_DEFAULT=0
-CONFIG_SND_HDA_PREALLOC_SIZE=64
-# CONFIG_SND_HDSP is not set
-# CONFIG_SND_HDSPM is not set
-# CONFIG_SND_HRTIMER is not set
-# CONFIG_SND_HWDEP is not set
-# CONFIG_SND_ICE1712 is not set
-# CONFIG_SND_ICE1724 is not set
-# CONFIG_SND_INDIGO is not set
-# CONFIG_SND_INDIGODJ is not set
-# CONFIG_SND_INDIGODJX is not set
-# CONFIG_SND_INDIGOIO is not set
-# CONFIG_SND_INDIGOIOX is not set
-# CONFIG_SND_INTEL8X0 is not set
-# CONFIG_SND_INTEL8X0M is not set
-# CONFIG_SND_INTERWAVE is not set
-# CONFIG_SND_INTERWAVE_STB is not set
-# CONFIG_SND_ISA is not set
-# CONFIG_SND_KIRKWOOD_SOC is not set
-# CONFIG_SND_KORG1212 is not set
-# CONFIG_SND_LAYLA20 is not set
-# CONFIG_SND_LAYLA24 is not set
-# CONFIG_SND_LOLA is not set
-# CONFIG_SND_LX6464ES is not set
-# CONFIG_SND_MAESTRO3 is not set
-# CONFIG_SND_MIA is not set
-# CONFIG_SND_MIPS is not set
-# CONFIG_SND_MIRO is not set
-# CONFIG_SND_MIXART is not set
-# CONFIG_SND_MIXER_OSS is not set
-# CONFIG_SND_MONA is not set
-# CONFIG_SND_MPC52xx_SOC_EFIKA is not set
-# CONFIG_SND_MPU401 is not set
-# CONFIG_SND_MTPAV is not set
-# CONFIG_SND_MTS64 is not set
-# CONFIG_SND_MXS_SOC is not set
-# CONFIG_SND_NM256 is not set
-# CONFIG_SND_OPL3SA2 is not set
-# CONFIG_SND_OPTI92X_AD1848 is not set
-# CONFIG_SND_OPTI92X_CS4231 is not set
-# CONFIG_SND_OPTI93X is not set
-CONFIG_SND_OSSEMUL=y
-# CONFIG_SND_OXYGEN is not set
-CONFIG_SND_PCI=y
-# CONFIG_SND_PCM is not set
-# CONFIG_SND_PCMCIA is not set
-# CONFIG_SND_PCM_OSS is not set
-CONFIG_SND_PCM_OSS_PLUGINS=y
-# CONFIG_SND_PCXHR is not set
-# CONFIG_SND_PDAUDIOCF is not set
-# CONFIG_SND_PORTMAN2X4 is not set
-# CONFIG_SND_POWERPC_SOC is not set
-# CONFIG_SND_PPC is not set
-# CONFIG_SND_RAWMIDI is not set
-# CONFIG_SND_RIPTIDE is not set
-# CONFIG_SND_RME32 is not set
-# CONFIG_SND_RME96 is not set
-# CONFIG_SND_RME9652 is not set
-# CONFIG_SND_RTCTIMER is not set
-# CONFIG_SND_SB16 is not set
-# CONFIG_SND_SB8 is not set
-# CONFIG_SND_SBAWE is not set
-# CONFIG_SND_SEQUENCER is not set
-# CONFIG_SND_SERIAL_U16550 is not set
-# CONFIG_SND_SIMPLE_CARD is not set
-# CONFIG_SND_SIS7019 is not set
-# CONFIG_SND_SOC is not set
-# CONFIG_SND_SOC_ADAU1701 is not set
-# CONFIG_SND_SOC_AK4104 is not set
-# CONFIG_SND_SOC_AK4554 is not set
-# CONFIG_SND_SOC_AK4642 is not set
-# CONFIG_SND_SOC_AK5386 is not set
-# CONFIG_SND_SOC_ALC5623 is not set
-# CONFIG_SND_SOC_AU1XAUDIO is not set
-# CONFIG_SND_SOC_AU1XPSC is not set
-# CONFIG_SND_SOC_CACHE_LZO is not set
-# CONFIG_SND_SOC_CS35L32 is not set
-# CONFIG_SND_SOC_CS4265 is not set
-# CONFIG_SND_SOC_CS4270 is not set
-# CONFIG_SND_SOC_CS4271 is not set
-# CONFIG_SND_SOC_CS42L52 is not set
-# CONFIG_SND_SOC_CS42L56 is not set
-# CONFIG_SND_SOC_CS42L73 is not set
-# CONFIG_SND_SOC_CS42XX8_I2C is not set
-# CONFIG_SND_SOC_ES8328 is not set
-# CONFIG_SND_SOC_EUKREA_TLV320 is not set
-# CONFIG_SND_SOC_FSL_ASOC_CARD is not set
-# CONFIG_SND_SOC_FSL_ASRC is not set
-# CONFIG_SND_SOC_FSL_ESAI is not set
-# CONFIG_SND_SOC_FSL_SAI is not set
-# CONFIG_SND_SOC_FSL_SPDIF is not set
-# CONFIG_SND_SOC_HDMI_CODEC is not set
-# CONFIG_SND_SOC_IMX_ES8328 is not set
-# CONFIG_SND_SOC_IMX_SPDIF is not set
-# CONFIG_SND_SOC_IMX_WM8962 is not set
-# CONFIG_SND_SOC_INTEL_SST is not set
-# CONFIG_SND_SOC_MPC5200_AC97 is not set
-# CONFIG_SND_SOC_MPC5200_I2S is not set
-# CONFIG_SND_SOC_PCM1681 is not set
-# CONFIG_SND_SOC_PCM1792A is not set
-# CONFIG_SND_SOC_PCM512x_I2C is not set
-# CONFIG_SND_SOC_PCM512x_SPI is not set
-# CONFIG_SND_SOC_SGTL5000 is not set
-# CONFIG_SND_SOC_SIRF_AUDIO_CODEC is not set
-# CONFIG_SND_SOC_SPDIF is not set
-# CONFIG_SND_SOC_SSM2602_I2C is not set
-# CONFIG_SND_SOC_SSM2602_SPI is not set
-# CONFIG_SND_SOC_SSM4567 is not set
-# CONFIG_SND_SOC_STA350 is not set
-# CONFIG_SND_SOC_TAS2552 is not set
-# CONFIG_SND_SOC_TAS5086 is not set
-# CONFIG_SND_SOC_TLV320AIC31XX is not set
-# CONFIG_SND_SOC_TLV320AIC3X is not set
-# CONFIG_SND_SOC_TPA6130A2 is not set
-# CONFIG_SND_SOC_WM8510 is not set
-# CONFIG_SND_SOC_WM8523 is not set
-# CONFIG_SND_SOC_WM8580 is not set
-# CONFIG_SND_SOC_WM8711 is not set
-# CONFIG_SND_SOC_WM8728 is not set
-# CONFIG_SND_SOC_WM8731 is not set
-# CONFIG_SND_SOC_WM8737 is not set
-# CONFIG_SND_SOC_WM8741 is not set
-# CONFIG_SND_SOC_WM8750 is not set
-# CONFIG_SND_SOC_WM8753 is not set
-# CONFIG_SND_SOC_WM8770 is not set
-# CONFIG_SND_SOC_WM8776 is not set
-# CONFIG_SND_SOC_WM8804 is not set
-# CONFIG_SND_SOC_WM8903 is not set
-# CONFIG_SND_SOC_WM8962 is not set
-# CONFIG_SND_SOC_WM8978 is not set
-# CONFIG_SND_SONICVIBES is not set
-# CONFIG_SND_SPI is not set
-# CONFIG_SND_SSCAPE is not set
-# CONFIG_SND_SUPPORT_OLD_API is not set
-# CONFIG_SND_TIMER is not set
-# CONFIG_SND_TRIDENT is not set
-CONFIG_SND_USB=y
-# CONFIG_SND_USB_6FIRE is not set
-# CONFIG_SND_USB_AUDIO is not set
-# CONFIG_SND_USB_CAIAQ is not set
-# CONFIG_SND_USB_HIFACE is not set
-# CONFIG_SND_USB_UA101 is not set
-# CONFIG_SND_USB_US122L is not set
-# CONFIG_SND_USB_USX2Y is not set
-# CONFIG_SND_VERBOSE_PRINTK is not set
-CONFIG_SND_VERBOSE_PROCFS=y
-# CONFIG_SND_VIA82XX is not set
-# CONFIG_SND_VIA82XX_MODEM is not set
-# CONFIG_SND_VIRTUOSO is not set
-# CONFIG_SND_VX222 is not set
-# CONFIG_SND_VXPOCKET is not set
-# CONFIG_SND_WAVEFRONT is not set
-# CONFIG_SND_YMFPCI is not set
-# CONFIG_SNI_RM is not set
-# CONFIG_SOC_AM33XX is not set
-# CONFIG_SOC_AM43XX is not set
-# CONFIG_SOC_CAMERA is not set
-# CONFIG_SOC_DRA7XX is not set
-# CONFIG_SOC_HAS_OMAP2_SDRC is not set
-# CONFIG_SOC_OMAP5 is not set
-# CONFIG_SOC_TI is not set
-# CONFIG_SOFT_WATCHDOG is not set
-# CONFIG_SOLARIS_X86_PARTITION is not set
-# CONFIG_SOLO6X10 is not set
-# CONFIG_SONYPI is not set
-# CONFIG_SONY_LAPTOP is not set
-# CONFIG_SOUND is not set
-# CONFIG_SOUND_PRIME is not set
-# CONFIG_SP5100_TCO is not set
-# CONFIG_SPARSEMEM_MANUAL is not set
-# CONFIG_SPARSEMEM_STATIC is not set
-# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
-# CONFIG_SPARSE_IRQ is not set
-# CONFIG_SPARSE_RCU_POINTER is not set
-# CONFIG_SPEAKUP is not set
-# CONFIG_SPI is not set
-# CONFIG_SPINLOCK_TEST is not set
-# CONFIG_SPI_ALTERA is not set
-# CONFIG_SPI_AU1550 is not set
-# CONFIG_SPI_BCM2835 is not set
-# CONFIG_SPI_BITBANG is not set
-# CONFIG_SPI_BUTTERFLY is not set
-# CONFIG_SPI_CADENCE is not set
-# CONFIG_SPI_DEBUG is not set
-# CONFIG_SPI_DESIGNWARE is not set
-# CONFIG_SPI_FSL_DSPI is not set
-# CONFIG_SPI_FSL_ESPI is not set
-# CONFIG_SPI_FSL_SPI is not set
-# CONFIG_SPI_GPIO is not set
-# CONFIG_SPI_GPIO_OLD is not set
-# CONFIG_SPI_LM70_LLP is not set
-# CONFIG_SPI_MASTER is not set
-# CONFIG_SPI_MPC52xx is not set
-# CONFIG_SPI_MPC52xx_PSC is not set
-# CONFIG_SPI_OCTEON is not set
-# CONFIG_SPI_OC_TINY is not set
-# CONFIG_SPI_ORION is not set
-# CONFIG_SPI_PL022 is not set
-# CONFIG_SPI_PPC4xx is not set
-# CONFIG_SPI_PXA2XX is not set
-# CONFIG_SPI_PXA2XX_PCI is not set
-# CONFIG_SPI_RAMIPS is not set
-# CONFIG_SPI_ROCKCHIP is not set
-# CONFIG_SPI_SC18IS602 is not set
-# CONFIG_SPI_SPIDEV is not set
-# CONFIG_SPI_TI_QSPI is not set
-# CONFIG_SPI_TLE62X0 is not set
-# CONFIG_SPI_TOPCLIFF_PCH is not set
-# CONFIG_SPI_XCOMM is not set
-# CONFIG_SPI_XILINX is not set
-# CONFIG_SPI_XWAY is not set
-CONFIG_SPLIT_PTLOCK_CPUS=4
-# CONFIG_SPMI is not set
-CONFIG_SQUASHFS=y
-# CONFIG_SQUASHFS_4K_DEVBLK_SIZE is not set
-# CONFIG_SQUASHFS_DECOMP_MULTI is not set
-CONFIG_SQUASHFS_DECOMP_MULTI_PERCPU=y
-# CONFIG_SQUASHFS_DECOMP_SINGLE is not set
-CONFIG_SQUASHFS_EMBEDDED=y
-# CONFIG_SQUASHFS_FILE_CACHE is not set
-CONFIG_SQUASHFS_FILE_DIRECT=y
-CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
-# CONFIG_SQUASHFS_LZO is not set
-# CONFIG_SQUASHFS_XATTR is not set
-CONFIG_SQUASHFS_XZ=y
-# CONFIG_SQUASHFS_ZLIB is not set
-# CONFIG_SRAM is not set
-# CONFIG_SSB is not set
-# CONFIG_SSBI is not set
-# CONFIG_SSB_DEBUG is not set
-# CONFIG_SSB_DRIVER_GPIO is not set
-# CONFIG_SSB_PCMCIAHOST is not set
-CONFIG_SSB_POSSIBLE=y
-# CONFIG_SSB_SDIOHOST is not set
-# CONFIG_SSB_SILENT is not set
-# CONFIG_SSFDC is not set
-# CONFIG_STACKTRACE is not set
-CONFIG_STACKTRACE_SUPPORT=y
-# CONFIG_STACK_TRACER is not set
-CONFIG_STAGING=y
-# CONFIG_STAGING_MEDIA is not set
-CONFIG_STANDALONE=y
-CONFIG_STDBINUTILS=y
-# CONFIG_STE10XP is not set
-# CONFIG_STE_MODEM_RPROC is not set
-# CONFIG_STMMAC_ETH is not set
-# CONFIG_STMMAC_PCI is not set
-# CONFIG_STMMAC_PLATFORM is not set
-CONFIG_STP=y
-# CONFIG_STRICT_DEVMEM is not set
-CONFIG_STRIP_ASM_SYMS=y
-# CONFIG_STUB_POULSBO is not set
-# CONFIG_SUNDANCE is not set
-# CONFIG_SUNGEM is not set
-# CONFIG_SUNRPC is not set
-# CONFIG_SUNRPC_DEBUG is not set
-# CONFIG_SUNRPC_GSS is not set
-# CONFIG_SUN_PARTITION is not set
-# CONFIG_SUSPEND is not set
-CONFIG_SWAP=y
-# CONFIG_SWCONFIG is not set
-# CONFIG_SWCONFIG_B53 is not set
-# CONFIG_SWCONFIG_B53_SPI_DRIVER is not set
-# CONFIG_SWCONFIG_LEDS is not set
-# CONFIG_SXGBE_ETH is not set
-# CONFIG_SYNCLINK_CS is not set
-CONFIG_SYN_COOKIES=y
-CONFIG_SYSCTL=y
-# CONFIG_SYSCTL_SYSCALL is not set
-# CONFIG_SYSCTL_SYSCALL_CHECK is not set
-CONFIG_SYSFS=y
-# CONFIG_SYSFS_DEPRECATED is not set
-# CONFIG_SYSFS_DEPRECATED_V2 is not set
-# CONFIG_SYSFS_SYSCALL is not set
-# CONFIG_SYSTEMPORT is not set
-# CONFIG_SYSTEM_TRUSTED_KEYRING is not set
-# CONFIG_SYSV68_PARTITION is not set
-CONFIG_SYSVIPC=y
-CONFIG_SYSVIPC_SYSCTL=y
-# CONFIG_SYSV_FS is not set
-# CONFIG_SYS_HYPERVISOR is not set
-# CONFIG_T5403 is not set
-# CONFIG_TARGET_CORE is not set
-# CONFIG_TASKSTATS is not set
-# CONFIG_TASKS_RCU is not set
-# CONFIG_TC35815 is not set
-# CONFIG_TCG_ATMEL is not set
-# CONFIG_TCG_INFINEON is not set
-# CONFIG_TCG_ST33_I2C is not set
-# CONFIG_TCG_TIS is not set
-# CONFIG_TCG_TIS_I2C_ATMEL is not set
-# CONFIG_TCG_TIS_I2C_INFINEON is not set
-# CONFIG_TCG_TIS_I2C_NUVOTON is not set
-# CONFIG_TCG_TIS_ST33ZP24 is not set
-# CONFIG_TCG_TPM is not set
-# CONFIG_TCG_XEN is not set
-# CONFIG_TCIC is not set
-CONFIG_TCP_CONG_ADVANCED=y
-# CONFIG_TCP_CONG_BIC is not set
-CONFIG_TCP_CONG_CUBIC=y
-# CONFIG_TCP_CONG_DCTCP is not set
-# CONFIG_TCP_CONG_HSTCP is not set
-# CONFIG_TCP_CONG_HTCP is not set
-# CONFIG_TCP_CONG_HYBLA is not set
-# CONFIG_TCP_CONG_ILLINOIS is not set
-# CONFIG_TCP_CONG_LP is not set
-# CONFIG_TCP_CONG_SCALABLE is not set
-# CONFIG_TCP_CONG_VEGAS is not set
-# CONFIG_TCP_CONG_VENO is not set
-# CONFIG_TCP_CONG_WESTWOOD is not set
-# CONFIG_TCP_CONG_YEAH is not set
-# CONFIG_TCP_MD5SIG is not set
-# CONFIG_TCS3414 is not set
-# CONFIG_TCS3472 is not set
-# CONFIG_TEGRA_HOST1X is not set
-# CONFIG_TEHUTI is not set
-# CONFIG_TEST_BPF is not set
-# CONFIG_TEST_FIRMWARE is not set
-# CONFIG_TEST_KSTRTOX is not set
-# CONFIG_TEST_LIST_SORT is not set
-# CONFIG_TEST_LKM is not set
-# CONFIG_TEST_MODULE is not set
-# CONFIG_TEST_POWER is not set
-# CONFIG_TEST_RHASHTABLE is not set
-# CONFIG_TEST_STRING_HELPERS is not set
-# CONFIG_TEST_UDELAY is not set
-# CONFIG_TEST_USER_COPY is not set
-CONFIG_TEXTSEARCH=y
-# CONFIG_TEXTSEARCH_BM is not set
-# CONFIG_TEXTSEARCH_FSM is not set
-# CONFIG_TEXTSEARCH_KMP is not set
-# CONFIG_THERMAL is not set
-# CONFIG_THERMAL_GOV_BANG_BANG is not set
-# CONFIG_THERMAL_HWMON is not set
-# CONFIG_THRUSTMASTER_FF is not set
-# CONFIG_THUNDERBOLT is not set
-# CONFIG_TICK_CPU_ACCOUNTING is not set
-CONFIG_TICK_ONESHOT=y
-# CONFIG_TIFM_CORE is not set
-# CONFIG_TIGON3 is not set
-# CONFIG_TIMB_DMA is not set
-CONFIG_TIMERFD=y
-# CONFIG_TIMER_STATS is not set
-CONFIG_TINY_RCU=y
-# CONFIG_TIPC is not set
-# CONFIG_TI_ADC081C is not set
-# CONFIG_TI_ADC128S052 is not set
-# CONFIG_TI_AM335X_ADC is not set
-# CONFIG_TI_CPSW is not set
-# CONFIG_TI_CPTS is not set
-# CONFIG_TI_DAC7512 is not set
-# CONFIG_TI_DAVINCI_CPDMA is not set
-# CONFIG_TI_DAVINCI_MDIO is not set
-# CONFIG_TI_ST is not set
-# CONFIG_TLAN is not set
-# CONFIG_TMD_HERMES is not set
-# CONFIG_TMP006 is not set
-CONFIG_TMPFS=y
-# CONFIG_TMPFS_POSIX_ACL is not set
-CONFIG_TMPFS_XATTR=y
-# CONFIG_TORTURE_TEST is not set
-# CONFIG_TOSHIBA_HAPS is not set
-# CONFIG_TOUCHSCREEN_AD7877 is not set
-# CONFIG_TOUCHSCREEN_AD7879 is not set
-# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
-# CONFIG_TOUCHSCREEN_AD7879_SPI is not set
-# CONFIG_TOUCHSCREEN_ADS7846 is not set
-# CONFIG_TOUCHSCREEN_AR1021_I2C is not set
-# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
-# CONFIG_TOUCHSCREEN_AUO_PIXCIR is not set
-# CONFIG_TOUCHSCREEN_BU21013 is not set
-# CONFIG_TOUCHSCREEN_CLEARPAD_TM1217 is not set
-# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
-# CONFIG_TOUCHSCREEN_CYTTSP4_CORE is not set
-# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
-# CONFIG_TOUCHSCREEN_DYNAPRO is not set
-# CONFIG_TOUCHSCREEN_EDT_FT5X06 is not set
-# CONFIG_TOUCHSCREEN_EETI is not set
-# CONFIG_TOUCHSCREEN_EGALAX is not set
-# CONFIG_TOUCHSCREEN_ELO is not set
-# CONFIG_TOUCHSCREEN_FUJITSU is not set
-# CONFIG_TOUCHSCREEN_GUNZE is not set
-# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
-# CONFIG_TOUCHSCREEN_ILI210X is not set
-# CONFIG_TOUCHSCREEN_INEXIO is not set
-# CONFIG_TOUCHSCREEN_MAX11801 is not set
-# CONFIG_TOUCHSCREEN_MCS5000 is not set
-# CONFIG_TOUCHSCREEN_MK712 is not set
-# CONFIG_TOUCHSCREEN_MMS114 is not set
-# CONFIG_TOUCHSCREEN_MTOUCH is not set
-# CONFIG_TOUCHSCREEN_PENMOUNT is not set
-# CONFIG_TOUCHSCREEN_PIXCIR is not set
-# CONFIG_TOUCHSCREEN_S3C2410 is not set
-# CONFIG_TOUCHSCREEN_ST1232 is not set
-# CONFIG_TOUCHSCREEN_SUR40 is not set
-# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4 is not set
-# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
-# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
-# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
-# CONFIG_TOUCHSCREEN_TPS6507X is not set
-# CONFIG_TOUCHSCREEN_TSC2005 is not set
-# CONFIG_TOUCHSCREEN_TSC2007 is not set
-# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
-# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
-# CONFIG_TOUCHSCREEN_W90X900 is not set
-# CONFIG_TOUCHSCREEN_WACOM_I2C is not set
-# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
-# CONFIG_TOUCHSCREEN_WM97XX is not set
-# CONFIG_TOUCHSCREEN_ZFORCE is not set
-# CONFIG_TPS6105X is not set
-# CONFIG_TPS65010 is not set
-# CONFIG_TPS6507X is not set
-# CONFIG_TR is not set
-# CONFIG_TRACEPOINT_BENCHMARK is not set
-# CONFIG_TRACER_SNAPSHOT is not set
-# CONFIG_TRACER_SNAPSHOT_PER_CPU_SWAP is not set
-# CONFIG_TRACE_BRANCH_PROFILING is not set
-CONFIG_TRACE_IRQFLAGS_SUPPORT=y
-# CONFIG_TRACE_SINK is not set
-CONFIG_TRACING_SUPPORT=y
-CONFIG_TRAD_SIGNALS=y
-# CONFIG_TRANSPARENT_HUGEPAGE is not set
-# CONFIG_TRANZPORT is not set
-# CONFIG_TREE_PREEMPT_RCU is not set
-# CONFIG_TREE_RCU is not set
-# CONFIG_TREE_RCU_TRACE is not set
-# CONFIG_TRUSTED_KEYS is not set
-# CONFIG_TSL2583 is not set
-# CONFIG_TSL2x7x is not set
-# CONFIG_TSL4531 is not set
-CONFIG_TTY=y
-# CONFIG_TTY_PRINTK is not set
-# CONFIG_TUN is not set
-# CONFIG_TWL4030_CORE is not set
-# CONFIG_TWL4030_MADC is not set
-# CONFIG_TWL6030_GPADC is not set
-# CONFIG_TWL6040_CORE is not set
-# CONFIG_TYPHOON is not set
-# CONFIG_UACCESS_WITH_MEMCPY is not set
-# CONFIG_UCB1400_CORE is not set
-# CONFIG_UDF_FS is not set
-CONFIG_UDF_NLS=y
-CONFIG_UEVENT_HELPER=y
-CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
-# CONFIG_UFS_FS is not set
-# CONFIG_UHID is not set
-CONFIG_UIDGID_STRICT_TYPE_CHECKS=y
-# CONFIG_UIO is not set
-# CONFIG_ULTRA is not set
-# CONFIG_ULTRIX_PARTITION is not set
-CONFIG_UNIX=y
-CONFIG_UNIX98_PTYS=y
-# CONFIG_UNIXWARE_DISKLABEL is not set
-# CONFIG_UNIX_DIAG is not set
-# CONFIG_UNUSED_SYMBOLS is not set
-# CONFIG_UPROBES is not set
-# CONFIG_UPROBE_EVENT is not set
-# CONFIG_USB is not set
-# CONFIG_USBIP_CORE is not set
-# CONFIG_USBPCWATCHDOG is not set
-# CONFIG_USB_ACM is not set
-# CONFIG_USB_ADUTUX is not set
-CONFIG_USB_ALI_M5632=y
-# CONFIG_USB_AMD5536UDC is not set
-CONFIG_USB_AN2720=y
-# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
-# CONFIG_USB_APPLEDISPLAY is not set
-CONFIG_USB_ARCH_HAS_EHCI=y
-CONFIG_USB_ARCH_HAS_HCD=y
-CONFIG_USB_ARCH_HAS_OHCI=y
-CONFIG_USB_ARMLINUX=y
-# CONFIG_USB_ATM is not set
-CONFIG_USB_BELKIN=y
-# CONFIG_USB_BTMTK is not set
-# CONFIG_USB_C67X00_HCD is not set
-# CONFIG_USB_CATC is not set
-# CONFIG_USB_CDC_COMPOSITE is not set
-# CONFIG_USB_CHIPIDEA is not set
-# CONFIG_USB_CONFIGFS is not set
-# CONFIG_USB_CXACRU is not set
-# CONFIG_USB_CYPRESS_CY7C63 is not set
-# CONFIG_USB_CYTHERM is not set
-# CONFIG_USB_DEBUG is not set
-CONFIG_USB_DEFAULT_PERSIST=y
-CONFIG_USB_DEVICEFS=y
-# CONFIG_USB_DEVICE_CLASS is not set
-# CONFIG_USB_DSBR is not set
-# CONFIG_USB_DUMMY_HCD is not set
-# CONFIG_USB_DWC2 is not set
-# CONFIG_USB_DWC2_DUAL_ROLE is not set
-# CONFIG_USB_DWC2_HOST is not set
-# CONFIG_USB_DWC2_PERIPHERAL is not set
-# CONFIG_USB_DWC3 is not set
-# CONFIG_USB_DWC3_EXYNOS is not set
-# CONFIG_USB_DWC3_KEYSTONE is not set
-# CONFIG_USB_DWC3_PCI is not set
-# CONFIG_USB_DWC3_QCOM is not set
-# CONFIG_USB_DWC_OTG_LPM is not set
-# CONFIG_USB_DYNAMIC_MINORS is not set
-# CONFIG_USB_EG20T is not set
-# CONFIG_USB_EHCI_HCD_AT91 is not set
-# CONFIG_USB_EHCI_HCD_PPC_OF is not set
-# CONFIG_USB_EHCI_MSM is not set
-# CONFIG_USB_EHCI_MV is not set
-CONFIG_USB_EHCI_ROOT_HUB_TT=y
-CONFIG_USB_EHCI_TT_NEWSCHED=y
-# CONFIG_USB_EHSET_TEST_FIXTURE is not set
-# CONFIG_USB_EMI26 is not set
-# CONFIG_USB_EMI62 is not set
-# CONFIG_USB_ENESTORAGE is not set
-# CONFIG_USB_EPSON2888 is not set
-# CONFIG_USB_ET61X251 is not set
-CONFIG_USB_EZUSB=y
-# CONFIG_USB_EZUSB_FX2 is not set
-# CONFIG_USB_FILE_STORAGE is not set
-# CONFIG_USB_FOTG210_HCD is not set
-# CONFIG_USB_FOTG210_UDC is not set
-# CONFIG_USB_FSL_USB2 is not set
-# CONFIG_USB_FTDI_ELAN is not set
-# CONFIG_USB_FUNCTIONFS is not set
-# CONFIG_USB_FUSB300 is not set
-# CONFIG_USB_FUSBH200_HCD is not set
-# CONFIG_USB_GADGET is not set
-# CONFIG_USB_GADGETFS is not set
-# CONFIG_USB_GADGET_DEBUG is not set
-# CONFIG_USB_GADGET_DEBUG_FILES is not set
-# CONFIG_USB_GADGET_DEBUG_FS is not set
-CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
-CONFIG_USB_GADGET_VBUS_DRAW=2
-# CONFIG_USB_GADGET_XILINX is not set
-# CONFIG_USB_GL860 is not set
-# CONFIG_USB_GOKU is not set
-# CONFIG_USB_GPIO_VBUS is not set
-# CONFIG_USB_GR_UDC is not set
-# CONFIG_USB_GSPCA is not set
-# CONFIG_USB_GSPCA_BENQ is not set
-# CONFIG_USB_GSPCA_CONEX is not set
-# CONFIG_USB_GSPCA_CPIA1 is not set
-# CONFIG_USB_GSPCA_DTCS033 is not set
-# CONFIG_USB_GSPCA_ETOMS is not set
-# CONFIG_USB_GSPCA_FINEPIX is not set
-# CONFIG_USB_GSPCA_JEILINJ is not set
-# CONFIG_USB_GSPCA_JL2005BCD is not set
-# CONFIG_USB_GSPCA_KINECT is not set
-# CONFIG_USB_GSPCA_KONICA is not set
-# CONFIG_USB_GSPCA_MARS is not set
-# CONFIG_USB_GSPCA_MR97310A is not set
-# CONFIG_USB_GSPCA_NW80X is not set
-# CONFIG_USB_GSPCA_OV519 is not set
-# CONFIG_USB_GSPCA_OV534 is not set
-# CONFIG_USB_GSPCA_OV534_9 is not set
-# CONFIG_USB_GSPCA_PAC207 is not set
-# CONFIG_USB_GSPCA_PAC7302 is not set
-# CONFIG_USB_GSPCA_PAC7311 is not set
-# CONFIG_USB_GSPCA_SE401 is not set
-# CONFIG_USB_GSPCA_SN9C2028 is not set
-# CONFIG_USB_GSPCA_SN9C20X is not set
-# CONFIG_USB_GSPCA_SONIXB is not set
-# CONFIG_USB_GSPCA_SONIXJ is not set
-# CONFIG_USB_GSPCA_SPCA1528 is not set
-# CONFIG_USB_GSPCA_SPCA500 is not set
-# CONFIG_USB_GSPCA_SPCA501 is not set
-# CONFIG_USB_GSPCA_SPCA505 is not set
-# CONFIG_USB_GSPCA_SPCA506 is not set
-# CONFIG_USB_GSPCA_SPCA508 is not set
-# CONFIG_USB_GSPCA_SPCA561 is not set
-# CONFIG_USB_GSPCA_SQ905 is not set
-# CONFIG_USB_GSPCA_SQ905C is not set
-# CONFIG_USB_GSPCA_SQ930X is not set
-# CONFIG_USB_GSPCA_STK014 is not set
-# CONFIG_USB_GSPCA_STK1135 is not set
-# CONFIG_USB_GSPCA_STV0680 is not set
-# CONFIG_USB_GSPCA_SUNPLUS is not set
-# CONFIG_USB_GSPCA_T613 is not set
-# CONFIG_USB_GSPCA_TOPRO is not set
-# CONFIG_USB_GSPCA_TV8532 is not set
-# CONFIG_USB_GSPCA_VC032X is not set
-# CONFIG_USB_GSPCA_VICAM is not set
-# CONFIG_USB_GSPCA_XIRLINK_CIT is not set
-# CONFIG_USB_GSPCA_ZC3XX is not set
-# CONFIG_USB_G_ACM_MS is not set
-# CONFIG_USB_G_DBGP is not set
-# CONFIG_USB_G_HID is not set
-# CONFIG_USB_G_MULTI is not set
-# CONFIG_USB_G_NCM is not set
-# CONFIG_USB_G_NOKIA is not set
-# CONFIG_USB_G_PRINTER is not set
-# CONFIG_USB_G_SERIAL is not set
-# CONFIG_USB_G_WEBCAM is not set
-# CONFIG_USB_HCD_TEST_MODE is not set
-# CONFIG_USB_HID is not set
-# CONFIG_USB_HIDDEV is not set
-# CONFIG_USB_HSIC_USB3503 is not set
-# CONFIG_USB_HSO is not set
-# CONFIG_USB_HWA_HCD is not set
-# CONFIG_USB_IBMCAM is not set
-# CONFIG_USB_IDMOUSE is not set
-# CONFIG_USB_INPUT_IMS_PCU is not set
-# CONFIG_USB_IOWARRIOR is not set
-# CONFIG_USB_IPHETH is not set
-# CONFIG_USB_IP_COMMON is not set
-# CONFIG_USB_ISIGHTFW is not set
-# CONFIG_USB_ISP116X_HCD is not set
-# CONFIG_USB_ISP1301 is not set
-# CONFIG_USB_ISP1362_HCD is not set
-# CONFIG_USB_ISP1760_HCD is not set
-# CONFIG_USB_KAWETH is not set
-# CONFIG_USB_KBD is not set
-# CONFIG_USB_KC2190 is not set
-# CONFIG_USB_KONICAWC is not set
-# CONFIG_USB_LCD is not set
-# CONFIG_USB_LD is not set
-# CONFIG_USB_LED is not set
-# CONFIG_USB_LED_TRIG is not set
-# CONFIG_USB_LEGOTOWER is not set
-# CONFIG_USB_LIBUSUAL is not set
-# CONFIG_USB_LINK_LAYER_TEST is not set
-# CONFIG_USB_M5602 is not set
-# CONFIG_USB_M66592 is not set
-# CONFIG_USB_MASS_STORAGE is not set
-# CONFIG_USB_MAX3421_HCD is not set
-# CONFIG_USB_MDC800 is not set
-# CONFIG_USB_MICROTEK is not set
-# CONFIG_USB_MIDI_GADGET is not set
-# CONFIG_USB_MON is not set
-# CONFIG_USB_MOUSE is not set
-# CONFIG_USB_MSM_OTG is not set
-# CONFIG_USB_MUSB_HDRC is not set
-# CONFIG_USB_MV_U3D is not set
-# CONFIG_USB_MV_UDC is not set
-# CONFIG_USB_MXS_PHY is not set
-# CONFIG_USB_NET2272 is not set
-# CONFIG_USB_NET2280 is not set
-# CONFIG_USB_NET_AX88179_178A is not set
-# CONFIG_USB_NET_AX8817X is not set
-# CONFIG_USB_NET_CDCETHER is not set
-# CONFIG_USB_NET_CDC_EEM is not set
-# CONFIG_USB_NET_CDC_MBIM is not set
-# CONFIG_USB_NET_CDC_NCM is not set
-# CONFIG_USB_NET_CDC_SUBSET is not set
-# CONFIG_USB_NET_CX82310_ETH is not set
-# CONFIG_USB_NET_DM9601 is not set
-# CONFIG_USB_NET_DRIVERS is not set
-# CONFIG_USB_NET_GL620A is not set
-# CONFIG_USB_NET_HUAWEI_CDC_NCM is not set
-# CONFIG_USB_NET_INT51X1 is not set
-# CONFIG_USB_NET_KALMIA is not set
-# CONFIG_USB_NET_MCS7830 is not set
-# CONFIG_USB_NET_NET1080 is not set
-# CONFIG_USB_NET_PLUSB is not set
-# CONFIG_USB_NET_QMI_WWAN is not set
-# CONFIG_USB_NET_RNDIS_HOST is not set
-# CONFIG_USB_NET_RNDIS_WLAN is not set
-# CONFIG_USB_NET_SMSC75XX is not set
-# CONFIG_USB_NET_SMSC95XX is not set
-# CONFIG_USB_NET_SR9700 is not set
-# CONFIG_USB_NET_SR9800 is not set
-# CONFIG_USB_NET_ZAURUS is not set
-# CONFIG_USB_OHCI_HCD is not set
-# CONFIG_USB_OHCI_HCD_PCI is not set
-# CONFIG_USB_OHCI_HCD_PPC_OF is not set
-# CONFIG_USB_OHCI_HCD_PPC_OF_BE is not set
-# CONFIG_USB_OHCI_HCD_PPC_OF_LE is not set
-# CONFIG_USB_OHCI_HCD_PPC_SOC is not set
-# CONFIG_USB_OHCI_HCD_SSB is not set
-CONFIG_USB_OHCI_LITTLE_ENDIAN=y
-# CONFIG_USB_OTG is not set
-# CONFIG_USB_OTG_BLACKLIST_HUB is not set
-# CONFIG_USB_OTG_FSM is not set
-# CONFIG_USB_OTG_WHITELIST is not set
-# CONFIG_USB_OXU210HP_HCD is not set
-# CONFIG_USB_PEGASUS is not set
-# CONFIG_USB_PHY is not set
-# CONFIG_USB_PRINTER is not set
-# CONFIG_USB_PWC_INPUT_EVDEV is not set
-# CONFIG_USB_PXA27X is not set
-# CONFIG_USB_R8A66597 is not set
-# CONFIG_USB_R8A66597_HCD is not set
-# CONFIG_USB_RCAR_PHY is not set
-# CONFIG_USB_RENESAS_USBHS is not set
-# CONFIG_USB_RIO500 is not set
-# CONFIG_USB_RTL8150 is not set
-# CONFIG_USB_RTL8152 is not set
-# CONFIG_USB_S2255 is not set
-# CONFIG_USB_S3C_HSOTG is not set
-# CONFIG_USB_SE401 is not set
-# CONFIG_USB_SERIAL is not set
-# CONFIG_USB_SERIAL_AIRCABLE is not set
-# CONFIG_USB_SERIAL_ARK3116 is not set
-# CONFIG_USB_SERIAL_BELKIN is not set
-# CONFIG_USB_SERIAL_CH341 is not set
-# CONFIG_USB_SERIAL_CP210X is not set
-# CONFIG_USB_SERIAL_CYBERJACK is not set
-# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
-# CONFIG_USB_SERIAL_DEBUG is not set
-# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
-# CONFIG_USB_SERIAL_EDGEPORT is not set
-# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
-# CONFIG_USB_SERIAL_EMPEG is not set
-# CONFIG_USB_SERIAL_F81232 is not set
-# CONFIG_USB_SERIAL_FTDI_SIO is not set
-# CONFIG_USB_SERIAL_FUNSOFT is not set
-# CONFIG_USB_SERIAL_GARMIN is not set
-CONFIG_USB_SERIAL_GENERIC=y
-# CONFIG_USB_SERIAL_HP4X is not set
-# CONFIG_USB_SERIAL_IPAQ is not set
-# CONFIG_USB_SERIAL_IPW is not set
-# CONFIG_USB_SERIAL_IR is not set
-# CONFIG_USB_SERIAL_IUU is not set
-# CONFIG_USB_SERIAL_KEYSPAN is not set
-CONFIG_USB_SERIAL_KEYSPAN_MPR=y
-# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
-CONFIG_USB_SERIAL_KEYSPAN_USA18X=y
-CONFIG_USB_SERIAL_KEYSPAN_USA19=y
-CONFIG_USB_SERIAL_KEYSPAN_USA19QI=y
-CONFIG_USB_SERIAL_KEYSPAN_USA19QW=y
-CONFIG_USB_SERIAL_KEYSPAN_USA19W=y
-CONFIG_USB_SERIAL_KEYSPAN_USA28=y
-CONFIG_USB_SERIAL_KEYSPAN_USA28X=y
-CONFIG_USB_SERIAL_KEYSPAN_USA28XA=y
-CONFIG_USB_SERIAL_KEYSPAN_USA28XB=y
-CONFIG_USB_SERIAL_KEYSPAN_USA49W=y
-CONFIG_USB_SERIAL_KEYSPAN_USA49WLC=y
-# CONFIG_USB_SERIAL_KLSI is not set
-# CONFIG_USB_SERIAL_KOBIL_SCT is not set
-# CONFIG_USB_SERIAL_MCT_U232 is not set
-# CONFIG_USB_SERIAL_METRO is not set
-# CONFIG_USB_SERIAL_MOS7715_PARPORT is not set
-# CONFIG_USB_SERIAL_MOS7720 is not set
-# CONFIG_USB_SERIAL_MOS7840 is not set
-# CONFIG_USB_SERIAL_MOTOROLA is not set
-# CONFIG_USB_SERIAL_MXUPORT is not set
-# CONFIG_USB_SERIAL_NAVMAN is not set
-# CONFIG_USB_SERIAL_OMNINET is not set
-# CONFIG_USB_SERIAL_OPTICON is not set
-# CONFIG_USB_SERIAL_OPTION is not set
-# CONFIG_USB_SERIAL_OTI6858 is not set
-# CONFIG_USB_SERIAL_PL2303 is not set
-# CONFIG_USB_SERIAL_QCAUX is not set
-# CONFIG_USB_SERIAL_QT2 is not set
-# CONFIG_USB_SERIAL_QUALCOMM is not set
-# CONFIG_USB_SERIAL_QUATECH2 is not set
-# CONFIG_USB_SERIAL_QUATECH_USB2 is not set
-# CONFIG_USB_SERIAL_SAFE is not set
-CONFIG_USB_SERIAL_SAFE_PADDED=y
-# CONFIG_USB_SERIAL_SIEMENS_MPI is not set
-# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
-# CONFIG_USB_SERIAL_SIMPLE is not set
-# CONFIG_USB_SERIAL_SPCP8X5 is not set
-# CONFIG_USB_SERIAL_SSU100 is not set
-# CONFIG_USB_SERIAL_SYMBOL is not set
-# CONFIG_USB_SERIAL_TI is not set
-# CONFIG_USB_SERIAL_VISOR is not set
-# CONFIG_USB_SERIAL_VIVOPAY_SERIAL is not set
-# CONFIG_USB_SERIAL_WHITEHEAT is not set
-# CONFIG_USB_SERIAL_WISHBONE is not set
-# CONFIG_USB_SERIAL_XIRCOM is not set
-# CONFIG_USB_SERIAL_XSENS_MT is not set
-# CONFIG_USB_SERIAL_ZIO is not set
-# CONFIG_USB_SERIAL_ZTE is not set
-# CONFIG_USB_SEVSEG is not set
-# CONFIG_USB_SIERRA_NET is not set
-# CONFIG_USB_SISUSBVGA is not set
-# CONFIG_USB_SL811_HCD is not set
-# CONFIG_USB_SN9C102 is not set
-# CONFIG_USB_SPEEDTOUCH is not set
-# CONFIG_USB_STKWEBCAM is not set
-# CONFIG_USB_STORAGE is not set
-# CONFIG_USB_STORAGE_ALAUDA is not set
-# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
-# CONFIG_USB_STORAGE_DATAFAB is not set
-# CONFIG_USB_STORAGE_DEBUG is not set
-# CONFIG_USB_STORAGE_ENE_UB6250 is not set
-# CONFIG_USB_STORAGE_FREECOM is not set
-# CONFIG_USB_STORAGE_ISD200 is not set
-# CONFIG_USB_STORAGE_JUMPSHOT is not set
-# CONFIG_USB_STORAGE_KARMA is not set
-# CONFIG_USB_STORAGE_ONETOUCH is not set
-# CONFIG_USB_STORAGE_REALTEK is not set
-# CONFIG_USB_STORAGE_SDDR09 is not set
-# CONFIG_USB_STORAGE_SDDR55 is not set
-# CONFIG_USB_STORAGE_USBAT is not set
-# CONFIG_USB_STV06XX is not set
-# CONFIG_USB_SUPPORT is not set
-# CONFIG_USB_SUSPEND is not set
-# CONFIG_USB_SWITCH_FSA9480 is not set
-# CONFIG_USB_TEST is not set
-# CONFIG_USB_TMC is not set
-# CONFIG_USB_TRANCEVIBRATOR is not set
-# CONFIG_USB_UAS is not set
-# CONFIG_USB_UEAGLEATM is not set
-# CONFIG_USB_ULPI is not set
-# CONFIG_USB_USBNET is not set
-# CONFIG_USB_USS720 is not set
-# CONFIG_USB_VIDEO_CLASS is not set
-CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
-# CONFIG_USB_VL600 is not set
-# CONFIG_USB_WDM is not set
-# CONFIG_USB_WHCI_HCD is not set
-# CONFIG_USB_WPAN_HCD is not set
-# CONFIG_USB_WUSB is not set
-# CONFIG_USB_WUSB_CBAF is not set
-# CONFIG_USB_XHCI_HCD is not set
-# CONFIG_USB_XUSBATM is not set
-# CONFIG_USB_YUREX is not set
-# CONFIG_USB_ZD1201 is not set
-# CONFIG_USB_ZERO is not set
-# CONFIG_USB_ZR364XX is not set
-# CONFIG_USELIB is not set
-# CONFIG_USE_GENERIC_SMP_HELPERS is not set
-# CONFIG_USE_OF is not set
-# CONFIG_UTS_NS is not set
-# CONFIG_UWB is not set
-# CONFIG_V4L_MEM2MEM_DRIVERS is not set
-# CONFIG_V4L_TEST_DRIVERS is not set
-# CONFIG_VCNL4000 is not set
-# CONFIG_VETH is not set
-# CONFIG_VEXPRESS_CONFIG is not set
-# CONFIG_VF610_ADC is not set
-# CONFIG_VFAT_FS is not set
-# CONFIG_VGASTATE is not set
-# CONFIG_VGA_ARB is not set
-# CONFIG_VGA_SWITCHEROO is not set
-# CONFIG_VIA_RHINE is not set
-# CONFIG_VIA_VELOCITY is not set
-# CONFIG_VIDEO_ADV7170 is not set
-# CONFIG_VIDEO_ADV7175 is not set
-# CONFIG_VIDEO_ADV7180 is not set
-# CONFIG_VIDEO_ADV7183 is not set
-# CONFIG_VIDEO_ADV7343 is not set
-# CONFIG_VIDEO_ADV7393 is not set
-# CONFIG_VIDEO_ADV_DEBUG is not set
-# CONFIG_VIDEO_AK881X is not set
-# CONFIG_VIDEO_BT819 is not set
-# CONFIG_VIDEO_BT848 is not set
-# CONFIG_VIDEO_BT856 is not set
-# CONFIG_VIDEO_BT866 is not set
-# CONFIG_VIDEO_BWQCAM is not set
-# CONFIG_VIDEO_CAFE_CCIC is not set
-# CONFIG_VIDEO_CAPTURE_DRIVERS is not set
-# CONFIG_VIDEO_CPIA is not set
-# CONFIG_VIDEO_CQCAM is not set
-# CONFIG_VIDEO_CS5345 is not set
-# CONFIG_VIDEO_CS53L32A is not set
-# CONFIG_VIDEO_CX231XX is not set
-# CONFIG_VIDEO_CX2341X is not set
-# CONFIG_VIDEO_CX25840 is not set
-# CONFIG_VIDEO_CX88 is not set
-# CONFIG_VIDEO_DEV is not set
-# CONFIG_VIDEO_DM6446_CCDC is not set
-# CONFIG_VIDEO_DT3155 is not set
-# CONFIG_VIDEO_EM28XX is not set
-# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
-# CONFIG_VIDEO_GO7007 is not set
-# CONFIG_VIDEO_HDPVR is not set
-# CONFIG_VIDEO_HELPER_CHIPS_AUTO is not set
-# CONFIG_VIDEO_HEXIUM_GEMINI is not set
-# CONFIG_VIDEO_HEXIUM_ORION is not set
-# CONFIG_VIDEO_IR_I2C is not set
-# CONFIG_VIDEO_IVTV is not set
-# CONFIG_VIDEO_KS0127 is not set
-# CONFIG_VIDEO_M52790 is not set
-# CONFIG_VIDEO_MEDIA is not set
-# CONFIG_VIDEO_MEM2MEM_TESTDEV is not set
-# CONFIG_VIDEO_ML86V7667 is not set
-# CONFIG_VIDEO_MSP3400 is not set
-# CONFIG_VIDEO_MT9V011 is not set
-# CONFIG_VIDEO_MXB is not set
-# CONFIG_VIDEO_NOON010PC30 is not set
-# CONFIG_VIDEO_OMAP2_VOUT is not set
-# CONFIG_VIDEO_OUTPUT_CONTROL is not set
-# CONFIG_VIDEO_OV7640 is not set
-# CONFIG_VIDEO_OV7670 is not set
-# CONFIG_VIDEO_PMS is not set
-# CONFIG_VIDEO_PVRUSB2 is not set
-# CONFIG_VIDEO_SAA6588 is not set
-# CONFIG_VIDEO_SAA6752HS is not set
-# CONFIG_VIDEO_SAA7110 is not set
-# CONFIG_VIDEO_SAA711X is not set
-# CONFIG_VIDEO_SAA7127 is not set
-# CONFIG_VIDEO_SAA7134 is not set
-# CONFIG_VIDEO_SAA717X is not set
-# CONFIG_VIDEO_SAA7185 is not set
-# CONFIG_VIDEO_SAA7191 is not set
-# CONFIG_VIDEO_SH_MOBILE_CEU is not set
-# CONFIG_VIDEO_SONY_BTF_MPX is not set
-# CONFIG_VIDEO_SR030PC30 is not set
-# CONFIG_VIDEO_TCM825X is not set
-# CONFIG_VIDEO_TDA7432 is not set
-# CONFIG_VIDEO_TDA9840 is not set
-# CONFIG_VIDEO_TEA6415C is not set
-# CONFIG_VIDEO_TEA6420 is not set
-# CONFIG_VIDEO_THS7303 is not set
-# CONFIG_VIDEO_THS8200 is not set
-# CONFIG_VIDEO_TIMBERDALE is not set
-# CONFIG_VIDEO_TLV320AIC23B is not set
-# CONFIG_VIDEO_TM6000 is not set
-# CONFIG_VIDEO_TVAUDIO is not set
-# CONFIG_VIDEO_TVP514X is not set
-# CONFIG_VIDEO_TVP5150 is not set
-# CONFIG_VIDEO_TVP7002 is not set
-# CONFIG_VIDEO_TW2804 is not set
-# CONFIG_VIDEO_TW9903 is not set
-# CONFIG_VIDEO_TW9906 is not set
-# CONFIG_VIDEO_UDA1342 is not set
-# CONFIG_VIDEO_UPD64031A is not set
-# CONFIG_VIDEO_UPD64083 is not set
-# CONFIG_VIDEO_USBTV is not set
-# CONFIG_VIDEO_USBVISION is not set
-# CONFIG_VIDEO_V4L2 is not set
-# CONFIG_VIDEO_V4L2_COMMON is not set
-# CONFIG_VIDEO_V4L2_INT_DEVICE is not set
-# CONFIG_VIDEO_VIVI is not set
-# CONFIG_VIDEO_VP27SMPX is not set
-# CONFIG_VIDEO_VPX3220 is not set
-# CONFIG_VIDEO_VS6624 is not set
-# CONFIG_VIDEO_WM8739 is not set
-# CONFIG_VIDEO_WM8775 is not set
-# CONFIG_VIDEO_ZORAN is not set
-# CONFIG_VIRQ_DEBUG is not set
-# CONFIG_VIRTIO_BALLOON is not set
-# CONFIG_VIRTIO_MMIO is not set
-# CONFIG_VIRTIO_PCI is not set
-# CONFIG_VIRTUALIZATION is not set
-# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
-# CONFIG_VIRT_DRIVERS is not set
-CONFIG_VIRT_TO_BUS=y
-# CONFIG_VITESSE_PHY is not set
-CONFIG_VLAN_8021Q=y
-# CONFIG_VLAN_8021Q_GVRP is not set
-# CONFIG_VLAN_8021Q_MVRP is not set
-# CONFIG_VME_BUS is not set
-# CONFIG_VMSPLIT_1G is not set
-# CONFIG_VMSPLIT_2G is not set
-# CONFIG_VMSPLIT_2G_OPT is not set
-CONFIG_VMSPLIT_3G=y
-# CONFIG_VMSPLIT_3G_OPT is not set
-# CONFIG_VMWARE_PVSCSI is not set
-# CONFIG_VMXNET3 is not set
-# CONFIG_VM_EVENT_COUNTERS is not set
-# CONFIG_VORTEX is not set
-# CONFIG_VSOCKETS is not set
-# CONFIG_VT is not set
-# CONFIG_VT6655 is not set
-# CONFIG_VT6656 is not set
-# CONFIG_VXFS_FS is not set
-# CONFIG_VXGE is not set
-# CONFIG_VXLAN is not set
-# CONFIG_W1 is not set
-# CONFIG_W1_CON is not set
-# CONFIG_W1_MASTER_DS1WM is not set
-# CONFIG_W1_MASTER_DS2482 is not set
-# CONFIG_W1_MASTER_DS2490 is not set
-# CONFIG_W1_MASTER_GPIO is not set
-# CONFIG_W1_MASTER_MATROX is not set
-# CONFIG_W1_SLAVE_BQ27000 is not set
-# CONFIG_W1_SLAVE_DS2406 is not set
-# CONFIG_W1_SLAVE_DS2408 is not set
-# CONFIG_W1_SLAVE_DS2413 is not set
-# CONFIG_W1_SLAVE_DS2423 is not set
-# CONFIG_W1_SLAVE_DS2431 is not set
-# CONFIG_W1_SLAVE_DS2433 is not set
-# CONFIG_W1_SLAVE_DS2760 is not set
-# CONFIG_W1_SLAVE_DS2780 is not set
-# CONFIG_W1_SLAVE_DS2781 is not set
-# CONFIG_W1_SLAVE_DS28E04 is not set
-# CONFIG_W1_SLAVE_SMEM is not set
-# CONFIG_W1_SLAVE_THERM is not set
-# CONFIG_W35UND is not set
-# CONFIG_W83627HF_WDT is not set
-# CONFIG_W83697HF_WDT is not set
-# CONFIG_W83877F_WDT is not set
-# CONFIG_W83977F_WDT is not set
-# CONFIG_WAN is not set
-# CONFIG_WANXL is not set
-# CONFIG_WAN_ROUTER is not set
-CONFIG_WATCHDOG=y
-# CONFIG_WATCHDOG_CORE is not set
-# CONFIG_WATCHDOG_NOWAYOUT is not set
-# CONFIG_WD80x3 is not set
-# CONFIG_WDTPCI is not set
-CONFIG_WEXT_CORE=y
-CONFIG_WEXT_PRIV=y
-CONFIG_WEXT_PROC=y
-CONFIG_WEXT_SPY=y
-CONFIG_WILINK_PLATFORM_DATA=y
-# CONFIG_WIMAX is not set
-# CONFIG_WIMAX_GDM72XX is not set
-CONFIG_WIRELESS=y
-CONFIG_WIRELESS_EXT=y
-# CONFIG_WIRELESS_EXT_SYSFS is not set
-# CONFIG_WL1251 is not set
-# CONFIG_WL12XX is not set
-# CONFIG_WL18XX is not set
-# CONFIG_WLAGS49_H2 is not set
-# CONFIG_WLAGS49_H25 is not set
-CONFIG_WLAN=y
-# CONFIG_WLCORE is not set
-CONFIG_WL_TI=y
-CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
-# CONFIG_WR_PPMC is not set
-# CONFIG_X25 is not set
-# CONFIG_X86_DEBUG_STATIC_CPU_HAS is not set
-# CONFIG_X86_PKG_TEMP_THERMAL is not set
-CONFIG_X86_SYSFB=y
-# CONFIG_XEN is not set
-CONFIG_XFRM=y
-# CONFIG_XFRM_IPCOMP is not set
-# CONFIG_XFRM_MIGRATE is not set
-# CONFIG_XFRM_STATISTICS is not set
-# CONFIG_XFRM_SUB_POLICY is not set
-# CONFIG_XFRM_USER is not set
-# CONFIG_XFS_DEBUG is not set
-# CONFIG_XFS_FS is not set
-# CONFIG_XFS_POSIX_ACL is not set
-# CONFIG_XFS_QUOTA is not set
-# CONFIG_XFS_RT is not set
-# CONFIG_XFS_WARN is not set
-# CONFIG_XILINX_AXI_EMAC is not set
-# CONFIG_XILINX_EMACLITE is not set
-# CONFIG_XILINX_LL_TEMAC is not set
-# CONFIG_XILINX_WATCHDOG is not set
-# CONFIG_XILLYBUS is not set
-# CONFIG_XIP_KERNEL is not set
-# CONFIG_XMON is not set
-# CONFIG_XVMALLOC is not set
-CONFIG_XZ_DEC=y
-# CONFIG_XZ_DEC_ARM is not set
-# CONFIG_XZ_DEC_ARMTHUMB is not set
-# CONFIG_XZ_DEC_BCJ is not set
-# CONFIG_XZ_DEC_IA64 is not set
-# CONFIG_XZ_DEC_POWERPC is not set
-# CONFIG_XZ_DEC_SPARC is not set
-# CONFIG_XZ_DEC_TEST is not set
-# CONFIG_XZ_DEC_X86 is not set
-# CONFIG_YAM is not set
-# CONFIG_YELLOWFIN is not set
-# CONFIG_YENTA is not set
-# CONFIG_YENTA_O2 is not set
-# CONFIG_YENTA_RICOH is not set
-# CONFIG_YENTA_TI is not set
-# CONFIG_YENTA_TOSHIBA is not set
-# CONFIG_ZBUD is not set
-# CONFIG_ZD1211RW is not set
-# CONFIG_ZD1211RW_DEBUG is not set
-# CONFIG_ZEROPLUS_FF is not set
-# CONFIG_ZISOFS is not set
-# CONFIG_ZLIB_DEFLATE is not set
-# CONFIG_ZLIB_INFLATE is not set
-# CONFIG_ZNET is not set
-CONFIG_ZONE_DMA=y
-CONFIG_ZONE_DMA_FLAG=1
-# CONFIG_ZPOOL is not set
-# CONFIG_ZRAM is not set
-# CONFIG_ZRAM_LZ4_COMPRESS is not set
-# CONFIG_ZSMALLOC is not set
--- a/target/linux/generic/config-4.14	2022-03-22 08:54:47.124464531 +0800
+++ b/target/linux/generic/config-4.14	2022-03-22 12:15:54.066429369 +0800
@@ -1,3 +1,4 @@
+# CONFIG_104_QUAD_8 is not set
 CONFIG_32BIT=y
 # CONFIG_6LOWPAN is not set
 # CONFIG_6LOWPAN_DEBUGFS is not set
@@ -284,6 +285,7 @@
 # CONFIG_ARM64_ERRATUM_845719 is not set
 # CONFIG_ARM64_ERRATUM_858921 is not set
 # CONFIG_ARM64_RELOC_TEST is not set
+CONFIG_ARM64_SW_TTBR0_PAN=y
 # CONFIG_ARM_APPENDED_DTB is not set
 # CONFIG_ARM_ARCH_TIMER is not set
 # CONFIG_ARM_BIG_LITTLE_CPUFREQ is not set
@@ -428,6 +430,7 @@
 # CONFIG_BACKLIGHT_LV5207LP is not set
 # CONFIG_BACKLIGHT_PANDORA is not set
 # CONFIG_BACKLIGHT_PM8941_WLED is not set
+# CONFIG_BACKLIGHT_PWM is not set
 # CONFIG_BACKLIGHT_RPI is not set
 # CONFIG_BACKLIGHT_SAHARA is not set
 # CONFIG_BACKTRACE_SELF_TEST is not set
@@ -446,6 +449,7 @@
 # CONFIG_BATTERY_MAX17040 is not set
 # CONFIG_BATTERY_MAX17042 is not set
 # CONFIG_BATTERY_MAX1721X is not set
+# CONFIG_BATTERY_RT5033 is not set
 # CONFIG_BATTERY_SBS is not set
 # CONFIG_BAYCOM_EPP is not set
 # CONFIG_BAYCOM_PAR is not set
@@ -593,7 +597,7 @@
 # CONFIG_BOOT_PRINTK_DELAY is not set
 CONFIG_BOOT_RAW=y
 CONFIG_BPF=y
-# CONFIG_BPF_JIT is not set
+CONFIG_BPF_JIT=y
 # CONFIG_BPF_JIT_ALWAYS_ON is not set
 # CONFIG_BPF_STREAM_PARSER is not set
 CONFIG_BPF_SYSCALL=y
@@ -726,11 +730,13 @@
 # CONFIG_CDROM_PKTCDVD is not set
 # CONFIG_CEPH_FS is not set
 # CONFIG_CEPH_LIB is not set
+# CONFIG_CFQ_GROUP_IOSCHED is not set
 # CONFIG_CFG80211 is not set
 # CONFIG_CFG80211_CERTIFICATION_ONUS is not set
 # CONFIG_CGROUPS is not set
 # CONFIG_CGROUP_BPF is not set
 # CONFIG_CGROUP_DEBUG is not set
+# CONFIG_CGROUP_HUGETLB is not set
 # CONFIG_CGROUP_NET_CLASSID is not set
 # CONFIG_CGROUP_NET_PRIO is not set
 # CONFIG_CGROUP_RDMA is not set
@@ -763,6 +769,7 @@
 # CONFIG_CICADA_PHY is not set
 # CONFIG_CIFS is not set
 # CONFIG_CIFS_ACL is not set
+CONFIG_CIFS_ALLOW_INSECURE_LEGACY=y
 # CONFIG_CIFS_DEBUG is not set
 # CONFIG_CIFS_DEBUG2 is not set
 # CONFIG_CIFS_FSCACHE is not set
@@ -815,6 +822,7 @@
 # CONFIG_COMMON_CLK_XLNX_CLKWZRD is not set
 CONFIG_COMPACTION=y
 # CONFIG_COMPAL_LAPTOP is not set
+# CONFIG_COMPAT is not set
 # CONFIG_COMPAT_BRK is not set
 # CONFIG_COMPILE_TEST is not set
 # CONFIG_CONFIGFS_FS is not set
@@ -897,6 +905,8 @@
 # CONFIG_CRYPTO_DEFLATE is not set
 # CONFIG_CRYPTO_DES is not set
 # CONFIG_CRYPTO_DEV_ATMEL_AES is not set
+# CONFIG_CRYPTO_DEV_ATMEL_AUTHENC is not set
+# CONFIG_CRYPTO_DEV_ATMEL_ECC is not set
 # CONFIG_CRYPTO_DEV_ATMEL_SHA is not set
 # CONFIG_CRYPTO_DEV_ATMEL_TDES is not set
 # CONFIG_CRYPTO_DEV_CAVIUM_ZIP is not set
@@ -1046,12 +1056,10 @@
 # CONFIG_DEBUG_PINCTRL is not set
 # CONFIG_DEBUG_PI_LIST is not set
 # CONFIG_DEBUG_PREEMPT is not set
-# CONFIG_DEBUG_RODATA is not set
 # CONFIG_DEBUG_RODATA_TEST is not set
 # CONFIG_DEBUG_RT_MUTEXES is not set
 # CONFIG_DEBUG_SECTION_MISMATCH is not set
 # CONFIG_DEBUG_SEMIHOSTING is not set
-# CONFIG_DEBUG_SET_MODULE_RONX is not set
 # CONFIG_DEBUG_SG is not set
 # CONFIG_DEBUG_SHIRQ is not set
 # CONFIG_DEBUG_SLAB is not set
@@ -1119,6 +1127,7 @@
 # CONFIG_DMA_API_DEBUG is not set
 # CONFIG_DMA_ENGINE is not set
 # CONFIG_DMA_FENCE_TRACE is not set
+# CONFIG_DMA_JZ4780 is not set
 # CONFIG_DMA_NOOP_OPS is not set
 # CONFIG_DMA_SHARED_BUFFER is not set
 # CONFIG_DMA_VIRT_OPS is not set
@@ -1142,6 +1151,7 @@
 # CONFIG_DNOTIFY is not set
 # CONFIG_DNS_RESOLVER is not set
 CONFIG_DOUBLEFAULT=y
+# CONFIG_DP83640_PHY is not set
 # CONFIG_DP83848_PHY is not set
 # CONFIG_DP83867_PHY is not set
 # CONFIG_DPOT_DAC is not set
@@ -1149,6 +1159,11 @@
 # CONFIG_DRAGONRISE_FF is not set
 # CONFIG_DRM is not set
 # CONFIG_DRM_AMDGPU is not set
+# CONFIG_DRM_AMDGPU_CIK is not set
+# CONFIG_DRM_AMDGPU_GART_DEBUGFS is not set
+# CONFIG_DRM_AMDGPU_SI is not set
+# CONFIG_DRM_AMDGPU_USERPTR is not set
+# CONFIG_DRM_AMD_ACP is not set
 # CONFIG_DRM_ANALOGIX_ANX78XX is not set
 # CONFIG_DRM_ARCPGU is not set
 # CONFIG_DRM_ARMADA is not set
@@ -1164,6 +1179,7 @@
 # CONFIG_DRM_EXYNOS is not set
 # CONFIG_DRM_FBDEV_EMULATION is not set
 # CONFIG_DRM_FSL_DCU is not set
+# CONFIG_DRM_GMA500 is not set
 # CONFIG_DRM_HDLCD is not set
 # CONFIG_DRM_HISI_HIBMC is not set
 # CONFIG_DRM_HISI_KIRIN is not set
@@ -1171,6 +1187,7 @@
 # CONFIG_DRM_I2C_CH7006 is not set
 # CONFIG_DRM_I2C_NXP_TDA998X is not set
 # CONFIG_DRM_I2C_SIL164 is not set
+# CONFIG_DRM_I915 is not set
 # CONFIG_DRM_LEGACY is not set
 # CONFIG_DRM_LIB_RANDOM is not set
 # CONFIG_DRM_LOAD_EDID_FIRMWARE is not set
@@ -1198,11 +1215,13 @@
 # CONFIG_DRM_PL111 is not set
 # CONFIG_DRM_QXL is not set
 # CONFIG_DRM_RADEON is not set
+# CONFIG_DRM_RADEON_USERPTR is not set
 # CONFIG_DRM_RCAR_DW_HDMI is not set
 # CONFIG_DRM_SII902X is not set
 # CONFIG_DRM_SIL_SII8620 is not set
 # CONFIG_DRM_STI is not set
 # CONFIG_DRM_STM is not set
+# CONFIG_DRM_SUN4I is not set
 # CONFIG_DRM_TILCDC is not set
 # CONFIG_DRM_TINYDRM is not set
 # CONFIG_DRM_TI_TFP410 is not set
@@ -1210,6 +1229,8 @@
 # CONFIG_DRM_UDL is not set
 # CONFIG_DRM_VBOXVIDEO is not set
 # CONFIG_DRM_VGEM is not set
+# CONFIG_DRM_VIRTIO_GPU is not set
+# CONFIG_DRM_VMWGFX is not set
 # CONFIG_DS1682 is not set
 # CONFIG_DS1803 is not set
 # CONFIG_DST_CACHE is not set
@@ -1340,6 +1361,7 @@
 # CONFIG_FB_CYBER2000 is not set
 # CONFIG_FB_DA8XX is not set
 # CONFIG_FB_DDC is not set
+# CONFIG_FB_FLEX is not set
 # CONFIG_FB_FOREIGN_ENDIAN is not set
 # CONFIG_FB_GEODE is not set
 # CONFIG_FB_GOLDFISH is not set
@@ -1385,6 +1407,39 @@
 # CONFIG_FB_SYS_FOPS is not set
 # CONFIG_FB_SYS_IMAGEBLIT is not set
 # CONFIG_FB_TFT is not set
+# CONFIG_FB_TFT_AGM1264K_FL is not set
+# CONFIG_FB_TFT_BD663474 is not set
+# CONFIG_FB_TFT_FBTFT_DEVICE is not set
+# CONFIG_FB_TFT_HX8340BN is not set
+# CONFIG_FB_TFT_HX8347D is not set
+# CONFIG_FB_TFT_HX8353D is not set
+# CONFIG_FB_TFT_HX8357D is not set
+# CONFIG_FB_TFT_ILI9163 is not set
+# CONFIG_FB_TFT_ILI9320 is not set
+# CONFIG_FB_TFT_ILI9325 is not set
+# CONFIG_FB_TFT_ILI9340 is not set
+# CONFIG_FB_TFT_ILI9341 is not set
+# CONFIG_FB_TFT_ILI9481 is not set
+# CONFIG_FB_TFT_ILI9486 is not set
+# CONFIG_FB_TFT_PCD8544 is not set
+# CONFIG_FB_TFT_RA8875 is not set
+# CONFIG_FB_TFT_S6D02A1 is not set
+# CONFIG_FB_TFT_S6D1121 is not set
+# CONFIG_FB_TFT_SH1106 is not set
+# CONFIG_FB_TFT_SSD1289 is not set
+# CONFIG_FB_TFT_SSD1305 is not set
+# CONFIG_FB_TFT_SSD1306 is not set
+# CONFIG_FB_TFT_SSD1325 is not set
+# CONFIG_FB_TFT_SSD1331 is not set
+# CONFIG_FB_TFT_SSD1351 is not set
+# CONFIG_FB_TFT_ST7735R is not set
+# CONFIG_FB_TFT_ST7789V is not set
+# CONFIG_FB_TFT_TINYLCD is not set
+# CONFIG_FB_TFT_TLS8204 is not set
+# CONFIG_FB_TFT_UC1611 is not set
+# CONFIG_FB_TFT_UC1701 is not set
+# CONFIG_FB_TFT_UPD161704 is not set
+# CONFIG_FB_TFT_WATTEROTT is not set
 # CONFIG_FB_TILEBLITTING is not set
 # CONFIG_FB_TMIO is not set
 # CONFIG_FB_TRIDENT is not set
@@ -1545,7 +1600,8 @@
 # CONFIG_HAMACHI is not set
 # CONFIG_HAMRADIO is not set
 # CONFIG_HAPPYMEAL is not set
-# CONFIG_HARDENED_USERCOPY is not set
+CONFIG_HARDENED_USERCOPY=y
+# CONFIG_HARDENED_USERCOPY_PAGESPAN is not set
 # CONFIG_HARDLOCKUP_DETECTOR is not set
 # CONFIG_HAVE_AOUT is not set
 CONFIG_HAVE_ARCH_HARDENED_USERCOPY=y
@@ -1719,6 +1775,7 @@
 # CONFIG_HW_RANDOM_GEODE is not set
 # CONFIG_HW_RANDOM_INTEL is not set
 # CONFIG_HW_RANDOM_IPROC_RNG200 is not set
+# CONFIG_HW_RANDOM_OMAP is not set
 # CONFIG_HW_RANDOM_OMAP3_ROM is not set
 # CONFIG_HW_RANDOM_PPC4XX is not set
 # CONFIG_HW_RANDOM_TIMERIOMEM is not set
@@ -2233,6 +2290,7 @@
 # CONFIG_KEYBOARD_SUNKBD is not set
 # CONFIG_KEYBOARD_TCA6416 is not set
 # CONFIG_KEYBOARD_TCA8418 is not set
+# CONFIG_KEYBOARD_TEGRA is not set
 # CONFIG_KEYBOARD_TM2_TOUCHKEY is not set
 # CONFIG_KEYBOARD_TWL4030 is not set
 # CONFIG_KEYBOARD_XTKBD is not set
@@ -2595,6 +2653,7 @@
 # CONFIG_MIGRATION is not set
 CONFIG_MII=y
 # CONFIG_MIKROTIK_RB532 is not set
+# CONFIG_MIKROTIK is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_MINIX_FS_NATIVE_ENDIAN is not set
 # CONFIG_MINIX_SUBPARTITION is not set
@@ -3327,7 +3386,7 @@
 # CONFIG_OPROFILE is not set
 # CONFIG_OPROFILE_EVENT_MULTIPLEX is not set
 # CONFIG_OPT3001 is not set
-# CONFIG_OPTIMIZE_INLINING is not set
+CONFIG_OPTIMIZE_INLINING=y
 # CONFIG_ORANGEFS_FS is not set
 # CONFIG_ORION_WATCHDOG is not set
 # CONFIG_OSF_PARTITION is not set
@@ -4035,6 +4094,7 @@
 # CONFIG_SENSORS_ADM1026 is not set
 # CONFIG_SENSORS_ADM1029 is not set
 # CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM1275 is not set
 # CONFIG_SENSORS_ADM9240 is not set
 # CONFIG_SENSORS_ADS1015 is not set
 # CONFIG_SENSORS_ADS7828 is not set
@@ -4083,10 +4143,12 @@
 # CONFIG_SENSORS_HTU21 is not set
 # CONFIG_SENSORS_I5500 is not set
 # CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_IBM_CFFPS is not set
 # CONFIG_SENSORS_IIO_HWMON is not set
 # CONFIG_SENSORS_INA209 is not set
 # CONFIG_SENSORS_INA2XX is not set
 # CONFIG_SENSORS_INA3221 is not set
+# CONFIG_SENSORS_IR35221 is not set
 # CONFIG_SENSORS_ISL29018 is not set
 # CONFIG_SENSORS_ISL29028 is not set
 # CONFIG_SENSORS_IT87 is not set
@@ -4097,6 +4159,7 @@
 # CONFIG_SENSORS_LIS3LV02D is not set
 # CONFIG_SENSORS_LIS3_I2C is not set
 # CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LM25066 is not set
 # CONFIG_SENSORS_LM63 is not set
 # CONFIG_SENSORS_LM70 is not set
 # CONFIG_SENSORS_LM73 is not set
@@ -4114,7 +4177,9 @@
 # CONFIG_SENSORS_LM95241 is not set
 # CONFIG_SENSORS_LM95245 is not set
 # CONFIG_SENSORS_LTC2945 is not set
+# CONFIG_SENSORS_LTC2978 is not set
 # CONFIG_SENSORS_LTC2990 is not set
+# CONFIG_SENSORS_LTC3815 is not set
 # CONFIG_SENSORS_LTC4151 is not set
 # CONFIG_SENSORS_LTC4215 is not set
 # CONFIG_SENSORS_LTC4222 is not set
@@ -4122,16 +4187,20 @@
 # CONFIG_SENSORS_LTC4260 is not set
 # CONFIG_SENSORS_LTC4261 is not set
 # CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX16064 is not set
 # CONFIG_SENSORS_MAX16065 is not set
 # CONFIG_SENSORS_MAX1619 is not set
 # CONFIG_SENSORS_MAX1668 is not set
 # CONFIG_SENSORS_MAX197 is not set
+# CONFIG_SENSORS_MAX20751 is not set
 # CONFIG_SENSORS_MAX31722 is not set
 # CONFIG_SENSORS_MAX31790 is not set
+# CONFIG_SENSORS_MAX34440 is not set
 # CONFIG_SENSORS_MAX6639 is not set
 # CONFIG_SENSORS_MAX6642 is not set
 # CONFIG_SENSORS_MAX6650 is not set
 # CONFIG_SENSORS_MAX6697 is not set
+# CONFIG_SENSORS_MAX8688 is not set
 # CONFIG_SENSORS_MCP3021 is not set
 # CONFIG_SENSORS_NCT6683 is not set
 # CONFIG_SENSORS_NCT6775 is not set
@@ -4142,6 +4211,7 @@
 # CONFIG_SENSORS_PC87360 is not set
 # CONFIG_SENSORS_PC87427 is not set
 # CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_PMBUS is not set
 # CONFIG_SENSORS_POWR1220 is not set
 # CONFIG_SENSORS_PWM_FAN is not set
 # CONFIG_SENSORS_SCH5627 is not set
@@ -4165,8 +4235,12 @@
 # CONFIG_SENSORS_TMP108 is not set
 # CONFIG_SENSORS_TMP401 is not set
 # CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_TPS40422 is not set
+# CONFIG_SENSORS_TPS53679 is not set
 # CONFIG_SENSORS_TSL2550 is not set
 # CONFIG_SENSORS_TSL2563 is not set
+# CONFIG_SENSORS_UCD9000 is not set
+# CONFIG_SENSORS_UCD9200 is not set
 # CONFIG_SENSORS_VEXPRESS is not set
 # CONFIG_SENSORS_VIA686A is not set
 # CONFIG_SENSORS_VIA_CPUTEMP is not set
@@ -4182,6 +4256,7 @@
 # CONFIG_SENSORS_W83L785TS is not set
 # CONFIG_SENSORS_W83L786NG is not set
 # CONFIG_SENSORS_XGENE is not set
+# CONFIG_SENSORS_ZL6100 is not set
 CONFIG_SERIAL_8250=y
 # CONFIG_SERIAL_8250_ACCENT is not set
 # CONFIG_SERIAL_8250_ASPEED_VUART is not set
@@ -4924,6 +4999,7 @@
 # CONFIG_TOPSTAR_LAPTOP is not set
 # CONFIG_TORTURE_TEST is not set
 # CONFIG_TOSHIBA_HAPS is not set
+# CONFIG_TOUCHSCREEN_88PM860X is not set
 # CONFIG_TOUCHSCREEN_AD7877 is not set
 # CONFIG_TOUCHSCREEN_AD7879 is not set
 # CONFIG_TOUCHSCREEN_AD7879_I2C is not set
@@ -4931,12 +5007,20 @@
 # CONFIG_TOUCHSCREEN_ADS7846 is not set
 # CONFIG_TOUCHSCREEN_AR1021_I2C is not set
 # CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT_T37 is not set
 # CONFIG_TOUCHSCREEN_AUO_PIXCIR is not set
 # CONFIG_TOUCHSCREEN_BU21013 is not set
 # CONFIG_TOUCHSCREEN_CHIPONE_ICN8318 is not set
+# CONFIG_TOUCHSCREEN_COLIBRI_VF50 is not set
 # CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
 # CONFIG_TOUCHSCREEN_CYTTSP4_CORE is not set
+# CONFIG_TOUCHSCREEN_CYTTSP4_I2C is not set
+# CONFIG_TOUCHSCREEN_CYTTSP4_SPI is not set
 # CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_I2C is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_SPI is not set
+# CONFIG_TOUCHSCREEN_DA9034 is not set
+# CONFIG_TOUCHSCREEN_DA9052 is not set
 # CONFIG_TOUCHSCREEN_DYNAPRO is not set
 # CONFIG_TOUCHSCREEN_EDT_FT5X06 is not set
 # CONFIG_TOUCHSCREEN_EETI is not set
@@ -4945,22 +5029,33 @@
 # CONFIG_TOUCHSCREEN_EKTF2127 is not set
 # CONFIG_TOUCHSCREEN_ELAN is not set
 # CONFIG_TOUCHSCREEN_ELO is not set
-# CONFIG_TOUCHSCREEN_FT6236 is not set
 # CONFIG_TOUCHSCREEN_FUJITSU is not set
 # CONFIG_TOUCHSCREEN_GOODIX is not set
 # CONFIG_TOUCHSCREEN_GUNZE is not set
 # CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_HP600 is not set
+# CONFIG_TOUCHSCREEN_HP7XX is not set
+# CONFIG_TOUCHSCREEN_HTCPEN is not set
 # CONFIG_TOUCHSCREEN_ILI210X is not set
 # CONFIG_TOUCHSCREEN_IMX6UL_TSC is not set
 # CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_IPAQ_MICRO is not set
+# CONFIG_TOUCHSCREEN_IPROC is not set
+# CONFIG_TOUCHSCREEN_LPC32XX is not set
 # CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MC13783 is not set
 # CONFIG_TOUCHSCREEN_MCS5000 is not set
 # CONFIG_TOUCHSCREEN_MELFAS_MIP4 is not set
+# CONFIG_TOUCHSCREEN_MIGOR is not set
 # CONFIG_TOUCHSCREEN_MK712 is not set
 # CONFIG_TOUCHSCREEN_MMS114 is not set
 # CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_MX25 is not set
+# CONFIG_TOUCHSCREEN_MXS_LRADC is not set
+# CONFIG_TOUCHSCREEN_PCAP is not set
 # CONFIG_TOUCHSCREEN_PENMOUNT is not set
 # CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_PROPERTIES is not set
 # CONFIG_TOUCHSCREEN_RM_TS is not set
 # CONFIG_TOUCHSCREEN_ROHM_BU21023 is not set
 # CONFIG_TOUCHSCREEN_S3C2410 is not set
@@ -4968,24 +5063,55 @@
 # CONFIG_TOUCHSCREEN_SIS_I2C is not set
 # CONFIG_TOUCHSCREEN_ST1232 is not set
 # CONFIG_TOUCHSCREEN_STMFTS is not set
+# CONFIG_TOUCHSCREEN_STMPE is not set
+# CONFIG_TOUCHSCREEN_SUN4I is not set
 # CONFIG_TOUCHSCREEN_SUR40 is not set
 # CONFIG_TOUCHSCREEN_SURFACE3_SPI is not set
 # CONFIG_TOUCHSCREEN_SX8654 is not set
-# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4 is not set
+# CONFIG_TOUCHSCREEN_TI_AM335X_TSC is not set
 # CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
 # CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
 # CONFIG_TOUCHSCREEN_TOUCHWIN is not set
 # CONFIG_TOUCHSCREEN_TPS6507X is not set
+# CONFIG_TOUCHSCREEN_TS4800 is not set
 # CONFIG_TOUCHSCREEN_TSC2004 is not set
 # CONFIG_TOUCHSCREEN_TSC2005 is not set
 # CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_TSC2007_IIO is not set
+# CONFIG_TOUCHSCREEN_TSC200X_CORE is not set
 # CONFIG_TOUCHSCREEN_TSC_SERIO is not set
+# CONFIG_TOUCHSCREEN_UCB1400 is not set
+# CONFIG_TOUCHSCREEN_USB_3M is not set
 # CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_USB_DMC_TSC10 is not set
+# CONFIG_TOUCHSCREEN_USB_E2I is not set
+# CONFIG_TOUCHSCREEN_USB_EASYTOUCH is not set
+# CONFIG_TOUCHSCREEN_USB_EGALAX is not set
+# CONFIG_TOUCHSCREEN_USB_ELO is not set
+# CONFIG_TOUCHSCREEN_USB_ETT_TC45USB is not set
+# CONFIG_TOUCHSCREEN_USB_ETURBO is not set
+# CONFIG_TOUCHSCREEN_USB_GENERAL_TOUCH is not set
+# CONFIG_TOUCHSCREEN_USB_GOTOP is not set
+# CONFIG_TOUCHSCREEN_USB_GUNZE is not set
+# CONFIG_TOUCHSCREEN_USB_IDEALTEK is not set
+# CONFIG_TOUCHSCREEN_USB_IRTOUCH is not set
+# CONFIG_TOUCHSCREEN_USB_ITM is not set
+# CONFIG_TOUCHSCREEN_USB_JASTEC is not set
+# CONFIG_TOUCHSCREEN_USB_NEXIO is not set
+# CONFIG_TOUCHSCREEN_USB_PANJIT is not set
+# CONFIG_TOUCHSCREEN_USB_ZYTRONIC is not set
 # CONFIG_TOUCHSCREEN_W90X900 is not set
 # CONFIG_TOUCHSCREEN_WACOM_I2C is not set
 # CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
 # CONFIG_TOUCHSCREEN_WDT87XX_I2C is not set
+# CONFIG_TOUCHSCREEN_WM831X is not set
+# CONFIG_TOUCHSCREEN_WM9705 is not set
+# CONFIG_TOUCHSCREEN_WM9712 is not set
+# CONFIG_TOUCHSCREEN_WM9713 is not set
 # CONFIG_TOUCHSCREEN_WM97XX is not set
+# CONFIG_TOUCHSCREEN_WM97XX_ATMEL is not set
+# CONFIG_TOUCHSCREEN_WM97XX_MAINSTONE is not set
+# CONFIG_TOUCHSCREEN_WM97XX_ZYLONITE is not set
 # CONFIG_TOUCHSCREEN_ZET6223 is not set
 # CONFIG_TOUCHSCREEN_ZFORCE is not set
 # CONFIG_TPL0102 is not set
@@ -5048,7 +5174,7 @@
 # CONFIG_UNIX_DIAG is not set
 # CONFIG_UNUSED_SYMBOLS is not set
 # CONFIG_UPROBES is not set
-# CONFIG_UPROBE_EVENT is not set
+# CONFIG_UPROBE_EVENTS is not set
 # CONFIG_US5182D is not set
 # CONFIG_USB is not set
 # CONFIG_USBIP_CORE is not set
@@ -5189,6 +5315,7 @@
 # CONFIG_USB_HUB_USB251XB is not set
 # CONFIG_USB_HWA_HCD is not set
 # CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_IMX21_HCD is not set
 # CONFIG_USB_IOWARRIOR is not set
 # CONFIG_USB_IPHETH is not set
 # CONFIG_USB_ISIGHTFW is not set
@@ -5386,6 +5513,7 @@
 # CONFIG_USB_WUSB is not set
 # CONFIG_USB_WUSB_CBAF is not set
 # CONFIG_USB_XHCI_HCD is not set
+# CONFIG_USB_XHCI_TEGRA is not set
 # CONFIG_USB_XUSBATM is not set
 # CONFIG_USB_YUREX is not set
 # CONFIG_USB_ZD1201 is not set
@@ -5612,6 +5740,7 @@
 # CONFIG_X25 is not set
 # CONFIG_X509_CERTIFICATE_PARSER is not set
 # CONFIG_X86_DEBUG_STATIC_CPU_HAS is not set
+# CONFIG_X86_DECODER_SELFTEST is not set
 # CONFIG_X86_PKG_TEMP_THERMAL is not set
 CONFIG_X86_SYSFB=y
 # CONFIG_XEN is not set
@@ -5667,4 +5796,3 @@
 # CONFIG_ZRAM is not set
 # CONFIG_ZSMALLOC is not set
 # CONFIG_ZX_TDM is not set
-# CONFIG_NET_ACT_CTINFO is not set
--- a/target/linux/generic/config-4.19	2022-03-22 08:54:47.131464543 +0800
+++ b/target/linux/generic/config-4.19	1970-01-01 08:00:00.000000000 +0800
@@ -1,6099 +0,0 @@
-# CONFIG_104_QUAD_8 is not set
-CONFIG_32BIT=y
-# CONFIG_6LOWPAN is not set
-# CONFIG_6LOWPAN_DEBUGFS is not set
-# CONFIG_6PACK is not set
-# CONFIG_8139CP is not set
-# CONFIG_8139TOO is not set
-# CONFIG_9P_FS is not set
-# CONFIG_AB3100_CORE is not set
-# CONFIG_AB8500_CORE is not set
-# CONFIG_ABP060MG is not set
-# CONFIG_ABX500_CORE is not set
-# CONFIG_ACCESSIBILITY is not set
-# CONFIG_ACENIC is not set
-# CONFIG_ACERHDF is not set
-# CONFIG_ACER_WIRELESS is not set
-# CONFIG_ACORN_PARTITION is not set
-# CONFIG_ACPI_ALS is not set
-# CONFIG_ACPI_APEI is not set
-# CONFIG_ACPI_BUTTON is not set
-# CONFIG_ACPI_CONFIGFS is not set
-# CONFIG_ACPI_CUSTOM_METHOD is not set
-# CONFIG_ACPI_EXTLOG is not set
-# CONFIG_ACPI_HED is not set
-# CONFIG_ACPI_NFIT is not set
-# CONFIG_ACPI_REDUCED_HARDWARE_ONLY is not set
-# CONFIG_ACPI_TABLE_UPGRADE is not set
-# CONFIG_ACPI_VIDEO is not set
-# CONFIG_AD2S1200 is not set
-# CONFIG_AD2S1210 is not set
-# CONFIG_AD2S90 is not set
-# CONFIG_AD5064 is not set
-# CONFIG_AD525X_DPOT is not set
-# CONFIG_AD5272 is not set
-# CONFIG_AD5360 is not set
-# CONFIG_AD5380 is not set
-# CONFIG_AD5421 is not set
-# CONFIG_AD5446 is not set
-# CONFIG_AD5449 is not set
-# CONFIG_AD5504 is not set
-# CONFIG_AD5592R is not set
-# CONFIG_AD5593R is not set
-# CONFIG_AD5624R_SPI is not set
-# CONFIG_AD5686 is not set
-# CONFIG_AD5686_SPI is not set
-# CONFIG_AD5696_I2C is not set
-# CONFIG_AD5755 is not set
-# CONFIG_AD5758 is not set
-# CONFIG_AD5761 is not set
-# CONFIG_AD5764 is not set
-# CONFIG_AD5791 is not set
-# CONFIG_AD5933 is not set
-# CONFIG_AD7150 is not set
-# CONFIG_AD7152 is not set
-# CONFIG_AD7192 is not set
-# CONFIG_AD7266 is not set
-# CONFIG_AD7280 is not set
-# CONFIG_AD7291 is not set
-# CONFIG_AD7298 is not set
-# CONFIG_AD7303 is not set
-# CONFIG_AD7476 is not set
-# CONFIG_AD7606 is not set
-# CONFIG_AD7746 is not set
-# CONFIG_AD7766 is not set
-# CONFIG_AD7780 is not set
-# CONFIG_AD7791 is not set
-# CONFIG_AD7793 is not set
-# CONFIG_AD7816 is not set
-# CONFIG_AD7887 is not set
-# CONFIG_AD7923 is not set
-# CONFIG_AD799X is not set
-# CONFIG_AD8366 is not set
-# CONFIG_AD8801 is not set
-# CONFIG_AD9523 is not set
-# CONFIG_AD9832 is not set
-# CONFIG_AD9834 is not set
-# CONFIG_ADAPTEC_STARFIRE is not set
-# CONFIG_ADE7753 is not set
-# CONFIG_ADE7754 is not set
-# CONFIG_ADE7758 is not set
-# CONFIG_ADE7759 is not set
-# CONFIG_ADE7854 is not set
-# CONFIG_ADF4350 is not set
-# CONFIG_ADFS_FS is not set
-# CONFIG_ADIS16060 is not set
-# CONFIG_ADIS16080 is not set
-# CONFIG_ADIS16130 is not set
-# CONFIG_ADIS16136 is not set
-# CONFIG_ADIS16201 is not set
-# CONFIG_ADIS16203 is not set
-# CONFIG_ADIS16204 is not set
-# CONFIG_ADIS16209 is not set
-# CONFIG_ADIS16220 is not set
-# CONFIG_ADIS16240 is not set
-# CONFIG_ADIS16260 is not set
-# CONFIG_ADIS16400 is not set
-# CONFIG_ADIS16480 is not set
-# CONFIG_ADJD_S311 is not set
-# CONFIG_ADM6996_PHY is not set
-# CONFIG_ADM8211 is not set
-# CONFIG_ADT7316 is not set
-CONFIG_ADVISE_SYSCALLS=y
-# CONFIG_ADXL345_I2C is not set
-# CONFIG_ADXL345_SPI is not set
-# CONFIG_ADXRS450 is not set
-CONFIG_AEABI=y
-# CONFIG_AFE4403 is not set
-# CONFIG_AFE4404 is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_AFS_FS is not set
-# CONFIG_AF_KCM is not set
-# CONFIG_AF_RXRPC is not set
-# CONFIG_AF_RXRPC_INJECT_LOSS is not set
-# CONFIG_AF_RXRPC_IPV6 is not set
-# CONFIG_AGP is not set
-# CONFIG_AHCI_CEVA is not set
-# CONFIG_AHCI_IMX is not set
-# CONFIG_AHCI_MVEBU is not set
-# CONFIG_AHCI_QORIQ is not set
-CONFIG_AIO=y
-# CONFIG_AIRO is not set
-# CONFIG_AIRO_CS is not set
-# CONFIG_AIX_PARTITION is not set
-# CONFIG_AK09911 is not set
-# CONFIG_AK8974 is not set
-# CONFIG_AK8975 is not set
-# CONFIG_AL3320A is not set
-# CONFIG_ALIM7101_WDT is not set
-CONFIG_ALLOW_DEV_COREDUMP=y
-# CONFIG_ALTERA_MBOX is not set
-# CONFIG_ALTERA_MSGDMA is not set
-# CONFIG_ALTERA_STAPL is not set
-# CONFIG_ALTERA_TSE is not set
-# CONFIG_ALX is not set
-# CONFIG_AM2315 is not set
-# CONFIG_AM335X_PHY_USB is not set
-# CONFIG_AMBA_PL08X is not set
-# CONFIG_AMD8111_ETH is not set
-# CONFIG_AMD_MEM_ENCRYPT is not set
-# CONFIG_AMD_PHY is not set
-# CONFIG_AMD_XGBE is not set
-# CONFIG_AMD_XGBE_HAVE_ECC is not set
-# CONFIG_AMIGA_PARTITION is not set
-# CONFIG_AMILO_RFKILL is not set
-# CONFIG_ANDROID is not set
-CONFIG_ANON_INODES=y
-# CONFIG_APDS9300 is not set
-# CONFIG_APDS9802ALS is not set
-# CONFIG_APDS9960 is not set
-# CONFIG_APM8018X is not set
-# CONFIG_APM_EMULATION is not set
-# CONFIG_APPLE_GMUX is not set
-# CONFIG_APPLE_PROPERTIES is not set
-# CONFIG_APPLICOM is not set
-# CONFIG_AQTION is not set
-# CONFIG_AQUANTIA_PHY is not set
-# CONFIG_AR5523 is not set
-# CONFIG_AR7 is not set
-# CONFIG_AR8216_PHY is not set
-# CONFIG_AR8216_PHY_LEDS is not set
-# CONFIG_ARCH_ACTIONS is not set
-# CONFIG_ARCH_ALPINE is not set
-# CONFIG_ARCH_ARTPEC is not set
-# CONFIG_ARCH_ASPEED is not set
-# CONFIG_ARCH_AT91 is not set
-# CONFIG_ARCH_BCM is not set
-# CONFIG_ARCH_BCM2835 is not set
-# CONFIG_ARCH_BCM_21664 is not set
-# CONFIG_ARCH_BCM_23550 is not set
-# CONFIG_ARCH_BCM_281XX is not set
-# CONFIG_ARCH_BCM_5301X is not set
-# CONFIG_ARCH_BCM_53573 is not set
-# CONFIG_ARCH_BCM_63XX is not set
-# CONFIG_ARCH_BCM_CYGNUS is not set
-# CONFIG_ARCH_BCM_IPROC is not set
-# CONFIG_ARCH_BCM_NSP is not set
-# CONFIG_ARCH_BERLIN is not set
-# CONFIG_ARCH_BRCMSTB is not set
-# CONFIG_ARCH_CLPS711X is not set
-# CONFIG_ARCH_CNS3XXX is not set
-# CONFIG_ARCH_DAVINCI is not set
-# CONFIG_ARCH_DIGICOLOR is not set
-# CONFIG_ARCH_DMA_ADDR_T_64BIT is not set
-# CONFIG_ARCH_DOVE is not set
-# CONFIG_ARCH_EBSA110 is not set
-# CONFIG_ARCH_EP93XX is not set
-# CONFIG_ARCH_EXYNOS is not set
-CONFIG_ARCH_FLATMEM_ENABLE=y
-# CONFIG_ARCH_FOOTBRIDGE is not set
-# CONFIG_ARCH_GEMINI is not set
-CONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED=y
-# CONFIG_ARCH_HAS_ILOG2_U32 is not set
-# CONFIG_ARCH_HAS_ILOG2_U64 is not set
-CONFIG_ARCH_HAS_UBSAN_SANITIZE_ALL=y
-# CONFIG_ARCH_HI3xxx is not set
-# CONFIG_ARCH_HIGHBANK is not set
-# CONFIG_ARCH_HISI is not set
-# CONFIG_ARCH_INTEGRATOR is not set
-# CONFIG_ARCH_IOP13XX is not set
-# CONFIG_ARCH_IOP32X is not set
-# CONFIG_ARCH_IOP33X is not set
-# CONFIG_ARCH_IXP4XX is not set
-# CONFIG_ARCH_K3 is not set
-# CONFIG_ARCH_KEYSTONE is not set
-# CONFIG_ARCH_KS8695 is not set
-# CONFIG_ARCH_LAYERSCAPE is not set
-# CONFIG_ARCH_LG1K is not set
-# CONFIG_ARCH_LPC32XX is not set
-# CONFIG_ARCH_MEDIATEK is not set
-# CONFIG_ARCH_MESON is not set
-CONFIG_ARCH_MMAP_RND_BITS=8
-CONFIG_ARCH_MMAP_RND_BITS_MAX=16
-CONFIG_ARCH_MMAP_RND_BITS_MIN=8
-CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MAX=16
-CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MIN=8
-# CONFIG_ARCH_MMP is not set
-# CONFIG_ARCH_MULTIPLATFORM is not set
-# CONFIG_ARCH_MULTI_V6 is not set
-# CONFIG_ARCH_MULTI_V7 is not set
-# CONFIG_ARCH_MV78XX0 is not set
-# CONFIG_ARCH_MVEBU is not set
-# CONFIG_ARCH_MXC is not set
-# CONFIG_ARCH_MXS is not set
-# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
-# CONFIG_ARCH_NETX is not set
-# CONFIG_ARCH_NOMADIK is not set
-# CONFIG_ARCH_NPCM is not set
-# CONFIG_ARCH_NSPIRE is not set
-# CONFIG_ARCH_OMAP is not set
-# CONFIG_ARCH_OMAP1 is not set
-# CONFIG_ARCH_OMAP2 is not set
-# CONFIG_ARCH_OMAP2PLUS is not set
-# CONFIG_ARCH_OMAP3 is not set
-# CONFIG_ARCH_OMAP4 is not set
-# CONFIG_ARCH_ORION5X is not set
-# CONFIG_ARCH_OXNAS is not set
-# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
-# CONFIG_ARCH_PICOXCELL is not set
-# CONFIG_ARCH_PRIMA2 is not set
-# CONFIG_ARCH_PXA is not set
-# CONFIG_ARCH_QCOM is not set
-# CONFIG_ARCH_REALTEK is not set
-# CONFIG_ARCH_REALVIEW is not set
-# CONFIG_ARCH_RENESAS is not set
-# CONFIG_ARCH_ROCKCHIP is not set
-# CONFIG_ARCH_RPC is not set
-# CONFIG_ARCH_S3C24XX is not set
-# CONFIG_ARCH_S3C64XX is not set
-# CONFIG_ARCH_S5PV210 is not set
-# CONFIG_ARCH_SA1100 is not set
-# CONFIG_ARCH_SEATTLE is not set
-# CONFIG_ARCH_SHMOBILE is not set
-# CONFIG_ARCH_SHMOBILE_MULTI is not set
-# CONFIG_ARCH_SIRF is not set
-# CONFIG_ARCH_SOCFPGA is not set
-# CONFIG_ARCH_SPRD is not set
-# CONFIG_ARCH_STI is not set
-# CONFIG_ARCH_STM32 is not set
-# CONFIG_ARCH_STRATIX10 is not set
-# CONFIG_ARCH_SUNXI is not set
-# CONFIG_ARCH_SYNQUACER is not set
-# CONFIG_ARCH_TANGO is not set
-# CONFIG_ARCH_TEGRA is not set
-# CONFIG_ARCH_THUNDER is not set
-# CONFIG_ARCH_THUNDER2 is not set
-# CONFIG_ARCH_U300 is not set
-# CONFIG_ARCH_U8500 is not set
-# CONFIG_ARCH_UNIPHIER is not set
-# CONFIG_ARCH_VERSATILE is not set
-# CONFIG_ARCH_VEXPRESS is not set
-# CONFIG_ARCH_VIRT is not set
-# CONFIG_ARCH_VT8500 is not set
-# CONFIG_ARCH_VULCAN is not set
-# CONFIG_ARCH_W90X900 is not set
-# CONFIG_ARCH_WANTS_THP_SWAP is not set
-# CONFIG_ARCH_WANTS_UBSAN_NO_NULL is not set
-# CONFIG_ARCH_WM8505 is not set
-# CONFIG_ARCH_WM8750 is not set
-# CONFIG_ARCH_WM8850 is not set
-# CONFIG_ARCH_XGENE is not set
-# CONFIG_ARCH_ZX is not set
-# CONFIG_ARCH_ZYNQ is not set
-# CONFIG_ARCH_ZYNQMP is not set
-# CONFIG_ARCNET is not set
-# CONFIG_ARC_EMAC is not set
-# CONFIG_ARC_IRQ_NO_AUTOSAVE is not set
-# CONFIG_ARM64_ERRATUM_1024718 is not set
-# CONFIG_ARM64_ERRATUM_1463225 is not set
-# CONFIG_ARM64_ERRATUM_819472 is not set
-# CONFIG_ARM64_ERRATUM_824069 is not set
-# CONFIG_ARM64_ERRATUM_826319 is not set
-# CONFIG_ARM64_ERRATUM_827319 is not set
-# CONFIG_ARM64_ERRATUM_832075 is not set
-# CONFIG_ARM64_ERRATUM_834220 is not set
-# CONFIG_ARM64_ERRATUM_843419 is not set
-# CONFIG_ARM64_ERRATUM_845719 is not set
-# CONFIG_ARM64_ERRATUM_858921 is not set
-# CONFIG_ARM64_RAS_EXTN is not set
-# CONFIG_ARM64_RELOC_TEST is not set
-CONFIG_ARM64_SW_TTBR0_PAN=y
-# CONFIG_ARM_APPENDED_DTB is not set
-# CONFIG_ARM_ARCH_TIMER is not set
-# CONFIG_ARM_BIG_LITTLE_CPUFREQ is not set
-# CONFIG_ARM_CCI is not set
-# CONFIG_ARM_CCI400_PMU is not set
-# CONFIG_ARM_CCI5xx_PMU is not set
-# CONFIG_ARM_CCI_PMU is not set
-# CONFIG_ARM_CCN is not set
-# CONFIG_ARM_CPUIDLE is not set
-CONFIG_ARM_CPU_TOPOLOGY=y
-# CONFIG_ARM_CRYPTO is not set
-CONFIG_ARM_DMA_MEM_BUFFERABLE=y
-# CONFIG_ARM_DSU_PMU is not set
-# CONFIG_ARM_ERRATA_326103 is not set
-# CONFIG_ARM_ERRATA_364296 is not set
-# CONFIG_ARM_ERRATA_411920 is not set
-# CONFIG_ARM_ERRATA_430973 is not set
-# CONFIG_ARM_ERRATA_458693 is not set
-# CONFIG_ARM_ERRATA_460075 is not set
-# CONFIG_ARM_ERRATA_643719 is not set
-# CONFIG_ARM_ERRATA_720789 is not set
-# CONFIG_ARM_ERRATA_742230 is not set
-# CONFIG_ARM_ERRATA_742231 is not set
-# CONFIG_ARM_ERRATA_743622 is not set
-# CONFIG_ARM_ERRATA_751472 is not set
-# CONFIG_ARM_ERRATA_754322 is not set
-# CONFIG_ARM_ERRATA_754327 is not set
-# CONFIG_ARM_ERRATA_764369 is not set
-# CONFIG_ARM_ERRATA_773022 is not set
-# CONFIG_ARM_ERRATA_775420 is not set
-# CONFIG_ARM_ERRATA_798181 is not set
-# CONFIG_ARM_ERRATA_818325_852422 is not set
-# CONFIG_ARM_ERRATA_821420 is not set
-# CONFIG_ARM_ERRATA_825619 is not set
-# CONFIG_ARM_ERRATA_852421 is not set
-# CONFIG_ARM_ERRATA_852423 is not set
-CONFIG_ARM_GIC_MAX_NR=1
-# CONFIG_ARM_KERNMEM_PERMS is not set
-# CONFIG_ARM_KIRKWOOD_CPUFREQ is not set
-# CONFIG_ARM_KPROBES_TEST is not set
-# CONFIG_ARM_MHU is not set
-# CONFIG_ARM_MODULE_PLTS is not set
-# CONFIG_ARM_PATCH_PHYS_VIRT is not set
-# CONFIG_ARM_PSCI is not set
-# CONFIG_ARM_PSCI_CHECKER is not set
-# CONFIG_ARM_PTDUMP is not set
-# CONFIG_ARM_PTDUMP_DEBUGFS is not set
-# CONFIG_ARM_SBSA_WATCHDOG is not set
-# CONFIG_ARM_SCPI_PROTOCOL is not set
-# CONFIG_ARM_SDE_INTERFACE is not set
-# CONFIG_ARM_SPE_PMU is not set
-# CONFIG_ARM_TIMER_SP804 is not set
-# CONFIG_ARM_UNWIND is not set
-# CONFIG_ARM_VIRT_EXT is not set
-# CONFIG_AS3935 is not set
-# CONFIG_ASM9260_TIMER is not set
-# CONFIG_ASUS_LAPTOP is not set
-# CONFIG_ASUS_WIRELESS is not set
-# CONFIG_ASYMMETRIC_KEY_TYPE is not set
-# CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE is not set
-# CONFIG_ASYNC_RAID6_TEST is not set
-# CONFIG_ASYNC_TX_DMA is not set
-# CONFIG_AT76C50X_USB is not set
-# CONFIG_AT803X_PHY is not set
-# CONFIG_AT91_SAMA5D2_ADC is not set
-# CONFIG_ATA is not set
-# CONFIG_ATAGS is not set
-CONFIG_ATAGS_PROC=y
-# CONFIG_ATALK is not set
-# CONFIG_ATARI_PARTITION is not set
-# CONFIG_ATA_ACPI is not set
-CONFIG_ATA_BMDMA=y
-# CONFIG_ATA_GENERIC is not set
-# CONFIG_ATA_NONSTANDARD is not set
-# CONFIG_ATA_OVER_ETH is not set
-# CONFIG_ATA_PIIX is not set
-CONFIG_ATA_SFF=y
-# CONFIG_ATA_VERBOSE_ERROR is not set
-# CONFIG_ATH10K is not set
-# CONFIG_ATH25 is not set
-# CONFIG_ATH5K is not set
-# CONFIG_ATH6KL is not set
-# CONFIG_ATH79 is not set
-# CONFIG_ATH9K is not set
-# CONFIG_ATH9K_HTC is not set
-# CONFIG_ATH_DEBUG is not set
-# CONFIG_ATL1 is not set
-# CONFIG_ATL1C is not set
-# CONFIG_ATL1E is not set
-# CONFIG_ATL2 is not set
-# CONFIG_ATLAS_PH_SENSOR is not set
-# CONFIG_ATM is not set
-# CONFIG_ATMEL is not set
-# CONFIG_ATMEL_PIT is not set
-# CONFIG_ATMEL_SSC is not set
-# CONFIG_ATM_AMBASSADOR is not set
-# CONFIG_ATM_BR2684 is not set
-CONFIG_ATM_BR2684_IPFILTER=y
-# CONFIG_ATM_CLIP is not set
-CONFIG_ATM_CLIP_NO_ICMP=y
-# CONFIG_ATM_DRIVERS is not set
-# CONFIG_ATM_DUMMY is not set
-# CONFIG_ATM_ENI is not set
-# CONFIG_ATM_FIRESTREAM is not set
-# CONFIG_ATM_FORE200E is not set
-# CONFIG_ATM_HE is not set
-# CONFIG_ATM_HORIZON is not set
-# CONFIG_ATM_IA is not set
-# CONFIG_ATM_IDT77252 is not set
-# CONFIG_ATM_LANAI is not set
-# CONFIG_ATM_LANE is not set
-# CONFIG_ATM_MPOA is not set
-# CONFIG_ATM_NICSTAR is not set
-# CONFIG_ATM_SOLOS is not set
-# CONFIG_ATM_TCP is not set
-# CONFIG_ATM_ZATM is not set
-# CONFIG_ATOMIC64_SELFTEST is not set
-# CONFIG_ATP is not set
-# CONFIG_AUDIT is not set
-# CONFIG_AUDIT_ARCH_COMPAT_GENERIC is not set
-# CONFIG_AURORA_NB8800 is not set
-# CONFIG_AUTOFS4_FS is not set
-# CONFIG_AUTOFS_FS is not set
-# CONFIG_AUTO_ZRELADDR is not set
-# CONFIG_AUXDISPLAY is not set
-# CONFIG_AX25 is not set
-# CONFIG_AX25_DAMA_SLAVE is not set
-# CONFIG_AX88796 is not set
-# CONFIG_AX88796B_PHY is not set
-# CONFIG_AXP20X_ADC is not set
-# CONFIG_AXP20X_POWER is not set
-# CONFIG_AXP288_ADC is not set
-# CONFIG_AXP288_FUEL_GAUGE is not set
-# CONFIG_B43 is not set
-# CONFIG_B43LEGACY is not set
-# CONFIG_B44 is not set
-# CONFIG_B53 is not set
-# CONFIG_BACKLIGHT_ADP8860 is not set
-# CONFIG_BACKLIGHT_ADP8870 is not set
-# CONFIG_BACKLIGHT_APPLE is not set
-# CONFIG_BACKLIGHT_ARCXCNN is not set
-# CONFIG_BACKLIGHT_BD6107 is not set
-# CONFIG_BACKLIGHT_GENERIC is not set
-# CONFIG_BACKLIGHT_GPIO is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
-# CONFIG_BACKLIGHT_LM3630A is not set
-# CONFIG_BACKLIGHT_LM3639 is not set
-# CONFIG_BACKLIGHT_LP855X is not set
-# CONFIG_BACKLIGHT_LV5207LP is not set
-# CONFIG_BACKLIGHT_PANDORA is not set
-# CONFIG_BACKLIGHT_PM8941_WLED is not set
-# CONFIG_BACKLIGHT_PWM is not set
-# CONFIG_BACKLIGHT_RPI is not set
-# CONFIG_BACKLIGHT_SAHARA is not set
-# CONFIG_BACKTRACE_SELF_TEST is not set
-CONFIG_BASE_FULL=y
-CONFIG_BASE_SMALL=0
-# CONFIG_BATMAN_ADV is not set
-# CONFIG_BATTERY_BQ27XXX is not set
-# CONFIG_BATTERY_BQ27XXX_HDQ is not set
-# CONFIG_BATTERY_DS2760 is not set
-# CONFIG_BATTERY_DS2780 is not set
-# CONFIG_BATTERY_DS2781 is not set
-# CONFIG_BATTERY_DS2782 is not set
-# CONFIG_BATTERY_GAUGE_LTC2941 is not set
-# CONFIG_BATTERY_GOLDFISH is not set
-# CONFIG_BATTERY_LEGO_EV3 is not set
-# CONFIG_BATTERY_MAX17040 is not set
-# CONFIG_BATTERY_MAX17042 is not set
-# CONFIG_BATTERY_MAX1721X is not set
-# CONFIG_BATTERY_SBS is not set
-# CONFIG_BAYCOM_EPP is not set
-# CONFIG_BAYCOM_PAR is not set
-# CONFIG_BAYCOM_SER_FDX is not set
-# CONFIG_BAYCOM_SER_HDX is not set
-# CONFIG_BCACHE is not set
-# CONFIG_BCM47XX is not set
-# CONFIG_BCM63XX is not set
-# CONFIG_BCM63XX_PHY is not set
-# CONFIG_BCM7038_WDT is not set
-# CONFIG_BCM7XXX_PHY is not set
-# CONFIG_BCM87XX_PHY is not set
-# CONFIG_BCMA is not set
-# CONFIG_BCMA_DRIVER_GPIO is not set
-CONFIG_BCMA_POSSIBLE=y
-# CONFIG_BCMGENET is not set
-# CONFIG_BCM_IPROC_ADC is not set
-# CONFIG_BCM_KONA_USB2_PHY is not set
-# CONFIG_BCM_SBA_RAID is not set
-# CONFIG_BDI_SWITCH is not set
-# CONFIG_BE2ISCSI is not set
-# CONFIG_BE2NET is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_BGMAC is not set
-# CONFIG_BH1750 is not set
-# CONFIG_BH1780 is not set
-# CONFIG_BIG_KEYS is not set
-# CONFIG_BIG_LITTLE is not set
-# CONFIG_BINARY_PRINTF is not set
-# CONFIG_BINFMT_AOUT is not set
-CONFIG_BINFMT_ELF=y
-# CONFIG_BINFMT_ELF_FDPIC is not set
-# CONFIG_BINFMT_FLAT is not set
-# CONFIG_BINFMT_MISC is not set
-CONFIG_BINFMT_SCRIPT=y
-CONFIG_BITREVERSE=y
-# CONFIG_BLK_CMDLINE_PARSER is not set
-# CONFIG_BLK_CPQ_CISS_DA is not set
-# CONFIG_BLK_CPQ_DA is not set
-# CONFIG_BLK_CGROUP_IOLATENCY is not set
-# CONFIG_BLK_DEBUG_FS is not set
-CONFIG_BLK_DEV=y
-# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
-# CONFIG_BLK_DEV_4DRIVES is not set
-# CONFIG_BLK_DEV_AEC62XX is not set
-# CONFIG_BLK_DEV_ALI14XX is not set
-# CONFIG_BLK_DEV_ALI15X3 is not set
-# CONFIG_BLK_DEV_AMD74XX is not set
-# CONFIG_BLK_DEV_ATIIXP is not set
-# CONFIG_BLK_DEV_BSG is not set
-# CONFIG_BLK_DEV_BSGLIB is not set
-# CONFIG_BLK_DEV_CMD640 is not set
-# CONFIG_BLK_DEV_CMD64X is not set
-# CONFIG_BLK_DEV_COW_COMMON is not set
-# CONFIG_BLK_DEV_CRYPTOLOOP is not set
-# CONFIG_BLK_DEV_CS5520 is not set
-# CONFIG_BLK_DEV_CS5530 is not set
-# CONFIG_BLK_DEV_CS5535 is not set
-# CONFIG_BLK_DEV_CS5536 is not set
-# CONFIG_BLK_DEV_CY82C693 is not set
-# CONFIG_BLK_DEV_DAC960 is not set
-# CONFIG_BLK_DEV_DELKIN is not set
-# CONFIG_BLK_DEV_DRBD is not set
-# CONFIG_BLK_DEV_DTC2278 is not set
-# CONFIG_BLK_DEV_FD is not set
-# CONFIG_BLK_DEV_GENERIC is not set
-# CONFIG_BLK_DEV_HD is not set
-# CONFIG_BLK_DEV_HPT366 is not set
-# CONFIG_BLK_DEV_HT6560B is not set
-# CONFIG_BLK_DEV_IDEACPI is not set
-# CONFIG_BLK_DEV_IDECD is not set
-# CONFIG_BLK_DEV_IDECS is not set
-# CONFIG_BLK_DEV_IDEPCI is not set
-# CONFIG_BLK_DEV_IDEPNP is not set
-# CONFIG_BLK_DEV_IDETAPE is not set
-# CONFIG_BLK_DEV_IDE_AU1XXX is not set
-# CONFIG_BLK_DEV_IDE_SATA is not set
-CONFIG_BLK_DEV_INITRD=y
-# CONFIG_BLK_DEV_INTEGRITY is not set
-# CONFIG_BLK_DEV_IO_TRACE is not set
-# CONFIG_BLK_DEV_IT8172 is not set
-# CONFIG_BLK_DEV_IT8213 is not set
-# CONFIG_BLK_DEV_IT821X is not set
-# CONFIG_BLK_DEV_JMICRON is not set
-# CONFIG_BLK_DEV_LOOP is not set
-CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
-# CONFIG_BLK_DEV_NBD is not set
-# CONFIG_BLK_DEV_NS87415 is not set
-# CONFIG_BLK_DEV_NULL_BLK is not set
-# CONFIG_BLK_DEV_NVME is not set
-# CONFIG_BLK_DEV_OFFBOARD is not set
-# CONFIG_BLK_DEV_OPTI621 is not set
-# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
-# CONFIG_BLK_DEV_PDC202XX_NEW is not set
-# CONFIG_BLK_DEV_PDC202XX_OLD is not set
-# CONFIG_BLK_DEV_PIIX is not set
-# CONFIG_BLK_DEV_PLATFORM is not set
-# CONFIG_BLK_DEV_PMEM is not set
-# CONFIG_BLK_DEV_QD65XX is not set
-# CONFIG_BLK_DEV_RAM is not set
-# CONFIG_BLK_DEV_RBD is not set
-# CONFIG_BLK_DEV_RSXX is not set
-# CONFIG_BLK_DEV_RZ1000 is not set
-# CONFIG_BLK_DEV_SC1200 is not set
-# CONFIG_BLK_DEV_SD is not set
-# CONFIG_BLK_DEV_SIIMAGE is not set
-# CONFIG_BLK_DEV_SIS5513 is not set
-# CONFIG_BLK_DEV_SKD is not set
-# CONFIG_BLK_DEV_SL82C105 is not set
-# CONFIG_BLK_DEV_SLC90E66 is not set
-# CONFIG_BLK_DEV_SR is not set
-# CONFIG_BLK_DEV_SVWKS is not set
-# CONFIG_BLK_DEV_SX8 is not set
-# CONFIG_BLK_DEV_TC86C001 is not set
-# CONFIG_BLK_DEV_THROTTLING is not set
-# CONFIG_BLK_DEV_TRIFLEX is not set
-# CONFIG_BLK_DEV_TRM290 is not set
-# CONFIG_BLK_DEV_UMC8672 is not set
-# CONFIG_BLK_DEV_UMEM is not set
-# CONFIG_BLK_DEV_VIA82CXXX is not set
-# CONFIG_BLK_DEV_ZONED is not set
-# CONFIG_BLK_SED_OPAL is not set
-# CONFIG_BLK_WBT is not set
-CONFIG_BLOCK=y
-# CONFIG_BMA180 is not set
-# CONFIG_BMA220 is not set
-# CONFIG_BMC150_ACCEL is not set
-# CONFIG_BMC150_MAGN is not set
-# CONFIG_BMC150_MAGN_I2C is not set
-# CONFIG_BMC150_MAGN_SPI is not set
-# CONFIG_BME680 is not set
-# CONFIG_BMG160 is not set
-# CONFIG_BMI160_I2C is not set
-# CONFIG_BMI160_SPI is not set
-# CONFIG_BMIPS_GENERIC is not set
-# CONFIG_BMP085 is not set
-# CONFIG_BMP085_I2C is not set
-# CONFIG_BMP085_SPI is not set
-# CONFIG_BMP280 is not set
-# CONFIG_BNA is not set
-# CONFIG_BNX2 is not set
-# CONFIG_BNX2X is not set
-# CONFIG_BNX2X_SRIOV is not set
-# CONFIG_BNXT is not set
-# CONFIG_BONDING is not set
-# CONFIG_BOOKE_WDT is not set
-CONFIG_BOOKE_WDT_DEFAULT_TIMEOUT=3
-# CONFIG_BOOT_PRINTK_DELAY is not set
-CONFIG_BOOT_RAW=y
-CONFIG_BPF=y
-# CONFIG_BPFILTER is not set
-CONFIG_BPF_JIT=y
-# CONFIG_BPF_JIT_ALWAYS_ON is not set
-# CONFIG_BPF_STREAM_PARSER is not set
-CONFIG_BPF_SYSCALL=y
-# CONFIG_BPQETHER is not set
-CONFIG_BQL=y
-CONFIG_BRANCH_PROFILE_NONE=y
-# CONFIG_BRCMFMAC is not set
-# CONFIG_BRCMSMAC is not set
-# CONFIG_BRCMSTB_GISB_ARB is not set
-CONFIG_BRIDGE=y
-# CONFIG_BRIDGE_EBT_802_3 is not set
-# CONFIG_BRIDGE_EBT_AMONG is not set
-# CONFIG_BRIDGE_EBT_ARP is not set
-# CONFIG_BRIDGE_EBT_ARPREPLY is not set
-# CONFIG_BRIDGE_EBT_BROUTE is not set
-# CONFIG_BRIDGE_EBT_DNAT is not set
-# CONFIG_BRIDGE_EBT_IP is not set
-# CONFIG_BRIDGE_EBT_IP6 is not set
-# CONFIG_BRIDGE_EBT_LIMIT is not set
-# CONFIG_BRIDGE_EBT_LOG is not set
-# CONFIG_BRIDGE_EBT_MARK is not set
-# CONFIG_BRIDGE_EBT_MARK_T is not set
-# CONFIG_BRIDGE_EBT_NFLOG is not set
-# CONFIG_BRIDGE_EBT_PKTTYPE is not set
-# CONFIG_BRIDGE_EBT_REDIRECT is not set
-# CONFIG_BRIDGE_EBT_SNAT is not set
-# CONFIG_BRIDGE_EBT_STP is not set
-# CONFIG_BRIDGE_EBT_T_FILTER is not set
-# CONFIG_BRIDGE_EBT_T_NAT is not set
-# CONFIG_BRIDGE_EBT_VLAN is not set
-CONFIG_BRIDGE_IGMP_SNOOPING=y
-# CONFIG_BRIDGE_NETFILTER is not set
-# CONFIG_BRIDGE_NF_EBTABLES is not set
-CONFIG_BRIDGE_VLAN_FILTERING=y
-# CONFIG_BROADCOM_PHY is not set
-CONFIG_BROKEN_ON_SMP=y
-# CONFIG_BSD_DISKLABEL is not set
-# CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_BSD_PROCESS_ACCT_V3 is not set
-# CONFIG_BT is not set
-# CONFIG_BTRFS_ASSERT is not set
-# CONFIG_BTRFS_DEBUG is not set
-# CONFIG_BTRFS_FS is not set
-# CONFIG_BTRFS_FS_POSIX_ACL is not set
-# CONFIG_BTRFS_FS_REF_VERIFY is not set
-# CONFIG_BTRFS_FS_RUN_SANITY_TESTS is not set
-# CONFIG_BT_ATH3K is not set
-# CONFIG_BT_BNEP is not set
-CONFIG_BT_BNEP_MC_FILTER=y
-CONFIG_BT_BNEP_PROTO_FILTER=y
-# CONFIG_BT_BREDR is not set
-# CONFIG_BT_CMTP is not set
-# CONFIG_BT_HCIBCM203X is not set
-# CONFIG_BT_HCIBFUSB is not set
-# CONFIG_BT_HCIBLUECARD is not set
-# CONFIG_BT_HCIBPA10X is not set
-# CONFIG_BT_HCIBT3C is not set
-# CONFIG_BT_HCIBTSDIO is not set
-# CONFIG_BT_HCIBTUART is not set
-# CONFIG_BT_HCIBTUSB is not set
-# CONFIG_BT_HCIBTUSB_AUTOSUSPEND is not set
-# CONFIG_BT_HCIBTUSB_RTL is not set
-# CONFIG_BT_HCIDTL1 is not set
-# CONFIG_BT_HCIUART is not set
-# CONFIG_BT_HCIUART_3WIRE is not set
-# CONFIG_BT_HCIUART_AG6XX is not set
-# CONFIG_BT_HCIUART_ATH3K is not set
-CONFIG_BT_HCIUART_BCSP=y
-CONFIG_BT_HCIUART_H4=y
-# CONFIG_BT_HCIUART_LL is not set
-# CONFIG_BT_HCIUART_MRVL is not set
-# CONFIG_BT_HCIUART_QCA is not set
-# CONFIG_BT_HCIVHCI is not set
-# CONFIG_BT_HIDP is not set
-# CONFIG_BT_HS is not set
-# CONFIG_BT_LE is not set
-# CONFIG_BT_LEDS is not set
-# CONFIG_BT_MRVL is not set
-# CONFIG_BT_MTKUART is not set
-# CONFIG_BT_RFCOMM is not set
-CONFIG_BT_RFCOMM_TTY=y
-# CONFIG_BT_SELFTEST is not set
-CONFIG_BUG=y
-# CONFIG_BUG_ON_DATA_CORRUPTION is not set
-CONFIG_BUILDTIME_EXTABLE_SORT=y
-# CONFIG_BUILD_BIN2C is not set
-CONFIG_BUILD_SALT=""
-# CONFIG_C2PORT is not set
-CONFIG_CACHE_L2X0_PMU=y
-# CONFIG_CADENCE_WATCHDOG is not set
-# CONFIG_CAIF is not set
-# CONFIG_CAN is not set
-# CONFIG_CAN_BCM is not set
-# CONFIG_CAN_DEBUG_DEVICES is not set
-# CONFIG_CAN_DEV is not set
-# CONFIG_CAN_GS_USB is not set
-# CONFIG_CAN_GW is not set
-# CONFIG_CAN_HI311X is not set
-# CONFIG_CAN_IFI_CANFD is not set
-# CONFIG_CAN_MCBA_USB is not set
-# CONFIG_CAN_M_CAN is not set
-# CONFIG_CAN_PEAK_PCIEFD is not set
-# CONFIG_CAN_RAW is not set
-# CONFIG_CAN_RCAR is not set
-# CONFIG_CAN_RCAR_CANFD is not set
-# CONFIG_CAN_SLCAN is not set
-# CONFIG_CAN_SUN4I is not set
-# CONFIG_CAN_UCAN is not set
-# CONFIG_CAN_VCAN is not set
-# CONFIG_CAN_VXCAN is not set
-# CONFIG_CAPI_AVM is not set
-# CONFIG_CAPI_EICON is not set
-# CONFIG_CAPI_TRACE is not set
-CONFIG_CARDBUS=y
-# CONFIG_CARDMAN_4000 is not set
-# CONFIG_CARDMAN_4040 is not set
-# CONFIG_CARL9170 is not set
-# CONFIG_CASSINI is not set
-# CONFIG_CAVIUM_CPT is not set
-# CONFIG_CAVIUM_ERRATUM_22375 is not set
-# CONFIG_CAVIUM_ERRATUM_23144 is not set
-# CONFIG_CAVIUM_ERRATUM_23154 is not set
-# CONFIG_CAVIUM_ERRATUM_27456 is not set
-# CONFIG_CAVIUM_ERRATUM_30115 is not set
-# CONFIG_CAVIUM_OCTEON_SOC is not set
-# CONFIG_CAVIUM_PTP is not set
-# CONFIG_CB710_CORE is not set
-# CONFIG_CC10001_ADC is not set
-# CONFIG_CCS811 is not set
-CONFIG_CC_HAS_SANCOV_TRACE_PC=y
-CONFIG_CC_HAS_STACKPROTECTOR_NONE=y
-CONFIG_CC_IS_GCC=y
-CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
-# CONFIG_CDROM_PKTCDVD is not set
-# CONFIG_CEPH_FS is not set
-# CONFIG_CEPH_LIB is not set
-# CONFIG_CFG80211 is not set
-# CONFIG_CFG80211_CERTIFICATION_ONUS is not set
-# CONFIG_CGROUPS is not set
-# CONFIG_CGROUP_BPF is not set
-# CONFIG_CGROUP_DEBUG is not set
-# CONFIG_CGROUP_NET_CLASSID is not set
-# CONFIG_CGROUP_NET_PRIO is not set
-# CONFIG_CGROUP_RDMA is not set
-# CONFIG_CHARGER_ADP5061 is not set
-# CONFIG_CHARGER_BQ2415X is not set
-# CONFIG_CHARGER_BQ24190 is not set
-# CONFIG_CHARGER_BQ24257 is not set
-# CONFIG_CHARGER_BQ24735 is not set
-# CONFIG_CHARGER_BQ25890 is not set
-# CONFIG_CHARGER_DETECTOR_MAX14656 is not set
-# CONFIG_CHARGER_GPIO is not set
-# CONFIG_CHARGER_ISP1704 is not set
-# CONFIG_CHARGER_LP8727 is not set
-# CONFIG_CHARGER_LTC3651 is not set
-# CONFIG_CHARGER_MANAGER is not set
-# CONFIG_CHARGER_MAX8903 is not set
-# CONFIG_CHARGER_RT9455 is not set
-# CONFIG_CHARGER_SBS is not set
-# CONFIG_CHARGER_SMB347 is not set
-# CONFIG_CHARGER_TWL4030 is not set
-# CONFIG_CHASH_SELFTEST is not set
-# CONFIG_CHASH_STATS is not set
-# CONFIG_CHECKPOINT_RESTORE is not set
-# CONFIG_CHELSIO_T1 is not set
-# CONFIG_CHELSIO_T3 is not set
-# CONFIG_CHELSIO_T4 is not set
-# CONFIG_CHELSIO_T4VF is not set
-# CONFIG_CHROME_PLATFORMS is not set
-# CONFIG_CHR_DEV_OSST is not set
-# CONFIG_CHR_DEV_SCH is not set
-# CONFIG_CHR_DEV_SG is not set
-# CONFIG_CHR_DEV_ST is not set
-# CONFIG_CICADA_PHY is not set
-# CONFIG_CIFS is not set
-# CONFIG_CIFS_ACL is not set
-CONFIG_CIFS_ALLOW_INSECURE_LEGACY=y
-# CONFIG_CIFS_DEBUG is not set
-# CONFIG_CIFS_DEBUG2 is not set
-# CONFIG_CIFS_FSCACHE is not set
-# CONFIG_CIFS_NFSD_EXPORT is not set
-CONFIG_CIFS_POSIX=y
-# CONFIG_CIFS_SMB2 is not set
-CONFIG_CIFS_STATS=y
-# CONFIG_CIFS_STATS2 is not set
-# CONFIG_CIFS_WEAK_PW_HASH is not set
-# CONFIG_CIFS_XATTR is not set
-# CONFIG_CIO_DAC is not set
-CONFIG_CLANG_VERSION=0
-# CONFIG_CLEANCACHE is not set
-# CONFIG_CLKSRC_VERSATILE is not set
-# CONFIG_CLK_HSDK is not set
-# CONFIG_CLK_QORIQ is not set
-# CONFIG_CLOCK_THERMAL is not set
-CONFIG_CLS_U32_MARK=y
-# CONFIG_CLS_U32_PERF is not set
-# CONFIG_CM32181 is not set
-# CONFIG_CM3232 is not set
-# CONFIG_CM3323 is not set
-# CONFIG_CM3605 is not set
-# CONFIG_CM36651 is not set
-# CONFIG_CMA is not set
-CONFIG_CMDLINE=""
-# CONFIG_CMDLINE_BOOL is not set
-# CONFIG_CMDLINE_EXTEND is not set
-# CONFIG_CMDLINE_FORCE is not set
-# CONFIG_CMDLINE_FROM_BOOTLOADER is not set
-# CONFIG_CMDLINE_PARTITION is not set
-# CONFIG_CNIC is not set
-# CONFIG_CODA_FS is not set
-# CONFIG_CODE_PATCHING_SELFTEST is not set
-# CONFIG_COMEDI is not set
-# CONFIG_COMMON_CLK_CDCE706 is not set
-# CONFIG_COMMON_CLK_CDCE925 is not set
-# CONFIG_COMMON_CLK_CS2000_CP is not set
-# CONFIG_COMMON_CLK_IPROC is not set
-# CONFIG_COMMON_CLK_MAX9485 is not set
-# CONFIG_COMMON_CLK_NXP is not set
-# CONFIG_COMMON_CLK_PIC32 is not set
-# CONFIG_COMMON_CLK_PWM is not set
-# CONFIG_COMMON_CLK_PXA is not set
-# CONFIG_COMMON_CLK_QCOM is not set
-# CONFIG_COMMON_CLK_SI514 is not set
-# CONFIG_COMMON_CLK_SI5351 is not set
-# CONFIG_COMMON_CLK_SI544 is not set
-# CONFIG_COMMON_CLK_SI570 is not set
-# CONFIG_COMMON_CLK_VC5 is not set
-# CONFIG_COMMON_CLK_VERSATILE is not set
-# CONFIG_COMMON_CLK_XGENE is not set
-# CONFIG_COMMON_CLK_XLNX_CLKWZRD is not set
-CONFIG_COMPACTION=y
-# CONFIG_COMPAL_LAPTOP is not set
-# CONFIG_COMPAT is not set
-# CONFIG_COMPAT_BRK is not set
-# CONFIG_COMPILE_TEST is not set
-# CONFIG_CONFIGFS_FS is not set
-# CONFIG_CONFIG_KVM_AMD_SEV is not set
-# CONFIG_CONNECTOR is not set
-CONFIG_CONSOLE_LOGLEVEL_DEFAULT=7
-CONFIG_CONSOLE_LOGLEVEL_QUIET=4
-CONFIG_CONSTRUCTORS=y
-# CONFIG_CONTEXT_SWITCH_TRACER is not set
-# CONFIG_COPS is not set
-# CONFIG_CORDIC is not set
-# CONFIG_COREDUMP is not set
-# CONFIG_CORESIGHT is not set
-# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
-# CONFIG_CORTINA_PHY is not set
-# CONFIG_CPA_DEBUG is not set
-# CONFIG_CPU_DCACHE_DISABLE is not set
-# CONFIG_CPU_FREQ is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_SCHEDUTIL is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
-# CONFIG_CPU_FREQ_GOV_SCHEDUTIL is not set
-# CONFIG_CPU_FREQ_STAT_DETAILS is not set
-# CONFIG_CPU_IDLE is not set
-# CONFIG_CPU_IDLE_GOV_MENU is not set
-# CONFIG_CPU_IDLE_MULTIPLE_DRIVERS is not set
-# CONFIG_CPU_ISOLATION is not set
-# CONFIG_CPU_NO_EFFICIENT_FFS is not set
-CONFIG_CPU_SW_DOMAIN_PAN=y
-# CONFIG_CRAMFS is not set
-CONFIG_CRAMFS_BLOCKDEV=y
-# CONFIG_CRAMFS_MTD is not set
-CONFIG_CRASHLOG=y
-# CONFIG_CRASH_DUMP is not set
-# CONFIG_CRC16 is not set
-CONFIG_CRC32=y
-# CONFIG_CRC32_BIT is not set
-CONFIG_CRC32_SARWATE=y
-# CONFIG_CRC32_SELFTEST is not set
-# CONFIG_CRC32_SLICEBY4 is not set
-# CONFIG_CRC32_SLICEBY8 is not set
-# CONFIG_CRC4 is not set
-# CONFIG_CRC64 is not set
-# CONFIG_CRC7 is not set
-# CONFIG_CRC8 is not set
-# CONFIG_CRC_CCITT is not set
-# CONFIG_CRC_ITU_T is not set
-# CONFIG_CRC_T10DIF is not set
-CONFIG_CROSS_COMPILE=""
-# CONFIG_CROSS_MEMORY_ATTACH is not set
-CONFIG_CRYPTO=y
-# CONFIG_CRYPTO_842 is not set
-# CONFIG_CRYPTO_AEAD is not set
-# CONFIG_CRYPTO_AEGIS128 is not set
-# CONFIG_CRYPTO_AEGIS128L is not set
-# CONFIG_CRYPTO_AEGIS128L_AESNI_SSE2 is not set
-# CONFIG_CRYPTO_AEGIS128_AESNI_SSE2 is not set
-# CONFIG_CRYPTO_AEGIS256 is not set
-# CONFIG_CRYPTO_AEGIS256_AESNI_SSE2 is not set
-CONFIG_CRYPTO_AES=y
-# CONFIG_CRYPTO_AES_586 is not set
-# CONFIG_CRYPTO_AES_ARM is not set
-# CONFIG_CRYPTO_AES_ARM_BS is not set
-# CONFIG_CRYPTO_AES_NI_INTEL is not set
-# CONFIG_CRYPTO_AES_TI is not set
-CONFIG_CRYPTO_ALGAPI=y
-CONFIG_CRYPTO_ALGAPI2=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-# CONFIG_CRYPTO_ANUBIS is not set
-# CONFIG_CRYPTO_ARC4 is not set
-# CONFIG_CRYPTO_AUTHENC is not set
-CONFIG_CRYPTO_BLKCIPHER=y
-CONFIG_CRYPTO_BLKCIPHER2=y
-# CONFIG_CRYPTO_BLOWFISH is not set
-# CONFIG_CRYPTO_CAMELLIA is not set
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
-# CONFIG_CRYPTO_CBC is not set
-# CONFIG_CRYPTO_CCM is not set
-# CONFIG_CRYPTO_CFB is not set
-# CONFIG_CRYPTO_CHACHA20 is not set
-# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
-# CONFIG_CRYPTO_CMAC is not set
-# CONFIG_CRYPTO_CRC32 is not set
-# CONFIG_CRYPTO_CRC32C is not set
-# CONFIG_CRYPTO_CRC32C_INTEL is not set
-# CONFIG_CRYPTO_CRCT10DIF is not set
-# CONFIG_CRYPTO_CRYPTD is not set
-# CONFIG_CRYPTO_CTR is not set
-# CONFIG_CRYPTO_CTS is not set
-# CONFIG_CRYPTO_DEFLATE is not set
-# CONFIG_CRYPTO_DES is not set
-# CONFIG_CRYPTO_DEV_ATMEL_AES is not set
-# CONFIG_CRYPTO_DEV_ATMEL_AUTHENC is not set
-# CONFIG_CRYPTO_DEV_ATMEL_ECC is not set
-# CONFIG_CRYPTO_DEV_ATMEL_SHA is not set
-# CONFIG_CRYPTO_DEV_ATMEL_TDES is not set
-# CONFIG_CRYPTO_DEV_CAVIUM_ZIP is not set
-# CONFIG_CRYPTO_DEV_CCP is not set
-# CONFIG_CRYPTO_DEV_CCREE is not set
-# CONFIG_CRYPTO_DEV_FSL_CAAM is not set
-# CONFIG_CRYPTO_DEV_FSL_CAAM_CRYPTO_API_DESC is not set
-# CONFIG_CRYPTO_DEV_HIFN_795X is not set
-# CONFIG_CRYPTO_DEV_HISI_SEC is not set
-# CONFIG_CRYPTO_DEV_IMGTEC_HASH is not set
-# CONFIG_CRYPTO_DEV_MARVELL_CESA is not set
-# CONFIG_CRYPTO_DEV_MV_CESA is not set
-# CONFIG_CRYPTO_DEV_MXC_SCC is not set
-# CONFIG_CRYPTO_DEV_MXS_DCP is not set
-# CONFIG_CRYPTO_DEV_NITROX_CNN55XX is not set
-# CONFIG_CRYPTO_DEV_QAT_C3XXX is not set
-# CONFIG_CRYPTO_DEV_QAT_C3XXXVF is not set
-# CONFIG_CRYPTO_DEV_QAT_C62X is not set
-# CONFIG_CRYPTO_DEV_QAT_C62XVF is not set
-# CONFIG_CRYPTO_DEV_QAT_DH895xCC is not set
-# CONFIG_CRYPTO_DEV_QAT_DH895xCCVF is not set
-# CONFIG_CRYPTO_DEV_QCE is not set
-# CONFIG_CRYPTO_DEV_S5P is not set
-# CONFIG_CRYPTO_DEV_SAFEXCEL is not set
-# CONFIG_CRYPTO_DEV_SAHARA is not set
-# CONFIG_CRYPTO_DEV_SP_PSP is not set
-# CONFIG_CRYPTO_DEV_TALITOS is not set
-# CONFIG_CRYPTO_DEV_VIRTIO is not set
-# CONFIG_CRYPTO_DH is not set
-# CONFIG_CRYPTO_DRBG_CTR is not set
-# CONFIG_CRYPTO_DRBG_HASH is not set
-# CONFIG_CRYPTO_DRBG_MENU is not set
-# CONFIG_CRYPTO_ECB is not set
-# CONFIG_CRYPTO_ECDH is not set
-# CONFIG_CRYPTO_ECHAINIV is not set
-# CONFIG_CRYPTO_FCRYPT is not set
-# CONFIG_CRYPTO_FIPS is not set
-# CONFIG_CRYPTO_GCM is not set
-# CONFIG_CRYPTO_GF128MUL is not set
-# CONFIG_CRYPTO_GHASH is not set
-# CONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL is not set
-# CONFIG_CRYPTO_HASH is not set
-# CONFIG_CRYPTO_HMAC is not set
-# CONFIG_CRYPTO_HW is not set
-# CONFIG_CRYPTO_JITTERENTROPY is not set
-# CONFIG_CRYPTO_KEYWRAP is not set
-# CONFIG_CRYPTO_KHAZAD is not set
-# CONFIG_CRYPTO_LRW is not set
-# CONFIG_CRYPTO_LZ4 is not set
-# CONFIG_CRYPTO_LZ4HC is not set
-# CONFIG_CRYPTO_LZO is not set
-# CONFIG_CRYPTO_MANAGER is not set
-# CONFIG_CRYPTO_MANAGER2 is not set
-CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
-# CONFIG_CRYPTO_MCRYPTD is not set
-# CONFIG_CRYPTO_MD4 is not set
-# CONFIG_CRYPTO_MD5 is not set
-# CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_MORUS1280 is not set
-# CONFIG_CRYPTO_MORUS1280_AVX2 is not set
-# CONFIG_CRYPTO_MORUS1280_SSE2 is not set
-# CONFIG_CRYPTO_MORUS640 is not set
-# CONFIG_CRYPTO_MORUS640_SSE2 is not set
-# CONFIG_CRYPTO_NULL is not set
-# CONFIG_CRYPTO_PCBC is not set
-# CONFIG_CRYPTO_PCOMP is not set
-# CONFIG_CRYPTO_PCOMP2 is not set
-CONFIG_CRYPTO_PCRYPT=y
-# CONFIG_CRYPTO_POLY1305 is not set
-# CONFIG_CRYPTO_RMD128 is not set
-# CONFIG_CRYPTO_RMD160 is not set
-# CONFIG_CRYPTO_RMD256 is not set
-# CONFIG_CRYPTO_RMD320 is not set
-# CONFIG_CRYPTO_RNG is not set
-# CONFIG_CRYPTO_RSA is not set
-# CONFIG_CRYPTO_SALSA20 is not set
-# CONFIG_CRYPTO_SALSA20_586 is not set
-# CONFIG_CRYPTO_SEED is not set
-# CONFIG_CRYPTO_SEQIV is not set
-# CONFIG_CRYPTO_SERPENT is not set
-# CONFIG_CRYPTO_SHA1 is not set
-# CONFIG_CRYPTO_SHA1_ARM is not set
-# CONFIG_CRYPTO_SHA256 is not set
-# CONFIG_CRYPTO_SHA3 is not set
-# CONFIG_CRYPTO_SHA512 is not set
-# CONFIG_CRYPTO_SM3 is not set
-# CONFIG_CRYPTO_SM4 is not set
-# CONFIG_CRYPTO_SPECK is not set
-# CONFIG_CRYPTO_TEA is not set
-# CONFIG_CRYPTO_TEST is not set
-# CONFIG_CRYPTO_TGR192 is not set
-# CONFIG_CRYPTO_TWOFISH is not set
-# CONFIG_CRYPTO_TWOFISH_586 is not set
-# CONFIG_CRYPTO_TWOFISH_COMMON is not set
-# CONFIG_CRYPTO_USER is not set
-# CONFIG_CRYPTO_USER_API_AEAD is not set
-# CONFIG_CRYPTO_USER_API_HASH is not set
-# CONFIG_CRYPTO_USER_API_RNG is not set
-# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
-# CONFIG_CRYPTO_VMAC is not set
-# CONFIG_CRYPTO_WP512 is not set
-# CONFIG_CRYPTO_XCBC is not set
-# CONFIG_CRYPTO_XTS is not set
-# CONFIG_CRYPTO_ZLIB is not set
-# CONFIG_CRYPTO_ZSTD is not set
-# CONFIG_CS5535_MFGPT is not set
-# CONFIG_CS89x0 is not set
-# CONFIG_CUSE is not set
-# CONFIG_CW1200 is not set
-# CONFIG_CXL_AFU_DRIVER_OPS is not set
-# CONFIG_CXL_BASE is not set
-# CONFIG_CXL_EEH is not set
-# CONFIG_CXL_KERNEL_API is not set
-# CONFIG_CXL_LIB is not set
-# CONFIG_CYPRESS_FIRMWARE is not set
-# CONFIG_DA280 is not set
-# CONFIG_DA311 is not set
-# CONFIG_DAVICOM_PHY is not set
-# CONFIG_DAX is not set
-# CONFIG_DCB is not set
-# CONFIG_DDR is not set
-# CONFIG_DEBUG_ALIGN_RODATA is not set
-# CONFIG_DEBUG_ATOMIC_SLEEP is not set
-# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
-# CONFIG_DEBUG_BUGVERBOSE is not set
-# CONFIG_DEBUG_CREDENTIALS is not set
-# CONFIG_DEBUG_DEVRES is not set
-# CONFIG_DEBUG_DRIVER is not set
-# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
-CONFIG_DEBUG_FS=y
-# CONFIG_DEBUG_GPIO is not set
-# CONFIG_DEBUG_HIGHMEM is not set
-# CONFIG_DEBUG_ICEDCC is not set
-# CONFIG_DEBUG_INFO is not set
-# CONFIG_DEBUG_INFO_DWARF4 is not set
-CONFIG_DEBUG_INFO_REDUCED=y
-# CONFIG_DEBUG_INFO_SPLIT is not set
-CONFIG_DEBUG_KERNEL=y
-# CONFIG_DEBUG_KMEMLEAK is not set
-# CONFIG_DEBUG_KOBJECT is not set
-# CONFIG_DEBUG_KOBJECT_RELEASE is not set
-# CONFIG_DEBUG_LIST is not set
-# CONFIG_DEBUG_LL is not set
-# CONFIG_DEBUG_LL_UART_8250 is not set
-# CONFIG_DEBUG_LL_UART_PL01X is not set
-# CONFIG_DEBUG_LOCKDEP is not set
-# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
-# CONFIG_DEBUG_LOCK_ALLOC is not set
-# CONFIG_DEBUG_MEMORY_INIT is not set
-# CONFIG_DEBUG_MUTEXES is not set
-# CONFIG_DEBUG_NOTIFIERS is not set
-# CONFIG_DEBUG_NX_TEST is not set
-# CONFIG_DEBUG_OBJECTS is not set
-# CONFIG_DEBUG_PAGEALLOC is not set
-# CONFIG_DEBUG_PAGE_REF is not set
-# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
-# CONFIG_DEBUG_PER_CPU_MAPS is not set
-# CONFIG_DEBUG_PINCTRL is not set
-# CONFIG_DEBUG_PI_LIST is not set
-# CONFIG_DEBUG_PREEMPT is not set
-# CONFIG_DEBUG_RODATA_TEST is not set
-# CONFIG_DEBUG_RSEQ is not set
-# CONFIG_DEBUG_RT_MUTEXES is not set
-# CONFIG_DEBUG_RWSEMS is not set
-# CONFIG_DEBUG_SECTION_MISMATCH is not set
-# CONFIG_DEBUG_SEMIHOSTING is not set
-# CONFIG_DEBUG_SG is not set
-# CONFIG_DEBUG_SHIRQ is not set
-# CONFIG_DEBUG_SLAB is not set
-# CONFIG_DEBUG_SPINLOCK is not set
-# CONFIG_DEBUG_STACKOVERFLOW is not set
-# CONFIG_DEBUG_STACK_USAGE is not set
-# CONFIG_DEBUG_STRICT_USER_COPY_CHECKS is not set
-# CONFIG_DEBUG_TEST_DRIVER_REMOVE is not set
-# CONFIG_DEBUG_TIMEKEEPING is not set
-# CONFIG_DEBUG_UART_8250_PALMCHIP is not set
-# CONFIG_DEBUG_UART_BCM63XX is not set
-# CONFIG_DEBUG_VIRTUAL is not set
-# CONFIG_DEBUG_VM is not set
-# CONFIG_DEBUG_WQ_FORCE_RR_CPU is not set
-# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
-# CONFIG_DEBUG_WX is not set
-# CONFIG_DEBUG_ZBOOT is not set
-# CONFIG_DECNET is not set
-CONFIG_DEFAULT_CUBIC=y
-CONFIG_DEFAULT_DEADLINE=y
-CONFIG_DEFAULT_HOSTNAME="(none)"
-CONFIG_DEFAULT_IOSCHED="deadline"
-CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
-# CONFIG_DEFAULT_NOOP is not set
-# CONFIG_DEFAULT_RENO is not set
-CONFIG_DEFAULT_SECURITY=""
-CONFIG_DEFAULT_SECURITY_DAC=y
-CONFIG_DEFAULT_TCP_CONG="cubic"
-CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
-# CONFIG_DEFERRED_STRUCT_PAGE_INIT is not set
-# CONFIG_DELL_LAPTOP is not set
-# CONFIG_DELL_RBTN is not set
-# CONFIG_DELL_SMBIOS is not set
-# CONFIG_DELL_SMO8800 is not set
-# CONFIG_DEPRECATED_PARAM_STRUCT is not set
-# CONFIG_DETECT_HUNG_TASK is not set
-# CONFIG_DEVKMEM is not set
-# CONFIG_DEVMEM is not set
-CONFIG_DEVPORT=y
-# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
-# CONFIG_DEVTMPFS is not set
-# CONFIG_DEVTMPFS_MOUNT is not set
-# CONFIG_DEV_DAX is not set
-# CONFIG_DGAP is not set
-# CONFIG_DGNC is not set
-# CONFIG_DHT11 is not set
-# CONFIG_DISCONTIGMEM_MANUAL is not set
-# CONFIG_DISPLAY_CONNECTOR_ANALOG_TV is not set
-# CONFIG_DISPLAY_CONNECTOR_DVI is not set
-# CONFIG_DISPLAY_CONNECTOR_HDMI is not set
-# CONFIG_DISPLAY_ENCODER_TFP410 is not set
-# CONFIG_DISPLAY_ENCODER_TPD12S015 is not set
-# CONFIG_DISPLAY_PANEL_DPI is not set
-# CONFIG_DISPLAY_PANEL_LGPHILIPS_LB035Q02 is not set
-# CONFIG_DISPLAY_PANEL_TPO_TD028TTEC1 is not set
-# CONFIG_DISPLAY_PANEL_TPO_TD043MTEA1 is not set
-# CONFIG_DL2K is not set
-# CONFIG_DLM is not set
-# CONFIG_DM9000 is not set
-# CONFIG_DMADEVICES is not set
-# CONFIG_DMADEVICES_DEBUG is not set
-# CONFIG_DMARD06 is not set
-# CONFIG_DMARD09 is not set
-# CONFIG_DMARD10 is not set
-# CONFIG_DMASCC is not set
-# CONFIG_DMATEST is not set
-# CONFIG_DMA_API_DEBUG is not set
-# CONFIG_DMA_ENGINE is not set
-# CONFIG_DMA_FENCE_TRACE is not set
-# CONFIG_DMA_NOOP_OPS is not set
-# CONFIG_DMA_SHARED_BUFFER is not set
-# CONFIG_DMA_VIRT_OPS is not set
-# CONFIG_DM_CACHE is not set
-# CONFIG_DM_DEBUG is not set
-# CONFIG_DM_DELAY is not set
-# CONFIG_DM_ERA is not set
-# CONFIG_DM_FLAKEY is not set
-# CONFIG_DM_INTEGRITY is not set
-# CONFIG_DM_LOG_USERSPACE is not set
-# CONFIG_DM_LOG_WRITES is not set
-# CONFIG_DM_MQ_DEFAULT is not set
-# CONFIG_DM_MULTIPATH is not set
-# CONFIG_DM_RAID is not set
-# CONFIG_DM_SWITCH is not set
-# CONFIG_DM_THIN_PROVISIONING is not set
-# CONFIG_DM_UEVENT is not set
-# CONFIG_DM_UNSTRIPED is not set
-# CONFIG_DM_VERITY is not set
-# CONFIG_DM_WRITECACHE is not set
-# CONFIG_DM_ZERO is not set
-# CONFIG_DNET is not set
-# CONFIG_DNOTIFY is not set
-# CONFIG_DNS_RESOLVER is not set
-CONFIG_DOUBLEFAULT=y
-# CONFIG_DP83822_PHY is not set
-# CONFIG_DP83848_PHY is not set
-# CONFIG_DP83867_PHY is not set
-# CONFIG_DP83TC811_PHY is not set
-# CONFIG_DPOT_DAC is not set
-CONFIG_DQL=y
-# CONFIG_DRAGONRISE_FF is not set
-# CONFIG_DRM is not set
-# CONFIG_DRM_AMDGPU is not set
-# CONFIG_DRM_AMDGPU_CIK is not set
-# CONFIG_DRM_AMDGPU_GART_DEBUGFS is not set
-# CONFIG_DRM_AMDGPU_SI is not set
-# CONFIG_DRM_AMDGPU_USERPTR is not set
-# CONFIG_DRM_AMD_ACP is not set
-# CONFIG_DRM_ANALOGIX_ANX78XX is not set
-# CONFIG_DRM_ARCPGU is not set
-# CONFIG_DRM_ARMADA is not set
-# CONFIG_DRM_AST is not set
-# CONFIG_DRM_BOCHS is not set
-# CONFIG_DRM_CDNS_DSI is not set
-# CONFIG_DRM_CIRRUS_QEMU is not set
-# CONFIG_DRM_DEBUG_MM is not set
-# CONFIG_DRM_DEBUG_SELFTEST is not set
-# CONFIG_DRM_DP_AUX_CHARDEV is not set
-# CONFIG_DRM_DP_CEC is not set
-# CONFIG_DRM_DUMB_VGA_DAC is not set
-# CONFIG_DRM_DW_HDMI_CEC is not set
-# CONFIG_DRM_ETNAVIV is not set
-# CONFIG_DRM_EXYNOS is not set
-# CONFIG_DRM_FBDEV_EMULATION is not set
-# CONFIG_DRM_FBDEV_LEAK_PHYS_SMEM is not set
-# CONFIG_DRM_FSL_DCU is not set
-# CONFIG_DRM_GMA500 is not set
-# CONFIG_DRM_HDLCD is not set
-# CONFIG_DRM_HISI_HIBMC is not set
-# CONFIG_DRM_HISI_KIRIN is not set
-# CONFIG_DRM_I2C_ADV7511 is not set
-# CONFIG_DRM_I2C_CH7006 is not set
-# CONFIG_DRM_I2C_NXP_TDA9950 is not set
-# CONFIG_DRM_I2C_NXP_TDA998X is not set
-# CONFIG_DRM_I2C_SIL164 is not set
-# CONFIG_DRM_I915 is not set
-# CONFIG_DRM_LEGACY is not set
-# CONFIG_DRM_LIB_RANDOM is not set
-# CONFIG_DRM_LOAD_EDID_FIRMWARE is not set
-# CONFIG_DRM_LVDS_ENCODER is not set
-# CONFIG_DRM_MALI_DISPLAY is not set
-# CONFIG_DRM_MEGACHIPS_STDPXXXX_GE_B850V3_FW is not set
-# CONFIG_DRM_MGAG200 is not set
-# CONFIG_DRM_MXSFB is not set
-# CONFIG_DRM_NOUVEAU is not set
-# CONFIG_DRM_NXP_PTN3460 is not set
-# CONFIG_DRM_OMAP is not set
-# CONFIG_DRM_PANEL_ARM_VERSATILE is not set
-# CONFIG_DRM_PANEL_ILITEK_IL9322 is not set
-# CONFIG_DRM_PANEL_ILITEK_ILI9881C is not set
-# CONFIG_DRM_PANEL_INNOLUX_P079ZCA is not set
-# CONFIG_DRM_PANEL_JDI_LT070ME05000 is not set
-# CONFIG_DRM_PANEL_LG_LG4573 is not set
-# CONFIG_DRM_PANEL_LVDS is not set
-# CONFIG_DRM_PANEL_ORISETECH_OTM8009A is not set
-# CONFIG_DRM_PANEL_PANASONIC_VVX10F034N00 is not set
-# CONFIG_DRM_PANEL_RASPBERRYPI_TOUCHSCREEN is not set
-# CONFIG_DRM_PANEL_RAYDIUM_RM68200 is not set
-# CONFIG_DRM_PANEL_SAMSUNG_LD9040 is not set
-# CONFIG_DRM_PANEL_SAMSUNG_S6E3HA2 is not set
-# CONFIG_DRM_PANEL_SAMSUNG_S6E63J0X03 is not set
-# CONFIG_DRM_PANEL_SAMSUNG_S6E8AA0 is not set
-# CONFIG_DRM_PANEL_SEIKO_43WVF1G is not set
-# CONFIG_DRM_PANEL_SHARP_LQ101R1SX01 is not set
-# CONFIG_DRM_PANEL_SHARP_LS043T1LE01 is not set
-# CONFIG_DRM_PANEL_SITRONIX_ST7789V is not set
-# CONFIG_DRM_PARADE_PS8622 is not set
-# CONFIG_DRM_PL111 is not set
-# CONFIG_DRM_QXL is not set
-# CONFIG_DRM_RADEON is not set
-# CONFIG_DRM_RADEON_USERPTR is not set
-# CONFIG_DRM_RCAR_DW_HDMI is not set
-# CONFIG_DRM_RCAR_LVDS is not set
-# CONFIG_DRM_SII902X is not set
-# CONFIG_DRM_SII9234 is not set
-# CONFIG_DRM_SIL_SII8620 is not set
-# CONFIG_DRM_STI is not set
-# CONFIG_DRM_STM is not set
-# CONFIG_DRM_SUN4I is not set
-# CONFIG_DRM_THINE_THC63LVD1024 is not set
-# CONFIG_DRM_TILCDC is not set
-# CONFIG_DRM_TINYDRM is not set
-# CONFIG_DRM_TI_TFP410 is not set
-# CONFIG_DRM_TOSHIBA_TC358767 is not set
-# CONFIG_DRM_UDL is not set
-# CONFIG_DRM_VBOXVIDEO is not set
-# CONFIG_DRM_VGEM is not set
-# CONFIG_DRM_VIRTIO_GPU is not set
-# CONFIG_DRM_VKMS is not set
-# CONFIG_DRM_VMWGFX is not set
-# CONFIG_DRM_XEN is not set
-# CONFIG_DS1682 is not set
-# CONFIG_DS1803 is not set
-# CONFIG_DS4424 is not set
-# CONFIG_DST_CACHE is not set
-# CONFIG_DTLK is not set
-# CONFIG_DUMMY is not set
-CONFIG_DUMMY_CONSOLE_COLUMNS=80
-CONFIG_DUMMY_CONSOLE_ROWS=25
-# CONFIG_DUMMY_IRQ is not set
-# CONFIG_DVB_AU8522_V4L is not set
-# CONFIG_DVB_CORE is not set
-# CONFIG_DVB_DUMMY_FE is not set
-# CONFIG_DVB_TUNER_DIB0070 is not set
-# CONFIG_DVB_TUNER_DIB0090 is not set
-# CONFIG_DWC_XLGMAC is not set
-# CONFIG_DWMAC_IPQ806X is not set
-# CONFIG_DWMAC_LPC18XX is not set
-# CONFIG_DWMAC_MESON is not set
-# CONFIG_DWMAC_ROCKCHIP is not set
-# CONFIG_DWMAC_SOCFPGA is not set
-# CONFIG_DWMAC_STI is not set
-# CONFIG_DW_AXI_DMAC is not set
-# CONFIG_DW_DMAC is not set
-# CONFIG_DW_DMAC_PCI is not set
-# CONFIG_DW_WATCHDOG is not set
-# CONFIG_DYNAMIC_DEBUG is not set
-# CONFIG_E100 is not set
-# CONFIG_E1000 is not set
-# CONFIG_E1000E is not set
-# CONFIG_E1000E_HWTS is not set
-# CONFIG_EARLY_PRINTK_8250 is not set
-# CONFIG_EARLY_PRINTK_USB_XDBC is not set
-# CONFIG_EBC_C384_WDT is not set
-# CONFIG_ECHO is not set
-# CONFIG_ECRYPT_FS is not set
-# CONFIG_EDAC is not set
-# CONFIG_EEEPC_LAPTOP is not set
-# CONFIG_EEPROM_93CX6 is not set
-# CONFIG_EEPROM_93XX46 is not set
-# CONFIG_EEPROM_AT24 is not set
-# CONFIG_EEPROM_AT25 is not set
-# CONFIG_EEPROM_DIGSY_MTC_CFG is not set
-# CONFIG_EEPROM_IDT_89HPESX is not set
-# CONFIG_EEPROM_LEGACY is not set
-# CONFIG_EEPROM_MAX6875 is not set
-# CONFIG_EFI is not set
-CONFIG_EFI_PARTITION=y
-# CONFIG_EFS_FS is not set
-CONFIG_ELFCORE=y
-# CONFIG_ELF_CORE is not set
-# CONFIG_EMAC_ROCKCHIP is not set
-CONFIG_EMBEDDED=y
-# CONFIG_EM_TIMER_STI is not set
-# CONFIG_ENABLE_MUST_CHECK is not set
-CONFIG_ENABLE_WARN_DEPRECATED=y
-# CONFIG_ENA_ETHERNET is not set
-# CONFIG_ENC28J60 is not set
-# CONFIG_ENCLOSURE_SERVICES is not set
-# CONFIG_ENCRYPTED_KEYS is not set
-# CONFIG_ENCX24J600 is not set
-# CONFIG_ENIC is not set
-# CONFIG_ENVELOPE_DETECTOR is not set
-# CONFIG_EPAPR_PARAVIRT is not set
-# CONFIG_EPIC100 is not set
-CONFIG_EPOLL=y
-# CONFIG_EQUALIZER is not set
-# CONFIG_EROFS_FS is not set
-# CONFIG_ET131X is not set
-CONFIG_ETHERNET=y
-# CONFIG_ETHOC is not set
-CONFIG_EVENTFD=y
-CONFIG_EXPERT=y
-CONFIG_EXPORTFS=y
-# CONFIG_EXPORTFS_BLOCK_OPS is not set
-# CONFIG_EXT2_FS is not set
-# CONFIG_EXT2_FS_XATTR is not set
-# CONFIG_EXT3_FS is not set
-# CONFIG_EXT4_DEBUG is not set
-# CONFIG_EXT4_ENCRYPTION is not set
-# CONFIG_EXT4_FS is not set
-# CONFIG_EXT4_FS_POSIX_ACL is not set
-# CONFIG_EXT4_FS_SECURITY is not set
-CONFIG_EXT4_USE_FOR_EXT2=y
-# CONFIG_EXTCON is not set
-# CONFIG_EXTCON_ADC_JACK is not set
-# CONFIG_EXTCON_ARIZONA is not set
-# CONFIG_EXTCON_AXP288 is not set
-# CONFIG_EXTCON_GPIO is not set
-# CONFIG_EXTCON_INTEL_INT3496 is not set
-# CONFIG_EXTCON_MAX3355 is not set
-# CONFIG_EXTCON_QCOM_SPMI_MISC is not set
-# CONFIG_EXTCON_RT8973A is not set
-# CONFIG_EXTCON_SM5502 is not set
-# CONFIG_EXTCON_USB_GPIO is not set
-CONFIG_EXTRA_FIRMWARE=""
-CONFIG_EXTRA_TARGETS=""
-# CONFIG_EXYNOS_ADC is not set
-# CONFIG_EXYNOS_VIDEO is not set
-# CONFIG_EZCHIP_NPS_MANAGEMENT_ENET is not set
-# CONFIG_EZX_PCAP is not set
-# CONFIG_F2FS_FAULT_INJECTION is not set
-# CONFIG_F2FS_FS is not set
-# CONFIG_F2FS_FS_ENCRYPTION is not set
-# CONFIG_F2FS_FS_POSIX_ACL is not set
-# CONFIG_F2FS_IO_TRACE is not set
-# CONFIG_FAILOVER is not set
-# CONFIG_FAIR_GROUP_SCHED is not set
-# CONFIG_FANOTIFY is not set
-CONFIG_FAT_DEFAULT_CODEPAGE=437
-CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
-# CONFIG_FAT_DEFAULT_UTF8 is not set
-# CONFIG_FAT_FS is not set
-# CONFIG_FAULT_INJECTION is not set
-# CONFIG_FB is not set
-# CONFIG_FB_3DFX is not set
-# CONFIG_FB_ARC is not set
-# CONFIG_FB_ARK is not set
-# CONFIG_FB_ARMCLCD is not set
-# CONFIG_FB_ASILIANT is not set
-# CONFIG_FB_ATY is not set
-# CONFIG_FB_ATY128 is not set
-# CONFIG_FB_AUO_K190X is not set
-# CONFIG_FB_BACKLIGHT is not set
-# CONFIG_FB_BIG_ENDIAN is not set
-# CONFIG_FB_BOOT_VESA_SUPPORT is not set
-# CONFIG_FB_BOTH_ENDIAN is not set
-# CONFIG_FB_BROADSHEET is not set
-# CONFIG_FB_CARMINE is not set
-# CONFIG_FB_CFB_COPYAREA is not set
-# CONFIG_FB_CFB_FILLRECT is not set
-# CONFIG_FB_CFB_IMAGEBLIT is not set
-# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
-# CONFIG_FB_CIRRUS is not set
-# CONFIG_FB_CYBER2000 is not set
-# CONFIG_FB_DA8XX is not set
-# CONFIG_FB_DDC is not set
-# CONFIG_FB_FLEX is not set
-# CONFIG_FB_FOREIGN_ENDIAN is not set
-# CONFIG_FB_GEODE is not set
-# CONFIG_FB_GOLDFISH is not set
-# CONFIG_FB_HGA is not set
-# CONFIG_FB_I740 is not set
-# CONFIG_FB_IBM_GXT4500 is not set
-# CONFIG_FB_IMSTT is not set
-# CONFIG_FB_IMX is not set
-# CONFIG_FB_KYRO is not set
-# CONFIG_FB_LE80578 is not set
-# CONFIG_FB_LITTLE_ENDIAN is not set
-# CONFIG_FB_MACMODES is not set
-# CONFIG_FB_MATROX is not set
-# CONFIG_FB_MB862XX is not set
-# CONFIG_FB_METRONOME is not set
-# CONFIG_FB_MODE_HELPERS is not set
-# CONFIG_FB_MXS is not set
-# CONFIG_FB_N411 is not set
-# CONFIG_FB_NEOMAGIC is not set
-CONFIG_FB_NOTIFY=y
-# CONFIG_FB_NVIDIA is not set
-# CONFIG_FB_OF is not set
-# CONFIG_FB_OMAP2 is not set
-# CONFIG_FB_OPENCORES is not set
-# CONFIG_FB_PM2 is not set
-# CONFIG_FB_PM3 is not set
-# CONFIG_FB_PS3 is not set
-# CONFIG_FB_PXA is not set
-# CONFIG_FB_RADEON is not set
-# CONFIG_FB_RIVA is not set
-# CONFIG_FB_S1D13XXX is not set
-# CONFIG_FB_S3 is not set
-# CONFIG_FB_SAVAGE is not set
-# CONFIG_FB_SIMPLE is not set
-# CONFIG_FB_SIS is not set
-# CONFIG_FB_SM712 is not set
-# CONFIG_FB_SM750 is not set
-# CONFIG_FB_SMSCUFX is not set
-# CONFIG_FB_SSD1307 is not set
-# CONFIG_FB_SVGALIB is not set
-# CONFIG_FB_SYS_COPYAREA is not set
-# CONFIG_FB_SYS_FILLRECT is not set
-# CONFIG_FB_SYS_FOPS is not set
-# CONFIG_FB_SYS_IMAGEBLIT is not set
-# CONFIG_FB_TFT is not set
-# CONFIG_FB_TFT_AGM1264K_FL is not set
-# CONFIG_FB_TFT_BD663474 is not set
-# CONFIG_FB_TFT_FBTFT_DEVICE is not set
-# CONFIG_FB_TFT_HX8340BN is not set
-# CONFIG_FB_TFT_HX8347D is not set
-# CONFIG_FB_TFT_HX8353D is not set
-# CONFIG_FB_TFT_HX8357D is not set
-# CONFIG_FB_TFT_ILI9163 is not set
-# CONFIG_FB_TFT_ILI9320 is not set
-# CONFIG_FB_TFT_ILI9325 is not set
-# CONFIG_FB_TFT_ILI9340 is not set
-# CONFIG_FB_TFT_ILI9341 is not set
-# CONFIG_FB_TFT_ILI9481 is not set
-# CONFIG_FB_TFT_ILI9486 is not set
-# CONFIG_FB_TFT_PCD8544 is not set
-# CONFIG_FB_TFT_RA8875 is not set
-# CONFIG_FB_TFT_S6D02A1 is not set
-# CONFIG_FB_TFT_S6D1121 is not set
-# CONFIG_FB_TFT_SH1106 is not set
-# CONFIG_FB_TFT_SSD1289 is not set
-# CONFIG_FB_TFT_SSD1305 is not set
-# CONFIG_FB_TFT_SSD1306 is not set
-# CONFIG_FB_TFT_SSD1325 is not set
-# CONFIG_FB_TFT_SSD1331 is not set
-# CONFIG_FB_TFT_SSD1351 is not set
-# CONFIG_FB_TFT_ST7735R is not set
-# CONFIG_FB_TFT_ST7789V is not set
-# CONFIG_FB_TFT_TINYLCD is not set
-# CONFIG_FB_TFT_TLS8204 is not set
-# CONFIG_FB_TFT_UC1611 is not set
-# CONFIG_FB_TFT_UC1701 is not set
-# CONFIG_FB_TFT_UPD161704 is not set
-# CONFIG_FB_TFT_WATTEROTT is not set
-# CONFIG_FB_TILEBLITTING is not set
-# CONFIG_FB_TMIO is not set
-# CONFIG_FB_TRIDENT is not set
-# CONFIG_FB_UDL is not set
-# CONFIG_FB_UVESA is not set
-# CONFIG_FB_VGA16 is not set
-# CONFIG_FB_VIA is not set
-# CONFIG_FB_VIRTUAL is not set
-# CONFIG_FB_VOODOO1 is not set
-# CONFIG_FB_VT8623 is not set
-# CONFIG_FB_XGI is not set
-# CONFIG_FCOE is not set
-# CONFIG_FCOE_FNIC is not set
-# CONFIG_FDDI is not set
-# CONFIG_FEALNX is not set
-# CONFIG_FENCE_TRACE is not set
-# CONFIG_FHANDLE is not set
-CONFIG_FIB_RULES=y
-CONFIG_FILE_LOCKING=y
-# CONFIG_FIND_BIT_BENCHMARK is not set
-# CONFIG_FIREWIRE is not set
-# CONFIG_FIREWIRE_NOSY is not set
-# CONFIG_FIREWIRE_SERIAL is not set
-# CONFIG_FIRMWARE_EDID is not set
-# CONFIG_FIRMWARE_IN_KERNEL is not set
-# CONFIG_FIRMWARE_MEMMAP is not set
-# CONFIG_FIXED_PHY is not set
-CONFIG_FLATMEM=y
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_FLAT_NODE_MEM_MAP=y
-# CONFIG_FM10K is not set
-# CONFIG_FMC is not set
-# CONFIG_FORCEDETH is not set
-CONFIG_FORCE_MAX_ZONEORDER=11
-CONFIG_FORTIFY_SOURCE=y
-# CONFIG_FPGA is not set
-# CONFIG_FRAMEBUFFER_CONSOLE is not set
-# CONFIG_FRAMEBUFFER_CONSOLE_DEFERRED_TAKEOVER is not set
-# CONFIG_FRAME_POINTER is not set
-CONFIG_FRAME_WARN=1024
-# CONFIG_FREEZER is not set
-# CONFIG_FRONTSWAP is not set
-# CONFIG_FSCACHE is not set
-# CONFIG_FSI is not set
-# CONFIG_FSL_EDMA is not set
-# CONFIG_FSL_ERRATUM_A008585 is not set
-# CONFIG_FSL_MC_BUS is not set
-# CONFIG_FSL_PQ_MDIO is not set
-# CONFIG_FSL_XGMAC_MDIO is not set
-CONFIG_FSNOTIFY=y
-# CONFIG_FS_DAX is not set
-# CONFIG_FS_ENCRYPTION is not set
-# CONFIG_FS_POSIX_ACL is not set
-# CONFIG_FTGMAC100 is not set
-# CONFIG_FTL is not set
-# CONFIG_FTMAC100 is not set
-# CONFIG_FTRACE is not set
-# CONFIG_FTRACE_STARTUP_TEST is not set
-# CONFIG_FTR_FIXUP_SELFTEST is not set
-# CONFIG_FTWDT010_WATCHDOG is not set
-# CONFIG_FUJITSU_ES is not set
-# CONFIG_FUJITSU_LAPTOP is not set
-# CONFIG_FUJITSU_TABLET is not set
-# CONFIG_FUNCTION_TRACER is not set
-# CONFIG_FUSE_FS is not set
-# CONFIG_FUSION is not set
-# CONFIG_FUSION_FC is not set
-# CONFIG_FUSION_SAS is not set
-# CONFIG_FUSION_SPI is not set
-CONFIG_FUTEX=y
-CONFIG_FUTEX_PI=y
-# CONFIG_FW_CFG_SYSFS is not set
-CONFIG_FW_LOADER=y
-CONFIG_FW_LOADER_USER_HELPER=y
-CONFIG_FW_LOADER_USER_HELPER_FALLBACK=y
-CONFIG_GACT_PROB=y
-# CONFIG_GADGET_UAC1 is not set
-# CONFIG_GAMEPORT is not set
-# CONFIG_GATEWORKS_GW16083 is not set
-# CONFIG_GCC_PLUGINS is not set
-CONFIG_GCC_VERSION=80300
-# CONFIG_GCOV is not set
-# CONFIG_GCOV_KERNEL is not set
-# CONFIG_GDB_SCRIPTS is not set
-# CONFIG_GEMINI_ETHERNET is not set
-# CONFIG_GENERIC_ADC_BATTERY is not set
-# CONFIG_GENERIC_ADC_THERMAL is not set
-CONFIG_GENERIC_CALIBRATE_DELAY=y
-# CONFIG_GENERIC_CPU_DEVICES is not set
-CONFIG_GENERIC_HWEIGHT=y
-# CONFIG_GENERIC_IRQ_DEBUGFS is not set
-CONFIG_GENERIC_IRQ_PROBE=y
-CONFIG_GENERIC_NET_UTILS=y
-# CONFIG_GENERIC_PHY is not set
-# CONFIG_GENEVE is not set
-# CONFIG_GENWQE is not set
-# CONFIG_GFS2_FS is not set
-# CONFIG_GIGASET_CAPI is not set
-# CONFIG_GIGASET_DEBUG is not set
-# CONFIG_GIGASET_DUMMYLL is not set
-# CONFIG_GLOB_SELFTEST is not set
-# CONFIG_GNSS is not set
-# CONFIG_GOLDFISH is not set
-# CONFIG_GOOGLE_FIRMWARE is not set
-# CONFIG_GP2AP020A00F is not set
-# CONFIG_GPD_POCKET_FAN is not set
-# CONFIG_GPIOLIB is not set
-CONFIG_GPIOLIB_FASTPATH_LIMIT=512
-# CONFIG_GPIO_104_DIO_48E is not set
-# CONFIG_GPIO_104_IDIO_16 is not set
-# CONFIG_GPIO_104_IDI_48 is not set
-# CONFIG_GPIO_74X164 is not set
-# CONFIG_GPIO_74XX_MMIO is not set
-# CONFIG_GPIO_ADNP is not set
-# CONFIG_GPIO_ADP5588 is not set
-# CONFIG_GPIO_ALTERA is not set
-# CONFIG_GPIO_AMD8111 is not set
-# CONFIG_GPIO_AMDPT is not set
-# CONFIG_GPIO_BCM_KONA is not set
-# CONFIG_GPIO_BT8XX is not set
-# CONFIG_GPIO_CS5535 is not set
-# CONFIG_GPIO_DWAPB is not set
-# CONFIG_GPIO_EM is not set
-# CONFIG_GPIO_EXAR is not set
-# CONFIG_GPIO_F7188X is not set
-# CONFIG_GPIO_FTGPIO010 is not set
-# CONFIG_GPIO_GENERIC_PLATFORM is not set
-# CONFIG_GPIO_GPIO_MM is not set
-# CONFIG_GPIO_GRGPIO is not set
-# CONFIG_GPIO_HLWD is not set
-# CONFIG_GPIO_ICH is not set
-# CONFIG_GPIO_IT87 is not set
-# CONFIG_GPIO_LYNXPOINT is not set
-# CONFIG_GPIO_MAX3191X is not set
-# CONFIG_GPIO_MAX7300 is not set
-# CONFIG_GPIO_MAX7301 is not set
-# CONFIG_GPIO_MAX732X is not set
-# CONFIG_GPIO_MB86S7X is not set
-# CONFIG_GPIO_MC33880 is not set
-# CONFIG_GPIO_MCP23S08 is not set
-# CONFIG_GPIO_ML_IOH is not set
-# CONFIG_GPIO_MOCKUP is not set
-# CONFIG_GPIO_MPC8XXX is not set
-# CONFIG_GPIO_PCA953X is not set
-# CONFIG_GPIO_PCF857X is not set
-# CONFIG_GPIO_PCH is not set
-# CONFIG_GPIO_PCIE_IDIO_24 is not set
-# CONFIG_GPIO_PCI_IDIO_16 is not set
-# CONFIG_GPIO_PISOSR is not set
-# CONFIG_GPIO_PL061 is not set
-# CONFIG_GPIO_RCAR is not set
-# CONFIG_GPIO_RDC321X is not set
-# CONFIG_GPIO_SCH is not set
-# CONFIG_GPIO_SCH311X is not set
-# CONFIG_GPIO_SX150X is not set
-# CONFIG_GPIO_SYSCON is not set
-# CONFIG_GPIO_SYSFS is not set
-# CONFIG_GPIO_TPIC2810 is not set
-# CONFIG_GPIO_TS4900 is not set
-# CONFIG_GPIO_TS5500 is not set
-# CONFIG_GPIO_VX855 is not set
-# CONFIG_GPIO_WATCHDOG is not set
-# CONFIG_GPIO_WINBOND is not set
-# CONFIG_GPIO_WS16C48 is not set
-# CONFIG_GPIO_XGENE is not set
-# CONFIG_GPIO_XILINX is not set
-# CONFIG_GPIO_XRA1403 is not set
-# CONFIG_GPIO_ZEVIO is not set
-# CONFIG_GPIO_ZX is not set
-# CONFIG_GREENASIA_FF is not set
-# CONFIG_GREYBUS is not set
-# CONFIG_GS_FPGABOOT is not set
-# CONFIG_GTP is not set
-# CONFIG_GUP_BENCHMARK is not set
-# CONFIG_HAMACHI is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_HAPPYMEAL is not set
-CONFIG_HARDENED_USERCOPY=y
-# CONFIG_HARDENED_USERCOPY_FALLBACK is not set
-# CONFIG_HARDENED_USERCOPY_PAGESPAN is not set
-CONFIG_HARDEN_EL2_VECTORS=y
-# CONFIG_HARDLOCKUP_DETECTOR is not set
-# CONFIG_HAVE_AOUT is not set
-CONFIG_HAVE_ARCH_HARDENED_USERCOPY=y
-# CONFIG_HAVE_ARCH_HASH is not set
-CONFIG_HAVE_ARCH_MMAP_RND_BITS=y
-# CONFIG_HAVE_ARCH_VMAP_STACK is not set
-CONFIG_HAVE_ARCH_WITHIN_STACK_FRAMES=y
-# CONFIG_HAVE_ARM_ARCH_TIMER is not set
-CONFIG_HAVE_EXIT_THREAD=y
-CONFIG_HAVE_GCC_PLUGINS=y
-CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=y
-CONFIG_HAVE_KERNEL_BZIP2=y
-CONFIG_HAVE_KERNEL_CAT=y
-CONFIG_HAVE_KERNEL_GZIP=y
-CONFIG_HAVE_KERNEL_LZ4=y
-CONFIG_HAVE_KERNEL_LZMA=y
-CONFIG_HAVE_KERNEL_LZO=y
-CONFIG_HAVE_KERNEL_XZ=y
-CONFIG_HAVE_KPROBES=y
-CONFIG_HAVE_KRETPROBES=y
-CONFIG_HAVE_NMI=y
-CONFIG_HAVE_STACKPROTECTOR=y
-# CONFIG_HCALL_STATS is not set
-# CONFIG_HDC100X is not set
-# CONFIG_HDLC is not set
-# CONFIG_HDLC_CISCO is not set
-# CONFIG_HDLC_FR is not set
-# CONFIG_HDLC_PPP is not set
-# CONFIG_HDLC_RAW is not set
-# CONFIG_HDLC_RAW_ETH is not set
-# CONFIG_HDMI_LPE_AUDIO is not set
-# CONFIG_HDQ_MASTER_OMAP is not set
-# CONFIG_HEADERS_CHECK is not set
-# CONFIG_HERMES is not set
-# CONFIG_HFSPLUS_FS is not set
-# CONFIG_HFSPLUS_FS_POSIX_ACL is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_HFS_FS_POSIX_ACL is not set
-# CONFIG_HI8435 is not set
-# CONFIG_HIBERNATION is not set
-# CONFIG_HID is not set
-# CONFIG_HIDRAW is not set
-# CONFIG_HID_A4TECH is not set
-# CONFIG_HID_ACCUTOUCH is not set
-# CONFIG_HID_ACRUX is not set
-# CONFIG_HID_ACRUX_FF is not set
-# CONFIG_HID_ALPS is not set
-# CONFIG_HID_APPLE is not set
-# CONFIG_HID_APPLEIR is not set
-# CONFIG_HID_ASUS is not set
-# CONFIG_HID_AUREAL is not set
-# CONFIG_HID_BATTERY_STRENGTH is not set
-# CONFIG_HID_BELKIN is not set
-# CONFIG_HID_BETOP_FF is not set
-# CONFIG_HID_BIGBEN_FF is not set
-# CONFIG_HID_CHERRY is not set
-# CONFIG_HID_CHICONY is not set
-# CONFIG_HID_CMEDIA is not set
-# CONFIG_HID_CORSAIR is not set
-# CONFIG_HID_COUGAR is not set
-# CONFIG_HID_CP2112 is not set
-# CONFIG_HID_CYPRESS is not set
-# CONFIG_HID_DRAGONRISE is not set
-# CONFIG_HID_ELAN is not set
-# CONFIG_HID_ELECOM is not set
-# CONFIG_HID_ELO is not set
-# CONFIG_HID_EMS_FF is not set
-# CONFIG_HID_EZKEY is not set
-# CONFIG_HID_GEMBIRD is not set
-# CONFIG_HID_GENERIC is not set
-# CONFIG_HID_GFRM is not set
-# CONFIG_HID_GOOGLE_HAMMER is not set
-# CONFIG_HID_GREENASIA is not set
-# CONFIG_HID_GT683R is not set
-# CONFIG_HID_GYRATION is not set
-# CONFIG_HID_HOLTEK is not set
-# CONFIG_HID_ICADE is not set
-# CONFIG_HID_ITE is not set
-# CONFIG_HID_JABRA is not set
-# CONFIG_HID_KENSINGTON is not set
-# CONFIG_HID_KEYTOUCH is not set
-# CONFIG_HID_KYE is not set
-# CONFIG_HID_LCPOWER is not set
-# CONFIG_HID_LED is not set
-# CONFIG_HID_LENOVO is not set
-# CONFIG_HID_LOGITECH is not set
-# CONFIG_HID_LOGITECH_DJ is not set
-# CONFIG_HID_LOGITECH_HIDPP is not set
-# CONFIG_HID_MAGICMOUSE is not set
-# CONFIG_HID_MAYFLASH is not set
-# CONFIG_HID_MICROSOFT is not set
-# CONFIG_HID_MONTEREY is not set
-# CONFIG_HID_MULTITOUCH is not set
-# CONFIG_HID_NTI is not set
-# CONFIG_HID_NTRIG is not set
-# CONFIG_HID_ORTEK is not set
-# CONFIG_HID_PANTHERLORD is not set
-# CONFIG_HID_PENMOUNT is not set
-# CONFIG_HID_PETALYNX is not set
-# CONFIG_HID_PICOLCD is not set
-# CONFIG_HID_PID is not set
-# CONFIG_HID_PLANTRONICS is not set
-# CONFIG_HID_PRIMAX is not set
-# CONFIG_HID_PRODIKEYS is not set
-# CONFIG_HID_REDRAGON is not set
-# CONFIG_HID_RETRODE is not set
-# CONFIG_HID_RMI is not set
-# CONFIG_HID_ROCCAT is not set
-# CONFIG_HID_SAITEK is not set
-# CONFIG_HID_SAMSUNG is not set
-# CONFIG_HID_SENSOR_HUB is not set
-# CONFIG_HID_SMARTJOYPLUS is not set
-# CONFIG_HID_SONY is not set
-# CONFIG_HID_SPEEDLINK is not set
-# CONFIG_HID_STEAM is not set
-# CONFIG_HID_STEELSERIES is not set
-# CONFIG_HID_SUNPLUS is not set
-# CONFIG_HID_THINGM is not set
-# CONFIG_HID_THRUSTMASTER is not set
-# CONFIG_HID_TIVO is not set
-# CONFIG_HID_TOPSEED is not set
-# CONFIG_HID_TWINHAN is not set
-# CONFIG_HID_UCLOGIC is not set
-# CONFIG_HID_UDRAW_PS3 is not set
-# CONFIG_HID_WACOM is not set
-# CONFIG_HID_WALTOP is not set
-# CONFIG_HID_WIIMOTE is not set
-# CONFIG_HID_XINMO is not set
-# CONFIG_HID_ZEROPLUS is not set
-# CONFIG_HID_ZYDACRON is not set
-# CONFIG_HIGHMEM is not set
-CONFIG_HIGH_RES_TIMERS=y
-# CONFIG_HINIC is not set
-# CONFIG_HIP04_ETH is not set
-# CONFIG_HIPPI is not set
-# CONFIG_HISILICON_ERRATUM_161010101 is not set
-# CONFIG_HISILICON_ERRATUM_161600802 is not set
-# CONFIG_HISI_FEMAC is not set
-# CONFIG_HIX5HD2_GMAC is not set
-# CONFIG_HMC6352 is not set
-# CONFIG_HNS is not set
-# CONFIG_HNS3 is not set
-# CONFIG_HNS_DSAF is not set
-# CONFIG_HNS_ENET is not set
-# CONFIG_HOSTAP is not set
-# CONFIG_HOSTAP_CS is not set
-# CONFIG_HOSTAP_PCI is not set
-# CONFIG_HOSTAP_PLX is not set
-# CONFIG_HOTPLUG_CPU is not set
-# CONFIG_HOTPLUG_PCI is not set
-# CONFIG_HP03 is not set
-# CONFIG_HP100 is not set
-# CONFIG_HP206C is not set
-CONFIG_HPET_MMAP_DEFAULT=y
-# CONFIG_HPFS_FS is not set
-# CONFIG_HP_ILO is not set
-# CONFIG_HP_WIRELESS is not set
-# CONFIG_HSI is not set
-# CONFIG_HSR is not set
-# CONFIG_HTC_EGPIO is not set
-# CONFIG_HTC_I2CPLD is not set
-# CONFIG_HTC_PASIC3 is not set
-# CONFIG_HTS221 is not set
-# CONFIG_HTU21 is not set
-# CONFIG_HUGETLB_PAGE is not set
-# CONFIG_HVC_DCC is not set
-# CONFIG_HVC_UDBG is not set
-# CONFIG_HWLAT_TRACER is not set
-# CONFIG_HWMON is not set
-# CONFIG_HWMON_DEBUG_CHIP is not set
-# CONFIG_HWMON_VID is not set
-# CONFIG_HWSPINLOCK is not set
-# CONFIG_HWSPINLOCK_OMAP is not set
-CONFIG_HW_PERF_EVENTS=y
-# CONFIG_HW_RANDOM is not set
-# CONFIG_HW_RANDOM_AMD is not set
-# CONFIG_HW_RANDOM_ATMEL is not set
-# CONFIG_HW_RANDOM_CAVIUM is not set
-# CONFIG_HW_RANDOM_EXYNOS is not set
-# CONFIG_HW_RANDOM_GEODE is not set
-# CONFIG_HW_RANDOM_INTEL is not set
-# CONFIG_HW_RANDOM_IPROC_RNG200 is not set
-# CONFIG_HW_RANDOM_OMAP is not set
-# CONFIG_HW_RANDOM_OMAP3_ROM is not set
-# CONFIG_HW_RANDOM_PPC4XX is not set
-# CONFIG_HW_RANDOM_TIMERIOMEM is not set
-CONFIG_HW_RANDOM_TPM=y
-# CONFIG_HW_RANDOM_VIA is not set
-# CONFIG_HW_RANDOM_VIRTIO is not set
-# CONFIG_HX711 is not set
-# CONFIG_HYPERV is not set
-# CONFIG_HYPERV_TSCPAGE is not set
-# CONFIG_HYSDN is not set
-CONFIG_HZ=100
-CONFIG_HZ_100=y
-# CONFIG_HZ_1000 is not set
-# CONFIG_HZ_1024 is not set
-# CONFIG_HZ_128 is not set
-# CONFIG_HZ_200 is not set
-# CONFIG_HZ_24 is not set
-# CONFIG_HZ_250 is not set
-# CONFIG_HZ_256 is not set
-# CONFIG_HZ_300 is not set
-# CONFIG_HZ_48 is not set
-# CONFIG_HZ_500 is not set
-# CONFIG_HZ_PERIODIC is not set
-# CONFIG_I2C is not set
-# CONFIG_I2C_ALGOBIT is not set
-# CONFIG_I2C_ALGOPCA is not set
-# CONFIG_I2C_ALGOPCF is not set
-# CONFIG_I2C_ALI1535 is not set
-# CONFIG_I2C_ALI1563 is not set
-# CONFIG_I2C_ALI15X3 is not set
-# CONFIG_I2C_AMD756 is not set
-# CONFIG_I2C_AMD8111 is not set
-# CONFIG_I2C_ARB_GPIO_CHALLENGE is not set
-# CONFIG_I2C_AU1550 is not set
-# CONFIG_I2C_BCM2835 is not set
-# CONFIG_I2C_BCM_IPROC is not set
-# CONFIG_I2C_CADENCE is not set
-# CONFIG_I2C_CBUS_GPIO is not set
-# CONFIG_I2C_CHARDEV is not set
-# CONFIG_I2C_COMPAT is not set
-# CONFIG_I2C_DEBUG_ALGO is not set
-# CONFIG_I2C_DEBUG_BUS is not set
-# CONFIG_I2C_DEBUG_CORE is not set
-# CONFIG_I2C_DEMUX_PINCTRL is not set
-# CONFIG_I2C_DESIGNWARE_PCI is not set
-# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
-# CONFIG_I2C_DIOLAN_U2C is not set
-# CONFIG_I2C_EG20T is not set
-# CONFIG_I2C_ELEKTOR is not set
-# CONFIG_I2C_EMEV2 is not set
-# CONFIG_I2C_GPIO is not set
-# CONFIG_I2C_GPIO_FAULT_INJECTOR is not set
-# CONFIG_I2C_HELPER_AUTO is not set
-# CONFIG_I2C_HID is not set
-# CONFIG_I2C_I801 is not set
-# CONFIG_I2C_IBM_IIC is not set
-# CONFIG_I2C_IMG is not set
-# CONFIG_I2C_ISCH is not set
-# CONFIG_I2C_ISMT is not set
-# CONFIG_I2C_MLXCPLD is not set
-# CONFIG_I2C_MPC is not set
-# CONFIG_I2C_MUX is not set
-# CONFIG_I2C_MUX_GPIO is not set
-# CONFIG_I2C_MUX_GPMUX is not set
-# CONFIG_I2C_MUX_LTC4306 is not set
-# CONFIG_I2C_MUX_MLXCPLD is not set
-# CONFIG_I2C_MUX_PCA9541 is not set
-# CONFIG_I2C_MUX_PCA954x is not set
-# CONFIG_I2C_MUX_PINCTRL is not set
-# CONFIG_I2C_MUX_REG is not set
-# CONFIG_I2C_MV64XXX is not set
-# CONFIG_I2C_NFORCE2 is not set
-# CONFIG_I2C_NOMADIK is not set
-# CONFIG_I2C_OCORES is not set
-# CONFIG_I2C_OCTEON is not set
-# CONFIG_I2C_PARPORT is not set
-# CONFIG_I2C_PARPORT_LIGHT is not set
-# CONFIG_I2C_PCA_ISA is not set
-# CONFIG_I2C_PCA_PLATFORM is not set
-# CONFIG_I2C_PIIX4 is not set
-# CONFIG_I2C_PXA_PCI is not set
-# CONFIG_I2C_RCAR is not set
-# CONFIG_I2C_RK3X is not set
-# CONFIG_I2C_ROBOTFUZZ_OSIF is not set
-# CONFIG_I2C_S3C2410 is not set
-# CONFIG_I2C_SCMI is not set
-# CONFIG_I2C_SH_MOBILE is not set
-# CONFIG_I2C_SIMTEC is not set
-# CONFIG_I2C_SIS5595 is not set
-# CONFIG_I2C_SIS630 is not set
-# CONFIG_I2C_SIS96X is not set
-# CONFIG_I2C_SLAVE is not set
-# CONFIG_I2C_SMBUS is not set
-# CONFIG_I2C_STUB is not set
-# CONFIG_I2C_TAOS_EVM is not set
-# CONFIG_I2C_THUNDERX is not set
-# CONFIG_I2C_TINY_USB is not set
-# CONFIG_I2C_VERSATILE is not set
-# CONFIG_I2C_VIA is not set
-# CONFIG_I2C_VIAPRO is not set
-# CONFIG_I2C_XILINX is not set
-# CONFIG_I40E is not set
-# CONFIG_I40EVF is not set
-# CONFIG_I6300ESB_WDT is not set
-# CONFIG_I82092 is not set
-# CONFIG_I82365 is not set
-# CONFIG_IAQCORE is not set
-# CONFIG_IBM_ASM is not set
-# CONFIG_IBM_EMAC_DEBUG is not set
-# CONFIG_IBM_EMAC_EMAC4 is not set
-# CONFIG_IBM_EMAC_MAL_CLR_ICINTSTAT is not set
-# CONFIG_IBM_EMAC_MAL_COMMON_ERR is not set
-# CONFIG_IBM_EMAC_NO_FLOW_CTRL is not set
-# CONFIG_IBM_EMAC_RGMII is not set
-# CONFIG_IBM_EMAC_TAH is not set
-# CONFIG_IBM_EMAC_ZMII is not set
-# CONFIG_ICE is not set
-# CONFIG_ICPLUS_PHY is not set
-# CONFIG_ICS932S401 is not set
-# CONFIG_IDE is not set
-# CONFIG_IDEAPAD_LAPTOP is not set
-# CONFIG_IDE_GD is not set
-# CONFIG_IDE_PROC_FS is not set
-# CONFIG_IDE_TASK_IOCTL is not set
-# CONFIG_IDLE_PAGE_TRACKING is not set
-# CONFIG_IEEE802154 is not set
-# CONFIG_IEEE802154_ADF7242 is not set
-# CONFIG_IEEE802154_ATUSB is not set
-# CONFIG_IEEE802154_CA8210 is not set
-# CONFIG_IEEE802154_HWSIM is not set
-# CONFIG_IEEE802154_MCR20A is not set
-# CONFIG_IFB is not set
-# CONFIG_IGB is not set
-# CONFIG_IGBVF is not set
-# CONFIG_IIO is not set
-# CONFIG_IIO_BUFFER_CB is not set
-# CONFIG_IIO_BUFFER_HW_CONSUMER is not set
-# CONFIG_IIO_CONFIGFS is not set
-CONFIG_IIO_CONSUMERS_PER_TRIGGER=2
-# CONFIG_IIO_CROS_EC_ACCEL_LEGACY is not set
-# CONFIG_IIO_INTERRUPT_TRIGGER is not set
-# CONFIG_IIO_MUX is not set
-# CONFIG_IIO_PERIODIC_RTC_TRIGGER is not set
-# CONFIG_IIO_RESCALE is not set
-# CONFIG_IIO_SIMPLE_DUMMY is not set
-# CONFIG_IIO_SSP_SENSORHUB is not set
-# CONFIG_IIO_ST_ACCEL_3AXIS is not set
-# CONFIG_IIO_ST_GYRO_3AXIS is not set
-# CONFIG_IIO_ST_LSM6DSX is not set
-# CONFIG_IIO_ST_MAGN_3AXIS is not set
-# CONFIG_IIO_ST_PRESS is not set
-# CONFIG_IIO_SW_DEVICE is not set
-# CONFIG_IIO_SW_TRIGGER is not set
-# CONFIG_IIO_SYSFS_TRIGGER is not set
-# CONFIG_IKCONFIG is not set
-# CONFIG_IKCONFIG_PROC is not set
-# CONFIG_IMAGE_CMDLINE_HACK is not set
-# CONFIG_IMGPDC_WDT is not set
-# CONFIG_IMG_MDC_DMA is not set
-# CONFIG_IMX7D_ADC is not set
-# CONFIG_IMX_IPUV3_CORE is not set
-# CONFIG_IMX_THERMAL is not set
-# CONFIG_INA2XX_ADC is not set
-# CONFIG_INDIRECT_PIO is not set
-CONFIG_INET=y
-# CONFIG_INET6_AH is not set
-# CONFIG_INET6_ESP is not set
-# CONFIG_INET6_IPCOMP is not set
-# CONFIG_INET6_TUNNEL is not set
-# CONFIG_INET6_XFRM_MODE_BEET is not set
-# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
-# CONFIG_INET6_XFRM_MODE_TRANSPORT is not set
-# CONFIG_INET6_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET6_XFRM_TUNNEL is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_DIAG is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_LRO is not set
-# CONFIG_INET_TCP_DIAG is not set
-# CONFIG_INET_TUNNEL is not set
-# CONFIG_INET_UDP_DIAG is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_TUNNEL is not set
-# CONFIG_INFINIBAND is not set
-# CONFIG_INFTL is not set
-CONFIG_INIT_ENV_ARG_LIMIT=32
-# CONFIG_INLINE_READ_LOCK is not set
-# CONFIG_INLINE_READ_LOCK_BH is not set
-# CONFIG_INLINE_READ_LOCK_IRQ is not set
-# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
-# CONFIG_INLINE_READ_TRYLOCK is not set
-CONFIG_INLINE_READ_UNLOCK=y
-# CONFIG_INLINE_READ_UNLOCK_BH is not set
-CONFIG_INLINE_READ_UNLOCK_IRQ=y
-# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
-# CONFIG_INLINE_SPIN_LOCK is not set
-# CONFIG_INLINE_SPIN_LOCK_BH is not set
-# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
-# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
-# CONFIG_INLINE_SPIN_TRYLOCK is not set
-# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
-# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
-CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
-# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
-# CONFIG_INLINE_WRITE_LOCK is not set
-# CONFIG_INLINE_WRITE_LOCK_BH is not set
-# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
-# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
-# CONFIG_INLINE_WRITE_TRYLOCK is not set
-CONFIG_INLINE_WRITE_UNLOCK=y
-# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
-CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
-# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
-CONFIG_INOTIFY_USER=y
-# CONFIG_INPUT is not set
-# CONFIG_INPUT_AD714X is not set
-# CONFIG_INPUT_ADXL34X is not set
-# CONFIG_INPUT_APANEL is not set
-# CONFIG_INPUT_ATI_REMOTE2 is not set
-# CONFIG_INPUT_ATLAS_BTNS is not set
-# CONFIG_INPUT_ATMEL_CAPTOUCH is not set
-# CONFIG_INPUT_AXP20X_PEK is not set
-# CONFIG_INPUT_BMA150 is not set
-# CONFIG_INPUT_CM109 is not set
-# CONFIG_INPUT_CMA3000 is not set
-# CONFIG_INPUT_DRV260X_HAPTICS is not set
-# CONFIG_INPUT_DRV2665_HAPTICS is not set
-# CONFIG_INPUT_DRV2667_HAPTICS is not set
-# CONFIG_INPUT_E3X0_BUTTON is not set
-# CONFIG_INPUT_EVBUG is not set
-# CONFIG_INPUT_EVDEV is not set
-# CONFIG_INPUT_FF_MEMLESS is not set
-# CONFIG_INPUT_GP2A is not set
-# CONFIG_INPUT_GPIO_BEEPER is not set
-# CONFIG_INPUT_GPIO_DECODER is not set
-# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
-# CONFIG_INPUT_GPIO_TILT_POLLED is not set
-# CONFIG_INPUT_IDEAPAD_SLIDEBAR is not set
-# CONFIG_INPUT_IMS_PCU is not set
-# CONFIG_INPUT_JOYDEV is not set
-# CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_KEYSPAN_REMOTE is not set
-# CONFIG_INPUT_KXTJ9 is not set
-# CONFIG_INPUT_LEDS is not set
-# CONFIG_INPUT_MATRIXKMAP is not set
-# CONFIG_INPUT_MAX8997_HAPTIC is not set
-CONFIG_INPUT_MISC=y
-# CONFIG_INPUT_MMA8450 is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_MPU3050 is not set
-# CONFIG_INPUT_PALMAS_PWRBUTTON is not set
-# CONFIG_INPUT_PCF8574 is not set
-# CONFIG_INPUT_PCSPKR is not set
-# CONFIG_INPUT_POLLDEV is not set
-# CONFIG_INPUT_POWERMATE is not set
-# CONFIG_INPUT_PWM_BEEPER is not set
-# CONFIG_INPUT_PWM_VIBRA is not set
-# CONFIG_INPUT_REGULATOR_HAPTIC is not set
-# CONFIG_INPUT_SOC_BUTTON_ARRAY is not set
-# CONFIG_INPUT_SPARSEKMAP is not set
-# CONFIG_INPUT_TABLET is not set
-# CONFIG_INPUT_TOUCHSCREEN is not set
-# CONFIG_INPUT_TPS65218_PWRBUTTON is not set
-# CONFIG_INPUT_TWL4030_PWRBUTTON is not set
-# CONFIG_INPUT_TWL4030_VIBRA is not set
-# CONFIG_INPUT_TWL6040_VIBRA is not set
-# CONFIG_INPUT_UINPUT is not set
-# CONFIG_INPUT_WISTRON_BTNS is not set
-# CONFIG_INPUT_YEALINK is not set
-# CONFIG_INT340X_THERMAL is not set
-# CONFIG_INTEL_ATOMISP2_PM is not set
-# CONFIG_INTEL_CHT_INT33FE is not set
-# CONFIG_INTEL_HID_EVENT is not set
-# CONFIG_INTEL_IDLE is not set
-# CONFIG_INTEL_IDMA64 is not set
-# CONFIG_INTEL_IOATDMA is not set
-# CONFIG_INTEL_ISH_HID is not set
-# CONFIG_INTEL_MEI is not set
-# CONFIG_INTEL_MEI_ME is not set
-# CONFIG_INTEL_MEI_TXE is not set
-# CONFIG_INTEL_MIC_CARD is not set
-# CONFIG_INTEL_MIC_HOST is not set
-# CONFIG_INTEL_MID_PTI is not set
-# CONFIG_INTEL_OAKTRAIL is not set
-# CONFIG_INTEL_PMC_CORE is not set
-# CONFIG_INTEL_PUNIT_IPC is not set
-# CONFIG_INTEL_RST is not set
-# CONFIG_INTEL_SMARTCONNECT is not set
-# CONFIG_INTEL_SOC_PMIC is not set
-# CONFIG_INTEL_SOC_PMIC_CHTDC_TI is not set
-# CONFIG_INTEL_SOC_PMIC_CHTWC is not set
-# CONFIG_INTEL_TH is not set
-# CONFIG_INTEL_VBTN is not set
-# CONFIG_INTEL_XWAY_PHY is not set
-# CONFIG_INTERVAL_TREE_TEST is not set
-# CONFIG_INV_MPU6050_I2C is not set
-# CONFIG_INV_MPU6050_IIO is not set
-# CONFIG_INV_MPU6050_SPI is not set
-# CONFIG_IOMMU_SUPPORT is not set
-# CONFIG_IOSCHED_BFQ is not set
-# CONFIG_IOSCHED_CFQ is not set
-CONFIG_IOSCHED_DEADLINE=y
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IO_STRICT_DEVMEM=y
-# CONFIG_IP17XX_PHY is not set
-# CONFIG_IP6_NF_FILTER is not set
-# CONFIG_IP6_NF_IPTABLES is not set
-# CONFIG_IP6_NF_MANGLE is not set
-# CONFIG_IP6_NF_MATCH_AH is not set
-# CONFIG_IP6_NF_MATCH_EUI64 is not set
-# CONFIG_IP6_NF_MATCH_FRAG is not set
-# CONFIG_IP6_NF_MATCH_HL is not set
-# CONFIG_IP6_NF_MATCH_IPV6HEADER is not set
-# CONFIG_IP6_NF_MATCH_MH is not set
-# CONFIG_IP6_NF_MATCH_OPTS is not set
-# CONFIG_IP6_NF_MATCH_RPFILTER is not set
-# CONFIG_IP6_NF_MATCH_RT is not set
-# CONFIG_IP6_NF_MATCH_SRH is not set
-# CONFIG_IP6_NF_NAT is not set
-# CONFIG_IP6_NF_RAW is not set
-# CONFIG_IP6_NF_SECURITY is not set
-# CONFIG_IP6_NF_TARGET_HL is not set
-# CONFIG_IP6_NF_TARGET_REJECT is not set
-# CONFIG_IP6_NF_TARGET_SYNPROXY is not set
-# CONFIG_IPACK_BUS is not set
-# CONFIG_IPC_NS is not set
-# CONFIG_IPMI_HANDLER is not set
-# CONFIG_IPV6 is not set
-# CONFIG_IPV6_FOU is not set
-# CONFIG_IPV6_FOU_TUNNEL is not set
-# CONFIG_IPV6_ILA is not set
-# CONFIG_IPV6_MIP6 is not set
-# CONFIG_IPV6_MROUTE is not set
-# CONFIG_IPV6_MROUTE_MULTIPLE_TABLES is not set
-# CONFIG_IPV6_MULTIPLE_TABLES is not set
-CONFIG_IPV6_NDISC_NODETYPE=y
-# CONFIG_IPV6_OPTIMISTIC_DAD is not set
-# CONFIG_IPV6_ROUTER_PREF is not set
-# CONFIG_IPV6_ROUTE_INFO is not set
-# CONFIG_IPV6_SEG6_HMAC is not set
-# CONFIG_IPV6_SEG6_LWTUNNEL is not set
-# CONFIG_IPV6_SIT is not set
-# CONFIG_IPV6_SIT_6RD is not set
-# CONFIG_IPV6_TUNNEL is not set
-# CONFIG_IPV6_VTI is not set
-# CONFIG_IPVLAN is not set
-# CONFIG_IPW2100 is not set
-# CONFIG_IPW2100_DEBUG is not set
-CONFIG_IPW2100_MONITOR=y
-# CONFIG_IPW2200 is not set
-# CONFIG_IPW2200_DEBUG is not set
-CONFIG_IPW2200_MONITOR=y
-# CONFIG_IPW2200_PROMISCUOUS is not set
-# CONFIG_IPW2200_QOS is not set
-# CONFIG_IPW2200_RADIOTAP is not set
-# CONFIG_IPWIRELESS is not set
-# CONFIG_IPX is not set
-CONFIG_IP_ADVANCED_ROUTER=y
-# CONFIG_IP_DCCP is not set
-# CONFIG_IP_FIB_TRIE_STATS is not set
-# CONFIG_IP_MROUTE is not set
-CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
-CONFIG_IP_MULTICAST=y
-CONFIG_IP_MULTIPLE_TABLES=y
-# CONFIG_IP_NF_ARPFILTER is not set
-# CONFIG_IP_NF_ARPTABLES is not set
-# CONFIG_IP_NF_ARP_MANGLE is not set
-# CONFIG_IP_NF_FILTER is not set
-# CONFIG_IP_NF_IPTABLES is not set
-# CONFIG_IP_NF_MANGLE is not set
-# CONFIG_IP_NF_MATCH_AH is not set
-# CONFIG_IP_NF_MATCH_ECN is not set
-# CONFIG_IP_NF_MATCH_RPFILTER is not set
-# CONFIG_IP_NF_MATCH_TTL is not set
-# CONFIG_IP_NF_RAW is not set
-# CONFIG_IP_NF_SECURITY is not set
-# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
-# CONFIG_IP_NF_TARGET_ECN is not set
-# CONFIG_IP_NF_TARGET_MASQUERADE is not set
-# CONFIG_IP_NF_TARGET_NETMAP is not set
-# CONFIG_IP_NF_TARGET_REDIRECT is not set
-# CONFIG_IP_NF_TARGET_REJECT is not set
-# CONFIG_IP_NF_TARGET_SYNPROXY is not set
-# CONFIG_IP_NF_TARGET_TTL is not set
-# CONFIG_IP_PIMSM_V1 is not set
-# CONFIG_IP_PIMSM_V2 is not set
-# CONFIG_IP_PNP is not set
-CONFIG_IP_ROUTE_MULTIPATH=y
-CONFIG_IP_ROUTE_VERBOSE=y
-# CONFIG_IP_SCTP is not set
-# CONFIG_IP_SET is not set
-# CONFIG_IP_SET_HASH_IPMAC is not set
-# CONFIG_IP_VS is not set
-# CONFIG_IP_VS_MH is not set
-CONFIG_IP_VS_MH_TAB_INDEX=10
-# CONFIG_IRDA is not set
-# CONFIG_IRQSOFF_TRACER is not set
-# CONFIG_IRQ_ALL_CPUS is not set
-# CONFIG_IRQ_DOMAIN_DEBUG is not set
-# CONFIG_IRQ_POLL is not set
-# CONFIG_IRQ_TIME_ACCOUNTING is not set
-# CONFIG_IR_GPIO_CIR is not set
-# CONFIG_IR_HIX5HD2 is not set
-# CONFIG_IR_IGORPLUGUSB is not set
-# CONFIG_IR_IGUANA is not set
-# CONFIG_IR_IMG is not set
-# CONFIG_IR_IMON is not set
-# CONFIG_IR_JVC_DECODER is not set
-# CONFIG_IR_LIRC_CODEC is not set
-# CONFIG_IR_MCEUSB is not set
-# CONFIG_IR_NEC_DECODER is not set
-# CONFIG_IR_RC5_DECODER is not set
-# CONFIG_IR_RC6_DECODER is not set
-# CONFIG_IR_REDRAT3 is not set
-# CONFIG_IR_SONY_DECODER is not set
-# CONFIG_IR_STREAMZAP is not set
-# CONFIG_IR_TTUSBIR is not set
-# CONFIG_ISA_BUS is not set
-# CONFIG_ISA_BUS_API is not set
-# CONFIG_ISCSI_BOOT_SYSFS is not set
-# CONFIG_ISCSI_TCP is not set
-CONFIG_ISDN=y
-# CONFIG_ISDN_AUDIO is not set
-# CONFIG_ISDN_CAPI is not set
-# CONFIG_ISDN_CAPI_CAPIDRV is not set
-# CONFIG_ISDN_DIVERSION is not set
-# CONFIG_ISDN_DRV_ACT2000 is not set
-# CONFIG_ISDN_DRV_GIGASET is not set
-# CONFIG_ISDN_DRV_HISAX is not set
-# CONFIG_ISDN_DRV_ICN is not set
-# CONFIG_ISDN_DRV_LOOP is not set
-# CONFIG_ISDN_DRV_PCBIT is not set
-# CONFIG_ISDN_DRV_SC is not set
-# CONFIG_ISDN_I4L is not set
-# CONFIG_ISL29003 is not set
-# CONFIG_ISL29020 is not set
-# CONFIG_ISL29125 is not set
-# CONFIG_ISL29501 is not set
-# CONFIG_ISO9660_FS is not set
-# CONFIG_ISS4xx is not set
-# CONFIG_ITG3200 is not set
-# CONFIG_IWL3945 is not set
-# CONFIG_IWLWIFI is not set
-# CONFIG_IXGB is not set
-# CONFIG_IXGBE is not set
-# CONFIG_IXGBEVF is not set
-# CONFIG_JAILHOUSE_GUEST is not set
-# CONFIG_JBD2_DEBUG is not set
-# CONFIG_JFFS2_CMODE_FAVOURLZO is not set
-# CONFIG_JFFS2_CMODE_NONE is not set
-CONFIG_JFFS2_CMODE_PRIORITY=y
-# CONFIG_JFFS2_CMODE_SIZE is not set
-CONFIG_JFFS2_COMPRESSION_OPTIONS=y
-CONFIG_JFFS2_FS=y
-CONFIG_JFFS2_FS_DEBUG=0
-# CONFIG_JFFS2_FS_POSIX_ACL is not set
-# CONFIG_JFFS2_FS_SECURITY is not set
-# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
-CONFIG_JFFS2_FS_WRITEBUFFER=y
-CONFIG_JFFS2_FS_XATTR=y
-CONFIG_JFFS2_LZMA=y
-# CONFIG_JFFS2_LZO is not set
-CONFIG_JFFS2_RTIME=y
-# CONFIG_JFFS2_RUBIN is not set
-CONFIG_JFFS2_SUMMARY=y
-# CONFIG_JFFS2_ZLIB is not set
-# CONFIG_JFS_DEBUG is not set
-# CONFIG_JFS_FS is not set
-# CONFIG_JFS_POSIX_ACL is not set
-# CONFIG_JFS_SECURITY is not set
-# CONFIG_JFS_STATISTICS is not set
-# CONFIG_JME is not set
-CONFIG_JOLIET=y
-# CONFIG_JSA1212 is not set
-# CONFIG_JUMP_LABEL is not set
-# CONFIG_KALLSYMS is not set
-# CONFIG_KALLSYMS_ABSOLUTE_PERCPU is not set
-# CONFIG_KALLSYMS_ALL is not set
-CONFIG_KALLSYMS_BASE_RELATIVE=y
-# CONFIG_KALLSYMS_UNCOMPRESSED is not set
-# CONFIG_KARMA_PARTITION is not set
-# CONFIG_KASAN is not set
-# CONFIG_KCOV is not set
-# CONFIG_KERNEL_BZIP2 is not set
-# CONFIG_KERNEL_CAT is not set
-# CONFIG_KERNEL_GZIP is not set
-# CONFIG_KERNEL_LZ4 is not set
-# CONFIG_KERNEL_LZMA is not set
-# CONFIG_KERNEL_LZO is not set
-CONFIG_KERNEL_MODE_NEON=y
-CONFIG_KERNEL_XZ=y
-CONFIG_KERNFS=y
-# CONFIG_KEXEC is not set
-# CONFIG_KEXEC_FILE is not set
-# CONFIG_KEYBOARD_ADC is not set
-# CONFIG_KEYBOARD_ADP5588 is not set
-# CONFIG_KEYBOARD_ADP5589 is not set
-# CONFIG_KEYBOARD_ATKBD is not set
-# CONFIG_KEYBOARD_BCM is not set
-# CONFIG_KEYBOARD_CAP11XX is not set
-# CONFIG_KEYBOARD_DLINK_DIR685 is not set
-# CONFIG_KEYBOARD_GPIO is not set
-# CONFIG_KEYBOARD_GPIO_POLLED is not set
-# CONFIG_KEYBOARD_LKKBD is not set
-# CONFIG_KEYBOARD_LM8323 is not set
-# CONFIG_KEYBOARD_LM8333 is not set
-# CONFIG_KEYBOARD_MATRIX is not set
-# CONFIG_KEYBOARD_MAX7359 is not set
-# CONFIG_KEYBOARD_MCS is not set
-# CONFIG_KEYBOARD_MPR121 is not set
-# CONFIG_KEYBOARD_NEWTON is not set
-# CONFIG_KEYBOARD_OMAP4 is not set
-# CONFIG_KEYBOARD_OPENCORES is not set
-# CONFIG_KEYBOARD_PXA27x is not set
-# CONFIG_KEYBOARD_QT1070 is not set
-# CONFIG_KEYBOARD_QT2160 is not set
-# CONFIG_KEYBOARD_SAMSUNG is not set
-# CONFIG_KEYBOARD_SH_KEYSC is not set
-# CONFIG_KEYBOARD_SNVS_PWRKEY is not set
-# CONFIG_KEYBOARD_STMPE is not set
-# CONFIG_KEYBOARD_STOWAWAY is not set
-# CONFIG_KEYBOARD_SUNKBD is not set
-# CONFIG_KEYBOARD_TCA6416 is not set
-# CONFIG_KEYBOARD_TCA8418 is not set
-# CONFIG_KEYBOARD_TEGRA is not set
-# CONFIG_KEYBOARD_TM2_TOUCHKEY is not set
-# CONFIG_KEYBOARD_TWL4030 is not set
-# CONFIG_KEYBOARD_XTKBD is not set
-# CONFIG_KEYS is not set
-# CONFIG_KEY_DH_OPERATIONS is not set
-# CONFIG_KGDB is not set
-# CONFIG_KMEMCHECK is not set
-# CONFIG_KMX61 is not set
-# CONFIG_KPROBES is not set
-# CONFIG_KPROBES_SANITY_TEST is not set
-# CONFIG_KS7010 is not set
-# CONFIG_KS8842 is not set
-# CONFIG_KS8851 is not set
-# CONFIG_KS8851_MLL is not set
-# CONFIG_KSM is not set
-# CONFIG_KSZ884X_PCI is not set
-CONFIG_KUSER_HELPERS=y
-# CONFIG_KVM_AMD is not set
-# CONFIG_KVM_GUEST is not set
-# CONFIG_KVM_INTEL is not set
-# CONFIG_KXCJK1013 is not set
-# CONFIG_KXSD9 is not set
-# CONFIG_L2TP is not set
-# CONFIG_L2TP_ETH is not set
-# CONFIG_L2TP_IP is not set
-# CONFIG_L2TP_V3 is not set
-# CONFIG_LAN743X is not set
-# CONFIG_LANMEDIA is not set
-# CONFIG_LANTIQ is not set
-# CONFIG_LAPB is not set
-# CONFIG_LASAT is not set
-# CONFIG_LATENCYTOP is not set
-# CONFIG_LATTICE_ECP3_CONFIG is not set
-CONFIG_LBDAF=y
-# CONFIG_LCD_AMS369FG06 is not set
-# CONFIG_LCD_HX8357 is not set
-# CONFIG_LCD_ILI922X is not set
-# CONFIG_LCD_ILI9320 is not set
-# CONFIG_LCD_L4F00242T03 is not set
-# CONFIG_LCD_LD9040 is not set
-# CONFIG_LCD_LMS283GF05 is not set
-# CONFIG_LCD_LMS501KF03 is not set
-# CONFIG_LCD_LTV350QV is not set
-# CONFIG_LCD_OTM3225A is not set
-# CONFIG_LCD_S6E63M0 is not set
-# CONFIG_LCD_TDO24M is not set
-# CONFIG_LCD_VGG2432A4 is not set
-CONFIG_LDISC_AUTOLOAD=y
-# CONFIG_LDM_PARTITION is not set
-CONFIG_LD_DEAD_CODE_DATA_ELIMINATION=y
-# CONFIG_LEDS_APU is not set
-# CONFIG_LEDS_BCM6328 is not set
-# CONFIG_LEDS_BCM6358 is not set
-# CONFIG_LEDS_BD2802 is not set
-# CONFIG_LEDS_BLINKM is not set
-CONFIG_LEDS_BRIGHTNESS_HW_CHANGED=y
-CONFIG_LEDS_CLASS=y
-# CONFIG_LEDS_CLASS_FLASH is not set
-# CONFIG_LEDS_CR0014114 is not set
-# CONFIG_LEDS_DAC124S085 is not set
-# CONFIG_LEDS_GPIO is not set
-# CONFIG_LEDS_INTEL_SS4200 is not set
-# CONFIG_LEDS_IS31FL319X is not set
-# CONFIG_LEDS_IS31FL32XX is not set
-# CONFIG_LEDS_LM3530 is not set
-# CONFIG_LEDS_LM355x is not set
-# CONFIG_LEDS_LM3642 is not set
-# CONFIG_LEDS_LM3692X is not set
-# CONFIG_LEDS_LP3944 is not set
-# CONFIG_LEDS_LP3952 is not set
-# CONFIG_LEDS_LP5521 is not set
-# CONFIG_LEDS_LP5523 is not set
-# CONFIG_LEDS_LP5562 is not set
-# CONFIG_LEDS_LP8501 is not set
-# CONFIG_LEDS_LP8860 is not set
-# CONFIG_LEDS_LT3593 is not set
-# CONFIG_LEDS_MLXCPLD is not set
-# CONFIG_LEDS_MLXREG is not set
-# CONFIG_LEDS_NIC78BX is not set
-# CONFIG_LEDS_NS2 is not set
-# CONFIG_LEDS_OT200 is not set
-# CONFIG_LEDS_PCA9532 is not set
-# CONFIG_LEDS_PCA955X is not set
-# CONFIG_LEDS_PCA963X is not set
-# CONFIG_LEDS_PWM is not set
-# CONFIG_LEDS_REGULATOR is not set
-# CONFIG_LEDS_SYSCON is not set
-# CONFIG_LEDS_TCA6507 is not set
-# CONFIG_LEDS_TLC591XX is not set
-CONFIG_LEDS_TRIGGERS=y
-# CONFIG_LEDS_TRIGGER_ACTIVITY is not set
-# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
-# CONFIG_LEDS_TRIGGER_CAMERA is not set
-# CONFIG_LEDS_TRIGGER_CPU is not set
-CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
-# CONFIG_LEDS_TRIGGER_DISK is not set
-# CONFIG_LEDS_TRIGGER_GPIO is not set
-# CONFIG_LEDS_TRIGGER_HEARTBEAT is not set
-# CONFIG_LEDS_TRIGGER_IDE_DISK is not set
-# CONFIG_LEDS_TRIGGER_MTD is not set
-CONFIG_LEDS_TRIGGER_NETDEV=y
-# CONFIG_LEDS_TRIGGER_ONESHOT is not set
-# CONFIG_LEDS_TRIGGER_PANIC is not set
-CONFIG_LEDS_TRIGGER_TIMER=y
-# CONFIG_LEDS_TRIGGER_TRANSIENT is not set
-# CONFIG_LEDS_USER is not set
-# CONFIG_LED_TRIGGER_PHY is not set
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_LGUEST is not set
-# CONFIG_LIB80211 is not set
-# CONFIG_LIB80211_CRYPT_CCMP is not set
-# CONFIG_LIB80211_CRYPT_TKIP is not set
-# CONFIG_LIB80211_CRYPT_WEP is not set
-# CONFIG_LIB80211_DEBUG is not set
-# CONFIG_LIBCRC32C is not set
-# CONFIG_LIBERTAS is not set
-# CONFIG_LIBERTAS_THINFIRM is not set
-# CONFIG_LIBERTAS_USB is not set
-# CONFIG_LIBFC is not set
-# CONFIG_LIBFCOE is not set
-# CONFIG_LIBIPW_DEBUG is not set
-# CONFIG_LIBNVDIMM is not set
-# CONFIG_LIDAR_LITE_V2 is not set
-# CONFIG_LIQUIDIO is not set
-# CONFIG_LIQUIDIO_VF is not set
-# CONFIG_LIS3L02DQ is not set
-# CONFIG_LKDTM is not set
-CONFIG_LLC=y
-# CONFIG_LLC2 is not set
-# CONFIG_LMP91000 is not set
-# CONFIG_LNET is not set
-CONFIG_LOCALVERSION=""
-# CONFIG_LOCALVERSION_AUTO is not set
-# CONFIG_LOCKD is not set
-CONFIG_LOCKDEP_SUPPORT=y
-CONFIG_LOCKD_V4=y
-# CONFIG_LOCKUP_DETECTOR is not set
-# CONFIG_LOCK_STAT is not set
-# CONFIG_LOCK_TORTURE_TEST is not set
-# CONFIG_LOGFS is not set
-# CONFIG_LOGIG940_FF is not set
-# CONFIG_LOGIRUMBLEPAD2_FF is not set
-# CONFIG_LOGITECH_FF is not set
-# CONFIG_LOGIWHEELS_FF is not set
-# CONFIG_LOGO is not set
-CONFIG_LOG_BUF_SHIFT=17
-CONFIG_LOG_CPU_MAX_BUF_SHIFT=12
-# CONFIG_LOONGSON_MC146818 is not set
-# CONFIG_LPC_ICH is not set
-# CONFIG_LPC_SCH is not set
-# CONFIG_LP_CONSOLE is not set
-# CONFIG_LSI_ET1011C_PHY is not set
-# CONFIG_LTC2471 is not set
-# CONFIG_LTC2485 is not set
-# CONFIG_LTC2497 is not set
-# CONFIG_LTC2632 is not set
-# CONFIG_LTE_GDM724X is not set
-# CONFIG_LTPC is not set
-# CONFIG_LTR501 is not set
-# CONFIG_LUSTRE_FS is not set
-# CONFIG_LV0104CS is not set
-# CONFIG_LWTUNNEL is not set
-# CONFIG_LXT_PHY is not set
-# CONFIG_LZ4HC_COMPRESS is not set
-# CONFIG_LZ4_COMPRESS is not set
-# CONFIG_LZ4_DECOMPRESS is not set
-CONFIG_LZMA_COMPRESS=y
-CONFIG_LZMA_DECOMPRESS=y
-# CONFIG_LZO_COMPRESS is not set
-# CONFIG_LZO_DECOMPRESS is not set
-# CONFIG_M62332 is not set
-# CONFIG_MAC80211 is not set
-# CONFIG_MAC80211_MESSAGE_TRACING is not set
-CONFIG_MAC80211_STA_HASH_MAX_SIZE=0
-# CONFIG_MACB is not set
-# CONFIG_MACH_ASM9260 is not set
-# CONFIG_MACH_DECSTATION is not set
-# CONFIG_MACH_INGENIC is not set
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_JZ4740 is not set
-# CONFIG_MACH_LOONGSON32 is not set
-# CONFIG_MACH_LOONGSON64 is not set
-# CONFIG_MACH_PIC32 is not set
-# CONFIG_MACH_PISTACHIO is not set
-# CONFIG_MACH_TX39XX is not set
-# CONFIG_MACH_TX49XX is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_MACH_XILFPGA is not set
-# CONFIG_MACINTOSH_DRIVERS is not set
-# CONFIG_MACSEC is not set
-# CONFIG_MACVLAN is not set
-# CONFIG_MACVTAP is not set
-# CONFIG_MAC_EMUMOUSEBTN is not set
-# CONFIG_MAC_PARTITION is not set
-# CONFIG_MAG3110 is not set
-# CONFIG_MAGIC_SYSRQ is not set
-CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x1
-# CONFIG_MAGIC_SYSRQ_SERIAL is not set
-# CONFIG_MAILBOX is not set
-# CONFIG_MANAGER_SBS is not set
-# CONFIG_MANDATORY_FILE_LOCKING is not set
-# CONFIG_MANGLE_BOOTARGS is not set
-# CONFIG_MARVELL_10G_PHY is not set
-# CONFIG_MARVELL_PHY is not set
-# CONFIG_MAX1027 is not set
-# CONFIG_MAX11100 is not set
-# CONFIG_MAX1118 is not set
-# CONFIG_MAX1363 is not set
-# CONFIG_MAX30100 is not set
-# CONFIG_MAX30102 is not set
-# CONFIG_MAX44000 is not set
-# CONFIG_MAX517 is not set
-# CONFIG_MAX5481 is not set
-# CONFIG_MAX5487 is not set
-# CONFIG_MAX5821 is not set
-# CONFIG_MAX63XX_WATCHDOG is not set
-# CONFIG_MAX9611 is not set
-# CONFIG_MAXIM_THERMOCOUPLE is not set
-CONFIG_MAY_USE_DEVLINK=y
-# CONFIG_MC3230 is not set
-# CONFIG_MCB is not set
-# CONFIG_MCP320X is not set
-# CONFIG_MCP3422 is not set
-# CONFIG_MCP4018 is not set
-# CONFIG_MCP4131 is not set
-# CONFIG_MCP4531 is not set
-# CONFIG_MCP4725 is not set
-# CONFIG_MCP4922 is not set
-# CONFIG_MCPM is not set
-# CONFIG_MD is not set
-# CONFIG_MDIO_BCM_UNIMAC is not set
-# CONFIG_MDIO_BITBANG is not set
-# CONFIG_MDIO_BUS_MUX_GPIO is not set
-# CONFIG_MDIO_BUS_MUX_MMIOREG is not set
-# CONFIG_MDIO_DEVICE is not set
-# CONFIG_MDIO_HISI_FEMAC is not set
-# CONFIG_MDIO_MSCC_MIIM is not set
-# CONFIG_MDIO_OCTEON is not set
-# CONFIG_MDIO_THUNDER is not set
-# CONFIG_MD_FAULTY is not set
-# CONFIG_MEDIA_ANALOG_TV_SUPPORT is not set
-# CONFIG_MEDIA_ATTACH is not set
-# CONFIG_MEDIA_CAMERA_SUPPORT is not set
-# CONFIG_MEDIA_CEC_SUPPORT is not set
-# CONFIG_MEDIA_CONTROLLER is not set
-# CONFIG_MEDIA_DIGITAL_TV_SUPPORT is not set
-# CONFIG_MEDIA_PCI_SUPPORT is not set
-# CONFIG_MEDIA_RADIO_SUPPORT is not set
-# CONFIG_MEDIA_RC_SUPPORT is not set
-# CONFIG_MEDIA_SDR_SUPPORT is not set
-# CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
-# CONFIG_MEDIA_SUPPORT is not set
-# CONFIG_MEDIA_USB_SUPPORT is not set
-# CONFIG_MEGARAID_LEGACY is not set
-# CONFIG_MEGARAID_NEWGEN is not set
-# CONFIG_MEGARAID_SAS is not set
-# CONFIG_MELLANOX_PLATFORM is not set
-CONFIG_MEMBARRIER=y
-# CONFIG_MEMORY is not set
-# CONFIG_MEMORY_FAILURE is not set
-# CONFIG_MEMSTICK is not set
-# CONFIG_MEMTEST is not set
-# CONFIG_MEN_A21_WDT is not set
-# CONFIG_MESON_SM is not set
-CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
-# CONFIG_MFD_88PM800 is not set
-# CONFIG_MFD_88PM805 is not set
-# CONFIG_MFD_88PM860X is not set
-# CONFIG_MFD_AAT2870_CORE is not set
-# CONFIG_MFD_ACT8945A is not set
-# CONFIG_MFD_ARIZONA_I2C is not set
-# CONFIG_MFD_ARIZONA_SPI is not set
-# CONFIG_MFD_AS3711 is not set
-# CONFIG_MFD_AS3722 is not set
-# CONFIG_MFD_ASIC3 is not set
-# CONFIG_MFD_ATMEL_FLEXCOM is not set
-# CONFIG_MFD_ATMEL_HLCDC is not set
-# CONFIG_MFD_AXP20X is not set
-# CONFIG_MFD_AXP20X_I2C is not set
-# CONFIG_MFD_BCM590XX is not set
-# CONFIG_MFD_BD9571MWV is not set
-# CONFIG_MFD_CORE is not set
-# CONFIG_MFD_CPCAP is not set
-# CONFIG_MFD_CROS_EC is not set
-# CONFIG_MFD_CS5535 is not set
-# CONFIG_MFD_DA9052_I2C is not set
-# CONFIG_MFD_DA9052_SPI is not set
-# CONFIG_MFD_DA9055 is not set
-# CONFIG_MFD_DA9062 is not set
-# CONFIG_MFD_DA9063 is not set
-# CONFIG_MFD_DA9150 is not set
-# CONFIG_MFD_DLN2 is not set
-# CONFIG_MFD_EXYNOS_LPASS is not set
-# CONFIG_MFD_HI6421_PMIC is not set
-# CONFIG_MFD_INTEL_QUARK_I2C_GPIO is not set
-# CONFIG_MFD_JANZ_CMODIO is not set
-# CONFIG_MFD_KEMPLD is not set
-# CONFIG_MFD_LM3533 is not set
-# CONFIG_MFD_LP3943 is not set
-# CONFIG_MFD_LP8788 is not set
-# CONFIG_MFD_MADERA is not set
-# CONFIG_MFD_MAX14577 is not set
-# CONFIG_MFD_MAX77620 is not set
-# CONFIG_MFD_MAX77686 is not set
-# CONFIG_MFD_MAX77693 is not set
-# CONFIG_MFD_MAX77843 is not set
-# CONFIG_MFD_MAX8907 is not set
-# CONFIG_MFD_MAX8925 is not set
-# CONFIG_MFD_MAX8997 is not set
-# CONFIG_MFD_MAX8998 is not set
-# CONFIG_MFD_MC13XXX is not set
-# CONFIG_MFD_MC13XXX_I2C is not set
-# CONFIG_MFD_MC13XXX_SPI is not set
-# CONFIG_MFD_MENF21BMC is not set
-# CONFIG_MFD_MT6397 is not set
-# CONFIG_MFD_OMAP_USB_HOST is not set
-# CONFIG_MFD_PALMAS is not set
-# CONFIG_MFD_PCF50633 is not set
-# CONFIG_MFD_PM8921_CORE is not set
-# CONFIG_MFD_PM8XXX is not set
-# CONFIG_MFD_RC5T583 is not set
-# CONFIG_MFD_RDC321X is not set
-# CONFIG_MFD_RETU is not set
-# CONFIG_MFD_RK808 is not set
-# CONFIG_MFD_RN5T618 is not set
-# CONFIG_MFD_ROHM_BD718XX is not set
-# CONFIG_MFD_RT5033 is not set
-# CONFIG_MFD_RTSX_PCI is not set
-# CONFIG_MFD_RTSX_USB is not set
-# CONFIG_MFD_SEC_CORE is not set
-# CONFIG_MFD_SI476X_CORE is not set
-# CONFIG_MFD_SKY81452 is not set
-# CONFIG_MFD_SM501 is not set
-# CONFIG_MFD_SMSC is not set
-# CONFIG_MFD_STMPE is not set
-# CONFIG_MFD_SYSCON is not set
-# CONFIG_MFD_T7L66XB is not set
-# CONFIG_MFD_TC3589X is not set
-# CONFIG_MFD_TC6387XB is not set
-# CONFIG_MFD_TC6393XB is not set
-# CONFIG_MFD_TIMBERDALE is not set
-# CONFIG_MFD_TI_AM335X_TSCADC is not set
-# CONFIG_MFD_TI_LMU is not set
-# CONFIG_MFD_TI_LP873X is not set
-# CONFIG_MFD_TI_LP87565 is not set
-# CONFIG_MFD_TMIO is not set
-# CONFIG_MFD_TPS65086 is not set
-# CONFIG_MFD_TPS65090 is not set
-# CONFIG_MFD_TPS65217 is not set
-# CONFIG_MFD_TPS65218 is not set
-# CONFIG_MFD_TPS6586X is not set
-# CONFIG_MFD_TPS65910 is not set
-# CONFIG_MFD_TPS65912 is not set
-# CONFIG_MFD_TPS65912_I2C is not set
-# CONFIG_MFD_TPS65912_SPI is not set
-# CONFIG_MFD_TPS68470 is not set
-# CONFIG_MFD_TPS80031 is not set
-# CONFIG_MFD_VIPERBOARD is not set
-# CONFIG_MFD_VX855 is not set
-# CONFIG_MFD_WL1273_CORE is not set
-# CONFIG_MFD_WM831X is not set
-# CONFIG_MFD_WM831X_I2C is not set
-# CONFIG_MFD_WM831X_SPI is not set
-# CONFIG_MFD_WM8350_I2C is not set
-# CONFIG_MFD_WM8400 is not set
-# CONFIG_MFD_WM8994 is not set
-# CONFIG_MG_DISK is not set
-# CONFIG_MICREL_KS8995MA is not set
-# CONFIG_MICREL_PHY is not set
-# CONFIG_MICROCHIP_KSZ is not set
-# CONFIG_MICROCHIP_PHY is not set
-# CONFIG_MICROCHIP_T1_PHY is not set
-# CONFIG_MICROSEMI_PHY is not set
-# CONFIG_MIGRATION is not set
-CONFIG_MII=y
-# CONFIG_MIKROTIK_RB532 is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_MINIX_FS_NATIVE_ENDIAN is not set
-# CONFIG_MINIX_SUBPARTITION is not set
-# CONFIG_MIPS_ALCHEMY is not set
-# CONFIG_MIPS_CDMM is not set
-# CONFIG_MIPS_COBALT is not set
-# CONFIG_MIPS_FPU_EMULATOR is not set
-# CONFIG_MIPS_GENERIC is not set
-# CONFIG_MIPS_MALTA is not set
-# CONFIG_MIPS_O32_FP64_SUPPORT is not set
-# CONFIG_MIPS_PARAVIRT is not set
-# CONFIG_MIPS_PLATFORM_DEVICES is not set
-# CONFIG_MIPS_SEAD3 is not set
-CONFIG_MISC_FILESYSTEMS=y
-# CONFIG_MISC_RTSX_PCI is not set
-# CONFIG_MISC_RTSX_USB is not set
-# CONFIG_MISDN is not set
-# CONFIG_MISDN_AVMFRITZ is not set
-# CONFIG_MISDN_HFCPCI is not set
-# CONFIG_MISDN_HFCUSB is not set
-# CONFIG_MISDN_INFINEON is not set
-# CONFIG_MISDN_NETJET is not set
-# CONFIG_MISDN_SPEEDFAX is not set
-# CONFIG_MISDN_W6692 is not set
-# CONFIG_MKISS is not set
-# CONFIG_MLX4_CORE is not set
-# CONFIG_MLX4_EN is not set
-# CONFIG_MLX5_CORE is not set
-# CONFIG_MLX90614 is not set
-# CONFIG_MLX90632 is not set
-# CONFIG_MLXFW is not set
-# CONFIG_MLXSW_CORE is not set
-# CONFIG_MLX_CPLD_PLATFORM is not set
-# CONFIG_MLX_PLATFORM is not set
-# CONFIG_MMA7455_I2C is not set
-# CONFIG_MMA7455_SPI is not set
-# CONFIG_MMA7660 is not set
-# CONFIG_MMA8452 is not set
-# CONFIG_MMA9551 is not set
-# CONFIG_MMA9553 is not set
-# CONFIG_MMC is not set
-# CONFIG_MMC35240 is not set
-# CONFIG_MMC_ARMMMCI is not set
-# CONFIG_MMC_AU1X is not set
-# CONFIG_MMC_BLOCK is not set
-CONFIG_MMC_BLOCK_BOUNCE=y
-CONFIG_MMC_BLOCK_MINORS=8
-# CONFIG_MMC_CAVIUM_THUNDERX is not set
-# CONFIG_MMC_CB710 is not set
-# CONFIG_MMC_CQHCI is not set
-# CONFIG_MMC_DEBUG is not set
-# CONFIG_MMC_DW is not set
-# CONFIG_MMC_MTK is not set
-# CONFIG_MMC_MVSDIO is not set
-# CONFIG_MMC_S3C is not set
-# CONFIG_MMC_SDHCI is not set
-# CONFIG_MMC_SDHCI_ACPI is not set
-# CONFIG_MMC_SDHCI_BCM_KONA is not set
-# CONFIG_MMC_SDHCI_CADENCE is not set
-# CONFIG_MMC_SDHCI_F_SDH30 is not set
-# CONFIG_MMC_SDHCI_IPROC is not set
-# CONFIG_MMC_SDHCI_MSM is not set
-# CONFIG_MMC_SDHCI_OF_ARASAN is not set
-# CONFIG_MMC_SDHCI_OF_AT91 is not set
-# CONFIG_MMC_SDHCI_OF_DWCMSHC is not set
-# CONFIG_MMC_SDHCI_OF_ESDHC is not set
-# CONFIG_MMC_SDHCI_OF_HLWD is not set
-# CONFIG_MMC_SDHCI_OMAP is not set
-# CONFIG_MMC_SDHCI_PXAV2 is not set
-# CONFIG_MMC_SDHCI_PXAV3 is not set
-# CONFIG_MMC_SDHCI_S3C is not set
-# CONFIG_MMC_SDHCI_XENON is not set
-# CONFIG_MMC_SDRICOH_CS is not set
-# CONFIG_MMC_SPI is not set
-# CONFIG_MMC_TEST is not set
-# CONFIG_MMC_TOSHIBA_PCI is not set
-# CONFIG_MMC_USDHI6ROL0 is not set
-# CONFIG_MMC_USHC is not set
-# CONFIG_MMC_VIA_SDMMC is not set
-# CONFIG_MMC_VUB300 is not set
-# CONFIG_MMIOTRACE is not set
-CONFIG_MMU=y
-CONFIG_MODULES=y
-# CONFIG_MODULE_COMPRESS is not set
-# CONFIG_MODULE_FORCE_LOAD is not set
-# CONFIG_MODULE_FORCE_UNLOAD is not set
-# CONFIG_MODULE_SIG is not set
-# CONFIG_MODULE_SRCVERSION_ALL is not set
-CONFIG_MODULE_STRIPPED=y
-CONFIG_MODULE_UNLOAD=y
-# CONFIG_MODVERSIONS is not set
-# CONFIG_MOST is not set
-# CONFIG_MOUSE_APPLETOUCH is not set
-# CONFIG_MOUSE_ELAN_I2C is not set
-# CONFIG_MOUSE_GPIO is not set
-# CONFIG_MOUSE_INPORT is not set
-# CONFIG_MOUSE_LOGIBM is not set
-# CONFIG_MOUSE_PC110PAD is not set
-# CONFIG_MOUSE_PS2_FOCALTECH is not set
-# CONFIG_MOUSE_PS2_SENTELIC is not set
-# CONFIG_MOUSE_SYNAPTICS_I2C is not set
-# CONFIG_MOUSE_SYNAPTICS_USB is not set
-# CONFIG_MPL115 is not set
-# CONFIG_MPL115_I2C is not set
-# CONFIG_MPL115_SPI is not set
-# CONFIG_MPL3115 is not set
-# CONFIG_MPLS is not set
-# CONFIG_MPU3050_I2C is not set
-# CONFIG_MQ_IOSCHED_DEADLINE is not set
-# CONFIG_MQ_IOSCHED_KYBER is not set
-# CONFIG_MS5611 is not set
-# CONFIG_MS5637 is not set
-# CONFIG_MSCC_OCELOT_SWITCH is not set
-# CONFIG_MSDOS_FS is not set
-CONFIG_MSDOS_PARTITION=y
-# CONFIG_MSI_BITMAP_SELFTEST is not set
-# CONFIG_MSI_LAPTOP is not set
-CONFIG_MTD=y
-# CONFIG_MTD_ABSENT is not set
-# CONFIG_MTD_AFS_PARTS is not set
-# CONFIG_MTD_AR7_PARTS is not set
-CONFIG_MTD_BLKDEVS=y
-CONFIG_MTD_BLOCK=y
-# CONFIG_MTD_BLOCK2MTD is not set
-CONFIG_MTD_CFI=y
-# CONFIG_MTD_CFI_ADV_OPTIONS is not set
-CONFIG_MTD_CFI_AMDSTD=y
-# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
-CONFIG_MTD_CFI_I1=y
-CONFIG_MTD_CFI_I2=y
-# CONFIG_MTD_CFI_I4 is not set
-# CONFIG_MTD_CFI_I8 is not set
-CONFIG_MTD_CFI_INTELEXT=y
-# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
-CONFIG_MTD_CFI_NOSWAP=y
-# CONFIG_MTD_CFI_STAA is not set
-CONFIG_MTD_CFI_UTIL=y
-# CONFIG_MTD_CMDLINE_PARTS is not set
-CONFIG_MTD_COMPLEX_MAPPINGS=y
-# CONFIG_MTD_DATAFLASH is not set
-# CONFIG_MTD_DOCG3 is not set
-CONFIG_MTD_GEN_PROBE=y
-# CONFIG_MTD_GPIO_ADDR is not set
-# CONFIG_MTD_INTEL_VR_NOR is not set
-# CONFIG_MTD_JEDECPROBE is not set
-# CONFIG_MTD_LATCH_ADDR is not set
-# CONFIG_MTD_LPDDR is not set
-# CONFIG_MTD_LPDDR2_NVM is not set
-# CONFIG_MTD_M25P80 is not set
-CONFIG_MTD_MAP_BANK_WIDTH_1=y
-# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
-CONFIG_MTD_MAP_BANK_WIDTH_2=y
-# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
-CONFIG_MTD_MAP_BANK_WIDTH_4=y
-# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
-# CONFIG_MTD_MCHP23K256 is not set
-# CONFIG_MTD_MT81xx_NOR is not set
-# CONFIG_MTD_MTDRAM is not set
-# CONFIG_MTD_MYLOADER_PARTS is not set
-# CONFIG_MTD_NAND is not set
-# CONFIG_MTD_NAND_AMS_DELTA is not set
-# CONFIG_MTD_NAND_AR934X is not set
-# CONFIG_MTD_NAND_AR934X_HW_ECC is not set
-# CONFIG_MTD_NAND_ATMEL is not set
-# CONFIG_MTD_NAND_AU1550 is not set
-# CONFIG_MTD_NAND_BCH is not set
-# CONFIG_MTD_NAND_BF5XX is not set
-# CONFIG_MTD_NAND_BRCMNAND is not set
-# CONFIG_MTD_NAND_CAFE is not set
-# CONFIG_MTD_NAND_CM_X270 is not set
-# CONFIG_MTD_NAND_CS553X is not set
-# CONFIG_MTD_NAND_DAVINCI is not set
-# CONFIG_MTD_NAND_DENALI is not set
-# CONFIG_MTD_NAND_DENALI_DT is not set
-# CONFIG_MTD_NAND_DENALI_PCI is not set
-CONFIG_MTD_NAND_DENALI_SCRATCH_REG_ADDR=0xff108018
-# CONFIG_MTD_NAND_DISKONCHIP is not set
-# CONFIG_MTD_NAND_DOCG4 is not set
-# CONFIG_MTD_NAND_ECC is not set
-# CONFIG_MTD_NAND_ECC_BCH is not set
-# CONFIG_MTD_NAND_ECC_SMC is not set
-# CONFIG_MTD_NAND_FSL_ELBC is not set
-# CONFIG_MTD_NAND_FSL_IFC is not set
-# CONFIG_MTD_NAND_FSL_UPM is not set
-# CONFIG_MTD_NAND_FSMC is not set
-# CONFIG_MTD_NAND_GPIO is not set
-# CONFIG_MTD_NAND_GPMI_NAND is not set
-# CONFIG_MTD_NAND_HISI504 is not set
-CONFIG_MTD_NAND_IDS=y
-# CONFIG_MTD_NAND_JZ4740 is not set
-# CONFIG_MTD_NAND_MPC5121_NFC is not set
-# CONFIG_MTD_NAND_MTK is not set
-# CONFIG_MTD_NAND_MXC is not set
-# CONFIG_MTD_NAND_NANDSIM is not set
-# CONFIG_MTD_NAND_NDFC is not set
-# CONFIG_MTD_NAND_NUC900 is not set
-# CONFIG_MTD_NAND_OMAP2 is not set
-# CONFIG_MTD_NAND_OMAP_BCH_BUILD is not set
-# CONFIG_MTD_NAND_ORION is not set
-# CONFIG_MTD_NAND_PASEMI is not set
-# CONFIG_MTD_NAND_PLATFORM is not set
-# CONFIG_MTD_NAND_PXA3xx is not set
-# CONFIG_MTD_NAND_RB4XX is not set
-# CONFIG_MTD_NAND_RB750 is not set
-# CONFIG_MTD_NAND_RICOH is not set
-# CONFIG_MTD_NAND_S3C2410 is not set
-# CONFIG_MTD_NAND_SHARPSL is not set
-# CONFIG_MTD_NAND_SH_FLCTL is not set
-# CONFIG_MTD_NAND_SOCRATES is not set
-# CONFIG_MTD_NAND_TMIO is not set
-# CONFIG_MTD_NAND_TXX9NDFMC is not set
-CONFIG_MTD_OF_PARTS=y
-# CONFIG_MTD_ONENAND is not set
-# CONFIG_MTD_OOPS is not set
-# CONFIG_MTD_OTP is not set
-# CONFIG_MTD_PARTITIONED_MASTER is not set
-# CONFIG_MTD_PCI is not set
-# CONFIG_MTD_PCMCIA is not set
-# CONFIG_MTD_PHRAM is not set
-# CONFIG_MTD_PHYSMAP is not set
-# CONFIG_MTD_PHYSMAP_COMPAT is not set
-CONFIG_MTD_PHYSMAP_OF=y
-# CONFIG_MTD_PHYSMAP_OF_GEMINI is not set
-# CONFIG_MTD_PHYSMAP_OF_VERSATILE is not set
-# CONFIG_MTD_PLATRAM is not set
-# CONFIG_MTD_PMC551 is not set
-# CONFIG_MTD_RAM is not set
-CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK=-1
-# CONFIG_MTD_REDBOOT_PARTS is not set
-# CONFIG_MTD_REDBOOT_PARTS_READONLY is not set
-# CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED is not set
-# CONFIG_MTD_ROM is not set
-CONFIG_MTD_ROOTFS_ROOT_DEV=y
-# CONFIG_MTD_SLRAM is not set
-# CONFIG_MTD_SM_COMMON is not set
-# CONFIG_MTD_SPINAND_MT29F is not set
-# CONFIG_MTD_SPI_NAND is not set
-# CONFIG_MTD_SPI_NOR is not set
-# CONFIG_MTD_SPI_NOR_USE_4K_SECTORS is not set
-CONFIG_MTD_SPI_NOR_USE_4K_SECTORS_LIMIT=4096
-CONFIG_MTD_SPLIT=y
-# CONFIG_MTD_SPLIT_BRNIMAGE_FW is not set
-# CONFIG_MTD_SPLIT_EVA_FW is not set
-# CONFIG_MTD_SPLIT_FIRMWARE is not set
-CONFIG_MTD_SPLIT_FIRMWARE_NAME="firmware"
-# CONFIG_MTD_SPLIT_FIT_FW is not set
-# CONFIG_MTD_SPLIT_JIMAGE_FW is not set
-# CONFIG_MTD_SPLIT_LZMA_FW is not set
-# CONFIG_MTD_SPLIT_MINOR_FW is not set
-# CONFIG_MTD_SPLIT_SEAMA_FW is not set
-CONFIG_MTD_SPLIT_SQUASHFS_ROOT=y
-CONFIG_MTD_SPLIT_SUPPORT=y
-# CONFIG_MTD_SPLIT_TPLINK_FW is not set
-# CONFIG_MTD_SPLIT_TRX_FW is not set
-# CONFIG_MTD_SPLIT_UIMAGE_FW is not set
-# CONFIG_MTD_SPLIT_WRGG_FW is not set
-# CONFIG_MTD_SST25L is not set
-# CONFIG_MTD_SWAP is not set
-# CONFIG_MTD_TESTS is not set
-# CONFIG_MTD_UBI is not set
-# CONFIG_MTD_UIMAGE_SPLIT is not set
-# CONFIG_MTD_VIRT_CONCAT is not set
-# CONFIG_MTK_MMC is not set
-CONFIG_MULTIUSER=y
-# CONFIG_MUTEX_SPIN_ON_OWNER is not set
-# CONFIG_MV643XX_ETH is not set
-# CONFIG_MVMDIO is not set
-# CONFIG_MVNETA_BM is not set
-# CONFIG_MVSW61XX_PHY is not set
-# CONFIG_MVSWITCH_PHY is not set
-# CONFIG_MV_XOR_V2 is not set
-# CONFIG_MWAVE is not set
-# CONFIG_MWL8K is not set
-# CONFIG_MXC4005 is not set
-# CONFIG_MXC6255 is not set
-# CONFIG_MYRI10GE is not set
-# CONFIG_NAMESPACES is not set
-# CONFIG_NATIONAL_PHY is not set
-# CONFIG_NATSEMI is not set
-# CONFIG_NAU7802 is not set
-# CONFIG_NBPFAXI_DMA is not set
-# CONFIG_NCP_FS is not set
-# CONFIG_NE2000 is not set
-# CONFIG_NE2K_PCI is not set
-# CONFIG_NEC_MARKEINS is not set
-CONFIG_NET=y
-# CONFIG_NETCONSOLE is not set
-CONFIG_NETDEVICES=y
-# CONFIG_NETDEVSIM is not set
-# CONFIG_NETFILTER is not set
-# CONFIG_NETFILTER_ADVANCED is not set
-# CONFIG_NETFILTER_DEBUG is not set
-# CONFIG_NETFILTER_INGRESS is not set
-# CONFIG_NETFILTER_NETLINK is not set
-# CONFIG_NETFILTER_NETLINK_ACCT is not set
-# CONFIG_NETFILTER_NETLINK_GLUE_CT is not set
-# CONFIG_NETFILTER_NETLINK_LOG is not set
-# CONFIG_NETFILTER_NETLINK_OSF is not set
-# CONFIG_NETFILTER_NETLINK_QUEUE is not set
-# CONFIG_NETFILTER_XTABLES is not set
-# CONFIG_NETFILTER_XT_CONNMARK is not set
-# CONFIG_NETFILTER_XT_MARK is not set
-# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
-# CONFIG_NETFILTER_XT_MATCH_BPF is not set
-# CONFIG_NETFILTER_XT_MATCH_CGROUP is not set
-# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
-# CONFIG_NETFILTER_XT_MATCH_COMMENT is not set
-# CONFIG_NETFILTER_XT_MATCH_CONNBYTES is not set
-# CONFIG_NETFILTER_XT_MATCH_CONNLABEL is not set
-# CONFIG_NETFILTER_XT_MATCH_CONNLIMIT is not set
-# CONFIG_NETFILTER_XT_MATCH_CONNMARK is not set
-# CONFIG_NETFILTER_XT_MATCH_CONNTRACK is not set
-# CONFIG_NETFILTER_XT_MATCH_CPU is not set
-# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
-# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
-# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
-# CONFIG_NETFILTER_XT_MATCH_ECN is not set
-# CONFIG_NETFILTER_XT_MATCH_ESP is not set
-# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
-# CONFIG_NETFILTER_XT_MATCH_HELPER is not set
-# CONFIG_NETFILTER_XT_MATCH_HL is not set
-# CONFIG_NETFILTER_XT_MATCH_IPCOMP is not set
-# CONFIG_NETFILTER_XT_MATCH_IPRANGE is not set
-# CONFIG_NETFILTER_XT_MATCH_L2TP is not set
-# CONFIG_NETFILTER_XT_MATCH_LENGTH is not set
-# CONFIG_NETFILTER_XT_MATCH_LIMIT is not set
-# CONFIG_NETFILTER_XT_MATCH_MAC is not set
-# CONFIG_NETFILTER_XT_MATCH_MARK is not set
-# CONFIG_NETFILTER_XT_MATCH_MULTIPORT is not set
-# CONFIG_NETFILTER_XT_MATCH_NFACCT is not set
-# CONFIG_NETFILTER_XT_MATCH_OSF is not set
-# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
-# CONFIG_NETFILTER_XT_MATCH_PHYSDEV is not set
-# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
-# CONFIG_NETFILTER_XT_MATCH_POLICY is not set
-# CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
-# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
-# CONFIG_NETFILTER_XT_MATCH_REALM is not set
-# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
-# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
-# CONFIG_NETFILTER_XT_MATCH_SOCKET is not set
-# CONFIG_NETFILTER_XT_MATCH_STATE is not set
-# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
-# CONFIG_NETFILTER_XT_MATCH_STRING is not set
-# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
-# CONFIG_NETFILTER_XT_MATCH_TIME is not set
-# CONFIG_NETFILTER_XT_MATCH_U32 is not set
-# CONFIG_NETFILTER_XT_TARGET_AUDIT is not set
-# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
-# CONFIG_NETFILTER_XT_TARGET_CLASSIFY is not set
-# CONFIG_NETFILTER_XT_TARGET_CONNMARK is not set
-# CONFIG_NETFILTER_XT_TARGET_CT is not set
-# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
-# CONFIG_NETFILTER_XT_TARGET_HL is not set
-# CONFIG_NETFILTER_XT_TARGET_HMARK is not set
-# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
-# CONFIG_NETFILTER_XT_TARGET_LED is not set
-# CONFIG_NETFILTER_XT_TARGET_LOG is not set
-# CONFIG_NETFILTER_XT_TARGET_MARK is not set
-# CONFIG_NETFILTER_XT_TARGET_NETMAP is not set
-# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
-# CONFIG_NETFILTER_XT_TARGET_NFQUEUE is not set
-# CONFIG_NETFILTER_XT_TARGET_NOTRACK is not set
-# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
-# CONFIG_NETFILTER_XT_TARGET_REDIRECT is not set
-# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
-# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
-# CONFIG_NETFILTER_XT_TARGET_TEE is not set
-# CONFIG_NETFILTER_XT_TARGET_TPROXY is not set
-# CONFIG_NETFILTER_XT_TARGET_TRACE is not set
-# CONFIG_NETLINK_DIAG is not set
-# CONFIG_NETLINK_MMAP is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NETROM is not set
-CONFIG_NETWORK_FILESYSTEMS=y
-# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
-# CONFIG_NETWORK_SECMARK is not set
-# CONFIG_NETXEN_NIC is not set
-# CONFIG_NET_9P is not set
-# CONFIG_NET_ACT_BPF is not set
-# CONFIG_NET_ACT_CSUM is not set
-# CONFIG_NET_ACT_GACT is not set
-# CONFIG_NET_ACT_IFE is not set
-# CONFIG_NET_ACT_IPT is not set
-# CONFIG_NET_ACT_MIRRED is not set
-# CONFIG_NET_ACT_NAT is not set
-# CONFIG_NET_ACT_PEDIT is not set
-# CONFIG_NET_ACT_POLICE is not set
-# CONFIG_NET_ACT_SAMPLE is not set
-# CONFIG_NET_ACT_SIMP is not set
-# CONFIG_NET_ACT_SKBEDIT is not set
-# CONFIG_NET_ACT_SKBMOD is not set
-# CONFIG_NET_ACT_TUNNEL_KEY is not set
-# CONFIG_NET_ACT_VLAN is not set
-CONFIG_NET_CADENCE=y
-# CONFIG_NET_CALXEDA_XGMAC is not set
-CONFIG_NET_CLS=y
-# CONFIG_NET_CLS_ACT is not set
-# CONFIG_NET_CLS_BASIC is not set
-# CONFIG_NET_CLS_BPF is not set
-# CONFIG_NET_CLS_FLOW is not set
-# CONFIG_NET_CLS_FLOWER is not set
-# CONFIG_NET_CLS_FW is not set
-CONFIG_NET_CLS_IND=y
-# CONFIG_NET_CLS_MATCHALL is not set
-# CONFIG_NET_CLS_ROUTE4 is not set
-# CONFIG_NET_CLS_RSVP is not set
-# CONFIG_NET_CLS_RSVP6 is not set
-# CONFIG_NET_CLS_TCINDEX is not set
-# CONFIG_NET_CLS_U32 is not set
-CONFIG_NET_CORE=y
-# CONFIG_NET_DEVLINK is not set
-# CONFIG_NET_DROP_MONITOR is not set
-# CONFIG_NET_DSA is not set
-# CONFIG_NET_DSA_BCM_SF2 is not set
-# CONFIG_NET_DSA_LEGACY is not set
-# CONFIG_NET_DSA_LOOP is not set
-# CONFIG_NET_DSA_MT7530 is not set
-# CONFIG_NET_DSA_MV88E6060 is not set
-# CONFIG_NET_DSA_MV88E6123_61_65 is not set
-# CONFIG_NET_DSA_MV88E6131 is not set
-# CONFIG_NET_DSA_MV88E6171 is not set
-# CONFIG_NET_DSA_MV88E6352 is not set
-# CONFIG_NET_DSA_MV88E6XXX is not set
-# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
-# CONFIG_NET_DSA_QCA8K is not set
-# CONFIG_NET_DSA_REALTEK_SMI is not set
-# CONFIG_NET_DSA_SMSC_LAN9303_I2C is not set
-# CONFIG_NET_DSA_SMSC_LAN9303_MDIO is not set
-# CONFIG_NET_DSA_TAG_DSA is not set
-# CONFIG_NET_DSA_TAG_EDSA is not set
-# CONFIG_NET_DSA_VITESSE_VSC73XX is not set
-# CONFIG_NET_EMATCH is not set
-# CONFIG_NET_EMATCH_CANID is not set
-# CONFIG_NET_EMATCH_CMP is not set
-# CONFIG_NET_EMATCH_IPT is not set
-# CONFIG_NET_EMATCH_META is not set
-# CONFIG_NET_EMATCH_NBYTE is not set
-CONFIG_NET_EMATCH_STACK=32
-# CONFIG_NET_EMATCH_TEXT is not set
-# CONFIG_NET_EMATCH_U32 is not set
-# CONFIG_NET_FAILOVER is not set
-# CONFIG_NET_FC is not set
-# CONFIG_NET_FOU is not set
-# CONFIG_NET_FOU_IP_TUNNELS is not set
-# CONFIG_NET_IFE is not set
-# CONFIG_NET_IPGRE is not set
-CONFIG_NET_IPGRE_BROADCAST=y
-# CONFIG_NET_IPGRE_DEMUX is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPVTI is not set
-# CONFIG_NET_IP_TUNNEL is not set
-# CONFIG_NET_KEY is not set
-# CONFIG_NET_KEY_MIGRATE is not set
-# CONFIG_NET_L3_MASTER_DEV is not set
-# CONFIG_NET_MPLS_GSO is not set
-# CONFIG_NET_NCSI is not set
-# CONFIG_NET_NSH is not set
-# CONFIG_NET_PACKET_ENGINE is not set
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_NET_PTP_CLASSIFY is not set
-CONFIG_NET_RX_BUSY_POLL=y
-# CONFIG_NET_SB1000 is not set
-CONFIG_NET_SCHED=y
-# CONFIG_NET_SCH_ATM is not set
-# CONFIG_NET_SCH_CAKE is not set
-# CONFIG_NET_SCH_CBQ is not set
-# CONFIG_NET_SCH_CBS is not set
-# CONFIG_NET_SCH_CHOKE is not set
-# CONFIG_NET_SCH_CODEL is not set
-# CONFIG_NET_SCH_DEFAULT is not set
-# CONFIG_NET_SCH_DRR is not set
-# CONFIG_NET_SCH_DSMARK is not set
-# CONFIG_NET_SCH_ETF is not set
-CONFIG_NET_SCH_FIFO=y
-# CONFIG_NET_SCH_FQ is not set
-CONFIG_NET_SCH_FQ_CODEL=y
-# CONFIG_NET_SCH_GRED is not set
-# CONFIG_NET_SCH_HFSC is not set
-# CONFIG_NET_SCH_HHF is not set
-# CONFIG_NET_SCH_HTB is not set
-# CONFIG_NET_SCH_INGRESS is not set
-# CONFIG_NET_SCH_MQPRIO is not set
-# CONFIG_NET_SCH_MULTIQ is not set
-# CONFIG_NET_SCH_NETEM is not set
-# CONFIG_NET_SCH_PIE is not set
-# CONFIG_NET_SCH_PLUG is not set
-# CONFIG_NET_SCH_PRIO is not set
-# CONFIG_NET_SCH_QFQ is not set
-# CONFIG_NET_SCH_RED is not set
-# CONFIG_NET_SCH_SFB is not set
-# CONFIG_NET_SCH_SFQ is not set
-# CONFIG_NET_SCH_SKBPRIO is not set
-# CONFIG_NET_SCH_TBF is not set
-# CONFIG_NET_SCH_TEQL is not set
-# CONFIG_NET_SCTPPROBE is not set
-# CONFIG_NET_SWITCHDEV is not set
-# CONFIG_NET_TCPPROBE is not set
-# CONFIG_NET_TEAM is not set
-# CONFIG_NET_TULIP is not set
-# CONFIG_NET_UDP_TUNNEL is not set
-CONFIG_NET_VENDOR_3COM=y
-CONFIG_NET_VENDOR_8390=y
-CONFIG_NET_VENDOR_ADAPTEC=y
-CONFIG_NET_VENDOR_AGERE=y
-CONFIG_NET_VENDOR_ALACRITECH=y
-CONFIG_NET_VENDOR_ALTEON=y
-CONFIG_NET_VENDOR_AMAZON=y
-CONFIG_NET_VENDOR_AMD=y
-CONFIG_NET_VENDOR_AQUANTIA=y
-CONFIG_NET_VENDOR_ARC=y
-CONFIG_NET_VENDOR_ATHEROS=y
-CONFIG_NET_VENDOR_AURORA=y
-CONFIG_NET_VENDOR_BROADCOM=y
-CONFIG_NET_VENDOR_BROCADE=y
-CONFIG_NET_VENDOR_CADENCE=y
-CONFIG_NET_VENDOR_CAVIUM=y
-CONFIG_NET_VENDOR_CHELSIO=y
-CONFIG_NET_VENDOR_CIRRUS=y
-CONFIG_NET_VENDOR_CISCO=y
-CONFIG_NET_VENDOR_CORTINA=y
-CONFIG_NET_VENDOR_DEC=y
-CONFIG_NET_VENDOR_DLINK=y
-CONFIG_NET_VENDOR_EMULEX=y
-CONFIG_NET_VENDOR_EXAR=y
-CONFIG_NET_VENDOR_EZCHIP=y
-CONFIG_NET_VENDOR_FARADAY=y
-CONFIG_NET_VENDOR_FREESCALE=y
-CONFIG_NET_VENDOR_FUJITSU=y
-CONFIG_NET_VENDOR_HISILICON=y
-CONFIG_NET_VENDOR_HP=y
-CONFIG_NET_VENDOR_HUAWEI=y
-CONFIG_NET_VENDOR_I825XX=y
-CONFIG_NET_VENDOR_IBM=y
-CONFIG_NET_VENDOR_INTEL=y
-CONFIG_NET_VENDOR_MARVELL=y
-CONFIG_NET_VENDOR_MELLANOX=y
-CONFIG_NET_VENDOR_MICREL=y
-CONFIG_NET_VENDOR_MICROCHIP=y
-CONFIG_NET_VENDOR_MICROSEMI=y
-CONFIG_NET_VENDOR_MYRI=y
-CONFIG_NET_VENDOR_NATSEMI=y
-CONFIG_NET_VENDOR_NETERION=y
-CONFIG_NET_VENDOR_NETRONOME=y
-CONFIG_NET_VENDOR_NI=y
-CONFIG_NET_VENDOR_NVIDIA=y
-CONFIG_NET_VENDOR_OKI=y
-CONFIG_NET_VENDOR_PACKET_ENGINES=y
-CONFIG_NET_VENDOR_QLOGIC=y
-CONFIG_NET_VENDOR_QUALCOMM=y
-CONFIG_NET_VENDOR_RDC=y
-CONFIG_NET_VENDOR_REALTEK=y
-CONFIG_NET_VENDOR_RENESAS=y
-CONFIG_NET_VENDOR_ROCKER=y
-CONFIG_NET_VENDOR_SAMSUNG=y
-CONFIG_NET_VENDOR_SEEQ=y
-CONFIG_NET_VENDOR_SILAN=y
-CONFIG_NET_VENDOR_SIS=y
-CONFIG_NET_VENDOR_SMSC=y
-CONFIG_NET_VENDOR_SOCIONEXT=y
-CONFIG_NET_VENDOR_SOLARFLARE=y
-CONFIG_NET_VENDOR_STMICRO=y
-CONFIG_NET_VENDOR_SUN=y
-CONFIG_NET_VENDOR_SYNOPSYS=y
-CONFIG_NET_VENDOR_TEHUTI=y
-CONFIG_NET_VENDOR_TI=y
-CONFIG_NET_VENDOR_TOSHIBA=y
-CONFIG_NET_VENDOR_VIA=y
-CONFIG_NET_VENDOR_WIZNET=y
-CONFIG_NET_VENDOR_XILINX=y
-CONFIG_NET_VENDOR_XIRCOM=y
-# CONFIG_NET_VRF is not set
-# CONFIG_NET_XGENE is not set
-CONFIG_NEW_LEDS=y
-# CONFIG_NFC is not set
-# CONFIG_NFP is not set
-# CONFIG_NFSD is not set
-# CONFIG_NFSD_V2_ACL is not set
-CONFIG_NFSD_V3=y
-# CONFIG_NFSD_V3_ACL is not set
-# CONFIG_NFSD_V4 is not set
-# CONFIG_NFS_ACL_SUPPORT is not set
-CONFIG_NFS_COMMON=y
-# CONFIG_NFS_FS is not set
-# CONFIG_NFS_FSCACHE is not set
-# CONFIG_NFS_SWAP is not set
-# CONFIG_NFS_V2 is not set
-CONFIG_NFS_V3=y
-# CONFIG_NFS_V3_ACL is not set
-# CONFIG_NFS_V4 is not set
-# CONFIG_NFS_V4_1 is not set
-# CONFIG_NFTL is not set
-# CONFIG_NFT_BRIDGE_META is not set
-# CONFIG_NFT_BRIDGE_REJECT is not set
-# CONFIG_NFT_CONNLIMIT is not set
-# CONFIG_NFT_DUP_IPV4 is not set
-# CONFIG_NFT_DUP_IPV6 is not set
-# CONFIG_NFT_FIB_IPV4 is not set
-# CONFIG_NFT_FIB_IPV6 is not set
-# CONFIG_NFT_FIB_NETDEV is not set
-# CONFIG_NFT_FLOW_OFFLOAD is not set
-# CONFIG_NFT_OBJREF is not set
-# CONFIG_NFT_OSF is not set
-# CONFIG_NFT_RT is not set
-# CONFIG_NFT_SET_BITMAP is not set
-# CONFIG_NFT_SOCKET is not set
-# CONFIG_NFT_TPROXY is not set
-# CONFIG_NFT_TUNNEL is not set
-# CONFIG_NF_CONNTRACK is not set
-# CONFIG_NF_CONNTRACK_AMANDA is not set
-# CONFIG_NF_CONNTRACK_EVENTS is not set
-# CONFIG_NF_CONNTRACK_FTP is not set
-# CONFIG_NF_CONNTRACK_H323 is not set
-# CONFIG_NF_CONNTRACK_IPV4 is not set
-# CONFIG_NF_CONNTRACK_IPV6 is not set
-# CONFIG_NF_CONNTRACK_IRC is not set
-# CONFIG_NF_CONNTRACK_LABELS is not set
-# CONFIG_NF_CONNTRACK_MARK is not set
-# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
-# CONFIG_NF_CONNTRACK_PPTP is not set
-CONFIG_NF_CONNTRACK_PROCFS=y
-# CONFIG_NF_CONNTRACK_PROC_COMPAT is not set
-# CONFIG_NF_CONNTRACK_SANE is not set
-# CONFIG_NF_CONNTRACK_SIP is not set
-# CONFIG_NF_CONNTRACK_SNMP is not set
-# CONFIG_NF_CONNTRACK_TFTP is not set
-# CONFIG_NF_CONNTRACK_TIMEOUT is not set
-# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
-# CONFIG_NF_CONNTRACK_ZONES is not set
-# CONFIG_NF_CT_NETLINK is not set
-# CONFIG_NF_CT_NETLINK_TIMEOUT is not set
-# CONFIG_NF_CT_PROTO_DCCP is not set
-# CONFIG_NF_CT_PROTO_GRE is not set
-# CONFIG_NF_CT_PROTO_SCTP is not set
-# CONFIG_NF_CT_PROTO_UDPLITE is not set
-# CONFIG_NF_DEFRAG_IPV4 is not set
-# CONFIG_NF_DUP_IPV4 is not set
-# CONFIG_NF_DUP_IPV6 is not set
-# CONFIG_NF_FLOW_TABLE is not set
-# CONFIG_NF_LOG_ARP is not set
-# CONFIG_NF_LOG_BRIDGE is not set
-# CONFIG_NF_LOG_IPV4 is not set
-# CONFIG_NF_LOG_NETDEV is not set
-# CONFIG_NF_NAT is not set
-# CONFIG_NF_NAT_AMANDA is not set
-# CONFIG_NF_NAT_FTP is not set
-# CONFIG_NF_NAT_H323 is not set
-# CONFIG_NF_NAT_IPV6 is not set
-# CONFIG_NF_NAT_IRC is not set
-CONFIG_NF_NAT_MASQUERADE_IPV4=y
-CONFIG_NF_NAT_MASQUERADE_IPV6=y
-# CONFIG_NF_NAT_NEEDED is not set
-# CONFIG_NF_NAT_PPTP is not set
-# CONFIG_NF_NAT_PROTO_GRE is not set
-# CONFIG_NF_NAT_SIP is not set
-# CONFIG_NF_NAT_SNMP_BASIC is not set
-# CONFIG_NF_NAT_TFTP is not set
-# CONFIG_NF_REJECT_IPV4 is not set
-# CONFIG_NF_REJECT_IPV6 is not set
-# CONFIG_NF_SOCKET_IPV4 is not set
-# CONFIG_NF_SOCKET_IPV6 is not set
-# CONFIG_NF_TABLES is not set
-CONFIG_NF_TABLES_ARP=y
-CONFIG_NF_TABLES_BRIDGE=y
-CONFIG_NF_TABLES_INET=y
-CONFIG_NF_TABLES_IPV4=y
-CONFIG_NF_TABLES_IPV6=y
-CONFIG_NF_TABLES_NETDEV=y
-# CONFIG_NF_TABLES_SET is not set
-# CONFIG_NF_TPROXY_IPV4 is not set
-# CONFIG_NF_TPROXY_IPV6 is not set
-# CONFIG_NI65 is not set
-# CONFIG_NI903X_WDT is not set
-# CONFIG_NIC7018_WDT is not set
-# CONFIG_NILFS2_FS is not set
-# CONFIG_NIU is not set
-CONFIG_NLATTR=y
-# CONFIG_NLMON is not set
-# CONFIG_NLM_XLP_BOARD is not set
-# CONFIG_NLM_XLR_BOARD is not set
-# CONFIG_NLS is not set
-# CONFIG_NLS_ASCII is not set
-# CONFIG_NLS_CODEPAGE_1250 is not set
-# CONFIG_NLS_CODEPAGE_1251 is not set
-# CONFIG_NLS_CODEPAGE_437 is not set
-# CONFIG_NLS_CODEPAGE_737 is not set
-# CONFIG_NLS_CODEPAGE_775 is not set
-# CONFIG_NLS_CODEPAGE_850 is not set
-# CONFIG_NLS_CODEPAGE_852 is not set
-# CONFIG_NLS_CODEPAGE_855 is not set
-# CONFIG_NLS_CODEPAGE_857 is not set
-# CONFIG_NLS_CODEPAGE_860 is not set
-# CONFIG_NLS_CODEPAGE_861 is not set
-# CONFIG_NLS_CODEPAGE_862 is not set
-# CONFIG_NLS_CODEPAGE_863 is not set
-# CONFIG_NLS_CODEPAGE_864 is not set
-# CONFIG_NLS_CODEPAGE_865 is not set
-# CONFIG_NLS_CODEPAGE_866 is not set
-# CONFIG_NLS_CODEPAGE_869 is not set
-# CONFIG_NLS_CODEPAGE_874 is not set
-# CONFIG_NLS_CODEPAGE_932 is not set
-# CONFIG_NLS_CODEPAGE_936 is not set
-# CONFIG_NLS_CODEPAGE_949 is not set
-# CONFIG_NLS_CODEPAGE_950 is not set
-CONFIG_NLS_DEFAULT="iso8859-1"
-# CONFIG_NLS_ISO8859_1 is not set
-# CONFIG_NLS_ISO8859_13 is not set
-# CONFIG_NLS_ISO8859_14 is not set
-# CONFIG_NLS_ISO8859_15 is not set
-# CONFIG_NLS_ISO8859_2 is not set
-# CONFIG_NLS_ISO8859_3 is not set
-# CONFIG_NLS_ISO8859_4 is not set
-# CONFIG_NLS_ISO8859_5 is not set
-# CONFIG_NLS_ISO8859_6 is not set
-# CONFIG_NLS_ISO8859_7 is not set
-# CONFIG_NLS_ISO8859_8 is not set
-# CONFIG_NLS_ISO8859_9 is not set
-# CONFIG_NLS_KOI8_R is not set
-# CONFIG_NLS_KOI8_U is not set
-# CONFIG_NLS_MAC_CELTIC is not set
-# CONFIG_NLS_MAC_CENTEURO is not set
-# CONFIG_NLS_MAC_CROATIAN is not set
-# CONFIG_NLS_MAC_CYRILLIC is not set
-# CONFIG_NLS_MAC_GAELIC is not set
-# CONFIG_NLS_MAC_GREEK is not set
-# CONFIG_NLS_MAC_ICELAND is not set
-# CONFIG_NLS_MAC_INUIT is not set
-# CONFIG_NLS_MAC_ROMAN is not set
-# CONFIG_NLS_MAC_ROMANIAN is not set
-# CONFIG_NLS_MAC_TURKISH is not set
-# CONFIG_NLS_UTF8 is not set
-CONFIG_NMI_LOG_BUF_SHIFT=13
-# CONFIG_NOP_USB_XCEIV is not set
-# CONFIG_NORTEL_HERMES is not set
-# CONFIG_NOTIFIER_ERROR_INJECTION is not set
-# CONFIG_NOUVEAU_LEGACY_CTX_SUPPORT is not set
-# CONFIG_NOZOMI is not set
-# CONFIG_NO_BOOTMEM is not set
-# CONFIG_NO_HZ is not set
-# CONFIG_NO_HZ_FULL is not set
-# CONFIG_NO_HZ_IDLE is not set
-# CONFIG_NS83820 is not set
-# CONFIG_NTB is not set
-# CONFIG_NTFS_DEBUG is not set
-# CONFIG_NTFS_FS is not set
-# CONFIG_NTFS_RW is not set
-# CONFIG_NTP_PPS is not set
-# CONFIG_NVM is not set
-# CONFIG_NVMEM is not set
-# CONFIG_NVMEM_BCM_OCOTP is not set
-# CONFIG_NVMEM_IMX_OCOTP is not set
-# CONFIG_NVME_FC is not set
-# CONFIG_NVME_TARGET is not set
-# CONFIG_NVRAM is not set
-# CONFIG_NV_TCO is not set
-# CONFIG_NXP_STB220 is not set
-# CONFIG_NXP_STB225 is not set
-# CONFIG_N_GSM is not set
-# CONFIG_OABI_COMPAT is not set
-# CONFIG_OBS600 is not set
-# CONFIG_OCFS2_FS is not set
-# CONFIG_OF_OVERLAY is not set
-# CONFIG_OF_UNITTEST is not set
-# CONFIG_OMAP2_DSS_DEBUG is not set
-# CONFIG_OMAP2_DSS_DEBUGFS is not set
-# CONFIG_OMAP2_DSS_SDI is not set
-# CONFIG_OMAP_OCP2SCP is not set
-# CONFIG_OMAP_USB2 is not set
-# CONFIG_OMFS_FS is not set
-# CONFIG_OPENVSWITCH is not set
-# CONFIG_OPROFILE is not set
-# CONFIG_OPROFILE_EVENT_MULTIPLEX is not set
-# CONFIG_OPT3001 is not set
-CONFIG_OPTIMIZE_INLINING=y
-# CONFIG_ORANGEFS_FS is not set
-# CONFIG_ORION_WATCHDOG is not set
-# CONFIG_OSF_PARTITION is not set
-CONFIG_OVERLAY_FS=y
-# CONFIG_OVERLAY_FS_INDEX is not set
-# CONFIG_OVERLAY_FS_METACOPY is not set
-CONFIG_OVERLAY_FS_REDIRECT_ALWAYS_FOLLOW=y
-# CONFIG_OVERLAY_FS_REDIRECT_DIR is not set
-CONFIG_OVERLAY_FS_XINO_AUTO=y
-# CONFIG_OWL_LOADER is not set
-# CONFIG_P54_COMMON is not set
-# CONFIG_PA12203001 is not set
-CONFIG_PACKET=y
-# CONFIG_PACKET_DIAG is not set
-# CONFIG_PAGE_EXTENSION is not set
-# CONFIG_PAGE_OWNER is not set
-# CONFIG_PAGE_POISONING is not set
-# CONFIG_PAGE_SIZE_16KB is not set
-# CONFIG_PAGE_SIZE_32KB is not set
-CONFIG_PAGE_SIZE_4KB=y
-# CONFIG_PAGE_SIZE_64KB is not set
-# CONFIG_PAGE_SIZE_8KB is not set
-# CONFIG_PALMAS_GPADC is not set
-# CONFIG_PANASONIC_LAPTOP is not set
-# CONFIG_PANEL is not set
-CONFIG_PANIC_ON_OOPS=y
-CONFIG_PANIC_ON_OOPS_VALUE=1
-CONFIG_PANIC_TIMEOUT=1
-# CONFIG_PANTHERLORD_FF is not set
-# CONFIG_PARAVIRT is not set
-# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
-# CONFIG_PARPORT is not set
-# CONFIG_PARPORT_1284 is not set
-# CONFIG_PARPORT_AX88796 is not set
-# CONFIG_PARPORT_GSC is not set
-# CONFIG_PARPORT_PC is not set
-CONFIG_PARTITION_ADVANCED=y
-# CONFIG_PATA_ALI is not set
-# CONFIG_PATA_AMD is not set
-# CONFIG_PATA_ARASAN_CF is not set
-# CONFIG_PATA_ARTOP is not set
-# CONFIG_PATA_ATIIXP is not set
-# CONFIG_PATA_ATP867X is not set
-# CONFIG_PATA_CMD640_PCI is not set
-# CONFIG_PATA_CMD64X is not set
-# CONFIG_PATA_CS5520 is not set
-# CONFIG_PATA_CS5530 is not set
-# CONFIG_PATA_CS5535 is not set
-# CONFIG_PATA_CS5536 is not set
-# CONFIG_PATA_CYPRESS is not set
-# CONFIG_PATA_EFAR is not set
-# CONFIG_PATA_HPT366 is not set
-# CONFIG_PATA_HPT37X is not set
-# CONFIG_PATA_HPT3X2N is not set
-# CONFIG_PATA_HPT3X3 is not set
-# CONFIG_PATA_IMX is not set
-# CONFIG_PATA_ISAPNP is not set
-# CONFIG_PATA_IT8213 is not set
-# CONFIG_PATA_IT821X is not set
-# CONFIG_PATA_JMICRON is not set
-# CONFIG_PATA_LEGACY is not set
-# CONFIG_PATA_MARVELL is not set
-# CONFIG_PATA_MPIIX is not set
-# CONFIG_PATA_NETCELL is not set
-# CONFIG_PATA_NINJA32 is not set
-# CONFIG_PATA_NS87410 is not set
-# CONFIG_PATA_NS87415 is not set
-# CONFIG_PATA_OCTEON_CF is not set
-# CONFIG_PATA_OF_PLATFORM is not set
-# CONFIG_PATA_OLDPIIX is not set
-# CONFIG_PATA_OPTI is not set
-# CONFIG_PATA_OPTIDMA is not set
-# CONFIG_PATA_PCMCIA is not set
-# CONFIG_PATA_PDC2027X is not set
-# CONFIG_PATA_PDC_OLD is not set
-# CONFIG_PATA_PLATFORM is not set
-# CONFIG_PATA_QDI is not set
-# CONFIG_PATA_RADISYS is not set
-# CONFIG_PATA_RDC is not set
-# CONFIG_PATA_RZ1000 is not set
-# CONFIG_PATA_SC1200 is not set
-# CONFIG_PATA_SCH is not set
-# CONFIG_PATA_SERVERWORKS is not set
-# CONFIG_PATA_SIL680 is not set
-# CONFIG_PATA_SIS is not set
-# CONFIG_PATA_TOSHIBA is not set
-# CONFIG_PATA_TRIFLEX is not set
-# CONFIG_PATA_VIA is not set
-# CONFIG_PATA_WINBOND is not set
-# CONFIG_PATA_WINBOND_VLB is not set
-# CONFIG_PC104 is not set
-# CONFIG_PC300TOO is not set
-# CONFIG_PCCARD is not set
-# CONFIG_PCH_DMA is not set
-# CONFIG_PCH_GBE is not set
-# CONFIG_PCH_PHUB is not set
-# CONFIG_PCI is not set
-# CONFIG_PCI200SYN is not set
-# CONFIG_PCIEAER_INJECT is not set
-# CONFIG_PCIEASPM is not set
-# CONFIG_PCIEPORTBUS is not set
-# CONFIG_PCIE_ALTERA is not set
-# CONFIG_PCIE_ARMADA_8K is not set
-# CONFIG_PCIE_CADENCE_HOST is not set
-# CONFIG_PCIE_DPC is not set
-# CONFIG_PCIE_DW_PLAT is not set
-# CONFIG_PCIE_DW_PLAT_HOST is not set
-# CONFIG_PCIE_ECRC is not set
-# CONFIG_PCIE_IPROC is not set
-# CONFIG_PCIE_KIRIN is not set
-# CONFIG_PCIE_PTM is not set
-# CONFIG_PCIE_XILINX is not set
-# CONFIG_PCIPCWATCHDOG is not set
-# CONFIG_PCI_ATMEL is not set
-# CONFIG_PCI_CNB20LE_QUIRK is not set
-# CONFIG_PCI_DEBUG is not set
-# CONFIG_PCI_DISABLE_COMMON_QUIRKS is not set
-# CONFIG_PCI_ENDPOINT is not set
-# CONFIG_PCI_ENDPOINT_TEST is not set
-# CONFIG_PCI_FTPCI100 is not set
-# CONFIG_PCI_HERMES is not set
-# CONFIG_PCI_HISI is not set
-# CONFIG_PCI_HOST_GENERIC is not set
-# CONFIG_PCI_HOST_THUNDER_ECAM is not set
-# CONFIG_PCI_HOST_THUNDER_PEM is not set
-# CONFIG_PCI_IOV is not set
-# CONFIG_PCI_LAYERSCAPE is not set
-# CONFIG_PCI_MSI is not set
-# CONFIG_PCI_PASID is not set
-# CONFIG_PCI_PF_STUB is not set
-# CONFIG_PCI_PRI is not set
-CONFIG_PCI_QUIRKS=y
-# CONFIG_PCI_REALLOC_ENABLE_AUTO is not set
-# CONFIG_PCI_STUB is not set
-# CONFIG_PCI_SW_SWITCHTEC is not set
-CONFIG_PCI_SYSCALL=y
-# CONFIG_PCI_XGENE is not set
-# CONFIG_PCMCIA is not set
-# CONFIG_PCMCIA_3C574 is not set
-# CONFIG_PCMCIA_3C589 is not set
-# CONFIG_PCMCIA_AHA152X is not set
-# CONFIG_PCMCIA_ATMEL is not set
-# CONFIG_PCMCIA_AXNET is not set
-# CONFIG_PCMCIA_DEBUG is not set
-# CONFIG_PCMCIA_FDOMAIN is not set
-# CONFIG_PCMCIA_FMVJ18X is not set
-# CONFIG_PCMCIA_HERMES is not set
-# CONFIG_PCMCIA_LOAD_CIS is not set
-# CONFIG_PCMCIA_NINJA_SCSI is not set
-# CONFIG_PCMCIA_NMCLAN is not set
-# CONFIG_PCMCIA_PCNET is not set
-# CONFIG_PCMCIA_QLOGIC is not set
-# CONFIG_PCMCIA_RAYCS is not set
-# CONFIG_PCMCIA_SMC91C92 is not set
-# CONFIG_PCMCIA_SPECTRUM is not set
-# CONFIG_PCMCIA_SYM53C500 is not set
-# CONFIG_PCMCIA_WL3501 is not set
-# CONFIG_PCMCIA_XIRC2PS is not set
-# CONFIG_PCMCIA_XIRCOM is not set
-# CONFIG_PCNET32 is not set
-# CONFIG_PCSPKR_PLATFORM is not set
-# CONFIG_PD6729 is not set
-# CONFIG_PDA_POWER is not set
-# CONFIG_PDC_ADMA is not set
-# CONFIG_PERCPU_STATS is not set
-# CONFIG_PERCPU_TEST is not set
-# CONFIG_PERF_EVENTS is not set
-# CONFIG_PERF_EVENTS_AMD_POWER is not set
-# CONFIG_PERSISTENT_KEYRINGS is not set
-# CONFIG_PHANTOM is not set
-# CONFIG_PHONET is not set
-# CONFIG_PHYLIB is not set
-# CONFIG_PHYS_ADDR_T_64BIT is not set
-# CONFIG_PHY_CPCAP_USB is not set
-# CONFIG_PHY_EXYNOS_DP_VIDEO is not set
-# CONFIG_PHY_EXYNOS_MIPI_VIDEO is not set
-# CONFIG_PHY_MAPPHONE_MDM6600 is not set
-# CONFIG_PHY_PXA_28NM_HSIC is not set
-# CONFIG_PHY_PXA_28NM_USB2 is not set
-# CONFIG_PHY_QCOM_DWC3 is not set
-# CONFIG_PHY_QCOM_USB_HS is not set
-# CONFIG_PHY_QCOM_USB_HSIC is not set
-# CONFIG_PHY_SAMSUNG_USB2 is not set
-# CONFIG_PHY_TUSB1210 is not set
-# CONFIG_PHY_XGENE is not set
-# CONFIG_PI433 is not set
-# CONFIG_PID_IN_CONTEXTIDR is not set
-# CONFIG_PID_NS is not set
-CONFIG_PINCONF=y
-# CONFIG_PINCTRL is not set
-# CONFIG_PINCTRL_AMD is not set
-# CONFIG_PINCTRL_AXP209 is not set
-# CONFIG_PINCTRL_CEDARFORK is not set
-# CONFIG_PINCTRL_EXYNOS is not set
-# CONFIG_PINCTRL_EXYNOS5440 is not set
-# CONFIG_PINCTRL_ICELAKE is not set
-# CONFIG_PINCTRL_MCP23S08 is not set
-# CONFIG_PINCTRL_MSM8X74 is not set
-CONFIG_PINCTRL_SINGLE=y
-# CONFIG_PINCTRL_SX150X is not set
-CONFIG_PINMUX=y
-# CONFIG_PKCS7_MESSAGE_PARSER is not set
-# CONFIG_PL320_MBOX is not set
-# CONFIG_PL330_DMA is not set
-# CONFIG_PLATFORM_MHU is not set
-# CONFIG_PLAT_SPEAR is not set
-# CONFIG_PLIP is not set
-CONFIG_PLUGIN_HOSTCC=""
-# CONFIG_PLX_HERMES is not set
-# CONFIG_PM is not set
-# CONFIG_PMBUS is not set
-# CONFIG_PMC_MSP is not set
-# CONFIG_PMIC_ADP5520 is not set
-# CONFIG_PMIC_DA903X is not set
-# CONFIG_PM_AUTOSLEEP is not set
-# CONFIG_PM_DEVFREQ is not set
-# CONFIG_PM_WAKELOCKS is not set
-# CONFIG_POSIX_MQUEUE is not set
-CONFIG_POSIX_TIMERS=y
-# CONFIG_POWERCAP is not set
-# CONFIG_POWER_AVS is not set
-# CONFIG_POWER_RESET is not set
-# CONFIG_POWER_RESET_BRCMKONA is not set
-# CONFIG_POWER_RESET_BRCMSTB is not set
-# CONFIG_POWER_RESET_GPIO is not set
-# CONFIG_POWER_RESET_GPIO_RESTART is not set
-# CONFIG_POWER_RESET_LTC2952 is not set
-# CONFIG_POWER_RESET_PIIX4_POWEROFF is not set
-# CONFIG_POWER_RESET_RESTART is not set
-# CONFIG_POWER_RESET_SYSCON is not set
-# CONFIG_POWER_RESET_SYSCON_POWEROFF is not set
-# CONFIG_POWER_RESET_VERSATILE is not set
-# CONFIG_POWER_RESET_XGENE is not set
-# CONFIG_POWER_SUPPLY is not set
-# CONFIG_POWER_SUPPLY_DEBUG is not set
-# CONFIG_PPC4xx_GPIO is not set
-# CONFIG_PPC_16K_PAGES is not set
-# CONFIG_PPC_256K_PAGES is not set
-CONFIG_PPC_4K_PAGES=y
-# CONFIG_PPC_64K_PAGES is not set
-# CONFIG_PPC_DISABLE_WERROR is not set
-# CONFIG_PPC_EMULATED_STATS is not set
-# CONFIG_PPC_EPAPR_HV_BYTECHAN is not set
-# CONFIG_PPP is not set
-# CONFIG_PPPOATM is not set
-# CONFIG_PPPOE is not set
-# CONFIG_PPPOL2TP is not set
-# CONFIG_PPP_ASYNC is not set
-# CONFIG_PPP_BSDCOMP is not set
-# CONFIG_PPP_DEFLATE is not set
-CONFIG_PPP_FILTER=y
-# CONFIG_PPP_MPPE is not set
-CONFIG_PPP_MULTILINK=y
-# CONFIG_PPP_SYNC_TTY is not set
-# CONFIG_PPS is not set
-# CONFIG_PPS_CLIENT_GPIO is not set
-# CONFIG_PPS_CLIENT_KTIMER is not set
-# CONFIG_PPS_CLIENT_LDISC is not set
-# CONFIG_PPS_CLIENT_PARPORT is not set
-# CONFIG_PPS_DEBUG is not set
-# CONFIG_PPTP is not set
-# CONFIG_PREEMPT is not set
-CONFIG_PREEMPT_NONE=y
-# CONFIG_PREEMPT_TRACER is not set
-# CONFIG_PREEMPT_VOLUNTARY is not set
-# CONFIG_PREEMPTIRQ_EVENTS is not set
-# CONFIG_PREEMPTIRQ_DELAY_TEST is not set
-CONFIG_PREVENT_FIRMWARE_BUILD=y
-CONFIG_PRINTK=y
-CONFIG_PRINTK_NMI=y
-CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT=13
-# CONFIG_PRINTK_TIME is not set
-CONFIG_PRINT_STACK_DEPTH=64
-# CONFIG_PRISM2_USB is not set
-# CONFIG_PRISM54 is not set
-# CONFIG_PROC_CHILDREN is not set
-CONFIG_PROC_FS=y
-# CONFIG_PROC_KCORE is not set
-# CONFIG_PROC_PAGE_MONITOR is not set
-CONFIG_PROC_STRIPPED=y
-CONFIG_PROC_SYSCTL=y
-# CONFIG_PROC_VMCORE_DEVICE_DUMP is not set
-# CONFIG_PROFILE_ALL_BRANCHES is not set
-# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
-# CONFIG_PROFILING is not set
-# CONFIG_PROVE_LOCKING is not set
-# CONFIG_PROVE_RCU is not set
-# CONFIG_PROVE_RCU_REPEATEDLY is not set
-# CONFIG_PSAMPLE is not set
-# CONFIG_PSB6970_PHY is not set
-# CONFIG_PSTORE is not set
-# CONFIG_PTP_1588_CLOCK is not set
-# CONFIG_PTP_1588_CLOCK_IXP46X is not set
-# CONFIG_PTP_1588_CLOCK_KVM is not set
-# CONFIG_PTP_1588_CLOCK_PCH is not set
-# CONFIG_PUBLIC_KEY_ALGO_RSA is not set
-# CONFIG_PWM is not set
-# CONFIG_PWM_FSL_FTM is not set
-# CONFIG_PWM_PCA9685 is not set
-CONFIG_PWRSEQ_EMMC=y
-# CONFIG_PWRSEQ_SD8787 is not set
-CONFIG_PWRSEQ_SIMPLE=y
-# CONFIG_QCA7000 is not set
-# CONFIG_QCA7000_SPI is not set
-# CONFIG_QCA7000_UART is not set
-# CONFIG_QCOM_EMAC is not set
-# CONFIG_QCOM_FALKOR_ERRATUM_1003 is not set
-# CONFIG_QCOM_FALKOR_ERRATUM_1009 is not set
-# CONFIG_QCOM_FALKOR_ERRATUM_E1041 is not set
-# CONFIG_QCOM_HIDMA is not set
-# CONFIG_QCOM_HIDMA_MGMT is not set
-# CONFIG_QCOM_QDF2400_ERRATUM_0065 is not set
-# CONFIG_QCOM_SPMI_IADC is not set
-# CONFIG_QCOM_SPMI_TEMP_ALARM is not set
-# CONFIG_QCOM_SPMI_VADC is not set
-# CONFIG_QED is not set
-# CONFIG_QLA3XXX is not set
-# CONFIG_QLCNIC is not set
-# CONFIG_QLGE is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_QNX6FS_FS is not set
-# CONFIG_QORIQ_CPUFREQ is not set
-# CONFIG_QORIQ_THERMAL is not set
-# CONFIG_QSEMI_PHY is not set
-# CONFIG_QUEUED_LOCK_STAT is not set
-# CONFIG_QUOTA is not set
-# CONFIG_QUOTACTL is not set
-# CONFIG_QUOTA_DEBUG is not set
-# CONFIG_R3964 is not set
-# CONFIG_R6040 is not set
-# CONFIG_R8169 is not set
-# CONFIG_R8188EU is not set
-# CONFIG_R8712U is not set
-# CONFIG_R8723AU is not set
-# CONFIG_RADIO_ADAPTERS is not set
-# CONFIG_RADIO_AZTECH is not set
-# CONFIG_RADIO_CADET is not set
-# CONFIG_RADIO_GEMTEK is not set
-# CONFIG_RADIO_MAXIRADIO is not set
-# CONFIG_RADIO_RTRACK is not set
-# CONFIG_RADIO_RTRACK2 is not set
-# CONFIG_RADIO_SF16FMI is not set
-# CONFIG_RADIO_SF16FMR2 is not set
-# CONFIG_RADIO_TERRATEC is not set
-# CONFIG_RADIO_TRUST is not set
-# CONFIG_RADIO_TYPHOON is not set
-# CONFIG_RADIO_ZOLTRIX is not set
-# CONFIG_RAID_ATTRS is not set
-# CONFIG_RALINK is not set
-# CONFIG_RANDOM32_SELFTEST is not set
-# CONFIG_RANDOM_TRUST_CPU is not set
-# CONFIG_RAPIDIO is not set
-# CONFIG_RAS is not set
-# CONFIG_RAW_DRIVER is not set
-# CONFIG_RBTREE_TEST is not set
-CONFIG_RCU_CPU_STALL_TIMEOUT=60
-# CONFIG_RCU_EQS_DEBUG is not set
-# CONFIG_RCU_EXPEDITE_BOOT is not set
-CONFIG_RCU_EXPERT=y
-CONFIG_RCU_FANOUT=32
-CONFIG_RCU_FANOUT_LEAF=16
-# CONFIG_RCU_FAST_NO_HZ is not set
-CONFIG_RCU_KTHREAD_PRIO=0
-# CONFIG_RCU_NOCB_CPU is not set
-# CONFIG_RCU_PERF_TEST is not set
-# CONFIG_RCU_TORTURE_TEST is not set
-CONFIG_RCU_TORTURE_TEST_SLOW_INIT_DELAY=3
-# CONFIG_RCU_TRACE is not set
-# CONFIG_RC_ATI_REMOTE is not set
-# CONFIG_RC_CORE is not set
-# CONFIG_RC_DECODERS is not set
-# CONFIG_RC_LOOPBACK is not set
-# CONFIG_RC_MAP is not set
-# CONFIG_RDS is not set
-# CONFIG_RD_BZIP2 is not set
-# CONFIG_RD_GZIP is not set
-# CONFIG_RD_LZ4 is not set
-# CONFIG_RD_LZMA is not set
-# CONFIG_RD_LZO is not set
-# CONFIG_RD_XZ is not set
-# CONFIG_READABLE_ASM is not set
-# CONFIG_REALTEK_PHY is not set
-# CONFIG_REDWOOD is not set
-# CONFIG_REFCOUNT_FULL is not set
-# CONFIG_REGMAP is not set
-# CONFIG_REGMAP_I2C is not set
-# CONFIG_REGMAP_MMIO is not set
-# CONFIG_REGMAP_SPI is not set
-# CONFIG_REGULATOR is not set
-# CONFIG_REGULATOR_88PG86X is not set
-# CONFIG_REGULATOR_ACT8865 is not set
-# CONFIG_REGULATOR_AD5398 is not set
-# CONFIG_REGULATOR_ANATOP is not set
-# CONFIG_REGULATOR_DA9210 is not set
-# CONFIG_REGULATOR_DA9211 is not set
-# CONFIG_REGULATOR_DEBUG is not set
-# CONFIG_REGULATOR_FAN53555 is not set
-# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
-# CONFIG_REGULATOR_GPIO is not set
-# CONFIG_REGULATOR_ISL6271A is not set
-# CONFIG_REGULATOR_ISL9305 is not set
-# CONFIG_REGULATOR_LP3971 is not set
-# CONFIG_REGULATOR_LP3972 is not set
-# CONFIG_REGULATOR_LP872X is not set
-# CONFIG_REGULATOR_LP8755 is not set
-# CONFIG_REGULATOR_LTC3589 is not set
-# CONFIG_REGULATOR_LTC3676 is not set
-# CONFIG_REGULATOR_MAX1586 is not set
-# CONFIG_REGULATOR_MAX8649 is not set
-# CONFIG_REGULATOR_MAX8660 is not set
-# CONFIG_REGULATOR_MAX8952 is not set
-# CONFIG_REGULATOR_MAX8973 is not set
-# CONFIG_REGULATOR_MT6311 is not set
-# CONFIG_REGULATOR_PFUZE100 is not set
-# CONFIG_REGULATOR_PV88060 is not set
-# CONFIG_REGULATOR_PV88080 is not set
-# CONFIG_REGULATOR_PV88090 is not set
-# CONFIG_REGULATOR_PWM is not set
-# CONFIG_REGULATOR_SY8106A is not set
-# CONFIG_REGULATOR_TI_ABB is not set
-# CONFIG_REGULATOR_TPS51632 is not set
-# CONFIG_REGULATOR_TPS62360 is not set
-# CONFIG_REGULATOR_TPS65023 is not set
-# CONFIG_REGULATOR_TPS6507X is not set
-# CONFIG_REGULATOR_TPS65132 is not set
-# CONFIG_REGULATOR_TPS6524X is not set
-# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
-# CONFIG_REGULATOR_VCTRL is not set
-# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
-# CONFIG_REISERFS_CHECK is not set
-# CONFIG_REISERFS_FS is not set
-# CONFIG_REISERFS_FS_POSIX_ACL is not set
-# CONFIG_REISERFS_FS_SECURITY is not set
-# CONFIG_REISERFS_FS_XATTR is not set
-# CONFIG_REISERFS_PROC_INFO is not set
-# CONFIG_RELAY is not set
-# CONFIG_RELOCATABLE is not set
-# CONFIG_REMOTEPROC is not set
-# CONFIG_RENESAS_PHY is not set
-# CONFIG_RESET_ATH79 is not set
-# CONFIG_RESET_BERLIN is not set
-# CONFIG_RESET_CONTROLLER is not set
-# CONFIG_RESET_IMX7 is not set
-# CONFIG_RESET_LANTIQ is not set
-# CONFIG_RESET_LPC18XX is not set
-# CONFIG_RESET_MESON is not set
-# CONFIG_RESET_PISTACHIO is not set
-# CONFIG_RESET_SOCFPGA is not set
-# CONFIG_RESET_STM32 is not set
-# CONFIG_RESET_SUNXI is not set
-# CONFIG_RESET_TEGRA_BPMP is not set
-# CONFIG_RESET_TI_SYSCON is not set
-# CONFIG_RESET_ZYNQ is not set
-# CONFIG_RFD77402 is not set
-# CONFIG_RFD_FTL is not set
-CONFIG_RFKILL=y
-# CONFIG_RFKILL_FULL is not set
-# CONFIG_RFKILL_GPIO is not set
-# CONFIG_RFKILL_INPUT is not set
-# CONFIG_RFKILL_LEDS is not set
-# CONFIG_RFKILL_REGULATOR is not set
-# CONFIG_RING_BUFFER_BENCHMARK is not set
-# CONFIG_RING_BUFFER_STARTUP_TEST is not set
-# CONFIG_RMI4_CORE is not set
-# CONFIG_RMNET is not set
-# CONFIG_ROCKCHIP_PHY is not set
-# CONFIG_ROCKER is not set
-# CONFIG_ROMFS_FS is not set
-# CONFIG_ROSE is not set
-# CONFIG_RPCSEC_GSS_KRB5 is not set
-# CONFIG_RPMSG_QCOM_GLINK_RPM is not set
-# CONFIG_RPMSG_VIRTIO is not set
-# CONFIG_RPR0521 is not set
-# CONFIG_RSEQ is not set
-# CONFIG_RT2X00 is not set
-# CONFIG_RTC_CLASS is not set
-# CONFIG_RTC_DEBUG is not set
-# CONFIG_RTC_DRV_ABB5ZES3 is not set
-# CONFIG_RTC_DRV_ABX80X is not set
-# CONFIG_RTC_DRV_ARMADA38X is not set
-# CONFIG_RTC_DRV_AU1XXX is not set
-# CONFIG_RTC_DRV_BQ32K is not set
-# CONFIG_RTC_DRV_BQ4802 is not set
-CONFIG_RTC_DRV_CMOS=y
-# CONFIG_RTC_DRV_DS1286 is not set
-# CONFIG_RTC_DRV_DS1302 is not set
-# CONFIG_RTC_DRV_DS1305 is not set
-# CONFIG_RTC_DRV_DS1307 is not set
-# CONFIG_RTC_DRV_DS1307_CENTURY is not set
-# CONFIG_RTC_DRV_DS1307_HWMON is not set
-# CONFIG_RTC_DRV_DS1343 is not set
-# CONFIG_RTC_DRV_DS1347 is not set
-# CONFIG_RTC_DRV_DS1374 is not set
-# CONFIG_RTC_DRV_DS1390 is not set
-# CONFIG_RTC_DRV_DS1511 is not set
-# CONFIG_RTC_DRV_DS1553 is not set
-# CONFIG_RTC_DRV_DS1672 is not set
-# CONFIG_RTC_DRV_DS1685_FAMILY is not set
-# CONFIG_RTC_DRV_DS1742 is not set
-# CONFIG_RTC_DRV_DS2404 is not set
-# CONFIG_RTC_DRV_DS3232 is not set
-# CONFIG_RTC_DRV_DS3234 is not set
-# CONFIG_RTC_DRV_EM3027 is not set
-# CONFIG_RTC_DRV_EP93XX is not set
-# CONFIG_RTC_DRV_FM3130 is not set
-# CONFIG_RTC_DRV_FTRTC010 is not set
-# CONFIG_RTC_DRV_GENERIC is not set
-# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
-# CONFIG_RTC_DRV_HYM8563 is not set
-# CONFIG_RTC_DRV_ISL12022 is not set
-# CONFIG_RTC_DRV_ISL12026 is not set
-# CONFIG_RTC_DRV_ISL12057 is not set
-# CONFIG_RTC_DRV_ISL1208 is not set
-# CONFIG_RTC_DRV_M41T80 is not set
-# CONFIG_RTC_DRV_M41T93 is not set
-# CONFIG_RTC_DRV_M41T94 is not set
-# CONFIG_RTC_DRV_M48T35 is not set
-# CONFIG_RTC_DRV_M48T59 is not set
-# CONFIG_RTC_DRV_M48T86 is not set
-# CONFIG_RTC_DRV_MAX6900 is not set
-# CONFIG_RTC_DRV_MAX6902 is not set
-# CONFIG_RTC_DRV_MAX6916 is not set
-# CONFIG_RTC_DRV_MCP795 is not set
-# CONFIG_RTC_DRV_MOXART is not set
-# CONFIG_RTC_DRV_MPC5121 is not set
-# CONFIG_RTC_DRV_MSM6242 is not set
-# CONFIG_RTC_DRV_OMAP is not set
-# CONFIG_RTC_DRV_PCF2123 is not set
-# CONFIG_RTC_DRV_PCF2127 is not set
-# CONFIG_RTC_DRV_PCF85063 is not set
-# CONFIG_RTC_DRV_PCF8523 is not set
-# CONFIG_RTC_DRV_PCF85363 is not set
-# CONFIG_RTC_DRV_PCF8563 is not set
-# CONFIG_RTC_DRV_PCF8583 is not set
-# CONFIG_RTC_DRV_PL030 is not set
-# CONFIG_RTC_DRV_PL031 is not set
-# CONFIG_RTC_DRV_PS3 is not set
-# CONFIG_RTC_DRV_PT7C4338 is not set
-# CONFIG_RTC_DRV_R7301 is not set
-# CONFIG_RTC_DRV_R9701 is not set
-# CONFIG_RTC_DRV_RP5C01 is not set
-# CONFIG_RTC_DRV_RS5C348 is not set
-# CONFIG_RTC_DRV_RS5C372 is not set
-# CONFIG_RTC_DRV_RTC7301 is not set
-# CONFIG_RTC_DRV_RV3029C2 is not set
-# CONFIG_RTC_DRV_RV8803 is not set
-# CONFIG_RTC_DRV_RX4581 is not set
-# CONFIG_RTC_DRV_RX6110 is not set
-# CONFIG_RTC_DRV_RX8010 is not set
-# CONFIG_RTC_DRV_RX8025 is not set
-# CONFIG_RTC_DRV_RX8581 is not set
-# CONFIG_RTC_DRV_S35390A is not set
-# CONFIG_RTC_DRV_SNVS is not set
-# CONFIG_RTC_DRV_STK17TA8 is not set
-# CONFIG_RTC_DRV_SUN6I is not set
-# CONFIG_RTC_DRV_TEST is not set
-# CONFIG_RTC_DRV_V3020 is not set
-# CONFIG_RTC_DRV_X1205 is not set
-# CONFIG_RTC_DRV_XGENE is not set
-# CONFIG_RTC_DRV_ZYNQMP is not set
-CONFIG_RTC_HCTOSYS=y
-CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
-CONFIG_RTC_INTF_DEV=y
-# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
-CONFIG_RTC_INTF_PROC=y
-CONFIG_RTC_INTF_SYSFS=y
-CONFIG_RTC_LIB=y
-# CONFIG_RTC_NVMEM is not set
-CONFIG_RTC_SYSTOHC=y
-CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
-# CONFIG_RTL8180 is not set
-# CONFIG_RTL8187 is not set
-# CONFIG_RTL8192E is not set
-# CONFIG_RTL8192U is not set
-# CONFIG_RTL8306_PHY is not set
-# CONFIG_RTL8366RB_PHY is not set
-# CONFIG_RTL8366S_PHY is not set
-# CONFIG_RTL8366_SMI is not set
-# CONFIG_RTL8366_SMI_DEBUG_FS is not set
-# CONFIG_RTL8367B_PHY is not set
-# CONFIG_RTL8367_PHY is not set
-# CONFIG_RTLLIB is not set
-# CONFIG_RTL_CARDS is not set
-# CONFIG_RTS5208 is not set
-CONFIG_RT_MUTEXES=y
-# CONFIG_RUNTIME_DEBUG is not set
-CONFIG_RUNTIME_TESTING_MENU=y
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-CONFIG_RXKAD=y
-# CONFIG_S2IO is not set
-# CONFIG_SAMPLES is not set
-# CONFIG_SAMSUNG_LAPTOP is not set
-# CONFIG_SATA_ACARD_AHCI is not set
-# CONFIG_SATA_AHCI is not set
-# CONFIG_SATA_AHCI_PLATFORM is not set
-# CONFIG_SATA_DWC is not set
-# CONFIG_SATA_FSL is not set
-# CONFIG_SATA_HIGHBANK is not set
-# CONFIG_SATA_INIC162X is not set
-CONFIG_SATA_MOBILE_LPM_POLICY=0
-# CONFIG_SATA_MV is not set
-# CONFIG_SATA_NV is not set
-# CONFIG_SATA_PMP is not set
-# CONFIG_SATA_PROMISE is not set
-# CONFIG_SATA_QSTOR is not set
-# CONFIG_SATA_RCAR is not set
-# CONFIG_SATA_SIL is not set
-# CONFIG_SATA_SIL24 is not set
-# CONFIG_SATA_SIS is not set
-# CONFIG_SATA_SVW is not set
-# CONFIG_SATA_SX4 is not set
-# CONFIG_SATA_ULI is not set
-# CONFIG_SATA_VIA is not set
-# CONFIG_SATA_VITESSE is not set
-# CONFIG_SBC_FITPC2_WATCHDOG is not set
-CONFIG_SBITMAP=y
-# CONFIG_SC92031 is not set
-# CONFIG_SCA3000 is not set
-# CONFIG_SCACHE_DEBUGFS is not set
-# CONFIG_SCC is not set
-# CONFIG_SCHEDSTATS is not set
-# CONFIG_SCHED_AUTOGROUP is not set
-# CONFIG_SCHED_DEBUG is not set
-CONFIG_SCHED_HRTICK=y
-# CONFIG_SCHED_MC is not set
-CONFIG_SCHED_OMIT_FRAME_POINTER=y
-# CONFIG_SCHED_SMT is not set
-# CONFIG_SCHED_STACK_END_CHECK is not set
-# CONFIG_SCHED_TRACER is not set
-# CONFIG_SCR24X is not set
-# CONFIG_SCSI is not set
-# CONFIG_SCSI_3W_9XXX is not set
-# CONFIG_SCSI_3W_SAS is not set
-# CONFIG_SCSI_7000FASST is not set
-# CONFIG_SCSI_AACRAID is not set
-# CONFIG_SCSI_ACARD is not set
-# CONFIG_SCSI_ADVANSYS is not set
-# CONFIG_SCSI_AHA152X is not set
-# CONFIG_SCSI_AHA1542 is not set
-# CONFIG_SCSI_AIC79XX is not set
-# CONFIG_SCSI_AIC7XXX is not set
-# CONFIG_SCSI_AIC94XX is not set
-# CONFIG_SCSI_AM53C974 is not set
-# CONFIG_SCSI_ARCMSR is not set
-# CONFIG_SCSI_BFA_FC is not set
-# CONFIG_SCSI_BNX2X_FCOE is not set
-# CONFIG_SCSI_BNX2_ISCSI is not set
-# CONFIG_SCSI_BUSLOGIC is not set
-# CONFIG_SCSI_CHELSIO_FCOE is not set
-# CONFIG_SCSI_CONSTANTS is not set
-# CONFIG_SCSI_CXGB3_ISCSI is not set
-# CONFIG_SCSI_CXGB4_ISCSI is not set
-# CONFIG_SCSI_DC395x is not set
-# CONFIG_SCSI_DEBUG is not set
-# CONFIG_SCSI_DH is not set
-CONFIG_SCSI_DMA=y
-# CONFIG_SCSI_DMX3191D is not set
-# CONFIG_SCSI_DPT_I2O is not set
-# CONFIG_SCSI_DTC3280 is not set
-# CONFIG_SCSI_EATA is not set
-# CONFIG_SCSI_ESAS2R is not set
-# CONFIG_SCSI_FC_ATTRS is not set
-# CONFIG_SCSI_FUTURE_DOMAIN is not set
-# CONFIG_SCSI_GDTH is not set
-# CONFIG_SCSI_GENERIC_NCR5380 is not set
-# CONFIG_SCSI_GENERIC_NCR5380_MMIO is not set
-# CONFIG_SCSI_HISI_SAS is not set
-# CONFIG_SCSI_HPSA is not set
-# CONFIG_SCSI_HPTIOP is not set
-# CONFIG_SCSI_IN2000 is not set
-# CONFIG_SCSI_INIA100 is not set
-# CONFIG_SCSI_INITIO is not set
-# CONFIG_SCSI_IPR is not set
-# CONFIG_SCSI_IPS is not set
-# CONFIG_SCSI_ISCI is not set
-# CONFIG_SCSI_ISCSI_ATTRS is not set
-# CONFIG_SCSI_LOGGING is not set
-CONFIG_SCSI_LOWLEVEL=y
-# CONFIG_SCSI_LOWLEVEL_PCMCIA is not set
-# CONFIG_SCSI_LPFC is not set
-CONFIG_SCSI_MOD=y
-# CONFIG_SCSI_MPT2SAS is not set
-# CONFIG_SCSI_MPT3SAS is not set
-# CONFIG_SCSI_MQ_DEFAULT is not set
-# CONFIG_SCSI_MVSAS is not set
-# CONFIG_SCSI_MVSAS_DEBUG is not set
-# CONFIG_SCSI_MVUMI is not set
-# CONFIG_SCSI_NCR53C406A is not set
-# CONFIG_SCSI_NETLINK is not set
-# CONFIG_SCSI_NSP32 is not set
-# CONFIG_SCSI_OSD_INITIATOR is not set
-# CONFIG_SCSI_PAS16 is not set
-# CONFIG_SCSI_PM8001 is not set
-# CONFIG_SCSI_PMCRAID is not set
-CONFIG_SCSI_PROC_FS=y
-# CONFIG_SCSI_QLA_FC is not set
-# CONFIG_SCSI_QLA_ISCSI is not set
-# CONFIG_SCSI_QLOGIC_1280 is not set
-# CONFIG_SCSI_QLOGIC_FAS is not set
-# CONFIG_SCSI_SAS_ATTRS is not set
-# CONFIG_SCSI_SAS_LIBSAS is not set
-# CONFIG_SCSI_SCAN_ASYNC is not set
-# CONFIG_SCSI_SMARTPQI is not set
-# CONFIG_SCSI_SNIC is not set
-# CONFIG_SCSI_SPI_ATTRS is not set
-# CONFIG_SCSI_SRP_ATTRS is not set
-# CONFIG_SCSI_STEX is not set
-# CONFIG_SCSI_SYM53C416 is not set
-# CONFIG_SCSI_SYM53C8XX_2 is not set
-# CONFIG_SCSI_T128 is not set
-# CONFIG_SCSI_U14_34F is not set
-# CONFIG_SCSI_UFSHCD is not set
-# CONFIG_SCSI_ULTRASTOR is not set
-# CONFIG_SCSI_VIRTIO is not set
-# CONFIG_SCSI_WD719X is not set
-# CONFIG_SCx200_ACB is not set
-# CONFIG_SDIO_UART is not set
-# CONFIG_SD_ADC_MODULATOR is not set
-# CONFIG_SECCOMP is not set
-CONFIG_SECTION_MISMATCH_WARN_ONLY=y
-# CONFIG_SECURITY is not set
-# CONFIG_SECURITYFS is not set
-CONFIG_SECURITY_DMESG_RESTRICT=y
-CONFIG_SELECT_MEMORY_MODEL=y
-# CONFIG_SENSORS_ABITUGURU is not set
-# CONFIG_SENSORS_ABITUGURU3 is not set
-# CONFIG_SENSORS_ACPI_POWER is not set
-# CONFIG_SENSORS_AD7314 is not set
-# CONFIG_SENSORS_AD7414 is not set
-# CONFIG_SENSORS_AD7418 is not set
-# CONFIG_SENSORS_ADC128D818 is not set
-# CONFIG_SENSORS_ADCXX is not set
-# CONFIG_SENSORS_ADM1021 is not set
-# CONFIG_SENSORS_ADM1025 is not set
-# CONFIG_SENSORS_ADM1026 is not set
-# CONFIG_SENSORS_ADM1029 is not set
-# CONFIG_SENSORS_ADM1031 is not set
-# CONFIG_SENSORS_ADM1275 is not set
-# CONFIG_SENSORS_ADM9240 is not set
-# CONFIG_SENSORS_ADS1015 is not set
-# CONFIG_SENSORS_ADS7828 is not set
-# CONFIG_SENSORS_ADS7871 is not set
-# CONFIG_SENSORS_ADT7310 is not set
-# CONFIG_SENSORS_ADT7410 is not set
-# CONFIG_SENSORS_ADT7411 is not set
-# CONFIG_SENSORS_ADT7462 is not set
-# CONFIG_SENSORS_ADT7470 is not set
-# CONFIG_SENSORS_ADT7475 is not set
-# CONFIG_SENSORS_AMC6821 is not set
-# CONFIG_SENSORS_APDS990X is not set
-# CONFIG_SENSORS_APPLESMC is not set
-# CONFIG_SENSORS_ASB100 is not set
-# CONFIG_SENSORS_ASC7621 is not set
-# CONFIG_SENSORS_ASPEED is not set
-# CONFIG_SENSORS_ATK0110 is not set
-# CONFIG_SENSORS_ATXP1 is not set
-# CONFIG_SENSORS_BH1770 is not set
-# CONFIG_SENSORS_BH1780 is not set
-# CONFIG_SENSORS_CORETEMP is not set
-# CONFIG_SENSORS_DELL_SMM is not set
-# CONFIG_SENSORS_DME1737 is not set
-# CONFIG_SENSORS_DS1621 is not set
-# CONFIG_SENSORS_DS620 is not set
-# CONFIG_SENSORS_EMC1403 is not set
-# CONFIG_SENSORS_EMC2103 is not set
-# CONFIG_SENSORS_EMC6W201 is not set
-# CONFIG_SENSORS_F71805F is not set
-# CONFIG_SENSORS_F71882FG is not set
-# CONFIG_SENSORS_F75375S is not set
-# CONFIG_SENSORS_FAM15H_POWER is not set
-# CONFIG_SENSORS_FSCHMD is not set
-# CONFIG_SENSORS_FTSTEUTATES is not set
-# CONFIG_SENSORS_G760A is not set
-# CONFIG_SENSORS_G762 is not set
-# CONFIG_SENSORS_GL518SM is not set
-# CONFIG_SENSORS_GL520SM is not set
-# CONFIG_SENSORS_GPIO_FAN is not set
-# CONFIG_SENSORS_GSC is not set
-# CONFIG_SENSORS_HDAPS is not set
-# CONFIG_SENSORS_HIH6130 is not set
-# CONFIG_SENSORS_HMC5843 is not set
-# CONFIG_SENSORS_HMC5843_I2C is not set
-# CONFIG_SENSORS_HMC5843_SPI is not set
-# CONFIG_SENSORS_HTU21 is not set
-# CONFIG_SENSORS_I5500 is not set
-# CONFIG_SENSORS_I5K_AMB is not set
-# CONFIG_SENSORS_IBM_CFFPS is not set
-# CONFIG_SENSORS_IIO_HWMON is not set
-# CONFIG_SENSORS_INA209 is not set
-# CONFIG_SENSORS_INA2XX is not set
-# CONFIG_SENSORS_INA3221 is not set
-# CONFIG_SENSORS_IR35221 is not set
-# CONFIG_SENSORS_ISL29018 is not set
-# CONFIG_SENSORS_ISL29028 is not set
-# CONFIG_SENSORS_IT87 is not set
-# CONFIG_SENSORS_JC42 is not set
-# CONFIG_SENSORS_K10TEMP is not set
-# CONFIG_SENSORS_K8TEMP is not set
-# CONFIG_SENSORS_LINEAGE is not set
-# CONFIG_SENSORS_LIS3LV02D is not set
-# CONFIG_SENSORS_LIS3_I2C is not set
-# CONFIG_SENSORS_LIS3_SPI is not set
-# CONFIG_SENSORS_LM25066 is not set
-# CONFIG_SENSORS_LM63 is not set
-# CONFIG_SENSORS_LM70 is not set
-# CONFIG_SENSORS_LM73 is not set
-# CONFIG_SENSORS_LM75 is not set
-# CONFIG_SENSORS_LM77 is not set
-# CONFIG_SENSORS_LM78 is not set
-# CONFIG_SENSORS_LM80 is not set
-# CONFIG_SENSORS_LM83 is not set
-# CONFIG_SENSORS_LM85 is not set
-# CONFIG_SENSORS_LM87 is not set
-# CONFIG_SENSORS_LM90 is not set
-# CONFIG_SENSORS_LM92 is not set
-# CONFIG_SENSORS_LM93 is not set
-# CONFIG_SENSORS_LM95234 is not set
-# CONFIG_SENSORS_LM95241 is not set
-# CONFIG_SENSORS_LM95245 is not set
-# CONFIG_SENSORS_LTC2945 is not set
-# CONFIG_SENSORS_LTC2978 is not set
-# CONFIG_SENSORS_LTC2990 is not set
-# CONFIG_SENSORS_LTC3815 is not set
-# CONFIG_SENSORS_LTC4151 is not set
-# CONFIG_SENSORS_LTC4215 is not set
-# CONFIG_SENSORS_LTC4222 is not set
-# CONFIG_SENSORS_LTC4245 is not set
-# CONFIG_SENSORS_LTC4260 is not set
-# CONFIG_SENSORS_LTC4261 is not set
-# CONFIG_SENSORS_MAX1111 is not set
-# CONFIG_SENSORS_MAX16064 is not set
-# CONFIG_SENSORS_MAX16065 is not set
-# CONFIG_SENSORS_MAX1619 is not set
-# CONFIG_SENSORS_MAX1668 is not set
-# CONFIG_SENSORS_MAX197 is not set
-# CONFIG_SENSORS_MAX20751 is not set
-# CONFIG_SENSORS_MAX31722 is not set
-# CONFIG_SENSORS_MAX31785 is not set
-# CONFIG_SENSORS_MAX31790 is not set
-# CONFIG_SENSORS_MAX34440 is not set
-# CONFIG_SENSORS_MAX6621 is not set
-# CONFIG_SENSORS_MAX6639 is not set
-# CONFIG_SENSORS_MAX6642 is not set
-# CONFIG_SENSORS_MAX6650 is not set
-# CONFIG_SENSORS_MAX6697 is not set
-# CONFIG_SENSORS_MAX8688 is not set
-# CONFIG_SENSORS_MCP3021 is not set
-# CONFIG_SENSORS_NCT6683 is not set
-# CONFIG_SENSORS_NCT6775 is not set
-# CONFIG_SENSORS_NCT7802 is not set
-# CONFIG_SENSORS_NCT7904 is not set
-# CONFIG_SENSORS_NPCM7XX is not set
-# CONFIG_SENSORS_NSA320 is not set
-# CONFIG_SENSORS_NTC_THERMISTOR is not set
-# CONFIG_SENSORS_PC87360 is not set
-# CONFIG_SENSORS_PC87427 is not set
-# CONFIG_SENSORS_PCF8591 is not set
-# CONFIG_SENSORS_PMBUS is not set
-# CONFIG_SENSORS_POWR1220 is not set
-# CONFIG_SENSORS_PWM_FAN is not set
-# CONFIG_SENSORS_SCH5627 is not set
-# CONFIG_SENSORS_SCH5636 is not set
-# CONFIG_SENSORS_SCH56XX_COMMON is not set
-# CONFIG_SENSORS_SHT15 is not set
-# CONFIG_SENSORS_SHT21 is not set
-# CONFIG_SENSORS_SHT3x is not set
-# CONFIG_SENSORS_SHTC1 is not set
-# CONFIG_SENSORS_SIS5595 is not set
-# CONFIG_SENSORS_SMM665 is not set
-# CONFIG_SENSORS_SMSC47B397 is not set
-# CONFIG_SENSORS_SMSC47M1 is not set
-# CONFIG_SENSORS_SMSC47M192 is not set
-# CONFIG_SENSORS_STTS751 is not set
-# CONFIG_SENSORS_TC654 is not set
-# CONFIG_SENSORS_TC74 is not set
-# CONFIG_SENSORS_THMC50 is not set
-# CONFIG_SENSORS_TMP102 is not set
-# CONFIG_SENSORS_TMP103 is not set
-# CONFIG_SENSORS_TMP108 is not set
-# CONFIG_SENSORS_TMP401 is not set
-# CONFIG_SENSORS_TMP421 is not set
-# CONFIG_SENSORS_TPS40422 is not set
-# CONFIG_SENSORS_TPS53679 is not set
-# CONFIG_SENSORS_TSL2550 is not set
-# CONFIG_SENSORS_TSL2563 is not set
-# CONFIG_SENSORS_UCD9000 is not set
-# CONFIG_SENSORS_UCD9200 is not set
-# CONFIG_SENSORS_VEXPRESS is not set
-# CONFIG_SENSORS_VIA686A is not set
-# CONFIG_SENSORS_VIA_CPUTEMP is not set
-# CONFIG_SENSORS_VT1211 is not set
-# CONFIG_SENSORS_VT8231 is not set
-# CONFIG_SENSORS_W83627EHF is not set
-# CONFIG_SENSORS_W83627HF is not set
-# CONFIG_SENSORS_W83773G is not set
-# CONFIG_SENSORS_W83781D is not set
-# CONFIG_SENSORS_W83791D is not set
-# CONFIG_SENSORS_W83792D is not set
-# CONFIG_SENSORS_W83793 is not set
-# CONFIG_SENSORS_W83795 is not set
-# CONFIG_SENSORS_W83L785TS is not set
-# CONFIG_SENSORS_W83L786NG is not set
-# CONFIG_SENSORS_XGENE is not set
-# CONFIG_SENSORS_ZL6100 is not set
-CONFIG_SERIAL_8250=y
-# CONFIG_SERIAL_8250_ACCENT is not set
-# CONFIG_SERIAL_8250_ASPEED_VUART is not set
-# CONFIG_SERIAL_8250_BOCA is not set
-CONFIG_SERIAL_8250_CONSOLE=y
-# CONFIG_SERIAL_8250_CS is not set
-# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
-# CONFIG_SERIAL_8250_DETECT_IRQ is not set
-CONFIG_SERIAL_8250_DMA=y
-# CONFIG_SERIAL_8250_DW is not set
-# CONFIG_SERIAL_8250_EM is not set
-# CONFIG_SERIAL_8250_EXAR is not set
-# CONFIG_SERIAL_8250_EXAR_ST16C554 is not set
-# CONFIG_SERIAL_8250_EXTENDED is not set
-# CONFIG_SERIAL_8250_FINTEK is not set
-# CONFIG_SERIAL_8250_FOURPORT is not set
-# CONFIG_SERIAL_8250_HUB6 is not set
-# CONFIG_SERIAL_8250_INGENIC is not set
-# CONFIG_SERIAL_8250_LPSS is not set
-# CONFIG_SERIAL_8250_MANY_PORTS is not set
-# CONFIG_SERIAL_8250_MID is not set
-# CONFIG_SERIAL_8250_MOXA is not set
-CONFIG_SERIAL_8250_NR_UARTS=2
-# CONFIG_SERIAL_8250_PCI is not set
-# CONFIG_SERIAL_8250_RSA is not set
-# CONFIG_SERIAL_8250_RT288X is not set
-CONFIG_SERIAL_8250_RUNTIME_UARTS=2
-# CONFIG_SERIAL_ALTERA_JTAGUART is not set
-# CONFIG_SERIAL_ALTERA_UART is not set
-# CONFIG_SERIAL_AMBA_PL010 is not set
-# CONFIG_SERIAL_ARC is not set
-# CONFIG_SERIAL_BCM63XX is not set
-# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
-CONFIG_SERIAL_CORE=y
-CONFIG_SERIAL_CORE_CONSOLE=y
-# CONFIG_SERIAL_DEV_BUS is not set
-CONFIG_SERIAL_EARLYCON=y
-# CONFIG_SERIAL_EARLYCON_ARM_SEMIHOST is not set
-# CONFIG_SERIAL_FSL_LPUART is not set
-# CONFIG_SERIAL_GRLIB_GAISLER_APBUART is not set
-# CONFIG_SERIAL_IFX6X60 is not set
-# CONFIG_SERIAL_JSM is not set
-# CONFIG_SERIAL_MAX3100 is not set
-# CONFIG_SERIAL_MAX310X is not set
-# CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_SERIAL_OF_PLATFORM is not set
-# CONFIG_SERIAL_OF_PLATFORM_NWPSERIAL is not set
-# CONFIG_SERIAL_PCH_UART is not set
-# CONFIG_SERIAL_RP2 is not set
-# CONFIG_SERIAL_SC16IS7XX is not set
-# CONFIG_SERIAL_SCCNXP is not set
-# CONFIG_SERIAL_SH_SCI is not set
-# CONFIG_SERIAL_STM32 is not set
-# CONFIG_SERIAL_ST_ASC is not set
-# CONFIG_SERIAL_TIMBERDALE is not set
-# CONFIG_SERIAL_UARTLITE is not set
-# CONFIG_SERIAL_XILINX_PS_UART is not set
-# CONFIG_SERIO is not set
-# CONFIG_SERIO_ALTERA_PS2 is not set
-# CONFIG_SERIO_AMBAKMI is not set
-# CONFIG_SERIO_APBPS2 is not set
-# CONFIG_SERIO_ARC_PS2 is not set
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_GPIO_PS2 is not set
-# CONFIG_SERIO_I8042 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-# CONFIG_SERIO_PARKBD is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_PS2MULT is not set
-# CONFIG_SERIO_RAW is not set
-# CONFIG_SERIO_SERPORT is not set
-# CONFIG_SERIO_SUN4I_PS2 is not set
-# CONFIG_SFC is not set
-# CONFIG_SFC_FALCON is not set
-# CONFIG_SFI is not set
-# CONFIG_SGETMASK_SYSCALL is not set
-# CONFIG_SGI_IOC4 is not set
-# CONFIG_SGI_IP22 is not set
-# CONFIG_SGI_IP27 is not set
-# CONFIG_SGI_IP28 is not set
-# CONFIG_SGI_IP32 is not set
-# CONFIG_SGI_PARTITION is not set
-# CONFIG_SG_POOL is not set
-# CONFIG_SG_SPLIT is not set
-CONFIG_SHMEM=y
-# CONFIG_SH_ETH is not set
-# CONFIG_SH_TIMER_CMT is not set
-# CONFIG_SH_TIMER_MTU2 is not set
-# CONFIG_SH_TIMER_TMU is not set
-# CONFIG_SI1133 is not set
-# CONFIG_SI1145 is not set
-# CONFIG_SI7005 is not set
-# CONFIG_SI7020 is not set
-# CONFIG_SIBYTE_BIGSUR is not set
-# CONFIG_SIBYTE_CARMEL is not set
-# CONFIG_SIBYTE_CRHINE is not set
-# CONFIG_SIBYTE_CRHONE is not set
-# CONFIG_SIBYTE_LITTLESUR is not set
-# CONFIG_SIBYTE_RHONE is not set
-# CONFIG_SIBYTE_SENTOSA is not set
-# CONFIG_SIBYTE_SWARM is not set
-CONFIG_SIGNALFD=y
-# CONFIG_SIGNED_PE_FILE_VERIFICATION is not set
-# CONFIG_SIMPLE_GPIO is not set
-# CONFIG_SIMPLE_PM_BUS is not set
-# CONFIG_SIOX is not set
-# CONFIG_SIS190 is not set
-# CONFIG_SIS900 is not set
-# CONFIG_SKGE is not set
-# CONFIG_SKY2 is not set
-# CONFIG_SKY2_DEBUG is not set
-# CONFIG_SLAB is not set
-CONFIG_SLABINFO=y
-# CONFIG_SLAB_FREELIST_HARDENED is not set
-# CONFIG_SLAB_FREELIST_RANDOM is not set
-CONFIG_SLAB_MERGE_DEFAULT=y
-# CONFIG_SLHC is not set
-# CONFIG_SLICOSS is not set
-# CONFIG_SLIMBUS is not set
-# CONFIG_SLIP is not set
-# CONFIG_SLOB is not set
-CONFIG_SLUB=y
-CONFIG_SLUB_CPU_PARTIAL=y
-# CONFIG_SLUB_DEBUG is not set
-# CONFIG_SLUB_DEBUG_ON is not set
-# CONFIG_SLUB_MEMCG_SYSFS_ON is not set
-# CONFIG_SLUB_STATS is not set
-# CONFIG_SMARTJOYPLUS_FF is not set
-# CONFIG_SMC911X is not set
-# CONFIG_SMC9194 is not set
-# CONFIG_SMC91X is not set
-# CONFIG_SMP is not set
-# CONFIG_SMSC911X is not set
-# CONFIG_SMSC9420 is not set
-# CONFIG_SMSC_PHY is not set
-# CONFIG_SM_FTL is not set
-# CONFIG_SND is not set
-# CONFIG_SND_AC97_POWER_SAVE is not set
-# CONFIG_SND_AD1816A is not set
-# CONFIG_SND_AD1848 is not set
-# CONFIG_SND_AD1889 is not set
-# CONFIG_SND_ADLIB is not set
-# CONFIG_SND_ALI5451 is not set
-# CONFIG_SND_ALOOP is not set
-# CONFIG_SND_ALS100 is not set
-# CONFIG_SND_ALS300 is not set
-# CONFIG_SND_ALS4000 is not set
-# CONFIG_SND_ARM is not set
-# CONFIG_SND_ASIHPI is not set
-# CONFIG_SND_ATIIXP is not set
-# CONFIG_SND_ATIIXP_MODEM is not set
-# CONFIG_SND_ATMEL_AC97C is not set
-# CONFIG_SND_ATMEL_SOC is not set
-# CONFIG_SND_AU8810 is not set
-# CONFIG_SND_AU8820 is not set
-# CONFIG_SND_AU8830 is not set
-# CONFIG_SND_AUDIO_GRAPH_CARD is not set
-# CONFIG_SND_AUDIO_GRAPH_SCU_CARD is not set
-# CONFIG_SND_AW2 is not set
-# CONFIG_SND_AZT2320 is not set
-# CONFIG_SND_AZT3328 is not set
-# CONFIG_SND_BCD2000 is not set
-# CONFIG_SND_BT87X is not set
-# CONFIG_SND_CA0106 is not set
-# CONFIG_SND_CMI8330 is not set
-# CONFIG_SND_CMIPCI is not set
-# CONFIG_SND_CS4231 is not set
-# CONFIG_SND_CS4236 is not set
-# CONFIG_SND_CS4281 is not set
-# CONFIG_SND_CS46XX is not set
-# CONFIG_SND_CS5530 is not set
-# CONFIG_SND_CS5535AUDIO is not set
-# CONFIG_SND_CTXFI is not set
-# CONFIG_SND_DARLA20 is not set
-# CONFIG_SND_DARLA24 is not set
-# CONFIG_SND_DEBUG is not set
-# CONFIG_SND_DESIGNWARE_I2S is not set
-CONFIG_SND_DRIVERS=y
-# CONFIG_SND_DUMMY is not set
-# CONFIG_SND_DYNAMIC_MINORS is not set
-# CONFIG_SND_ECHO3G is not set
-# CONFIG_SND_EDMA_SOC is not set
-# CONFIG_SND_EMU10K1 is not set
-# CONFIG_SND_EMU10K1X is not set
-# CONFIG_SND_EMU10K1_SEQ is not set
-# CONFIG_SND_ENS1370 is not set
-# CONFIG_SND_ENS1371 is not set
-# CONFIG_SND_ES1688 is not set
-# CONFIG_SND_ES18XX is not set
-# CONFIG_SND_ES1938 is not set
-# CONFIG_SND_ES1968 is not set
-# CONFIG_SND_FIREWIRE is not set
-# CONFIG_SND_FM801 is not set
-# CONFIG_SND_GINA20 is not set
-# CONFIG_SND_GINA24 is not set
-# CONFIG_SND_GUSCLASSIC is not set
-# CONFIG_SND_GUSEXTREME is not set
-# CONFIG_SND_GUSMAX is not set
-# CONFIG_SND_HDA_INTEL is not set
-CONFIG_SND_HDA_POWER_SAVE_DEFAULT=0
-CONFIG_SND_HDA_PREALLOC_SIZE=64
-# CONFIG_SND_HDSP is not set
-# CONFIG_SND_HDSPM is not set
-# CONFIG_SND_HRTIMER is not set
-# CONFIG_SND_HWDEP is not set
-# CONFIG_SND_I2S_HI6210_I2S is not set
-# CONFIG_SND_ICE1712 is not set
-# CONFIG_SND_ICE1724 is not set
-# CONFIG_SND_INDIGO is not set
-# CONFIG_SND_INDIGODJ is not set
-# CONFIG_SND_INDIGODJX is not set
-# CONFIG_SND_INDIGOIO is not set
-# CONFIG_SND_INDIGOIOX is not set
-# CONFIG_SND_INTEL8X0 is not set
-# CONFIG_SND_INTEL8X0M is not set
-# CONFIG_SND_INTERWAVE is not set
-# CONFIG_SND_INTERWAVE_STB is not set
-# CONFIG_SND_ISA is not set
-# CONFIG_SND_KIRKWOOD_SOC is not set
-# CONFIG_SND_KORG1212 is not set
-# CONFIG_SND_LAYLA20 is not set
-# CONFIG_SND_LAYLA24 is not set
-# CONFIG_SND_LOLA is not set
-# CONFIG_SND_LX6464ES is not set
-# CONFIG_SND_MAESTRO3 is not set
-CONFIG_SND_MAX_CARDS=16
-# CONFIG_SND_MIA is not set
-# CONFIG_SND_MIPS is not set
-# CONFIG_SND_MIRO is not set
-# CONFIG_SND_MIXART is not set
-# CONFIG_SND_MIXER_OSS is not set
-# CONFIG_SND_MONA is not set
-# CONFIG_SND_MPC52xx_SOC_EFIKA is not set
-# CONFIG_SND_MPU401 is not set
-# CONFIG_SND_MTPAV is not set
-# CONFIG_SND_MTS64 is not set
-# CONFIG_SND_MXS_SOC is not set
-# CONFIG_SND_NM256 is not set
-# CONFIG_SND_OPL3SA2 is not set
-# CONFIG_SND_OPL3_LIB_SEQ is not set
-# CONFIG_SND_OPL4_LIB_SEQ is not set
-# CONFIG_SND_OPTI92X_AD1848 is not set
-# CONFIG_SND_OPTI92X_CS4231 is not set
-# CONFIG_SND_OPTI93X is not set
-CONFIG_SND_OSSEMUL=y
-# CONFIG_SND_OXYGEN is not set
-CONFIG_SND_PCI=y
-# CONFIG_SND_PCM is not set
-# CONFIG_SND_PCMCIA is not set
-# CONFIG_SND_PCM_OSS is not set
-CONFIG_SND_PCM_OSS_PLUGINS=y
-# CONFIG_SND_PCM_TIMER is not set
-# CONFIG_SND_PCM_XRUN_DEBUG is not set
-# CONFIG_SND_PCXHR is not set
-# CONFIG_SND_PDAUDIOCF is not set
-# CONFIG_SND_PORTMAN2X4 is not set
-# CONFIG_SND_POWERPC_SOC is not set
-# CONFIG_SND_PPC is not set
-CONFIG_SND_PROC_FS=y
-# CONFIG_SND_RAWMIDI is not set
-# CONFIG_SND_RAWMIDI_SEQ is not set
-# CONFIG_SND_RIPTIDE is not set
-# CONFIG_SND_RME32 is not set
-# CONFIG_SND_RME96 is not set
-# CONFIG_SND_RME9652 is not set
-# CONFIG_SND_RTCTIMER is not set
-# CONFIG_SND_SB16 is not set
-# CONFIG_SND_SB8 is not set
-# CONFIG_SND_SBAWE is not set
-# CONFIG_SND_SBAWE_SEQ is not set
-# CONFIG_SND_SE6X is not set
-# CONFIG_SND_SEQUENCER is not set
-# CONFIG_SND_SERIAL_U16550 is not set
-# CONFIG_SND_SIMPLE_CARD is not set
-# CONFIG_SND_SIMPLE_SCU_CARD is not set
-# CONFIG_SND_SIS7019 is not set
-# CONFIG_SND_SOC is not set
-# CONFIG_SND_SOC_AC97_CODEC is not set
-# CONFIG_SND_SOC_ADAU1701 is not set
-# CONFIG_SND_SOC_ADAU1761_I2C is not set
-# CONFIG_SND_SOC_ADAU1761_SPI is not set
-# CONFIG_SND_SOC_ADAU7002 is not set
-# CONFIG_SND_SOC_AK4104 is not set
-# CONFIG_SND_SOC_AK4458 is not set
-# CONFIG_SND_SOC_AK4554 is not set
-# CONFIG_SND_SOC_AK4613 is not set
-# CONFIG_SND_SOC_AK4642 is not set
-# CONFIG_SND_SOC_AK5386 is not set
-# CONFIG_SND_SOC_AK5558 is not set
-# CONFIG_SND_SOC_ALC5623 is not set
-# CONFIG_SND_SOC_AMD_ACP is not set
-# CONFIG_SND_SOC_AU1XAUDIO is not set
-# CONFIG_SND_SOC_AU1XPSC is not set
-# CONFIG_SND_SOC_BD28623 is not set
-# CONFIG_SND_SOC_BT_SCO is not set
-# CONFIG_SND_SOC_CS35L32 is not set
-# CONFIG_SND_SOC_CS35L33 is not set
-# CONFIG_SND_SOC_CS35L34 is not set
-# CONFIG_SND_SOC_CS35L35 is not set
-# CONFIG_SND_SOC_CS4265 is not set
-# CONFIG_SND_SOC_CS4270 is not set
-# CONFIG_SND_SOC_CS4271 is not set
-# CONFIG_SND_SOC_CS4271_I2C is not set
-# CONFIG_SND_SOC_CS4271_SPI is not set
-# CONFIG_SND_SOC_CS42L42 is not set
-# CONFIG_SND_SOC_CS42L51_I2C is not set
-# CONFIG_SND_SOC_CS42L52 is not set
-# CONFIG_SND_SOC_CS42L56 is not set
-# CONFIG_SND_SOC_CS42L73 is not set
-# CONFIG_SND_SOC_CS42XX8_I2C is not set
-# CONFIG_SND_SOC_CS43130 is not set
-# CONFIG_SND_SOC_CS4349 is not set
-# CONFIG_SND_SOC_CS53L30 is not set
-# CONFIG_SND_SOC_DIO2125 is not set
-# CONFIG_SND_SOC_ES7134 is not set
-# CONFIG_SND_SOC_ES7241 is not set
-# CONFIG_SND_SOC_ES8316 is not set
-# CONFIG_SND_SOC_ES8328 is not set
-# CONFIG_SND_SOC_ES8328_I2C is not set
-# CONFIG_SND_SOC_ES8328_SPI is not set
-# CONFIG_SND_SOC_EUKREA_TLV320 is not set
-# CONFIG_SND_SOC_FSL_ASOC_CARD is not set
-# CONFIG_SND_SOC_FSL_ASRC is not set
-# CONFIG_SND_SOC_FSL_ESAI is not set
-# CONFIG_SND_SOC_FSL_SAI is not set
-# CONFIG_SND_SOC_FSL_SPDIF is not set
-# CONFIG_SND_SOC_FSL_SSI is not set
-# CONFIG_SND_SOC_GTM601 is not set
-# CONFIG_SND_SOC_ICS43432 is not set
-# CONFIG_SND_SOC_IMG is not set
-# CONFIG_SND_SOC_IMX_AUDMUX is not set
-# CONFIG_SND_SOC_IMX_ES8328 is not set
-# CONFIG_SND_SOC_IMX_SPDIF is not set
-# CONFIG_SND_SOC_IMX_WM8962 is not set
-# CONFIG_SND_SOC_INNO_RK3036 is not set
-# CONFIG_SND_SOC_INTEL_BAYTRAIL is not set
-# CONFIG_SND_SOC_INTEL_BDW_RT5677_MACH is not set
-# CONFIG_SND_SOC_INTEL_BXT_DA7219_MAX98357A_MACH is not set
-# CONFIG_SND_SOC_INTEL_BXT_RT298_MACH is not set
-# CONFIG_SND_SOC_INTEL_BYTCR_RT5640_MACH is not set
-# CONFIG_SND_SOC_INTEL_BYTCR_RT5651_MACH is not set
-# CONFIG_SND_SOC_INTEL_BYT_CHT_DA7213_MACH is not set
-# CONFIG_SND_SOC_INTEL_BYT_CHT_ES8316_MACH is not set
-# CONFIG_SND_SOC_INTEL_BYT_CHT_NOCODEC_MACH is not set
-# CONFIG_SND_SOC_INTEL_BYT_MAX98090_MACH is not set
-# CONFIG_SND_SOC_INTEL_BYT_RT5640_MACH is not set
-# CONFIG_SND_SOC_INTEL_CHT_BSW_MAX98090_TI_MACH is not set
-# CONFIG_SND_SOC_INTEL_CHT_BSW_NAU8824_MACH is not set
-# CONFIG_SND_SOC_INTEL_CHT_BSW_RT5645_MACH is not set
-# CONFIG_SND_SOC_INTEL_CHT_BSW_RT5672_MACH is not set
-# CONFIG_SND_SOC_INTEL_HASWELL is not set
-# CONFIG_SND_SOC_INTEL_KBL_RT5663_MAX98927_MACH is not set
-# CONFIG_SND_SOC_INTEL_KBL_RT5663_RT5514_MAX98927_MACH is not set
-# CONFIG_SND_SOC_INTEL_SKL_NAU88L25_MAX98357A_MACH is not set
-# CONFIG_SND_SOC_INTEL_SKL_NAU88L25_SSM4567_MACH is not set
-# CONFIG_SND_SOC_INTEL_SKL_RT286_MACH is not set
-# CONFIG_SND_SOC_INTEL_SKYLAKE is not set
-# CONFIG_SND_SOC_INTEL_SST is not set
-CONFIG_SND_SOC_INTEL_SST_TOPLEVEL=y
-# CONFIG_SND_SOC_MAX9759 is not set
-# CONFIG_SND_SOC_MAX98373 is not set
-# CONFIG_SND_SOC_MAX98504 is not set
-# CONFIG_SND_SOC_MAX9860 is not set
-# CONFIG_SND_SOC_MAX9867 is not set
-# CONFIG_SND_SOC_MAX98927 is not set
-# CONFIG_SND_SOC_MEDIATEK is not set
-# CONFIG_SND_SOC_MPC5200_AC97 is not set
-# CONFIG_SND_SOC_MPC5200_I2S is not set
-# CONFIG_SND_SOC_MSM8916_WCD_ANALOG is not set
-# CONFIG_SND_SOC_MSM8916_WCD_DIGITAL is not set
-# CONFIG_SND_SOC_MT2701 is not set
-# CONFIG_SND_SOC_MT6351 is not set
-# CONFIG_SND_SOC_MT8173 is not set
-# CONFIG_SND_SOC_NAU8540 is not set
-# CONFIG_SND_SOC_NAU8810 is not set
-# CONFIG_SND_SOC_NAU8824 is not set
-# CONFIG_SND_SOC_PCM1681 is not set
-# CONFIG_SND_SOC_PCM1789_I2C is not set
-# CONFIG_SND_SOC_PCM1792A is not set
-# CONFIG_SND_SOC_PCM179X_I2C is not set
-# CONFIG_SND_SOC_PCM179X_SPI is not set
-# CONFIG_SND_SOC_PCM186X_I2C is not set
-# CONFIG_SND_SOC_PCM186X_SPI is not set
-# CONFIG_SND_SOC_PCM3168A_I2C is not set
-# CONFIG_SND_SOC_PCM3168A_SPI is not set
-# CONFIG_SND_SOC_PCM512x_I2C is not set
-# CONFIG_SND_SOC_PCM512x_SPI is not set
-# CONFIG_SND_SOC_QCOM is not set
-# CONFIG_SND_SOC_RT5616 is not set
-# CONFIG_SND_SOC_RT5631 is not set
-# CONFIG_SND_SOC_RT5677_SPI is not set
-# CONFIG_SND_SOC_SGTL5000 is not set
-# CONFIG_SND_SOC_SIMPLE_AMPLIFIER is not set
-# CONFIG_SND_SOC_SIRF_AUDIO_CODEC is not set
-# CONFIG_SND_SOC_SPDIF is not set
-# CONFIG_SND_SOC_SSM2305 is not set
-# CONFIG_SND_SOC_SSM2602_I2C is not set
-# CONFIG_SND_SOC_SSM2602_SPI is not set
-# CONFIG_SND_SOC_SSM4567 is not set
-# CONFIG_SND_SOC_STA32X is not set
-# CONFIG_SND_SOC_STA350 is not set
-# CONFIG_SND_SOC_STI_SAS is not set
-# CONFIG_SND_SOC_TAS2552 is not set
-# CONFIG_SND_SOC_TAS5086 is not set
-# CONFIG_SND_SOC_TAS571X is not set
-# CONFIG_SND_SOC_TAS5720 is not set
-# CONFIG_SND_SOC_TAS6424 is not set
-# CONFIG_SND_SOC_TDA7419 is not set
-# CONFIG_SND_SOC_TFA9879 is not set
-# CONFIG_SND_SOC_TLV320AIC23_I2C is not set
-# CONFIG_SND_SOC_TLV320AIC23_SPI is not set
-# CONFIG_SND_SOC_TLV320AIC31XX is not set
-# CONFIG_SND_SOC_TLV320AIC32X4_I2C is not set
-# CONFIG_SND_SOC_TLV320AIC32X4_SPI is not set
-# CONFIG_SND_SOC_TLV320AIC3X is not set
-# CONFIG_SND_SOC_TPA6130A2 is not set
-# CONFIG_SND_SOC_TS3A227E is not set
-# CONFIG_SND_SOC_TSCS42XX is not set
-# CONFIG_SND_SOC_TSCS454 is not set
-# CONFIG_SND_SOC_WM8510 is not set
-# CONFIG_SND_SOC_WM8523 is not set
-# CONFIG_SND_SOC_WM8524 is not set
-# CONFIG_SND_SOC_WM8580 is not set
-# CONFIG_SND_SOC_WM8711 is not set
-# CONFIG_SND_SOC_WM8728 is not set
-# CONFIG_SND_SOC_WM8731 is not set
-# CONFIG_SND_SOC_WM8737 is not set
-# CONFIG_SND_SOC_WM8741 is not set
-# CONFIG_SND_SOC_WM8750 is not set
-# CONFIG_SND_SOC_WM8753 is not set
-# CONFIG_SND_SOC_WM8770 is not set
-# CONFIG_SND_SOC_WM8776 is not set
-# CONFIG_SND_SOC_WM8782 is not set
-# CONFIG_SND_SOC_WM8804_I2C is not set
-# CONFIG_SND_SOC_WM8804_SPI is not set
-# CONFIG_SND_SOC_WM8903 is not set
-# CONFIG_SND_SOC_WM8960 is not set
-# CONFIG_SND_SOC_WM8962 is not set
-# CONFIG_SND_SOC_WM8974 is not set
-# CONFIG_SND_SOC_WM8978 is not set
-# CONFIG_SND_SOC_WM8985 is not set
-# CONFIG_SND_SOC_XTFPGA_I2S is not set
-# CONFIG_SND_SOC_ZX_AUD96P22 is not set
-# CONFIG_SND_SONICVIBES is not set
-# CONFIG_SND_SPI is not set
-# CONFIG_SND_SSCAPE is not set
-# CONFIG_SND_SST_ATOM_HIFI2_PLATFORM_ACPI is not set
-# CONFIG_SND_SST_ATOM_HIFI2_PLATFORM_PCI is not set
-# CONFIG_SND_SUN4I_CODEC is not set
-# CONFIG_SND_SUPPORT_OLD_API is not set
-# CONFIG_SND_TIMER is not set
-# CONFIG_SND_TRIDENT is not set
-CONFIG_SND_USB=y
-# CONFIG_SND_USB_6FIRE is not set
-# CONFIG_SND_USB_AUDIO is not set
-# CONFIG_SND_USB_CAIAQ is not set
-# CONFIG_SND_USB_HIFACE is not set
-# CONFIG_SND_USB_POD is not set
-# CONFIG_SND_USB_PODHD is not set
-# CONFIG_SND_USB_TONEPORT is not set
-# CONFIG_SND_USB_UA101 is not set
-# CONFIG_SND_USB_US122L is not set
-# CONFIG_SND_USB_USX2Y is not set
-# CONFIG_SND_USB_VARIAX is not set
-# CONFIG_SND_VERBOSE_PRINTK is not set
-CONFIG_SND_VERBOSE_PROCFS=y
-# CONFIG_SND_VIA82XX is not set
-# CONFIG_SND_VIA82XX_MODEM is not set
-# CONFIG_SND_VIRTUOSO is not set
-# CONFIG_SND_VX222 is not set
-# CONFIG_SND_VXPOCKET is not set
-# CONFIG_SND_WAVEFRONT is not set
-CONFIG_SND_X86=y
-# CONFIG_SND_XEN_FRONTEND is not set
-# CONFIG_SND_YMFPCI is not set
-# CONFIG_SNI_RM is not set
-# CONFIG_SOCIONEXT_SYNQUACER_PREITS is not set
-# CONFIG_SOCK_CGROUP_DATA is not set
-# CONFIG_SOC_AM33XX is not set
-# CONFIG_SOC_AM43XX is not set
-# CONFIG_SOC_BRCMSTB is not set
-# CONFIG_SOC_CAMERA is not set
-# CONFIG_SOC_DRA7XX is not set
-# CONFIG_SOC_HAS_OMAP2_SDRC is not set
-# CONFIG_SOC_OMAP5 is not set
-# CONFIG_SOC_TI is not set
-# CONFIG_SOFTLOCKUP_DETECTOR is not set
-# CONFIG_SOFT_WATCHDOG is not set
-# CONFIG_SOLARIS_X86_PARTITION is not set
-# CONFIG_SONYPI is not set
-# CONFIG_SONY_LAPTOP is not set
-# CONFIG_SOUND is not set
-# CONFIG_SOUNDWIRE is not set
-# CONFIG_SOUND_OSS_CORE is not set
-# CONFIG_SOUND_PRIME is not set
-# CONFIG_SP5100_TCO is not set
-# CONFIG_SPARSEMEM_MANUAL is not set
-# CONFIG_SPARSEMEM_STATIC is not set
-# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
-# CONFIG_SPARSE_IRQ is not set
-# CONFIG_SPARSE_RCU_POINTER is not set
-# CONFIG_SPEAKUP is not set
-# CONFIG_SPI is not set
-# CONFIG_SPINLOCK_TEST is not set
-# CONFIG_SPI_ALTERA is not set
-# CONFIG_SPI_AU1550 is not set
-# CONFIG_SPI_AXI_SPI_ENGINE is not set
-# CONFIG_SPI_BCM2835 is not set
-# CONFIG_SPI_BCM_QSPI is not set
-# CONFIG_SPI_BITBANG is not set
-# CONFIG_SPI_BUTTERFLY is not set
-# CONFIG_SPI_CADENCE is not set
-# CONFIG_SPI_CADENCE_QUADSPI is not set
-# CONFIG_SPI_DEBUG is not set
-# CONFIG_SPI_DESIGNWARE is not set
-# CONFIG_SPI_FSL_DSPI is not set
-# CONFIG_SPI_FSL_ESPI is not set
-# CONFIG_SPI_FSL_SPI is not set
-# CONFIG_SPI_GPIO is not set
-# CONFIG_SPI_GPIO_OLD is not set
-# CONFIG_SPI_IMG_SPFI is not set
-# CONFIG_SPI_LM70_LLP is not set
-# CONFIG_SPI_LOOPBACK_TEST is not set
-# CONFIG_SPI_MASTER is not set
-# CONFIG_SPI_MEM is not set
-# CONFIG_SPI_MPC52xx is not set
-# CONFIG_SPI_MPC52xx_PSC is not set
-# CONFIG_SPI_OCTEON is not set
-# CONFIG_SPI_OC_TINY is not set
-# CONFIG_SPI_ORION is not set
-# CONFIG_SPI_PL022 is not set
-# CONFIG_SPI_PPC4xx is not set
-# CONFIG_SPI_PXA2XX is not set
-# CONFIG_SPI_PXA2XX_PCI is not set
-# CONFIG_SPI_ROCKCHIP is not set
-# CONFIG_SPI_S3C64XX is not set
-# CONFIG_SPI_SC18IS602 is not set
-# CONFIG_SPI_SLAVE is not set
-# CONFIG_SPI_SPIDEV is not set
-# CONFIG_SPI_THUNDERX is not set
-# CONFIG_SPI_TI_QSPI is not set
-# CONFIG_SPI_TLE62X0 is not set
-# CONFIG_SPI_TOPCLIFF_PCH is not set
-# CONFIG_SPI_XCOMM is not set
-# CONFIG_SPI_XILINX is not set
-# CONFIG_SPI_XWAY is not set
-# CONFIG_SPI_ZYNQMP_GQSPI is not set
-CONFIG_SPLIT_PTLOCK_CPUS=4
-# CONFIG_SPMI is not set
-CONFIG_SQUASHFS=y
-# CONFIG_SQUASHFS_4K_DEVBLK_SIZE is not set
-# CONFIG_SQUASHFS_DECOMP_MULTI is not set
-CONFIG_SQUASHFS_DECOMP_MULTI_PERCPU=y
-# CONFIG_SQUASHFS_DECOMP_SINGLE is not set
-CONFIG_SQUASHFS_EMBEDDED=y
-# CONFIG_SQUASHFS_FILE_CACHE is not set
-CONFIG_SQUASHFS_FILE_DIRECT=y
-CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
-# CONFIG_SQUASHFS_LZ4 is not set
-# CONFIG_SQUASHFS_LZO is not set
-# CONFIG_SQUASHFS_XATTR is not set
-CONFIG_SQUASHFS_XZ=y
-# CONFIG_SQUASHFS_ZLIB is not set
-# CONFIG_SQUASHFS_ZSTD is not set
-# CONFIG_SRAM is not set
-# CONFIG_SRF04 is not set
-# CONFIG_SRF08 is not set
-# CONFIG_SSB is not set
-# CONFIG_SSB_DEBUG is not set
-# CONFIG_SSB_DRIVER_GPIO is not set
-# CONFIG_SSB_HOST_SOC is not set
-# CONFIG_SSB_PCMCIAHOST is not set
-CONFIG_SSB_POSSIBLE=y
-# CONFIG_SSB_SDIOHOST is not set
-# CONFIG_SSB_SILENT is not set
-# CONFIG_SSFDC is not set
-# CONFIG_STACKPROTECTOR is not set
-# CONFIG_STACKPROTECTOR_STRONG is not set
-# CONFIG_STACKTRACE is not set
-CONFIG_STACKTRACE_SUPPORT=y
-# CONFIG_STACK_TRACER is not set
-# CONFIG_STACK_VALIDATION is not set
-CONFIG_STAGING=y
-# CONFIG_STAGING_BOARD is not set
-# CONFIG_STAGING_GASKET_FRAMEWORK is not set
-# CONFIG_STAGING_MEDIA is not set
-CONFIG_STANDALONE=y
-# CONFIG_STATIC_KEYS_SELFTEST is not set
-# CONFIG_STATIC_USERMODEHELPER is not set
-CONFIG_STDBINUTILS=y
-# CONFIG_STE10XP is not set
-# CONFIG_STE_MODEM_RPROC is not set
-# CONFIG_STK3310 is not set
-# CONFIG_STK8312 is not set
-# CONFIG_STK8BA50 is not set
-# CONFIG_STM is not set
-# CONFIG_STMMAC_ETH is not set
-# CONFIG_STMMAC_PCI is not set
-# CONFIG_STMMAC_PLATFORM is not set
-# CONFIG_STM_DUMMY is not set
-# CONFIG_STM_SOURCE_CONSOLE is not set
-CONFIG_STP=y
-# CONFIG_STREAM_PARSER is not set
-# CONFIG_STRICT_DEVMEM is not set
-CONFIG_STRICT_KERNEL_RWX=y
-CONFIG_STRICT_MODULE_RWX=y
-# CONFIG_STRING_SELFTEST is not set
-CONFIG_STRIP_ASM_SYMS=y
-# CONFIG_STX104 is not set
-# CONFIG_ST_UVIS25 is not set
-# CONFIG_SUN4I_GPADC is not set
-# CONFIG_SUN50I_DE2_BUS is not set
-# CONFIG_SUN50I_ERRATUM_UNKNOWN1 is not set
-# CONFIG_SUNDANCE is not set
-# CONFIG_SUNGEM is not set
-# CONFIG_SUNRPC is not set
-# CONFIG_SUNRPC_DEBUG is not set
-# CONFIG_SUNRPC_GSS is not set
-# CONFIG_SUNXI_SRAM is not set
-# CONFIG_SUN_PARTITION is not set
-# CONFIG_SURFACE_3_BUTTON is not set
-# CONFIG_SUSPEND is not set
-# CONFIG_SUSPEND_SKIP_SYNC is not set
-CONFIG_SWAP=y
-# CONFIG_SWCONFIG is not set
-# CONFIG_SWCONFIG_B53 is not set
-# CONFIG_SWCONFIG_B53_SPI_DRIVER is not set
-# CONFIG_SWCONFIG_LEDS is not set
-# CONFIG_SW_SYNC is not set
-# CONFIG_SX9500 is not set
-# CONFIG_SXGBE_ETH is not set
-# CONFIG_SYNCLINK_CS is not set
-# CONFIG_SYNC_FILE is not set
-# CONFIG_SYNOPSYS_DWC_ETH_QOS is not set
-CONFIG_SYN_COOKIES=y
-# CONFIG_SYSCON_REBOOT_MODE is not set
-CONFIG_SYSCTL=y
-# CONFIG_SYSCTL_SYSCALL is not set
-CONFIG_SYSFS=y
-# CONFIG_SYSFS_DEPRECATED is not set
-# CONFIG_SYSFS_DEPRECATED_V2 is not set
-# CONFIG_SYSFS_SYSCALL is not set
-# CONFIG_SYSTEMPORT is not set
-# CONFIG_SYSTEM_BLACKLIST_KEYRING is not set
-# CONFIG_SYSTEM_DATA_VERIFICATION is not set
-# CONFIG_SYSTEM_TRUSTED_KEYRING is not set
-CONFIG_SYSTEM_TRUSTED_KEYS=""
-# CONFIG_SYSV68_PARTITION is not set
-CONFIG_SYSVIPC=y
-CONFIG_SYSVIPC_SYSCTL=y
-# CONFIG_SYSV_FS is not set
-# CONFIG_SYS_HYPERVISOR is not set
-# CONFIG_T5403 is not set
-# CONFIG_TARGET_CORE is not set
-# CONFIG_TASKSTATS is not set
-# CONFIG_TASKS_RCU is not set
-# CONFIG_TASK_XACCT is not set
-# CONFIG_TC35815 is not set
-# CONFIG_TCG_ATMEL is not set
-# CONFIG_TCG_CRB is not set
-# CONFIG_TCG_INFINEON is not set
-# CONFIG_TCG_NSC is not set
-# CONFIG_TCG_ST33_I2C is not set
-# CONFIG_TCG_TIS is not set
-# CONFIG_TCG_TIS_I2C_ATMEL is not set
-# CONFIG_TCG_TIS_I2C_INFINEON is not set
-# CONFIG_TCG_TIS_I2C_NUVOTON is not set
-# CONFIG_TCG_TIS_SPI is not set
-# CONFIG_TCG_TIS_ST33ZP24_I2C is not set
-# CONFIG_TCG_TIS_ST33ZP24_SPI is not set
-# CONFIG_TCG_TPM is not set
-# CONFIG_TCG_VTPM_PROXY is not set
-# CONFIG_TCG_XEN is not set
-# CONFIG_TCIC is not set
-CONFIG_TCP_CONG_ADVANCED=y
-# CONFIG_TCP_CONG_BBR is not set
-# CONFIG_TCP_CONG_BIC is not set
-# CONFIG_TCP_CONG_CDG is not set
-CONFIG_TCP_CONG_CUBIC=y
-# CONFIG_TCP_CONG_DCTCP is not set
-# CONFIG_TCP_CONG_HSTCP is not set
-# CONFIG_TCP_CONG_HTCP is not set
-# CONFIG_TCP_CONG_HYBLA is not set
-# CONFIG_TCP_CONG_ILLINOIS is not set
-# CONFIG_TCP_CONG_LP is not set
-# CONFIG_TCP_CONG_NV is not set
-# CONFIG_TCP_CONG_SCALABLE is not set
-# CONFIG_TCP_CONG_VEGAS is not set
-# CONFIG_TCP_CONG_VENO is not set
-# CONFIG_TCP_CONG_WESTWOOD is not set
-# CONFIG_TCP_CONG_YEAH is not set
-# CONFIG_TCP_MD5SIG is not set
-# CONFIG_TCS3414 is not set
-# CONFIG_TCS3472 is not set
-# CONFIG_TEE is not set
-# CONFIG_TEGRA_AHB is not set
-# CONFIG_TEGRA_HOST1X is not set
-# CONFIG_TEHUTI is not set
-# CONFIG_TERANETICS_PHY is not set
-# CONFIG_TEST_ASYNC_DRIVER_PROBE is not set
-# CONFIG_TEST_BITFIELD is not set
-# CONFIG_TEST_BITMAP is not set
-# CONFIG_TEST_BPF is not set
-# CONFIG_TEST_FIRMWARE is not set
-# CONFIG_TEST_HASH is not set
-# CONFIG_TEST_HEXDUMP is not set
-# CONFIG_TEST_IDA is not set
-# CONFIG_TEST_KMOD is not set
-# CONFIG_TEST_KSTRTOX is not set
-# CONFIG_TEST_LIST_SORT is not set
-# CONFIG_TEST_LKM is not set
-# CONFIG_TEST_OVERFLOW is not set
-# CONFIG_TEST_POWER is not set
-# CONFIG_TEST_PRINTF is not set
-# CONFIG_TEST_RHASHTABLE is not set
-# CONFIG_TEST_SORT is not set
-# CONFIG_TEST_STATIC_KEYS is not set
-# CONFIG_TEST_STRING_HELPERS is not set
-# CONFIG_TEST_SYSCTL is not set
-# CONFIG_TEST_UDELAY is not set
-# CONFIG_TEST_USER_COPY is not set
-# CONFIG_TEST_UUID is not set
-CONFIG_TEXTSEARCH=y
-# CONFIG_TEXTSEARCH_BM is not set
-# CONFIG_TEXTSEARCH_FSM is not set
-# CONFIG_TEXTSEARCH_KMP is not set
-# CONFIG_THERMAL is not set
-# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
-# CONFIG_THERMAL_DEFAULT_GOV_POWER_ALLOCATOR is not set
-# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
-# CONFIG_THERMAL_EMULATION is not set
-# CONFIG_THERMAL_GOV_BANG_BANG is not set
-# CONFIG_THERMAL_GOV_FAIR_SHARE is not set
-# CONFIG_THERMAL_GOV_POWER_ALLOCATOR is not set
-# CONFIG_THERMAL_GOV_USER_SPACE is not set
-# CONFIG_THERMAL_HWMON is not set
-# CONFIG_THERMAL_STATISTICS is not set
-# CONFIG_THERMAL_WRITABLE_TRIPS is not set
-# CONFIG_THINKPAD_ACPI is not set
-CONFIG_THIN_ARCHIVES=y
-# CONFIG_THRUSTMASTER_FF is not set
-# CONFIG_THUNDERBOLT is not set
-# CONFIG_THUNDER_NIC_BGX is not set
-# CONFIG_THUNDER_NIC_PF is not set
-# CONFIG_THUNDER_NIC_RGX is not set
-# CONFIG_THUNDER_NIC_VF is not set
-# CONFIG_TICK_CPU_ACCOUNTING is not set
-CONFIG_TICK_ONESHOT=y
-# CONFIG_TIFM_CORE is not set
-# CONFIG_TIGON3 is not set
-# CONFIG_TIMB_DMA is not set
-CONFIG_TIMERFD=y
-# CONFIG_TIMER_STATS is not set
-CONFIG_TINY_RCU=y
-# CONFIG_TIPC is not set
-# CONFIG_TI_ADC081C is not set
-# CONFIG_TI_ADC0832 is not set
-# CONFIG_TI_ADC084S021 is not set
-# CONFIG_TI_ADC108S102 is not set
-# CONFIG_TI_ADC12138 is not set
-# CONFIG_TI_ADC128S052 is not set
-# CONFIG_TI_ADC161S626 is not set
-# CONFIG_TI_ADS1015 is not set
-# CONFIG_TI_ADS7950 is not set
-# CONFIG_TI_ADS8688 is not set
-# CONFIG_TI_AM335X_ADC is not set
-# CONFIG_TI_CPSW is not set
-# CONFIG_TI_CPSW_ALE is not set
-# CONFIG_TI_CPTS is not set
-# CONFIG_TI_DAC082S085 is not set
-# CONFIG_TI_DAC5571 is not set
-# CONFIG_TI_DAC7512 is not set
-# CONFIG_TI_DAVINCI_CPDMA is not set
-# CONFIG_TI_DAVINCI_MDIO is not set
-# CONFIG_TI_ST is not set
-# CONFIG_TI_SYSCON_RESET is not set
-# CONFIG_TI_TLC4541 is not set
-# CONFIG_TLAN is not set
-# CONFIG_TLS is not set
-# CONFIG_TMD_HERMES is not set
-# CONFIG_TMP006 is not set
-# CONFIG_TMP007 is not set
-CONFIG_TMPFS=y
-# CONFIG_TMPFS_POSIX_ACL is not set
-CONFIG_TMPFS_XATTR=y
-# CONFIG_TOPSTAR_LAPTOP is not set
-# CONFIG_TORTURE_TEST is not set
-# CONFIG_TOSHIBA_HAPS is not set
-# CONFIG_TOUCHSCREEN_88PM860X is not set
-# CONFIG_TOUCHSCREEN_AD7877 is not set
-# CONFIG_TOUCHSCREEN_AD7879 is not set
-# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
-# CONFIG_TOUCHSCREEN_AD7879_SPI is not set
-# CONFIG_TOUCHSCREEN_ADC is not set
-# CONFIG_TOUCHSCREEN_ADS7846 is not set
-# CONFIG_TOUCHSCREEN_AR1021_I2C is not set
-# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
-# CONFIG_TOUCHSCREEN_ATMEL_MXT_T37 is not set
-# CONFIG_TOUCHSCREEN_AUO_PIXCIR is not set
-# CONFIG_TOUCHSCREEN_BU21013 is not set
-# CONFIG_TOUCHSCREEN_BU21029 is not set
-# CONFIG_TOUCHSCREEN_CHIPONE_ICN8318 is not set
-# CONFIG_TOUCHSCREEN_CHIPONE_ICN8505 is not set
-# CONFIG_TOUCHSCREEN_COLIBRI_VF50 is not set
-# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
-# CONFIG_TOUCHSCREEN_CYTTSP4_CORE is not set
-# CONFIG_TOUCHSCREEN_CYTTSP4_I2C is not set
-# CONFIG_TOUCHSCREEN_CYTTSP4_SPI is not set
-# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
-# CONFIG_TOUCHSCREEN_CYTTSP_I2C is not set
-# CONFIG_TOUCHSCREEN_CYTTSP_SPI is not set
-# CONFIG_TOUCHSCREEN_DA9034 is not set
-# CONFIG_TOUCHSCREEN_DA9052 is not set
-# CONFIG_TOUCHSCREEN_DYNAPRO is not set
-# CONFIG_TOUCHSCREEN_EDT_FT5X06 is not set
-# CONFIG_TOUCHSCREEN_EETI is not set
-# CONFIG_TOUCHSCREEN_EGALAX is not set
-# CONFIG_TOUCHSCREEN_EGALAX_SERIAL is not set
-# CONFIG_TOUCHSCREEN_EKTF2127 is not set
-# CONFIG_TOUCHSCREEN_ELAN is not set
-# CONFIG_TOUCHSCREEN_ELO is not set
-# CONFIG_TOUCHSCREEN_EXC3000 is not set
-# CONFIG_TOUCHSCREEN_FUJITSU is not set
-# CONFIG_TOUCHSCREEN_GOODIX is not set
-# CONFIG_TOUCHSCREEN_GUNZE is not set
-# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
-# CONFIG_TOUCHSCREEN_HIDEEP is not set
-# CONFIG_TOUCHSCREEN_HP600 is not set
-# CONFIG_TOUCHSCREEN_HP7XX is not set
-# CONFIG_TOUCHSCREEN_HTCPEN is not set
-# CONFIG_TOUCHSCREEN_ILI210X is not set
-# CONFIG_TOUCHSCREEN_IMX6UL_TSC is not set
-# CONFIG_TOUCHSCREEN_INEXIO is not set
-# CONFIG_TOUCHSCREEN_IPAQ_MICRO is not set
-# CONFIG_TOUCHSCREEN_IPROC is not set
-# CONFIG_TOUCHSCREEN_LPC32XX is not set
-# CONFIG_TOUCHSCREEN_MAX11801 is not set
-# CONFIG_TOUCHSCREEN_MC13783 is not set
-# CONFIG_TOUCHSCREEN_MCS5000 is not set
-# CONFIG_TOUCHSCREEN_MELFAS_MIP4 is not set
-# CONFIG_TOUCHSCREEN_MIGOR is not set
-# CONFIG_TOUCHSCREEN_MK712 is not set
-# CONFIG_TOUCHSCREEN_MMS114 is not set
-# CONFIG_TOUCHSCREEN_MTOUCH is not set
-# CONFIG_TOUCHSCREEN_MX25 is not set
-# CONFIG_TOUCHSCREEN_MXS_LRADC is not set
-# CONFIG_TOUCHSCREEN_PCAP is not set
-# CONFIG_TOUCHSCREEN_PENMOUNT is not set
-# CONFIG_TOUCHSCREEN_PIXCIR is not set
-# CONFIG_TOUCHSCREEN_PROPERTIES is not set
-# CONFIG_TOUCHSCREEN_RM_TS is not set
-# CONFIG_TOUCHSCREEN_ROHM_BU21023 is not set
-# CONFIG_TOUCHSCREEN_RPI_FT5406 is not set
-# CONFIG_TOUCHSCREEN_S3C2410 is not set
-# CONFIG_TOUCHSCREEN_S6SY761 is not set
-# CONFIG_TOUCHSCREEN_SILEAD is not set
-# CONFIG_TOUCHSCREEN_SIS_I2C is not set
-# CONFIG_TOUCHSCREEN_ST1232 is not set
-# CONFIG_TOUCHSCREEN_STMFTS is not set
-# CONFIG_TOUCHSCREEN_STMPE is not set
-# CONFIG_TOUCHSCREEN_SUN4I is not set
-# CONFIG_TOUCHSCREEN_SUR40 is not set
-# CONFIG_TOUCHSCREEN_SURFACE3_SPI is not set
-# CONFIG_TOUCHSCREEN_SX8654 is not set
-# CONFIG_TOUCHSCREEN_TI_AM335X_TSC is not set
-# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
-# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
-# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
-# CONFIG_TOUCHSCREEN_TPS6507X is not set
-# CONFIG_TOUCHSCREEN_TS4800 is not set
-# CONFIG_TOUCHSCREEN_TSC2004 is not set
-# CONFIG_TOUCHSCREEN_TSC2005 is not set
-# CONFIG_TOUCHSCREEN_TSC2007 is not set
-# CONFIG_TOUCHSCREEN_TSC2007_IIO is not set
-# CONFIG_TOUCHSCREEN_TSC200X_CORE is not set
-# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
-# CONFIG_TOUCHSCREEN_UCB1400 is not set
-# CONFIG_TOUCHSCREEN_USB_3M is not set
-# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
-# CONFIG_TOUCHSCREEN_USB_DMC_TSC10 is not set
-# CONFIG_TOUCHSCREEN_USB_E2I is not set
-# CONFIG_TOUCHSCREEN_USB_EASYTOUCH is not set
-# CONFIG_TOUCHSCREEN_USB_EGALAX is not set
-# CONFIG_TOUCHSCREEN_USB_ELO is not set
-# CONFIG_TOUCHSCREEN_USB_ETT_TC45USB is not set
-# CONFIG_TOUCHSCREEN_USB_ETURBO is not set
-# CONFIG_TOUCHSCREEN_USB_GENERAL_TOUCH is not set
-# CONFIG_TOUCHSCREEN_USB_GOTOP is not set
-# CONFIG_TOUCHSCREEN_USB_GUNZE is not set
-# CONFIG_TOUCHSCREEN_USB_IDEALTEK is not set
-# CONFIG_TOUCHSCREEN_USB_IRTOUCH is not set
-# CONFIG_TOUCHSCREEN_USB_ITM is not set
-# CONFIG_TOUCHSCREEN_USB_JASTEC is not set
-# CONFIG_TOUCHSCREEN_USB_NEXIO is not set
-# CONFIG_TOUCHSCREEN_USB_PANJIT is not set
-# CONFIG_TOUCHSCREEN_USB_ZYTRONIC is not set
-# CONFIG_TOUCHSCREEN_W90X900 is not set
-# CONFIG_TOUCHSCREEN_WACOM_I2C is not set
-# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
-# CONFIG_TOUCHSCREEN_WDT87XX_I2C is not set
-# CONFIG_TOUCHSCREEN_WM831X is not set
-# CONFIG_TOUCHSCREEN_WM9705 is not set
-# CONFIG_TOUCHSCREEN_WM9712 is not set
-# CONFIG_TOUCHSCREEN_WM9713 is not set
-# CONFIG_TOUCHSCREEN_WM97XX is not set
-# CONFIG_TOUCHSCREEN_WM97XX_MAINSTONE is not set
-# CONFIG_TOUCHSCREEN_WM97XX_ZYLONITE is not set
-# CONFIG_TOUCHSCREEN_ZET6223 is not set
-# CONFIG_TOUCHSCREEN_ZFORCE is not set
-# CONFIG_TPL0102 is not set
-# CONFIG_TPS6105X is not set
-# CONFIG_TPS65010 is not set
-# CONFIG_TPS6507X is not set
-# CONFIG_TRACEPOINT_BENCHMARK is not set
-# CONFIG_TRACER_SNAPSHOT is not set
-# CONFIG_TRACER_SNAPSHOT_PER_CPU_SWAP is not set
-# CONFIG_TRACE_BRANCH_PROFILING is not set
-# CONFIG_TRACE_EVAL_MAP_FILE is not set
-CONFIG_TRACE_IRQFLAGS_SUPPORT=y
-# CONFIG_TRACE_SINK is not set
-# CONFIG_TRACING_EVENTS_GPIO is not set
-CONFIG_TRACING_SUPPORT=y
-CONFIG_TRAD_SIGNALS=y
-# CONFIG_TRANSPARENT_HUGEPAGE is not set
-# CONFIG_TREE_RCU is not set
-# CONFIG_TREE_RCU_TRACE is not set
-# CONFIG_TRIM_UNUSED_KSYMS is not set
-# CONFIG_TRUSTED_KEYS is not set
-# CONFIG_TSL2583 is not set
-# CONFIG_TSL2772 is not set
-# CONFIG_TSL2x7x is not set
-# CONFIG_TSL4531 is not set
-# CONFIG_TSYS01 is not set
-# CONFIG_TSYS02D is not set
-# CONFIG_TTPCI_EEPROM is not set
-CONFIG_TTY=y
-# CONFIG_TTY_PRINTK is not set
-# CONFIG_TUN is not set
-# CONFIG_TUN_VNET_CROSS_LE is not set
-# CONFIG_TWL4030_CORE is not set
-# CONFIG_TWL4030_MADC is not set
-# CONFIG_TWL6030_GPADC is not set
-# CONFIG_TWL6040_CORE is not set
-# CONFIG_TYPEC is not set
-# CONFIG_TYPEC_TCPM is not set
-# CONFIG_TYPEC_UCSI is not set
-# CONFIG_TYPHOON is not set
-# CONFIG_UACCESS_WITH_MEMCPY is not set
-# CONFIG_UBIFS_ATIME_SUPPORT is not set
-# CONFIG_UBIFS_FS_ENCRYPTION is not set
-CONFIG_UBIFS_FS_FORMAT4=y
-# CONFIG_UBIFS_FS_SECURITY is not set
-# CONFIG_UBIFS_FS_XATTR is not set
-# CONFIG_UBSAN is not set
-# CONFIG_UCB1400_CORE is not set
-# CONFIG_UCSI is not set
-# CONFIG_UDF_FS is not set
-CONFIG_UEVENT_HELPER=y
-CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
-# CONFIG_UFS_FS is not set
-# CONFIG_UHID is not set
-CONFIG_UID16=y
-# CONFIG_UIO is not set
-# CONFIG_ULTRA is not set
-# CONFIG_ULTRIX_PARTITION is not set
-# CONFIG_UNISYSSPAR is not set
-# CONFIG_UNISYS_VISORBUS is not set
-CONFIG_UNIX=y
-CONFIG_UNIX98_PTYS=y
-# CONFIG_UNIXWARE_DISKLABEL is not set
-# CONFIG_UNIX_DIAG is not set
-# CONFIG_UNUSED_SYMBOLS is not set
-# CONFIG_UPROBES is not set
-# CONFIG_UPROBE_EVENTS is not set
-# CONFIG_US5182D is not set
-# CONFIG_USB is not set
-# CONFIG_USBIP_CORE is not set
-CONFIG_USBIP_VHCI_HC_PORTS=8
-CONFIG_USBIP_VHCI_NR_HCS=1
-# CONFIG_USBIP_VUDC is not set
-# CONFIG_USBPCWATCHDOG is not set
-# CONFIG_USB_ACM is not set
-# CONFIG_USB_ADUTUX is not set
-CONFIG_USB_ALI_M5632=y
-# CONFIG_USB_AMD5536UDC is not set
-CONFIG_USB_AN2720=y
-# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
-# CONFIG_USB_APPLEDISPLAY is not set
-CONFIG_USB_ARCH_HAS_HCD=y
-CONFIG_USB_ARMLINUX=y
-# CONFIG_USB_ATM is not set
-# CONFIG_USB_BDC_UDC is not set
-CONFIG_USB_BELKIN=y
-# CONFIG_USB_C67X00_HCD is not set
-# CONFIG_USB_CATC is not set
-# CONFIG_USB_CDC_COMPOSITE is not set
-# CONFIG_USB_CHAOSKEY is not set
-# CONFIG_USB_CHIPIDEA is not set
-# CONFIG_USB_CONFIGFS is not set
-# CONFIG_USB_CXACRU is not set
-# CONFIG_USB_CYPRESS_CY7C63 is not set
-# CONFIG_USB_CYTHERM is not set
-CONFIG_USB_DEFAULT_PERSIST=y
-# CONFIG_USB_DSBR is not set
-# CONFIG_USB_DUMMY_HCD is not set
-# CONFIG_USB_DWC2 is not set
-# CONFIG_USB_DWC2_DEBUG is not set
-# CONFIG_USB_DWC2_DUAL_ROLE is not set
-# CONFIG_USB_DWC2_HOST is not set
-# CONFIG_USB_DWC2_PERIPHERAL is not set
-# CONFIG_USB_DWC3 is not set
-# CONFIG_USB_DWC3_EXYNOS is not set
-# CONFIG_USB_DWC3_HAPS is not set
-# CONFIG_USB_DWC3_KEYSTONE is not set
-# CONFIG_USB_DWC3_OF_SIMPLE is not set
-# CONFIG_USB_DWC3_PCI is not set
-# CONFIG_USB_DWC3_QCOM is not set
-# CONFIG_USB_DWC3_ULPI is not set
-# CONFIG_USB_DYNAMIC_MINORS is not set
-# CONFIG_USB_EG20T is not set
-# CONFIG_USB_EHCI_ATH79 is not set
-# CONFIG_USB_EHCI_HCD_AT91 is not set
-# CONFIG_USB_EHCI_HCD_OMAP is not set
-# CONFIG_USB_EHCI_HCD_PPC_OF is not set
-# CONFIG_USB_EHCI_MSM is not set
-# CONFIG_USB_EHCI_MV is not set
-CONFIG_USB_EHCI_ROOT_HUB_TT=y
-CONFIG_USB_EHCI_TT_NEWSCHED=y
-# CONFIG_USB_EHSET_TEST_FIXTURE is not set
-# CONFIG_USB_EMI26 is not set
-# CONFIG_USB_EMI62 is not set
-# CONFIG_USB_EPSON2888 is not set
-# CONFIG_USB_EZUSB_FX2 is not set
-# CONFIG_USB_FOTG210_HCD is not set
-# CONFIG_USB_FOTG210_UDC is not set
-# CONFIG_USB_FSL_USB2 is not set
-# CONFIG_USB_FTDI_ELAN is not set
-# CONFIG_USB_FUNCTIONFS is not set
-# CONFIG_USB_FUSB300 is not set
-# CONFIG_USB_GADGET is not set
-# CONFIG_USB_GADGETFS is not set
-# CONFIG_USB_GADGET_DEBUG is not set
-# CONFIG_USB_GADGET_DEBUG_FILES is not set
-# CONFIG_USB_GADGET_DEBUG_FS is not set
-CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
-CONFIG_USB_GADGET_VBUS_DRAW=2
-# CONFIG_USB_GADGET_XILINX is not set
-# CONFIG_USB_GL860 is not set
-# CONFIG_USB_GOKU is not set
-# CONFIG_USB_GPIO_VBUS is not set
-# CONFIG_USB_GR_UDC is not set
-# CONFIG_USB_GSPCA is not set
-# CONFIG_USB_GSPCA_BENQ is not set
-# CONFIG_USB_GSPCA_CONEX is not set
-# CONFIG_USB_GSPCA_CPIA1 is not set
-# CONFIG_USB_GSPCA_DTCS033 is not set
-# CONFIG_USB_GSPCA_ETOMS is not set
-# CONFIG_USB_GSPCA_FINEPIX is not set
-# CONFIG_USB_GSPCA_JEILINJ is not set
-# CONFIG_USB_GSPCA_JL2005BCD is not set
-# CONFIG_USB_GSPCA_KINECT is not set
-# CONFIG_USB_GSPCA_KONICA is not set
-# CONFIG_USB_GSPCA_MARS is not set
-# CONFIG_USB_GSPCA_MR97310A is not set
-# CONFIG_USB_GSPCA_NW80X is not set
-# CONFIG_USB_GSPCA_OV519 is not set
-# CONFIG_USB_GSPCA_OV534 is not set
-# CONFIG_USB_GSPCA_OV534_9 is not set
-# CONFIG_USB_GSPCA_PAC207 is not set
-# CONFIG_USB_GSPCA_PAC7302 is not set
-# CONFIG_USB_GSPCA_PAC7311 is not set
-# CONFIG_USB_GSPCA_SE401 is not set
-# CONFIG_USB_GSPCA_SN9C2028 is not set
-# CONFIG_USB_GSPCA_SN9C20X is not set
-# CONFIG_USB_GSPCA_SONIXB is not set
-# CONFIG_USB_GSPCA_SONIXJ is not set
-# CONFIG_USB_GSPCA_SPCA1528 is not set
-# CONFIG_USB_GSPCA_SPCA500 is not set
-# CONFIG_USB_GSPCA_SPCA501 is not set
-# CONFIG_USB_GSPCA_SPCA505 is not set
-# CONFIG_USB_GSPCA_SPCA506 is not set
-# CONFIG_USB_GSPCA_SPCA508 is not set
-# CONFIG_USB_GSPCA_SPCA561 is not set
-# CONFIG_USB_GSPCA_SQ905 is not set
-# CONFIG_USB_GSPCA_SQ905C is not set
-# CONFIG_USB_GSPCA_SQ930X is not set
-# CONFIG_USB_GSPCA_STK014 is not set
-# CONFIG_USB_GSPCA_STK1135 is not set
-# CONFIG_USB_GSPCA_STV0680 is not set
-# CONFIG_USB_GSPCA_SUNPLUS is not set
-# CONFIG_USB_GSPCA_T613 is not set
-# CONFIG_USB_GSPCA_TOPRO is not set
-# CONFIG_USB_GSPCA_TOUPTEK is not set
-# CONFIG_USB_GSPCA_TV8532 is not set
-# CONFIG_USB_GSPCA_VC032X is not set
-# CONFIG_USB_GSPCA_VICAM is not set
-# CONFIG_USB_GSPCA_XIRLINK_CIT is not set
-# CONFIG_USB_GSPCA_ZC3XX is not set
-# CONFIG_USB_G_ACM_MS is not set
-# CONFIG_USB_G_DBGP is not set
-# CONFIG_USB_G_HID is not set
-# CONFIG_USB_G_MULTI is not set
-# CONFIG_USB_G_NCM is not set
-# CONFIG_USB_G_NOKIA is not set
-# CONFIG_USB_G_PRINTER is not set
-# CONFIG_USB_G_SERIAL is not set
-# CONFIG_USB_G_WEBCAM is not set
-# CONFIG_USB_HCD_TEST_MODE is not set
-# CONFIG_USB_HID is not set
-# CONFIG_USB_HIDDEV is not set
-# CONFIG_USB_HSIC_USB3503 is not set
-# CONFIG_USB_HSIC_USB4604 is not set
-# CONFIG_USB_HSO is not set
-# CONFIG_USB_HUB_USB251XB is not set
-# CONFIG_USB_HWA_HCD is not set
-# CONFIG_USB_IDMOUSE is not set
-# CONFIG_USB_IMX21_HCD is not set
-# CONFIG_USB_IOWARRIOR is not set
-# CONFIG_USB_IPHETH is not set
-# CONFIG_USB_ISIGHTFW is not set
-# CONFIG_USB_ISP116X_HCD is not set
-# CONFIG_USB_ISP1301 is not set
-# CONFIG_USB_ISP1362_HCD is not set
-# CONFIG_USB_ISP1760 is not set
-# CONFIG_USB_ISP1760_HCD is not set
-# CONFIG_USB_KAWETH is not set
-# CONFIG_USB_KBD is not set
-# CONFIG_USB_KC2190 is not set
-# CONFIG_USB_LAN78XX is not set
-# CONFIG_USB_LCD is not set
-# CONFIG_USB_LD is not set
-# CONFIG_USB_LED is not set
-# CONFIG_USB_LEDS_TRIGGER_USBPORT is not set
-# CONFIG_USB_LED_TRIG is not set
-# CONFIG_USB_LEGOTOWER is not set
-# CONFIG_USB_LINK_LAYER_TEST is not set
-# CONFIG_USB_M5602 is not set
-# CONFIG_USB_M66592 is not set
-# CONFIG_USB_MASS_STORAGE is not set
-# CONFIG_USB_MAX3421_HCD is not set
-# CONFIG_USB_MDC800 is not set
-# CONFIG_USB_MICROTEK is not set
-# CONFIG_USB_MIDI_GADGET is not set
-# CONFIG_USB_MON is not set
-# CONFIG_USB_MOUSE is not set
-# CONFIG_USB_MSM_OTG is not set
-# CONFIG_USB_MTU3 is not set
-# CONFIG_USB_MUSB_HDRC is not set
-# CONFIG_USB_MV_U3D is not set
-# CONFIG_USB_MV_UDC is not set
-# CONFIG_USB_MXS_PHY is not set
-# CONFIG_USB_NET2272 is not set
-# CONFIG_USB_NET2280 is not set
-# CONFIG_USB_NET_AX88179_178A is not set
-# CONFIG_USB_NET_AX8817X is not set
-# CONFIG_USB_NET_CDCETHER is not set
-# CONFIG_USB_NET_CDC_EEM is not set
-# CONFIG_USB_NET_CDC_MBIM is not set
-# CONFIG_USB_NET_CDC_NCM is not set
-# CONFIG_USB_NET_CDC_SUBSET is not set
-# CONFIG_USB_NET_CH9200 is not set
-# CONFIG_USB_NET_CX82310_ETH is not set
-# CONFIG_USB_NET_DM9601 is not set
-# CONFIG_USB_NET_DRIVERS is not set
-# CONFIG_USB_NET_GL620A is not set
-# CONFIG_USB_NET_HUAWEI_CDC_NCM is not set
-# CONFIG_USB_NET_INT51X1 is not set
-# CONFIG_USB_NET_KALMIA is not set
-# CONFIG_USB_NET_MCS7830 is not set
-# CONFIG_USB_NET_NET1080 is not set
-# CONFIG_USB_NET_PLUSB is not set
-# CONFIG_USB_NET_QMI_WWAN is not set
-# CONFIG_USB_NET_RNDIS_HOST is not set
-# CONFIG_USB_NET_RNDIS_WLAN is not set
-# CONFIG_USB_NET_SMSC75XX is not set
-# CONFIG_USB_NET_SMSC95XX is not set
-# CONFIG_USB_NET_SR9700 is not set
-# CONFIG_USB_NET_SR9800 is not set
-# CONFIG_USB_NET_ZAURUS is not set
-# CONFIG_USB_OHCI_HCD is not set
-# CONFIG_USB_OHCI_HCD_PCI is not set
-# CONFIG_USB_OHCI_HCD_PPC_OF is not set
-# CONFIG_USB_OHCI_HCD_PPC_OF_BE is not set
-# CONFIG_USB_OHCI_HCD_PPC_OF_LE is not set
-# CONFIG_USB_OHCI_HCD_SSB is not set
-CONFIG_USB_OHCI_LITTLE_ENDIAN=y
-# CONFIG_USB_OTG is not set
-# CONFIG_USB_OTG_BLACKLIST_HUB is not set
-# CONFIG_USB_OTG_FSM is not set
-# CONFIG_USB_OTG_WHITELIST is not set
-# CONFIG_USB_OXU210HP_HCD is not set
-# CONFIG_USB_PCI is not set
-# CONFIG_USB_PEGASUS is not set
-# CONFIG_USB_PHY is not set
-# CONFIG_USB_PRINTER is not set
-# CONFIG_USB_PWC_INPUT_EVDEV is not set
-# CONFIG_USB_PXA27X is not set
-# CONFIG_USB_R8A66597 is not set
-# CONFIG_USB_R8A66597_HCD is not set
-# CONFIG_USB_RCAR_PHY is not set
-# CONFIG_USB_RENESAS_USBHS is not set
-# CONFIG_USB_RIO500 is not set
-# CONFIG_USB_ROLE_SWITCH is not set
-# CONFIG_USB_RTL8150 is not set
-# CONFIG_USB_RTL8152 is not set
-# CONFIG_USB_S2255 is not set
-# CONFIG_USB_SERIAL is not set
-# CONFIG_USB_SERIAL_AIRCABLE is not set
-# CONFIG_USB_SERIAL_ARK3116 is not set
-# CONFIG_USB_SERIAL_BELKIN is not set
-# CONFIG_USB_SERIAL_CH341 is not set
-# CONFIG_USB_SERIAL_CP210X is not set
-# CONFIG_USB_SERIAL_CYBERJACK is not set
-# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
-# CONFIG_USB_SERIAL_DEBUG is not set
-# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
-# CONFIG_USB_SERIAL_EDGEPORT is not set
-# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
-# CONFIG_USB_SERIAL_EMPEG is not set
-# CONFIG_USB_SERIAL_F81232 is not set
-# CONFIG_USB_SERIAL_F8153X is not set
-# CONFIG_USB_SERIAL_FTDI_SIO is not set
-# CONFIG_USB_SERIAL_GARMIN is not set
-CONFIG_USB_SERIAL_GENERIC=y
-# CONFIG_USB_SERIAL_IPAQ is not set
-# CONFIG_USB_SERIAL_IPW is not set
-# CONFIG_USB_SERIAL_IR is not set
-# CONFIG_USB_SERIAL_IUU is not set
-# CONFIG_USB_SERIAL_KEYSPAN is not set
-CONFIG_USB_SERIAL_KEYSPAN_MPR=y
-# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
-CONFIG_USB_SERIAL_KEYSPAN_USA18X=y
-CONFIG_USB_SERIAL_KEYSPAN_USA19=y
-CONFIG_USB_SERIAL_KEYSPAN_USA19QI=y
-CONFIG_USB_SERIAL_KEYSPAN_USA19QW=y
-CONFIG_USB_SERIAL_KEYSPAN_USA19W=y
-CONFIG_USB_SERIAL_KEYSPAN_USA28=y
-CONFIG_USB_SERIAL_KEYSPAN_USA28X=y
-CONFIG_USB_SERIAL_KEYSPAN_USA28XA=y
-CONFIG_USB_SERIAL_KEYSPAN_USA28XB=y
-CONFIG_USB_SERIAL_KEYSPAN_USA49W=y
-CONFIG_USB_SERIAL_KEYSPAN_USA49WLC=y
-# CONFIG_USB_SERIAL_KLSI is not set
-# CONFIG_USB_SERIAL_KOBIL_SCT is not set
-# CONFIG_USB_SERIAL_MCT_U232 is not set
-# CONFIG_USB_SERIAL_METRO is not set
-# CONFIG_USB_SERIAL_MOS7715_PARPORT is not set
-# CONFIG_USB_SERIAL_MOS7720 is not set
-# CONFIG_USB_SERIAL_MOS7840 is not set
-# CONFIG_USB_SERIAL_MXUPORT is not set
-# CONFIG_USB_SERIAL_NAVMAN is not set
-# CONFIG_USB_SERIAL_OMNINET is not set
-# CONFIG_USB_SERIAL_OPTICON is not set
-# CONFIG_USB_SERIAL_OPTION is not set
-# CONFIG_USB_SERIAL_OTI6858 is not set
-# CONFIG_USB_SERIAL_PL2303 is not set
-# CONFIG_USB_SERIAL_QCAUX is not set
-# CONFIG_USB_SERIAL_QT2 is not set
-# CONFIG_USB_SERIAL_QUALCOMM is not set
-# CONFIG_USB_SERIAL_SAFE is not set
-CONFIG_USB_SERIAL_SAFE_PADDED=y
-# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
-# CONFIG_USB_SERIAL_SIMPLE is not set
-# CONFIG_USB_SERIAL_SPCP8X5 is not set
-# CONFIG_USB_SERIAL_SSU100 is not set
-# CONFIG_USB_SERIAL_SYMBOL is not set
-# CONFIG_USB_SERIAL_TI is not set
-# CONFIG_USB_SERIAL_UPD78F0730 is not set
-# CONFIG_USB_SERIAL_VISOR is not set
-# CONFIG_USB_SERIAL_WHITEHEAT is not set
-# CONFIG_USB_SERIAL_WISHBONE is not set
-# CONFIG_USB_SERIAL_XIRCOM is not set
-# CONFIG_USB_SERIAL_XSENS_MT is not set
-# CONFIG_USB_SEVSEG is not set
-# CONFIG_USB_SIERRA_NET is not set
-# CONFIG_USB_SISUSBVGA is not set
-# CONFIG_USB_SL811_HCD is not set
-# CONFIG_USB_SNP_UDC_PLAT is not set
-# CONFIG_USB_SPEEDTOUCH is not set
-# CONFIG_USB_STKWEBCAM is not set
-# CONFIG_USB_STORAGE is not set
-# CONFIG_USB_STORAGE_ALAUDA is not set
-# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
-# CONFIG_USB_STORAGE_DATAFAB is not set
-# CONFIG_USB_STORAGE_DEBUG is not set
-# CONFIG_USB_STORAGE_ENE_UB6250 is not set
-# CONFIG_USB_STORAGE_FREECOM is not set
-# CONFIG_USB_STORAGE_ISD200 is not set
-# CONFIG_USB_STORAGE_JUMPSHOT is not set
-# CONFIG_USB_STORAGE_KARMA is not set
-# CONFIG_USB_STORAGE_ONETOUCH is not set
-# CONFIG_USB_STORAGE_REALTEK is not set
-# CONFIG_USB_STORAGE_SDDR09 is not set
-# CONFIG_USB_STORAGE_SDDR55 is not set
-# CONFIG_USB_STORAGE_USBAT is not set
-# CONFIG_USB_STV06XX is not set
-# CONFIG_USB_SUPPORT is not set
-# CONFIG_USB_SWITCH_FSA9480 is not set
-# CONFIG_USB_TEST is not set
-# CONFIG_USB_TMC is not set
-# CONFIG_USB_TRANCEVIBRATOR is not set
-# CONFIG_USB_UAS is not set
-# CONFIG_USB_UEAGLEATM is not set
-# CONFIG_USB_ULPI is not set
-# CONFIG_USB_ULPI_BUS is not set
-# CONFIG_USB_USBNET is not set
-# CONFIG_USB_USS720 is not set
-# CONFIG_USB_VIDEO_CLASS is not set
-CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
-# CONFIG_USB_VL600 is not set
-# CONFIG_USB_WDM is not set
-# CONFIG_USB_WHCI_HCD is not set
-# CONFIG_USB_WUSB is not set
-# CONFIG_USB_WUSB_CBAF is not set
-# CONFIG_USB_XHCI_DBGCAP is not set
-# CONFIG_USB_XHCI_HCD is not set
-# CONFIG_USB_XHCI_MVEBU is not set
-# CONFIG_USB_XUSBATM is not set
-# CONFIG_USB_YUREX is not set
-# CONFIG_USB_ZD1201 is not set
-# CONFIG_USB_ZERO is not set
-# CONFIG_USB_ZR364XX is not set
-# CONFIG_USELIB is not set
-# CONFIG_USERFAULTFD is not set
-# CONFIG_USE_OF is not set
-# CONFIG_UTS_NS is not set
-# CONFIG_UWB is not set
-# CONFIG_U_SERIAL_CONSOLE is not set
-# CONFIG_V4L_MEM2MEM_DRIVERS is not set
-# CONFIG_V4L_TEST_DRIVERS is not set
-# CONFIG_VBOXGUEST is not set
-# CONFIG_VCNL4000 is not set
-# CONFIG_VDSO is not set
-# CONFIG_VEML6070 is not set
-# CONFIG_VETH is not set
-# CONFIG_VEXPRESS_CONFIG is not set
-# CONFIG_VF610_ADC is not set
-# CONFIG_VF610_DAC is not set
-# CONFIG_VFAT_FS is not set
-# CONFIG_VGASTATE is not set
-# CONFIG_VGA_ARB is not set
-# CONFIG_VGA_SWITCHEROO is not set
-# CONFIG_VHOST_CROSS_ENDIAN_LEGACY is not set
-# CONFIG_VHOST_NET is not set
-# CONFIG_VHOST_VSOCK is not set
-# CONFIG_VIA_RHINE is not set
-# CONFIG_VIA_VELOCITY is not set
-# CONFIG_VIDEO_ADV7170 is not set
-# CONFIG_VIDEO_ADV7175 is not set
-# CONFIG_VIDEO_ADV7180 is not set
-# CONFIG_VIDEO_ADV7183 is not set
-# CONFIG_VIDEO_ADV7343 is not set
-# CONFIG_VIDEO_ADV7393 is not set
-# CONFIG_VIDEO_ADV_DEBUG is not set
-# CONFIG_VIDEO_AK881X is not set
-# CONFIG_VIDEO_BT819 is not set
-# CONFIG_VIDEO_BT848 is not set
-# CONFIG_VIDEO_BT856 is not set
-# CONFIG_VIDEO_BT866 is not set
-# CONFIG_VIDEO_CADENCE is not set
-# CONFIG_VIDEO_CAFE_CCIC is not set
-# CONFIG_VIDEO_CS3308 is not set
-# CONFIG_VIDEO_CS5345 is not set
-# CONFIG_VIDEO_CS53L32A is not set
-# CONFIG_VIDEO_CX231XX is not set
-# CONFIG_VIDEO_CX2341X is not set
-# CONFIG_VIDEO_CX25840 is not set
-# CONFIG_VIDEO_CX88 is not set
-# CONFIG_VIDEO_DEV is not set
-# CONFIG_VIDEO_DM6446_CCDC is not set
-# CONFIG_VIDEO_DT3155 is not set
-# CONFIG_VIDEO_EM28XX is not set
-# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
-# CONFIG_VIDEO_GO7007 is not set
-# CONFIG_VIDEO_HDPVR is not set
-# CONFIG_VIDEO_HEXIUM_GEMINI is not set
-# CONFIG_VIDEO_HEXIUM_ORION is not set
-# CONFIG_VIDEO_I2C is not set
-# CONFIG_VIDEO_IR_I2C is not set
-# CONFIG_VIDEO_IVTV is not set
-# CONFIG_VIDEO_KS0127 is not set
-# CONFIG_VIDEO_M52790 is not set
-# CONFIG_VIDEO_ML86V7667 is not set
-# CONFIG_VIDEO_MSP3400 is not set
-# CONFIG_VIDEO_MT9M111 is not set
-# CONFIG_VIDEO_MT9T112 is not set
-# CONFIG_VIDEO_MT9V011 is not set
-# CONFIG_VIDEO_MT9V111 is not set
-# CONFIG_VIDEO_MXB is not set
-# CONFIG_VIDEO_NOON010PC30 is not set
-# CONFIG_VIDEO_OMAP2_VOUT is not set
-# CONFIG_VIDEO_OV2640 is not set
-# CONFIG_VIDEO_OV2659 is not set
-# CONFIG_VIDEO_OV5695 is not set
-# CONFIG_VIDEO_OV6650 is not set
-# CONFIG_VIDEO_OV7640 is not set
-# CONFIG_VIDEO_OV7670 is not set
-# CONFIG_VIDEO_OV772X is not set
-# CONFIG_VIDEO_OV7740 is not set
-# CONFIG_VIDEO_PVRUSB2 is not set
-# CONFIG_VIDEO_RJ54N1 is not set
-# CONFIG_VIDEO_SAA6588 is not set
-# CONFIG_VIDEO_SAA6752HS is not set
-# CONFIG_VIDEO_SAA7110 is not set
-# CONFIG_VIDEO_SAA711X is not set
-# CONFIG_VIDEO_SAA7127 is not set
-# CONFIG_VIDEO_SAA7134 is not set
-# CONFIG_VIDEO_SAA717X is not set
-# CONFIG_VIDEO_SAA7185 is not set
-# CONFIG_VIDEO_SH_MOBILE_CEU is not set
-# CONFIG_VIDEO_SONY_BTF_MPX is not set
-# CONFIG_VIDEO_SR030PC30 is not set
-# CONFIG_VIDEO_TDA7432 is not set
-# CONFIG_VIDEO_TDA9840 is not set
-# CONFIG_VIDEO_TEA6415C is not set
-# CONFIG_VIDEO_TEA6420 is not set
-# CONFIG_VIDEO_THS7303 is not set
-# CONFIG_VIDEO_THS8200 is not set
-# CONFIG_VIDEO_TIMBERDALE is not set
-# CONFIG_VIDEO_TLV320AIC23B is not set
-# CONFIG_VIDEO_TM6000 is not set
-# CONFIG_VIDEO_TVAUDIO is not set
-# CONFIG_VIDEO_TVP514X is not set
-# CONFIG_VIDEO_TVP5150 is not set
-# CONFIG_VIDEO_TVP7002 is not set
-# CONFIG_VIDEO_TW2804 is not set
-# CONFIG_VIDEO_TW9903 is not set
-# CONFIG_VIDEO_TW9906 is not set
-# CONFIG_VIDEO_TW9910 is not set
-# CONFIG_VIDEO_UDA1342 is not set
-# CONFIG_VIDEO_UPD64031A is not set
-# CONFIG_VIDEO_UPD64083 is not set
-# CONFIG_VIDEO_USBTV is not set
-# CONFIG_VIDEO_USBVISION is not set
-# CONFIG_VIDEO_V4L2 is not set
-# CONFIG_VIDEO_VP27SMPX is not set
-# CONFIG_VIDEO_VPX3220 is not set
-# CONFIG_VIDEO_VS6624 is not set
-# CONFIG_VIDEO_WM8739 is not set
-# CONFIG_VIDEO_WM8775 is not set
-# CONFIG_VIDEO_ZORAN is not set
-# CONFIG_VIRTIO_BALLOON is not set
-# CONFIG_VIRTIO_BLK_SCSI is not set
-# CONFIG_VIRTIO_INPUT is not set
-CONFIG_VIRTIO_MENU=y
-# CONFIG_VIRTIO_MMIO is not set
-# CONFIG_VIRTIO_PCI is not set
-# CONFIG_VIRTUALIZATION is not set
-# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
-# CONFIG_VIRT_DRIVERS is not set
-CONFIG_VIRT_TO_BUS=y
-# CONFIG_VITESSE_PHY is not set
-# CONFIG_VL6180 is not set
-CONFIG_VLAN_8021Q=y
-# CONFIG_VLAN_8021Q_GVRP is not set
-# CONFIG_VLAN_8021Q_MVRP is not set
-# CONFIG_VME_BUS is not set
-# CONFIG_VMSPLIT_1G is not set
-# CONFIG_VMSPLIT_2G is not set
-# CONFIG_VMSPLIT_2G_OPT is not set
-CONFIG_VMSPLIT_3G=y
-# CONFIG_VMSPLIT_3G_OPT is not set
-# CONFIG_VMWARE_PVSCSI is not set
-# CONFIG_VMXNET3 is not set
-# CONFIG_VM_EVENT_COUNTERS is not set
-# CONFIG_VOP_BUS is not set
-# CONFIG_VORTEX is not set
-# CONFIG_VSOCKETS is not set
-# CONFIG_VSOCKETS_DIAG is not set
-# CONFIG_VT is not set
-# CONFIG_VT6655 is not set
-# CONFIG_VT6656 is not set
-# CONFIG_VXFS_FS is not set
-# CONFIG_VXGE is not set
-# CONFIG_VXLAN is not set
-# CONFIG_VZ89X is not set
-# CONFIG_W1 is not set
-# CONFIG_W1_CON is not set
-# CONFIG_W1_MASTER_DS1WM is not set
-# CONFIG_W1_MASTER_DS2482 is not set
-# CONFIG_W1_MASTER_DS2490 is not set
-# CONFIG_W1_MASTER_GPIO is not set
-# CONFIG_W1_MASTER_MATROX is not set
-# CONFIG_W1_SLAVE_BQ27000 is not set
-# CONFIG_W1_SLAVE_DS2405 is not set
-# CONFIG_W1_SLAVE_DS2406 is not set
-# CONFIG_W1_SLAVE_DS2408 is not set
-# CONFIG_W1_SLAVE_DS2413 is not set
-# CONFIG_W1_SLAVE_DS2423 is not set
-# CONFIG_W1_SLAVE_DS2431 is not set
-# CONFIG_W1_SLAVE_DS2433 is not set
-# CONFIG_W1_SLAVE_DS2438 is not set
-# CONFIG_W1_SLAVE_DS2760 is not set
-# CONFIG_W1_SLAVE_DS2780 is not set
-# CONFIG_W1_SLAVE_DS2781 is not set
-# CONFIG_W1_SLAVE_DS2805 is not set
-# CONFIG_W1_SLAVE_DS28E04 is not set
-# CONFIG_W1_SLAVE_DS28E17 is not set
-# CONFIG_W1_SLAVE_SMEM is not set
-# CONFIG_W1_SLAVE_THERM is not set
-# CONFIG_W83627HF_WDT is not set
-# CONFIG_W83877F_WDT is not set
-# CONFIG_W83977F_WDT is not set
-# CONFIG_WAN is not set
-# CONFIG_WANXL is not set
-# CONFIG_WARN_ALL_UNSEEDED_RANDOM is not set
-CONFIG_WATCHDOG=y
-# CONFIG_WATCHDOG_CORE is not set
-CONFIG_WATCHDOG_HANDLE_BOOT_ENABLED=y
-# CONFIG_WATCHDOG_NOWAYOUT is not set
-# CONFIG_WATCHDOG_PRETIMEOUT_GOV is not set
-# CONFIG_WATCHDOG_SYSFS is not set
-# CONFIG_WD80x3 is not set
-# CONFIG_WDAT_WDT is not set
-# CONFIG_WDTPCI is not set
-CONFIG_WEXT_CORE=y
-CONFIG_WEXT_PRIV=y
-CONFIG_WEXT_PROC=y
-CONFIG_WEXT_SPY=y
-CONFIG_WILINK_PLATFORM_DATA=y
-# CONFIG_WIMAX is not set
-# CONFIG_WIMAX_GDM72XX is not set
-CONFIG_WIRELESS=y
-CONFIG_WIRELESS_EXT=y
-# CONFIG_WIRELESS_WDS is not set
-# CONFIG_WIZNET_W5100 is not set
-# CONFIG_WIZNET_W5300 is not set
-# CONFIG_WL1251 is not set
-# CONFIG_WL12XX is not set
-# CONFIG_WL18XX is not set
-CONFIG_WLAN=y
-# CONFIG_WLAN_VENDOR_ADMTEK is not set
-# CONFIG_WLAN_VENDOR_ATH is not set
-# CONFIG_WLAN_VENDOR_ATMEL is not set
-# CONFIG_WLAN_VENDOR_BROADCOM is not set
-# CONFIG_WLAN_VENDOR_CISCO is not set
-# CONFIG_WLAN_VENDOR_INTEL is not set
-# CONFIG_WLAN_VENDOR_INTERSIL is not set
-# CONFIG_WLAN_VENDOR_MARVELL is not set
-# CONFIG_WLAN_VENDOR_MEDIATEK is not set
-# CONFIG_WLAN_VENDOR_QUANTENNA is not set
-# CONFIG_WLAN_VENDOR_RALINK is not set
-# CONFIG_WLAN_VENDOR_REALTEK is not set
-# CONFIG_WLAN_VENDOR_RSI is not set
-# CONFIG_WLAN_VENDOR_ST is not set
-# CONFIG_WLAN_VENDOR_TI is not set
-# CONFIG_WLAN_VENDOR_ZYDAS is not set
-# CONFIG_WLCORE is not set
-# CONFIG_WL_MEDIATEK is not set
-CONFIG_WL_TI=y
-CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
-# CONFIG_WQ_WATCHDOG is not set
-# CONFIG_WW_MUTEX_SELFTEST is not set
-# CONFIG_X25 is not set
-# CONFIG_X509_CERTIFICATE_PARSER is not set
-# CONFIG_X86_DEBUG_STATIC_CPU_HAS is not set
-# CONFIG_X86_PKG_TEMP_THERMAL is not set
-CONFIG_X86_SYSFB=y
-# CONFIG_XDP_SOCKETS is not set
-# CONFIG_XEN is not set
-# CONFIG_XEN_GRANT_DMA_ALLOC is not set
-# CONFIG_XEN_PVCALLS_FRONTEND is not set
-CONFIG_XEN_SCRUB_PAGES_DEFAULT=y
-CONFIG_XFRM=y
-# CONFIG_XFRM_INTERFACE is not set
-# CONFIG_XFRM_IPCOMP is not set
-# CONFIG_XFRM_MIGRATE is not set
-# CONFIG_XFRM_STATISTICS is not set
-# CONFIG_XFRM_SUB_POLICY is not set
-# CONFIG_XFRM_USER is not set
-# CONFIG_XFS_DEBUG is not set
-# CONFIG_XFS_FS is not set
-# CONFIG_XFS_ONLINE_SCRUB is not set
-# CONFIG_XFS_POSIX_ACL is not set
-# CONFIG_XFS_QUOTA is not set
-# CONFIG_XFS_RT is not set
-# CONFIG_XFS_WARN is not set
-# CONFIG_XILINX_AXI_EMAC is not set
-# CONFIG_XILINX_DMA is not set
-# CONFIG_XILINX_EMACLITE is not set
-# CONFIG_XILINX_GMII2RGMII is not set
-# CONFIG_XILINX_LL_TEMAC is not set
-# CONFIG_XILINX_VCU is not set
-# CONFIG_XILINX_WATCHDOG is not set
-# CONFIG_XILINX_ZYNQMP_DMA is not set
-# CONFIG_XILLYBUS is not set
-# CONFIG_XIL_AXIS_FIFO is not set
-# CONFIG_XIP_KERNEL is not set
-# CONFIG_XMON is not set
-CONFIG_XZ_DEC=y
-# CONFIG_XZ_DEC_ARM is not set
-# CONFIG_XZ_DEC_ARMTHUMB is not set
-# CONFIG_XZ_DEC_BCJ is not set
-# CONFIG_XZ_DEC_IA64 is not set
-# CONFIG_XZ_DEC_POWERPC is not set
-# CONFIG_XZ_DEC_SPARC is not set
-# CONFIG_XZ_DEC_TEST is not set
-# CONFIG_XZ_DEC_X86 is not set
-# CONFIG_YAM is not set
-# CONFIG_YELLOWFIN is not set
-# CONFIG_YENTA is not set
-# CONFIG_YENTA_O2 is not set
-# CONFIG_YENTA_RICOH is not set
-# CONFIG_YENTA_TI is not set
-# CONFIG_YENTA_TOSHIBA is not set
-# CONFIG_ZBUD is not set
-# CONFIG_ZD1211RW is not set
-# CONFIG_ZD1211RW_DEBUG is not set
-# CONFIG_ZEROPLUS_FF is not set
-# CONFIG_ZIIRAVE_WATCHDOG is not set
-# CONFIG_ZISOFS is not set
-# CONFIG_ZLIB_DEFLATE is not set
-# CONFIG_ZLIB_INFLATE is not set
-CONFIG_ZONE_DMA=y
-# CONFIG_ZOPT2201 is not set
-# CONFIG_ZPA2326 is not set
-# CONFIG_ZPOOL is not set
-# CONFIG_ZRAM is not set
-# CONFIG_ZRAM_MEMORY_TRACKING is not set
-# CONFIG_ZSMALLOC is not set
-# CONFIG_ZX_TDM is not set
-# CONFIG_NET_ACT_CTINFO is not set
-# CONFIG_RPI_AXIPERF is not set
-
--- a/target/linux/generic/config-4.9	2022-03-22 08:54:47.136464551 +0800
+++ b/target/linux/generic/config-4.9	1970-01-01 08:00:00.000000000 +0800
@@ -1,5328 +0,0 @@
-CONFIG_32BIT=y
-# CONFIG_6LOWPAN is not set
-# CONFIG_6LOWPAN_DEBUGFS is not set
-# CONFIG_6PACK is not set
-# CONFIG_8139CP is not set
-# CONFIG_8139TOO is not set
-# CONFIG_9P_FS is not set
-# CONFIG_AB3100_CORE is not set
-# CONFIG_AB8500_CORE is not set
-# CONFIG_ABX500_CORE is not set
-# CONFIG_ACCESSIBILITY is not set
-# CONFIG_ACENIC is not set
-# CONFIG_ACERHDF is not set
-# CONFIG_ACORN_PARTITION is not set
-# CONFIG_ACPI_ALS is not set
-# CONFIG_ACPI_APEI is not set
-# CONFIG_ACPI_BUTTON is not set
-# CONFIG_ACPI_CONFIGFS is not set
-# CONFIG_ACPI_CUSTOM_METHOD is not set
-# CONFIG_ACPI_EXTLOG is not set
-# CONFIG_ACPI_HED is not set
-# CONFIG_ACPI_NFIT is not set
-# CONFIG_ACPI_REDUCED_HARDWARE_ONLY is not set
-# CONFIG_ACPI_TABLE_UPGRADE is not set
-# CONFIG_ACPI_VIDEO is not set
-# CONFIG_AD2S1200 is not set
-# CONFIG_AD2S1210 is not set
-# CONFIG_AD2S90 is not set
-# CONFIG_AD5064 is not set
-# CONFIG_AD525X_DPOT is not set
-# CONFIG_AD5360 is not set
-# CONFIG_AD5380 is not set
-# CONFIG_AD5421 is not set
-# CONFIG_AD5446 is not set
-# CONFIG_AD5449 is not set
-# CONFIG_AD5504 is not set
-# CONFIG_AD5592R is not set
-# CONFIG_AD5593R is not set
-# CONFIG_AD5624R_SPI is not set
-# CONFIG_AD5686 is not set
-# CONFIG_AD5755 is not set
-# CONFIG_AD5761 is not set
-# CONFIG_AD5764 is not set
-# CONFIG_AD5791 is not set
-# CONFIG_AD5933 is not set
-# CONFIG_AD7150 is not set
-# CONFIG_AD7152 is not set
-# CONFIG_AD7192 is not set
-# CONFIG_AD7266 is not set
-# CONFIG_AD7280 is not set
-# CONFIG_AD7291 is not set
-# CONFIG_AD7298 is not set
-# CONFIG_AD7303 is not set
-# CONFIG_AD7476 is not set
-# CONFIG_AD7606 is not set
-# CONFIG_AD7746 is not set
-# CONFIG_AD7780 is not set
-# CONFIG_AD7791 is not set
-# CONFIG_AD7793 is not set
-# CONFIG_AD7816 is not set
-# CONFIG_AD7887 is not set
-# CONFIG_AD7923 is not set
-# CONFIG_AD799X is not set
-# CONFIG_AD8366 is not set
-# CONFIG_AD8801 is not set
-# CONFIG_AD9523 is not set
-# CONFIG_AD9832 is not set
-# CONFIG_AD9834 is not set
-# CONFIG_ADAPTEC_STARFIRE is not set
-# CONFIG_ADE7753 is not set
-# CONFIG_ADE7754 is not set
-# CONFIG_ADE7758 is not set
-# CONFIG_ADE7759 is not set
-# CONFIG_ADE7854 is not set
-# CONFIG_ADF4350 is not set
-# CONFIG_ADFS_FS is not set
-# CONFIG_ADIS16060 is not set
-# CONFIG_ADIS16080 is not set
-# CONFIG_ADIS16130 is not set
-# CONFIG_ADIS16136 is not set
-# CONFIG_ADIS16201 is not set
-# CONFIG_ADIS16203 is not set
-# CONFIG_ADIS16204 is not set
-# CONFIG_ADIS16209 is not set
-# CONFIG_ADIS16220 is not set
-# CONFIG_ADIS16240 is not set
-# CONFIG_ADIS16260 is not set
-# CONFIG_ADIS16400 is not set
-# CONFIG_ADIS16480 is not set
-# CONFIG_ADJD_S311 is not set
-# CONFIG_ADM6996_PHY is not set
-# CONFIG_ADM8211 is not set
-# CONFIG_ADT7316 is not set
-CONFIG_ADVISE_SYSCALLS=y
-# CONFIG_ADXRS450 is not set
-CONFIG_AEABI=y
-# CONFIG_AFE4403 is not set
-# CONFIG_AFE4404 is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_AFS_FS is not set
-# CONFIG_AF_KCM is not set
-# CONFIG_AF_RXRPC is not set
-# CONFIG_AF_RXRPC_INJECT_LOSS is not set
-# CONFIG_AF_RXRPC_IPV6 is not set
-# CONFIG_AGP is not set
-# CONFIG_AHCI_CEVA is not set
-# CONFIG_AHCI_IMX is not set
-# CONFIG_AHCI_MVEBU is not set
-# CONFIG_AHCI_QORIQ is not set
-CONFIG_AIO=y
-# CONFIG_AIRO is not set
-# CONFIG_AIRO_CS is not set
-# CONFIG_AIX_PARTITION is not set
-# CONFIG_AK09911 is not set
-# CONFIG_AK8974 is not set
-# CONFIG_AK8975 is not set
-# CONFIG_AL3320A is not set
-# CONFIG_ALIM7101_WDT is not set
-CONFIG_ALLOW_DEV_COREDUMP=y
-# CONFIG_ALTERA_MBOX is not set
-# CONFIG_ALTERA_STAPL is not set
-# CONFIG_ALTERA_TSE is not set
-# CONFIG_ALX is not set
-# CONFIG_AM2315 is not set
-# CONFIG_AM335X_PHY_USB is not set
-# CONFIG_AMBA_PL08X is not set
-# CONFIG_AMD8111_ETH is not set
-# CONFIG_AMD_PHY is not set
-# CONFIG_AMD_XGBE is not set
-# CONFIG_AMIGA_PARTITION is not set
-# CONFIG_AMILO_RFKILL is not set
-# CONFIG_ANDROID is not set
-CONFIG_ANON_INODES=y
-# CONFIG_APDS9300 is not set
-# CONFIG_APDS9802ALS is not set
-# CONFIG_APDS9960 is not set
-# CONFIG_APM8018X is not set
-# CONFIG_APM_EMULATION is not set
-# CONFIG_APPLE_GMUX is not set
-# CONFIG_APPLICOM is not set
-# CONFIG_AQUANTIA_PHY is not set
-# CONFIG_AR5523 is not set
-# CONFIG_AR7 is not set
-# CONFIG_AR8216_PHY is not set
-# CONFIG_AR8216_PHY_LEDS is not set
-# CONFIG_ARCH_ALPINE is not set
-# CONFIG_ARCH_ARTPEC is not set
-# CONFIG_ARCH_ASPEED is not set
-# CONFIG_ARCH_AT91 is not set
-# CONFIG_ARCH_BCM is not set
-# CONFIG_ARCH_BCM2835 is not set
-# CONFIG_ARCH_BCM_21664 is not set
-# CONFIG_ARCH_BCM_23550 is not set
-# CONFIG_ARCH_BCM_281XX is not set
-# CONFIG_ARCH_BCM_5301X is not set
-# CONFIG_ARCH_BCM_53573 is not set
-# CONFIG_ARCH_BCM_63XX is not set
-# CONFIG_ARCH_BCM_CYGNUS is not set
-# CONFIG_ARCH_BCM_IPROC is not set
-# CONFIG_ARCH_BCM_NSP is not set
-# CONFIG_ARCH_BERLIN is not set
-# CONFIG_ARCH_BRCMSTB is not set
-# CONFIG_ARCH_CLPS711X is not set
-# CONFIG_ARCH_CNS3XXX is not set
-# CONFIG_ARCH_DAVINCI is not set
-# CONFIG_ARCH_DIGICOLOR is not set
-# CONFIG_ARCH_DMA_ADDR_T_64BIT is not set
-# CONFIG_ARCH_DOVE is not set
-# CONFIG_ARCH_EBSA110 is not set
-# CONFIG_ARCH_EP93XX is not set
-# CONFIG_ARCH_EXYNOS is not set
-CONFIG_ARCH_FLATMEM_ENABLE=y
-# CONFIG_ARCH_FOOTBRIDGE is not set
-# CONFIG_ARCH_GEMINI is not set
-CONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED=y
-# CONFIG_ARCH_HAS_ILOG2_U32 is not set
-# CONFIG_ARCH_HAS_ILOG2_U64 is not set
-CONFIG_ARCH_HAS_UBSAN_SANITIZE_ALL=y
-# CONFIG_ARCH_HI3xxx is not set
-# CONFIG_ARCH_HIGHBANK is not set
-# CONFIG_ARCH_HISI is not set
-# CONFIG_ARCH_INTEGRATOR is not set
-# CONFIG_ARCH_IOP13XX is not set
-# CONFIG_ARCH_IOP32X is not set
-# CONFIG_ARCH_IOP33X is not set
-# CONFIG_ARCH_IXP4XX is not set
-# CONFIG_ARCH_KEYSTONE is not set
-# CONFIG_ARCH_KS8695 is not set
-# CONFIG_ARCH_LAYERSCAPE is not set
-# CONFIG_ARCH_LG1K is not set
-# CONFIG_ARCH_LPC32XX is not set
-# CONFIG_ARCH_MEDIATEK is not set
-# CONFIG_ARCH_MESON is not set
-CONFIG_ARCH_MMAP_RND_BITS=8
-CONFIG_ARCH_MMAP_RND_BITS_MAX=16
-CONFIG_ARCH_MMAP_RND_BITS_MIN=8
-CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MAX=16
-CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MIN=8
-# CONFIG_ARCH_MMP is not set
-# CONFIG_ARCH_MULTIPLATFORM is not set
-# CONFIG_ARCH_MULTI_V6 is not set
-# CONFIG_ARCH_MULTI_V7 is not set
-# CONFIG_ARCH_MV78XX0 is not set
-# CONFIG_ARCH_MVEBU is not set
-# CONFIG_ARCH_MXC is not set
-# CONFIG_ARCH_MXS is not set
-# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
-# CONFIG_ARCH_NETX is not set
-# CONFIG_ARCH_NOMADIK is not set
-# CONFIG_ARCH_NSPIRE is not set
-# CONFIG_ARCH_OMAP is not set
-# CONFIG_ARCH_OMAP1 is not set
-# CONFIG_ARCH_OMAP2 is not set
-# CONFIG_ARCH_OMAP2PLUS is not set
-# CONFIG_ARCH_OMAP3 is not set
-# CONFIG_ARCH_OMAP4 is not set
-# CONFIG_ARCH_ORION5X is not set
-# CONFIG_ARCH_OXNAS is not set
-# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
-# CONFIG_ARCH_PICOXCELL is not set
-# CONFIG_ARCH_PRIMA2 is not set
-# CONFIG_ARCH_PXA is not set
-# CONFIG_ARCH_QCOM is not set
-# CONFIG_ARCH_REALVIEW is not set
-# CONFIG_ARCH_RENESAS is not set
-# CONFIG_ARCH_ROCKCHIP is not set
-# CONFIG_ARCH_RPC is not set
-# CONFIG_ARCH_S3C24XX is not set
-# CONFIG_ARCH_S3C64XX is not set
-# CONFIG_ARCH_S5PV210 is not set
-# CONFIG_ARCH_SA1100 is not set
-# CONFIG_ARCH_SEATTLE is not set
-# CONFIG_ARCH_SHMOBILE is not set
-# CONFIG_ARCH_SHMOBILE_MULTI is not set
-# CONFIG_ARCH_SIRF is not set
-# CONFIG_ARCH_SOCFPGA is not set
-# CONFIG_ARCH_SPRD is not set
-# CONFIG_ARCH_STI is not set
-# CONFIG_ARCH_STRATIX10 is not set
-# CONFIG_ARCH_SUNXI is not set
-# CONFIG_ARCH_TANGO is not set
-# CONFIG_ARCH_TEGRA is not set
-# CONFIG_ARCH_THUNDER is not set
-# CONFIG_ARCH_U300 is not set
-# CONFIG_ARCH_U8500 is not set
-# CONFIG_ARCH_UNIPHIER is not set
-# CONFIG_ARCH_VERSATILE is not set
-# CONFIG_ARCH_VEXPRESS is not set
-# CONFIG_ARCH_VIRT is not set
-# CONFIG_ARCH_VT8500 is not set
-# CONFIG_ARCH_VULCAN is not set
-# CONFIG_ARCH_W90X900 is not set
-# CONFIG_ARCH_WANTS_UBSAN_NO_NULL is not set
-# CONFIG_ARCH_WM8505 is not set
-# CONFIG_ARCH_WM8750 is not set
-# CONFIG_ARCH_WM8850 is not set
-# CONFIG_ARCH_XGENE is not set
-# CONFIG_ARCH_ZX is not set
-# CONFIG_ARCH_ZYNQ is not set
-# CONFIG_ARCH_ZYNQMP is not set
-# CONFIG_ARCNET is not set
-# CONFIG_ARC_EMAC is not set
-# CONFIG_ARM64_ERRATUM_1024718 is not set
-# CONFIG_ARM64_ERRATUM_819472 is not set
-# CONFIG_ARM64_ERRATUM_824069 is not set
-# CONFIG_ARM64_ERRATUM_826319 is not set
-# CONFIG_ARM64_ERRATUM_827319 is not set
-# CONFIG_ARM64_ERRATUM_832075 is not set
-# CONFIG_ARM64_ERRATUM_834220 is not set
-# CONFIG_ARM64_ERRATUM_843419 is not set
-# CONFIG_ARM64_ERRATUM_845719 is not set
-# CONFIG_ARM_APPENDED_DTB is not set
-# CONFIG_ARM_ARCH_TIMER is not set
-# CONFIG_ARM_BIG_LITTLE_CPUFREQ is not set
-# CONFIG_ARM_CCI is not set
-# CONFIG_ARM_CCI400_PMU is not set
-# CONFIG_ARM_CCI5xx_PMU is not set
-# CONFIG_ARM_CCN is not set
-# CONFIG_ARM_CPUIDLE is not set
-CONFIG_ARM_CPU_TOPOLOGY=y
-# CONFIG_ARM_CRYPTO is not set
-CONFIG_ARM_DMA_MEM_BUFFERABLE=y
-# CONFIG_ARM_ERRATA_326103 is not set
-# CONFIG_ARM_ERRATA_364296 is not set
-# CONFIG_ARM_ERRATA_411920 is not set
-# CONFIG_ARM_ERRATA_430973 is not set
-# CONFIG_ARM_ERRATA_458693 is not set
-# CONFIG_ARM_ERRATA_460075 is not set
-# CONFIG_ARM_ERRATA_643719 is not set
-# CONFIG_ARM_ERRATA_720789 is not set
-# CONFIG_ARM_ERRATA_742230 is not set
-# CONFIG_ARM_ERRATA_742231 is not set
-# CONFIG_ARM_ERRATA_743622 is not set
-# CONFIG_ARM_ERRATA_751472 is not set
-# CONFIG_ARM_ERRATA_754322 is not set
-# CONFIG_ARM_ERRATA_754327 is not set
-# CONFIG_ARM_ERRATA_764369 is not set
-# CONFIG_ARM_ERRATA_773022 is not set
-# CONFIG_ARM_ERRATA_775420 is not set
-# CONFIG_ARM_ERRATA_798181 is not set
-# CONFIG_ARM_ERRATA_818325_852422 is not set
-# CONFIG_ARM_ERRATA_821420 is not set
-# CONFIG_ARM_ERRATA_825619 is not set
-# CONFIG_ARM_ERRATA_852421 is not set
-# CONFIG_ARM_ERRATA_852423 is not set
-CONFIG_ARM_GIC_MAX_NR=1
-# CONFIG_ARM_KERNMEM_PERMS is not set
-# CONFIG_ARM_KIRKWOOD_CPUFREQ is not set
-# CONFIG_ARM_KPROBES_TEST is not set
-# CONFIG_ARM_MHU is not set
-# CONFIG_ARM_MODULE_PLTS is not set
-# CONFIG_ARM_PATCH_PHYS_VIRT is not set
-# CONFIG_ARM_PSCI is not set
-# CONFIG_ARM_PTDUMP is not set
-# CONFIG_ARM_SBSA_WATCHDOG is not set
-# CONFIG_ARM_SCPI_PROTOCOL is not set
-# CONFIG_ARM_TIMER_SP804 is not set
-# CONFIG_ARM_UNWIND is not set
-# CONFIG_ARM_VIRT_EXT is not set
-# CONFIG_AS3935 is not set
-# CONFIG_ASM9260_TIMER is not set
-# CONFIG_ASUS_LAPTOP is not set
-# CONFIG_ASUS_WIRELESS is not set
-# CONFIG_ASYMMETRIC_KEY_TYPE is not set
-# CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE is not set
-# CONFIG_ASYNC_RAID6_TEST is not set
-# CONFIG_ASYNC_TX_DMA is not set
-# CONFIG_AT76C50X_USB is not set
-# CONFIG_AT803X_PHY is not set
-# CONFIG_AT91_SAMA5D2_ADC is not set
-# CONFIG_ATA is not set
-# CONFIG_ATAGS is not set
-CONFIG_ATAGS_PROC=y
-# CONFIG_ATALK is not set
-# CONFIG_ATARI_PARTITION is not set
-# CONFIG_ATA_ACPI is not set
-CONFIG_ATA_BMDMA=y
-# CONFIG_ATA_GENERIC is not set
-# CONFIG_ATA_NONSTANDARD is not set
-# CONFIG_ATA_OVER_ETH is not set
-# CONFIG_ATA_PIIX is not set
-CONFIG_ATA_SFF=y
-# CONFIG_ATA_VERBOSE_ERROR is not set
-# CONFIG_ATH10K is not set
-# CONFIG_ATH25 is not set
-# CONFIG_ATH5K is not set
-# CONFIG_ATH6KL is not set
-# CONFIG_ATH79 is not set
-# CONFIG_ATH9K is not set
-# CONFIG_ATH9K_HTC is not set
-# CONFIG_ATH_DEBUG is not set
-# CONFIG_ATL1 is not set
-# CONFIG_ATL1C is not set
-# CONFIG_ATL1E is not set
-# CONFIG_ATL2 is not set
-# CONFIG_ATLAS_PH_SENSOR is not set
-# CONFIG_ATM is not set
-# CONFIG_ATMEL is not set
-# CONFIG_ATMEL_PIT is not set
-# CONFIG_ATMEL_SSC is not set
-# CONFIG_ATM_AMBASSADOR is not set
-# CONFIG_ATM_BR2684 is not set
-CONFIG_ATM_BR2684_IPFILTER=y
-# CONFIG_ATM_CLIP is not set
-CONFIG_ATM_CLIP_NO_ICMP=y
-# CONFIG_ATM_DRIVERS is not set
-# CONFIG_ATM_DUMMY is not set
-# CONFIG_ATM_ENI is not set
-# CONFIG_ATM_FIRESTREAM is not set
-# CONFIG_ATM_FORE200E is not set
-# CONFIG_ATM_HE is not set
-# CONFIG_ATM_HORIZON is not set
-# CONFIG_ATM_IA is not set
-# CONFIG_ATM_IDT77252 is not set
-# CONFIG_ATM_LANAI is not set
-# CONFIG_ATM_LANE is not set
-# CONFIG_ATM_MPOA is not set
-# CONFIG_ATM_NICSTAR is not set
-# CONFIG_ATM_SOLOS is not set
-# CONFIG_ATM_TCP is not set
-# CONFIG_ATM_ZATM is not set
-# CONFIG_ATOMIC64_SELFTEST is not set
-# CONFIG_ATP is not set
-# CONFIG_AUDIT is not set
-# CONFIG_AUDIT_ARCH_COMPAT_GENERIC is not set
-# CONFIG_AURORA_NB8800 is not set
-# CONFIG_AUTOFS4_FS is not set
-# CONFIG_AUTO_ZRELADDR is not set
-# CONFIG_AUXDISPLAY is not set
-# CONFIG_AX25 is not set
-# CONFIG_AX25_DAMA_SLAVE is not set
-# CONFIG_AX88796 is not set
-# CONFIG_AXP288_ADC is not set
-# CONFIG_AXP288_FUEL_GAUGE is not set
-# CONFIG_B43 is not set
-# CONFIG_B43LEGACY is not set
-# CONFIG_B44 is not set
-# CONFIG_B53 is not set
-# CONFIG_BACKLIGHT_ADP8860 is not set
-# CONFIG_BACKLIGHT_ADP8870 is not set
-# CONFIG_BACKLIGHT_APPLE is not set
-# CONFIG_BACKLIGHT_BD6107 is not set
-# CONFIG_BACKLIGHT_GENERIC is not set
-# CONFIG_BACKLIGHT_GPIO is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
-# CONFIG_BACKLIGHT_LM3630A is not set
-# CONFIG_BACKLIGHT_LM3639 is not set
-# CONFIG_BACKLIGHT_LP855X is not set
-# CONFIG_BACKLIGHT_LV5207LP is not set
-# CONFIG_BACKLIGHT_PANDORA is not set
-# CONFIG_BACKLIGHT_PM8941_WLED is not set
-# CONFIG_BACKLIGHT_RPI is not set
-# CONFIG_BACKLIGHT_SAHARA is not set
-# CONFIG_BACKTRACE_SELF_TEST is not set
-CONFIG_BASE_FULL=y
-CONFIG_BASE_SMALL=0
-# CONFIG_BATMAN_ADV is not set
-# CONFIG_BATTERY_BQ27XXX is not set
-# CONFIG_BATTERY_DS2760 is not set
-# CONFIG_BATTERY_DS2780 is not set
-# CONFIG_BATTERY_DS2781 is not set
-# CONFIG_BATTERY_DS2782 is not set
-# CONFIG_BATTERY_GAUGE_LTC2941 is not set
-# CONFIG_BATTERY_GOLDFISH is not set
-# CONFIG_BATTERY_MAX17040 is not set
-# CONFIG_BATTERY_MAX17042 is not set
-# CONFIG_BATTERY_SBS is not set
-# CONFIG_BAYCOM_EPP is not set
-# CONFIG_BAYCOM_PAR is not set
-# CONFIG_BAYCOM_SER_FDX is not set
-# CONFIG_BAYCOM_SER_HDX is not set
-# CONFIG_BCACHE is not set
-# CONFIG_BCM47XX is not set
-# CONFIG_BCM63XX is not set
-# CONFIG_BCM63XX_PHY is not set
-# CONFIG_BCM7038_WDT is not set
-# CONFIG_BCM7XXX_PHY is not set
-# CONFIG_BCM87XX_PHY is not set
-# CONFIG_BCMA is not set
-# CONFIG_BCMA_DRIVER_GPIO is not set
-CONFIG_BCMA_POSSIBLE=y
-# CONFIG_BCMGENET is not set
-# CONFIG_BCM_IPROC_ADC is not set
-# CONFIG_BCM_KONA_USB2_PHY is not set
-# CONFIG_BDI_SWITCH is not set
-# CONFIG_BE2ISCSI is not set
-# CONFIG_BE2NET is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_BGMAC is not set
-# CONFIG_BH1750 is not set
-# CONFIG_BH1780 is not set
-# CONFIG_BIG_KEYS is not set
-# CONFIG_BIG_LITTLE is not set
-# CONFIG_BINARY_PRINTF is not set
-# CONFIG_BINFMT_AOUT is not set
-CONFIG_BINFMT_ELF=y
-# CONFIG_BINFMT_FLAT is not set
-# CONFIG_BINFMT_MISC is not set
-CONFIG_BINFMT_SCRIPT=y
-CONFIG_BITREVERSE=y
-# CONFIG_BLK_CMDLINE_PARSER is not set
-# CONFIG_BLK_CPQ_CISS_DA is not set
-# CONFIG_BLK_CPQ_DA is not set
-CONFIG_BLK_DEV=y
-# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
-# CONFIG_BLK_DEV_4DRIVES is not set
-# CONFIG_BLK_DEV_AEC62XX is not set
-# CONFIG_BLK_DEV_ALI14XX is not set
-# CONFIG_BLK_DEV_ALI15X3 is not set
-# CONFIG_BLK_DEV_AMD74XX is not set
-# CONFIG_BLK_DEV_ATIIXP is not set
-# CONFIG_BLK_DEV_BSG is not set
-# CONFIG_BLK_DEV_BSGLIB is not set
-# CONFIG_BLK_DEV_CMD640 is not set
-# CONFIG_BLK_DEV_CMD64X is not set
-# CONFIG_BLK_DEV_COW_COMMON is not set
-# CONFIG_BLK_DEV_CRYPTOLOOP is not set
-# CONFIG_BLK_DEV_CS5520 is not set
-# CONFIG_BLK_DEV_CS5530 is not set
-# CONFIG_BLK_DEV_CS5535 is not set
-# CONFIG_BLK_DEV_CS5536 is not set
-# CONFIG_BLK_DEV_CY82C693 is not set
-# CONFIG_BLK_DEV_DAC960 is not set
-# CONFIG_BLK_DEV_DELKIN is not set
-# CONFIG_BLK_DEV_DRBD is not set
-# CONFIG_BLK_DEV_DTC2278 is not set
-# CONFIG_BLK_DEV_FD is not set
-# CONFIG_BLK_DEV_GENERIC is not set
-# CONFIG_BLK_DEV_HD is not set
-# CONFIG_BLK_DEV_HPT366 is not set
-# CONFIG_BLK_DEV_HT6560B is not set
-# CONFIG_BLK_DEV_IDEACPI is not set
-# CONFIG_BLK_DEV_IDECD is not set
-# CONFIG_BLK_DEV_IDECS is not set
-# CONFIG_BLK_DEV_IDEPCI is not set
-# CONFIG_BLK_DEV_IDEPNP is not set
-# CONFIG_BLK_DEV_IDETAPE is not set
-# CONFIG_BLK_DEV_IDE_AU1XXX is not set
-# CONFIG_BLK_DEV_IDE_SATA is not set
-CONFIG_BLK_DEV_INITRD=y
-# CONFIG_BLK_DEV_INTEGRITY is not set
-# CONFIG_BLK_DEV_IO_TRACE is not set
-# CONFIG_BLK_DEV_IT8172 is not set
-# CONFIG_BLK_DEV_IT8213 is not set
-# CONFIG_BLK_DEV_IT821X is not set
-# CONFIG_BLK_DEV_JMICRON is not set
-# CONFIG_BLK_DEV_LOOP is not set
-CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
-# CONFIG_BLK_DEV_NBD is not set
-# CONFIG_BLK_DEV_NS87415 is not set
-# CONFIG_BLK_DEV_NULL_BLK is not set
-# CONFIG_BLK_DEV_NVME is not set
-# CONFIG_BLK_DEV_OFFBOARD is not set
-# CONFIG_BLK_DEV_OPTI621 is not set
-# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
-# CONFIG_BLK_DEV_PDC202XX_NEW is not set
-# CONFIG_BLK_DEV_PDC202XX_OLD is not set
-# CONFIG_BLK_DEV_PIIX is not set
-# CONFIG_BLK_DEV_PLATFORM is not set
-# CONFIG_BLK_DEV_PMEM is not set
-# CONFIG_BLK_DEV_QD65XX is not set
-# CONFIG_BLK_DEV_RAM is not set
-# CONFIG_BLK_DEV_RBD is not set
-# CONFIG_BLK_DEV_RSXX is not set
-# CONFIG_BLK_DEV_RZ1000 is not set
-# CONFIG_BLK_DEV_SC1200 is not set
-# CONFIG_BLK_DEV_SD is not set
-# CONFIG_BLK_DEV_SIIMAGE is not set
-# CONFIG_BLK_DEV_SIS5513 is not set
-# CONFIG_BLK_DEV_SKD is not set
-# CONFIG_BLK_DEV_SL82C105 is not set
-# CONFIG_BLK_DEV_SLC90E66 is not set
-# CONFIG_BLK_DEV_SR is not set
-# CONFIG_BLK_DEV_SVWKS is not set
-# CONFIG_BLK_DEV_SX8 is not set
-# CONFIG_BLK_DEV_TC86C001 is not set
-# CONFIG_BLK_DEV_THROTTLING is not set
-# CONFIG_BLK_DEV_TRIFLEX is not set
-# CONFIG_BLK_DEV_TRM290 is not set
-# CONFIG_BLK_DEV_UMC8672 is not set
-# CONFIG_BLK_DEV_UMEM is not set
-# CONFIG_BLK_DEV_VIA82CXXX is not set
-CONFIG_BLOCK=y
-# CONFIG_BMA180 is not set
-# CONFIG_BMA220 is not set
-# CONFIG_BMC150_ACCEL is not set
-# CONFIG_BMC150_MAGN is not set
-# CONFIG_BMC150_MAGN_I2C is not set
-# CONFIG_BMC150_MAGN_SPI is not set
-# CONFIG_BMG160 is not set
-# CONFIG_BMI160_I2C is not set
-# CONFIG_BMI160_SPI is not set
-# CONFIG_BMIPS_GENERIC is not set
-# CONFIG_BMP085 is not set
-# CONFIG_BMP085_I2C is not set
-# CONFIG_BMP085_SPI is not set
-# CONFIG_BMP280 is not set
-# CONFIG_BNA is not set
-# CONFIG_BNX2 is not set
-# CONFIG_BNX2X is not set
-# CONFIG_BNXT is not set
-# CONFIG_BONDING is not set
-# CONFIG_BOOKE_WDT is not set
-CONFIG_BOOKE_WDT_DEFAULT_TIMEOUT=3
-# CONFIG_BOOT_PRINTK_DELAY is not set
-CONFIG_BOOT_RAW=y
-CONFIG_BPF=y
-# CONFIG_BPF_JIT is not set
-CONFIG_BPF_SYSCALL=y
-# CONFIG_BPQETHER is not set
-CONFIG_BQL=y
-CONFIG_BRANCH_PROFILE_NONE=y
-# CONFIG_BRCMFMAC is not set
-# CONFIG_BRCMSMAC is not set
-# CONFIG_BRCMSTB_GISB_ARB is not set
-CONFIG_BRIDGE=y
-# CONFIG_BRIDGE_EBT_802_3 is not set
-# CONFIG_BRIDGE_EBT_AMONG is not set
-# CONFIG_BRIDGE_EBT_ARP is not set
-# CONFIG_BRIDGE_EBT_ARPREPLY is not set
-# CONFIG_BRIDGE_EBT_BROUTE is not set
-# CONFIG_BRIDGE_EBT_DNAT is not set
-# CONFIG_BRIDGE_EBT_IP is not set
-# CONFIG_BRIDGE_EBT_IP6 is not set
-# CONFIG_BRIDGE_EBT_LIMIT is not set
-# CONFIG_BRIDGE_EBT_LOG is not set
-# CONFIG_BRIDGE_EBT_MARK is not set
-# CONFIG_BRIDGE_EBT_MARK_T is not set
-# CONFIG_BRIDGE_EBT_NFLOG is not set
-# CONFIG_BRIDGE_EBT_PKTTYPE is not set
-# CONFIG_BRIDGE_EBT_REDIRECT is not set
-# CONFIG_BRIDGE_EBT_SNAT is not set
-# CONFIG_BRIDGE_EBT_STP is not set
-# CONFIG_BRIDGE_EBT_T_FILTER is not set
-# CONFIG_BRIDGE_EBT_T_NAT is not set
-# CONFIG_BRIDGE_EBT_VLAN is not set
-CONFIG_BRIDGE_IGMP_SNOOPING=y
-# CONFIG_BRIDGE_NETFILTER is not set
-# CONFIG_BRIDGE_NF_EBTABLES is not set
-CONFIG_BRIDGE_VLAN_FILTERING=y
-# CONFIG_BROADCOM_PHY is not set
-CONFIG_BROKEN_ON_SMP=y
-# CONFIG_BSD_DISKLABEL is not set
-# CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_BSD_PROCESS_ACCT_V3 is not set
-# CONFIG_BT is not set
-# CONFIG_BTRFS_ASSERT is not set
-# CONFIG_BTRFS_DEBUG is not set
-# CONFIG_BTRFS_FS is not set
-# CONFIG_BTRFS_FS_POSIX_ACL is not set
-# CONFIG_BTRFS_FS_RUN_SANITY_TESTS is not set
-# CONFIG_BT_ATH3K is not set
-# CONFIG_BT_BNEP is not set
-CONFIG_BT_BNEP_MC_FILTER=y
-CONFIG_BT_BNEP_PROTO_FILTER=y
-# CONFIG_BT_BREDR is not set
-# CONFIG_BT_CMTP is not set
-# CONFIG_BT_HCIBCM203X is not set
-# CONFIG_BT_HCIBFUSB is not set
-# CONFIG_BT_HCIBLUECARD is not set
-# CONFIG_BT_HCIBPA10X is not set
-# CONFIG_BT_HCIBT3C is not set
-# CONFIG_BT_HCIBTSDIO is not set
-# CONFIG_BT_HCIBTUART is not set
-# CONFIG_BT_HCIBTUSB is not set
-# CONFIG_BT_HCIBTUSB_RTL is not set
-# CONFIG_BT_HCIDTL1 is not set
-# CONFIG_BT_HCIUART is not set
-# CONFIG_BT_HCIUART_3WIRE is not set
-# CONFIG_BT_HCIUART_AG6XX is not set
-# CONFIG_BT_HCIUART_ATH3K is not set
-CONFIG_BT_HCIUART_BCSP=y
-CONFIG_BT_HCIUART_H4=y
-# CONFIG_BT_HCIUART_LL is not set
-# CONFIG_BT_HCIUART_MRVL is not set
-# CONFIG_BT_HCIUART_QCA is not set
-# CONFIG_BT_HCIVHCI is not set
-# CONFIG_BT_HIDP is not set
-# CONFIG_BT_HS is not set
-# CONFIG_BT_LE is not set
-# CONFIG_BT_LEDS is not set
-# CONFIG_BT_MRVL is not set
-# CONFIG_BT_RFCOMM is not set
-CONFIG_BT_RFCOMM_TTY=y
-# CONFIG_BT_SELFTEST is not set
-CONFIG_BUG=y
-CONFIG_BUILDTIME_EXTABLE_SORT=y
-# CONFIG_BUILD_BIN2C is not set
-# CONFIG_C2PORT is not set
-CONFIG_CACHE_L2X0_PMU=y
-# CONFIG_CADENCE_WATCHDOG is not set
-# CONFIG_CAIF is not set
-# CONFIG_CAN is not set
-# CONFIG_CAN_BCM is not set
-# CONFIG_CAN_DEBUG_DEVICES is not set
-# CONFIG_CAN_DEV is not set
-# CONFIG_CAN_GS_USB is not set
-# CONFIG_CAN_GW is not set
-# CONFIG_CAN_IFI_CANFD is not set
-# CONFIG_CAN_M_CAN is not set
-# CONFIG_CAN_RAW is not set
-# CONFIG_CAN_RCAR is not set
-# CONFIG_CAN_RCAR_CANFD is not set
-# CONFIG_CAN_SLCAN is not set
-# CONFIG_CAN_SUN4I is not set
-# CONFIG_CAN_VCAN is not set
-# CONFIG_CAPI_AVM is not set
-# CONFIG_CAPI_EICON is not set
-# CONFIG_CAPI_TRACE is not set
-CONFIG_CARDBUS=y
-# CONFIG_CARDMAN_4000 is not set
-# CONFIG_CARDMAN_4040 is not set
-# CONFIG_CARL9170 is not set
-# CONFIG_CASSINI is not set
-# CONFIG_CAVIUM_ERRATUM_22375 is not set
-# CONFIG_CAVIUM_ERRATUM_23144 is not set
-# CONFIG_CAVIUM_ERRATUM_23154 is not set
-# CONFIG_CAVIUM_ERRATUM_27456 is not set
-# CONFIG_CAVIUM_OCTEON_SOC is not set
-# CONFIG_CB710_CORE is not set
-# CONFIG_CC10001_ADC is not set
-# CONFIG_CC_STACKPROTECTOR is not set
-CONFIG_CC_STACKPROTECTOR_NONE=y
-# CONFIG_CC_STACKPROTECTOR_REGULAR is not set
-# CONFIG_CC_STACKPROTECTOR_STRONG is not set
-# CONFIG_CDROM_PKTCDVD is not set
-# CONFIG_CEPH_FS is not set
-# CONFIG_CEPH_LIB is not set
-# CONFIG_CFG80211 is not set
-# CONFIG_CFG80211_CERTIFICATION_ONUS is not set
-# CONFIG_CGROUPS is not set
-# CONFIG_CGROUP_DEBUG is not set
-# CONFIG_CGROUP_NET_CLASSID is not set
-# CONFIG_CGROUP_NET_PRIO is not set
-# CONFIG_CHARGER_BQ2415X is not set
-# CONFIG_CHARGER_BQ24190 is not set
-# CONFIG_CHARGER_BQ24257 is not set
-# CONFIG_CHARGER_BQ24735 is not set
-# CONFIG_CHARGER_BQ25890 is not set
-# CONFIG_CHARGER_GPIO is not set
-# CONFIG_CHARGER_ISP1704 is not set
-# CONFIG_CHARGER_LP8727 is not set
-# CONFIG_CHARGER_MANAGER is not set
-# CONFIG_CHARGER_MAX8903 is not set
-# CONFIG_CHARGER_RT9455 is not set
-# CONFIG_CHARGER_SMB347 is not set
-# CONFIG_CHARGER_TWL4030 is not set
-# CONFIG_CHECKPOINT_RESTORE is not set
-# CONFIG_CHELSIO_T1 is not set
-# CONFIG_CHELSIO_T3 is not set
-# CONFIG_CHELSIO_T4 is not set
-# CONFIG_CHELSIO_T4VF is not set
-# CONFIG_CHROME_PLATFORMS is not set
-# CONFIG_CHR_DEV_OSST is not set
-# CONFIG_CHR_DEV_SCH is not set
-# CONFIG_CHR_DEV_SG is not set
-# CONFIG_CHR_DEV_ST is not set
-# CONFIG_CICADA_PHY is not set
-# CONFIG_CIFS is not set
-# CONFIG_CIFS_ACL is not set
-# CONFIG_CIFS_DEBUG is not set
-# CONFIG_CIFS_DEBUG2 is not set
-# CONFIG_CIFS_FSCACHE is not set
-# CONFIG_CIFS_NFSD_EXPORT is not set
-CONFIG_CIFS_POSIX=y
-# CONFIG_CIFS_SMB2 is not set
-CONFIG_CIFS_STATS=y
-# CONFIG_CIFS_STATS2 is not set
-# CONFIG_CIFS_WEAK_PW_HASH is not set
-# CONFIG_CIFS_XATTR is not set
-# CONFIG_CIO_DAC is not set
-# CONFIG_CLEANCACHE is not set
-# CONFIG_CLKSRC_VERSATILE is not set
-# CONFIG_CLK_QORIQ is not set
-# CONFIG_CLOCK_THERMAL is not set
-CONFIG_CLS_U32_MARK=y
-# CONFIG_CLS_U32_PERF is not set
-# CONFIG_CM32181 is not set
-# CONFIG_CM3232 is not set
-# CONFIG_CM3323 is not set
-# CONFIG_CM36651 is not set
-# CONFIG_CMA is not set
-CONFIG_CMDLINE=""
-# CONFIG_CMDLINE_BOOL is not set
-# CONFIG_CMDLINE_EXTEND is not set
-# CONFIG_CMDLINE_FORCE is not set
-# CONFIG_CMDLINE_FROM_BOOTLOADER is not set
-# CONFIG_CMDLINE_PARTITION is not set
-# CONFIG_CNIC is not set
-# CONFIG_CODA_FS is not set
-# CONFIG_CODE_PATCHING_SELFTEST is not set
-# CONFIG_COMEDI is not set
-# CONFIG_COMMON_CLK_CDCE706 is not set
-# CONFIG_COMMON_CLK_CDCE925 is not set
-# CONFIG_COMMON_CLK_CS2000_CP is not set
-# CONFIG_COMMON_CLK_IPROC is not set
-# CONFIG_COMMON_CLK_NXP is not set
-# CONFIG_COMMON_CLK_PIC32 is not set
-# CONFIG_COMMON_CLK_PWM is not set
-# CONFIG_COMMON_CLK_PXA is not set
-# CONFIG_COMMON_CLK_QCOM is not set
-# CONFIG_COMMON_CLK_SI514 is not set
-# CONFIG_COMMON_CLK_SI5351 is not set
-# CONFIG_COMMON_CLK_SI570 is not set
-# CONFIG_COMMON_CLK_XLNX_CLKWZRD is not set
-CONFIG_COMPACTION=y
-# CONFIG_COMPAL_LAPTOP is not set
-# CONFIG_COMPAT_BRK is not set
-# CONFIG_COMPILE_TEST is not set
-# CONFIG_CONFIGFS_FS is not set
-# CONFIG_CONNECTOR is not set
-CONFIG_CONSTRUCTORS=y
-# CONFIG_CONTEXT_SWITCH_TRACER is not set
-# CONFIG_COPS is not set
-# CONFIG_CORDIC is not set
-# CONFIG_COREDUMP is not set
-# CONFIG_CORESIGHT is not set
-# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
-# CONFIG_CPA_DEBUG is not set
-# CONFIG_CPU_DCACHE_DISABLE is not set
-# CONFIG_CPU_FREQ is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_SCHEDUTIL is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
-# CONFIG_CPU_FREQ_GOV_SCHEDUTIL is not set
-# CONFIG_CPU_FREQ_STAT_DETAILS is not set
-# CONFIG_CPU_IDLE is not set
-# CONFIG_CPU_IDLE_GOV_MENU is not set
-# CONFIG_CPU_IDLE_MULTIPLE_DRIVERS is not set
-# CONFIG_CPU_NO_EFFICIENT_FFS is not set
-CONFIG_CPU_SW_DOMAIN_PAN=y
-# CONFIG_CRAMFS is not set
-CONFIG_CRASHLOG=y
-# CONFIG_CRASH_DUMP is not set
-# CONFIG_CRC16 is not set
-CONFIG_CRC32=y
-# CONFIG_CRC32_BIT is not set
-CONFIG_CRC32_SARWATE=y
-# CONFIG_CRC32_SELFTEST is not set
-# CONFIG_CRC32_SLICEBY4 is not set
-# CONFIG_CRC32_SLICEBY8 is not set
-# CONFIG_CRC7 is not set
-# CONFIG_CRC8 is not set
-# CONFIG_CRC_CCITT is not set
-# CONFIG_CRC_ITU_T is not set
-# CONFIG_CRC_T10DIF is not set
-CONFIG_CROSS_COMPILE=""
-# CONFIG_CROSS_MEMORY_ATTACH is not set
-CONFIG_CRYPTO=y
-# CONFIG_CRYPTO_842 is not set
-# CONFIG_CRYPTO_AEAD is not set
-CONFIG_CRYPTO_AES=y
-# CONFIG_CRYPTO_AES_586 is not set
-# CONFIG_CRYPTO_AES_ARM is not set
-# CONFIG_CRYPTO_AES_ARM_BS is not set
-# CONFIG_CRYPTO_AES_NI_INTEL is not set
-CONFIG_CRYPTO_ALGAPI=y
-CONFIG_CRYPTO_ALGAPI2=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-# CONFIG_CRYPTO_ANUBIS is not set
-CONFIG_CRYPTO_ARC4=y
-# CONFIG_CRYPTO_AUTHENC is not set
-CONFIG_CRYPTO_BLKCIPHER=y
-CONFIG_CRYPTO_BLKCIPHER2=y
-# CONFIG_CRYPTO_BLOWFISH is not set
-# CONFIG_CRYPTO_CAMELLIA is not set
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
-# CONFIG_CRYPTO_CBC is not set
-# CONFIG_CRYPTO_CCM is not set
-# CONFIG_CRYPTO_CHACHA20 is not set
-# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
-# CONFIG_CRYPTO_CMAC is not set
-# CONFIG_CRYPTO_CRC32 is not set
-# CONFIG_CRYPTO_CRC32C is not set
-# CONFIG_CRYPTO_CRC32C_INTEL is not set
-# CONFIG_CRYPTO_CRCT10DIF is not set
-# CONFIG_CRYPTO_CRYPTD is not set
-# CONFIG_CRYPTO_CTR is not set
-# CONFIG_CRYPTO_CTS is not set
-# CONFIG_CRYPTO_DEFLATE is not set
-# CONFIG_CRYPTO_DES is not set
-# CONFIG_CRYPTO_DEV_ATMEL_AES is not set
-# CONFIG_CRYPTO_DEV_ATMEL_SHA is not set
-# CONFIG_CRYPTO_DEV_ATMEL_TDES is not set
-# CONFIG_CRYPTO_DEV_CCP is not set
-# CONFIG_CRYPTO_DEV_FSL_CAAM is not set
-# CONFIG_CRYPTO_DEV_HIFN_795X is not set
-# CONFIG_CRYPTO_DEV_IMGTEC_HASH is not set
-# CONFIG_CRYPTO_DEV_MARVELL_CESA is not set
-# CONFIG_CRYPTO_DEV_MV_CESA is not set
-# CONFIG_CRYPTO_DEV_MXC_SCC is not set
-# CONFIG_CRYPTO_DEV_MXS_DCP is not set
-# CONFIG_CRYPTO_DEV_QAT_C3XXX is not set
-# CONFIG_CRYPTO_DEV_QAT_C3XXXVF is not set
-# CONFIG_CRYPTO_DEV_QAT_C62X is not set
-# CONFIG_CRYPTO_DEV_QAT_C62XVF is not set
-# CONFIG_CRYPTO_DEV_QAT_DH895xCC is not set
-# CONFIG_CRYPTO_DEV_QAT_DH895xCCVF is not set
-# CONFIG_CRYPTO_DEV_QCE is not set
-# CONFIG_CRYPTO_DEV_SAHARA is not set
-# CONFIG_CRYPTO_DEV_TALITOS is not set
-# CONFIG_CRYPTO_DH is not set
-# CONFIG_CRYPTO_DRBG_CTR is not set
-# CONFIG_CRYPTO_DRBG_HASH is not set
-# CONFIG_CRYPTO_DRBG_MENU is not set
-# CONFIG_CRYPTO_ECB is not set
-# CONFIG_CRYPTO_ECDH is not set
-# CONFIG_CRYPTO_ECHAINIV is not set
-# CONFIG_CRYPTO_FCRYPT is not set
-# CONFIG_CRYPTO_FIPS is not set
-# CONFIG_CRYPTO_GCM is not set
-# CONFIG_CRYPTO_GF128MUL is not set
-# CONFIG_CRYPTO_GHASH is not set
-# CONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL is not set
-# CONFIG_CRYPTO_HASH is not set
-# CONFIG_CRYPTO_HMAC is not set
-# CONFIG_CRYPTO_HW is not set
-# CONFIG_CRYPTO_JITTERENTROPY is not set
-# CONFIG_CRYPTO_KEYWRAP is not set
-# CONFIG_CRYPTO_KHAZAD is not set
-# CONFIG_CRYPTO_LRW is not set
-# CONFIG_CRYPTO_LZ4 is not set
-# CONFIG_CRYPTO_LZ4HC is not set
-# CONFIG_CRYPTO_LZO is not set
-# CONFIG_CRYPTO_MANAGER is not set
-# CONFIG_CRYPTO_MANAGER2 is not set
-CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
-# CONFIG_CRYPTO_MCRYPTD is not set
-# CONFIG_CRYPTO_MD4 is not set
-# CONFIG_CRYPTO_MD5 is not set
-# CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_NULL is not set
-# CONFIG_CRYPTO_PCBC is not set
-# CONFIG_CRYPTO_PCOMP is not set
-# CONFIG_CRYPTO_PCOMP2 is not set
-CONFIG_CRYPTO_PCRYPT=y
-# CONFIG_CRYPTO_POLY1305 is not set
-# CONFIG_CRYPTO_RMD128 is not set
-# CONFIG_CRYPTO_RMD160 is not set
-# CONFIG_CRYPTO_RMD256 is not set
-# CONFIG_CRYPTO_RMD320 is not set
-# CONFIG_CRYPTO_RNG is not set
-# CONFIG_CRYPTO_RSA is not set
-# CONFIG_CRYPTO_SALSA20 is not set
-# CONFIG_CRYPTO_SALSA20_586 is not set
-# CONFIG_CRYPTO_SEED is not set
-# CONFIG_CRYPTO_SEQIV is not set
-# CONFIG_CRYPTO_SERPENT is not set
-# CONFIG_CRYPTO_SHA1 is not set
-# CONFIG_CRYPTO_SHA1_ARM is not set
-# CONFIG_CRYPTO_SHA256 is not set
-# CONFIG_CRYPTO_SHA3 is not set
-# CONFIG_CRYPTO_SHA512 is not set
-# CONFIG_CRYPTO_TEA is not set
-# CONFIG_CRYPTO_TEST is not set
-# CONFIG_CRYPTO_TGR192 is not set
-# CONFIG_CRYPTO_TWOFISH is not set
-# CONFIG_CRYPTO_TWOFISH_586 is not set
-# CONFIG_CRYPTO_TWOFISH_COMMON is not set
-# CONFIG_CRYPTO_USER is not set
-# CONFIG_CRYPTO_USER_API_AEAD is not set
-# CONFIG_CRYPTO_USER_API_HASH is not set
-# CONFIG_CRYPTO_USER_API_RNG is not set
-# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
-# CONFIG_CRYPTO_VMAC is not set
-# CONFIG_CRYPTO_WP512 is not set
-# CONFIG_CRYPTO_XCBC is not set
-# CONFIG_CRYPTO_XTS is not set
-# CONFIG_CRYPTO_ZLIB is not set
-# CONFIG_CS5535_MFGPT is not set
-# CONFIG_CS89x0 is not set
-# CONFIG_CUSE is not set
-# CONFIG_CW1200 is not set
-# CONFIG_CXL_AFU_DRIVER_OPS is not set
-# CONFIG_CXL_BASE is not set
-# CONFIG_CXL_EEH is not set
-# CONFIG_CXL_KERNEL_API is not set
-# CONFIG_CYPRESS_FIRMWARE is not set
-# CONFIG_DAVICOM_PHY is not set
-# CONFIG_DCB is not set
-# CONFIG_DDR is not set
-# CONFIG_DEBUG_ATOMIC_SLEEP is not set
-# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
-# CONFIG_DEBUG_BUGVERBOSE is not set
-# CONFIG_DEBUG_CREDENTIALS is not set
-# CONFIG_DEBUG_DEVRES is not set
-# CONFIG_DEBUG_DRIVER is not set
-# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
-CONFIG_DEBUG_FS=y
-# CONFIG_DEBUG_GPIO is not set
-# CONFIG_DEBUG_HIGHMEM is not set
-# CONFIG_DEBUG_ICEDCC is not set
-# CONFIG_DEBUG_INFO is not set
-# CONFIG_DEBUG_INFO_DWARF4 is not set
-CONFIG_DEBUG_INFO_REDUCED=y
-# CONFIG_DEBUG_INFO_SPLIT is not set
-CONFIG_DEBUG_KERNEL=y
-# CONFIG_DEBUG_KMEMLEAK is not set
-# CONFIG_DEBUG_KOBJECT is not set
-# CONFIG_DEBUG_KOBJECT_RELEASE is not set
-# CONFIG_DEBUG_LIST is not set
-# CONFIG_DEBUG_LL is not set
-# CONFIG_DEBUG_LL_UART_8250 is not set
-# CONFIG_DEBUG_LL_UART_PL01X is not set
-# CONFIG_DEBUG_LOCKDEP is not set
-# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
-# CONFIG_DEBUG_LOCK_ALLOC is not set
-# CONFIG_DEBUG_MEMORY_INIT is not set
-# CONFIG_DEBUG_MUTEXES is not set
-# CONFIG_DEBUG_NOTIFIERS is not set
-# CONFIG_DEBUG_NX_TEST is not set
-# CONFIG_DEBUG_OBJECTS is not set
-# CONFIG_DEBUG_PAGEALLOC is not set
-# CONFIG_DEBUG_PAGE_REF is not set
-# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
-# CONFIG_DEBUG_PER_CPU_MAPS is not set
-# CONFIG_DEBUG_PINCTRL is not set
-# CONFIG_DEBUG_PI_LIST is not set
-# CONFIG_DEBUG_PREEMPT is not set
-# CONFIG_DEBUG_RODATA is not set
-# CONFIG_DEBUG_RODATA_TEST is not set
-# CONFIG_DEBUG_RT_MUTEXES is not set
-# CONFIG_DEBUG_SECTION_MISMATCH is not set
-# CONFIG_DEBUG_SEMIHOSTING is not set
-# CONFIG_DEBUG_SET_MODULE_RONX is not set
-# CONFIG_DEBUG_SG is not set
-# CONFIG_DEBUG_SHIRQ is not set
-# CONFIG_DEBUG_SLAB is not set
-# CONFIG_DEBUG_SPINLOCK is not set
-# CONFIG_DEBUG_STACKOVERFLOW is not set
-# CONFIG_DEBUG_STACK_USAGE is not set
-# CONFIG_DEBUG_STRICT_USER_COPY_CHECKS is not set
-# CONFIG_DEBUG_TEST_DRIVER_REMOVE is not set
-# CONFIG_DEBUG_TIMEKEEPING is not set
-# CONFIG_DEBUG_UART_8250_PALMCHIP is not set
-# CONFIG_DEBUG_UART_BCM63XX is not set
-# CONFIG_DEBUG_VM is not set
-# CONFIG_DEBUG_WQ_FORCE_RR_CPU is not set
-# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
-# CONFIG_DEBUG_WX is not set
-# CONFIG_DEBUG_ZBOOT is not set
-# CONFIG_DECNET is not set
-CONFIG_DEFAULT_CUBIC=y
-CONFIG_DEFAULT_DEADLINE=y
-CONFIG_DEFAULT_HOSTNAME="(none)"
-CONFIG_DEFAULT_IOSCHED="deadline"
-CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
-# CONFIG_DEFAULT_NOOP is not set
-# CONFIG_DEFAULT_RENO is not set
-CONFIG_DEFAULT_SECURITY=""
-CONFIG_DEFAULT_SECURITY_DAC=y
-CONFIG_DEFAULT_TCP_CONG="cubic"
-CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
-# CONFIG_DELL_RBTN is not set
-# CONFIG_DELL_SMO8800 is not set
-# CONFIG_DEPRECATED_PARAM_STRUCT is not set
-# CONFIG_DETECT_HUNG_TASK is not set
-# CONFIG_DEVKMEM is not set
-# CONFIG_DEVMEM is not set
-CONFIG_DEVPORT=y
-# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
-# CONFIG_DEVTMPFS is not set
-# CONFIG_DEVTMPFS_MOUNT is not set
-# CONFIG_DGAP is not set
-# CONFIG_DGNC is not set
-# CONFIG_DHT11 is not set
-# CONFIG_DISCONTIGMEM_MANUAL is not set
-# CONFIG_DISPLAY_CONNECTOR_ANALOG_TV is not set
-# CONFIG_DISPLAY_CONNECTOR_DVI is not set
-# CONFIG_DISPLAY_CONNECTOR_HDMI is not set
-# CONFIG_DISPLAY_ENCODER_TFP410 is not set
-# CONFIG_DISPLAY_ENCODER_TPD12S015 is not set
-# CONFIG_DISPLAY_PANEL_DPI is not set
-# CONFIG_DISPLAY_PANEL_LGPHILIPS_LB035Q02 is not set
-# CONFIG_DISPLAY_PANEL_TPO_TD028TTEC1 is not set
-# CONFIG_DISPLAY_PANEL_TPO_TD043MTEA1 is not set
-# CONFIG_DL2K is not set
-# CONFIG_DLM is not set
-# CONFIG_DM9000 is not set
-# CONFIG_DMADEVICES is not set
-# CONFIG_DMADEVICES_DEBUG is not set
-# CONFIG_DMARD06 is not set
-# CONFIG_DMARD09 is not set
-# CONFIG_DMASCC is not set
-# CONFIG_DMATEST is not set
-# CONFIG_DMA_API_DEBUG is not set
-# CONFIG_DMA_ENGINE is not set
-# CONFIG_DMA_SHARED_BUFFER is not set
-# CONFIG_DM_CACHE is not set
-# CONFIG_DM_DEBUG is not set
-# CONFIG_DM_DELAY is not set
-# CONFIG_DM_ERA is not set
-# CONFIG_DM_FLAKEY is not set
-# CONFIG_DM_LOG_USERSPACE is not set
-# CONFIG_DM_LOG_WRITES is not set
-# CONFIG_DM_MQ_DEFAULT is not set
-# CONFIG_DM_MULTIPATH is not set
-# CONFIG_DM_RAID is not set
-# CONFIG_DM_SWITCH is not set
-# CONFIG_DM_THIN_PROVISIONING is not set
-# CONFIG_DM_UEVENT is not set
-# CONFIG_DM_VERITY is not set
-# CONFIG_DM_ZERO is not set
-# CONFIG_DNET is not set
-# CONFIG_DNOTIFY is not set
-# CONFIG_DNS_RESOLVER is not set
-CONFIG_DOUBLEFAULT=y
-# CONFIG_DP83848_PHY is not set
-# CONFIG_DP83867_PHY is not set
-CONFIG_DQL=y
-# CONFIG_DRAGONRISE_FF is not set
-# CONFIG_DRM is not set
-# CONFIG_DRM_AMDGPU is not set
-# CONFIG_DRM_ANALOGIX_ANX78XX is not set
-# CONFIG_DRM_ARCPGU is not set
-# CONFIG_DRM_ARMADA is not set
-# CONFIG_DRM_AST is not set
-# CONFIG_DRM_BOCHS is not set
-# CONFIG_DRM_CIRRUS_QEMU is not set
-# CONFIG_DRM_DP_AUX_CHARDEV is not set
-# CONFIG_DRM_DUMB_VGA_DAC is not set
-# CONFIG_DRM_ETNAVIV is not set
-# CONFIG_DRM_EXYNOS is not set
-# CONFIG_DRM_FBDEV_EMULATION is not set
-# CONFIG_DRM_FSL_DCU is not set
-# CONFIG_DRM_HDLCD is not set
-# CONFIG_DRM_HISI_KIRIN is not set
-# CONFIG_DRM_I2C_ADV7511 is not set
-# CONFIG_DRM_I2C_CH7006 is not set
-# CONFIG_DRM_I2C_NXP_TDA998X is not set
-# CONFIG_DRM_I2C_SIL164 is not set
-# CONFIG_DRM_LEGACY is not set
-# CONFIG_DRM_LOAD_EDID_FIRMWARE is not set
-# CONFIG_DRM_MALI_DISPLAY is not set
-# CONFIG_DRM_MGAG200 is not set
-# CONFIG_DRM_NOUVEAU is not set
-# CONFIG_DRM_NXP_PTN3460 is not set
-# CONFIG_DRM_OMAP is not set
-# CONFIG_DRM_PANEL_JDI_LT070ME05000 is not set
-# CONFIG_DRM_PANEL_LG_LG4573 is not set
-# CONFIG_DRM_PANEL_PANASONIC_VVX10F034N00 is not set
-# CONFIG_DRM_PANEL_RASPBERRYPI_TOUCHSCREEN is not set
-# CONFIG_DRM_PANEL_SAMSUNG_LD9040 is not set
-# CONFIG_DRM_PANEL_SAMSUNG_S6E8AA0 is not set
-# CONFIG_DRM_PANEL_SHARP_LQ101R1SX01 is not set
-# CONFIG_DRM_PANEL_SHARP_LS043T1LE01 is not set
-# CONFIG_DRM_PARADE_PS8622 is not set
-# CONFIG_DRM_QXL is not set
-# CONFIG_DRM_RADEON is not set
-# CONFIG_DRM_SII902X is not set
-# CONFIG_DRM_STI is not set
-# CONFIG_DRM_TILCDC is not set
-# CONFIG_DRM_TOSHIBA_TC358767 is not set
-# CONFIG_DRM_UDL is not set
-# CONFIG_DRM_VGEM is not set
-# CONFIG_DS1682 is not set
-# CONFIG_DS1803 is not set
-# CONFIG_DST_CACHE is not set
-# CONFIG_DTLK is not set
-# CONFIG_DUMMY is not set
-CONFIG_DUMMY_CONSOLE_COLUMNS=80
-CONFIG_DUMMY_CONSOLE_ROWS=25
-# CONFIG_DUMMY_IRQ is not set
-# CONFIG_DVB_AU8522_V4L is not set
-# CONFIG_DVB_CORE is not set
-# CONFIG_DVB_DUMMY_FE is not set
-# CONFIG_DVB_TUNER_DIB0070 is not set
-# CONFIG_DVB_TUNER_DIB0090 is not set
-# CONFIG_DWMAC_IPQ806X is not set
-# CONFIG_DWMAC_LPC18XX is not set
-# CONFIG_DWMAC_MESON is not set
-# CONFIG_DWMAC_ROCKCHIP is not set
-# CONFIG_DWMAC_SOCFPGA is not set
-# CONFIG_DWMAC_STI is not set
-# CONFIG_DW_DMAC is not set
-# CONFIG_DW_DMAC_PCI is not set
-# CONFIG_DW_WATCHDOG is not set
-# CONFIG_DYNAMIC_DEBUG is not set
-# CONFIG_E100 is not set
-# CONFIG_E1000 is not set
-# CONFIG_E1000E is not set
-# CONFIG_E1000E_HWTS is not set
-# CONFIG_EARLY_PRINTK_8250 is not set
-# CONFIG_ECHO is not set
-# CONFIG_ECRYPT_FS is not set
-# CONFIG_EDAC is not set
-# CONFIG_EEEPC_LAPTOP is not set
-# CONFIG_EEPROM_93CX6 is not set
-# CONFIG_EEPROM_93XX46 is not set
-# CONFIG_EEPROM_AT24 is not set
-# CONFIG_EEPROM_AT25 is not set
-# CONFIG_EEPROM_DIGSY_MTC_CFG is not set
-# CONFIG_EEPROM_LEGACY is not set
-# CONFIG_EEPROM_MAX6875 is not set
-# CONFIG_EFI is not set
-CONFIG_EFI_PARTITION=y
-# CONFIG_EFS_FS is not set
-CONFIG_ELFCORE=y
-# CONFIG_ELF_CORE is not set
-# CONFIG_EMAC_ROCKCHIP is not set
-CONFIG_EMBEDDED=y
-# CONFIG_EM_TIMER_STI is not set
-# CONFIG_ENABLE_MUST_CHECK is not set
-CONFIG_ENABLE_WARN_DEPRECATED=y
-# CONFIG_ENA_ETHERNET is not set
-# CONFIG_ENC28J60 is not set
-# CONFIG_ENCLOSURE_SERVICES is not set
-# CONFIG_ENCRYPTED_KEYS is not set
-# CONFIG_ENCX24J600 is not set
-# CONFIG_ENIC is not set
-# CONFIG_EPAPR_PARAVIRT is not set
-# CONFIG_EPIC100 is not set
-CONFIG_EPOLL=y
-# CONFIG_EQUALIZER is not set
-# CONFIG_ET131X is not set
-CONFIG_ETHERNET=y
-# CONFIG_ETHOC is not set
-CONFIG_EVENTFD=y
-CONFIG_EXPERT=y
-# CONFIG_EXPORTFS is not set
-# CONFIG_EXPORTFS_BLOCK_OPS is not set
-# CONFIG_EXT2_FS is not set
-# CONFIG_EXT2_FS_XATTR is not set
-# CONFIG_EXT3_FS is not set
-# CONFIG_EXT4_DEBUG is not set
-# CONFIG_EXT4_ENCRYPTION is not set
-# CONFIG_EXT4_FS is not set
-# CONFIG_EXT4_FS_POSIX_ACL is not set
-# CONFIG_EXT4_FS_SECURITY is not set
-CONFIG_EXT4_USE_FOR_EXT2=y
-# CONFIG_EXTCON is not set
-# CONFIG_EXTCON_ADC_JACK is not set
-# CONFIG_EXTCON_AXP288 is not set
-# CONFIG_EXTCON_GPIO is not set
-# CONFIG_EXTCON_MAX3355 is not set
-# CONFIG_EXTCON_QCOM_SPMI_MISC is not set
-# CONFIG_EXTCON_RT8973A is not set
-# CONFIG_EXTCON_SM5502 is not set
-# CONFIG_EXTCON_USB_GPIO is not set
-CONFIG_EXTRA_FIRMWARE=""
-CONFIG_EXTRA_TARGETS=""
-# CONFIG_EXYNOS_ADC is not set
-# CONFIG_EXYNOS_VIDEO is not set
-# CONFIG_EZCHIP_NPS_MANAGEMENT_ENET is not set
-# CONFIG_EZX_PCAP is not set
-# CONFIG_F2FS_FAULT_INJECTION is not set
-# CONFIG_F2FS_FS is not set
-# CONFIG_F2FS_FS_ENCRYPTION is not set
-# CONFIG_F2FS_FS_POSIX_ACL is not set
-# CONFIG_F2FS_IO_TRACE is not set
-# CONFIG_FAIR_GROUP_SCHED is not set
-# CONFIG_FANOTIFY is not set
-CONFIG_FAT_DEFAULT_CODEPAGE=437
-CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
-# CONFIG_FAT_DEFAULT_UTF8 is not set
-# CONFIG_FAT_FS is not set
-# CONFIG_FAULT_INJECTION is not set
-# CONFIG_FB is not set
-# CONFIG_FB_3DFX is not set
-# CONFIG_FB_ARC is not set
-# CONFIG_FB_ARK is not set
-# CONFIG_FB_ARMCLCD is not set
-# CONFIG_FB_ASILIANT is not set
-# CONFIG_FB_ATY is not set
-# CONFIG_FB_ATY128 is not set
-# CONFIG_FB_AUO_K190X is not set
-# CONFIG_FB_BACKLIGHT is not set
-# CONFIG_FB_BIG_ENDIAN is not set
-# CONFIG_FB_BOOT_VESA_SUPPORT is not set
-# CONFIG_FB_BOTH_ENDIAN is not set
-# CONFIG_FB_BROADSHEET is not set
-# CONFIG_FB_CARMINE is not set
-# CONFIG_FB_CFB_COPYAREA is not set
-# CONFIG_FB_CFB_FILLRECT is not set
-# CONFIG_FB_CFB_IMAGEBLIT is not set
-# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
-# CONFIG_FB_CIRRUS is not set
-# CONFIG_FB_CYBER2000 is not set
-# CONFIG_FB_DA8XX is not set
-# CONFIG_FB_DDC is not set
-# CONFIG_FB_FOREIGN_ENDIAN is not set
-# CONFIG_FB_GEODE is not set
-# CONFIG_FB_GOLDFISH is not set
-# CONFIG_FB_HGA is not set
-# CONFIG_FB_I740 is not set
-# CONFIG_FB_IBM_GXT4500 is not set
-# CONFIG_FB_IMSTT is not set
-# CONFIG_FB_IMX is not set
-# CONFIG_FB_KYRO is not set
-# CONFIG_FB_LE80578 is not set
-# CONFIG_FB_LITTLE_ENDIAN is not set
-# CONFIG_FB_MACMODES is not set
-# CONFIG_FB_MATROX is not set
-# CONFIG_FB_MB862XX is not set
-# CONFIG_FB_METRONOME is not set
-# CONFIG_FB_MODE_HELPERS is not set
-# CONFIG_FB_MXS is not set
-# CONFIG_FB_N411 is not set
-# CONFIG_FB_NEOMAGIC is not set
-CONFIG_FB_NOTIFY=y
-# CONFIG_FB_NVIDIA is not set
-# CONFIG_FB_OF is not set
-# CONFIG_FB_OMAP2 is not set
-# CONFIG_FB_OPENCORES is not set
-# CONFIG_FB_PM2 is not set
-# CONFIG_FB_PM3 is not set
-# CONFIG_FB_PS3 is not set
-# CONFIG_FB_PXA is not set
-# CONFIG_FB_RADEON is not set
-# CONFIG_FB_RIVA is not set
-# CONFIG_FB_S1D13XXX is not set
-# CONFIG_FB_S3 is not set
-# CONFIG_FB_SAVAGE is not set
-# CONFIG_FB_SIMPLE is not set
-# CONFIG_FB_SIS is not set
-# CONFIG_FB_SM712 is not set
-# CONFIG_FB_SM750 is not set
-# CONFIG_FB_SMSCUFX is not set
-# CONFIG_FB_SSD1307 is not set
-# CONFIG_FB_SVGALIB is not set
-# CONFIG_FB_SYS_COPYAREA is not set
-# CONFIG_FB_SYS_FILLRECT is not set
-# CONFIG_FB_SYS_FOPS is not set
-# CONFIG_FB_SYS_IMAGEBLIT is not set
-# CONFIG_FB_TFT is not set
-# CONFIG_FB_TILEBLITTING is not set
-# CONFIG_FB_TMIO is not set
-# CONFIG_FB_TRIDENT is not set
-# CONFIG_FB_UDL is not set
-# CONFIG_FB_UVESA is not set
-# CONFIG_FB_VGA16 is not set
-# CONFIG_FB_VIA is not set
-# CONFIG_FB_VIRTUAL is not set
-# CONFIG_FB_VOODOO1 is not set
-# CONFIG_FB_VT8623 is not set
-# CONFIG_FB_XGI is not set
-# CONFIG_FCOE is not set
-# CONFIG_FCOE_FNIC is not set
-# CONFIG_FDDI is not set
-# CONFIG_FEALNX is not set
-# CONFIG_FENCE_TRACE is not set
-# CONFIG_FHANDLE is not set
-CONFIG_FIB_RULES=y
-CONFIG_FILE_LOCKING=y
-# CONFIG_FIREWIRE is not set
-# CONFIG_FIREWIRE_NOSY is not set
-# CONFIG_FIREWIRE_SERIAL is not set
-# CONFIG_FIRMWARE_EDID is not set
-# CONFIG_FIRMWARE_IN_KERNEL is not set
-# CONFIG_FIRMWARE_MEMMAP is not set
-# CONFIG_FIXED_PHY is not set
-CONFIG_FLATMEM=y
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_FLAT_NODE_MEM_MAP=y
-# CONFIG_FM10K is not set
-# CONFIG_FMC is not set
-# CONFIG_FORCEDETH is not set
-CONFIG_FORCE_MAX_ZONEORDER=11
-# CONFIG_FPGA is not set
-# CONFIG_FRAMEBUFFER_CONSOLE is not set
-# CONFIG_FRAME_POINTER is not set
-CONFIG_FRAME_WARN=1024
-# CONFIG_FREEZER is not set
-# CONFIG_FRONTSWAP is not set
-# CONFIG_FSCACHE is not set
-# CONFIG_FSL_EDMA is not set
-# CONFIG_FSL_MC_BUS is not set
-# CONFIG_FSL_PQ_MDIO is not set
-# CONFIG_FSL_XGMAC_MDIO is not set
-CONFIG_FSNOTIFY=y
-# CONFIG_FS_DAX is not set
-# CONFIG_FS_ENCRYPTION is not set
-# CONFIG_FS_POSIX_ACL is not set
-# CONFIG_FTGMAC100 is not set
-# CONFIG_FTL is not set
-# CONFIG_FTMAC100 is not set
-# CONFIG_FTRACE is not set
-# CONFIG_FTRACE_STARTUP_TEST is not set
-# CONFIG_FTR_FIXUP_SELFTEST is not set
-# CONFIG_FUJITSU_ES is not set
-# CONFIG_FUJITSU_LAPTOP is not set
-# CONFIG_FUJITSU_TABLET is not set
-# CONFIG_FUNCTION_TRACER is not set
-# CONFIG_FUSE_FS is not set
-# CONFIG_FUSION is not set
-# CONFIG_FUSION_FC is not set
-# CONFIG_FUSION_SAS is not set
-# CONFIG_FUSION_SPI is not set
-CONFIG_FUTEX=y
-# CONFIG_FW_CFG_SYSFS is not set
-CONFIG_FW_LOADER=y
-CONFIG_FW_LOADER_USER_HELPER=y
-CONFIG_FW_LOADER_USER_HELPER_FALLBACK=y
-CONFIG_GACT_PROB=y
-# CONFIG_GADGET_UAC1 is not set
-# CONFIG_GAMEPORT is not set
-# CONFIG_GATEWORKS_GW16083 is not set
-# CONFIG_GCC_PLUGINS is not set
-# CONFIG_GCOV is not set
-# CONFIG_GCOV_KERNEL is not set
-# CONFIG_GDB_SCRIPTS is not set
-# CONFIG_GENERIC_ADC_BATTERY is not set
-# CONFIG_GENERIC_ADC_THERMAL is not set
-CONFIG_GENERIC_CALIBRATE_DELAY=y
-# CONFIG_GENERIC_CPU_DEVICES is not set
-CONFIG_GENERIC_HWEIGHT=y
-CONFIG_GENERIC_IRQ_PROBE=y
-CONFIG_GENERIC_NET_UTILS=y
-# CONFIG_GENERIC_PHY is not set
-# CONFIG_GENEVE is not set
-# CONFIG_GENWQE is not set
-# CONFIG_GFS2_FS is not set
-# CONFIG_GIGASET_CAPI is not set
-# CONFIG_GIGASET_DEBUG is not set
-# CONFIG_GIGASET_DUMMYLL is not set
-# CONFIG_GLOB_SELFTEST is not set
-# CONFIG_GOLDFISH is not set
-# CONFIG_GP2AP020A00F is not set
-# CONFIG_GPIOLIB is not set
-# CONFIG_GPIO_74X164 is not set
-# CONFIG_GPIO_74XX_MMIO is not set
-# CONFIG_GPIO_ADNP is not set
-# CONFIG_GPIO_ADP5588 is not set
-# CONFIG_GPIO_ALTERA is not set
-# CONFIG_GPIO_AMD8111 is not set
-# CONFIG_GPIO_AMDPT is not set
-# CONFIG_GPIO_BCM_KONA is not set
-# CONFIG_GPIO_BT8XX is not set
-# CONFIG_GPIO_CS5535 is not set
-# CONFIG_GPIO_DWAPB is not set
-# CONFIG_GPIO_EM is not set
-# CONFIG_GPIO_F7188X is not set
-# CONFIG_GPIO_GENERIC_PLATFORM is not set
-# CONFIG_GPIO_GPIO_MM is not set
-# CONFIG_GPIO_GRGPIO is not set
-# CONFIG_GPIO_ICH is not set
-# CONFIG_GPIO_IT87 is not set
-# CONFIG_GPIO_LYNXPOINT is not set
-# CONFIG_GPIO_MAX7300 is not set
-# CONFIG_GPIO_MAX7301 is not set
-# CONFIG_GPIO_MAX732X is not set
-# CONFIG_GPIO_MC33880 is not set
-# CONFIG_GPIO_MCP23S08 is not set
-# CONFIG_GPIO_ML_IOH is not set
-# CONFIG_GPIO_MOCKUP is not set
-# CONFIG_GPIO_MPC8XXX is not set
-# CONFIG_GPIO_PCA953X is not set
-# CONFIG_GPIO_PCF857X is not set
-# CONFIG_GPIO_PCH is not set
-# CONFIG_GPIO_PISOSR is not set
-# CONFIG_GPIO_PL061 is not set
-# CONFIG_GPIO_RCAR is not set
-# CONFIG_GPIO_RDC321X is not set
-# CONFIG_GPIO_SCH is not set
-# CONFIG_GPIO_SCH311X is not set
-# CONFIG_GPIO_SX150X is not set
-# CONFIG_GPIO_SYSCON is not set
-# CONFIG_GPIO_SYSFS is not set
-# CONFIG_GPIO_TPIC2810 is not set
-# CONFIG_GPIO_TS4900 is not set
-# CONFIG_GPIO_TS5500 is not set
-# CONFIG_GPIO_VX855 is not set
-# CONFIG_GPIO_WATCHDOG is not set
-# CONFIG_GPIO_WS16C48 is not set
-# CONFIG_GPIO_XGENE is not set
-# CONFIG_GPIO_XILINX is not set
-# CONFIG_GPIO_ZEVIO is not set
-# CONFIG_GPIO_ZX is not set
-# CONFIG_GREENASIA_FF is not set
-# CONFIG_GREYBUS is not set
-# CONFIG_GS_FPGABOOT is not set
-# CONFIG_GTP is not set
-# CONFIG_HAMACHI is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_HAPPYMEAL is not set
-# CONFIG_HARDENED_USERCOPY is not set
-# CONFIG_HARDLOCKUP_DETECTOR is not set
-# CONFIG_HAVE_AOUT is not set
-CONFIG_HAVE_ARCH_HARDENED_USERCOPY=y
-# CONFIG_HAVE_ARCH_HASH is not set
-CONFIG_HAVE_ARCH_MMAP_RND_BITS=y
-# CONFIG_HAVE_ARCH_VMAP_STACK is not set
-CONFIG_HAVE_ARCH_WITHIN_STACK_FRAMES=y
-# CONFIG_HAVE_ARM_ARCH_TIMER is not set
-CONFIG_HAVE_EXIT_THREAD=y
-CONFIG_HAVE_GCC_PLUGINS=y
-CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=y
-CONFIG_HAVE_KERNEL_BZIP2=y
-CONFIG_HAVE_KERNEL_CAT=y
-CONFIG_HAVE_KERNEL_GZIP=y
-CONFIG_HAVE_KERNEL_LZ4=y
-CONFIG_HAVE_KERNEL_LZMA=y
-CONFIG_HAVE_KERNEL_LZO=y
-CONFIG_HAVE_KERNEL_XZ=y
-CONFIG_HAVE_KPROBES=y
-CONFIG_HAVE_KRETPROBES=y
-CONFIG_HAVE_NMI=y
-# CONFIG_HCALL_STATS is not set
-# CONFIG_HDC100X is not set
-# CONFIG_HDLC is not set
-# CONFIG_HDLC_CISCO is not set
-# CONFIG_HDLC_FR is not set
-# CONFIG_HDLC_PPP is not set
-# CONFIG_HDLC_RAW is not set
-# CONFIG_HDLC_RAW_ETH is not set
-# CONFIG_HDQ_MASTER_OMAP is not set
-# CONFIG_HEADERS_CHECK is not set
-# CONFIG_HERMES is not set
-# CONFIG_HFSPLUS_FS is not set
-# CONFIG_HFSPLUS_FS_POSIX_ACL is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_HFS_FS_POSIX_ACL is not set
-# CONFIG_HI8435 is not set
-# CONFIG_HIBERNATION is not set
-# CONFIG_HID is not set
-# CONFIG_HIDRAW is not set
-# CONFIG_HID_A4TECH is not set
-# CONFIG_HID_ACRUX is not set
-# CONFIG_HID_ACRUX_FF is not set
-# CONFIG_HID_ALPS is not set
-# CONFIG_HID_APPLE is not set
-# CONFIG_HID_APPLEIR is not set
-# CONFIG_HID_AUREAL is not set
-# CONFIG_HID_BATTERY_STRENGTH is not set
-# CONFIG_HID_BELKIN is not set
-# CONFIG_HID_BETOP_FF is not set
-# CONFIG_HID_CHERRY is not set
-# CONFIG_HID_CHICONY is not set
-# CONFIG_HID_CMEDIA is not set
-# CONFIG_HID_CORSAIR is not set
-# CONFIG_HID_CP2112 is not set
-# CONFIG_HID_CYPRESS is not set
-# CONFIG_HID_DRAGONRISE is not set
-# CONFIG_HID_ELECOM is not set
-# CONFIG_HID_ELO is not set
-# CONFIG_HID_EMS_FF is not set
-# CONFIG_HID_EZKEY is not set
-# CONFIG_HID_GEMBIRD is not set
-# CONFIG_HID_GENERIC is not set
-# CONFIG_HID_GFRM is not set
-# CONFIG_HID_GREENASIA is not set
-# CONFIG_HID_GT683R is not set
-# CONFIG_HID_GYRATION is not set
-# CONFIG_HID_HOLTEK is not set
-# CONFIG_HID_ICADE is not set
-# CONFIG_HID_KENSINGTON is not set
-# CONFIG_HID_KEYTOUCH is not set
-# CONFIG_HID_KYE is not set
-# CONFIG_HID_LCPOWER is not set
-# CONFIG_HID_LED is not set
-# CONFIG_HID_LENOVO is not set
-# CONFIG_HID_LOGITECH is not set
-# CONFIG_HID_LOGITECH_DJ is not set
-# CONFIG_HID_LOGITECH_HIDPP is not set
-# CONFIG_HID_MAGICMOUSE is not set
-# CONFIG_HID_MICROSOFT is not set
-# CONFIG_HID_MONTEREY is not set
-# CONFIG_HID_MULTITOUCH is not set
-# CONFIG_HID_NTRIG is not set
-# CONFIG_HID_ORTEK is not set
-# CONFIG_HID_PANTHERLORD is not set
-# CONFIG_HID_PENMOUNT is not set
-# CONFIG_HID_PETALYNX is not set
-# CONFIG_HID_PICOLCD is not set
-# CONFIG_HID_PID is not set
-# CONFIG_HID_PLANTRONICS is not set
-# CONFIG_HID_PRIMAX is not set
-# CONFIG_HID_PRODIKEYS is not set
-# CONFIG_HID_RMI is not set
-# CONFIG_HID_ROCCAT is not set
-# CONFIG_HID_SAITEK is not set
-# CONFIG_HID_SAMSUNG is not set
-# CONFIG_HID_SENSOR_HUB is not set
-# CONFIG_HID_SMARTJOYPLUS is not set
-# CONFIG_HID_SONY is not set
-# CONFIG_HID_SPEEDLINK is not set
-# CONFIG_HID_STEELSERIES is not set
-# CONFIG_HID_SUNPLUS is not set
-# CONFIG_HID_THINGM is not set
-# CONFIG_HID_THRUSTMASTER is not set
-# CONFIG_HID_TIVO is not set
-# CONFIG_HID_TOPSEED is not set
-# CONFIG_HID_TWINHAN is not set
-# CONFIG_HID_UCLOGIC is not set
-# CONFIG_HID_WACOM is not set
-# CONFIG_HID_WALTOP is not set
-# CONFIG_HID_WIIMOTE is not set
-# CONFIG_HID_XINMO is not set
-# CONFIG_HID_ZEROPLUS is not set
-# CONFIG_HID_ZYDACRON is not set
-# CONFIG_HIGHMEM is not set
-CONFIG_HIGH_RES_TIMERS=y
-# CONFIG_HIP04_ETH is not set
-# CONFIG_HIPPI is not set
-# CONFIG_HISI_FEMAC is not set
-# CONFIG_HIX5HD2_GMAC is not set
-# CONFIG_HMC6352 is not set
-# CONFIG_HNS is not set
-# CONFIG_HNS_DSAF is not set
-# CONFIG_HNS_ENET is not set
-# CONFIG_HOSTAP is not set
-# CONFIG_HOSTAP_CS is not set
-# CONFIG_HOSTAP_PCI is not set
-# CONFIG_HOSTAP_PLX is not set
-# CONFIG_HOTPLUG_CPU is not set
-# CONFIG_HOTPLUG_PCI is not set
-# CONFIG_HP03 is not set
-# CONFIG_HP100 is not set
-# CONFIG_HP206C is not set
-CONFIG_HPET_MMAP_DEFAULT=y
-# CONFIG_HPFS_FS is not set
-# CONFIG_HP_ILO is not set
-# CONFIG_HP_WIRELESS is not set
-# CONFIG_HSI is not set
-# CONFIG_HSR is not set
-# CONFIG_HTC_EGPIO is not set
-# CONFIG_HTC_I2CPLD is not set
-# CONFIG_HTC_PASIC3 is not set
-# CONFIG_HTU21 is not set
-# CONFIG_HUGETLB_PAGE is not set
-# CONFIG_HVC_DCC is not set
-# CONFIG_HVC_UDBG is not set
-# CONFIG_HWLAT_TRACER is not set
-# CONFIG_HWMON is not set
-# CONFIG_HWMON_DEBUG_CHIP is not set
-# CONFIG_HWMON_VID is not set
-# CONFIG_HWSPINLOCK_OMAP is not set
-CONFIG_HW_PERF_EVENTS=y
-# CONFIG_HW_RANDOM is not set
-# CONFIG_HW_RANDOM_AMD is not set
-# CONFIG_HW_RANDOM_ATMEL is not set
-# CONFIG_HW_RANDOM_EXYNOS is not set
-# CONFIG_HW_RANDOM_GEODE is not set
-# CONFIG_HW_RANDOM_INTEL is not set
-# CONFIG_HW_RANDOM_IPROC_RNG200 is not set
-# CONFIG_HW_RANDOM_OMAP3_ROM is not set
-# CONFIG_HW_RANDOM_PPC4XX is not set
-# CONFIG_HW_RANDOM_TIMERIOMEM is not set
-# CONFIG_HW_RANDOM_TPM is not set
-# CONFIG_HW_RANDOM_VIA is not set
-# CONFIG_HW_RANDOM_VIRTIO is not set
-# CONFIG_HYPERV is not set
-# CONFIG_HYSDN is not set
-CONFIG_HZ=100
-CONFIG_HZ_100=y
-# CONFIG_HZ_1000 is not set
-# CONFIG_HZ_1024 is not set
-# CONFIG_HZ_128 is not set
-# CONFIG_HZ_200 is not set
-# CONFIG_HZ_24 is not set
-# CONFIG_HZ_250 is not set
-# CONFIG_HZ_256 is not set
-# CONFIG_HZ_300 is not set
-# CONFIG_HZ_48 is not set
-# CONFIG_HZ_500 is not set
-# CONFIG_HZ_PERIODIC is not set
-# CONFIG_I2C is not set
-# CONFIG_I2C_ALGOBIT is not set
-# CONFIG_I2C_ALGOPCA is not set
-# CONFIG_I2C_ALGOPCF is not set
-# CONFIG_I2C_ALI1535 is not set
-# CONFIG_I2C_ALI1563 is not set
-# CONFIG_I2C_ALI15X3 is not set
-# CONFIG_I2C_AMD756 is not set
-# CONFIG_I2C_AMD8111 is not set
-# CONFIG_I2C_ARB_GPIO_CHALLENGE is not set
-# CONFIG_I2C_AU1550 is not set
-# CONFIG_I2C_BCM2835 is not set
-# CONFIG_I2C_BCM_IPROC is not set
-# CONFIG_I2C_CADENCE is not set
-# CONFIG_I2C_CBUS_GPIO is not set
-# CONFIG_I2C_CHARDEV is not set
-# CONFIG_I2C_COMPAT is not set
-# CONFIG_I2C_DEBUG_ALGO is not set
-# CONFIG_I2C_DEBUG_BUS is not set
-# CONFIG_I2C_DEBUG_CORE is not set
-# CONFIG_I2C_DEMUX_PINCTRL is not set
-# CONFIG_I2C_DESIGNWARE_PCI is not set
-# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
-# CONFIG_I2C_DIOLAN_U2C is not set
-# CONFIG_I2C_EG20T is not set
-# CONFIG_I2C_ELEKTOR is not set
-# CONFIG_I2C_EMEV2 is not set
-# CONFIG_I2C_GPIO is not set
-# CONFIG_I2C_HELPER_AUTO is not set
-# CONFIG_I2C_HID is not set
-# CONFIG_I2C_I801 is not set
-# CONFIG_I2C_IBM_IIC is not set
-# CONFIG_I2C_IMG is not set
-# CONFIG_I2C_ISCH is not set
-# CONFIG_I2C_ISMT is not set
-# CONFIG_I2C_MPC is not set
-# CONFIG_I2C_MUX is not set
-# CONFIG_I2C_MUX_GPIO is not set
-# CONFIG_I2C_MUX_PCA9541 is not set
-# CONFIG_I2C_MUX_PCA954x is not set
-# CONFIG_I2C_MUX_PINCTRL is not set
-# CONFIG_I2C_MUX_REG is not set
-# CONFIG_I2C_MV64XXX is not set
-# CONFIG_I2C_NFORCE2 is not set
-# CONFIG_I2C_NOMADIK is not set
-# CONFIG_I2C_OCORES is not set
-# CONFIG_I2C_OCTEON is not set
-# CONFIG_I2C_PARPORT is not set
-# CONFIG_I2C_PARPORT_LIGHT is not set
-# CONFIG_I2C_PCA_ISA is not set
-# CONFIG_I2C_PCA_PLATFORM is not set
-# CONFIG_I2C_PIIX4 is not set
-# CONFIG_I2C_PXA_PCI is not set
-# CONFIG_I2C_RCAR is not set
-# CONFIG_I2C_RK3X is not set
-# CONFIG_I2C_ROBOTFUZZ_OSIF is not set
-# CONFIG_I2C_SCMI is not set
-# CONFIG_I2C_SH_MOBILE is not set
-# CONFIG_I2C_SIMTEC is not set
-# CONFIG_I2C_SIS5595 is not set
-# CONFIG_I2C_SIS630 is not set
-# CONFIG_I2C_SIS96X is not set
-# CONFIG_I2C_SLAVE is not set
-# CONFIG_I2C_SMBUS is not set
-# CONFIG_I2C_STUB is not set
-# CONFIG_I2C_TAOS_EVM is not set
-# CONFIG_I2C_THUNDERX is not set
-# CONFIG_I2C_TINY_USB is not set
-# CONFIG_I2C_VERSATILE is not set
-# CONFIG_I2C_VIA is not set
-# CONFIG_I2C_VIAPRO is not set
-# CONFIG_I2C_XILINX is not set
-# CONFIG_I40E is not set
-# CONFIG_I40EVF is not set
-# CONFIG_I6300ESB_WDT is not set
-# CONFIG_I82092 is not set
-# CONFIG_I82365 is not set
-# CONFIG_IAQCORE is not set
-# CONFIG_IBM_ASM is not set
-# CONFIG_IBM_EMAC_DEBUG is not set
-# CONFIG_IBM_EMAC_EMAC4 is not set
-# CONFIG_IBM_EMAC_MAL_CLR_ICINTSTAT is not set
-# CONFIG_IBM_EMAC_MAL_COMMON_ERR is not set
-# CONFIG_IBM_EMAC_NO_FLOW_CTRL is not set
-# CONFIG_IBM_EMAC_RGMII is not set
-# CONFIG_IBM_EMAC_TAH is not set
-# CONFIG_IBM_EMAC_ZMII is not set
-# CONFIG_ICPLUS_PHY is not set
-# CONFIG_ICS932S401 is not set
-# CONFIG_IDE is not set
-# CONFIG_IDEAPAD_LAPTOP is not set
-# CONFIG_IDE_GD is not set
-# CONFIG_IDE_PROC_FS is not set
-# CONFIG_IDE_TASK_IOCTL is not set
-# CONFIG_IDLE_PAGE_TRACKING is not set
-# CONFIG_IEEE802154 is not set
-# CONFIG_IEEE802154_ADF7242 is not set
-# CONFIG_IEEE802154_ATUSB is not set
-# CONFIG_IFB is not set
-# CONFIG_IGB is not set
-# CONFIG_IGBVF is not set
-# CONFIG_IIO is not set
-# CONFIG_IIO_BUFFER_CB is not set
-# CONFIG_IIO_CONFIGFS is not set
-CONFIG_IIO_CONSUMERS_PER_TRIGGER=2
-# CONFIG_IIO_INTERRUPT_TRIGGER is not set
-# CONFIG_IIO_PERIODIC_RTC_TRIGGER is not set
-# CONFIG_IIO_SIMPLE_DUMMY is not set
-# CONFIG_IIO_SSP_SENSORHUB is not set
-# CONFIG_IIO_ST_ACCEL_3AXIS is not set
-# CONFIG_IIO_ST_GYRO_3AXIS is not set
-# CONFIG_IIO_ST_MAGN_3AXIS is not set
-# CONFIG_IIO_ST_PRESS is not set
-# CONFIG_IIO_SW_DEVICE is not set
-# CONFIG_IIO_SW_TRIGGER is not set
-# CONFIG_IIO_SYSFS_TRIGGER is not set
-# CONFIG_IKCONFIG is not set
-# CONFIG_IKCONFIG_PROC is not set
-# CONFIG_IMAGE_CMDLINE_HACK is not set
-# CONFIG_IMGPDC_WDT is not set
-# CONFIG_IMG_MDC_DMA is not set
-# CONFIG_IMX7D_ADC is not set
-# CONFIG_IMX_IPUV3_CORE is not set
-# CONFIG_IMX_THERMAL is not set
-# CONFIG_INA2XX_ADC is not set
-CONFIG_INET=y
-# CONFIG_INET6_AH is not set
-# CONFIG_INET6_ESP is not set
-# CONFIG_INET6_IPCOMP is not set
-# CONFIG_INET6_TUNNEL is not set
-# CONFIG_INET6_XFRM_MODE_BEET is not set
-# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
-# CONFIG_INET6_XFRM_MODE_TRANSPORT is not set
-# CONFIG_INET6_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET6_XFRM_TUNNEL is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_DIAG is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_LRO is not set
-# CONFIG_INET_TCP_DIAG is not set
-# CONFIG_INET_TUNNEL is not set
-# CONFIG_INET_UDP_DIAG is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_TUNNEL is not set
-# CONFIG_INFINIBAND is not set
-# CONFIG_INFTL is not set
-CONFIG_INIT_ENV_ARG_LIMIT=32
-# CONFIG_INLINE_READ_LOCK is not set
-# CONFIG_INLINE_READ_LOCK_BH is not set
-# CONFIG_INLINE_READ_LOCK_IRQ is not set
-# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
-# CONFIG_INLINE_READ_TRYLOCK is not set
-CONFIG_INLINE_READ_UNLOCK=y
-# CONFIG_INLINE_READ_UNLOCK_BH is not set
-CONFIG_INLINE_READ_UNLOCK_IRQ=y
-# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
-# CONFIG_INLINE_SPIN_LOCK is not set
-# CONFIG_INLINE_SPIN_LOCK_BH is not set
-# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
-# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
-# CONFIG_INLINE_SPIN_TRYLOCK is not set
-# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
-# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
-CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
-# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
-# CONFIG_INLINE_WRITE_LOCK is not set
-# CONFIG_INLINE_WRITE_LOCK_BH is not set
-# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
-# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
-# CONFIG_INLINE_WRITE_TRYLOCK is not set
-CONFIG_INLINE_WRITE_UNLOCK=y
-# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
-CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
-# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
-CONFIG_INOTIFY_USER=y
-# CONFIG_INPUT is not set
-# CONFIG_INPUT_AD714X is not set
-# CONFIG_INPUT_ADXL34X is not set
-# CONFIG_INPUT_APANEL is not set
-# CONFIG_INPUT_ATI_REMOTE2 is not set
-# CONFIG_INPUT_ATLAS_BTNS is not set
-# CONFIG_INPUT_ATMEL_CAPTOUCH is not set
-# CONFIG_INPUT_AXP20X_PEK is not set
-# CONFIG_INPUT_BMA150 is not set
-# CONFIG_INPUT_CM109 is not set
-# CONFIG_INPUT_CMA3000 is not set
-# CONFIG_INPUT_DRV260X_HAPTICS is not set
-# CONFIG_INPUT_DRV2665_HAPTICS is not set
-# CONFIG_INPUT_DRV2667_HAPTICS is not set
-# CONFIG_INPUT_E3X0_BUTTON is not set
-# CONFIG_INPUT_EVBUG is not set
-# CONFIG_INPUT_EVDEV is not set
-# CONFIG_INPUT_FF_MEMLESS is not set
-# CONFIG_INPUT_GP2A is not set
-# CONFIG_INPUT_GPIO_BEEPER is not set
-# CONFIG_INPUT_GPIO_DECODER is not set
-# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
-# CONFIG_INPUT_GPIO_TILT_POLLED is not set
-# CONFIG_INPUT_IDEAPAD_SLIDEBAR is not set
-# CONFIG_INPUT_IMS_PCU is not set
-# CONFIG_INPUT_JOYDEV is not set
-# CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_KEYSPAN_REMOTE is not set
-# CONFIG_INPUT_KXTJ9 is not set
-# CONFIG_INPUT_LEDS is not set
-# CONFIG_INPUT_MATRIXKMAP is not set
-# CONFIG_INPUT_MAX8997_HAPTIC is not set
-CONFIG_INPUT_MISC=y
-# CONFIG_INPUT_MMA8450 is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_MPU3050 is not set
-# CONFIG_INPUT_PALMAS_PWRBUTTON is not set
-# CONFIG_INPUT_PCF8574 is not set
-# CONFIG_INPUT_PCSPKR is not set
-# CONFIG_INPUT_POLLDEV is not set
-# CONFIG_INPUT_POWERMATE is not set
-# CONFIG_INPUT_PWM_BEEPER is not set
-# CONFIG_INPUT_REGULATOR_HAPTIC is not set
-# CONFIG_INPUT_SOC_BUTTON_ARRAY is not set
-# CONFIG_INPUT_SPARSEKMAP is not set
-# CONFIG_INPUT_TABLET is not set
-# CONFIG_INPUT_TOUCHSCREEN is not set
-# CONFIG_INPUT_TPS65218_PWRBUTTON is not set
-# CONFIG_INPUT_TWL4030_PWRBUTTON is not set
-# CONFIG_INPUT_TWL4030_VIBRA is not set
-# CONFIG_INPUT_TWL6040_VIBRA is not set
-# CONFIG_INPUT_UINPUT is not set
-# CONFIG_INPUT_WISTRON_BTNS is not set
-# CONFIG_INPUT_YEALINK is not set
-# CONFIG_INT340X_THERMAL is not set
-# CONFIG_INTEL_HID_EVENT is not set
-# CONFIG_INTEL_IDLE is not set
-# CONFIG_INTEL_IDMA64 is not set
-# CONFIG_INTEL_IOATDMA is not set
-# CONFIG_INTEL_ISH_HID is not set
-# CONFIG_INTEL_MEI is not set
-# CONFIG_INTEL_MEI_ME is not set
-# CONFIG_INTEL_MEI_TXE is not set
-# CONFIG_INTEL_MIC_CARD is not set
-# CONFIG_INTEL_MIC_HOST is not set
-# CONFIG_INTEL_MID_PTI is not set
-# CONFIG_INTEL_OAKTRAIL is not set
-# CONFIG_INTEL_PMC_CORE is not set
-# CONFIG_INTEL_PUNIT_IPC is not set
-# CONFIG_INTEL_RST is not set
-# CONFIG_INTEL_SMARTCONNECT is not set
-# CONFIG_INTEL_SOC_PMIC is not set
-# CONFIG_INTEL_TH is not set
-# CONFIG_INTEL_VBTN is not set
-# CONFIG_INTEL_XWAY_PHY is not set
-# CONFIG_INTERVAL_TREE_TEST is not set
-# CONFIG_INV_MPU6050_I2C is not set
-# CONFIG_INV_MPU6050_IIO is not set
-# CONFIG_INV_MPU6050_SPI is not set
-# CONFIG_IOMMU_SUPPORT is not set
-# CONFIG_IOSCHED_CFQ is not set
-CONFIG_IOSCHED_DEADLINE=y
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IO_STRICT_DEVMEM=y
-# CONFIG_IP17XX_PHY is not set
-# CONFIG_IP6_NF_FILTER is not set
-# CONFIG_IP6_NF_IPTABLES is not set
-# CONFIG_IP6_NF_MANGLE is not set
-# CONFIG_IP6_NF_MATCH_AH is not set
-# CONFIG_IP6_NF_MATCH_EUI64 is not set
-# CONFIG_IP6_NF_MATCH_FRAG is not set
-# CONFIG_IP6_NF_MATCH_HL is not set
-# CONFIG_IP6_NF_MATCH_IPV6HEADER is not set
-# CONFIG_IP6_NF_MATCH_MH is not set
-# CONFIG_IP6_NF_MATCH_OPTS is not set
-# CONFIG_IP6_NF_MATCH_RPFILTER is not set
-# CONFIG_IP6_NF_MATCH_RT is not set
-# CONFIG_IP6_NF_NAT is not set
-# CONFIG_IP6_NF_RAW is not set
-# CONFIG_IP6_NF_SECURITY is not set
-# CONFIG_IP6_NF_TARGET_HL is not set
-# CONFIG_IP6_NF_TARGET_REJECT is not set
-# CONFIG_IP6_NF_TARGET_SYNPROXY is not set
-# CONFIG_IPACK_BUS is not set
-# CONFIG_IPC_NS is not set
-# CONFIG_IPMI_HANDLER is not set
-# CONFIG_IPV6 is not set
-# CONFIG_IPV6_FOU is not set
-# CONFIG_IPV6_FOU_TUNNEL is not set
-# CONFIG_IPV6_ILA is not set
-# CONFIG_IPV6_MIP6 is not set
-# CONFIG_IPV6_MROUTE is not set
-# CONFIG_IPV6_MROUTE_MULTIPLE_TABLES is not set
-# CONFIG_IPV6_MULTIPLE_TABLES is not set
-CONFIG_IPV6_NDISC_NODETYPE=y
-# CONFIG_IPV6_OPTIMISTIC_DAD is not set
-# CONFIG_IPV6_ROUTER_PREF is not set
-# CONFIG_IPV6_ROUTE_INFO is not set
-# CONFIG_IPV6_SIT is not set
-# CONFIG_IPV6_SIT_6RD is not set
-# CONFIG_IPV6_TUNNEL is not set
-# CONFIG_IPV6_VTI is not set
-# CONFIG_IPVLAN is not set
-# CONFIG_IPW2100 is not set
-# CONFIG_IPW2100_DEBUG is not set
-CONFIG_IPW2100_MONITOR=y
-# CONFIG_IPW2200 is not set
-# CONFIG_IPW2200_DEBUG is not set
-CONFIG_IPW2200_MONITOR=y
-# CONFIG_IPW2200_PROMISCUOUS is not set
-# CONFIG_IPW2200_QOS is not set
-# CONFIG_IPW2200_RADIOTAP is not set
-# CONFIG_IPWIRELESS is not set
-# CONFIG_IPX is not set
-CONFIG_IP_ADVANCED_ROUTER=y
-# CONFIG_IP_DCCP is not set
-# CONFIG_IP_FIB_TRIE_STATS is not set
-# CONFIG_IP_MROUTE is not set
-CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
-CONFIG_IP_MULTICAST=y
-CONFIG_IP_MULTIPLE_TABLES=y
-# CONFIG_IP_NF_ARPFILTER is not set
-# CONFIG_IP_NF_ARPTABLES is not set
-# CONFIG_IP_NF_ARP_MANGLE is not set
-# CONFIG_IP_NF_FILTER is not set
-# CONFIG_IP_NF_IPTABLES is not set
-# CONFIG_IP_NF_MANGLE is not set
-# CONFIG_IP_NF_MATCH_AH is not set
-# CONFIG_IP_NF_MATCH_ECN is not set
-# CONFIG_IP_NF_MATCH_RPFILTER is not set
-# CONFIG_IP_NF_MATCH_TTL is not set
-# CONFIG_IP_NF_RAW is not set
-# CONFIG_IP_NF_SECURITY is not set
-# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
-# CONFIG_IP_NF_TARGET_ECN is not set
-# CONFIG_IP_NF_TARGET_MASQUERADE is not set
-# CONFIG_IP_NF_TARGET_NETMAP is not set
-# CONFIG_IP_NF_TARGET_REDIRECT is not set
-# CONFIG_IP_NF_TARGET_REJECT is not set
-# CONFIG_IP_NF_TARGET_SYNPROXY is not set
-# CONFIG_IP_NF_TARGET_TTL is not set
-# CONFIG_IP_PIMSM_V1 is not set
-# CONFIG_IP_PIMSM_V2 is not set
-# CONFIG_IP_PNP is not set
-CONFIG_IP_ROUTE_MULTIPATH=y
-CONFIG_IP_ROUTE_VERBOSE=y
-# CONFIG_IP_SCTP is not set
-# CONFIG_IP_SET is not set
-# CONFIG_IP_VS is not set
-# CONFIG_IRDA is not set
-# CONFIG_IRQSOFF_TRACER is not set
-# CONFIG_IRQ_ALL_CPUS is not set
-# CONFIG_IRQ_DOMAIN_DEBUG is not set
-# CONFIG_IRQ_POLL is not set
-# CONFIG_IRQ_TIME_ACCOUNTING is not set
-# CONFIG_IR_GPIO_CIR is not set
-# CONFIG_IR_HIX5HD2 is not set
-# CONFIG_IR_IGORPLUGUSB is not set
-# CONFIG_IR_IGUANA is not set
-# CONFIG_IR_IMG is not set
-# CONFIG_IR_IMON is not set
-# CONFIG_IR_JVC_DECODER is not set
-# CONFIG_IR_LIRC_CODEC is not set
-# CONFIG_IR_MCEUSB is not set
-# CONFIG_IR_NEC_DECODER is not set
-# CONFIG_IR_RC5_DECODER is not set
-# CONFIG_IR_RC6_DECODER is not set
-# CONFIG_IR_REDRAT3 is not set
-# CONFIG_IR_SONY_DECODER is not set
-# CONFIG_IR_STREAMZAP is not set
-# CONFIG_IR_TTUSBIR is not set
-# CONFIG_ISA_BUS is not set
-# CONFIG_ISA_BUS_API is not set
-# CONFIG_ISCSI_BOOT_SYSFS is not set
-# CONFIG_ISCSI_TCP is not set
-CONFIG_ISDN=y
-# CONFIG_ISDN_AUDIO is not set
-# CONFIG_ISDN_CAPI is not set
-# CONFIG_ISDN_CAPI_CAPIDRV is not set
-# CONFIG_ISDN_DIVERSION is not set
-# CONFIG_ISDN_DRV_ACT2000 is not set
-# CONFIG_ISDN_DRV_GIGASET is not set
-# CONFIG_ISDN_DRV_HISAX is not set
-# CONFIG_ISDN_DRV_ICN is not set
-# CONFIG_ISDN_DRV_LOOP is not set
-# CONFIG_ISDN_DRV_PCBIT is not set
-# CONFIG_ISDN_DRV_SC is not set
-# CONFIG_ISDN_I4L is not set
-# CONFIG_ISL29003 is not set
-# CONFIG_ISL29020 is not set
-# CONFIG_ISL29125 is not set
-# CONFIG_ISO9660_FS is not set
-# CONFIG_ISS4xx is not set
-# CONFIG_ITG3200 is not set
-# CONFIG_IWL3945 is not set
-# CONFIG_IWLWIFI is not set
-# CONFIG_IXGB is not set
-# CONFIG_IXGBE is not set
-# CONFIG_IXGBEVF is not set
-# CONFIG_JBD2_DEBUG is not set
-# CONFIG_JFFS2_CMODE_FAVOURLZO is not set
-# CONFIG_JFFS2_CMODE_NONE is not set
-CONFIG_JFFS2_CMODE_PRIORITY=y
-# CONFIG_JFFS2_CMODE_SIZE is not set
-CONFIG_JFFS2_COMPRESSION_OPTIONS=y
-CONFIG_JFFS2_FS=y
-CONFIG_JFFS2_FS_DEBUG=0
-# CONFIG_JFFS2_FS_POSIX_ACL is not set
-# CONFIG_JFFS2_FS_SECURITY is not set
-# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
-CONFIG_JFFS2_FS_WRITEBUFFER=y
-CONFIG_JFFS2_FS_XATTR=y
-CONFIG_JFFS2_LZMA=y
-# CONFIG_JFFS2_LZO is not set
-CONFIG_JFFS2_RTIME=y
-# CONFIG_JFFS2_RUBIN is not set
-CONFIG_JFFS2_SUMMARY=y
-# CONFIG_JFFS2_ZLIB is not set
-# CONFIG_JFS_DEBUG is not set
-# CONFIG_JFS_FS is not set
-# CONFIG_JFS_POSIX_ACL is not set
-# CONFIG_JFS_SECURITY is not set
-# CONFIG_JFS_STATISTICS is not set
-# CONFIG_JME is not set
-CONFIG_JOLIET=y
-# CONFIG_JSA1212 is not set
-# CONFIG_JUMP_LABEL is not set
-# CONFIG_KALLSYMS is not set
-# CONFIG_KALLSYMS_ABSOLUTE_PERCPU is not set
-# CONFIG_KALLSYMS_ALL is not set
-CONFIG_KALLSYMS_BASE_RELATIVE=y
-# CONFIG_KALLSYMS_UNCOMPRESSED is not set
-# CONFIG_KARMA_PARTITION is not set
-# CONFIG_KASAN is not set
-# CONFIG_KCOV is not set
-# CONFIG_KERNEL_BZIP2 is not set
-# CONFIG_KERNEL_CAT is not set
-# CONFIG_KERNEL_GZIP is not set
-# CONFIG_KERNEL_LZ4 is not set
-# CONFIG_KERNEL_LZMA is not set
-# CONFIG_KERNEL_LZO is not set
-CONFIG_KERNEL_MODE_NEON=y
-CONFIG_KERNEL_XZ=y
-CONFIG_KERNFS=y
-# CONFIG_KEXEC is not set
-# CONFIG_KEYBOARD_ADC is not set
-# CONFIG_KEYBOARD_ADP5588 is not set
-# CONFIG_KEYBOARD_ADP5589 is not set
-# CONFIG_KEYBOARD_ATKBD is not set
-# CONFIG_KEYBOARD_BCM is not set
-# CONFIG_KEYBOARD_CAP11XX is not set
-# CONFIG_KEYBOARD_GPIO is not set
-# CONFIG_KEYBOARD_GPIO_POLLED is not set
-# CONFIG_KEYBOARD_LKKBD is not set
-# CONFIG_KEYBOARD_LM8323 is not set
-# CONFIG_KEYBOARD_LM8333 is not set
-# CONFIG_KEYBOARD_MATRIX is not set
-# CONFIG_KEYBOARD_MAX7359 is not set
-# CONFIG_KEYBOARD_MCS is not set
-# CONFIG_KEYBOARD_MPR121 is not set
-# CONFIG_KEYBOARD_NEWTON is not set
-# CONFIG_KEYBOARD_OMAP4 is not set
-# CONFIG_KEYBOARD_OPENCORES is not set
-# CONFIG_KEYBOARD_PXA27x is not set
-# CONFIG_KEYBOARD_QT1070 is not set
-# CONFIG_KEYBOARD_QT2160 is not set
-# CONFIG_KEYBOARD_SAMSUNG is not set
-# CONFIG_KEYBOARD_SH_KEYSC is not set
-# CONFIG_KEYBOARD_SNVS_PWRKEY is not set
-# CONFIG_KEYBOARD_STMPE is not set
-# CONFIG_KEYBOARD_STOWAWAY is not set
-# CONFIG_KEYBOARD_SUNKBD is not set
-# CONFIG_KEYBOARD_TCA6416 is not set
-# CONFIG_KEYBOARD_TCA8418 is not set
-# CONFIG_KEYBOARD_TWL4030 is not set
-# CONFIG_KEYBOARD_XTKBD is not set
-# CONFIG_KEYS is not set
-# CONFIG_KEY_DH_OPERATIONS is not set
-# CONFIG_KGDB is not set
-# CONFIG_KMEMCHECK is not set
-# CONFIG_KMX61 is not set
-# CONFIG_KPROBES is not set
-# CONFIG_KPROBES_SANITY_TEST is not set
-# CONFIG_KS7010 is not set
-# CONFIG_KS8842 is not set
-# CONFIG_KS8851 is not set
-# CONFIG_KS8851_MLL is not set
-# CONFIG_KSM is not set
-# CONFIG_KSZ884X_PCI is not set
-CONFIG_KUSER_HELPERS=y
-# CONFIG_KVM_AMD is not set
-# CONFIG_KVM_GUEST is not set
-# CONFIG_KVM_INTEL is not set
-# CONFIG_KXCJK1013 is not set
-# CONFIG_KXSD9 is not set
-# CONFIG_L2TP is not set
-# CONFIG_L2TP_ETH is not set
-# CONFIG_L2TP_IP is not set
-# CONFIG_L2TP_V3 is not set
-# CONFIG_LANMEDIA is not set
-# CONFIG_LANTIQ is not set
-# CONFIG_LAPB is not set
-# CONFIG_LASAT is not set
-# CONFIG_LATENCYTOP is not set
-# CONFIG_LATTICE_ECP3_CONFIG is not set
-CONFIG_LBDAF=y
-# CONFIG_LCD_AMS369FG06 is not set
-# CONFIG_LCD_HX8357 is not set
-# CONFIG_LCD_ILI922X is not set
-# CONFIG_LCD_ILI9320 is not set
-# CONFIG_LCD_L4F00242T03 is not set
-# CONFIG_LCD_LD9040 is not set
-# CONFIG_LCD_LMS283GF05 is not set
-# CONFIG_LCD_LMS501KF03 is not set
-# CONFIG_LCD_LTV350QV is not set
-# CONFIG_LCD_S6E63M0 is not set
-# CONFIG_LCD_TDO24M is not set
-# CONFIG_LCD_VGG2432A4 is not set
-CONFIG_LDISC_AUTOLOAD=y
-# CONFIG_LDM_PARTITION is not set
-CONFIG_LD_DEAD_CODE_DATA_ELIMINATION=y
-# CONFIG_LEDS_BCM6328 is not set
-# CONFIG_LEDS_BCM6358 is not set
-# CONFIG_LEDS_BD2802 is not set
-# CONFIG_LEDS_BLINKM is not set
-CONFIG_LEDS_CLASS=y
-# CONFIG_LEDS_CLASS_FLASH is not set
-# CONFIG_LEDS_DAC124S085 is not set
-# CONFIG_LEDS_GPIO is not set
-# CONFIG_LEDS_INTEL_SS4200 is not set
-# CONFIG_LEDS_IS31FL319X is not set
-# CONFIG_LEDS_IS31FL32XX is not set
-# CONFIG_LEDS_LM3530 is not set
-# CONFIG_LEDS_LM355x is not set
-# CONFIG_LEDS_LM3642 is not set
-# CONFIG_LEDS_LP3944 is not set
-# CONFIG_LEDS_LP3952 is not set
-# CONFIG_LEDS_LP5521 is not set
-# CONFIG_LEDS_LP5523 is not set
-# CONFIG_LEDS_LP5562 is not set
-# CONFIG_LEDS_LP8501 is not set
-# CONFIG_LEDS_LP8860 is not set
-# CONFIG_LEDS_LT3593 is not set
-# CONFIG_LEDS_MLXCPLD is not set
-# CONFIG_LEDS_NS2 is not set
-# CONFIG_LEDS_OT200 is not set
-# CONFIG_LEDS_PCA9532 is not set
-# CONFIG_LEDS_PCA955X is not set
-# CONFIG_LEDS_PCA963X is not set
-# CONFIG_LEDS_PWM is not set
-# CONFIG_LEDS_REGULATOR is not set
-# CONFIG_LEDS_SYSCON is not set
-# CONFIG_LEDS_TCA6507 is not set
-# CONFIG_LEDS_TLC591XX is not set
-CONFIG_LEDS_TRIGGERS=y
-# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
-# CONFIG_LEDS_TRIGGER_CAMERA is not set
-# CONFIG_LEDS_TRIGGER_CPU is not set
-CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
-# CONFIG_LEDS_TRIGGER_DISK is not set
-# CONFIG_LEDS_TRIGGER_GPIO is not set
-# CONFIG_LEDS_TRIGGER_HEARTBEAT is not set
-# CONFIG_LEDS_TRIGGER_IDE_DISK is not set
-# CONFIG_LEDS_TRIGGER_MTD is not set
-CONFIG_LEDS_TRIGGER_NETDEV=y
-# CONFIG_LEDS_TRIGGER_ONESHOT is not set
-# CONFIG_LEDS_TRIGGER_PANIC is not set
-CONFIG_LEDS_TRIGGER_TIMER=y
-# CONFIG_LEDS_TRIGGER_TRANSIENT is not set
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_LGUEST is not set
-# CONFIG_LIB80211 is not set
-# CONFIG_LIB80211_CRYPT_CCMP is not set
-# CONFIG_LIB80211_CRYPT_TKIP is not set
-# CONFIG_LIB80211_CRYPT_WEP is not set
-# CONFIG_LIB80211_DEBUG is not set
-# CONFIG_LIBCRC32C is not set
-# CONFIG_LIBERTAS is not set
-# CONFIG_LIBERTAS_THINFIRM is not set
-# CONFIG_LIBERTAS_USB is not set
-# CONFIG_LIBFC is not set
-# CONFIG_LIBFCOE is not set
-# CONFIG_LIBIPW_DEBUG is not set
-# CONFIG_LIBNVDIMM is not set
-# CONFIG_LIDAR_LITE_V2 is not set
-# CONFIG_LIQUIDIO is not set
-# CONFIG_LIRC_STAGING is not set
-# CONFIG_LIS3L02DQ is not set
-# CONFIG_LKDTM is not set
-CONFIG_LLC=y
-# CONFIG_LLC2 is not set
-# CONFIG_LNET is not set
-CONFIG_LOCALVERSION=""
-# CONFIG_LOCALVERSION_AUTO is not set
-# CONFIG_LOCKD is not set
-CONFIG_LOCKDEP_SUPPORT=y
-CONFIG_LOCKD_V4=y
-# CONFIG_LOCKUP_DETECTOR is not set
-# CONFIG_LOCK_STAT is not set
-# CONFIG_LOCK_TORTURE_TEST is not set
-# CONFIG_LOGFS is not set
-# CONFIG_LOGIG940_FF is not set
-# CONFIG_LOGIRUMBLEPAD2_FF is not set
-# CONFIG_LOGITECH_FF is not set
-# CONFIG_LOGIWHEELS_FF is not set
-# CONFIG_LOGO is not set
-CONFIG_LOG_BUF_SHIFT=17
-CONFIG_LOG_CPU_MAX_BUF_SHIFT=12
-# CONFIG_LOONGSON_MC146818 is not set
-# CONFIG_LPC_ICH is not set
-# CONFIG_LPC_SCH is not set
-# CONFIG_LP_CONSOLE is not set
-# CONFIG_LSI_ET1011C_PHY is not set
-# CONFIG_LTC2485 is not set
-# CONFIG_LTE_GDM724X is not set
-# CONFIG_LTPC is not set
-# CONFIG_LTR501 is not set
-# CONFIG_LUSTRE_FS is not set
-# CONFIG_LWTUNNEL is not set
-# CONFIG_LXT_PHY is not set
-# CONFIG_LZ4HC_COMPRESS is not set
-# CONFIG_LZ4_COMPRESS is not set
-# CONFIG_LZ4_DECOMPRESS is not set
-CONFIG_LZMA_COMPRESS=y
-CONFIG_LZMA_DECOMPRESS=y
-# CONFIG_LZO_COMPRESS is not set
-# CONFIG_LZO_DECOMPRESS is not set
-# CONFIG_M62332 is not set
-# CONFIG_MAC80211 is not set
-# CONFIG_MAC80211_MESSAGE_TRACING is not set
-CONFIG_MAC80211_STA_HASH_MAX_SIZE=0
-# CONFIG_MACB is not set
-# CONFIG_MACH_ASM9260 is not set
-# CONFIG_MACH_DECSTATION is not set
-# CONFIG_MACH_INGENIC is not set
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_JZ4740 is not set
-# CONFIG_MACH_LOONGSON32 is not set
-# CONFIG_MACH_LOONGSON64 is not set
-# CONFIG_MACH_PIC32 is not set
-# CONFIG_MACH_PISTACHIO is not set
-# CONFIG_MACH_TX39XX is not set
-# CONFIG_MACH_TX49XX is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_MACH_XILFPGA is not set
-# CONFIG_MACINTOSH_DRIVERS is not set
-# CONFIG_MACSEC is not set
-# CONFIG_MACVLAN is not set
-# CONFIG_MACVTAP is not set
-# CONFIG_MAC_EMUMOUSEBTN is not set
-# CONFIG_MAC_PARTITION is not set
-# CONFIG_MAG3110 is not set
-# CONFIG_MAGIC_SYSRQ is not set
-CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x1
-# CONFIG_MAGIC_SYSRQ_SERIAL is not set
-# CONFIG_MAILBOX is not set
-# CONFIG_MANDATORY_FILE_LOCKING is not set
-# CONFIG_MANGLE_BOOTARGS is not set
-# CONFIG_MARVELL_PHY is not set
-# CONFIG_MAX1027 is not set
-# CONFIG_MAX1363 is not set
-# CONFIG_MAX30100 is not set
-# CONFIG_MAX44000 is not set
-# CONFIG_MAX517 is not set
-# CONFIG_MAX5487 is not set
-# CONFIG_MAX5821 is not set
-# CONFIG_MAX63XX_WATCHDOG is not set
-# CONFIG_MAXIM_THERMOCOUPLE is not set
-CONFIG_MAY_USE_DEVLINK=y
-# CONFIG_MC3230 is not set
-# CONFIG_MCB is not set
-# CONFIG_MCP320X is not set
-# CONFIG_MCP3422 is not set
-# CONFIG_MCP4131 is not set
-# CONFIG_MCP4531 is not set
-# CONFIG_MCP4725 is not set
-# CONFIG_MCP4922 is not set
-# CONFIG_MCPM is not set
-# CONFIG_MD is not set
-# CONFIG_MDIO_BCM_UNIMAC is not set
-# CONFIG_MDIO_BITBANG is not set
-# CONFIG_MDIO_BUS_MUX_GPIO is not set
-# CONFIG_MDIO_BUS_MUX_MMIOREG is not set
-# CONFIG_MDIO_HISI_FEMAC is not set
-# CONFIG_MDIO_OCTEON is not set
-# CONFIG_MDIO_THUNDER is not set
-# CONFIG_MD_FAULTY is not set
-# CONFIG_MEDIA_ANALOG_TV_SUPPORT is not set
-# CONFIG_MEDIA_ATTACH is not set
-# CONFIG_MEDIA_CAMERA_SUPPORT is not set
-# CONFIG_MEDIA_CONTROLLER is not set
-# CONFIG_MEDIA_DIGITAL_TV_SUPPORT is not set
-# CONFIG_MEDIA_PCI_SUPPORT is not set
-# CONFIG_MEDIA_RADIO_SUPPORT is not set
-# CONFIG_MEDIA_RC_SUPPORT is not set
-# CONFIG_MEDIA_SDR_SUPPORT is not set
-# CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
-# CONFIG_MEDIA_SUPPORT is not set
-# CONFIG_MEDIA_USB_SUPPORT is not set
-# CONFIG_MEGARAID_LEGACY is not set
-# CONFIG_MEGARAID_NEWGEN is not set
-# CONFIG_MEGARAID_SAS is not set
-CONFIG_MEMBARRIER=y
-# CONFIG_MEMORY is not set
-# CONFIG_MEMORY_FAILURE is not set
-# CONFIG_MEMSTICK is not set
-# CONFIG_MEMTEST is not set
-# CONFIG_MEN_A21_WDT is not set
-# CONFIG_MESON_SM is not set
-CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
-# CONFIG_MFD_88PM800 is not set
-# CONFIG_MFD_88PM805 is not set
-# CONFIG_MFD_88PM860X is not set
-# CONFIG_MFD_AAT2870_CORE is not set
-# CONFIG_MFD_ACT8945A is not set
-# CONFIG_MFD_ARIZONA_I2C is not set
-# CONFIG_MFD_ARIZONA_SPI is not set
-# CONFIG_MFD_AS3711 is not set
-# CONFIG_MFD_AS3722 is not set
-# CONFIG_MFD_ASIC3 is not set
-# CONFIG_MFD_ATMEL_FLEXCOM is not set
-# CONFIG_MFD_ATMEL_HLCDC is not set
-# CONFIG_MFD_AXP20X is not set
-# CONFIG_MFD_AXP20X_I2C is not set
-# CONFIG_MFD_BCM590XX is not set
-# CONFIG_MFD_CORE is not set
-# CONFIG_MFD_CROS_EC is not set
-# CONFIG_MFD_CS5535 is not set
-# CONFIG_MFD_DA9052_I2C is not set
-# CONFIG_MFD_DA9052_SPI is not set
-# CONFIG_MFD_DA9055 is not set
-# CONFIG_MFD_DA9062 is not set
-# CONFIG_MFD_DA9063 is not set
-# CONFIG_MFD_DA9150 is not set
-# CONFIG_MFD_DLN2 is not set
-# CONFIG_MFD_EXYNOS_LPASS is not set
-# CONFIG_MFD_HI6421_PMIC is not set
-# CONFIG_MFD_JANZ_CMODIO is not set
-# CONFIG_MFD_KEMPLD is not set
-# CONFIG_MFD_LM3533 is not set
-# CONFIG_MFD_LP3943 is not set
-# CONFIG_MFD_LP8788 is not set
-# CONFIG_MFD_MAX14577 is not set
-# CONFIG_MFD_MAX77620 is not set
-# CONFIG_MFD_MAX77686 is not set
-# CONFIG_MFD_MAX77693 is not set
-# CONFIG_MFD_MAX77843 is not set
-# CONFIG_MFD_MAX8907 is not set
-# CONFIG_MFD_MAX8925 is not set
-# CONFIG_MFD_MAX8997 is not set
-# CONFIG_MFD_MAX8998 is not set
-# CONFIG_MFD_MC13XXX is not set
-# CONFIG_MFD_MC13XXX_I2C is not set
-# CONFIG_MFD_MC13XXX_SPI is not set
-# CONFIG_MFD_MENF21BMC is not set
-# CONFIG_MFD_MT6397 is not set
-# CONFIG_MFD_OMAP_USB_HOST is not set
-# CONFIG_MFD_PALMAS is not set
-# CONFIG_MFD_PCF50633 is not set
-# CONFIG_MFD_PM8921_CORE is not set
-# CONFIG_MFD_RC5T583 is not set
-# CONFIG_MFD_RDC321X is not set
-# CONFIG_MFD_RETU is not set
-# CONFIG_MFD_RK808 is not set
-# CONFIG_MFD_RN5T618 is not set
-# CONFIG_MFD_RT5033 is not set
-# CONFIG_MFD_RTSX_PCI is not set
-# CONFIG_MFD_RTSX_USB is not set
-# CONFIG_MFD_SEC_CORE is not set
-# CONFIG_MFD_SI476X_CORE is not set
-# CONFIG_MFD_SKY81452 is not set
-# CONFIG_MFD_SM501 is not set
-# CONFIG_MFD_SMSC is not set
-# CONFIG_MFD_STMPE is not set
-# CONFIG_MFD_SYSCON is not set
-# CONFIG_MFD_T7L66XB is not set
-# CONFIG_MFD_TC3589X is not set
-# CONFIG_MFD_TC6387XB is not set
-# CONFIG_MFD_TC6393XB is not set
-# CONFIG_MFD_TIMBERDALE is not set
-# CONFIG_MFD_TI_AM335X_TSCADC is not set
-# CONFIG_MFD_TI_LP873X is not set
-# CONFIG_MFD_TMIO is not set
-# CONFIG_MFD_TPS65086 is not set
-# CONFIG_MFD_TPS65090 is not set
-# CONFIG_MFD_TPS65217 is not set
-# CONFIG_MFD_TPS65218 is not set
-# CONFIG_MFD_TPS6586X is not set
-# CONFIG_MFD_TPS65910 is not set
-# CONFIG_MFD_TPS65912 is not set
-# CONFIG_MFD_TPS65912_I2C is not set
-# CONFIG_MFD_TPS65912_SPI is not set
-# CONFIG_MFD_TPS80031 is not set
-# CONFIG_MFD_VIPERBOARD is not set
-# CONFIG_MFD_VX855 is not set
-# CONFIG_MFD_WL1273_CORE is not set
-# CONFIG_MFD_WM831X is not set
-# CONFIG_MFD_WM831X_I2C is not set
-# CONFIG_MFD_WM831X_SPI is not set
-# CONFIG_MFD_WM8350_I2C is not set
-# CONFIG_MFD_WM8400 is not set
-# CONFIG_MFD_WM8994 is not set
-# CONFIG_MG_DISK is not set
-# CONFIG_MICREL_KS8995MA is not set
-# CONFIG_MICREL_PHY is not set
-# CONFIG_MICROCHIP_PHY is not set
-# CONFIG_MICROSEMI_PHY is not set
-# CONFIG_MIGRATION is not set
-CONFIG_MII=y
-# CONFIG_MIKROTIK_RB532 is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_MINIX_FS_NATIVE_ENDIAN is not set
-# CONFIG_MINIX_SUBPARTITION is not set
-# CONFIG_MIPS_ALCHEMY is not set
-# CONFIG_MIPS_CDMM is not set
-# CONFIG_MIPS_COBALT is not set
-# CONFIG_MIPS_FPU_EMULATOR is not set
-# CONFIG_MIPS_GENERIC is not set
-# CONFIG_MIPS_MALTA is not set
-# CONFIG_MIPS_O32_FP64_SUPPORT is not set
-# CONFIG_MIPS_PARAVIRT is not set
-# CONFIG_MIPS_PLATFORM_DEVICES is not set
-# CONFIG_MIPS_SEAD3 is not set
-CONFIG_MISC_FILESYSTEMS=y
-# CONFIG_MISDN is not set
-# CONFIG_MISDN_AVMFRITZ is not set
-# CONFIG_MISDN_HFCPCI is not set
-# CONFIG_MISDN_HFCUSB is not set
-# CONFIG_MISDN_INFINEON is not set
-# CONFIG_MISDN_NETJET is not set
-# CONFIG_MISDN_SPEEDFAX is not set
-# CONFIG_MISDN_W6692 is not set
-# CONFIG_MKISS is not set
-# CONFIG_MLX4_CORE is not set
-# CONFIG_MLX4_EN is not set
-# CONFIG_MLX5_CORE is not set
-# CONFIG_MLX90614 is not set
-# CONFIG_MLXSW_CORE is not set
-# CONFIG_MMA7455_I2C is not set
-# CONFIG_MMA7455_SPI is not set
-# CONFIG_MMA7660 is not set
-# CONFIG_MMA8452 is not set
-# CONFIG_MMA9551 is not set
-# CONFIG_MMA9553 is not set
-# CONFIG_MMC is not set
-# CONFIG_MMC35240 is not set
-# CONFIG_MMC_ARMMMCI is not set
-# CONFIG_MMC_AU1X is not set
-# CONFIG_MMC_BLOCK is not set
-CONFIG_MMC_BLOCK_BOUNCE=y
-CONFIG_MMC_BLOCK_MINORS=8
-# CONFIG_MMC_CB710 is not set
-# CONFIG_MMC_DEBUG is not set
-# CONFIG_MMC_DW is not set
-# CONFIG_MMC_MTK is not set
-# CONFIG_MMC_MVSDIO is not set
-# CONFIG_MMC_S3C is not set
-# CONFIG_MMC_SDHCI is not set
-# CONFIG_MMC_SDHCI_ACPI is not set
-# CONFIG_MMC_SDHCI_BCM_KONA is not set
-# CONFIG_MMC_SDHCI_F_SDH30 is not set
-# CONFIG_MMC_SDHCI_IPROC is not set
-# CONFIG_MMC_SDHCI_MSM is not set
-# CONFIG_MMC_SDHCI_OF_ARASAN is not set
-# CONFIG_MMC_SDHCI_OF_AT91 is not set
-# CONFIG_MMC_SDHCI_OF_ESDHC is not set
-# CONFIG_MMC_SDHCI_OF_HLWD is not set
-# CONFIG_MMC_SDHCI_PXAV2 is not set
-# CONFIG_MMC_SDHCI_PXAV3 is not set
-# CONFIG_MMC_SDRICOH_CS is not set
-# CONFIG_MMC_SPI is not set
-# CONFIG_MMC_TEST is not set
-# CONFIG_MMC_TOSHIBA_PCI is not set
-# CONFIG_MMC_USDHI6ROL0 is not set
-# CONFIG_MMC_USHC is not set
-# CONFIG_MMC_VIA_SDMMC is not set
-# CONFIG_MMC_VUB300 is not set
-# CONFIG_MMIOTRACE is not set
-CONFIG_MMU=y
-CONFIG_MODULES=y
-# CONFIG_MODULE_COMPRESS is not set
-# CONFIG_MODULE_FORCE_LOAD is not set
-# CONFIG_MODULE_FORCE_UNLOAD is not set
-# CONFIG_MODULE_SIG is not set
-# CONFIG_MODULE_SRCVERSION_ALL is not set
-CONFIG_MODULE_STRIPPED=y
-CONFIG_MODULE_UNLOAD=y
-# CONFIG_MODVERSIONS is not set
-# CONFIG_MOST is not set
-# CONFIG_MOUSE_APPLETOUCH is not set
-# CONFIG_MOUSE_ELAN_I2C is not set
-# CONFIG_MOUSE_GPIO is not set
-# CONFIG_MOUSE_INPORT is not set
-# CONFIG_MOUSE_LOGIBM is not set
-# CONFIG_MOUSE_PC110PAD is not set
-# CONFIG_MOUSE_PS2_FOCALTECH is not set
-# CONFIG_MOUSE_PS2_SENTELIC is not set
-# CONFIG_MOUSE_SYNAPTICS_I2C is not set
-# CONFIG_MOUSE_SYNAPTICS_USB is not set
-# CONFIG_MPL115 is not set
-# CONFIG_MPL115_I2C is not set
-# CONFIG_MPL115_SPI is not set
-# CONFIG_MPL3115 is not set
-# CONFIG_MPLS is not set
-# CONFIG_MS5611 is not set
-# CONFIG_MS5637 is not set
-# CONFIG_MSDOS_FS is not set
-CONFIG_MSDOS_PARTITION=y
-# CONFIG_MSI_BITMAP_SELFTEST is not set
-# CONFIG_MSI_LAPTOP is not set
-CONFIG_MTD=y
-# CONFIG_MTD_ABSENT is not set
-# CONFIG_MTD_AFS_PARTS is not set
-# CONFIG_MTD_AR7_PARTS is not set
-CONFIG_MTD_BLKDEVS=y
-CONFIG_MTD_BLOCK=y
-# CONFIG_MTD_BLOCK2MTD is not set
-CONFIG_MTD_CFI=y
-# CONFIG_MTD_CFI_ADV_OPTIONS is not set
-CONFIG_MTD_CFI_AMDSTD=y
-# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
-CONFIG_MTD_CFI_I1=y
-CONFIG_MTD_CFI_I2=y
-# CONFIG_MTD_CFI_I4 is not set
-# CONFIG_MTD_CFI_I8 is not set
-CONFIG_MTD_CFI_INTELEXT=y
-# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
-CONFIG_MTD_CFI_NOSWAP=y
-# CONFIG_MTD_CFI_STAA is not set
-CONFIG_MTD_CFI_UTIL=y
-# CONFIG_MTD_CMDLINE_PARTS is not set
-CONFIG_MTD_COMPLEX_MAPPINGS=y
-# CONFIG_MTD_DATAFLASH is not set
-# CONFIG_MTD_DOCG3 is not set
-CONFIG_MTD_GEN_PROBE=y
-# CONFIG_MTD_GPIO_ADDR is not set
-# CONFIG_MTD_INTEL_VR_NOR is not set
-# CONFIG_MTD_JEDECPROBE is not set
-# CONFIG_MTD_LATCH_ADDR is not set
-# CONFIG_MTD_LPDDR is not set
-# CONFIG_MTD_LPDDR2_NVM is not set
-# CONFIG_MTD_M25P80 is not set
-CONFIG_MTD_MAP_BANK_WIDTH_1=y
-# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
-CONFIG_MTD_MAP_BANK_WIDTH_2=y
-# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
-CONFIG_MTD_MAP_BANK_WIDTH_4=y
-# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
-# CONFIG_MTD_MT81xx_NOR is not set
-# CONFIG_MTD_MTDRAM is not set
-# CONFIG_MTD_MYLOADER_PARTS is not set
-# CONFIG_MTD_NAND is not set
-# CONFIG_MTD_NAND_AMS_DELTA is not set
-# CONFIG_MTD_NAND_AR934X is not set
-# CONFIG_MTD_NAND_AR934X_HW_ECC is not set
-# CONFIG_MTD_NAND_ATMEL is not set
-# CONFIG_MTD_NAND_AU1550 is not set
-# CONFIG_MTD_NAND_BCH is not set
-# CONFIG_MTD_NAND_BF5XX is not set
-# CONFIG_MTD_NAND_BRCMNAND is not set
-# CONFIG_MTD_NAND_CAFE is not set
-# CONFIG_MTD_NAND_CM_X270 is not set
-# CONFIG_MTD_NAND_CS553X is not set
-# CONFIG_MTD_NAND_DAVINCI is not set
-# CONFIG_MTD_NAND_DENALI is not set
-# CONFIG_MTD_NAND_DENALI_DT is not set
-# CONFIG_MTD_NAND_DENALI_PCI is not set
-CONFIG_MTD_NAND_DENALI_SCRATCH_REG_ADDR=0xff108018
-# CONFIG_MTD_NAND_DISKONCHIP is not set
-# CONFIG_MTD_NAND_DOCG4 is not set
-# CONFIG_MTD_NAND_ECC is not set
-# CONFIG_MTD_NAND_ECC_BCH is not set
-# CONFIG_MTD_NAND_ECC_SMC is not set
-# CONFIG_MTD_NAND_FSL_ELBC is not set
-# CONFIG_MTD_NAND_FSL_IFC is not set
-# CONFIG_MTD_NAND_FSL_UPM is not set
-# CONFIG_MTD_NAND_FSMC is not set
-# CONFIG_MTD_NAND_GPIO is not set
-# CONFIG_MTD_NAND_GPMI_NAND is not set
-# CONFIG_MTD_NAND_HISI504 is not set
-CONFIG_MTD_NAND_IDS=y
-# CONFIG_MTD_NAND_JZ4740 is not set
-# CONFIG_MTD_NAND_MPC5121_NFC is not set
-# CONFIG_MTD_NAND_MTK is not set
-# CONFIG_MTD_NAND_MXC is not set
-# CONFIG_MTD_NAND_NANDSIM is not set
-# CONFIG_MTD_NAND_NDFC is not set
-# CONFIG_MTD_NAND_NUC900 is not set
-# CONFIG_MTD_NAND_OMAP2 is not set
-# CONFIG_MTD_NAND_OMAP_BCH_BUILD is not set
-# CONFIG_MTD_NAND_ORION is not set
-# CONFIG_MTD_NAND_PASEMI is not set
-# CONFIG_MTD_NAND_PLATFORM is not set
-# CONFIG_MTD_NAND_PXA3xx is not set
-# CONFIG_MTD_NAND_RB4XX is not set
-# CONFIG_MTD_NAND_RB750 is not set
-# CONFIG_MTD_NAND_RICOH is not set
-# CONFIG_MTD_NAND_S3C2410 is not set
-# CONFIG_MTD_NAND_SHARPSL is not set
-# CONFIG_MTD_NAND_SH_FLCTL is not set
-# CONFIG_MTD_NAND_SOCRATES is not set
-# CONFIG_MTD_NAND_TMIO is not set
-# CONFIG_MTD_NAND_TXX9NDFMC is not set
-CONFIG_MTD_OF_PARTS=y
-# CONFIG_MTD_ONENAND is not set
-# CONFIG_MTD_OOPS is not set
-# CONFIG_MTD_OTP is not set
-# CONFIG_MTD_PARTITIONED_MASTER is not set
-# CONFIG_MTD_PCI is not set
-# CONFIG_MTD_PCMCIA is not set
-# CONFIG_MTD_PHRAM is not set
-# CONFIG_MTD_PHYSMAP is not set
-# CONFIG_MTD_PHYSMAP_COMPAT is not set
-CONFIG_MTD_PHYSMAP_OF=y
-# CONFIG_MTD_PHYSMAP_OF_VERSATILE is not set
-# CONFIG_MTD_PLATRAM is not set
-# CONFIG_MTD_PMC551 is not set
-# CONFIG_MTD_RAM is not set
-CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK=-1
-# CONFIG_MTD_REDBOOT_PARTS is not set
-# CONFIG_MTD_REDBOOT_PARTS_READONLY is not set
-# CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED is not set
-# CONFIG_MTD_ROM is not set
-CONFIG_MTD_ROOTFS_ROOT_DEV=y
-# CONFIG_MTD_SLRAM is not set
-# CONFIG_MTD_SM_COMMON is not set
-# CONFIG_MTD_SPINAND_MT29F is not set
-# CONFIG_MTD_SPI_NOR is not set
-# CONFIG_MTD_SPI_NOR_USE_4K_SECTORS is not set
-CONFIG_MTD_SPI_NOR_USE_4K_SECTORS_LIMIT=4096
-CONFIG_MTD_SPLIT=y
-# CONFIG_MTD_SPLIT_BRNIMAGE_FW is not set
-# CONFIG_MTD_SPLIT_EVA_FW is not set
-# CONFIG_MTD_SPLIT_FIRMWARE is not set
-CONFIG_MTD_SPLIT_FIRMWARE_NAME="firmware"
-# CONFIG_MTD_SPLIT_FIT_FW is not set
-# CONFIG_MTD_SPLIT_JIMAGE_FW is not set
-# CONFIG_MTD_SPLIT_LZMA_FW is not set
-# CONFIG_MTD_SPLIT_MINOR_FW is not set
-# CONFIG_MTD_SPLIT_SEAMA_FW is not set
-CONFIG_MTD_SPLIT_SQUASHFS_ROOT=y
-CONFIG_MTD_SPLIT_SUPPORT=y
-# CONFIG_MTD_SPLIT_TPLINK_FW is not set
-# CONFIG_MTD_SPLIT_TRX_FW is not set
-# CONFIG_MTD_SPLIT_UIMAGE_FW is not set
-# CONFIG_MTD_SPLIT_WRGG_FW is not set
-# CONFIG_MTD_SST25L is not set
-# CONFIG_MTD_SWAP is not set
-# CONFIG_MTD_TESTS is not set
-# CONFIG_MTD_UBI is not set
-# CONFIG_MTD_UIMAGE_SPLIT is not set
-CONFIG_MULTIUSER=y
-# CONFIG_MUTEX_SPIN_ON_OWNER is not set
-# CONFIG_MV643XX_ETH is not set
-# CONFIG_MVMDIO is not set
-# CONFIG_MVNETA_BM is not set
-# CONFIG_MVSW61XX_PHY is not set
-# CONFIG_MVSWITCH_PHY is not set
-# CONFIG_MV_XOR_V2 is not set
-# CONFIG_MWAVE is not set
-# CONFIG_MWL8K is not set
-# CONFIG_MXC4005 is not set
-# CONFIG_MXC6255 is not set
-# CONFIG_MYRI10GE is not set
-# CONFIG_NAMESPACES is not set
-# CONFIG_NATIONAL_PHY is not set
-# CONFIG_NATSEMI is not set
-# CONFIG_NAU7802 is not set
-# CONFIG_NBPFAXI_DMA is not set
-# CONFIG_NCP_FS is not set
-# CONFIG_NE2000 is not set
-# CONFIG_NE2K_PCI is not set
-# CONFIG_NEC_MARKEINS is not set
-CONFIG_NET=y
-# CONFIG_NETCONSOLE is not set
-CONFIG_NETDEVICES=y
-# CONFIG_NETFILTER is not set
-# CONFIG_NETFILTER_ADVANCED is not set
-# CONFIG_NETFILTER_DEBUG is not set
-# CONFIG_NETFILTER_INGRESS is not set
-# CONFIG_NETFILTER_NETLINK is not set
-# CONFIG_NETFILTER_NETLINK_ACCT is not set
-# CONFIG_NETFILTER_NETLINK_GLUE_CT is not set
-# CONFIG_NETFILTER_NETLINK_LOG is not set
-# CONFIG_NETFILTER_NETLINK_QUEUE is not set
-# CONFIG_NETFILTER_XTABLES is not set
-# CONFIG_NETFILTER_XT_CONNMARK is not set
-# CONFIG_NETFILTER_XT_MARK is not set
-# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
-# CONFIG_NETFILTER_XT_MATCH_BPF is not set
-# CONFIG_NETFILTER_XT_MATCH_CGROUP is not set
-# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
-# CONFIG_NETFILTER_XT_MATCH_COMMENT is not set
-# CONFIG_NETFILTER_XT_MATCH_CONNBYTES is not set
-# CONFIG_NETFILTER_XT_MATCH_CONNLABEL is not set
-# CONFIG_NETFILTER_XT_MATCH_CONNLIMIT is not set
-# CONFIG_NETFILTER_XT_MATCH_CONNMARK is not set
-# CONFIG_NETFILTER_XT_MATCH_CONNTRACK is not set
-# CONFIG_NETFILTER_XT_MATCH_CPU is not set
-# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
-# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
-# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
-# CONFIG_NETFILTER_XT_MATCH_ECN is not set
-# CONFIG_NETFILTER_XT_MATCH_ESP is not set
-# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
-# CONFIG_NETFILTER_XT_MATCH_HELPER is not set
-# CONFIG_NETFILTER_XT_MATCH_HL is not set
-# CONFIG_NETFILTER_XT_MATCH_IPCOMP is not set
-# CONFIG_NETFILTER_XT_MATCH_IPRANGE is not set
-# CONFIG_NETFILTER_XT_MATCH_L2TP is not set
-# CONFIG_NETFILTER_XT_MATCH_LENGTH is not set
-# CONFIG_NETFILTER_XT_MATCH_LIMIT is not set
-# CONFIG_NETFILTER_XT_MATCH_MAC is not set
-# CONFIG_NETFILTER_XT_MATCH_MARK is not set
-# CONFIG_NETFILTER_XT_MATCH_MULTIPORT is not set
-# CONFIG_NETFILTER_XT_MATCH_NFACCT is not set
-# CONFIG_NETFILTER_XT_MATCH_OSF is not set
-# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
-# CONFIG_NETFILTER_XT_MATCH_PHYSDEV is not set
-# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
-# CONFIG_NETFILTER_XT_MATCH_POLICY is not set
-# CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
-# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
-# CONFIG_NETFILTER_XT_MATCH_REALM is not set
-# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
-# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
-# CONFIG_NETFILTER_XT_MATCH_SOCKET is not set
-# CONFIG_NETFILTER_XT_MATCH_STATE is not set
-# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
-# CONFIG_NETFILTER_XT_MATCH_STRING is not set
-# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
-# CONFIG_NETFILTER_XT_MATCH_TIME is not set
-# CONFIG_NETFILTER_XT_MATCH_U32 is not set
-# CONFIG_NETFILTER_XT_TARGET_AUDIT is not set
-# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
-# CONFIG_NETFILTER_XT_TARGET_CLASSIFY is not set
-# CONFIG_NETFILTER_XT_TARGET_CONNMARK is not set
-# CONFIG_NETFILTER_XT_TARGET_CT is not set
-# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
-# CONFIG_NETFILTER_XT_TARGET_HL is not set
-# CONFIG_NETFILTER_XT_TARGET_HMARK is not set
-# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
-# CONFIG_NETFILTER_XT_TARGET_LED is not set
-# CONFIG_NETFILTER_XT_TARGET_LOG is not set
-# CONFIG_NETFILTER_XT_TARGET_MARK is not set
-# CONFIG_NETFILTER_XT_TARGET_NETMAP is not set
-# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
-# CONFIG_NETFILTER_XT_TARGET_NFQUEUE is not set
-# CONFIG_NETFILTER_XT_TARGET_NOTRACK is not set
-# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
-# CONFIG_NETFILTER_XT_TARGET_REDIRECT is not set
-# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
-# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
-# CONFIG_NETFILTER_XT_TARGET_TEE is not set
-# CONFIG_NETFILTER_XT_TARGET_TPROXY is not set
-# CONFIG_NETFILTER_XT_TARGET_TRACE is not set
-# CONFIG_NETLINK_DIAG is not set
-# CONFIG_NETLINK_MMAP is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NETROM is not set
-CONFIG_NETWORK_FILESYSTEMS=y
-# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
-# CONFIG_NETWORK_SECMARK is not set
-# CONFIG_NETXEN_NIC is not set
-# CONFIG_NET_9P is not set
-# CONFIG_NET_ACT_BPF is not set
-# CONFIG_NET_ACT_CSUM is not set
-# CONFIG_NET_ACT_GACT is not set
-# CONFIG_NET_ACT_IFE is not set
-# CONFIG_NET_ACT_IPT is not set
-# CONFIG_NET_ACT_MIRRED is not set
-# CONFIG_NET_ACT_NAT is not set
-# CONFIG_NET_ACT_PEDIT is not set
-# CONFIG_NET_ACT_POLICE is not set
-# CONFIG_NET_ACT_SIMP is not set
-# CONFIG_NET_ACT_SKBEDIT is not set
-# CONFIG_NET_ACT_SKBMOD is not set
-# CONFIG_NET_ACT_TUNNEL_KEY is not set
-# CONFIG_NET_ACT_VLAN is not set
-CONFIG_NET_CADENCE=y
-# CONFIG_NET_CALXEDA_XGMAC is not set
-CONFIG_NET_CLS=y
-# CONFIG_NET_CLS_ACT is not set
-# CONFIG_NET_CLS_BASIC is not set
-# CONFIG_NET_CLS_BPF is not set
-# CONFIG_NET_CLS_FLOW is not set
-# CONFIG_NET_CLS_FLOWER is not set
-# CONFIG_NET_CLS_FW is not set
-CONFIG_NET_CLS_IND=y
-# CONFIG_NET_CLS_MATCHALL is not set
-# CONFIG_NET_CLS_ROUTE4 is not set
-# CONFIG_NET_CLS_RSVP is not set
-# CONFIG_NET_CLS_RSVP6 is not set
-# CONFIG_NET_CLS_TCINDEX is not set
-# CONFIG_NET_CLS_U32 is not set
-CONFIG_NET_CORE=y
-# CONFIG_NET_DEVLINK is not set
-# CONFIG_NET_DROP_MONITOR is not set
-# CONFIG_NET_DSA is not set
-# CONFIG_NET_DSA_BCM_SF2 is not set
-# CONFIG_NET_DSA_MV88E6060 is not set
-# CONFIG_NET_DSA_MV88E6123_61_65 is not set
-# CONFIG_NET_DSA_MV88E6131 is not set
-# CONFIG_NET_DSA_MV88E6171 is not set
-# CONFIG_NET_DSA_MV88E6352 is not set
-# CONFIG_NET_DSA_MV88E6XXX is not set
-# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
-# CONFIG_NET_DSA_QCA8K is not set
-# CONFIG_NET_DSA_TAG_DSA is not set
-# CONFIG_NET_DSA_TAG_EDSA is not set
-# CONFIG_NET_EMATCH is not set
-# CONFIG_NET_EMATCH_CANID is not set
-# CONFIG_NET_EMATCH_CMP is not set
-# CONFIG_NET_EMATCH_META is not set
-# CONFIG_NET_EMATCH_NBYTE is not set
-CONFIG_NET_EMATCH_STACK=32
-# CONFIG_NET_EMATCH_TEXT is not set
-# CONFIG_NET_EMATCH_U32 is not set
-# CONFIG_NET_FC is not set
-# CONFIG_NET_FOU is not set
-# CONFIG_NET_FOU_IP_TUNNELS is not set
-# CONFIG_NET_IPGRE is not set
-CONFIG_NET_IPGRE_BROADCAST=y
-# CONFIG_NET_IPGRE_DEMUX is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPVTI is not set
-# CONFIG_NET_IP_TUNNEL is not set
-# CONFIG_NET_KEY is not set
-# CONFIG_NET_KEY_MIGRATE is not set
-# CONFIG_NET_L3_MASTER_DEV is not set
-# CONFIG_NET_MPLS_GSO is not set
-# CONFIG_NET_NCSI is not set
-# CONFIG_NET_PACKET_ENGINE is not set
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_NET_PTP_CLASSIFY is not set
-CONFIG_NET_RX_BUSY_POLL=y
-# CONFIG_NET_SB1000 is not set
-CONFIG_NET_SCHED=y
-# CONFIG_NET_SCH_ATM is not set
-# CONFIG_NET_SCH_CBQ is not set
-# CONFIG_NET_SCH_CHOKE is not set
-# CONFIG_NET_SCH_CODEL is not set
-# CONFIG_NET_SCH_DRR is not set
-# CONFIG_NET_SCH_DSMARK is not set
-CONFIG_NET_SCH_FIFO=y
-# CONFIG_NET_SCH_FQ is not set
-CONFIG_NET_SCH_FQ_CODEL=y
-# CONFIG_NET_SCH_GRED is not set
-# CONFIG_NET_SCH_HFSC is not set
-# CONFIG_NET_SCH_HHF is not set
-# CONFIG_NET_SCH_HTB is not set
-# CONFIG_NET_SCH_INGRESS is not set
-# CONFIG_NET_SCH_MQPRIO is not set
-# CONFIG_NET_SCH_MULTIQ is not set
-# CONFIG_NET_SCH_NETEM is not set
-# CONFIG_NET_SCH_PIE is not set
-# CONFIG_NET_SCH_PLUG is not set
-# CONFIG_NET_SCH_PRIO is not set
-# CONFIG_NET_SCH_QFQ is not set
-# CONFIG_NET_SCH_RED is not set
-# CONFIG_NET_SCH_SFB is not set
-# CONFIG_NET_SCH_SFQ is not set
-# CONFIG_NET_SCH_TBF is not set
-# CONFIG_NET_SCH_TEQL is not set
-# CONFIG_NET_SCTPPROBE is not set
-# CONFIG_NET_SWITCHDEV is not set
-# CONFIG_NET_TCPPROBE is not set
-# CONFIG_NET_TEAM is not set
-# CONFIG_NET_TULIP is not set
-# CONFIG_NET_UDP_TUNNEL is not set
-CONFIG_NET_VENDOR_3COM=y
-CONFIG_NET_VENDOR_8390=y
-CONFIG_NET_VENDOR_ADAPTEC=y
-CONFIG_NET_VENDOR_AGERE=y
-CONFIG_NET_VENDOR_ALTEON=y
-CONFIG_NET_VENDOR_AMAZON=y
-CONFIG_NET_VENDOR_AMD=y
-CONFIG_NET_VENDOR_ARC=y
-CONFIG_NET_VENDOR_ATHEROS=y
-CONFIG_NET_VENDOR_AURORA=y
-CONFIG_NET_VENDOR_BROADCOM=y
-CONFIG_NET_VENDOR_BROCADE=y
-CONFIG_NET_VENDOR_CAVIUM=y
-CONFIG_NET_VENDOR_CHELSIO=y
-CONFIG_NET_VENDOR_CIRRUS=y
-CONFIG_NET_VENDOR_CISCO=y
-CONFIG_NET_VENDOR_DEC=y
-CONFIG_NET_VENDOR_DLINK=y
-CONFIG_NET_VENDOR_EMULEX=y
-CONFIG_NET_VENDOR_EXAR=y
-CONFIG_NET_VENDOR_EZCHIP=y
-CONFIG_NET_VENDOR_FARADAY=y
-CONFIG_NET_VENDOR_FREESCALE=y
-CONFIG_NET_VENDOR_FUJITSU=y
-CONFIG_NET_VENDOR_HISILICON=y
-CONFIG_NET_VENDOR_HP=y
-CONFIG_NET_VENDOR_I825XX=y
-CONFIG_NET_VENDOR_IBM=y
-CONFIG_NET_VENDOR_INTEL=y
-CONFIG_NET_VENDOR_MARVELL=y
-CONFIG_NET_VENDOR_MELLANOX=y
-CONFIG_NET_VENDOR_MICREL=y
-CONFIG_NET_VENDOR_MICROCHIP=y
-CONFIG_NET_VENDOR_MYRI=y
-CONFIG_NET_VENDOR_NATSEMI=y
-CONFIG_NET_VENDOR_NETRONOME=y
-CONFIG_NET_VENDOR_NVIDIA=y
-CONFIG_NET_VENDOR_OKI=y
-CONFIG_NET_VENDOR_QLOGIC=y
-CONFIG_NET_VENDOR_QUALCOMM=y
-CONFIG_NET_VENDOR_RDC=y
-CONFIG_NET_VENDOR_REALTEK=y
-CONFIG_NET_VENDOR_RENESAS=y
-CONFIG_NET_VENDOR_ROCKER=y
-CONFIG_NET_VENDOR_SAMSUNG=y
-CONFIG_NET_VENDOR_SEEQ=y
-CONFIG_NET_VENDOR_SILAN=y
-CONFIG_NET_VENDOR_SIS=y
-CONFIG_NET_VENDOR_SMSC=y
-CONFIG_NET_VENDOR_STMICRO=y
-CONFIG_NET_VENDOR_SUN=y
-CONFIG_NET_VENDOR_SYNOPSYS=y
-CONFIG_NET_VENDOR_TEHUTI=y
-CONFIG_NET_VENDOR_TI=y
-CONFIG_NET_VENDOR_TOSHIBA=y
-CONFIG_NET_VENDOR_VIA=y
-CONFIG_NET_VENDOR_WIZNET=y
-CONFIG_NET_VENDOR_XILINX=y
-CONFIG_NET_VENDOR_XIRCOM=y
-# CONFIG_NET_VRF is not set
-# CONFIG_NET_XGENE is not set
-CONFIG_NEW_LEDS=y
-# CONFIG_NFC is not set
-# CONFIG_NFP_NETVF is not set
-# CONFIG_NFSD is not set
-# CONFIG_NFSD_V2_ACL is not set
-CONFIG_NFSD_V3=y
-# CONFIG_NFSD_V3_ACL is not set
-# CONFIG_NFSD_V4 is not set
-# CONFIG_NFS_ACL_SUPPORT is not set
-CONFIG_NFS_COMMON=y
-# CONFIG_NFS_FS is not set
-# CONFIG_NFS_FSCACHE is not set
-# CONFIG_NFS_SWAP is not set
-# CONFIG_NFS_V2 is not set
-CONFIG_NFS_V3=y
-# CONFIG_NFS_V3_ACL is not set
-# CONFIG_NFS_V4 is not set
-# CONFIG_NFS_V4_1 is not set
-# CONFIG_NFTL is not set
-# CONFIG_NFT_BRIDGE_META is not set
-# CONFIG_NFT_BRIDGE_REJECT is not set
-# CONFIG_NFT_DUP_IPV4 is not set
-# CONFIG_NFT_DUP_IPV6 is not set
-# CONFIG_NF_CONNTRACK is not set
-# CONFIG_NF_CONNTRACK_AMANDA is not set
-# CONFIG_NF_CONNTRACK_EVENTS is not set
-# CONFIG_NF_CONNTRACK_FTP is not set
-# CONFIG_NF_CONNTRACK_H323 is not set
-# CONFIG_NF_CONNTRACK_IPV4 is not set
-# CONFIG_NF_CONNTRACK_IPV6 is not set
-# CONFIG_NF_CONNTRACK_IRC is not set
-# CONFIG_NF_CONNTRACK_MARK is not set
-# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
-# CONFIG_NF_CONNTRACK_PPTP is not set
-CONFIG_NF_CONNTRACK_PROCFS=y
-# CONFIG_NF_CONNTRACK_PROC_COMPAT is not set
-# CONFIG_NF_CONNTRACK_SANE is not set
-# CONFIG_NF_CONNTRACK_SIP is not set
-# CONFIG_NF_CONNTRACK_SNMP is not set
-# CONFIG_NF_CONNTRACK_TFTP is not set
-# CONFIG_NF_CONNTRACK_TIMEOUT is not set
-# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
-# CONFIG_NF_CONNTRACK_ZONES is not set
-# CONFIG_NF_CT_NETLINK is not set
-# CONFIG_NF_CT_NETLINK_TIMEOUT is not set
-# CONFIG_NF_CT_PROTO_DCCP is not set
-# CONFIG_NF_CT_PROTO_GRE is not set
-# CONFIG_NF_CT_PROTO_SCTP is not set
-# CONFIG_NF_CT_PROTO_UDPLITE is not set
-# CONFIG_NF_DEFRAG_IPV4 is not set
-# CONFIG_NF_DUP_IPV4 is not set
-# CONFIG_NF_DUP_IPV6 is not set
-# CONFIG_NF_LOG_ARP is not set
-# CONFIG_NF_LOG_IPV4 is not set
-# CONFIG_NF_NAT is not set
-# CONFIG_NF_NAT_AMANDA is not set
-# CONFIG_NF_NAT_FTP is not set
-# CONFIG_NF_NAT_H323 is not set
-# CONFIG_NF_NAT_IPV6 is not set
-# CONFIG_NF_NAT_IRC is not set
-# CONFIG_NF_NAT_MASQUERADE_IPV4 is not set
-# CONFIG_NF_NAT_MASQUERADE_IPV6 is not set
-# CONFIG_NF_NAT_NEEDED is not set
-# CONFIG_NF_NAT_PPTP is not set
-# CONFIG_NF_NAT_PROTO_GRE is not set
-# CONFIG_NF_NAT_SIP is not set
-# CONFIG_NF_NAT_SNMP_BASIC is not set
-# CONFIG_NF_NAT_TFTP is not set
-# CONFIG_NF_REJECT_IPV4 is not set
-# CONFIG_NF_REJECT_IPV6 is not set
-# CONFIG_NF_TABLES is not set
-# CONFIG_NF_TABLES_NETDEV is not set
-# CONFIG_NI65 is not set
-# CONFIG_NI903X_WDT is not set
-# CONFIG_NILFS2_FS is not set
-# CONFIG_NIU is not set
-CONFIG_NLATTR=y
-# CONFIG_NLMON is not set
-# CONFIG_NLM_XLP_BOARD is not set
-# CONFIG_NLM_XLR_BOARD is not set
-# CONFIG_NLS is not set
-# CONFIG_NLS_ASCII is not set
-# CONFIG_NLS_CODEPAGE_1250 is not set
-# CONFIG_NLS_CODEPAGE_1251 is not set
-# CONFIG_NLS_CODEPAGE_437 is not set
-# CONFIG_NLS_CODEPAGE_737 is not set
-# CONFIG_NLS_CODEPAGE_775 is not set
-# CONFIG_NLS_CODEPAGE_850 is not set
-# CONFIG_NLS_CODEPAGE_852 is not set
-# CONFIG_NLS_CODEPAGE_855 is not set
-# CONFIG_NLS_CODEPAGE_857 is not set
-# CONFIG_NLS_CODEPAGE_860 is not set
-# CONFIG_NLS_CODEPAGE_861 is not set
-# CONFIG_NLS_CODEPAGE_862 is not set
-# CONFIG_NLS_CODEPAGE_863 is not set
-# CONFIG_NLS_CODEPAGE_864 is not set
-# CONFIG_NLS_CODEPAGE_865 is not set
-# CONFIG_NLS_CODEPAGE_866 is not set
-# CONFIG_NLS_CODEPAGE_869 is not set
-# CONFIG_NLS_CODEPAGE_874 is not set
-# CONFIG_NLS_CODEPAGE_932 is not set
-# CONFIG_NLS_CODEPAGE_936 is not set
-# CONFIG_NLS_CODEPAGE_949 is not set
-# CONFIG_NLS_CODEPAGE_950 is not set
-CONFIG_NLS_DEFAULT="iso8859-1"
-# CONFIG_NLS_ISO8859_1 is not set
-# CONFIG_NLS_ISO8859_13 is not set
-# CONFIG_NLS_ISO8859_14 is not set
-# CONFIG_NLS_ISO8859_15 is not set
-# CONFIG_NLS_ISO8859_2 is not set
-# CONFIG_NLS_ISO8859_3 is not set
-# CONFIG_NLS_ISO8859_4 is not set
-# CONFIG_NLS_ISO8859_5 is not set
-# CONFIG_NLS_ISO8859_6 is not set
-# CONFIG_NLS_ISO8859_7 is not set
-# CONFIG_NLS_ISO8859_8 is not set
-# CONFIG_NLS_ISO8859_9 is not set
-# CONFIG_NLS_KOI8_R is not set
-# CONFIG_NLS_KOI8_U is not set
-# CONFIG_NLS_MAC_CELTIC is not set
-# CONFIG_NLS_MAC_CENTEURO is not set
-# CONFIG_NLS_MAC_CROATIAN is not set
-# CONFIG_NLS_MAC_CYRILLIC is not set
-# CONFIG_NLS_MAC_GAELIC is not set
-# CONFIG_NLS_MAC_GREEK is not set
-# CONFIG_NLS_MAC_ICELAND is not set
-# CONFIG_NLS_MAC_INUIT is not set
-# CONFIG_NLS_MAC_ROMAN is not set
-# CONFIG_NLS_MAC_ROMANIAN is not set
-# CONFIG_NLS_MAC_TURKISH is not set
-# CONFIG_NLS_UTF8 is not set
-CONFIG_NMI_LOG_BUF_SHIFT=13
-# CONFIG_NOP_USB_XCEIV is not set
-# CONFIG_NORTEL_HERMES is not set
-# CONFIG_NOTIFIER_ERROR_INJECTION is not set
-# CONFIG_NOZOMI is not set
-# CONFIG_NO_BOOTMEM is not set
-# CONFIG_NO_HZ is not set
-# CONFIG_NO_HZ_FULL is not set
-# CONFIG_NO_HZ_IDLE is not set
-# CONFIG_NS83820 is not set
-# CONFIG_NTB is not set
-# CONFIG_NTFS_DEBUG is not set
-# CONFIG_NTFS_FS is not set
-# CONFIG_NTFS_RW is not set
-# CONFIG_NTP_PPS is not set
-# CONFIG_NVM is not set
-# CONFIG_NVMEM is not set
-# CONFIG_NVMEM_IMX_OCOTP is not set
-# CONFIG_NVME_TARGET is not set
-# CONFIG_NVRAM is not set
-# CONFIG_NV_TCO is not set
-# CONFIG_NXP_STB220 is not set
-# CONFIG_NXP_STB225 is not set
-# CONFIG_N_GSM is not set
-# CONFIG_OABI_COMPAT is not set
-# CONFIG_OBS600 is not set
-# CONFIG_OCFS2_FS is not set
-# CONFIG_OF_OVERLAY is not set
-# CONFIG_OF_UNITTEST is not set
-# CONFIG_OMAP2_DSS_DEBUG is not set
-# CONFIG_OMAP2_DSS_DEBUGFS is not set
-# CONFIG_OMAP2_DSS_SDI is not set
-# CONFIG_OMAP_OCP2SCP is not set
-# CONFIG_OMAP_USB2 is not set
-# CONFIG_OMFS_FS is not set
-# CONFIG_OPENVSWITCH is not set
-# CONFIG_OPROFILE is not set
-# CONFIG_OPROFILE_EVENT_MULTIPLEX is not set
-# CONFIG_OPT3001 is not set
-# CONFIG_OPTIMIZE_INLINING is not set
-# CONFIG_ORANGEFS_FS is not set
-# CONFIG_ORION_WATCHDOG is not set
-# CONFIG_OSF_PARTITION is not set
-CONFIG_OVERLAY_FS=y
-# CONFIG_OWL_LOADER is not set
-# CONFIG_P54_COMMON is not set
-# CONFIG_PA12203001 is not set
-CONFIG_PACKET=y
-# CONFIG_PACKET_DIAG is not set
-# CONFIG_PAGE_EXTENSION is not set
-# CONFIG_PAGE_OWNER is not set
-# CONFIG_PAGE_POISONING is not set
-# CONFIG_PAGE_SIZE_16KB is not set
-# CONFIG_PAGE_SIZE_32KB is not set
-CONFIG_PAGE_SIZE_4KB=y
-# CONFIG_PAGE_SIZE_64KB is not set
-# CONFIG_PAGE_SIZE_8KB is not set
-# CONFIG_PALMAS_GPADC is not set
-# CONFIG_PANASONIC_LAPTOP is not set
-# CONFIG_PANEL is not set
-CONFIG_PANIC_ON_OOPS=y
-CONFIG_PANIC_ON_OOPS_VALUE=1
-CONFIG_PANIC_TIMEOUT=1
-# CONFIG_PANTHERLORD_FF is not set
-# CONFIG_PARAVIRT is not set
-# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
-# CONFIG_PARPORT is not set
-# CONFIG_PARPORT_1284 is not set
-# CONFIG_PARPORT_AX88796 is not set
-# CONFIG_PARPORT_GSC is not set
-# CONFIG_PARPORT_PC is not set
-CONFIG_PARTITION_ADVANCED=y
-# CONFIG_PATA_ALI is not set
-# CONFIG_PATA_AMD is not set
-# CONFIG_PATA_ARASAN_CF is not set
-# CONFIG_PATA_ARTOP is not set
-# CONFIG_PATA_ATIIXP is not set
-# CONFIG_PATA_ATP867X is not set
-# CONFIG_PATA_CMD640_PCI is not set
-# CONFIG_PATA_CMD64X is not set
-# CONFIG_PATA_CS5520 is not set
-# CONFIG_PATA_CS5530 is not set
-# CONFIG_PATA_CS5535 is not set
-# CONFIG_PATA_CS5536 is not set
-# CONFIG_PATA_CYPRESS is not set
-# CONFIG_PATA_EFAR is not set
-# CONFIG_PATA_HPT366 is not set
-# CONFIG_PATA_HPT37X is not set
-# CONFIG_PATA_HPT3X2N is not set
-# CONFIG_PATA_HPT3X3 is not set
-# CONFIG_PATA_IMX is not set
-# CONFIG_PATA_ISAPNP is not set
-# CONFIG_PATA_IT8213 is not set
-# CONFIG_PATA_IT821X is not set
-# CONFIG_PATA_JMICRON is not set
-# CONFIG_PATA_LEGACY is not set
-# CONFIG_PATA_MARVELL is not set
-# CONFIG_PATA_MPIIX is not set
-# CONFIG_PATA_NETCELL is not set
-# CONFIG_PATA_NINJA32 is not set
-# CONFIG_PATA_NS87410 is not set
-# CONFIG_PATA_NS87415 is not set
-# CONFIG_PATA_OCTEON_CF is not set
-# CONFIG_PATA_OF_PLATFORM is not set
-# CONFIG_PATA_OLDPIIX is not set
-# CONFIG_PATA_OPTI is not set
-# CONFIG_PATA_OPTIDMA is not set
-# CONFIG_PATA_PCMCIA is not set
-# CONFIG_PATA_PDC2027X is not set
-# CONFIG_PATA_PDC_OLD is not set
-# CONFIG_PATA_PLATFORM is not set
-# CONFIG_PATA_QDI is not set
-# CONFIG_PATA_RADISYS is not set
-# CONFIG_PATA_RDC is not set
-# CONFIG_PATA_RZ1000 is not set
-# CONFIG_PATA_SC1200 is not set
-# CONFIG_PATA_SCH is not set
-# CONFIG_PATA_SERVERWORKS is not set
-# CONFIG_PATA_SIL680 is not set
-# CONFIG_PATA_SIS is not set
-# CONFIG_PATA_TOSHIBA is not set
-# CONFIG_PATA_TRIFLEX is not set
-# CONFIG_PATA_VIA is not set
-# CONFIG_PATA_WINBOND is not set
-# CONFIG_PATA_WINBOND_VLB is not set
-# CONFIG_PC300TOO is not set
-# CONFIG_PCCARD is not set
-# CONFIG_PCH_DMA is not set
-# CONFIG_PCH_GBE is not set
-# CONFIG_PCH_PHUB is not set
-# CONFIG_PCI is not set
-# CONFIG_PCI200SYN is not set
-# CONFIG_PCIEAER_INJECT is not set
-# CONFIG_PCIEASPM is not set
-# CONFIG_PCIEPORTBUS is not set
-# CONFIG_PCIE_ALTERA is not set
-# CONFIG_PCIE_ARMADA_8K is not set
-# CONFIG_PCIE_DPC is not set
-# CONFIG_PCIE_DW_PLAT is not set
-# CONFIG_PCIE_ECRC is not set
-# CONFIG_PCIE_IPROC is not set
-# CONFIG_PCIE_PTM is not set
-# CONFIG_PCIPCWATCHDOG is not set
-# CONFIG_PCI_ATMEL is not set
-# CONFIG_PCI_CNB20LE_QUIRK is not set
-# CONFIG_PCI_DEBUG is not set
-# CONFIG_PCI_DISABLE_COMMON_QUIRKS is not set
-# CONFIG_PCI_HERMES is not set
-# CONFIG_PCI_HOST_GENERIC is not set
-# CONFIG_PCI_HOST_THUNDER_ECAM is not set
-# CONFIG_PCI_HOST_THUNDER_PEM is not set
-# CONFIG_PCI_IOV is not set
-# CONFIG_PCI_LAYERSCAPE is not set
-# CONFIG_PCI_MSI is not set
-# CONFIG_PCI_PASID is not set
-# CONFIG_PCI_PRI is not set
-CONFIG_PCI_QUIRKS=y
-# CONFIG_PCI_REALLOC_ENABLE_AUTO is not set
-# CONFIG_PCI_STUB is not set
-CONFIG_PCI_SYSCALL=y
-# CONFIG_PCMCIA is not set
-# CONFIG_PCMCIA_3C574 is not set
-# CONFIG_PCMCIA_3C589 is not set
-# CONFIG_PCMCIA_AHA152X is not set
-# CONFIG_PCMCIA_ATMEL is not set
-# CONFIG_PCMCIA_AXNET is not set
-# CONFIG_PCMCIA_DEBUG is not set
-# CONFIG_PCMCIA_FDOMAIN is not set
-# CONFIG_PCMCIA_FMVJ18X is not set
-# CONFIG_PCMCIA_HERMES is not set
-# CONFIG_PCMCIA_LOAD_CIS is not set
-# CONFIG_PCMCIA_NINJA_SCSI is not set
-# CONFIG_PCMCIA_NMCLAN is not set
-# CONFIG_PCMCIA_PCNET is not set
-# CONFIG_PCMCIA_QLOGIC is not set
-# CONFIG_PCMCIA_RAYCS is not set
-# CONFIG_PCMCIA_SMC91C92 is not set
-# CONFIG_PCMCIA_SPECTRUM is not set
-# CONFIG_PCMCIA_SYM53C500 is not set
-# CONFIG_PCMCIA_WL3501 is not set
-# CONFIG_PCMCIA_XIRC2PS is not set
-# CONFIG_PCMCIA_XIRCOM is not set
-# CONFIG_PCNET32 is not set
-# CONFIG_PCSPKR_PLATFORM is not set
-# CONFIG_PD6729 is not set
-# CONFIG_PDA_POWER is not set
-# CONFIG_PDC_ADMA is not set
-# CONFIG_PERCPU_TEST is not set
-# CONFIG_PERF_EVENTS is not set
-# CONFIG_PERF_EVENTS_AMD_POWER is not set
-# CONFIG_PERSISTENT_KEYRINGS is not set
-# CONFIG_PHANTOM is not set
-# CONFIG_PHONET is not set
-# CONFIG_PHYLIB is not set
-# CONFIG_PHYS_ADDR_T_64BIT is not set
-# CONFIG_PHY_EXYNOS_DP_VIDEO is not set
-# CONFIG_PHY_EXYNOS_MIPI_VIDEO is not set
-# CONFIG_PHY_PXA_28NM_HSIC is not set
-# CONFIG_PHY_PXA_28NM_USB2 is not set
-# CONFIG_PHY_QCOM_DWC3 is not set
-# CONFIG_PHY_SAMSUNG_USB2 is not set
-# CONFIG_PID_IN_CONTEXTIDR is not set
-# CONFIG_PID_NS is not set
-CONFIG_PINCONF=y
-# CONFIG_PINCTRL is not set
-# CONFIG_PINCTRL_AMD is not set
-# CONFIG_PINCTRL_EXYNOS is not set
-# CONFIG_PINCTRL_EXYNOS5440 is not set
-# CONFIG_PINCTRL_MSM8X74 is not set
-CONFIG_PINCTRL_SINGLE=y
-CONFIG_PINMUX=y
-# CONFIG_PKCS7_MESSAGE_PARSER is not set
-# CONFIG_PL320_MBOX is not set
-# CONFIG_PL330_DMA is not set
-# CONFIG_PLATFORM_MHU is not set
-# CONFIG_PLAT_SPEAR is not set
-# CONFIG_PLIP is not set
-# CONFIG_PLX_HERMES is not set
-# CONFIG_PM is not set
-# CONFIG_PMBUS is not set
-# CONFIG_PMC_MSP is not set
-# CONFIG_PMIC_ADP5520 is not set
-# CONFIG_PMIC_DA903X is not set
-# CONFIG_PM_AUTOSLEEP is not set
-# CONFIG_PM_DEVFREQ is not set
-# CONFIG_PM_WAKELOCKS is not set
-# CONFIG_POSIX_MQUEUE is not set
-# CONFIG_POWERCAP is not set
-# CONFIG_POWER_AVS is not set
-# CONFIG_POWER_RESET is not set
-# CONFIG_POWER_RESET_BRCMKONA is not set
-# CONFIG_POWER_RESET_BRCMSTB is not set
-# CONFIG_POWER_RESET_GPIO is not set
-# CONFIG_POWER_RESET_GPIO_RESTART is not set
-# CONFIG_POWER_RESET_LTC2952 is not set
-# CONFIG_POWER_RESET_RESTART is not set
-# CONFIG_POWER_RESET_SYSCON is not set
-# CONFIG_POWER_RESET_SYSCON_POWEROFF is not set
-# CONFIG_POWER_RESET_VERSATILE is not set
-# CONFIG_POWER_RESET_XGENE is not set
-# CONFIG_POWER_SUPPLY is not set
-# CONFIG_POWER_SUPPLY_DEBUG is not set
-# CONFIG_PPC4xx_GPIO is not set
-# CONFIG_PPC_16K_PAGES is not set
-# CONFIG_PPC_256K_PAGES is not set
-CONFIG_PPC_4K_PAGES=y
-# CONFIG_PPC_64K_PAGES is not set
-CONFIG_PPC_BARRIER_NOSPEC=y
-# CONFIG_PPC_DISABLE_WERROR is not set
-# CONFIG_PPC_EMULATED_STATS is not set
-# CONFIG_PPC_EPAPR_HV_BYTECHAN is not set
-# CONFIG_PPP is not set
-# CONFIG_PPPOATM is not set
-# CONFIG_PPPOE is not set
-# CONFIG_PPPOL2TP is not set
-# CONFIG_PPP_ASYNC is not set
-# CONFIG_PPP_BSDCOMP is not set
-# CONFIG_PPP_DEFLATE is not set
-CONFIG_PPP_FILTER=y
-# CONFIG_PPP_MPPE is not set
-CONFIG_PPP_MULTILINK=y
-# CONFIG_PPP_SYNC_TTY is not set
-# CONFIG_PPS is not set
-# CONFIG_PPS_CLIENT_GPIO is not set
-# CONFIG_PPS_CLIENT_KTIMER is not set
-# CONFIG_PPS_CLIENT_LDISC is not set
-# CONFIG_PPS_CLIENT_PARPORT is not set
-# CONFIG_PPS_DEBUG is not set
-# CONFIG_PPTP is not set
-# CONFIG_PREEMPT is not set
-CONFIG_PREEMPT_NONE=y
-# CONFIG_PREEMPT_TRACER is not set
-# CONFIG_PREEMPT_VOLUNTARY is not set
-CONFIG_PREVENT_FIRMWARE_BUILD=y
-CONFIG_PRINTK=y
-CONFIG_PRINTK_NMI=y
-# CONFIG_PRINTK_TIME is not set
-CONFIG_PRINT_STACK_DEPTH=64
-# CONFIG_PRISM2_USB is not set
-# CONFIG_PRISM54 is not set
-# CONFIG_PROC_CHILDREN is not set
-CONFIG_PROC_FS=y
-# CONFIG_PROC_KCORE is not set
-# CONFIG_PROC_PAGE_MONITOR is not set
-CONFIG_PROC_STRIPPED=y
-CONFIG_PROC_SYSCTL=y
-# CONFIG_PROFILE_ALL_BRANCHES is not set
-# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
-# CONFIG_PROFILING is not set
-# CONFIG_PROVE_LOCKING is not set
-# CONFIG_PROVE_RCU is not set
-# CONFIG_PROVE_RCU_REPEATEDLY is not set
-# CONFIG_PSB6970_PHY is not set
-# CONFIG_PSTORE is not set
-# CONFIG_PTP_1588_CLOCK is not set
-# CONFIG_PTP_1588_CLOCK_IXP46X is not set
-# CONFIG_PTP_1588_CLOCK_PCH is not set
-# CONFIG_PUBLIC_KEY_ALGO_RSA is not set
-# CONFIG_PWM is not set
-# CONFIG_PWM_FSL_FTM is not set
-# CONFIG_PWM_PCA9685 is not set
-CONFIG_PWRSEQ_EMMC=y
-CONFIG_PWRSEQ_SIMPLE=y
-# CONFIG_QCA7000 is not set
-# CONFIG_QCOM_EMAC is not set
-# CONFIG_QCOM_HIDMA is not set
-# CONFIG_QCOM_HIDMA_MGMT is not set
-# CONFIG_QCOM_QDF2400_ERRATUM_0065 is not set
-# CONFIG_QCOM_SPMI_IADC is not set
-# CONFIG_QCOM_SPMI_TEMP_ALARM is not set
-# CONFIG_QCOM_SPMI_VADC is not set
-# CONFIG_QED is not set
-# CONFIG_QLA3XXX is not set
-# CONFIG_QLCNIC is not set
-# CONFIG_QLGE is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_QNX6FS_FS is not set
-# CONFIG_QORIQ_CPUFREQ is not set
-# CONFIG_QORIQ_THERMAL is not set
-# CONFIG_QSEMI_PHY is not set
-# CONFIG_QUEUED_LOCK_STAT is not set
-# CONFIG_QUOTA is not set
-# CONFIG_QUOTACTL is not set
-# CONFIG_QUOTA_DEBUG is not set
-# CONFIG_R3964 is not set
-# CONFIG_R6040 is not set
-# CONFIG_R8169 is not set
-# CONFIG_R8188EU is not set
-# CONFIG_R8712U is not set
-# CONFIG_R8723AU is not set
-# CONFIG_RADIO_ADAPTERS is not set
-# CONFIG_RADIO_AZTECH is not set
-# CONFIG_RADIO_CADET is not set
-# CONFIG_RADIO_GEMTEK is not set
-# CONFIG_RADIO_MAXIRADIO is not set
-# CONFIG_RADIO_RTRACK is not set
-# CONFIG_RADIO_RTRACK2 is not set
-# CONFIG_RADIO_SF16FMI is not set
-# CONFIG_RADIO_SF16FMR2 is not set
-# CONFIG_RADIO_TERRATEC is not set
-# CONFIG_RADIO_TRUST is not set
-# CONFIG_RADIO_TYPHOON is not set
-# CONFIG_RADIO_ZOLTRIX is not set
-# CONFIG_RAID_ATTRS is not set
-# CONFIG_RALINK is not set
-# CONFIG_RANDOM32_SELFTEST is not set
-# CONFIG_RAPIDIO is not set
-# CONFIG_RAS is not set
-# CONFIG_RAW_DRIVER is not set
-# CONFIG_RBTREE_TEST is not set
-CONFIG_RCU_CPU_STALL_TIMEOUT=60
-# CONFIG_RCU_EQS_DEBUG is not set
-# CONFIG_RCU_EXPEDITE_BOOT is not set
-CONFIG_RCU_EXPERT=y
-CONFIG_RCU_FANOUT=32
-CONFIG_RCU_FANOUT_LEAF=16
-# CONFIG_RCU_FAST_NO_HZ is not set
-CONFIG_RCU_KTHREAD_PRIO=0
-# CONFIG_RCU_NOCB_CPU is not set
-# CONFIG_RCU_PERF_TEST is not set
-# CONFIG_RCU_TORTURE_TEST is not set
-CONFIG_RCU_TORTURE_TEST_SLOW_INIT_DELAY=3
-# CONFIG_RCU_TRACE is not set
-# CONFIG_RC_ATI_REMOTE is not set
-# CONFIG_RC_CORE is not set
-# CONFIG_RC_DECODERS is not set
-# CONFIG_RC_LOOPBACK is not set
-# CONFIG_RC_MAP is not set
-# CONFIG_RDS is not set
-# CONFIG_RD_BZIP2 is not set
-# CONFIG_RD_GZIP is not set
-# CONFIG_RD_LZ4 is not set
-# CONFIG_RD_LZMA is not set
-# CONFIG_RD_LZO is not set
-# CONFIG_RD_XZ is not set
-# CONFIG_READABLE_ASM is not set
-# CONFIG_REALTEK_PHY is not set
-# CONFIG_REDWOOD is not set
-# CONFIG_REGMAP is not set
-# CONFIG_REGMAP_I2C is not set
-# CONFIG_REGMAP_MMIO is not set
-# CONFIG_REGMAP_SPI is not set
-# CONFIG_REGULATOR is not set
-# CONFIG_REGULATOR_ACT8865 is not set
-# CONFIG_REGULATOR_AD5398 is not set
-# CONFIG_REGULATOR_ANATOP is not set
-# CONFIG_REGULATOR_DA9210 is not set
-# CONFIG_REGULATOR_DA9211 is not set
-# CONFIG_REGULATOR_DEBUG is not set
-# CONFIG_REGULATOR_FAN53555 is not set
-# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
-# CONFIG_REGULATOR_GPIO is not set
-# CONFIG_REGULATOR_ISL6271A is not set
-# CONFIG_REGULATOR_ISL9305 is not set
-# CONFIG_REGULATOR_LP3971 is not set
-# CONFIG_REGULATOR_LP3972 is not set
-# CONFIG_REGULATOR_LP872X is not set
-# CONFIG_REGULATOR_LP8755 is not set
-# CONFIG_REGULATOR_LTC3589 is not set
-# CONFIG_REGULATOR_LTC3676 is not set
-# CONFIG_REGULATOR_MAX1586 is not set
-# CONFIG_REGULATOR_MAX8649 is not set
-# CONFIG_REGULATOR_MAX8660 is not set
-# CONFIG_REGULATOR_MAX8952 is not set
-# CONFIG_REGULATOR_MAX8973 is not set
-# CONFIG_REGULATOR_MT6311 is not set
-# CONFIG_REGULATOR_PFUZE100 is not set
-# CONFIG_REGULATOR_PV88060 is not set
-# CONFIG_REGULATOR_PV88080 is not set
-# CONFIG_REGULATOR_PV88090 is not set
-# CONFIG_REGULATOR_PWM is not set
-# CONFIG_REGULATOR_TI_ABB is not set
-# CONFIG_REGULATOR_TPS51632 is not set
-# CONFIG_REGULATOR_TPS62360 is not set
-# CONFIG_REGULATOR_TPS65023 is not set
-# CONFIG_REGULATOR_TPS6507X is not set
-# CONFIG_REGULATOR_TPS6524X is not set
-# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
-# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
-# CONFIG_REISERFS_CHECK is not set
-# CONFIG_REISERFS_FS is not set
-# CONFIG_REISERFS_FS_POSIX_ACL is not set
-# CONFIG_REISERFS_FS_SECURITY is not set
-# CONFIG_REISERFS_FS_XATTR is not set
-# CONFIG_REISERFS_PROC_INFO is not set
-# CONFIG_RELAY is not set
-# CONFIG_RELOCATABLE is not set
-# CONFIG_RESET_ATH79 is not set
-# CONFIG_RESET_BERLIN is not set
-# CONFIG_RESET_CONTROLLER is not set
-# CONFIG_RESET_LPC18XX is not set
-# CONFIG_RESET_MESON is not set
-# CONFIG_RESET_PISTACHIO is not set
-# CONFIG_RESET_SOCFPGA is not set
-# CONFIG_RESET_STM32 is not set
-# CONFIG_RESET_SUNXI is not set
-# CONFIG_RESET_ZYNQ is not set
-# CONFIG_RFD_FTL is not set
-CONFIG_RFKILL=y
-# CONFIG_RFKILL_FULL is not set
-# CONFIG_RFKILL_GPIO is not set
-# CONFIG_RFKILL_INPUT is not set
-# CONFIG_RFKILL_LEDS is not set
-# CONFIG_RFKILL_REGULATOR is not set
-# CONFIG_RING_BUFFER_BENCHMARK is not set
-# CONFIG_RING_BUFFER_STARTUP_TEST is not set
-# CONFIG_RMI4_CORE is not set
-# CONFIG_ROCKER is not set
-# CONFIG_ROMFS_FS is not set
-# CONFIG_ROSE is not set
-# CONFIG_RPCSEC_GSS_KRB5 is not set
-# CONFIG_RPR0521 is not set
-# CONFIG_RT2X00 is not set
-# CONFIG_RTC_CLASS is not set
-# CONFIG_RTC_DEBUG is not set
-# CONFIG_RTC_DRV_ABB5ZES3 is not set
-# CONFIG_RTC_DRV_ABX80X is not set
-# CONFIG_RTC_DRV_ARMADA38X is not set
-# CONFIG_RTC_DRV_AU1XXX is not set
-# CONFIG_RTC_DRV_BQ32K is not set
-# CONFIG_RTC_DRV_BQ4802 is not set
-CONFIG_RTC_DRV_CMOS=y
-# CONFIG_RTC_DRV_DS1286 is not set
-# CONFIG_RTC_DRV_DS1302 is not set
-# CONFIG_RTC_DRV_DS1305 is not set
-# CONFIG_RTC_DRV_DS1307 is not set
-# CONFIG_RTC_DRV_DS1307_CENTURY is not set
-# CONFIG_RTC_DRV_DS1307_HWMON is not set
-# CONFIG_RTC_DRV_DS1343 is not set
-# CONFIG_RTC_DRV_DS1347 is not set
-# CONFIG_RTC_DRV_DS1374 is not set
-# CONFIG_RTC_DRV_DS1390 is not set
-# CONFIG_RTC_DRV_DS1511 is not set
-# CONFIG_RTC_DRV_DS1553 is not set
-# CONFIG_RTC_DRV_DS1672 is not set
-# CONFIG_RTC_DRV_DS1685_FAMILY is not set
-# CONFIG_RTC_DRV_DS1742 is not set
-# CONFIG_RTC_DRV_DS2404 is not set
-# CONFIG_RTC_DRV_DS3232 is not set
-# CONFIG_RTC_DRV_DS3234 is not set
-# CONFIG_RTC_DRV_EM3027 is not set
-# CONFIG_RTC_DRV_EP93XX is not set
-# CONFIG_RTC_DRV_FM3130 is not set
-# CONFIG_RTC_DRV_GENERIC is not set
-# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
-# CONFIG_RTC_DRV_HYM8563 is not set
-# CONFIG_RTC_DRV_ISL12022 is not set
-# CONFIG_RTC_DRV_ISL12057 is not set
-# CONFIG_RTC_DRV_ISL1208 is not set
-# CONFIG_RTC_DRV_M41T80 is not set
-# CONFIG_RTC_DRV_M41T93 is not set
-# CONFIG_RTC_DRV_M41T94 is not set
-# CONFIG_RTC_DRV_M48T35 is not set
-# CONFIG_RTC_DRV_M48T59 is not set
-# CONFIG_RTC_DRV_M48T86 is not set
-# CONFIG_RTC_DRV_MAX6900 is not set
-# CONFIG_RTC_DRV_MAX6902 is not set
-# CONFIG_RTC_DRV_MAX6916 is not set
-# CONFIG_RTC_DRV_MCP795 is not set
-# CONFIG_RTC_DRV_MOXART is not set
-# CONFIG_RTC_DRV_MPC5121 is not set
-# CONFIG_RTC_DRV_MSM6242 is not set
-# CONFIG_RTC_DRV_OMAP is not set
-# CONFIG_RTC_DRV_PCF2123 is not set
-# CONFIG_RTC_DRV_PCF2127 is not set
-# CONFIG_RTC_DRV_PCF85063 is not set
-# CONFIG_RTC_DRV_PCF8523 is not set
-# CONFIG_RTC_DRV_PCF8563 is not set
-# CONFIG_RTC_DRV_PCF8583 is not set
-# CONFIG_RTC_DRV_PL030 is not set
-# CONFIG_RTC_DRV_PL031 is not set
-# CONFIG_RTC_DRV_PS3 is not set
-# CONFIG_RTC_DRV_PT7C4338 is not set
-# CONFIG_RTC_DRV_R9701 is not set
-# CONFIG_RTC_DRV_RP5C01 is not set
-# CONFIG_RTC_DRV_RS5C348 is not set
-# CONFIG_RTC_DRV_RS5C372 is not set
-# CONFIG_RTC_DRV_RTC7301 is not set
-# CONFIG_RTC_DRV_RV3029C2 is not set
-# CONFIG_RTC_DRV_RV8803 is not set
-# CONFIG_RTC_DRV_RX4581 is not set
-# CONFIG_RTC_DRV_RX6110 is not set
-# CONFIG_RTC_DRV_RX8010 is not set
-# CONFIG_RTC_DRV_RX8025 is not set
-# CONFIG_RTC_DRV_RX8581 is not set
-# CONFIG_RTC_DRV_S35390A is not set
-# CONFIG_RTC_DRV_SNVS is not set
-# CONFIG_RTC_DRV_STK17TA8 is not set
-# CONFIG_RTC_DRV_SUN6I is not set
-# CONFIG_RTC_DRV_TEST is not set
-# CONFIG_RTC_DRV_V3020 is not set
-# CONFIG_RTC_DRV_X1205 is not set
-# CONFIG_RTC_DRV_XGENE is not set
-# CONFIG_RTC_DRV_ZYNQMP is not set
-CONFIG_RTC_HCTOSYS=y
-CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
-CONFIG_RTC_INTF_DEV=y
-# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
-CONFIG_RTC_INTF_PROC=y
-CONFIG_RTC_INTF_SYSFS=y
-CONFIG_RTC_LIB=y
-CONFIG_RTC_SYSTOHC=y
-CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
-# CONFIG_RTL8180 is not set
-# CONFIG_RTL8187 is not set
-# CONFIG_RTL8192E is not set
-# CONFIG_RTL8192U is not set
-# CONFIG_RTL8306_PHY is not set
-# CONFIG_RTL8366RB_PHY is not set
-# CONFIG_RTL8366S_PHY is not set
-# CONFIG_RTL8366_SMI is not set
-# CONFIG_RTL8366_SMI_DEBUG_FS is not set
-# CONFIG_RTL8367B_PHY is not set
-# CONFIG_RTL8367_PHY is not set
-# CONFIG_RTLLIB is not set
-# CONFIG_RTL_CARDS is not set
-# CONFIG_RTS5208 is not set
-CONFIG_RT_MUTEXES=y
-# CONFIG_RUNTIME_DEBUG is not set
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-CONFIG_RXKAD=y
-# CONFIG_S2IO is not set
-# CONFIG_SAMPLES is not set
-# CONFIG_SAMSUNG_LAPTOP is not set
-# CONFIG_SATA_ACARD_AHCI is not set
-# CONFIG_SATA_AHCI is not set
-# CONFIG_SATA_AHCI_PLATFORM is not set
-# CONFIG_SATA_DWC is not set
-# CONFIG_SATA_FSL is not set
-# CONFIG_SATA_HIGHBANK is not set
-# CONFIG_SATA_INIC162X is not set
-# CONFIG_SATA_MV is not set
-# CONFIG_SATA_NV is not set
-# CONFIG_SATA_PMP is not set
-# CONFIG_SATA_PROMISE is not set
-# CONFIG_SATA_QSTOR is not set
-# CONFIG_SATA_RCAR is not set
-# CONFIG_SATA_SIL is not set
-# CONFIG_SATA_SIL24 is not set
-# CONFIG_SATA_SIS is not set
-# CONFIG_SATA_SVW is not set
-# CONFIG_SATA_SX4 is not set
-# CONFIG_SATA_ULI is not set
-# CONFIG_SATA_VIA is not set
-# CONFIG_SATA_VITESSE is not set
-# CONFIG_SBC_FITPC2_WATCHDOG is not set
-CONFIG_SBITMAP=y
-# CONFIG_SC92031 is not set
-# CONFIG_SCA3000 is not set
-# CONFIG_SCACHE_DEBUGFS is not set
-# CONFIG_SCC is not set
-# CONFIG_SCHEDSTATS is not set
-# CONFIG_SCHED_AUTOGROUP is not set
-# CONFIG_SCHED_DEBUG is not set
-CONFIG_SCHED_HRTICK=y
-# CONFIG_SCHED_MC is not set
-CONFIG_SCHED_OMIT_FRAME_POINTER=y
-# CONFIG_SCHED_SMT is not set
-# CONFIG_SCHED_STACK_END_CHECK is not set
-# CONFIG_SCHED_TRACER is not set
-# CONFIG_SCSI is not set
-# CONFIG_SCSI_3W_9XXX is not set
-# CONFIG_SCSI_3W_SAS is not set
-# CONFIG_SCSI_7000FASST is not set
-# CONFIG_SCSI_AACRAID is not set
-# CONFIG_SCSI_ACARD is not set
-# CONFIG_SCSI_ADVANSYS is not set
-# CONFIG_SCSI_AHA152X is not set
-# CONFIG_SCSI_AHA1542 is not set
-# CONFIG_SCSI_AIC79XX is not set
-# CONFIG_SCSI_AIC7XXX is not set
-# CONFIG_SCSI_AIC94XX is not set
-# CONFIG_SCSI_AM53C974 is not set
-# CONFIG_SCSI_ARCMSR is not set
-# CONFIG_SCSI_BFA_FC is not set
-# CONFIG_SCSI_BNX2X_FCOE is not set
-# CONFIG_SCSI_BNX2_ISCSI is not set
-# CONFIG_SCSI_BUSLOGIC is not set
-# CONFIG_SCSI_CHELSIO_FCOE is not set
-# CONFIG_SCSI_CONSTANTS is not set
-# CONFIG_SCSI_CXGB3_ISCSI is not set
-# CONFIG_SCSI_CXGB4_ISCSI is not set
-# CONFIG_SCSI_DC395x is not set
-# CONFIG_SCSI_DEBUG is not set
-# CONFIG_SCSI_DH is not set
-CONFIG_SCSI_DMA=y
-# CONFIG_SCSI_DMX3191D is not set
-# CONFIG_SCSI_DPT_I2O is not set
-# CONFIG_SCSI_DTC3280 is not set
-# CONFIG_SCSI_EATA is not set
-# CONFIG_SCSI_ESAS2R is not set
-# CONFIG_SCSI_FC_ATTRS is not set
-# CONFIG_SCSI_FUTURE_DOMAIN is not set
-# CONFIG_SCSI_GDTH is not set
-# CONFIG_SCSI_GENERIC_NCR5380 is not set
-# CONFIG_SCSI_GENERIC_NCR5380_MMIO is not set
-# CONFIG_SCSI_HISI_SAS is not set
-# CONFIG_SCSI_HPSA is not set
-# CONFIG_SCSI_HPTIOP is not set
-# CONFIG_SCSI_IN2000 is not set
-# CONFIG_SCSI_INIA100 is not set
-# CONFIG_SCSI_INITIO is not set
-# CONFIG_SCSI_IPR is not set
-# CONFIG_SCSI_IPS is not set
-# CONFIG_SCSI_ISCI is not set
-# CONFIG_SCSI_ISCSI_ATTRS is not set
-# CONFIG_SCSI_LOGGING is not set
-CONFIG_SCSI_LOWLEVEL=y
-# CONFIG_SCSI_LOWLEVEL_PCMCIA is not set
-# CONFIG_SCSI_LPFC is not set
-CONFIG_SCSI_MOD=y
-# CONFIG_SCSI_MPT2SAS is not set
-# CONFIG_SCSI_MPT3SAS is not set
-# CONFIG_SCSI_MQ_DEFAULT is not set
-# CONFIG_SCSI_MVSAS is not set
-# CONFIG_SCSI_MVSAS_DEBUG is not set
-# CONFIG_SCSI_MVUMI is not set
-# CONFIG_SCSI_NCR53C406A is not set
-# CONFIG_SCSI_NETLINK is not set
-# CONFIG_SCSI_NSP32 is not set
-# CONFIG_SCSI_OSD_INITIATOR is not set
-# CONFIG_SCSI_PAS16 is not set
-# CONFIG_SCSI_PM8001 is not set
-# CONFIG_SCSI_PMCRAID is not set
-CONFIG_SCSI_PROC_FS=y
-# CONFIG_SCSI_QLA_FC is not set
-# CONFIG_SCSI_QLA_ISCSI is not set
-# CONFIG_SCSI_QLOGIC_1280 is not set
-# CONFIG_SCSI_QLOGIC_FAS is not set
-# CONFIG_SCSI_SAS_ATTRS is not set
-# CONFIG_SCSI_SAS_LIBSAS is not set
-# CONFIG_SCSI_SCAN_ASYNC is not set
-# CONFIG_SCSI_SMARTPQI is not set
-# CONFIG_SCSI_SNIC is not set
-# CONFIG_SCSI_SPI_ATTRS is not set
-# CONFIG_SCSI_SRP_ATTRS is not set
-# CONFIG_SCSI_STEX is not set
-# CONFIG_SCSI_SYM53C416 is not set
-# CONFIG_SCSI_SYM53C8XX_2 is not set
-# CONFIG_SCSI_T128 is not set
-# CONFIG_SCSI_U14_34F is not set
-# CONFIG_SCSI_UFSHCD is not set
-# CONFIG_SCSI_ULTRASTOR is not set
-# CONFIG_SCSI_VIRTIO is not set
-# CONFIG_SCSI_WD719X is not set
-# CONFIG_SCx200_ACB is not set
-# CONFIG_SDIO_UART is not set
-# CONFIG_SECCOMP is not set
-CONFIG_SECTION_MISMATCH_WARN_ONLY=y
-# CONFIG_SECURITY is not set
-# CONFIG_SECURITYFS is not set
-CONFIG_SECURITY_DMESG_RESTRICT=y
-CONFIG_SELECT_MEMORY_MODEL=y
-# CONFIG_SENSORS_ABITUGURU is not set
-# CONFIG_SENSORS_ABITUGURU3 is not set
-# CONFIG_SENSORS_ACPI_POWER is not set
-# CONFIG_SENSORS_AD7314 is not set
-# CONFIG_SENSORS_AD7414 is not set
-# CONFIG_SENSORS_AD7418 is not set
-# CONFIG_SENSORS_ADC128D818 is not set
-# CONFIG_SENSORS_ADCXX is not set
-# CONFIG_SENSORS_ADM1021 is not set
-# CONFIG_SENSORS_ADM1025 is not set
-# CONFIG_SENSORS_ADM1026 is not set
-# CONFIG_SENSORS_ADM1029 is not set
-# CONFIG_SENSORS_ADM1031 is not set
-# CONFIG_SENSORS_ADM9240 is not set
-# CONFIG_SENSORS_ADS1015 is not set
-# CONFIG_SENSORS_ADS7828 is not set
-# CONFIG_SENSORS_ADS7871 is not set
-# CONFIG_SENSORS_ADT7310 is not set
-# CONFIG_SENSORS_ADT7410 is not set
-# CONFIG_SENSORS_ADT7411 is not set
-# CONFIG_SENSORS_ADT7462 is not set
-# CONFIG_SENSORS_ADT7470 is not set
-# CONFIG_SENSORS_ADT7475 is not set
-# CONFIG_SENSORS_AMC6821 is not set
-# CONFIG_SENSORS_APDS990X is not set
-# CONFIG_SENSORS_APPLESMC is not set
-# CONFIG_SENSORS_ASB100 is not set
-# CONFIG_SENSORS_ASC7621 is not set
-# CONFIG_SENSORS_ATK0110 is not set
-# CONFIG_SENSORS_ATXP1 is not set
-# CONFIG_SENSORS_BH1770 is not set
-# CONFIG_SENSORS_BH1780 is not set
-# CONFIG_SENSORS_CORETEMP is not set
-# CONFIG_SENSORS_DELL_SMM is not set
-# CONFIG_SENSORS_DME1737 is not set
-# CONFIG_SENSORS_DS1621 is not set
-# CONFIG_SENSORS_DS620 is not set
-# CONFIG_SENSORS_EMC1403 is not set
-# CONFIG_SENSORS_EMC2103 is not set
-# CONFIG_SENSORS_EMC6W201 is not set
-# CONFIG_SENSORS_F71805F is not set
-# CONFIG_SENSORS_F71882FG is not set
-# CONFIG_SENSORS_F75375S is not set
-# CONFIG_SENSORS_FAM15H_POWER is not set
-# CONFIG_SENSORS_FSCHMD is not set
-# CONFIG_SENSORS_FTSTEUTATES is not set
-# CONFIG_SENSORS_G760A is not set
-# CONFIG_SENSORS_G762 is not set
-# CONFIG_SENSORS_GL518SM is not set
-# CONFIG_SENSORS_GL520SM is not set
-# CONFIG_SENSORS_GPIO_FAN is not set
-# CONFIG_SENSORS_GSC is not set
-# CONFIG_SENSORS_HDAPS is not set
-# CONFIG_SENSORS_HIH6130 is not set
-# CONFIG_SENSORS_HMC5843 is not set
-# CONFIG_SENSORS_HMC5843_I2C is not set
-# CONFIG_SENSORS_HMC5843_SPI is not set
-# CONFIG_SENSORS_HTU21 is not set
-# CONFIG_SENSORS_I5500 is not set
-# CONFIG_SENSORS_I5K_AMB is not set
-# CONFIG_SENSORS_IIO_HWMON is not set
-# CONFIG_SENSORS_INA209 is not set
-# CONFIG_SENSORS_INA2XX is not set
-# CONFIG_SENSORS_INA3221 is not set
-# CONFIG_SENSORS_ISL29018 is not set
-# CONFIG_SENSORS_ISL29028 is not set
-# CONFIG_SENSORS_IT87 is not set
-# CONFIG_SENSORS_JC42 is not set
-# CONFIG_SENSORS_K10TEMP is not set
-# CONFIG_SENSORS_K8TEMP is not set
-# CONFIG_SENSORS_LINEAGE is not set
-# CONFIG_SENSORS_LIS3LV02D is not set
-# CONFIG_SENSORS_LIS3_I2C is not set
-# CONFIG_SENSORS_LIS3_SPI is not set
-# CONFIG_SENSORS_LM63 is not set
-# CONFIG_SENSORS_LM70 is not set
-# CONFIG_SENSORS_LM73 is not set
-# CONFIG_SENSORS_LM75 is not set
-# CONFIG_SENSORS_LM77 is not set
-# CONFIG_SENSORS_LM78 is not set
-# CONFIG_SENSORS_LM80 is not set
-# CONFIG_SENSORS_LM83 is not set
-# CONFIG_SENSORS_LM85 is not set
-# CONFIG_SENSORS_LM87 is not set
-# CONFIG_SENSORS_LM90 is not set
-# CONFIG_SENSORS_LM92 is not set
-# CONFIG_SENSORS_LM93 is not set
-# CONFIG_SENSORS_LM95234 is not set
-# CONFIG_SENSORS_LM95241 is not set
-# CONFIG_SENSORS_LM95245 is not set
-# CONFIG_SENSORS_LTC2945 is not set
-# CONFIG_SENSORS_LTC2990 is not set
-# CONFIG_SENSORS_LTC4151 is not set
-# CONFIG_SENSORS_LTC4215 is not set
-# CONFIG_SENSORS_LTC4222 is not set
-# CONFIG_SENSORS_LTC4245 is not set
-# CONFIG_SENSORS_LTC4260 is not set
-# CONFIG_SENSORS_LTC4261 is not set
-# CONFIG_SENSORS_MAX1111 is not set
-# CONFIG_SENSORS_MAX16065 is not set
-# CONFIG_SENSORS_MAX1619 is not set
-# CONFIG_SENSORS_MAX1668 is not set
-# CONFIG_SENSORS_MAX197 is not set
-# CONFIG_SENSORS_MAX31722 is not set
-# CONFIG_SENSORS_MAX31790 is not set
-# CONFIG_SENSORS_MAX6639 is not set
-# CONFIG_SENSORS_MAX6642 is not set
-# CONFIG_SENSORS_MAX6650 is not set
-# CONFIG_SENSORS_MAX6697 is not set
-# CONFIG_SENSORS_MCP3021 is not set
-# CONFIG_SENSORS_NCT6683 is not set
-# CONFIG_SENSORS_NCT6775 is not set
-# CONFIG_SENSORS_NCT7802 is not set
-# CONFIG_SENSORS_NCT7904 is not set
-# CONFIG_SENSORS_NSA320 is not set
-# CONFIG_SENSORS_NTC_THERMISTOR is not set
-# CONFIG_SENSORS_PC87360 is not set
-# CONFIG_SENSORS_PC87427 is not set
-# CONFIG_SENSORS_PCF8591 is not set
-# CONFIG_SENSORS_POWR1220 is not set
-# CONFIG_SENSORS_PWM_FAN is not set
-# CONFIG_SENSORS_SCH5627 is not set
-# CONFIG_SENSORS_SCH5636 is not set
-# CONFIG_SENSORS_SCH56XX_COMMON is not set
-# CONFIG_SENSORS_SHT15 is not set
-# CONFIG_SENSORS_SHT21 is not set
-# CONFIG_SENSORS_SHT3x is not set
-# CONFIG_SENSORS_SHTC1 is not set
-# CONFIG_SENSORS_SIS5595 is not set
-# CONFIG_SENSORS_SMM665 is not set
-# CONFIG_SENSORS_SMSC47B397 is not set
-# CONFIG_SENSORS_SMSC47M1 is not set
-# CONFIG_SENSORS_SMSC47M192 is not set
-# CONFIG_SENSORS_TC74 is not set
-# CONFIG_SENSORS_THMC50 is not set
-# CONFIG_SENSORS_TMP102 is not set
-# CONFIG_SENSORS_TMP103 is not set
-# CONFIG_SENSORS_TMP401 is not set
-# CONFIG_SENSORS_TMP421 is not set
-# CONFIG_SENSORS_TSL2550 is not set
-# CONFIG_SENSORS_TSL2563 is not set
-# CONFIG_SENSORS_VEXPRESS is not set
-# CONFIG_SENSORS_VIA686A is not set
-# CONFIG_SENSORS_VIA_CPUTEMP is not set
-# CONFIG_SENSORS_VT1211 is not set
-# CONFIG_SENSORS_VT8231 is not set
-# CONFIG_SENSORS_W83627EHF is not set
-# CONFIG_SENSORS_W83627HF is not set
-# CONFIG_SENSORS_W83781D is not set
-# CONFIG_SENSORS_W83791D is not set
-# CONFIG_SENSORS_W83792D is not set
-# CONFIG_SENSORS_W83793 is not set
-# CONFIG_SENSORS_W83795 is not set
-# CONFIG_SENSORS_W83L785TS is not set
-# CONFIG_SENSORS_W83L786NG is not set
-# CONFIG_SENSORS_XGENE is not set
-CONFIG_SERIAL_8250=y
-# CONFIG_SERIAL_8250_ACCENT is not set
-# CONFIG_SERIAL_8250_BOCA is not set
-CONFIG_SERIAL_8250_CONSOLE=y
-# CONFIG_SERIAL_8250_CS is not set
-# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
-# CONFIG_SERIAL_8250_DETECT_IRQ is not set
-CONFIG_SERIAL_8250_DMA=y
-# CONFIG_SERIAL_8250_DW is not set
-# CONFIG_SERIAL_8250_EM is not set
-# CONFIG_SERIAL_8250_EXAR_ST16C554 is not set
-# CONFIG_SERIAL_8250_EXTENDED is not set
-# CONFIG_SERIAL_8250_FINTEK is not set
-# CONFIG_SERIAL_8250_FOURPORT is not set
-# CONFIG_SERIAL_8250_HUB6 is not set
-# CONFIG_SERIAL_8250_INGENIC is not set
-# CONFIG_SERIAL_8250_LPSS is not set
-# CONFIG_SERIAL_8250_MANY_PORTS is not set
-# CONFIG_SERIAL_8250_MID is not set
-# CONFIG_SERIAL_8250_MOXA is not set
-CONFIG_SERIAL_8250_NR_UARTS=2
-# CONFIG_SERIAL_8250_PCI is not set
-# CONFIG_SERIAL_8250_RSA is not set
-# CONFIG_SERIAL_8250_RT288X is not set
-CONFIG_SERIAL_8250_RUNTIME_UARTS=2
-# CONFIG_SERIAL_ALTERA_JTAGUART is not set
-# CONFIG_SERIAL_ALTERA_UART is not set
-# CONFIG_SERIAL_AMBA_PL010 is not set
-# CONFIG_SERIAL_ARC is not set
-# CONFIG_SERIAL_BCM63XX is not set
-# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
-CONFIG_SERIAL_CORE=y
-CONFIG_SERIAL_CORE_CONSOLE=y
-CONFIG_SERIAL_EARLYCON=y
-# CONFIG_SERIAL_EARLYCON_ARM_SEMIHOST is not set
-# CONFIG_SERIAL_FSL_LPUART is not set
-# CONFIG_SERIAL_GRLIB_GAISLER_APBUART is not set
-# CONFIG_SERIAL_IFX6X60 is not set
-# CONFIG_SERIAL_JSM is not set
-# CONFIG_SERIAL_MAX3100 is not set
-# CONFIG_SERIAL_MAX310X is not set
-# CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_SERIAL_OF_PLATFORM is not set
-# CONFIG_SERIAL_OF_PLATFORM_NWPSERIAL is not set
-# CONFIG_SERIAL_PCH_UART is not set
-# CONFIG_SERIAL_RP2 is not set
-# CONFIG_SERIAL_SC16IS7XX is not set
-# CONFIG_SERIAL_SCCNXP is not set
-# CONFIG_SERIAL_SH_SCI is not set
-# CONFIG_SERIAL_STM32 is not set
-# CONFIG_SERIAL_ST_ASC is not set
-# CONFIG_SERIAL_TIMBERDALE is not set
-# CONFIG_SERIAL_UARTLITE is not set
-# CONFIG_SERIAL_XILINX_PS_UART is not set
-# CONFIG_SERIO is not set
-# CONFIG_SERIO_ALTERA_PS2 is not set
-# CONFIG_SERIO_AMBAKMI is not set
-# CONFIG_SERIO_APBPS2 is not set
-# CONFIG_SERIO_ARC_PS2 is not set
-# CONFIG_SERIO_I8042 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-# CONFIG_SERIO_PARKBD is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_PS2MULT is not set
-# CONFIG_SERIO_RAW is not set
-# CONFIG_SERIO_SERPORT is not set
-# CONFIG_SERIO_SUN4I_PS2 is not set
-# CONFIG_SFC is not set
-# CONFIG_SFI is not set
-# CONFIG_SGETMASK_SYSCALL is not set
-# CONFIG_SGI_IOC4 is not set
-# CONFIG_SGI_IP22 is not set
-# CONFIG_SGI_IP27 is not set
-# CONFIG_SGI_IP28 is not set
-# CONFIG_SGI_IP32 is not set
-# CONFIG_SGI_PARTITION is not set
-# CONFIG_SG_POOL is not set
-# CONFIG_SG_SPLIT is not set
-CONFIG_SHMEM=y
-# CONFIG_SH_ETH is not set
-# CONFIG_SH_TIMER_CMT is not set
-# CONFIG_SH_TIMER_MTU2 is not set
-# CONFIG_SH_TIMER_TMU is not set
-# CONFIG_SI1145 is not set
-# CONFIG_SI7005 is not set
-# CONFIG_SI7020 is not set
-# CONFIG_SIBYTE_BIGSUR is not set
-# CONFIG_SIBYTE_CARMEL is not set
-# CONFIG_SIBYTE_CRHINE is not set
-# CONFIG_SIBYTE_CRHONE is not set
-# CONFIG_SIBYTE_LITTLESUR is not set
-# CONFIG_SIBYTE_RHONE is not set
-# CONFIG_SIBYTE_SENTOSA is not set
-# CONFIG_SIBYTE_SWARM is not set
-CONFIG_SIGNALFD=y
-# CONFIG_SIGNED_PE_FILE_VERIFICATION is not set
-# CONFIG_SIMPLE_GPIO is not set
-# CONFIG_SIS190 is not set
-# CONFIG_SIS900 is not set
-# CONFIG_SKGE is not set
-# CONFIG_SKY2 is not set
-# CONFIG_SKY2_DEBUG is not set
-# CONFIG_SLAB is not set
-CONFIG_SLABINFO=y
-# CONFIG_SLAB_FREELIST_RANDOM is not set
-# CONFIG_SLHC is not set
-# CONFIG_SLICOSS is not set
-# CONFIG_SLIP is not set
-# CONFIG_SLOB is not set
-CONFIG_SLUB=y
-CONFIG_SLUB_CPU_PARTIAL=y
-# CONFIG_SLUB_DEBUG is not set
-# CONFIG_SLUB_DEBUG_ON is not set
-# CONFIG_SLUB_STATS is not set
-# CONFIG_SMARTJOYPLUS_FF is not set
-# CONFIG_SMC911X is not set
-# CONFIG_SMC9194 is not set
-# CONFIG_SMC91X is not set
-# CONFIG_SMP is not set
-# CONFIG_SMSC911X is not set
-# CONFIG_SMSC9420 is not set
-# CONFIG_SMSC_PHY is not set
-# CONFIG_SM_FTL is not set
-# CONFIG_SND is not set
-# CONFIG_SND_AC97_POWER_SAVE is not set
-# CONFIG_SND_AD1816A is not set
-# CONFIG_SND_AD1848 is not set
-# CONFIG_SND_AD1889 is not set
-# CONFIG_SND_ADLIB is not set
-# CONFIG_SND_ALI5451 is not set
-# CONFIG_SND_ALOOP is not set
-# CONFIG_SND_ALS100 is not set
-# CONFIG_SND_ALS300 is not set
-# CONFIG_SND_ALS4000 is not set
-# CONFIG_SND_ARM is not set
-# CONFIG_SND_ASIHPI is not set
-# CONFIG_SND_ATIIXP is not set
-# CONFIG_SND_ATIIXP_MODEM is not set
-# CONFIG_SND_ATMEL_AC97C is not set
-# CONFIG_SND_ATMEL_SOC is not set
-# CONFIG_SND_AU8810 is not set
-# CONFIG_SND_AU8820 is not set
-# CONFIG_SND_AU8830 is not set
-# CONFIG_SND_AW2 is not set
-# CONFIG_SND_AZT2320 is not set
-# CONFIG_SND_AZT3328 is not set
-# CONFIG_SND_BCD2000 is not set
-# CONFIG_SND_BT87X is not set
-# CONFIG_SND_CA0106 is not set
-# CONFIG_SND_CMI8330 is not set
-# CONFIG_SND_CMIPCI is not set
-# CONFIG_SND_CS4231 is not set
-# CONFIG_SND_CS4236 is not set
-# CONFIG_SND_CS4281 is not set
-# CONFIG_SND_CS46XX is not set
-# CONFIG_SND_CS5530 is not set
-# CONFIG_SND_CS5535AUDIO is not set
-# CONFIG_SND_CTXFI is not set
-# CONFIG_SND_DARLA20 is not set
-# CONFIG_SND_DARLA24 is not set
-# CONFIG_SND_DEBUG is not set
-# CONFIG_SND_DESIGNWARE_I2S is not set
-CONFIG_SND_DRIVERS=y
-# CONFIG_SND_DUMMY is not set
-# CONFIG_SND_DYNAMIC_MINORS is not set
-# CONFIG_SND_ECHO3G is not set
-# CONFIG_SND_EDMA_SOC is not set
-# CONFIG_SND_EMU10K1 is not set
-# CONFIG_SND_EMU10K1X is not set
-# CONFIG_SND_EMU10K1_SEQ is not set
-# CONFIG_SND_ENS1370 is not set
-# CONFIG_SND_ENS1371 is not set
-# CONFIG_SND_ES1688 is not set
-# CONFIG_SND_ES18XX is not set
-# CONFIG_SND_ES1938 is not set
-# CONFIG_SND_ES1968 is not set
-# CONFIG_SND_FIREWIRE is not set
-# CONFIG_SND_FM801 is not set
-# CONFIG_SND_GINA20 is not set
-# CONFIG_SND_GINA24 is not set
-# CONFIG_SND_GUSCLASSIC is not set
-# CONFIG_SND_GUSEXTREME is not set
-# CONFIG_SND_GUSMAX is not set
-# CONFIG_SND_HDA_INTEL is not set
-CONFIG_SND_HDA_POWER_SAVE_DEFAULT=0
-CONFIG_SND_HDA_PREALLOC_SIZE=64
-# CONFIG_SND_HDSP is not set
-# CONFIG_SND_HDSPM is not set
-# CONFIG_SND_HRTIMER is not set
-# CONFIG_SND_HWDEP is not set
-# CONFIG_SND_ICE1712 is not set
-# CONFIG_SND_ICE1724 is not set
-# CONFIG_SND_INDIGO is not set
-# CONFIG_SND_INDIGODJ is not set
-# CONFIG_SND_INDIGODJX is not set
-# CONFIG_SND_INDIGOIO is not set
-# CONFIG_SND_INDIGOIOX is not set
-# CONFIG_SND_INTEL8X0 is not set
-# CONFIG_SND_INTEL8X0M is not set
-# CONFIG_SND_INTERWAVE is not set
-# CONFIG_SND_INTERWAVE_STB is not set
-# CONFIG_SND_ISA is not set
-# CONFIG_SND_KIRKWOOD_SOC is not set
-# CONFIG_SND_KORG1212 is not set
-# CONFIG_SND_LAYLA20 is not set
-# CONFIG_SND_LAYLA24 is not set
-# CONFIG_SND_LOLA is not set
-# CONFIG_SND_LX6464ES is not set
-# CONFIG_SND_MAESTRO3 is not set
-# CONFIG_SND_MIA is not set
-# CONFIG_SND_MIPS is not set
-# CONFIG_SND_MIRO is not set
-# CONFIG_SND_MIXART is not set
-# CONFIG_SND_MIXER_OSS is not set
-# CONFIG_SND_MONA is not set
-# CONFIG_SND_MPC52xx_SOC_EFIKA is not set
-# CONFIG_SND_MPU401 is not set
-# CONFIG_SND_MTPAV is not set
-# CONFIG_SND_MTS64 is not set
-# CONFIG_SND_MXS_SOC is not set
-# CONFIG_SND_NM256 is not set
-# CONFIG_SND_OPL3SA2 is not set
-# CONFIG_SND_OPL3_LIB_SEQ is not set
-# CONFIG_SND_OPL4_LIB_SEQ is not set
-# CONFIG_SND_OPTI92X_AD1848 is not set
-# CONFIG_SND_OPTI92X_CS4231 is not set
-# CONFIG_SND_OPTI93X is not set
-CONFIG_SND_OSSEMUL=y
-# CONFIG_SND_OXYGEN is not set
-CONFIG_SND_PCI=y
-# CONFIG_SND_PCM is not set
-# CONFIG_SND_PCMCIA is not set
-# CONFIG_SND_PCM_OSS is not set
-CONFIG_SND_PCM_OSS_PLUGINS=y
-# CONFIG_SND_PCM_TIMER is not set
-# CONFIG_SND_PCM_XRUN_DEBUG is not set
-# CONFIG_SND_PCXHR is not set
-# CONFIG_SND_PDAUDIOCF is not set
-# CONFIG_SND_PORTMAN2X4 is not set
-# CONFIG_SND_POWERPC_SOC is not set
-# CONFIG_SND_PPC is not set
-CONFIG_SND_PROC_FS=y
-# CONFIG_SND_RAWMIDI is not set
-# CONFIG_SND_RAWMIDI_SEQ is not set
-# CONFIG_SND_RIPTIDE is not set
-# CONFIG_SND_RME32 is not set
-# CONFIG_SND_RME96 is not set
-# CONFIG_SND_RME9652 is not set
-# CONFIG_SND_RTCTIMER is not set
-# CONFIG_SND_SB16 is not set
-# CONFIG_SND_SB8 is not set
-# CONFIG_SND_SBAWE is not set
-# CONFIG_SND_SBAWE_SEQ is not set
-# CONFIG_SND_SE6X is not set
-# CONFIG_SND_SEQUENCER is not set
-# CONFIG_SND_SERIAL_U16550 is not set
-# CONFIG_SND_SIMPLE_CARD is not set
-# CONFIG_SND_SIMPLE_SCU_CARD is not set
-# CONFIG_SND_SIS7019 is not set
-# CONFIG_SND_SOC is not set
-# CONFIG_SND_SOC_AC97_CODEC is not set
-# CONFIG_SND_SOC_ADAU1701 is not set
-# CONFIG_SND_SOC_ADAU7002 is not set
-# CONFIG_SND_SOC_AK4104 is not set
-# CONFIG_SND_SOC_AK4554 is not set
-# CONFIG_SND_SOC_AK4613 is not set
-# CONFIG_SND_SOC_AK4642 is not set
-# CONFIG_SND_SOC_AK5386 is not set
-# CONFIG_SND_SOC_ALC5623 is not set
-# CONFIG_SND_SOC_AMD_ACP is not set
-# CONFIG_SND_SOC_AU1XAUDIO is not set
-# CONFIG_SND_SOC_AU1XPSC is not set
-# CONFIG_SND_SOC_BT_SCO is not set
-# CONFIG_SND_SOC_CS35L32 is not set
-# CONFIG_SND_SOC_CS35L33 is not set
-# CONFIG_SND_SOC_CS4265 is not set
-# CONFIG_SND_SOC_CS4270 is not set
-# CONFIG_SND_SOC_CS4271 is not set
-# CONFIG_SND_SOC_CS4271_I2C is not set
-# CONFIG_SND_SOC_CS4271_SPI is not set
-# CONFIG_SND_SOC_CS42L51_I2C is not set
-# CONFIG_SND_SOC_CS42L52 is not set
-# CONFIG_SND_SOC_CS42L56 is not set
-# CONFIG_SND_SOC_CS42L73 is not set
-# CONFIG_SND_SOC_CS42XX8_I2C is not set
-# CONFIG_SND_SOC_CS4349 is not set
-# CONFIG_SND_SOC_CS53L30 is not set
-# CONFIG_SND_SOC_ES8328 is not set
-# CONFIG_SND_SOC_EUKREA_TLV320 is not set
-# CONFIG_SND_SOC_FSL_ASOC_CARD is not set
-# CONFIG_SND_SOC_FSL_ASRC is not set
-# CONFIG_SND_SOC_FSL_ESAI is not set
-# CONFIG_SND_SOC_FSL_SAI is not set
-# CONFIG_SND_SOC_FSL_SPDIF is not set
-# CONFIG_SND_SOC_FSL_SSI is not set
-# CONFIG_SND_SOC_GTM601 is not set
-# CONFIG_SND_SOC_ICS43432 is not set
-# CONFIG_SND_SOC_IMG is not set
-# CONFIG_SND_SOC_IMX_AUDMUX is not set
-# CONFIG_SND_SOC_IMX_ES8328 is not set
-# CONFIG_SND_SOC_IMX_SPDIF is not set
-# CONFIG_SND_SOC_IMX_WM8962 is not set
-# CONFIG_SND_SOC_INNO_RK3036 is not set
-# CONFIG_SND_SOC_INTEL_BDW_RT5677_MACH is not set
-# CONFIG_SND_SOC_INTEL_BXT_DA7219_MAX98357A_MACH is not set
-# CONFIG_SND_SOC_INTEL_BXT_RT298_MACH is not set
-# CONFIG_SND_SOC_INTEL_BYTCR_RT5640_MACH is not set
-# CONFIG_SND_SOC_INTEL_BYTCR_RT5651_MACH is not set
-# CONFIG_SND_SOC_INTEL_BYT_MAX98090_MACH is not set
-# CONFIG_SND_SOC_INTEL_BYT_RT5640_MACH is not set
-# CONFIG_SND_SOC_INTEL_CHT_BSW_MAX98090_TI_MACH is not set
-# CONFIG_SND_SOC_INTEL_CHT_BSW_RT5645_MACH is not set
-# CONFIG_SND_SOC_INTEL_CHT_BSW_RT5672_MACH is not set
-# CONFIG_SND_SOC_INTEL_SKL_NAU88L25_MAX98357A_MACH is not set
-# CONFIG_SND_SOC_INTEL_SKL_NAU88L25_SSM4567_MACH is not set
-# CONFIG_SND_SOC_INTEL_SKL_RT286_MACH is not set
-# CONFIG_SND_SOC_INTEL_SST is not set
-# CONFIG_SND_SOC_MAX98504 is not set
-# CONFIG_SND_SOC_MAX9860 is not set
-# CONFIG_SND_SOC_MEDIATEK is not set
-# CONFIG_SND_SOC_MPC5200_AC97 is not set
-# CONFIG_SND_SOC_MPC5200_I2S is not set
-# CONFIG_SND_SOC_MT2701 is not set
-# CONFIG_SND_SOC_MT8173 is not set
-# CONFIG_SND_SOC_NAU8810 is not set
-# CONFIG_SND_SOC_PCM1681 is not set
-# CONFIG_SND_SOC_PCM1792A is not set
-# CONFIG_SND_SOC_PCM179X_I2C is not set
-# CONFIG_SND_SOC_PCM179X_SPI is not set
-# CONFIG_SND_SOC_PCM3168A_I2C is not set
-# CONFIG_SND_SOC_PCM3168A_SPI is not set
-# CONFIG_SND_SOC_PCM512x_I2C is not set
-# CONFIG_SND_SOC_PCM512x_SPI is not set
-# CONFIG_SND_SOC_QCOM is not set
-# CONFIG_SND_SOC_RT5616 is not set
-# CONFIG_SND_SOC_RT5631 is not set
-# CONFIG_SND_SOC_RT5677_SPI is not set
-# CONFIG_SND_SOC_SGTL5000 is not set
-# CONFIG_SND_SOC_SIRF_AUDIO_CODEC is not set
-# CONFIG_SND_SOC_SPDIF is not set
-# CONFIG_SND_SOC_SSM2602_I2C is not set
-# CONFIG_SND_SOC_SSM2602_SPI is not set
-# CONFIG_SND_SOC_SSM4567 is not set
-# CONFIG_SND_SOC_STA32X is not set
-# CONFIG_SND_SOC_STA350 is not set
-# CONFIG_SND_SOC_STI_SAS is not set
-# CONFIG_SND_SOC_TAS2552 is not set
-# CONFIG_SND_SOC_TAS5086 is not set
-# CONFIG_SND_SOC_TAS571X is not set
-# CONFIG_SND_SOC_TAS5720 is not set
-# CONFIG_SND_SOC_TFA9879 is not set
-# CONFIG_SND_SOC_TLV320AIC23_I2C is not set
-# CONFIG_SND_SOC_TLV320AIC23_SPI is not set
-# CONFIG_SND_SOC_TLV320AIC31XX is not set
-# CONFIG_SND_SOC_TLV320AIC3X is not set
-# CONFIG_SND_SOC_TPA6130A2 is not set
-# CONFIG_SND_SOC_TS3A227E is not set
-# CONFIG_SND_SOC_WM8510 is not set
-# CONFIG_SND_SOC_WM8523 is not set
-# CONFIG_SND_SOC_WM8580 is not set
-# CONFIG_SND_SOC_WM8711 is not set
-# CONFIG_SND_SOC_WM8728 is not set
-# CONFIG_SND_SOC_WM8731 is not set
-# CONFIG_SND_SOC_WM8737 is not set
-# CONFIG_SND_SOC_WM8741 is not set
-# CONFIG_SND_SOC_WM8750 is not set
-# CONFIG_SND_SOC_WM8753 is not set
-# CONFIG_SND_SOC_WM8770 is not set
-# CONFIG_SND_SOC_WM8776 is not set
-# CONFIG_SND_SOC_WM8804_I2C is not set
-# CONFIG_SND_SOC_WM8804_SPI is not set
-# CONFIG_SND_SOC_WM8903 is not set
-# CONFIG_SND_SOC_WM8960 is not set
-# CONFIG_SND_SOC_WM8962 is not set
-# CONFIG_SND_SOC_WM8974 is not set
-# CONFIG_SND_SOC_WM8978 is not set
-# CONFIG_SND_SOC_WM8985 is not set
-# CONFIG_SND_SOC_XTFPGA_I2S is not set
-# CONFIG_SND_SONICVIBES is not set
-# CONFIG_SND_SPI is not set
-# CONFIG_SND_SSCAPE is not set
-# CONFIG_SND_SUN4I_CODEC is not set
-# CONFIG_SND_SUPPORT_OLD_API is not set
-# CONFIG_SND_TIMER is not set
-# CONFIG_SND_TRIDENT is not set
-CONFIG_SND_USB=y
-# CONFIG_SND_USB_6FIRE is not set
-# CONFIG_SND_USB_AUDIO is not set
-# CONFIG_SND_USB_CAIAQ is not set
-# CONFIG_SND_USB_HIFACE is not set
-# CONFIG_SND_USB_POD is not set
-# CONFIG_SND_USB_PODHD is not set
-# CONFIG_SND_USB_TONEPORT is not set
-# CONFIG_SND_USB_UA101 is not set
-# CONFIG_SND_USB_US122L is not set
-# CONFIG_SND_USB_USX2Y is not set
-# CONFIG_SND_USB_VARIAX is not set
-# CONFIG_SND_VERBOSE_PRINTK is not set
-CONFIG_SND_VERBOSE_PROCFS=y
-# CONFIG_SND_VIA82XX is not set
-# CONFIG_SND_VIA82XX_MODEM is not set
-# CONFIG_SND_VIRTUOSO is not set
-# CONFIG_SND_VX222 is not set
-# CONFIG_SND_VXPOCKET is not set
-# CONFIG_SND_WAVEFRONT is not set
-# CONFIG_SND_YMFPCI is not set
-# CONFIG_SNI_RM is not set
-# CONFIG_SOCK_CGROUP_DATA is not set
-# CONFIG_SOC_AM33XX is not set
-# CONFIG_SOC_AM43XX is not set
-# CONFIG_SOC_BRCMSTB is not set
-# CONFIG_SOC_CAMERA is not set
-# CONFIG_SOC_DRA7XX is not set
-# CONFIG_SOC_HAS_OMAP2_SDRC is not set
-# CONFIG_SOC_OMAP5 is not set
-# CONFIG_SOC_TI is not set
-# CONFIG_SOFT_WATCHDOG is not set
-# CONFIG_SOLARIS_X86_PARTITION is not set
-# CONFIG_SONYPI is not set
-# CONFIG_SONY_LAPTOP is not set
-# CONFIG_SOUND is not set
-# CONFIG_SOUND_OSS_CORE is not set
-# CONFIG_SOUND_PRIME is not set
-# CONFIG_SP5100_TCO is not set
-# CONFIG_SPARSEMEM_MANUAL is not set
-# CONFIG_SPARSEMEM_STATIC is not set
-# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
-# CONFIG_SPARSE_IRQ is not set
-# CONFIG_SPARSE_RCU_POINTER is not set
-# CONFIG_SPEAKUP is not set
-# CONFIG_SPI is not set
-# CONFIG_SPINLOCK_TEST is not set
-# CONFIG_SPI_ALTERA is not set
-# CONFIG_SPI_AU1550 is not set
-# CONFIG_SPI_AXI_SPI_ENGINE is not set
-# CONFIG_SPI_BCM2835 is not set
-# CONFIG_SPI_BCM_QSPI is not set
-# CONFIG_SPI_BITBANG is not set
-# CONFIG_SPI_BUTTERFLY is not set
-# CONFIG_SPI_CADENCE is not set
-# CONFIG_SPI_CADENCE_QUADSPI is not set
-# CONFIG_SPI_DEBUG is not set
-# CONFIG_SPI_DESIGNWARE is not set
-# CONFIG_SPI_FSL_DSPI is not set
-# CONFIG_SPI_FSL_ESPI is not set
-# CONFIG_SPI_FSL_SPI is not set
-# CONFIG_SPI_GPIO is not set
-# CONFIG_SPI_GPIO_OLD is not set
-# CONFIG_SPI_IMG_SPFI is not set
-# CONFIG_SPI_LM70_LLP is not set
-# CONFIG_SPI_LOOPBACK_TEST is not set
-# CONFIG_SPI_MASTER is not set
-# CONFIG_SPI_MPC52xx is not set
-# CONFIG_SPI_MPC52xx_PSC is not set
-# CONFIG_SPI_OCTEON is not set
-# CONFIG_SPI_OC_TINY is not set
-# CONFIG_SPI_ORION is not set
-# CONFIG_SPI_PL022 is not set
-# CONFIG_SPI_PPC4xx is not set
-# CONFIG_SPI_PXA2XX is not set
-# CONFIG_SPI_PXA2XX_PCI is not set
-# CONFIG_SPI_ROCKCHIP is not set
-# CONFIG_SPI_SC18IS602 is not set
-# CONFIG_SPI_SPIDEV is not set
-# CONFIG_SPI_THUNDERX is not set
-# CONFIG_SPI_TI_QSPI is not set
-# CONFIG_SPI_TLE62X0 is not set
-# CONFIG_SPI_TOPCLIFF_PCH is not set
-# CONFIG_SPI_XCOMM is not set
-# CONFIG_SPI_XILINX is not set
-# CONFIG_SPI_XWAY is not set
-# CONFIG_SPI_ZYNQMP_GQSPI is not set
-CONFIG_SPLIT_PTLOCK_CPUS=4
-# CONFIG_SPMI is not set
-CONFIG_SQUASHFS=y
-# CONFIG_SQUASHFS_4K_DEVBLK_SIZE is not set
-# CONFIG_SQUASHFS_DECOMP_MULTI is not set
-CONFIG_SQUASHFS_DECOMP_MULTI_PERCPU=y
-# CONFIG_SQUASHFS_DECOMP_SINGLE is not set
-CONFIG_SQUASHFS_EMBEDDED=y
-# CONFIG_SQUASHFS_FILE_CACHE is not set
-CONFIG_SQUASHFS_FILE_DIRECT=y
-CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
-# CONFIG_SQUASHFS_LZ4 is not set
-# CONFIG_SQUASHFS_LZO is not set
-# CONFIG_SQUASHFS_XATTR is not set
-CONFIG_SQUASHFS_XZ=y
-# CONFIG_SQUASHFS_ZLIB is not set
-# CONFIG_SRAM is not set
-# CONFIG_SSB is not set
-# CONFIG_SSB_DEBUG is not set
-# CONFIG_SSB_DRIVER_GPIO is not set
-# CONFIG_SSB_HOST_SOC is not set
-# CONFIG_SSB_PCMCIAHOST is not set
-CONFIG_SSB_POSSIBLE=y
-# CONFIG_SSB_SDIOHOST is not set
-# CONFIG_SSB_SILENT is not set
-# CONFIG_SSFDC is not set
-# CONFIG_STACKTRACE is not set
-CONFIG_STACKTRACE_SUPPORT=y
-# CONFIG_STACK_TRACER is not set
-# CONFIG_STACK_VALIDATION is not set
-CONFIG_STAGING=y
-# CONFIG_STAGING_BOARD is not set
-# CONFIG_STAGING_MEDIA is not set
-CONFIG_STANDALONE=y
-# CONFIG_STATIC_KEYS_SELFTEST is not set
-CONFIG_STDBINUTILS=y
-# CONFIG_STE10XP is not set
-# CONFIG_STE_MODEM_RPROC is not set
-# CONFIG_STK3310 is not set
-# CONFIG_STK8312 is not set
-# CONFIG_STK8BA50 is not set
-# CONFIG_STM is not set
-# CONFIG_STMMAC_ETH is not set
-# CONFIG_STMMAC_PCI is not set
-# CONFIG_STMMAC_PLATFORM is not set
-# CONFIG_STM_DUMMY is not set
-# CONFIG_STM_SOURCE_CONSOLE is not set
-CONFIG_STP=y
-# CONFIG_STREAM_PARSER is not set
-# CONFIG_STRICT_DEVMEM is not set
-CONFIG_STRIP_ASM_SYMS=y
-# CONFIG_STX104 is not set
-# CONFIG_SUNDANCE is not set
-# CONFIG_SUNGEM is not set
-# CONFIG_SUNRPC is not set
-# CONFIG_SUNRPC_DEBUG is not set
-# CONFIG_SUNRPC_GSS is not set
-# CONFIG_SUNXI_SRAM is not set
-# CONFIG_SUN_PARTITION is not set
-# CONFIG_SUSPEND is not set
-# CONFIG_SUSPEND_SKIP_SYNC is not set
-CONFIG_SWAP=y
-# CONFIG_SWCONFIG is not set
-# CONFIG_SWCONFIG_B53 is not set
-# CONFIG_SWCONFIG_B53_SPI_DRIVER is not set
-# CONFIG_SWCONFIG_LEDS is not set
-# CONFIG_SX9500 is not set
-# CONFIG_SXGBE_ETH is not set
-# CONFIG_SYNCLINK_CS is not set
-# CONFIG_SYNC_FILE is not set
-# CONFIG_SYNOPSYS_DWC_ETH_QOS is not set
-CONFIG_SYN_COOKIES=y
-# CONFIG_SYSCON_REBOOT_MODE is not set
-CONFIG_SYSCTL=y
-# CONFIG_SYSCTL_SYSCALL is not set
-CONFIG_SYSFS=y
-# CONFIG_SYSFS_DEPRECATED is not set
-# CONFIG_SYSFS_DEPRECATED_V2 is not set
-# CONFIG_SYSFS_SYSCALL is not set
-# CONFIG_SYSTEMPORT is not set
-# CONFIG_SYSTEM_DATA_VERIFICATION is not set
-# CONFIG_SYSTEM_TRUSTED_KEYRING is not set
-CONFIG_SYSTEM_TRUSTED_KEYS=""
-# CONFIG_SYSV68_PARTITION is not set
-CONFIG_SYSVIPC=y
-CONFIG_SYSVIPC_SYSCTL=y
-# CONFIG_SYSV_FS is not set
-# CONFIG_SYS_HYPERVISOR is not set
-# CONFIG_T5403 is not set
-# CONFIG_TARGET_CORE is not set
-# CONFIG_TASKSTATS is not set
-# CONFIG_TASKS_RCU is not set
-# CONFIG_TASK_XACCT is not set
-# CONFIG_TC35815 is not set
-# CONFIG_TCG_ATMEL is not set
-# CONFIG_TCG_CRB is not set
-# CONFIG_TCG_INFINEON is not set
-# CONFIG_TCG_NSC is not set
-# CONFIG_TCG_ST33_I2C is not set
-# CONFIG_TCG_TIS is not set
-# CONFIG_TCG_TIS_I2C_ATMEL is not set
-# CONFIG_TCG_TIS_I2C_INFINEON is not set
-# CONFIG_TCG_TIS_I2C_NUVOTON is not set
-# CONFIG_TCG_TIS_SPI is not set
-# CONFIG_TCG_TIS_ST33ZP24_I2C is not set
-# CONFIG_TCG_TIS_ST33ZP24_SPI is not set
-# CONFIG_TCG_TPM is not set
-# CONFIG_TCG_VTPM_PROXY is not set
-# CONFIG_TCG_XEN is not set
-# CONFIG_TCIC is not set
-CONFIG_TCP_CONG_ADVANCED=y
-# CONFIG_TCP_CONG_BBR is not set
-# CONFIG_TCP_CONG_BIC is not set
-# CONFIG_TCP_CONG_CDG is not set
-CONFIG_TCP_CONG_CUBIC=y
-# CONFIG_TCP_CONG_DCTCP is not set
-# CONFIG_TCP_CONG_HSTCP is not set
-# CONFIG_TCP_CONG_HTCP is not set
-# CONFIG_TCP_CONG_HYBLA is not set
-# CONFIG_TCP_CONG_ILLINOIS is not set
-# CONFIG_TCP_CONG_LP is not set
-# CONFIG_TCP_CONG_NV is not set
-# CONFIG_TCP_CONG_SCALABLE is not set
-# CONFIG_TCP_CONG_VEGAS is not set
-# CONFIG_TCP_CONG_VENO is not set
-# CONFIG_TCP_CONG_WESTWOOD is not set
-# CONFIG_TCP_CONG_YEAH is not set
-# CONFIG_TCP_MD5SIG is not set
-# CONFIG_TCS3414 is not set
-# CONFIG_TCS3472 is not set
-# CONFIG_TEGRA_AHB is not set
-# CONFIG_TEGRA_HOST1X is not set
-# CONFIG_TEHUTI is not set
-# CONFIG_TERANETICS_PHY is not set
-# CONFIG_TEST_BITMAP is not set
-# CONFIG_TEST_BPF is not set
-# CONFIG_TEST_FIRMWARE is not set
-# CONFIG_TEST_HASH is not set
-# CONFIG_TEST_HEXDUMP is not set
-# CONFIG_TEST_KSTRTOX is not set
-# CONFIG_TEST_LIST_SORT is not set
-# CONFIG_TEST_LKM is not set
-# CONFIG_TEST_POWER is not set
-# CONFIG_TEST_PRINTF is not set
-# CONFIG_TEST_RHASHTABLE is not set
-# CONFIG_TEST_STATIC_KEYS is not set
-# CONFIG_TEST_STRING_HELPERS is not set
-# CONFIG_TEST_UDELAY is not set
-# CONFIG_TEST_USER_COPY is not set
-# CONFIG_TEST_UUID is not set
-CONFIG_TEXTSEARCH=y
-# CONFIG_TEXTSEARCH_BM is not set
-# CONFIG_TEXTSEARCH_FSM is not set
-# CONFIG_TEXTSEARCH_KMP is not set
-# CONFIG_THERMAL is not set
-# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
-# CONFIG_THERMAL_DEFAULT_GOV_POWER_ALLOCATOR is not set
-# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
-# CONFIG_THERMAL_EMULATION is not set
-# CONFIG_THERMAL_GOV_BANG_BANG is not set
-# CONFIG_THERMAL_GOV_FAIR_SHARE is not set
-# CONFIG_THERMAL_GOV_POWER_ALLOCATOR is not set
-# CONFIG_THERMAL_GOV_USER_SPACE is not set
-# CONFIG_THERMAL_HWMON is not set
-# CONFIG_THERMAL_WRITABLE_TRIPS is not set
-# CONFIG_THINKPAD_ACPI is not set
-# CONFIG_THRUSTMASTER_FF is not set
-# CONFIG_THUNDERBOLT is not set
-# CONFIG_THUNDER_NIC_BGX is not set
-# CONFIG_THUNDER_NIC_PF is not set
-# CONFIG_THUNDER_NIC_RGX is not set
-# CONFIG_THUNDER_NIC_VF is not set
-# CONFIG_TICK_CPU_ACCOUNTING is not set
-CONFIG_TICK_ONESHOT=y
-# CONFIG_TIFM_CORE is not set
-# CONFIG_TIGON3 is not set
-# CONFIG_TIMB_DMA is not set
-CONFIG_TIMERFD=y
-# CONFIG_TIMER_STATS is not set
-CONFIG_TINY_RCU=y
-# CONFIG_TIPC is not set
-# CONFIG_TI_ADC081C is not set
-# CONFIG_TI_ADC0832 is not set
-# CONFIG_TI_ADC12138 is not set
-# CONFIG_TI_ADC128S052 is not set
-# CONFIG_TI_ADC161S626 is not set
-# CONFIG_TI_ADS1015 is not set
-# CONFIG_TI_ADS8688 is not set
-# CONFIG_TI_AM335X_ADC is not set
-# CONFIG_TI_CPSW is not set
-# CONFIG_TI_CPSW_ALE is not set
-# CONFIG_TI_CPTS is not set
-# CONFIG_TI_DAC7512 is not set
-# CONFIG_TI_DAVINCI_CPDMA is not set
-# CONFIG_TI_DAVINCI_MDIO is not set
-# CONFIG_TI_ST is not set
-# CONFIG_TI_SYSCON_RESET is not set
-# CONFIG_TLAN is not set
-# CONFIG_TMD_HERMES is not set
-# CONFIG_TMP006 is not set
-CONFIG_TMPFS=y
-# CONFIG_TMPFS_POSIX_ACL is not set
-CONFIG_TMPFS_XATTR=y
-# CONFIG_TOPSTAR_LAPTOP is not set
-# CONFIG_TORTURE_TEST is not set
-# CONFIG_TOSHIBA_HAPS is not set
-# CONFIG_TOUCHSCREEN_AD7877 is not set
-# CONFIG_TOUCHSCREEN_AD7879 is not set
-# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
-# CONFIG_TOUCHSCREEN_AD7879_SPI is not set
-# CONFIG_TOUCHSCREEN_ADS7846 is not set
-# CONFIG_TOUCHSCREEN_AR1021_I2C is not set
-# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
-# CONFIG_TOUCHSCREEN_AUO_PIXCIR is not set
-# CONFIG_TOUCHSCREEN_BU21013 is not set
-# CONFIG_TOUCHSCREEN_CHIPONE_ICN8318 is not set
-# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
-# CONFIG_TOUCHSCREEN_CYTTSP4_CORE is not set
-# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
-# CONFIG_TOUCHSCREEN_DYNAPRO is not set
-# CONFIG_TOUCHSCREEN_EDT_FT5X06 is not set
-# CONFIG_TOUCHSCREEN_EETI is not set
-# CONFIG_TOUCHSCREEN_EGALAX is not set
-# CONFIG_TOUCHSCREEN_EGALAX_SERIAL is not set
-# CONFIG_TOUCHSCREEN_EKTF2127 is not set
-# CONFIG_TOUCHSCREEN_ELAN is not set
-# CONFIG_TOUCHSCREEN_ELO is not set
-# CONFIG_TOUCHSCREEN_FT6236 is not set
-# CONFIG_TOUCHSCREEN_FUJITSU is not set
-# CONFIG_TOUCHSCREEN_GOODIX is not set
-# CONFIG_TOUCHSCREEN_GUNZE is not set
-# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
-# CONFIG_TOUCHSCREEN_ILI210X is not set
-# CONFIG_TOUCHSCREEN_IMX6UL_TSC is not set
-# CONFIG_TOUCHSCREEN_INEXIO is not set
-# CONFIG_TOUCHSCREEN_MAX11801 is not set
-# CONFIG_TOUCHSCREEN_MCS5000 is not set
-# CONFIG_TOUCHSCREEN_MELFAS_MIP4 is not set
-# CONFIG_TOUCHSCREEN_MK712 is not set
-# CONFIG_TOUCHSCREEN_MMS114 is not set
-# CONFIG_TOUCHSCREEN_MTOUCH is not set
-# CONFIG_TOUCHSCREEN_PENMOUNT is not set
-# CONFIG_TOUCHSCREEN_PIXCIR is not set
-# CONFIG_TOUCHSCREEN_RM_TS is not set
-# CONFIG_TOUCHSCREEN_ROHM_BU21023 is not set
-# CONFIG_TOUCHSCREEN_S3C2410 is not set
-# CONFIG_TOUCHSCREEN_SILEAD is not set
-# CONFIG_TOUCHSCREEN_SIS_I2C is not set
-# CONFIG_TOUCHSCREEN_ST1232 is not set
-# CONFIG_TOUCHSCREEN_SUR40 is not set
-# CONFIG_TOUCHSCREEN_SURFACE3_SPI is not set
-# CONFIG_TOUCHSCREEN_SX8654 is not set
-# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4 is not set
-# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
-# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
-# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
-# CONFIG_TOUCHSCREEN_TPS6507X is not set
-# CONFIG_TOUCHSCREEN_TSC2004 is not set
-# CONFIG_TOUCHSCREEN_TSC2005 is not set
-# CONFIG_TOUCHSCREEN_TSC2007 is not set
-# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
-# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
-# CONFIG_TOUCHSCREEN_W90X900 is not set
-# CONFIG_TOUCHSCREEN_WACOM_I2C is not set
-# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
-# CONFIG_TOUCHSCREEN_WDT87XX_I2C is not set
-# CONFIG_TOUCHSCREEN_WM97XX is not set
-# CONFIG_TOUCHSCREEN_ZFORCE is not set
-# CONFIG_TPL0102 is not set
-# CONFIG_TPS6105X is not set
-# CONFIG_TPS65010 is not set
-# CONFIG_TPS6507X is not set
-# CONFIG_TRACEPOINT_BENCHMARK is not set
-# CONFIG_TRACER_SNAPSHOT is not set
-# CONFIG_TRACER_SNAPSHOT_PER_CPU_SWAP is not set
-# CONFIG_TRACE_BRANCH_PROFILING is not set
-# CONFIG_TRACE_ENUM_MAP_FILE is not set
-CONFIG_TRACE_IRQFLAGS_SUPPORT=y
-# CONFIG_TRACE_SINK is not set
-# CONFIG_TRACING_EVENTS_GPIO is not set
-CONFIG_TRACING_SUPPORT=y
-CONFIG_TRAD_SIGNALS=y
-# CONFIG_TRANSPARENT_HUGEPAGE is not set
-# CONFIG_TREE_RCU is not set
-# CONFIG_TREE_RCU_TRACE is not set
-# CONFIG_TRIM_UNUSED_KSYMS is not set
-# CONFIG_TRUSTED_KEYS is not set
-# CONFIG_TSL2583 is not set
-# CONFIG_TSL2x7x is not set
-# CONFIG_TSL4531 is not set
-# CONFIG_TSYS01 is not set
-# CONFIG_TSYS02D is not set
-# CONFIG_TTPCI_EEPROM is not set
-CONFIG_TTY=y
-# CONFIG_TTY_PRINTK is not set
-# CONFIG_TUN is not set
-# CONFIG_TUN_VNET_CROSS_LE is not set
-# CONFIG_TWL4030_CORE is not set
-# CONFIG_TWL4030_MADC is not set
-# CONFIG_TWL6030_GPADC is not set
-# CONFIG_TWL6040_CORE is not set
-# CONFIG_TYPHOON is not set
-# CONFIG_UACCESS_WITH_MEMCPY is not set
-# CONFIG_UBIFS_ATIME_SUPPORT is not set
-# CONFIG_UBSAN is not set
-# CONFIG_UCB1400_CORE is not set
-# CONFIG_UCSI is not set
-# CONFIG_UDF_FS is not set
-CONFIG_UDF_NLS=y
-CONFIG_UEVENT_HELPER=y
-CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
-# CONFIG_UFS_FS is not set
-# CONFIG_UHID is not set
-CONFIG_UID16=y
-# CONFIG_UIO is not set
-# CONFIG_ULTRA is not set
-# CONFIG_ULTRIX_PARTITION is not set
-CONFIG_UNIX=y
-CONFIG_UNIX98_PTYS=y
-# CONFIG_UNIXWARE_DISKLABEL is not set
-# CONFIG_UNIX_DIAG is not set
-# CONFIG_UNUSED_SYMBOLS is not set
-# CONFIG_UPROBES is not set
-# CONFIG_UPROBE_EVENT is not set
-# CONFIG_US5182D is not set
-# CONFIG_USB is not set
-# CONFIG_USBIP_CORE is not set
-CONFIG_USBIP_VHCI_HC_PORTS=8
-CONFIG_USBIP_VHCI_NR_HCS=1
-# CONFIG_USBIP_VUDC is not set
-# CONFIG_USBPCWATCHDOG is not set
-# CONFIG_USB_ACM is not set
-# CONFIG_USB_ADUTUX is not set
-CONFIG_USB_ALI_M5632=y
-# CONFIG_USB_AMD5536UDC is not set
-CONFIG_USB_AN2720=y
-# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
-# CONFIG_USB_APPLEDISPLAY is not set
-CONFIG_USB_ARCH_HAS_HCD=y
-CONFIG_USB_ARMLINUX=y
-# CONFIG_USB_ATM is not set
-# CONFIG_USB_BDC_UDC is not set
-CONFIG_USB_BELKIN=y
-# CONFIG_USB_C67X00_HCD is not set
-# CONFIG_USB_CATC is not set
-# CONFIG_USB_CDC_COMPOSITE is not set
-# CONFIG_USB_CHAOSKEY is not set
-# CONFIG_USB_CHIPIDEA is not set
-# CONFIG_USB_CONFIGFS is not set
-# CONFIG_USB_CXACRU is not set
-# CONFIG_USB_CYPRESS_CY7C63 is not set
-# CONFIG_USB_CYTHERM is not set
-CONFIG_USB_DEFAULT_PERSIST=y
-# CONFIG_USB_DSBR is not set
-# CONFIG_USB_DUMMY_HCD is not set
-# CONFIG_USB_DWC2 is not set
-# CONFIG_USB_DWC2_DEBUG is not set
-# CONFIG_USB_DWC2_DUAL_ROLE is not set
-# CONFIG_USB_DWC2_HOST is not set
-# CONFIG_USB_DWC2_PERIPHERAL is not set
-# CONFIG_USB_DWC3 is not set
-# CONFIG_USB_DWC3_EXYNOS is not set
-# CONFIG_USB_DWC3_KEYSTONE is not set
-# CONFIG_USB_DWC3_OF_SIMPLE is not set
-# CONFIG_USB_DWC3_PCI is not set
-# CONFIG_USB_DWC3_QCOM is not set
-# CONFIG_USB_DYNAMIC_MINORS is not set
-# CONFIG_USB_EG20T is not set
-# CONFIG_USB_EHCI_ATH79 is not set
-# CONFIG_USB_EHCI_HCD_AT91 is not set
-# CONFIG_USB_EHCI_HCD_OMAP is not set
-# CONFIG_USB_EHCI_HCD_PPC_OF is not set
-# CONFIG_USB_EHCI_MSM is not set
-# CONFIG_USB_EHCI_MV is not set
-CONFIG_USB_EHCI_ROOT_HUB_TT=y
-CONFIG_USB_EHCI_TT_NEWSCHED=y
-# CONFIG_USB_EHSET_TEST_FIXTURE is not set
-# CONFIG_USB_EMI26 is not set
-# CONFIG_USB_EMI62 is not set
-# CONFIG_USB_EPSON2888 is not set
-# CONFIG_USB_EZUSB_FX2 is not set
-# CONFIG_USB_FOTG210_HCD is not set
-# CONFIG_USB_FOTG210_UDC is not set
-# CONFIG_USB_FSL_USB2 is not set
-# CONFIG_USB_FTDI_ELAN is not set
-# CONFIG_USB_FUNCTIONFS is not set
-# CONFIG_USB_FUSB300 is not set
-# CONFIG_USB_GADGET is not set
-# CONFIG_USB_GADGETFS is not set
-# CONFIG_USB_GADGET_DEBUG is not set
-# CONFIG_USB_GADGET_DEBUG_FILES is not set
-# CONFIG_USB_GADGET_DEBUG_FS is not set
-CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
-CONFIG_USB_GADGET_VBUS_DRAW=2
-# CONFIG_USB_GADGET_XILINX is not set
-# CONFIG_USB_GL860 is not set
-# CONFIG_USB_GOKU is not set
-# CONFIG_USB_GPIO_VBUS is not set
-# CONFIG_USB_GR_UDC is not set
-# CONFIG_USB_GSPCA is not set
-# CONFIG_USB_GSPCA_BENQ is not set
-# CONFIG_USB_GSPCA_CONEX is not set
-# CONFIG_USB_GSPCA_CPIA1 is not set
-# CONFIG_USB_GSPCA_DTCS033 is not set
-# CONFIG_USB_GSPCA_ETOMS is not set
-# CONFIG_USB_GSPCA_FINEPIX is not set
-# CONFIG_USB_GSPCA_JEILINJ is not set
-# CONFIG_USB_GSPCA_JL2005BCD is not set
-# CONFIG_USB_GSPCA_KINECT is not set
-# CONFIG_USB_GSPCA_KONICA is not set
-# CONFIG_USB_GSPCA_MARS is not set
-# CONFIG_USB_GSPCA_MR97310A is not set
-# CONFIG_USB_GSPCA_NW80X is not set
-# CONFIG_USB_GSPCA_OV519 is not set
-# CONFIG_USB_GSPCA_OV534 is not set
-# CONFIG_USB_GSPCA_OV534_9 is not set
-# CONFIG_USB_GSPCA_PAC207 is not set
-# CONFIG_USB_GSPCA_PAC7302 is not set
-# CONFIG_USB_GSPCA_PAC7311 is not set
-# CONFIG_USB_GSPCA_SE401 is not set
-# CONFIG_USB_GSPCA_SN9C2028 is not set
-# CONFIG_USB_GSPCA_SN9C20X is not set
-# CONFIG_USB_GSPCA_SONIXB is not set
-# CONFIG_USB_GSPCA_SONIXJ is not set
-# CONFIG_USB_GSPCA_SPCA1528 is not set
-# CONFIG_USB_GSPCA_SPCA500 is not set
-# CONFIG_USB_GSPCA_SPCA501 is not set
-# CONFIG_USB_GSPCA_SPCA505 is not set
-# CONFIG_USB_GSPCA_SPCA506 is not set
-# CONFIG_USB_GSPCA_SPCA508 is not set
-# CONFIG_USB_GSPCA_SPCA561 is not set
-# CONFIG_USB_GSPCA_SQ905 is not set
-# CONFIG_USB_GSPCA_SQ905C is not set
-# CONFIG_USB_GSPCA_SQ930X is not set
-# CONFIG_USB_GSPCA_STK014 is not set
-# CONFIG_USB_GSPCA_STK1135 is not set
-# CONFIG_USB_GSPCA_STV0680 is not set
-# CONFIG_USB_GSPCA_SUNPLUS is not set
-# CONFIG_USB_GSPCA_T613 is not set
-# CONFIG_USB_GSPCA_TOPRO is not set
-# CONFIG_USB_GSPCA_TOUPTEK is not set
-# CONFIG_USB_GSPCA_TV8532 is not set
-# CONFIG_USB_GSPCA_VC032X is not set
-# CONFIG_USB_GSPCA_VICAM is not set
-# CONFIG_USB_GSPCA_XIRLINK_CIT is not set
-# CONFIG_USB_GSPCA_ZC3XX is not set
-# CONFIG_USB_G_ACM_MS is not set
-# CONFIG_USB_G_DBGP is not set
-# CONFIG_USB_G_HID is not set
-# CONFIG_USB_G_MULTI is not set
-# CONFIG_USB_G_NCM is not set
-# CONFIG_USB_G_NOKIA is not set
-# CONFIG_USB_G_PRINTER is not set
-# CONFIG_USB_G_SERIAL is not set
-# CONFIG_USB_G_WEBCAM is not set
-# CONFIG_USB_HCD_TEST_MODE is not set
-# CONFIG_USB_HID is not set
-# CONFIG_USB_HIDDEV is not set
-# CONFIG_USB_HSIC_USB3503 is not set
-# CONFIG_USB_HSIC_USB4604 is not set
-# CONFIG_USB_HSO is not set
-# CONFIG_USB_HWA_HCD is not set
-# CONFIG_USB_IDMOUSE is not set
-# CONFIG_USB_IOWARRIOR is not set
-# CONFIG_USB_IPHETH is not set
-# CONFIG_USB_ISIGHTFW is not set
-# CONFIG_USB_ISP116X_HCD is not set
-# CONFIG_USB_ISP1301 is not set
-# CONFIG_USB_ISP1362_HCD is not set
-# CONFIG_USB_ISP1760 is not set
-# CONFIG_USB_ISP1760_HCD is not set
-# CONFIG_USB_KAWETH is not set
-# CONFIG_USB_KBD is not set
-# CONFIG_USB_KC2190 is not set
-# CONFIG_USB_LAN78XX is not set
-# CONFIG_USB_LCD is not set
-# CONFIG_USB_LD is not set
-# CONFIG_USB_LED is not set
-# CONFIG_USB_LEDS_TRIGGER_USBPORT is not set
-# CONFIG_USB_LED_TRIG is not set
-# CONFIG_USB_LEGOTOWER is not set
-# CONFIG_USB_LINK_LAYER_TEST is not set
-# CONFIG_USB_M5602 is not set
-# CONFIG_USB_M66592 is not set
-# CONFIG_USB_MASS_STORAGE is not set
-# CONFIG_USB_MAX3421_HCD is not set
-# CONFIG_USB_MDC800 is not set
-# CONFIG_USB_MICROTEK is not set
-# CONFIG_USB_MIDI_GADGET is not set
-# CONFIG_USB_MON is not set
-# CONFIG_USB_MOUSE is not set
-# CONFIG_USB_MSM_OTG is not set
-# CONFIG_USB_MUSB_HDRC is not set
-# CONFIG_USB_MV_U3D is not set
-# CONFIG_USB_MV_UDC is not set
-# CONFIG_USB_MXS_PHY is not set
-# CONFIG_USB_NET2272 is not set
-# CONFIG_USB_NET2280 is not set
-# CONFIG_USB_NET_AX88179_178A is not set
-# CONFIG_USB_NET_AX8817X is not set
-# CONFIG_USB_NET_CDCETHER is not set
-# CONFIG_USB_NET_CDC_EEM is not set
-# CONFIG_USB_NET_CDC_MBIM is not set
-# CONFIG_USB_NET_CDC_NCM is not set
-# CONFIG_USB_NET_CDC_SUBSET is not set
-# CONFIG_USB_NET_CH9200 is not set
-# CONFIG_USB_NET_CX82310_ETH is not set
-# CONFIG_USB_NET_DM9601 is not set
-# CONFIG_USB_NET_DRIVERS is not set
-# CONFIG_USB_NET_GL620A is not set
-# CONFIG_USB_NET_HUAWEI_CDC_NCM is not set
-# CONFIG_USB_NET_INT51X1 is not set
-# CONFIG_USB_NET_KALMIA is not set
-# CONFIG_USB_NET_MCS7830 is not set
-# CONFIG_USB_NET_NET1080 is not set
-# CONFIG_USB_NET_PLUSB is not set
-# CONFIG_USB_NET_QMI_WWAN is not set
-# CONFIG_USB_NET_RNDIS_HOST is not set
-# CONFIG_USB_NET_RNDIS_WLAN is not set
-# CONFIG_USB_NET_SMSC75XX is not set
-# CONFIG_USB_NET_SMSC95XX is not set
-# CONFIG_USB_NET_SR9700 is not set
-# CONFIG_USB_NET_SR9800 is not set
-# CONFIG_USB_NET_ZAURUS is not set
-# CONFIG_USB_OHCI_HCD is not set
-# CONFIG_USB_OHCI_HCD_PCI is not set
-# CONFIG_USB_OHCI_HCD_PPC_OF is not set
-# CONFIG_USB_OHCI_HCD_PPC_OF_BE is not set
-# CONFIG_USB_OHCI_HCD_PPC_OF_LE is not set
-# CONFIG_USB_OHCI_HCD_SSB is not set
-CONFIG_USB_OHCI_LITTLE_ENDIAN=y
-# CONFIG_USB_OTG is not set
-# CONFIG_USB_OTG_BLACKLIST_HUB is not set
-# CONFIG_USB_OTG_FSM is not set
-# CONFIG_USB_OTG_WHITELIST is not set
-# CONFIG_USB_OXU210HP_HCD is not set
-# CONFIG_USB_PEGASUS is not set
-# CONFIG_USB_PHY is not set
-# CONFIG_USB_PRINTER is not set
-# CONFIG_USB_PWC_INPUT_EVDEV is not set
-# CONFIG_USB_PXA27X is not set
-# CONFIG_USB_R8A66597 is not set
-# CONFIG_USB_R8A66597_HCD is not set
-# CONFIG_USB_RCAR_PHY is not set
-# CONFIG_USB_RENESAS_USBHS is not set
-# CONFIG_USB_RIO500 is not set
-# CONFIG_USB_RTL8150 is not set
-# CONFIG_USB_RTL8152 is not set
-# CONFIG_USB_S2255 is not set
-# CONFIG_USB_SERIAL is not set
-# CONFIG_USB_SERIAL_AIRCABLE is not set
-# CONFIG_USB_SERIAL_ARK3116 is not set
-# CONFIG_USB_SERIAL_BELKIN is not set
-# CONFIG_USB_SERIAL_CH341 is not set
-# CONFIG_USB_SERIAL_CP210X is not set
-# CONFIG_USB_SERIAL_CYBERJACK is not set
-# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
-# CONFIG_USB_SERIAL_DEBUG is not set
-# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
-# CONFIG_USB_SERIAL_EDGEPORT is not set
-# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
-# CONFIG_USB_SERIAL_EMPEG is not set
-# CONFIG_USB_SERIAL_F81232 is not set
-# CONFIG_USB_SERIAL_FTDI_SIO is not set
-# CONFIG_USB_SERIAL_GARMIN is not set
-CONFIG_USB_SERIAL_GENERIC=y
-# CONFIG_USB_SERIAL_IPAQ is not set
-# CONFIG_USB_SERIAL_IPW is not set
-# CONFIG_USB_SERIAL_IR is not set
-# CONFIG_USB_SERIAL_IUU is not set
-# CONFIG_USB_SERIAL_KEYSPAN is not set
-CONFIG_USB_SERIAL_KEYSPAN_MPR=y
-# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
-CONFIG_USB_SERIAL_KEYSPAN_USA18X=y
-CONFIG_USB_SERIAL_KEYSPAN_USA19=y
-CONFIG_USB_SERIAL_KEYSPAN_USA19QI=y
-CONFIG_USB_SERIAL_KEYSPAN_USA19QW=y
-CONFIG_USB_SERIAL_KEYSPAN_USA19W=y
-CONFIG_USB_SERIAL_KEYSPAN_USA28=y
-CONFIG_USB_SERIAL_KEYSPAN_USA28X=y
-CONFIG_USB_SERIAL_KEYSPAN_USA28XA=y
-CONFIG_USB_SERIAL_KEYSPAN_USA28XB=y
-CONFIG_USB_SERIAL_KEYSPAN_USA49W=y
-CONFIG_USB_SERIAL_KEYSPAN_USA49WLC=y
-# CONFIG_USB_SERIAL_KLSI is not set
-# CONFIG_USB_SERIAL_KOBIL_SCT is not set
-# CONFIG_USB_SERIAL_MCT_U232 is not set
-# CONFIG_USB_SERIAL_METRO is not set
-# CONFIG_USB_SERIAL_MOS7715_PARPORT is not set
-# CONFIG_USB_SERIAL_MOS7720 is not set
-# CONFIG_USB_SERIAL_MOS7840 is not set
-# CONFIG_USB_SERIAL_MXUPORT is not set
-# CONFIG_USB_SERIAL_NAVMAN is not set
-# CONFIG_USB_SERIAL_OMNINET is not set
-# CONFIG_USB_SERIAL_OPTICON is not set
-# CONFIG_USB_SERIAL_OPTION is not set
-# CONFIG_USB_SERIAL_OTI6858 is not set
-# CONFIG_USB_SERIAL_PL2303 is not set
-# CONFIG_USB_SERIAL_QCAUX is not set
-# CONFIG_USB_SERIAL_QT2 is not set
-# CONFIG_USB_SERIAL_QUALCOMM is not set
-# CONFIG_USB_SERIAL_SAFE is not set
-CONFIG_USB_SERIAL_SAFE_PADDED=y
-# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
-# CONFIG_USB_SERIAL_SIMPLE is not set
-# CONFIG_USB_SERIAL_SPCP8X5 is not set
-# CONFIG_USB_SERIAL_SSU100 is not set
-# CONFIG_USB_SERIAL_SYMBOL is not set
-# CONFIG_USB_SERIAL_TI is not set
-# CONFIG_USB_SERIAL_VISOR is not set
-# CONFIG_USB_SERIAL_WHITEHEAT is not set
-# CONFIG_USB_SERIAL_WISHBONE is not set
-# CONFIG_USB_SERIAL_XIRCOM is not set
-# CONFIG_USB_SERIAL_XSENS_MT is not set
-# CONFIG_USB_SEVSEG is not set
-# CONFIG_USB_SIERRA_NET is not set
-# CONFIG_USB_SISUSBVGA is not set
-# CONFIG_USB_SL811_HCD is not set
-# CONFIG_USB_SPEEDTOUCH is not set
-# CONFIG_USB_STKWEBCAM is not set
-# CONFIG_USB_STORAGE is not set
-# CONFIG_USB_STORAGE_ALAUDA is not set
-# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
-# CONFIG_USB_STORAGE_DATAFAB is not set
-# CONFIG_USB_STORAGE_DEBUG is not set
-# CONFIG_USB_STORAGE_ENE_UB6250 is not set
-# CONFIG_USB_STORAGE_FREECOM is not set
-# CONFIG_USB_STORAGE_ISD200 is not set
-# CONFIG_USB_STORAGE_JUMPSHOT is not set
-# CONFIG_USB_STORAGE_KARMA is not set
-# CONFIG_USB_STORAGE_ONETOUCH is not set
-# CONFIG_USB_STORAGE_REALTEK is not set
-# CONFIG_USB_STORAGE_SDDR09 is not set
-# CONFIG_USB_STORAGE_SDDR55 is not set
-# CONFIG_USB_STORAGE_USBAT is not set
-# CONFIG_USB_STV06XX is not set
-# CONFIG_USB_SUPPORT is not set
-# CONFIG_USB_SWITCH_FSA9480 is not set
-# CONFIG_USB_TEST is not set
-# CONFIG_USB_TMC is not set
-# CONFIG_USB_TRANCEVIBRATOR is not set
-# CONFIG_USB_UAS is not set
-# CONFIG_USB_UEAGLEATM is not set
-# CONFIG_USB_ULPI is not set
-# CONFIG_USB_ULPI_BUS is not set
-# CONFIG_USB_USBNET is not set
-# CONFIG_USB_USS720 is not set
-# CONFIG_USB_VIDEO_CLASS is not set
-CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
-# CONFIG_USB_VL600 is not set
-# CONFIG_USB_WDM is not set
-# CONFIG_USB_WHCI_HCD is not set
-# CONFIG_USB_WUSB is not set
-# CONFIG_USB_WUSB_CBAF is not set
-# CONFIG_USB_XHCI_HCD is not set
-# CONFIG_USB_XUSBATM is not set
-# CONFIG_USB_YUREX is not set
-# CONFIG_USB_ZD1201 is not set
-# CONFIG_USB_ZERO is not set
-# CONFIG_USB_ZR364XX is not set
-# CONFIG_USELIB is not set
-# CONFIG_USERFAULTFD is not set
-# CONFIG_USE_OF is not set
-# CONFIG_UTS_NS is not set
-# CONFIG_UWB is not set
-# CONFIG_U_SERIAL_CONSOLE is not set
-# CONFIG_V4L_MEM2MEM_DRIVERS is not set
-# CONFIG_V4L_TEST_DRIVERS is not set
-# CONFIG_VCNL4000 is not set
-# CONFIG_VDSO is not set
-# CONFIG_VEML6070 is not set
-# CONFIG_VETH is not set
-# CONFIG_VEXPRESS_CONFIG is not set
-# CONFIG_VF610_ADC is not set
-# CONFIG_VF610_DAC is not set
-# CONFIG_VFAT_FS is not set
-# CONFIG_VGASTATE is not set
-# CONFIG_VGA_ARB is not set
-# CONFIG_VGA_SWITCHEROO is not set
-# CONFIG_VHOST_CROSS_ENDIAN_LEGACY is not set
-# CONFIG_VHOST_NET is not set
-# CONFIG_VHOST_VSOCK is not set
-# CONFIG_VIA_RHINE is not set
-# CONFIG_VIA_VELOCITY is not set
-# CONFIG_VIDEO_ADV7170 is not set
-# CONFIG_VIDEO_ADV7175 is not set
-# CONFIG_VIDEO_ADV7180 is not set
-# CONFIG_VIDEO_ADV7183 is not set
-# CONFIG_VIDEO_ADV7343 is not set
-# CONFIG_VIDEO_ADV7393 is not set
-# CONFIG_VIDEO_ADV_DEBUG is not set
-# CONFIG_VIDEO_AK881X is not set
-# CONFIG_VIDEO_BT819 is not set
-# CONFIG_VIDEO_BT848 is not set
-# CONFIG_VIDEO_BT856 is not set
-# CONFIG_VIDEO_BT866 is not set
-# CONFIG_VIDEO_CAFE_CCIC is not set
-# CONFIG_VIDEO_CS3308 is not set
-# CONFIG_VIDEO_CS5345 is not set
-# CONFIG_VIDEO_CS53L32A is not set
-# CONFIG_VIDEO_CX231XX is not set
-# CONFIG_VIDEO_CX2341X is not set
-# CONFIG_VIDEO_CX25840 is not set
-# CONFIG_VIDEO_CX88 is not set
-# CONFIG_VIDEO_DEV is not set
-# CONFIG_VIDEO_DM6446_CCDC is not set
-# CONFIG_VIDEO_DT3155 is not set
-# CONFIG_VIDEO_EM28XX is not set
-# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
-# CONFIG_VIDEO_GO7007 is not set
-# CONFIG_VIDEO_HDPVR is not set
-# CONFIG_VIDEO_HEXIUM_GEMINI is not set
-# CONFIG_VIDEO_HEXIUM_ORION is not set
-# CONFIG_VIDEO_IR_I2C is not set
-# CONFIG_VIDEO_IVTV is not set
-# CONFIG_VIDEO_KS0127 is not set
-# CONFIG_VIDEO_M52790 is not set
-# CONFIG_VIDEO_ML86V7667 is not set
-# CONFIG_VIDEO_MSP3400 is not set
-# CONFIG_VIDEO_MT9M111 is not set
-# CONFIG_VIDEO_MT9V011 is not set
-# CONFIG_VIDEO_MXB is not set
-# CONFIG_VIDEO_NOON010PC30 is not set
-# CONFIG_VIDEO_OMAP2_VOUT is not set
-# CONFIG_VIDEO_OV2659 is not set
-# CONFIG_VIDEO_OV7640 is not set
-# CONFIG_VIDEO_OV7670 is not set
-# CONFIG_VIDEO_PVRUSB2 is not set
-# CONFIG_VIDEO_SAA6588 is not set
-# CONFIG_VIDEO_SAA6752HS is not set
-# CONFIG_VIDEO_SAA7110 is not set
-# CONFIG_VIDEO_SAA711X is not set
-# CONFIG_VIDEO_SAA7127 is not set
-# CONFIG_VIDEO_SAA7134 is not set
-# CONFIG_VIDEO_SAA717X is not set
-# CONFIG_VIDEO_SAA7185 is not set
-# CONFIG_VIDEO_SH_MOBILE_CEU is not set
-# CONFIG_VIDEO_SONY_BTF_MPX is not set
-# CONFIG_VIDEO_SR030PC30 is not set
-# CONFIG_VIDEO_TDA7432 is not set
-# CONFIG_VIDEO_TDA9840 is not set
-# CONFIG_VIDEO_TEA6415C is not set
-# CONFIG_VIDEO_TEA6420 is not set
-# CONFIG_VIDEO_THS7303 is not set
-# CONFIG_VIDEO_THS8200 is not set
-# CONFIG_VIDEO_TIMBERDALE is not set
-# CONFIG_VIDEO_TLV320AIC23B is not set
-# CONFIG_VIDEO_TM6000 is not set
-# CONFIG_VIDEO_TVAUDIO is not set
-# CONFIG_VIDEO_TVP514X is not set
-# CONFIG_VIDEO_TVP5150 is not set
-# CONFIG_VIDEO_TVP7002 is not set
-# CONFIG_VIDEO_TW2804 is not set
-# CONFIG_VIDEO_TW9903 is not set
-# CONFIG_VIDEO_TW9906 is not set
-# CONFIG_VIDEO_UDA1342 is not set
-# CONFIG_VIDEO_UPD64031A is not set
-# CONFIG_VIDEO_UPD64083 is not set
-# CONFIG_VIDEO_USBTV is not set
-# CONFIG_VIDEO_USBVISION is not set
-# CONFIG_VIDEO_V4L2 is not set
-# CONFIG_VIDEO_VP27SMPX is not set
-# CONFIG_VIDEO_VPX3220 is not set
-# CONFIG_VIDEO_VS6624 is not set
-# CONFIG_VIDEO_WM8739 is not set
-# CONFIG_VIDEO_WM8775 is not set
-# CONFIG_VIDEO_ZORAN is not set
-# CONFIG_VIRTIO_BALLOON is not set
-# CONFIG_VIRTIO_INPUT is not set
-# CONFIG_VIRTIO_MMIO is not set
-# CONFIG_VIRTIO_PCI is not set
-# CONFIG_VIRTUALIZATION is not set
-# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
-# CONFIG_VIRT_DRIVERS is not set
-CONFIG_VIRT_TO_BUS=y
-# CONFIG_VITESSE_PHY is not set
-CONFIG_VLAN_8021Q=y
-# CONFIG_VLAN_8021Q_GVRP is not set
-# CONFIG_VLAN_8021Q_MVRP is not set
-# CONFIG_VME_BUS is not set
-# CONFIG_VMSPLIT_1G is not set
-# CONFIG_VMSPLIT_2G is not set
-# CONFIG_VMSPLIT_2G_OPT is not set
-CONFIG_VMSPLIT_3G=y
-# CONFIG_VMSPLIT_3G_OPT is not set
-# CONFIG_VMWARE_PVSCSI is not set
-# CONFIG_VMXNET3 is not set
-# CONFIG_VM_EVENT_COUNTERS is not set
-# CONFIG_VOP_BUS is not set
-# CONFIG_VORTEX is not set
-# CONFIG_VSOCKETS is not set
-# CONFIG_VT is not set
-# CONFIG_VT6655 is not set
-# CONFIG_VT6656 is not set
-# CONFIG_VXFS_FS is not set
-# CONFIG_VXGE is not set
-# CONFIG_VXLAN is not set
-# CONFIG_VZ89X is not set
-# CONFIG_W1 is not set
-# CONFIG_W1_CON is not set
-# CONFIG_W1_MASTER_DS1WM is not set
-# CONFIG_W1_MASTER_DS2482 is not set
-# CONFIG_W1_MASTER_DS2490 is not set
-# CONFIG_W1_MASTER_GPIO is not set
-# CONFIG_W1_MASTER_MATROX is not set
-# CONFIG_W1_SLAVE_BQ27000 is not set
-# CONFIG_W1_SLAVE_DS2406 is not set
-# CONFIG_W1_SLAVE_DS2408 is not set
-# CONFIG_W1_SLAVE_DS2413 is not set
-# CONFIG_W1_SLAVE_DS2423 is not set
-# CONFIG_W1_SLAVE_DS2431 is not set
-# CONFIG_W1_SLAVE_DS2433 is not set
-# CONFIG_W1_SLAVE_DS2760 is not set
-# CONFIG_W1_SLAVE_DS2780 is not set
-# CONFIG_W1_SLAVE_DS2781 is not set
-# CONFIG_W1_SLAVE_DS28E04 is not set
-# CONFIG_W1_SLAVE_SMEM is not set
-# CONFIG_W1_SLAVE_THERM is not set
-# CONFIG_W83627HF_WDT is not set
-# CONFIG_W83877F_WDT is not set
-# CONFIG_W83977F_WDT is not set
-# CONFIG_WAN is not set
-# CONFIG_WANXL is not set
-CONFIG_WATCHDOG=y
-# CONFIG_WATCHDOG_CORE is not set
-# CONFIG_WATCHDOG_NOWAYOUT is not set
-# CONFIG_WATCHDOG_PRETIMEOUT_GOV is not set
-# CONFIG_WATCHDOG_SYSFS is not set
-# CONFIG_WD80x3 is not set
-# CONFIG_WDAT_WDT is not set
-# CONFIG_WDTPCI is not set
-CONFIG_WEXT_CORE=y
-CONFIG_WEXT_PRIV=y
-CONFIG_WEXT_PROC=y
-CONFIG_WEXT_SPY=y
-CONFIG_WILINK_PLATFORM_DATA=y
-# CONFIG_WIMAX is not set
-# CONFIG_WIMAX_GDM72XX is not set
-CONFIG_WIRELESS=y
-CONFIG_WIRELESS_EXT=y
-# CONFIG_WIZNET_W5100 is not set
-# CONFIG_WIZNET_W5300 is not set
-# CONFIG_WL1251 is not set
-# CONFIG_WL12XX is not set
-# CONFIG_WL18XX is not set
-CONFIG_WLAN=y
-# CONFIG_WLAN_VENDOR_ADMTEK is not set
-# CONFIG_WLAN_VENDOR_ATH is not set
-# CONFIG_WLAN_VENDOR_ATMEL is not set
-# CONFIG_WLAN_VENDOR_BROADCOM is not set
-# CONFIG_WLAN_VENDOR_CISCO is not set
-# CONFIG_WLAN_VENDOR_INTEL is not set
-# CONFIG_WLAN_VENDOR_INTERSIL is not set
-# CONFIG_WLAN_VENDOR_MARVELL is not set
-# CONFIG_WLAN_VENDOR_MEDIATEK is not set
-# CONFIG_WLAN_VENDOR_RALINK is not set
-# CONFIG_WLAN_VENDOR_REALTEK is not set
-# CONFIG_WLAN_VENDOR_RSI is not set
-# CONFIG_WLAN_VENDOR_ST is not set
-# CONFIG_WLAN_VENDOR_TI is not set
-# CONFIG_WLAN_VENDOR_ZYDAS is not set
-# CONFIG_WLCORE is not set
-# CONFIG_WL_MEDIATEK is not set
-CONFIG_WL_TI=y
-CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
-# CONFIG_WQ_WATCHDOG is not set
-# CONFIG_X25 is not set
-# CONFIG_X509_CERTIFICATE_PARSER is not set
-# CONFIG_X86_DEBUG_STATIC_CPU_HAS is not set
-# CONFIG_X86_PKG_TEMP_THERMAL is not set
-CONFIG_X86_SYSFB=y
-# CONFIG_XEN is not set
-CONFIG_XFRM=y
-# CONFIG_XFRM_IPCOMP is not set
-# CONFIG_XFRM_MIGRATE is not set
-# CONFIG_XFRM_STATISTICS is not set
-# CONFIG_XFRM_SUB_POLICY is not set
-# CONFIG_XFRM_USER is not set
-# CONFIG_XFS_DEBUG is not set
-# CONFIG_XFS_FS is not set
-# CONFIG_XFS_POSIX_ACL is not set
-# CONFIG_XFS_QUOTA is not set
-# CONFIG_XFS_RT is not set
-# CONFIG_XFS_WARN is not set
-# CONFIG_XILINX_AXI_EMAC is not set
-# CONFIG_XILINX_DMA is not set
-# CONFIG_XILINX_EMACLITE is not set
-# CONFIG_XILINX_GMII2RGMII is not set
-# CONFIG_XILINX_LL_TEMAC is not set
-# CONFIG_XILINX_WATCHDOG is not set
-# CONFIG_XILINX_ZYNQMP_DMA is not set
-# CONFIG_XILLYBUS is not set
-# CONFIG_XIP_KERNEL is not set
-# CONFIG_XMON is not set
-CONFIG_XZ_DEC=y
-# CONFIG_XZ_DEC_ARM is not set
-# CONFIG_XZ_DEC_ARMTHUMB is not set
-# CONFIG_XZ_DEC_BCJ is not set
-# CONFIG_XZ_DEC_IA64 is not set
-# CONFIG_XZ_DEC_POWERPC is not set
-# CONFIG_XZ_DEC_SPARC is not set
-# CONFIG_XZ_DEC_TEST is not set
-# CONFIG_XZ_DEC_X86 is not set
-# CONFIG_YAM is not set
-# CONFIG_YELLOWFIN is not set
-# CONFIG_YENTA is not set
-# CONFIG_YENTA_O2 is not set
-# CONFIG_YENTA_RICOH is not set
-# CONFIG_YENTA_TI is not set
-# CONFIG_YENTA_TOSHIBA is not set
-# CONFIG_ZBUD is not set
-# CONFIG_ZD1211RW is not set
-# CONFIG_ZD1211RW_DEBUG is not set
-# CONFIG_ZEROPLUS_FF is not set
-# CONFIG_ZIIRAVE_WATCHDOG is not set
-# CONFIG_ZISOFS is not set
-# CONFIG_ZLIB_DEFLATE is not set
-# CONFIG_ZLIB_INFLATE is not set
-CONFIG_ZONE_DMA=y
-# CONFIG_ZPA2326 is not set
-# CONFIG_ZPOOL is not set
-# CONFIG_ZRAM is not set
-# CONFIG_ZSMALLOC is not set
-# CONFIG_NET_ACT_CTINFO is not set
--- a/target/linux/generic/files/drivers/misc/owl-loader.c	2022-03-22 08:54:47.140464558 +0800
+++ b/target/linux/generic/files/drivers/misc/owl-loader.c	2022-03-22 12:15:54.070429342 +0800
@@ -40,9 +40,9 @@
 	void __iomem *mem;
 	const void *cal_end = (void *)cal_data + cal_len;
 	const struct {
-		__be16 reg;
-		__be16 low_val;
-		__be16 high_val;
+		u16 reg;
+		u16 low_val;
+		u16 high_val;
 	} __packed *data;
 	u16 cmd;
 	u32 bar0;
@@ -75,14 +75,14 @@
 
 	/* set pointer to first reg address */
 	for (data = (const void *) (cal_data + 3);
-	     (const void *) data <= cal_end && data->reg != cpu_to_be16(~0);
+	     (const void *) data <= cal_end && data->reg != (u16)~0;
 	     data++) {
 		u32 val;
 		u16 reg;
 
 		reg = data->reg;
 		val = data->low_val;
-		val |= data->high_val << 16;
+		val |= ((u32)data->high_val) << 16;
 
 		if (swap_needed) {
 			reg = swab16(reg);
--- a/target/linux/generic/files/drivers/mtd/mtdsplit/mtdsplit_eva.c	2022-03-22 08:54:47.143464563 +0800
+++ b/target/linux/generic/files/drivers/mtd/mtdsplit/mtdsplit_eva.c	2022-03-22 12:15:54.073429321 +0800
@@ -79,21 +79,15 @@
 	return EVA_NR_PARTS;
 }
 
-#include <linux/version.h>
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
 static const struct of_device_id mtdsplit_eva_of_match_table[] = {
 	{ .compatible = "avm,eva-firmware" },
 	{},
 };
-#endif
 
 static struct mtd_part_parser mtdsplit_eva_parser = {
 	.owner = THIS_MODULE,
 	.name = "eva-fw",
-	#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
 	.of_match_table = mtdsplit_eva_of_match_table,
-	#endif
 	.parse_fn = mtdsplit_parse_eva,
 	.type = MTD_PARSER_TYPE_FIRMWARE,
 };
--- a/target/linux/generic/files/drivers/mtd/mtdsplit/mtdsplit_fit.c	2022-03-22 08:54:47.143464563 +0800
+++ b/target/linux/generic/files/drivers/mtd/mtdsplit/mtdsplit_fit.c	2022-03-22 12:15:54.073429321 +0800
@@ -60,8 +60,8 @@
 	hdr_len = sizeof(struct fdt_header);
 
 	/* Parse the MTD device & search for the FIT image location */
-	for(offset = 0; offset < mtd->size; offset += mtd->erasesize) {
-		ret = mtd_read(mtd, 0, hdr_len, &retlen, (void*) &hdr);
+	for(offset = 0; offset + hdr_len <= mtd->size; offset += mtd->erasesize) {
+		ret = mtd_read(mtd, offset, hdr_len, &retlen, (void*) &hdr);
 		if (ret) {
 			pr_err("read error in \"%s\" at offset 0x%llx\n",
 			       mtd->name, (unsigned long long) offset);
--- a/target/linux/generic/files/drivers/mtd/mtdsplit/mtdsplit_jimage.c	2022-03-22 08:54:47.144464564 +0800
+++ b/target/linux/generic/files/drivers/mtd/mtdsplit/mtdsplit_jimage.c	2022-03-22 12:15:54.074429314 +0800
@@ -256,21 +256,15 @@
 				      jimage_verify_default);
 }
 
-#include <linux/version.h>
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
 static const struct of_device_id mtdsplit_jimage_of_match_table[] = {
 	{ .compatible = "amit,jimage" },
 	{},
 };
-#endif
 
 static struct mtd_part_parser jimage_generic_parser = {
 	.owner = THIS_MODULE,
 	.name = "jimage-fw",
-	#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
 	.of_match_table = mtdsplit_jimage_of_match_table,
-	#endif
 	.parse_fn = mtdsplit_jimage_parse_generic,
 	.type = MTD_PARSER_TYPE_FIRMWARE,
 };
--- a/target/linux/generic/files/drivers/mtd/mtdsplit/mtdsplit_lzma.c	2022-03-22 08:54:47.144464564 +0800
+++ b/target/linux/generic/files/drivers/mtd/mtdsplit/mtdsplit_lzma.c	2022-03-22 12:15:54.074429314 +0800
@@ -79,22 +79,16 @@
 	return LZMA_NR_PARTS;
 }
 
-#include <linux/version.h>
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
 static const struct of_device_id mtdsplit_lzma_of_match_table[] = {
 	{ .compatible = "lzma" },
 	{},
 };
 MODULE_DEVICE_TABLE(of, mtdsplit_lzma_of_match_table);
-#endif
 
 static struct mtd_part_parser mtdsplit_lzma_parser = {
 	.owner = THIS_MODULE,
 	.name = "lzma-fw",
-	#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
 	.of_match_table = mtdsplit_lzma_of_match_table,
-	#endif
 	.parse_fn = mtdsplit_parse_lzma,
 	.type = MTD_PARSER_TYPE_FIRMWARE,
 };
--- a/target/linux/generic/files/drivers/mtd/mtdsplit/mtdsplit_minor.c	2022-03-22 08:54:47.145464566 +0800
+++ b/target/linux/generic/files/drivers/mtd/mtdsplit/mtdsplit_minor.c	2022-03-22 12:15:54.075429308 +0800
@@ -100,22 +100,16 @@
 	return MINOR_NR_PARTS;
 }
 
-#include <linux/version.h>
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
 static const struct of_device_id mtdsplit_minor_of_match_table[] = {
 	{ .compatible = "mikrotik,minor" },
 	{},
 };
 MODULE_DEVICE_TABLE(of, mtdsplit_minor_of_match_table);
-#endif
 
 static struct mtd_part_parser mtdsplit_minor_parser = {
 	.owner = THIS_MODULE,
 	.name = "minor-fw",
-	#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
 	.of_match_table = mtdsplit_minor_of_match_table,
-	#endif
 	.parse_fn = mtdsplit_parse_minor,
 	.type = MTD_PARSER_TYPE_FIRMWARE,
 };
--- a/target/linux/generic/files/drivers/mtd/mtdsplit/mtdsplit_seama.c	2022-03-22 08:54:47.145464566 +0800
+++ b/target/linux/generic/files/drivers/mtd/mtdsplit/mtdsplit_seama.c	2022-03-22 12:15:54.075429308 +0800
@@ -93,22 +93,16 @@
 	return SEAMA_NR_PARTS;
 }
 
-#include <linux/version.h>
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
 static const struct of_device_id mtdsplit_seama_of_match_table[] = {
 	{ .compatible = "seama" },
 	{},
 };
 MODULE_DEVICE_TABLE(of, mtdsplit_seama_of_match_table);
-#endif
 
 static struct mtd_part_parser mtdsplit_seama_parser = {
 	.owner = THIS_MODULE,
 	.name = "seama-fw",
-	#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
 	.of_match_table = mtdsplit_seama_of_match_table,
-	#endif
 	.parse_fn = mtdsplit_parse_seama,
 	.type = MTD_PARSER_TYPE_FIRMWARE,
 };
--- a/target/linux/generic/files/drivers/mtd/mtdsplit/mtdsplit_tplink.c	2022-03-22 08:54:47.146464568 +0800
+++ b/target/linux/generic/files/drivers/mtd/mtdsplit/mtdsplit_tplink.c	2022-03-22 12:15:54.076429301 +0800
@@ -152,21 +152,15 @@
 	return TPLINK_NR_PARTS;
 }
 
-#include <linux/version.h>
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
 static const struct of_device_id mtdsplit_tplink_of_match_table[] = {
 	{ .compatible = "tplink,firmware" },
 	{},
 };
-#endif
 
 static struct mtd_part_parser mtdsplit_tplink_parser = {
 	.owner = THIS_MODULE,
 	.name = "tplink-fw",
-	#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
 	.of_match_table = mtdsplit_tplink_of_match_table,
-	#endif
 	.parse_fn = mtdsplit_parse_tplink,
 	.type = MTD_PARSER_TYPE_FIRMWARE,
 };
--- a/target/linux/generic/files/drivers/mtd/mtdsplit/mtdsplit_trx.c	2022-03-22 08:54:47.146464568 +0800
+++ b/target/linux/generic/files/drivers/mtd/mtdsplit/mtdsplit_trx.c	2022-03-22 12:15:54.076429301 +0800
@@ -130,22 +130,16 @@
 	return ret;
 }
 
-#include <linux/version.h>
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
 static const struct of_device_id trx_parser_of_match_table[] = {
 	{ .compatible = "openwrt,trx" },
 	{},
 };
 MODULE_DEVICE_TABLE(of, trx_parser_of_match_table);
-#endif
 
 static struct mtd_part_parser trx_parser = {
 	.owner = THIS_MODULE,
 	.name = "trx-fw",
-	#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
 	.of_match_table = trx_parser_of_match_table,
-	#endif
 	.parse_fn = mtdsplit_parse_trx,
 	.type = MTD_PARSER_TYPE_FIRMWARE,
 };
--- a/target/linux/generic/files/drivers/mtd/mtdsplit/mtdsplit_uimage.c	2022-03-22 08:54:47.147464569 +0800
+++ b/target/linux/generic/files/drivers/mtd/mtdsplit/mtdsplit_uimage.c	2022-03-22 12:15:54.077429294 +0800
@@ -240,7 +240,7 @@
 				      uimage_verify_default);
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)
 static const struct of_device_id mtdsplit_uimage_of_match_table[] = {
 	{ .compatible = "denx,uimage" },
 	{},
@@ -250,7 +250,7 @@
 static struct mtd_part_parser uimage_generic_parser = {
 	.owner = THIS_MODULE,
 	.name = "uimage-fw",
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)
 	.of_match_table = mtdsplit_uimage_of_match_table,
 #endif
 	.parse_fn = mtdsplit_uimage_parse_generic,
@@ -307,7 +307,7 @@
 				      uimage_verify_wndr3700);
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)
 static const struct of_device_id mtdsplit_uimage_netgear_of_match_table[] = {
 	{ .compatible = "netgear,uimage" },
 	{},
@@ -317,7 +317,7 @@
 static struct mtd_part_parser uimage_netgear_parser = {
 	.owner = THIS_MODULE,
 	.name = "netgear-fw",
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)
 	.of_match_table = mtdsplit_uimage_netgear_of_match_table,
 #endif
 	.parse_fn = mtdsplit_uimage_parse_netgear,
@@ -359,7 +359,7 @@
 				       uimage_find_edimax);
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)
 static const struct of_device_id mtdsplit_uimage_edimax_of_match_table[] = {
 	{ .compatible = "edimax,uimage" },
 	{},
@@ -369,7 +369,7 @@
 static struct mtd_part_parser uimage_edimax_parser = {
 	.owner = THIS_MODULE,
 	.name = "edimax-fw",
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)
 	.of_match_table = mtdsplit_uimage_edimax_of_match_table,
 #endif
 	.parse_fn = mtdsplit_uimage_parse_edimax,
--- a/target/linux/generic/files/drivers/mtd/mtdsplit/mtdsplit_wrgg.c	2022-03-22 08:54:47.147464569 +0800
+++ b/target/linux/generic/files/drivers/mtd/mtdsplit/mtdsplit_wrgg.c	2022-03-22 12:15:54.077429294 +0800
@@ -72,6 +72,16 @@
 	/* sanity checks */
 	if (le32_to_cpu(hdr.magic1) == WRGG03_MAGIC) {
 		kernel_ent_size = hdr_len + be32_to_cpu(hdr.size);
+		/*
+		 * If this becomes silly big it's probably because the
+		 * WRGG image is little-endian.
+		 */
+		if (kernel_ent_size > master->size)
+			kernel_ent_size = hdr_len + le32_to_cpu(hdr.size);
+
+		/* Now what ?! It's neither */
+		if (kernel_ent_size > master->size)
+			return -EINVAL;
 	} else if (le32_to_cpu(hdr.magic1) == WRG_MAGIC) {
 		kernel_ent_size = sizeof(struct wrg_header) + le32_to_cpu(
 		                  ((struct wrg_header*)&hdr)->size);
@@ -107,22 +117,16 @@
 	return WRGG_NR_PARTS;
 }
 
-#include <linux/version.h>
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
 static const struct of_device_id mtdsplit_wrgg_of_match_table[] = {
 	{ .compatible = "wrg" },
 	{},
 };
 MODULE_DEVICE_TABLE(of, mtdsplit_wrgg_of_match_table);
-#endif
 
 static struct mtd_part_parser mtdsplit_wrgg_parser = {
 	.owner = THIS_MODULE,
 	.name = "wrgg-fw",
-	#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
 	.of_match_table = mtdsplit_wrgg_of_match_table,
-	#endif
 	.parse_fn = mtdsplit_parse_wrgg,
 	.type = MTD_PARSER_TYPE_FIRMWARE,
 };
--- a/target/linux/generic/files/drivers/net/phy/ar8216.c	2022-03-22 08:54:47.152464578 +0800
+++ b/target/linux/generic/files/drivers/net/phy/ar8216.c	2022-03-22 12:15:54.082429259 +0800
@@ -23,12 +23,14 @@
 #include <linux/skbuff.h>
 #include <linux/netdevice.h>
 #include <linux/netlink.h>
+#include <linux/of_device.h>
+#include <linux/of_mdio.h>
+#include <linux/of_net.h>
 #include <linux/bitops.h>
 #include <net/genetlink.h>
 #include <linux/switch.h>
 #include <linux/delay.h>
 #include <linux/phy.h>
-#include <linux/netdevice.h>
 #include <linux/etherdevice.h>
 #include <linux/lockdep.h>
 #include <linux/ar8216_platform.h>
@@ -40,100 +42,112 @@
 extern const struct ar8xxx_chip ar8327_chip;
 extern const struct ar8xxx_chip ar8337_chip;
 
-#define AR8XXX_MIB_WORK_DELAY	2000 /* msecs */
+#define MIB_DESC_BASIC(_s , _o, _n)		\
+	{					\
+		.size = (_s),			\
+		.offset = (_o),			\
+		.name = (_n),			\
+		.type = AR8XXX_MIB_BASIC,	\
+	}
 
-#define MIB_DESC(_s , _o, _n)	\
-	{			\
-		.size = (_s),	\
-		.offset = (_o),	\
-		.name = (_n),	\
+#define MIB_DESC_EXT(_s , _o, _n)		\
+	{					\
+		.size = (_s),			\
+		.offset = (_o),			\
+		.name = (_n),			\
+		.type = AR8XXX_MIB_EXTENDED,	\
 	}
 
 static const struct ar8xxx_mib_desc ar8216_mibs[] = {
-	MIB_DESC(1, AR8216_STATS_RXBROAD, "RxBroad"),
-	MIB_DESC(1, AR8216_STATS_RXPAUSE, "RxPause"),
-	MIB_DESC(1, AR8216_STATS_RXMULTI, "RxMulti"),
-	MIB_DESC(1, AR8216_STATS_RXFCSERR, "RxFcsErr"),
-	MIB_DESC(1, AR8216_STATS_RXALIGNERR, "RxAlignErr"),
-	MIB_DESC(1, AR8216_STATS_RXRUNT, "RxRunt"),
-	MIB_DESC(1, AR8216_STATS_RXFRAGMENT, "RxFragment"),
-	MIB_DESC(1, AR8216_STATS_RX64BYTE, "Rx64Byte"),
-	MIB_DESC(1, AR8216_STATS_RX128BYTE, "Rx128Byte"),
-	MIB_DESC(1, AR8216_STATS_RX256BYTE, "Rx256Byte"),
-	MIB_DESC(1, AR8216_STATS_RX512BYTE, "Rx512Byte"),
-	MIB_DESC(1, AR8216_STATS_RX1024BYTE, "Rx1024Byte"),
-	MIB_DESC(1, AR8216_STATS_RXMAXBYTE, "RxMaxByte"),
-	MIB_DESC(1, AR8216_STATS_RXTOOLONG, "RxTooLong"),
-	MIB_DESC(2, AR8216_STATS_RXGOODBYTE, "RxGoodByte"),
-	MIB_DESC(2, AR8216_STATS_RXBADBYTE, "RxBadByte"),
-	MIB_DESC(1, AR8216_STATS_RXOVERFLOW, "RxOverFlow"),
-	MIB_DESC(1, AR8216_STATS_FILTERED, "Filtered"),
-	MIB_DESC(1, AR8216_STATS_TXBROAD, "TxBroad"),
-	MIB_DESC(1, AR8216_STATS_TXPAUSE, "TxPause"),
-	MIB_DESC(1, AR8216_STATS_TXMULTI, "TxMulti"),
-	MIB_DESC(1, AR8216_STATS_TXUNDERRUN, "TxUnderRun"),
-	MIB_DESC(1, AR8216_STATS_TX64BYTE, "Tx64Byte"),
-	MIB_DESC(1, AR8216_STATS_TX128BYTE, "Tx128Byte"),
-	MIB_DESC(1, AR8216_STATS_TX256BYTE, "Tx256Byte"),
-	MIB_DESC(1, AR8216_STATS_TX512BYTE, "Tx512Byte"),
-	MIB_DESC(1, AR8216_STATS_TX1024BYTE, "Tx1024Byte"),
-	MIB_DESC(1, AR8216_STATS_TXMAXBYTE, "TxMaxByte"),
-	MIB_DESC(1, AR8216_STATS_TXOVERSIZE, "TxOverSize"),
-	MIB_DESC(2, AR8216_STATS_TXBYTE, "TxByte"),
-	MIB_DESC(1, AR8216_STATS_TXCOLLISION, "TxCollision"),
-	MIB_DESC(1, AR8216_STATS_TXABORTCOL, "TxAbortCol"),
-	MIB_DESC(1, AR8216_STATS_TXMULTICOL, "TxMultiCol"),
-	MIB_DESC(1, AR8216_STATS_TXSINGLECOL, "TxSingleCol"),
-	MIB_DESC(1, AR8216_STATS_TXEXCDEFER, "TxExcDefer"),
-	MIB_DESC(1, AR8216_STATS_TXDEFER, "TxDefer"),
-	MIB_DESC(1, AR8216_STATS_TXLATECOL, "TxLateCol"),
+	MIB_DESC_EXT(1, AR8216_STATS_RXBROAD, "RxBroad"),
+	MIB_DESC_EXT(1, AR8216_STATS_RXPAUSE, "RxPause"),
+	MIB_DESC_EXT(1, AR8216_STATS_RXMULTI, "RxMulti"),
+	MIB_DESC_EXT(1, AR8216_STATS_RXFCSERR, "RxFcsErr"),
+	MIB_DESC_EXT(1, AR8216_STATS_RXALIGNERR, "RxAlignErr"),
+	MIB_DESC_EXT(1, AR8216_STATS_RXRUNT, "RxRunt"),
+	MIB_DESC_EXT(1, AR8216_STATS_RXFRAGMENT, "RxFragment"),
+	MIB_DESC_EXT(1, AR8216_STATS_RX64BYTE, "Rx64Byte"),
+	MIB_DESC_EXT(1, AR8216_STATS_RX128BYTE, "Rx128Byte"),
+	MIB_DESC_EXT(1, AR8216_STATS_RX256BYTE, "Rx256Byte"),
+	MIB_DESC_EXT(1, AR8216_STATS_RX512BYTE, "Rx512Byte"),
+	MIB_DESC_EXT(1, AR8216_STATS_RX1024BYTE, "Rx1024Byte"),
+	MIB_DESC_EXT(1, AR8216_STATS_RXMAXBYTE, "RxMaxByte"),
+	MIB_DESC_EXT(1, AR8216_STATS_RXTOOLONG, "RxTooLong"),
+	MIB_DESC_BASIC(2, AR8216_STATS_RXGOODBYTE, "RxGoodByte"),
+	MIB_DESC_EXT(2, AR8216_STATS_RXBADBYTE, "RxBadByte"),
+	MIB_DESC_EXT(1, AR8216_STATS_RXOVERFLOW, "RxOverFlow"),
+	MIB_DESC_EXT(1, AR8216_STATS_FILTERED, "Filtered"),
+	MIB_DESC_EXT(1, AR8216_STATS_TXBROAD, "TxBroad"),
+	MIB_DESC_EXT(1, AR8216_STATS_TXPAUSE, "TxPause"),
+	MIB_DESC_EXT(1, AR8216_STATS_TXMULTI, "TxMulti"),
+	MIB_DESC_EXT(1, AR8216_STATS_TXUNDERRUN, "TxUnderRun"),
+	MIB_DESC_EXT(1, AR8216_STATS_TX64BYTE, "Tx64Byte"),
+	MIB_DESC_EXT(1, AR8216_STATS_TX128BYTE, "Tx128Byte"),
+	MIB_DESC_EXT(1, AR8216_STATS_TX256BYTE, "Tx256Byte"),
+	MIB_DESC_EXT(1, AR8216_STATS_TX512BYTE, "Tx512Byte"),
+	MIB_DESC_EXT(1, AR8216_STATS_TX1024BYTE, "Tx1024Byte"),
+	MIB_DESC_EXT(1, AR8216_STATS_TXMAXBYTE, "TxMaxByte"),
+	MIB_DESC_EXT(1, AR8216_STATS_TXOVERSIZE, "TxOverSize"),
+	MIB_DESC_BASIC(2, AR8216_STATS_TXBYTE, "TxByte"),
+	MIB_DESC_EXT(1, AR8216_STATS_TXCOLLISION, "TxCollision"),
+	MIB_DESC_EXT(1, AR8216_STATS_TXABORTCOL, "TxAbortCol"),
+	MIB_DESC_EXT(1, AR8216_STATS_TXMULTICOL, "TxMultiCol"),
+	MIB_DESC_EXT(1, AR8216_STATS_TXSINGLECOL, "TxSingleCol"),
+	MIB_DESC_EXT(1, AR8216_STATS_TXEXCDEFER, "TxExcDefer"),
+	MIB_DESC_EXT(1, AR8216_STATS_TXDEFER, "TxDefer"),
+	MIB_DESC_EXT(1, AR8216_STATS_TXLATECOL, "TxLateCol"),
 };
 
 const struct ar8xxx_mib_desc ar8236_mibs[39] = {
-	MIB_DESC(1, AR8236_STATS_RXBROAD, "RxBroad"),
-	MIB_DESC(1, AR8236_STATS_RXPAUSE, "RxPause"),
-	MIB_DESC(1, AR8236_STATS_RXMULTI, "RxMulti"),
-	MIB_DESC(1, AR8236_STATS_RXFCSERR, "RxFcsErr"),
-	MIB_DESC(1, AR8236_STATS_RXALIGNERR, "RxAlignErr"),
-	MIB_DESC(1, AR8236_STATS_RXRUNT, "RxRunt"),
-	MIB_DESC(1, AR8236_STATS_RXFRAGMENT, "RxFragment"),
-	MIB_DESC(1, AR8236_STATS_RX64BYTE, "Rx64Byte"),
-	MIB_DESC(1, AR8236_STATS_RX128BYTE, "Rx128Byte"),
-	MIB_DESC(1, AR8236_STATS_RX256BYTE, "Rx256Byte"),
-	MIB_DESC(1, AR8236_STATS_RX512BYTE, "Rx512Byte"),
-	MIB_DESC(1, AR8236_STATS_RX1024BYTE, "Rx1024Byte"),
-	MIB_DESC(1, AR8236_STATS_RX1518BYTE, "Rx1518Byte"),
-	MIB_DESC(1, AR8236_STATS_RXMAXBYTE, "RxMaxByte"),
-	MIB_DESC(1, AR8236_STATS_RXTOOLONG, "RxTooLong"),
-	MIB_DESC(2, AR8236_STATS_RXGOODBYTE, "RxGoodByte"),
-	MIB_DESC(2, AR8236_STATS_RXBADBYTE, "RxBadByte"),
-	MIB_DESC(1, AR8236_STATS_RXOVERFLOW, "RxOverFlow"),
-	MIB_DESC(1, AR8236_STATS_FILTERED, "Filtered"),
-	MIB_DESC(1, AR8236_STATS_TXBROAD, "TxBroad"),
-	MIB_DESC(1, AR8236_STATS_TXPAUSE, "TxPause"),
-	MIB_DESC(1, AR8236_STATS_TXMULTI, "TxMulti"),
-	MIB_DESC(1, AR8236_STATS_TXUNDERRUN, "TxUnderRun"),
-	MIB_DESC(1, AR8236_STATS_TX64BYTE, "Tx64Byte"),
-	MIB_DESC(1, AR8236_STATS_TX128BYTE, "Tx128Byte"),
-	MIB_DESC(1, AR8236_STATS_TX256BYTE, "Tx256Byte"),
-	MIB_DESC(1, AR8236_STATS_TX512BYTE, "Tx512Byte"),
-	MIB_DESC(1, AR8236_STATS_TX1024BYTE, "Tx1024Byte"),
-	MIB_DESC(1, AR8236_STATS_TX1518BYTE, "Tx1518Byte"),
-	MIB_DESC(1, AR8236_STATS_TXMAXBYTE, "TxMaxByte"),
-	MIB_DESC(1, AR8236_STATS_TXOVERSIZE, "TxOverSize"),
-	MIB_DESC(2, AR8236_STATS_TXBYTE, "TxByte"),
-	MIB_DESC(1, AR8236_STATS_TXCOLLISION, "TxCollision"),
-	MIB_DESC(1, AR8236_STATS_TXABORTCOL, "TxAbortCol"),
-	MIB_DESC(1, AR8236_STATS_TXMULTICOL, "TxMultiCol"),
-	MIB_DESC(1, AR8236_STATS_TXSINGLECOL, "TxSingleCol"),
-	MIB_DESC(1, AR8236_STATS_TXEXCDEFER, "TxExcDefer"),
-	MIB_DESC(1, AR8236_STATS_TXDEFER, "TxDefer"),
-	MIB_DESC(1, AR8236_STATS_TXLATECOL, "TxLateCol"),
+	MIB_DESC_EXT(1, AR8236_STATS_RXBROAD, "RxBroad"),
+	MIB_DESC_EXT(1, AR8236_STATS_RXPAUSE, "RxPause"),
+	MIB_DESC_EXT(1, AR8236_STATS_RXMULTI, "RxMulti"),
+	MIB_DESC_EXT(1, AR8236_STATS_RXFCSERR, "RxFcsErr"),
+	MIB_DESC_EXT(1, AR8236_STATS_RXALIGNERR, "RxAlignErr"),
+	MIB_DESC_EXT(1, AR8236_STATS_RXRUNT, "RxRunt"),
+	MIB_DESC_EXT(1, AR8236_STATS_RXFRAGMENT, "RxFragment"),
+	MIB_DESC_EXT(1, AR8236_STATS_RX64BYTE, "Rx64Byte"),
+	MIB_DESC_EXT(1, AR8236_STATS_RX128BYTE, "Rx128Byte"),
+	MIB_DESC_EXT(1, AR8236_STATS_RX256BYTE, "Rx256Byte"),
+	MIB_DESC_EXT(1, AR8236_STATS_RX512BYTE, "Rx512Byte"),
+	MIB_DESC_EXT(1, AR8236_STATS_RX1024BYTE, "Rx1024Byte"),
+	MIB_DESC_EXT(1, AR8236_STATS_RX1518BYTE, "Rx1518Byte"),
+	MIB_DESC_EXT(1, AR8236_STATS_RXMAXBYTE, "RxMaxByte"),
+	MIB_DESC_EXT(1, AR8236_STATS_RXTOOLONG, "RxTooLong"),
+	MIB_DESC_BASIC(2, AR8236_STATS_RXGOODBYTE, "RxGoodByte"),
+	MIB_DESC_EXT(2, AR8236_STATS_RXBADBYTE, "RxBadByte"),
+	MIB_DESC_EXT(1, AR8236_STATS_RXOVERFLOW, "RxOverFlow"),
+	MIB_DESC_EXT(1, AR8236_STATS_FILTERED, "Filtered"),
+	MIB_DESC_EXT(1, AR8236_STATS_TXBROAD, "TxBroad"),
+	MIB_DESC_EXT(1, AR8236_STATS_TXPAUSE, "TxPause"),
+	MIB_DESC_EXT(1, AR8236_STATS_TXMULTI, "TxMulti"),
+	MIB_DESC_EXT(1, AR8236_STATS_TXUNDERRUN, "TxUnderRun"),
+	MIB_DESC_EXT(1, AR8236_STATS_TX64BYTE, "Tx64Byte"),
+	MIB_DESC_EXT(1, AR8236_STATS_TX128BYTE, "Tx128Byte"),
+	MIB_DESC_EXT(1, AR8236_STATS_TX256BYTE, "Tx256Byte"),
+	MIB_DESC_EXT(1, AR8236_STATS_TX512BYTE, "Tx512Byte"),
+	MIB_DESC_EXT(1, AR8236_STATS_TX1024BYTE, "Tx1024Byte"),
+	MIB_DESC_EXT(1, AR8236_STATS_TX1518BYTE, "Tx1518Byte"),
+	MIB_DESC_EXT(1, AR8236_STATS_TXMAXBYTE, "TxMaxByte"),
+	MIB_DESC_EXT(1, AR8236_STATS_TXOVERSIZE, "TxOverSize"),
+	MIB_DESC_BASIC(2, AR8236_STATS_TXBYTE, "TxByte"),
+	MIB_DESC_EXT(1, AR8236_STATS_TXCOLLISION, "TxCollision"),
+	MIB_DESC_EXT(1, AR8236_STATS_TXABORTCOL, "TxAbortCol"),
+	MIB_DESC_EXT(1, AR8236_STATS_TXMULTICOL, "TxMultiCol"),
+	MIB_DESC_EXT(1, AR8236_STATS_TXSINGLECOL, "TxSingleCol"),
+	MIB_DESC_EXT(1, AR8236_STATS_TXEXCDEFER, "TxExcDefer"),
+	MIB_DESC_EXT(1, AR8236_STATS_TXDEFER, "TxDefer"),
+	MIB_DESC_EXT(1, AR8236_STATS_TXLATECOL, "TxLateCol"),
 };
 
 static DEFINE_MUTEX(ar8xxx_dev_list_lock);
 static LIST_HEAD(ar8xxx_dev_list);
 
+static void
+ar8xxx_mib_start(struct ar8xxx_priv *priv);
+static void
+ar8xxx_mib_stop(struct ar8xxx_priv *priv);
+
 /* inspired by phy_poll_reset in drivers/net/phy/phy_device.c */
 static int
 ar8xxx_phy_poll_reset(struct mii_bus *bus)
@@ -188,7 +202,7 @@
 	int i;
 	struct mii_bus *bus;
 
-	bus = priv->mii_bus;
+	bus = priv->sw_mii_bus ?: priv->mii_bus;
 	for (i = 0; i < AR8XXX_NUM_PHYS; i++) {
 		if (priv->chip->phy_fixup)
 			priv->chip->phy_fixup(priv, i);
@@ -426,6 +440,8 @@
 		u64 t;
 
 		mib = &priv->chip->mib_decs[i];
+		if (mib->type > priv->mib_type)
+			continue;
 		t = ar8xxx_read(priv, base + mib->offset);
 		if (mib->size == 2) {
 			u64 hi;
@@ -651,7 +667,8 @@
 }
 
 static void
-ar8216_setup_port(struct ar8xxx_priv *priv, int port, u32 members)
+__ar8216_setup_port(struct ar8xxx_priv *priv, int port, u32 members,
+		    bool ath_hdr_en)
 {
 	u32 header;
 	u32 egress, ingress;
@@ -670,10 +687,7 @@
 		ingress = AR8216_IN_PORT_ONLY;
 	}
 
-	if (chip_is_ar8216(priv) && priv->vlan && port == AR8216_PORT_CPU)
-		header = AR8216_PORT_CTRL_HEADER;
-	else
-		header = 0;
+	header = ath_hdr_en ? AR8216_PORT_CTRL_HEADER : 0;
 
 	ar8xxx_rmw(priv, AR8216_REG_PORT_CTRL(port),
 		   AR8216_PORT_CTRL_LEARN | AR8216_PORT_CTRL_VLAN_MODE |
@@ -691,12 +705,23 @@
 		   (pvid << AR8216_PORT_VLAN_DEFAULT_ID_S));
 }
 
+static void
+ar8216_setup_port(struct ar8xxx_priv *priv, int port, u32 members)
+{
+	return __ar8216_setup_port(priv, port, members,
+				   chip_is_ar8216(priv) && priv->vlan &&
+				   port == AR8216_PORT_CPU);
+}
+
 static int
 ar8216_hw_init(struct ar8xxx_priv *priv)
 {
 	if (priv->initialized)
 		return 0;
 
+	ar8xxx_write(priv, AR8216_REG_CTRL, AR8216_CTRL_RESET);
+	ar8xxx_reg_wait(priv, AR8216_REG_CTRL, AR8216_CTRL_RESET, 0, 1000);
+
 	ar8xxx_phy_init(priv);
 
 	priv->initialized = true;
@@ -714,7 +739,8 @@
 }
 
 static void
-ar8216_init_port(struct ar8xxx_priv *priv, int port)
+__ar8216_init_port(struct ar8xxx_priv *priv, int port,
+		   bool cpu_ge, bool flow_en)
 {
 	/* Enable port learning and tx */
 	ar8xxx_write(priv, AR8216_REG_PORT_CTRL(port),
@@ -726,12 +752,11 @@
 	if (port == AR8216_PORT_CPU) {
 		ar8xxx_write(priv, AR8216_REG_PORT_STATUS(port),
 			AR8216_PORT_STATUS_LINK_UP |
-			(ar8xxx_has_gige(priv) ?
-                                AR8216_PORT_SPEED_1000M : AR8216_PORT_SPEED_100M) |
+			(cpu_ge ? AR8216_PORT_SPEED_1000M : AR8216_PORT_SPEED_100M) |
 			AR8216_PORT_STATUS_TXMAC |
 			AR8216_PORT_STATUS_RXMAC |
-			(chip_is_ar8316(priv) ? AR8216_PORT_STATUS_RXFLOW : 0) |
-			(chip_is_ar8316(priv) ? AR8216_PORT_STATUS_TXFLOW : 0) |
+			(flow_en ? AR8216_PORT_STATUS_RXFLOW : 0) |
+			(flow_en ? AR8216_PORT_STATUS_TXFLOW : 0) |
 			AR8216_PORT_STATUS_DUPLEX);
 	} else {
 		ar8xxx_write(priv, AR8216_REG_PORT_STATUS(port),
@@ -740,6 +765,13 @@
 }
 
 static void
+ar8216_init_port(struct ar8xxx_priv *priv, int port)
+{
+	__ar8216_init_port(priv, port, ar8xxx_has_gige(priv),
+			   chip_is_ar8316(priv));
+}
+
+static void
 ar8216_wait_atu_ready(struct ar8xxx_priv *priv, u16 r2, u16 r1)
 {
 	int timeout = 20;
@@ -806,6 +838,197 @@
 	}
 }
 
+static int
+ar8216_phy_read(struct ar8xxx_priv *priv, int addr, int regnum)
+{
+	u32 t, val = 0xffff;
+	int err;
+
+	if (addr >= AR8216_NUM_PORTS)
+		return 0xffff;
+	t = (regnum << AR8216_MDIO_CTRL_REG_ADDR_S) |
+	    (addr << AR8216_MDIO_CTRL_PHY_ADDR_S) |
+	    AR8216_MDIO_CTRL_MASTER_EN |
+	    AR8216_MDIO_CTRL_BUSY |
+	    AR8216_MDIO_CTRL_CMD_READ;
+
+	ar8xxx_write(priv, AR8216_REG_MDIO_CTRL, t);
+	err = ar8xxx_reg_wait(priv, AR8216_REG_MDIO_CTRL,
+			      AR8216_MDIO_CTRL_BUSY, 0, 5);
+	if (!err)
+		val = ar8xxx_read(priv, AR8216_REG_MDIO_CTRL);
+
+	return val & AR8216_MDIO_CTRL_DATA_M;
+}
+
+static int
+ar8216_phy_write(struct ar8xxx_priv *priv, int addr, int regnum, u16 val)
+{
+	u32 t;
+	int ret;
+
+	if (addr >= AR8216_NUM_PORTS)
+		return -EINVAL;
+
+	t = (addr << AR8216_MDIO_CTRL_PHY_ADDR_S) |
+	    (regnum << AR8216_MDIO_CTRL_REG_ADDR_S) |
+	    AR8216_MDIO_CTRL_MASTER_EN |
+	    AR8216_MDIO_CTRL_BUSY |
+	    AR8216_MDIO_CTRL_CMD_WRITE |
+	    val;
+
+	ar8xxx_write(priv, AR8216_REG_MDIO_CTRL, t);
+	ret = ar8xxx_reg_wait(priv, AR8216_REG_MDIO_CTRL,
+			      AR8216_MDIO_CTRL_BUSY, 0, 5);
+
+	return ret;
+}
+
+static int
+ar8229_hw_init(struct ar8xxx_priv *priv)
+{
+	int phy_if_mode;
+
+	if (priv->initialized)
+		return 0;
+
+	ar8xxx_write(priv, AR8216_REG_CTRL, AR8216_CTRL_RESET);
+	ar8xxx_reg_wait(priv, AR8216_REG_CTRL, AR8216_CTRL_RESET, 0, 1000);
+
+	phy_if_mode = of_get_phy_mode(priv->pdev->of_node);
+
+	if (phy_if_mode == PHY_INTERFACE_MODE_GMII) {
+		ar8xxx_write(priv, AR8229_REG_OPER_MODE0,
+				 AR8229_OPER_MODE0_MAC_GMII_EN);
+	} else if (phy_if_mode == PHY_INTERFACE_MODE_MII) {
+		ar8xxx_write(priv, AR8229_REG_OPER_MODE0,
+				 AR8229_OPER_MODE0_PHY_MII_EN);
+	} else {
+		pr_err("ar8229: unsupported mii mode\n");
+		return -EINVAL;
+	}
+
+	if (priv->port4_phy) {
+		ar8xxx_write(priv, AR8229_REG_OPER_MODE1,
+			     AR8229_REG_OPER_MODE1_PHY4_MII_EN);
+		/* disable port5 to prevent mii conflict */
+		ar8xxx_write(priv, AR8216_REG_PORT_STATUS(5), 0);
+	}
+
+	ar8xxx_phy_init(priv);
+
+	priv->initialized = true;
+	return 0;
+}
+
+static void
+ar8229_init_globals(struct ar8xxx_priv *priv)
+{
+
+	/* Enable CPU port, and disable mirror port */
+	ar8xxx_write(priv, AR8216_REG_GLOBAL_CPUPORT,
+		     AR8216_GLOBAL_CPUPORT_EN |
+		     (15 << AR8216_GLOBAL_CPUPORT_MIRROR_PORT_S));
+
+	/* Setup TAG priority mapping */
+	ar8xxx_write(priv, AR8216_REG_TAG_PRIORITY, 0xfa50);
+
+	/* Enable aging, MAC replacing */
+	ar8xxx_write(priv, AR8216_REG_ATU_CTRL,
+		     0x2b /* 5 min age time */ |
+		     AR8216_ATU_CTRL_AGE_EN |
+		     AR8216_ATU_CTRL_LEARN_CHANGE);
+
+	/* Enable ARP frame acknowledge */
+	ar8xxx_reg_set(priv, AR8229_REG_QM_CTRL,
+		       AR8229_QM_CTRL_ARP_EN);
+
+	/*
+	 * Enable Broadcast/unknown multicast and unicast frames
+	 * transmitted to the CPU port.
+	 */
+	ar8xxx_reg_set(priv, AR8216_REG_FLOOD_MASK,
+		       AR8229_FLOOD_MASK_BC_DP(0) |
+		       AR8229_FLOOD_MASK_MC_DP(0) |
+		       AR8229_FLOOD_MASK_UC_DP(0));
+
+	/* setup MTU */
+	ar8xxx_rmw(priv, AR8216_REG_GLOBAL_CTRL,
+		   AR8236_GCTRL_MTU, AR8236_GCTRL_MTU);
+
+	/* Enable MIB counters */
+	ar8xxx_reg_set(priv, AR8216_REG_MIB_FUNC,
+		       AR8236_MIB_EN);
+
+	/* setup Service TAG */
+	ar8xxx_rmw(priv, AR8216_REG_SERVICE_TAG, AR8216_SERVICE_TAG_M, 0);
+}
+
+static void
+ar8229_init_port(struct ar8xxx_priv *priv, int port)
+{
+	__ar8216_init_port(priv, port, true, true);
+}
+
+
+static int
+ar7240sw_hw_init(struct ar8xxx_priv *priv)
+{
+	if (priv->initialized)
+		return 0;
+
+	ar8xxx_write(priv, AR8216_REG_CTRL, AR8216_CTRL_RESET);
+	ar8xxx_reg_wait(priv, AR8216_REG_CTRL, AR8216_CTRL_RESET, 0, 1000);
+
+	priv->port4_phy = 1;
+	/* disable port5 to prevent mii conflict */
+	ar8xxx_write(priv, AR8216_REG_PORT_STATUS(5), 0);
+
+	ar8xxx_phy_init(priv);
+
+	priv->initialized = true;
+	return 0;
+}
+
+static void
+ar7240sw_init_globals(struct ar8xxx_priv *priv)
+{
+
+	/* Enable CPU port, and disable mirror port */
+	ar8xxx_write(priv, AR8216_REG_GLOBAL_CPUPORT,
+		     AR8216_GLOBAL_CPUPORT_EN |
+		     (15 << AR8216_GLOBAL_CPUPORT_MIRROR_PORT_S));
+
+	/* Setup TAG priority mapping */
+	ar8xxx_write(priv, AR8216_REG_TAG_PRIORITY, 0xfa50);
+
+	/* Enable ARP frame acknowledge, aging, MAC replacing */
+	ar8xxx_write(priv, AR8216_REG_ATU_CTRL,
+		AR8216_ATU_CTRL_RESERVED |
+		0x2b /* 5 min age time */ |
+		AR8216_ATU_CTRL_AGE_EN |
+		AR8216_ATU_CTRL_ARP_EN |
+		AR8216_ATU_CTRL_LEARN_CHANGE);
+
+	/* Enable Broadcast frames transmitted to the CPU */
+	ar8xxx_reg_set(priv, AR8216_REG_FLOOD_MASK,
+		       AR8216_FM_CPU_BROADCAST_EN);
+
+	/* setup MTU */
+	ar8xxx_rmw(priv, AR8216_REG_GLOBAL_CTRL,
+		   AR8216_GCTRL_MTU,
+		   AR8216_GCTRL_MTU);
+
+	/* setup Service TAG */
+	ar8xxx_rmw(priv, AR8216_REG_SERVICE_TAG, AR8216_SERVICE_TAG_M, 0);
+}
+
+static void
+ar7240sw_setup_port(struct ar8xxx_priv *priv, int port, u32 members)
+{
+	return __ar8216_setup_port(priv, port, members, false);
+}
+
 static void
 ar8236_setup_port(struct ar8xxx_priv *priv, int port, u32 members)
 {
@@ -855,9 +1078,14 @@
 	ar8xxx_reg_set(priv, AR8216_REG_ATU_CTRL,
 		   AR8236_ATU_CTRL_RES);
 
-	/* enable cpu port to receive multicast and broadcast frames */
+	/*
+	 * Enable Broadcast/unknown multicast and unicast frames
+	 * transmitted to the CPU port.
+	 */
 	ar8xxx_reg_set(priv, AR8216_REG_FLOOD_MASK,
-		   AR8236_FM_CPU_BROADCAST_EN | AR8236_FM_CPU_BCAST_FWD_EN);
+		       AR8229_FLOOD_MASK_BC_DP(0) |
+		       AR8229_FLOOD_MASK_MC_DP(0) |
+		       AR8229_FLOOD_MASK_UC_DP(0));
 
 	/* Enable MIB counters */
 	ar8xxx_rmw(priv, AR8216_REG_MIB_FUNC, AR8216_MIB_FUNC | AR8236_MIB_EN,
@@ -1240,6 +1468,62 @@
 }
 
 int
+ar8xxx_sw_set_mib_poll_interval(struct switch_dev *dev,
+			       const struct switch_attr *attr,
+			       struct switch_val *val)
+{
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
+
+	if (!ar8xxx_has_mib_counters(priv))
+		return -EOPNOTSUPP;
+
+	ar8xxx_mib_stop(priv);
+	priv->mib_poll_interval = val->value.i;
+	ar8xxx_mib_start(priv);
+
+	return 0;
+}
+
+int
+ar8xxx_sw_get_mib_poll_interval(struct switch_dev *dev,
+			       const struct switch_attr *attr,
+			       struct switch_val *val)
+{
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
+
+	if (!ar8xxx_has_mib_counters(priv))
+		return -EOPNOTSUPP;
+	val->value.i = priv->mib_poll_interval;
+	return 0;
+}
+
+int
+ar8xxx_sw_set_mib_type(struct switch_dev *dev,
+			       const struct switch_attr *attr,
+			       struct switch_val *val)
+{
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
+
+	if (!ar8xxx_has_mib_counters(priv))
+		return -EOPNOTSUPP;
+	priv->mib_type = val->value.i;
+	return 0;
+}
+
+int
+ar8xxx_sw_get_mib_type(struct switch_dev *dev,
+			       const struct switch_attr *attr,
+			       struct switch_val *val)
+{
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
+
+	if (!ar8xxx_has_mib_counters(priv))
+		return -EOPNOTSUPP;
+	val->value.i = priv->mib_type;
+	return 0;
+}
+
+int
 ar8xxx_sw_set_mirror_rx_enable(struct switch_dev *dev,
 			       const struct switch_attr *attr,
 			       struct switch_val *val)
@@ -1410,7 +1694,7 @@
 	int i, len = 0;
 	bool mib_stats_empty = true;
 
-	if (!ar8xxx_has_mib_counters(priv))
+	if (!ar8xxx_has_mib_counters(priv) || !priv->mib_poll_interval)
 		return -EOPNOTSUPP;
 
 	port = val->port_vlan;
@@ -1429,6 +1713,8 @@
 
 	mib_stats = &priv->mib_stats[port * chip->num_mibs];
 	for (i = 0; i < chip->num_mibs; i++) {
+		if (chip->mib_decs[i].type > priv->mib_type)
+			continue;
 		mib_name = chip->mib_decs[i].name;
 		mib_data = mib_stats[i];
 		len += snprintf(buf + len, sizeof(priv->buf) - len,
@@ -1595,6 +1881,48 @@
 	return ret;
 }
 
+int
+ar8xxx_sw_get_port_stats(struct switch_dev *dev, int port,
+			struct switch_port_stats *stats)
+{
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
+	u64 *mib_stats;
+
+	if (!ar8xxx_has_mib_counters(priv) || !priv->mib_poll_interval)
+		return -EOPNOTSUPP;
+
+	if (!(priv->chip->mib_rxb_id || priv->chip->mib_txb_id))
+		return -EOPNOTSUPP;
+
+	if (port >= dev->ports)
+		return -EINVAL;
+
+	mutex_lock(&priv->mib_lock);
+
+	mib_stats = &priv->mib_stats[port * priv->chip->num_mibs];
+
+	stats->tx_bytes = mib_stats[priv->chip->mib_txb_id];
+	stats->rx_bytes = mib_stats[priv->chip->mib_rxb_id];
+
+	mutex_unlock(&priv->mib_lock);
+	return 0;
+}
+
+static int
+ar8xxx_phy_read(struct mii_bus *bus, int phy_addr, int reg_addr)
+{
+	struct ar8xxx_priv *priv = bus->priv;
+	return priv->chip->phy_read(priv, phy_addr, reg_addr);
+}
+
+static int
+ar8xxx_phy_write(struct mii_bus *bus, int phy_addr, int reg_addr,
+		 u16 reg_val)
+{
+	struct ar8xxx_priv *priv = bus->priv;
+	return priv->chip->phy_write(priv, phy_addr, reg_addr, reg_val);
+}
+
 static const struct switch_attr ar8xxx_sw_attr_globals[] = {
 	{
 		.type = SWITCH_TYPE_INT,
@@ -1612,6 +1940,20 @@
 	},
 	{
 		.type = SWITCH_TYPE_INT,
+		.name = "ar8xxx_mib_poll_interval",
+		.description = "MIB polling interval in msecs (0 to disable)",
+		.set = ar8xxx_sw_set_mib_poll_interval,
+		.get = ar8xxx_sw_get_mib_poll_interval
+	},
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "ar8xxx_mib_type",
+		.description = "MIB type (0=basic 1=extended)",
+		.set = ar8xxx_sw_set_mib_type,
+		.get = ar8xxx_sw_get_mib_type
+	},
+	{
+		.type = SWITCH_TYPE_INT,
 		.name = "enable_mirror_rx",
 		.description = "Enable mirroring of RX packets",
 		.set = ar8xxx_sw_set_mirror_rx_enable,
@@ -1710,16 +2052,41 @@
 	.apply_config = ar8xxx_sw_hw_apply,
 	.reset_switch = ar8xxx_sw_reset_switch,
 	.get_port_link = ar8xxx_sw_get_port_link,
-/* The following op is disabled as it hogs the CPU and degrades performance.
-   An implementation has been attempted in 4d8a66d but reading MIB data is slow
-   on ar8xxx switches.
-
-   The high CPU load has been traced down to the ar8xxx_reg_wait() call in
-   ar8xxx_mib_op(), which has to usleep_range() till the MIB busy flag set by
-   the request to update the MIB counter is cleared. */
-#if 0
 	.get_port_stats = ar8xxx_sw_get_port_stats,
-#endif
+};
+
+static const struct ar8xxx_chip ar7240sw_chip = {
+	.caps = AR8XXX_CAP_MIB_COUNTERS,
+
+	.reg_port_stats_start = 0x20000,
+	.reg_port_stats_length = 0x100,
+	.reg_arl_ctrl = AR8216_REG_ATU_CTRL,
+
+	.name = "Atheros AR724X/AR933X built-in",
+	.ports = AR7240SW_NUM_PORTS,
+	.vlans = AR8216_NUM_VLANS,
+	.swops = &ar8xxx_sw_ops,
+
+	.hw_init = ar7240sw_hw_init,
+	.init_globals = ar7240sw_init_globals,
+	.init_port = ar8229_init_port,
+	.phy_read = ar8216_phy_read,
+	.phy_write = ar8216_phy_write,
+	.setup_port = ar7240sw_setup_port,
+	.read_port_status = ar8216_read_port_status,
+	.atu_flush = ar8216_atu_flush,
+	.atu_flush_port = ar8216_atu_flush_port,
+	.vtu_flush = ar8216_vtu_flush,
+	.vtu_load_vlan = ar8216_vtu_load_vlan,
+	.set_mirror_regs = ar8216_set_mirror_regs,
+	.get_arl_entry = ar8216_get_arl_entry,
+	.sw_hw_apply = ar8xxx_sw_hw_apply,
+
+	.num_mibs = ARRAY_SIZE(ar8236_mibs),
+	.mib_decs = ar8236_mibs,
+	.mib_func = AR8216_REG_MIB_FUNC,
+	.mib_rxb_id = AR8236_MIB_RXB_ID,
+	.mib_txb_id = AR8236_MIB_TXB_ID,
 };
 
 static const struct ar8xxx_chip ar8216_chip = {
@@ -1749,7 +2116,43 @@
 
 	.num_mibs = ARRAY_SIZE(ar8216_mibs),
 	.mib_decs = ar8216_mibs,
-	.mib_func = AR8216_REG_MIB_FUNC
+	.mib_func = AR8216_REG_MIB_FUNC,
+	.mib_rxb_id = AR8216_MIB_RXB_ID,
+	.mib_txb_id = AR8216_MIB_TXB_ID,
+};
+
+static const struct ar8xxx_chip ar8229_chip = {
+	.caps = AR8XXX_CAP_MIB_COUNTERS,
+
+	.reg_port_stats_start = 0x20000,
+	.reg_port_stats_length = 0x100,
+	.reg_arl_ctrl = AR8216_REG_ATU_CTRL,
+
+	.name = "Atheros AR8229",
+	.ports = AR8216_NUM_PORTS,
+	.vlans = AR8216_NUM_VLANS,
+	.swops = &ar8xxx_sw_ops,
+
+	.hw_init = ar8229_hw_init,
+	.init_globals = ar8229_init_globals,
+	.init_port = ar8229_init_port,
+	.phy_read = ar8216_phy_read,
+	.phy_write = ar8216_phy_write,
+	.setup_port = ar8236_setup_port,
+	.read_port_status = ar8216_read_port_status,
+	.atu_flush = ar8216_atu_flush,
+	.atu_flush_port = ar8216_atu_flush_port,
+	.vtu_flush = ar8216_vtu_flush,
+	.vtu_load_vlan = ar8216_vtu_load_vlan,
+	.set_mirror_regs = ar8216_set_mirror_regs,
+	.get_arl_entry = ar8216_get_arl_entry,
+	.sw_hw_apply = ar8xxx_sw_hw_apply,
+
+	.num_mibs = ARRAY_SIZE(ar8236_mibs),
+	.mib_decs = ar8236_mibs,
+	.mib_func = AR8216_REG_MIB_FUNC,
+	.mib_rxb_id = AR8236_MIB_RXB_ID,
+	.mib_txb_id = AR8236_MIB_TXB_ID,
 };
 
 static const struct ar8xxx_chip ar8236_chip = {
@@ -1779,7 +2182,9 @@
 
 	.num_mibs = ARRAY_SIZE(ar8236_mibs),
 	.mib_decs = ar8236_mibs,
-	.mib_func = AR8216_REG_MIB_FUNC
+	.mib_func = AR8216_REG_MIB_FUNC,
+	.mib_rxb_id = AR8236_MIB_RXB_ID,
+	.mib_txb_id = AR8236_MIB_TXB_ID,
 };
 
 static const struct ar8xxx_chip ar8316_chip = {
@@ -1809,11 +2214,13 @@
 
 	.num_mibs = ARRAY_SIZE(ar8236_mibs),
 	.mib_decs = ar8236_mibs,
-	.mib_func = AR8216_REG_MIB_FUNC
+	.mib_func = AR8216_REG_MIB_FUNC,
+	.mib_rxb_id = AR8236_MIB_RXB_ID,
+	.mib_txb_id = AR8236_MIB_TXB_ID,
 };
 
 static int
-ar8xxx_id_chip(struct ar8xxx_priv *priv)
+ar8xxx_read_id(struct ar8xxx_priv *priv)
 {
 	u32 val;
 	u16 id;
@@ -1838,6 +2245,17 @@
 
 	priv->chip_ver = (id & AR8216_CTRL_VERSION) >> AR8216_CTRL_VERSION_S;
 	priv->chip_rev = (id & AR8216_CTRL_REVISION);
+	return 0;
+}
+
+static int
+ar8xxx_id_chip(struct ar8xxx_priv *priv)
+{
+	int ret;
+
+	ret = ar8xxx_read_id(priv);
+	if(ret)
+		return ret;
 
 	switch (priv->chip_ver) {
 	case AR8XXX_VER_AR8216:
@@ -1869,7 +2287,7 @@
 ar8xxx_mib_work_func(struct work_struct *work)
 {
 	struct ar8xxx_priv *priv;
-	int err;
+	int err, i;
 
 	priv = container_of(work, struct ar8xxx_priv, mib_work.work);
 
@@ -1877,18 +2295,15 @@
 
 	err = ar8xxx_mib_capture(priv);
 	if (err)
-		goto next_port;
-
-	ar8xxx_mib_fetch_port_stat(priv, priv->mib_next_port, false);
+		goto next_attempt;
 
-next_port:
-	priv->mib_next_port++;
-	if (priv->mib_next_port >= priv->dev.ports)
-		priv->mib_next_port = 0;
+	for (i = 0; i < priv->dev.ports; i++)
+		ar8xxx_mib_fetch_port_stat(priv, i, false);
 
+next_attempt:
 	mutex_unlock(&priv->mib_lock);
 	schedule_delayed_work(&priv->mib_work,
-			      msecs_to_jiffies(AR8XXX_MIB_WORK_DELAY));
+			      msecs_to_jiffies(priv->mib_poll_interval));
 }
 
 static int
@@ -1914,17 +2329,17 @@
 static void
 ar8xxx_mib_start(struct ar8xxx_priv *priv)
 {
-	if (!ar8xxx_has_mib_counters(priv))
+	if (!ar8xxx_has_mib_counters(priv) || !priv->mib_poll_interval)
 		return;
 
 	schedule_delayed_work(&priv->mib_work,
-			      msecs_to_jiffies(AR8XXX_MIB_WORK_DELAY));
+			      msecs_to_jiffies(priv->mib_poll_interval));
 }
 
 static void
 ar8xxx_mib_stop(struct ar8xxx_priv *priv)
 {
-	if (!ar8xxx_has_mib_counters(priv))
+	if (!ar8xxx_has_mib_counters(priv) || !priv->mib_poll_interval)
 		return;
 
 	cancel_delayed_work_sync(&priv->mib_work);
@@ -1964,10 +2379,6 @@
 	struct switch_dev *swdev;
 	int ret;
 
-	ret = ar8xxx_id_chip(priv);
-	if (ret)
-		return ret;
-
 	chip = priv->chip;
 
 	swdev = &priv->dev;
@@ -2195,6 +2606,16 @@
 	}
 
 	priv->mii_bus = phydev->mdio.bus;
+	priv->pdev = &phydev->mdio.dev;
+
+	ret = of_property_read_u32(priv->pdev->of_node, "qca,mib-poll-interval",
+				   &priv->mib_poll_interval);
+	if (ret)
+		priv->mib_poll_interval = 0;
+
+	ret = ar8xxx_id_chip(priv);
+	if (ret)
+		goto free_priv;
 
 	ret = ar8xxx_probe_switch(priv);
 	if (ret)
@@ -2321,5 +2742,172 @@
 	}
 };
 
-module_phy_driver(ar8xxx_phy_driver);
+static const struct of_device_id ar8xxx_mdiodev_of_match[] = {
+	{
+		.compatible = "qca,ar7240sw",
+		.data = &ar7240sw_chip,
+	}, {
+		.compatible = "qca,ar8229",
+		.data = &ar8229_chip,
+	}, {
+		.compatible = "qca,ar8236",
+		.data = &ar8236_chip,
+	}, {
+		.compatible = "qca,ar8327",
+		.data = &ar8327_chip,
+	},
+	{ /* sentinel */ },
+};
+
+static int
+ar8xxx_mdiodev_probe(struct mdio_device *mdiodev)
+{
+	const struct of_device_id *match;
+	struct ar8xxx_priv *priv;
+	struct switch_dev *swdev;
+	struct device_node *mdio_node;
+	int ret;
+
+	match = of_match_device(ar8xxx_mdiodev_of_match, &mdiodev->dev);
+	if (!match)
+		return -EINVAL;
+
+	priv = ar8xxx_create();
+	if (priv == NULL)
+		return -ENOMEM;
+
+	priv->mii_bus = mdiodev->bus;
+	priv->pdev = &mdiodev->dev;
+	priv->chip = (const struct ar8xxx_chip *) match->data;
+
+	ret = of_property_read_u32(priv->pdev->of_node, "qca,mib-poll-interval",
+				   &priv->mib_poll_interval);
+	if (ret)
+		priv->mib_poll_interval = 0;
+
+	ret = ar8xxx_read_id(priv);
+	if (ret)
+		goto free_priv;
+
+	ret = ar8xxx_probe_switch(priv);
+	if (ret)
+		goto free_priv;
+
+	if (priv->chip->phy_read && priv->chip->phy_write) {
+		priv->sw_mii_bus = devm_mdiobus_alloc(&mdiodev->dev);
+		priv->sw_mii_bus->name = "ar8xxx-mdio";
+		priv->sw_mii_bus->read = ar8xxx_phy_read;
+		priv->sw_mii_bus->write = ar8xxx_phy_write;
+		priv->sw_mii_bus->priv = priv;
+		priv->sw_mii_bus->parent = &mdiodev->dev;
+		snprintf(priv->sw_mii_bus->id, MII_BUS_ID_SIZE, "%s",
+			 dev_name(&mdiodev->dev));
+		mdio_node = of_get_child_by_name(priv->pdev->of_node, "mdio-bus");
+		ret = of_mdiobus_register(priv->sw_mii_bus, mdio_node);
+		if (ret)
+			goto free_priv;
+	}
+
+	swdev = &priv->dev;
+	swdev->alias = dev_name(&mdiodev->dev);
+
+	if (of_property_read_bool(priv->pdev->of_node, "qca,phy4-mii-enable")) {
+		priv->port4_phy = true;
+		swdev->ports--;
+	}
+
+	ret = register_switch(swdev, NULL);
+	if (ret)
+		goto free_priv;
+
+	pr_info("%s: %s rev. %u switch registered on %s\n",
+		swdev->devname, swdev->name, priv->chip_rev,
+		dev_name(&priv->mii_bus->dev));
+
+	mutex_lock(&ar8xxx_dev_list_lock);
+	list_add(&priv->list, &ar8xxx_dev_list);
+	mutex_unlock(&ar8xxx_dev_list_lock);
+
+	priv->use_count++;
+
+	ret = ar8xxx_start(priv);
+	if (ret)
+		goto err_unregister_switch;
+
+	dev_set_drvdata(&mdiodev->dev, priv);
+
+	return 0;
+
+err_unregister_switch:
+	if (--priv->use_count)
+		return ret;
+
+	unregister_switch(&priv->dev);
+
+free_priv:
+	ar8xxx_free(priv);
+	return ret;
+}
+
+static void
+ar8xxx_mdiodev_remove(struct mdio_device *mdiodev)
+{
+	struct ar8xxx_priv *priv = dev_get_drvdata(&mdiodev->dev);
+
+	if (WARN_ON(!priv))
+		return;
+
+	mutex_lock(&ar8xxx_dev_list_lock);
+
+	if (--priv->use_count > 0) {
+		mutex_unlock(&ar8xxx_dev_list_lock);
+		return;
+	}
+
+	list_del(&priv->list);
+	mutex_unlock(&ar8xxx_dev_list_lock);
+
+	unregister_switch(&priv->dev);
+	ar8xxx_mib_stop(priv);
+	if(priv->sw_mii_bus)
+		mdiobus_unregister(priv->sw_mii_bus);
+	ar8xxx_free(priv);
+}
+
+static struct mdio_driver ar8xxx_mdio_driver = {
+	.probe  = ar8xxx_mdiodev_probe,
+	.remove = ar8xxx_mdiodev_remove,
+	.mdiodrv.driver = {
+		.name = "ar8xxx-switch",
+		.of_match_table = ar8xxx_mdiodev_of_match,
+	},
+};
+
+static int __init ar8216_init(void)
+{
+	int ret;
+
+	ret = phy_drivers_register(ar8xxx_phy_driver,
+				   ARRAY_SIZE(ar8xxx_phy_driver),
+				   THIS_MODULE);
+	if (ret)
+		return ret;
+
+	ret = mdio_driver_register(&ar8xxx_mdio_driver);
+	if (ret)
+		phy_drivers_unregister(ar8xxx_phy_driver,
+				       ARRAY_SIZE(ar8xxx_phy_driver));
+
+	return ret;
+}
+module_init(ar8216_init);
+
+static void __exit ar8216_exit(void)
+{
+	mdio_driver_unregister(&ar8xxx_mdio_driver);
+	phy_drivers_unregister(ar8xxx_phy_driver,
+			        ARRAY_SIZE(ar8xxx_phy_driver));
+}
+module_exit(ar8216_exit);
+
 MODULE_LICENSE("GPL");
--- a/target/linux/generic/files/drivers/net/phy/ar8216.h	2022-03-22 08:54:47.153464579 +0800
+++ b/target/linux/generic/files/drivers/net/phy/ar8216.h	2022-03-22 12:15:54.083429252 +0800
@@ -26,6 +26,7 @@
 #define AR8216_PORT_CPU	0
 #define AR8216_NUM_PORTS	6
 #define AR8216_NUM_VLANS	16
+#define AR7240SW_NUM_PORTS	5
 #define AR8316_NUM_VLANS	4096
 
 /* size of the vlan table */
@@ -55,8 +56,10 @@
 #define AR8216_REG_FLOOD_MASK		0x002C
 #define   AR8216_FM_UNI_DEST_PORTS	BITS(0, 6)
 #define   AR8216_FM_MULTI_DEST_PORTS	BITS(16, 6)
-#define   AR8236_FM_CPU_BROADCAST_EN	BIT(26)
-#define   AR8236_FM_CPU_BCAST_FWD_EN	BIT(25)
+#define   AR8216_FM_CPU_BROADCAST_EN	BIT(26)
+#define   AR8229_FLOOD_MASK_UC_DP(_p)	BIT(_p)
+#define   AR8229_FLOOD_MASK_MC_DP(_p)	BIT(16 + (_p))
+#define   AR8229_FLOOD_MASK_BC_DP(_p)	BIT(25 + (_p))
 
 #define AR8216_REG_GLOBAL_CTRL		0x0030
 #define   AR8216_GCTRL_MTU		BITS(0, 11)
@@ -130,6 +133,14 @@
 #define   AR8216_ATU_CTRL_AGE_TIME	BITS(0, 16)
 #define   AR8216_ATU_CTRL_AGE_TIME_S	0
 #define   AR8236_ATU_CTRL_RES		BIT(20)
+#define   AR8216_ATU_CTRL_LEARN_CHANGE	BIT(18)
+#define   AR8216_ATU_CTRL_RESERVED	BIT(19)
+#define   AR8216_ATU_CTRL_ARP_EN	BIT(20)
+
+#define AR8216_REG_TAG_PRIORITY	0x0070
+
+#define AR8216_REG_SERVICE_TAG		0x0074
+#define  AR8216_SERVICE_TAG_M		BITS(0, 16)
 
 #define AR8216_REG_MIB_FUNC		0x0080
 #define   AR8216_MIB_TIMER		BITS(0, 16)
@@ -145,6 +156,16 @@
 #define AR8216_REG_GLOBAL_CPUPORT		0x0078
 #define   AR8216_GLOBAL_CPUPORT_MIRROR_PORT	BITS(4, 4)
 #define   AR8216_GLOBAL_CPUPORT_MIRROR_PORT_S	4
+#define   AR8216_GLOBAL_CPUPORT_EN		BIT(8)
+
+#define AR8216_REG_MDIO_CTRL		0x98
+#define   AR8216_MDIO_CTRL_DATA_M	BITS(0, 16)
+#define   AR8216_MDIO_CTRL_REG_ADDR_S	16
+#define   AR8216_MDIO_CTRL_PHY_ADDR_S	21
+#define   AR8216_MDIO_CTRL_CMD_WRITE	0
+#define   AR8216_MDIO_CTRL_CMD_READ	BIT(27)
+#define   AR8216_MDIO_CTRL_MASTER_EN	BIT(30)
+#define   AR8216_MDIO_CTRL_BUSY	BIT(31)
 
 #define AR8216_PORT_OFFSET(_i)		(0x0100 * (_i + 1))
 #define AR8216_REG_PORT_STATUS(_i)	(AR8216_PORT_OFFSET(_i) + 0x0000)
@@ -240,6 +261,19 @@
 #define AR8216_STATS_TXDEFER		0x98
 #define AR8216_STATS_TXLATECOL		0x9c
 
+#define AR8216_MIB_RXB_ID		14	/* RxGoodByte */
+#define AR8216_MIB_TXB_ID		29	/* TxByte */
+
+#define AR8229_REG_OPER_MODE0		0x04
+#define   AR8229_OPER_MODE0_MAC_GMII_EN	BIT(6)
+#define   AR8229_OPER_MODE0_PHY_MII_EN	BIT(10)
+
+#define AR8229_REG_OPER_MODE1		0x08
+#define   AR8229_REG_OPER_MODE1_PHY4_MII_EN	BIT(28)
+
+#define AR8229_REG_QM_CTRL		0x3c
+#define   AR8229_QM_CTRL_ARP_EN		BIT(15)
+
 #define AR8236_REG_PORT_VLAN(_i)	(AR8216_PORT_OFFSET((_i)) + 0x0008)
 #define   AR8236_PORT_VLAN_DEFAULT_ID	BITS(16, 12)
 #define   AR8236_PORT_VLAN_DEFAULT_ID_S	16
@@ -293,6 +327,9 @@
 #define AR8236_STATS_TXDEFER		0xa0
 #define AR8236_STATS_TXLATECOL		0xa4
 
+#define AR8236_MIB_RXB_ID		15	/* RxGoodByte */
+#define AR8236_MIB_TXB_ID		31	/* TxByte */
+
 #define AR8316_REG_POSTRIP			0x0008
 #define   AR8316_POSTRIP_MAC0_GMII_EN		BIT(0)
 #define   AR8316_POSTRIP_MAC0_RGMII_EN		BIT(1)
@@ -355,6 +392,12 @@
 	AR8216_PORT_STATE_FORWARD = 4
 };
 
+/* mib counter type */
+enum {
+	AR8XXX_MIB_BASIC = 0,
+	AR8XXX_MIB_EXTENDED = 1
+};
+
 enum {
 	AR8XXX_VER_AR8216 = 0x01,
 	AR8XXX_VER_AR8236 = 0x03,
@@ -381,6 +424,7 @@
 	unsigned int size;
 	unsigned int offset;
 	const char *name;
+	u8 type;
 };
 
 struct ar8xxx_chip {
@@ -417,16 +461,22 @@
 			      u32 *status, enum arl_op op);
 	int (*sw_hw_apply)(struct switch_dev *dev);
 	void (*phy_rgmii_set)(struct ar8xxx_priv *priv, struct phy_device *phydev);
+	int (*phy_read)(struct ar8xxx_priv *priv, int addr, int regnum);
+	int (*phy_write)(struct ar8xxx_priv *priv, int addr, int regnum, u16 val);
 
 	const struct ar8xxx_mib_desc *mib_decs;
 	unsigned num_mibs;
 	unsigned mib_func;
+	int mib_rxb_id;
+	int mib_txb_id;
 };
 
 struct ar8xxx_priv {
 	struct switch_dev dev;
 	struct mii_bus *mii_bus;
+	struct mii_bus *sw_mii_bus;
 	struct phy_device *phy;
+	struct device *pdev;
 
 	int (*get_port_link)(unsigned port);
 
@@ -448,8 +498,9 @@
 
 	struct mutex mib_lock;
 	struct delayed_work mib_work;
-	int mib_next_port;
 	u64 *mib_stats;
+	u32 mib_poll_interval;
+	u8 mib_type;
 
 	struct list_head list;
 	unsigned int use_count;
@@ -505,6 +556,22 @@
 			 const struct switch_attr *attr,
 			 struct switch_val *val);
 int
+ar8xxx_sw_set_mib_poll_interval(struct switch_dev *dev,
+			       const struct switch_attr *attr,
+			       struct switch_val *val);
+int
+ar8xxx_sw_get_mib_poll_interval(struct switch_dev *dev,
+			       const struct switch_attr *attr,
+			       struct switch_val *val);
+int
+ar8xxx_sw_set_mib_type(struct switch_dev *dev,
+			       const struct switch_attr *attr,
+			       struct switch_val *val);
+int
+ar8xxx_sw_get_mib_type(struct switch_dev *dev,
+			       const struct switch_attr *attr,
+			       struct switch_val *val);
+int
 ar8xxx_sw_set_mirror_rx_enable(struct switch_dev *dev,
 			       const struct switch_attr *attr,
 			       struct switch_val *val);
@@ -576,6 +643,9 @@
 				   const struct switch_attr *attr,
 				   struct switch_val *val);
 int
+ar8xxx_sw_get_port_stats(struct switch_dev *dev, int port,
+			struct switch_port_stats *stats);
+int
 ar8216_wait_bit(struct ar8xxx_priv *priv, int reg, u32 mask, u32 val);
 
 static inline struct ar8xxx_priv *
--- a/target/linux/generic/files/drivers/net/phy/ar8327.c	2022-03-22 08:54:47.154464581 +0800
+++ b/target/linux/generic/files/drivers/net/phy/ar8327.c	2022-03-22 12:15:54.085429239 +0800
@@ -139,7 +139,7 @@
 
 	if (!of_property_read_bool(np, "qca,phy-rgmii-en")) {
 		pr_err("ar8327: qca,phy-rgmii-en is not specified\n");
-		return -EINVAL;
+		return;
 	}
 	ar8xxx_phy_dbg_read(priv, phyaddr,
 				AR8327_PHY_MODE_SEL, &phy_val);
@@ -150,7 +150,7 @@
 	/* set rgmii tx clock delay if needed */
 	if (!of_property_read_bool(np, "qca,txclk-delay-en")) {
 		pr_err("ar8327: qca,txclk-delay-en is not specified\n");
-		return -EINVAL;
+		return;
 	}
 	ar8xxx_phy_dbg_read(priv, phyaddr,
 				AR8327_PHY_SYS_CTRL, &phy_val);
@@ -161,7 +161,7 @@
 	/* set rgmii rx clock delay if needed */
 	if (!of_property_read_bool(np, "qca,rxclk-delay-en")) {
 		pr_err("ar8327: qca,rxclk-delay-en is not specified\n");
-		return -EINVAL;
+		return;
 	}
 	ar8xxx_phy_dbg_read(priv, phyaddr,
 				AR8327_PHY_TEST_CTRL, &phy_val);
@@ -662,8 +662,8 @@
 	if (!priv->chip_data)
 		return -ENOMEM;
 
-	if (priv->phy->mdio.dev.of_node)
-		ret = ar8327_hw_config_of(priv, priv->phy->mdio.dev.of_node);
+	if (priv->pdev->of_node)
+		ret = ar8327_hw_config_of(priv, priv->pdev->of_node);
 	else
 		ret = ar8327_hw_config_pdata(priv,
 					     priv->phy->mdio.dev.platform_data);
@@ -1323,6 +1323,20 @@
 	},
 	{
 		.type = SWITCH_TYPE_INT,
+		.name = "ar8xxx_mib_poll_interval",
+		.description = "MIB polling interval in msecs (0 to disable)",
+		.set = ar8xxx_sw_set_mib_poll_interval,
+		.get = ar8xxx_sw_get_mib_poll_interval
+	},
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "ar8xxx_mib_type",
+		.description = "MIB type (0=basic 1=extended)",
+		.set = ar8xxx_sw_set_mib_type,
+		.get = ar8xxx_sw_get_mib_type
+	},
+	{
+		.type = SWITCH_TYPE_INT,
 		.name = "enable_mirror_rx",
 		.description = "Enable mirroring of RX packets",
 		.set = ar8xxx_sw_set_mirror_rx_enable,
@@ -1457,16 +1471,7 @@
 	.apply_config = ar8327_sw_hw_apply,
 	.reset_switch = ar8xxx_sw_reset_switch,
 	.get_port_link = ar8xxx_sw_get_port_link,
-/* The following op is disabled as it hogs the CPU and degrades performance.
-   An implementation has been attempted in 4d8a66d but reading MIB data is slow
-   on ar8xxx switches.
-
-   The high CPU load has been traced down to the ar8xxx_reg_wait() call in
-   ar8xxx_mib_op(), which has to usleep_range() till the MIB busy flag set by
-   the request to update the MIB counter is cleared. */
-#if 0
 	.get_port_stats = ar8xxx_sw_get_port_stats,
-#endif
 };
 
 const struct ar8xxx_chip ar8327_chip = {
@@ -1501,7 +1506,9 @@
 
 	.num_mibs = ARRAY_SIZE(ar8236_mibs),
 	.mib_decs = ar8236_mibs,
-	.mib_func = AR8327_REG_MIB_FUNC
+	.mib_func = AR8327_REG_MIB_FUNC,
+	.mib_rxb_id = AR8236_MIB_RXB_ID,
+	.mib_txb_id = AR8236_MIB_TXB_ID,
 };
 
 const struct ar8xxx_chip ar8337_chip = {
@@ -1537,5 +1544,7 @@
 
 	.num_mibs = ARRAY_SIZE(ar8236_mibs),
 	.mib_decs = ar8236_mibs,
-	.mib_func = AR8327_REG_MIB_FUNC
+	.mib_func = AR8327_REG_MIB_FUNC,
+	.mib_rxb_id = AR8236_MIB_RXB_ID,
+	.mib_txb_id = AR8236_MIB_TXB_ID,
 };
--- a/target/linux/generic/files/drivers/net/phy/b53/b53_mdio.c	2022-03-22 08:54:47.158464588 +0800
+++ b/target/linux/generic/files/drivers/net/phy/b53/b53_mdio.c	2022-03-22 12:15:54.089429211 +0800
@@ -294,12 +294,22 @@
 	if (ret)
 		return ret;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 0, 0)
+	linkmode_zero(phydev->supported);
+	if (is5325(dev) || is5365(dev))
+		linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, phydev->supported);
+	else
+		linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT, phydev->supported);
+
+	linkmode_copy(phydev->advertising, phydev->supported);
+#else
 	if (is5325(dev) || is5365(dev))
 		phydev->supported = SUPPORTED_100baseT_Full;
 	else
 		phydev->supported = SUPPORTED_1000baseT_Full;
 
 	phydev->advertising = phydev->supported;
+#endif
 
 	ret = b53_switch_register(dev);
 	if (ret) {
--- a/target/linux/generic/files/drivers/net/phy/swconfig.c	2022-03-22 08:54:47.176464618 +0800
+++ b/target/linux/generic/files/drivers/net/phy/swconfig.c	2022-03-22 12:15:54.108429080 +0800
@@ -1001,75 +1001,55 @@
 	{
 		.cmd = SWITCH_CMD_LIST_GLOBAL,
 		.doit = swconfig_list_attrs,
-#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 2, 0)
 		.policy = switch_policy,
-#endif
 	},
 	{
 		.cmd = SWITCH_CMD_LIST_VLAN,
 		.doit = swconfig_list_attrs,
-#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 2, 0)
 		.policy = switch_policy,
-#endif
 	},
 	{
 		.cmd = SWITCH_CMD_LIST_PORT,
 		.doit = swconfig_list_attrs,
-#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 2, 0)
 		.policy = switch_policy,
-#endif
 	},
 	{
 		.cmd = SWITCH_CMD_GET_GLOBAL,
 		.doit = swconfig_get_attr,
-#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 2, 0)
 		.policy = switch_policy,
-#endif
 	},
 	{
 		.cmd = SWITCH_CMD_GET_VLAN,
 		.doit = swconfig_get_attr,
-#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 2, 0)
 		.policy = switch_policy,
-#endif
 	},
 	{
 		.cmd = SWITCH_CMD_GET_PORT,
 		.doit = swconfig_get_attr,
-#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 2, 0)
 		.policy = switch_policy,
-#endif
 	},
 	{
 		.cmd = SWITCH_CMD_SET_GLOBAL,
 		.flags = GENL_ADMIN_PERM,
 		.doit = swconfig_set_attr,
-#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 2, 0)
 		.policy = switch_policy,
-#endif
 	},
 	{
 		.cmd = SWITCH_CMD_SET_VLAN,
 		.flags = GENL_ADMIN_PERM,
 		.doit = swconfig_set_attr,
-#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 2, 0)
 		.policy = switch_policy,
-#endif
 	},
 	{
 		.cmd = SWITCH_CMD_SET_PORT,
 		.flags = GENL_ADMIN_PERM,
 		.doit = swconfig_set_attr,
-#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 2, 0)
 		.policy = switch_policy,
-#endif
 	},
 	{
 		.cmd = SWITCH_CMD_GET_SWITCH,
 		.dumpit = swconfig_dump_switches,
-#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 2, 0)
 		.policy = switch_policy,
-#endif
 		.done = swconfig_done,
 	}
 };
@@ -1082,9 +1062,6 @@
 	.hdrsize = 0,
 	.version = 1,
 	.maxattr = SWITCH_ATTR_MAX,
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 2, 0)
-	.policy = switch_policy,
-#endif
 	.module = THIS_MODULE,
 	.ops = swconfig_ops,
 	.n_ops = ARRAY_SIZE(swconfig_ops),
--- a/target/linux/generic/files/drivers/platform/mikrotik/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/files/drivers/platform/mikrotik/Kconfig	2022-03-22 12:15:54.110429067 +0800
@@ -0,0 +1,18 @@
+menuconfig MIKROTIK
+	bool "Platform support for MikroTik RouterBoard virtual devices"
+	default n
+	depends on MTD
+	select LZO_DECOMPRESS
+	help
+	  Say Y here to get to see options for the MikroTik RouterBoard platform.
+	  This option alone does not add any kernel code.
+
+
+if MIKROTIK
+
+config MIKROTIK_RB_SYSFS
+	tristate "RouterBoot sysfs support"
+	help
+	  This driver exposes RouterBoot configuration in sysfs.
+
+endif # MIKROTIK
--- a/target/linux/generic/files/drivers/platform/mikrotik/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/files/drivers/platform/mikrotik/Makefile	2022-03-22 12:15:54.110429067 +0800
@@ -0,0 +1,4 @@
+#
+# Makefile for MikroTik RouterBoard platform specific drivers
+#
+obj-$(CONFIG_MIKROTIK_RB_SYSFS)     += routerboot.o rb_hardconfig.o
--- a/target/linux/generic/files/drivers/platform/mikrotik/rb_hardconfig.c	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/files/drivers/platform/mikrotik/rb_hardconfig.c	2022-03-22 12:15:54.111429060 +0800
@@ -0,0 +1,759 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Driver for MikroTik RouterBoot hard config.
+ *
+ * Copyright (C) 2020 Thibaut VARNE <hacks+kernel@slashdirt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ * This driver exposes the data encoded in the "hard_config" flash segment of
+ * MikroTik RouterBOARDs devices. It presents the data in a sysfs folder
+ * named "hard_config". The WLAN calibration data is available on demand via
+ * the 'wlan_data' sysfs file in that folder.
+ *
+ * This driver permanently allocates a chunk of RAM as large as the hard_config
+ * MTD partition, although it is technically possible to operate entirely from
+ * the MTD device without using a local buffer (except when requesting WLAN
+ * calibration data), at the cost of a performance penalty.
+ *
+ * Some constant defines extracted from routerboot.{c,h} by Gabor Juhos
+ * <juhosg@openwrt.org>
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/kobject.h>
+#include <linux/bitops.h>
+#include <linux/string.h>
+#include <linux/mtd/mtd.h>
+#include <linux/sysfs.h>
+#include <linux/lzo.h>
+
+#include "routerboot.h"
+
+#define RB_HARDCONFIG_VER		"0.03"
+#define RB_HC_PR_PFX			"[rb_hardconfig] "
+
+/* ID values for hardware settings */
+#define RB_ID_FLASH_INFO		0x03
+#define RB_ID_MAC_ADDRESS_PACK		0x04
+#define RB_ID_BOARD_PRODUCT_CODE	0x05
+#define RB_ID_BIOS_VERSION		0x06
+#define RB_ID_SDRAM_TIMINGS		0x08
+#define RB_ID_DEVICE_TIMINGS		0x09
+#define RB_ID_SOFTWARE_ID		0x0A
+#define RB_ID_SERIAL_NUMBER		0x0B
+#define RB_ID_MEMORY_SIZE		0x0D
+#define RB_ID_MAC_ADDRESS_COUNT		0x0E
+#define RB_ID_HW_OPTIONS		0x15
+#define RB_ID_WLAN_DATA			0x16
+#define RB_ID_BOARD_IDENTIFIER		0x17
+#define RB_ID_PRODUCT_NAME		0x21
+#define RB_ID_DEFCONF			0x26
+
+/* Bit definitions for hardware options */
+#define RB_HW_OPT_NO_UART		BIT(0)
+#define RB_HW_OPT_HAS_VOLTAGE		BIT(1)
+#define RB_HW_OPT_HAS_USB		BIT(2)
+#define RB_HW_OPT_HAS_ATTINY		BIT(3)
+#define RB_HW_OPT_NO_NAND		BIT(14)
+#define RB_HW_OPT_HAS_LCD		BIT(15)
+#define RB_HW_OPT_HAS_POE_OUT		BIT(16)
+#define RB_HW_OPT_HAS_uSD		BIT(17)
+#define RB_HW_OPT_HAS_SIM		BIT(18)
+#define RB_HW_OPT_HAS_SFP		BIT(20)
+#define RB_HW_OPT_HAS_WIFI		BIT(21)
+#define RB_HW_OPT_HAS_TS_FOR_ADC	BIT(22)
+#define RB_HW_OPT_HAS_PLC		BIT(29)
+
+static struct kobject *hc_kobj;
+static u8 *hc_buf;		// ro buffer after init(): no locking required
+static size_t hc_buflen;
+
+/*
+ * For LZOR style WLAN data unpacking.
+ * This binary blob is prepended to the data encoded on some devices as
+ * RB_ID_WLAN_DATA, the result is then first decompressed with LZO, and then
+ * finally RLE-decoded.
+ * This binary blob has been extracted from RouterOS by
+ * https://forum.openwrt.org/u/ius
+ */
+static const u8 hc_lzor_prefix[] = {
+	0x00, 0x05, 0x4c, 0x4c, 0x44, 0x00, 0x34, 0xfe,
+	0xfe, 0x34, 0x11, 0x3c, 0x1e, 0x3c, 0x2e, 0x3c,
+	0x4c, 0x34, 0x00, 0x52, 0x62, 0x92, 0xa2, 0xb2,
+	0xc3, 0x2a, 0x14, 0x00, 0x00, 0x05, 0xfe, 0x6a,
+	0x3c, 0x16, 0x32, 0x16, 0x11, 0x1e, 0x12, 0x46,
+	0x32, 0x46, 0x11, 0x4e, 0x12, 0x36, 0x32, 0x36,
+	0x11, 0x3e, 0x12, 0x5a, 0x9a, 0x64, 0x00, 0x04,
+	0xfe, 0x10, 0x3c, 0x00, 0x01, 0x00, 0x00, 0x28,
+	0x0c, 0x00, 0x0f, 0xfe, 0x14, 0x00, 0x24, 0x24,
+	0x23, 0x24, 0x24, 0x23, 0x25, 0x22, 0x21, 0x21,
+	0x23, 0x22, 0x21, 0x22, 0x21, 0x2d, 0x38, 0x00,
+	0x0c, 0x25, 0x25, 0x24, 0x25, 0x25, 0x24, 0x23,
+	0x22, 0x21, 0x20, 0x23, 0x21, 0x21, 0x22, 0x21,
+	0x2d, 0x38, 0x00, 0x28, 0xb0, 0x00, 0x00, 0x22,
+	0x00, 0x00, 0xc0, 0xfe, 0x03, 0x00, 0xc0, 0x00,
+	0x62, 0xff, 0x62, 0xff, 0xfe, 0x06, 0x00, 0xbb,
+	0xff, 0xba, 0xff, 0xfe, 0x08, 0x00, 0x9e, 0xff,
+	0xfe, 0x0a, 0x00, 0x53, 0xff, 0xfe, 0x02, 0x00,
+	0x20, 0xff, 0xb1, 0xfe, 0xfe, 0xb2, 0xfe, 0xfe,
+	0xed, 0xfe, 0xfe, 0xfe, 0x04, 0x00, 0x3a, 0xff,
+	0x3a, 0xff, 0xde, 0xfd, 0x5f, 0x04, 0x33, 0xff,
+	0x4c, 0x74, 0x03, 0x05, 0x05, 0xff, 0x6d, 0xfe,
+	0xfe, 0x6d, 0xfe, 0xfe, 0xaf, 0x08, 0x63, 0xff,
+	0x64, 0x6f, 0x08, 0xac, 0xff, 0xbf, 0x6d, 0x08,
+	0x7a, 0x6d, 0x08, 0x96, 0x74, 0x04, 0x00, 0x08,
+	0x79, 0xff, 0xda, 0xfe, 0xfe, 0xdb, 0xfe, 0xfe,
+	0x56, 0xff, 0xfe, 0x04, 0x00, 0x5e, 0xff, 0x5e,
+	0xff, 0x6c, 0xfe, 0xfe, 0xfe, 0x06, 0x00, 0x41,
+	0xff, 0x7f, 0x74, 0x03, 0x00, 0x11, 0x44, 0xff,
+	0xa9, 0xfe, 0xfe, 0xa9, 0xfe, 0xfe, 0xa5, 0x8f,
+	0x01, 0x00, 0x08, 0x01, 0x01, 0x02, 0x04, 0x08,
+	0x02, 0x04, 0x08, 0x08, 0x01, 0x01, 0xfe, 0x22,
+	0x00, 0x4c, 0x60, 0x64, 0x8c, 0x90, 0xd0, 0xd4,
+	0xd8, 0x5c, 0x10, 0x09, 0xd8, 0xff, 0xb0, 0xff,
+	0x00, 0x00, 0xba, 0xff, 0x14, 0x00, 0xba, 0xff,
+	0x64, 0x00, 0x00, 0x08, 0xfe, 0x06, 0x00, 0x74,
+	0xff, 0x42, 0xff, 0xce, 0xff, 0x60, 0xff, 0x0a,
+	0x00, 0xb4, 0x00, 0xa0, 0x00, 0xa0, 0xfe, 0x07,
+	0x00, 0x0a, 0x00, 0xb0, 0xff, 0x96, 0x4d, 0x00,
+	0x56, 0x57, 0x18, 0xa6, 0xff, 0x92, 0x70, 0x11,
+	0x00, 0x12, 0x90, 0x90, 0x76, 0x5a, 0x54, 0x54,
+	0x4c, 0x46, 0x38, 0x00, 0x10, 0x10, 0x08, 0xfe,
+	0x05, 0x00, 0x38, 0x29, 0x25, 0x23, 0x22, 0x22,
+	0x1f, 0x00, 0x00, 0x00, 0xf6, 0xe1, 0xdd, 0xf8,
+	0xfe, 0x00, 0xfe, 0x15, 0x00, 0x00, 0xd0, 0x02,
+	0x74, 0x02, 0x08, 0xf8, 0xe5, 0xde, 0x02, 0x04,
+	0x04, 0xfd, 0x00, 0x00, 0x00, 0x07, 0x50, 0x2d,
+	0x01, 0x90, 0x90, 0x76, 0x60, 0xb0, 0x07, 0x07,
+	0x0c, 0x0c, 0x04, 0xfe, 0x05, 0x00, 0x66, 0x66,
+	0x5a, 0x56, 0xbc, 0x01, 0x06, 0xfc, 0xfc, 0xf1,
+	0xfe, 0x07, 0x00, 0x24, 0x95, 0x70, 0x64, 0x18,
+	0x06, 0x2c, 0xff, 0xb5, 0xfe, 0xfe, 0xb5, 0xfe,
+	0xfe, 0xe2, 0x8c, 0x24, 0x02, 0x2f, 0xff, 0x2f,
+	0xff, 0xb4, 0x78, 0x02, 0x05, 0x73, 0xff, 0xed,
+	0xfe, 0xfe, 0x4f, 0xff, 0x36, 0x74, 0x1e, 0x09,
+	0x4f, 0xff, 0x50, 0xff, 0xfe, 0x16, 0x00, 0x70,
+	0xac, 0x70, 0x8e, 0xac, 0x40, 0x0e, 0x01, 0x70,
+	0x7f, 0x8e, 0xac, 0x6c, 0x00, 0x0b, 0xfe, 0x02,
+	0x00, 0xfe, 0x0a, 0x2c, 0x2a, 0x2a, 0x28, 0x26,
+	0x1e, 0x1e, 0xfe, 0x02, 0x20, 0x65, 0x20, 0x00,
+	0x00, 0x05, 0x12, 0x00, 0x11, 0x1e, 0x11, 0x11,
+	0x41, 0x1e, 0x41, 0x11, 0x31, 0x1e, 0x31, 0x11,
+	0x70, 0x75, 0x7a, 0x7f, 0x84, 0x89, 0x8e, 0x93,
+	0x98, 0x30, 0x20, 0x00, 0x02, 0x00, 0xfe, 0x06,
+	0x3c, 0xbc, 0x32, 0x0c, 0x00, 0x00, 0x2a, 0x12,
+	0x1e, 0x12, 0x2e, 0x12, 0xcc, 0x12, 0x11, 0x1a,
+	0x1e, 0x1a, 0x2e, 0x1a, 0x4c, 0x10, 0x1e, 0x10,
+	0x11, 0x18, 0x1e, 0x42, 0x1e, 0x42, 0x2e, 0x42,
+	0xcc, 0x42, 0x11, 0x4a, 0x1e, 0x4a, 0x2e, 0x4a,
+	0x4c, 0x40, 0x1e, 0x40, 0x11, 0x48, 0x1e, 0x32,
+	0x1e, 0x32, 0x2e, 0x32, 0xcc, 0x32, 0x11, 0x3a,
+	0x1e, 0x3a, 0x2e, 0x3a, 0x4c, 0x30, 0x1e, 0x30,
+	0x11, 0x38, 0x1e, 0x27, 0x9a, 0x01, 0x9d, 0xa2,
+	0x2f, 0x28, 0x00, 0x00, 0x46, 0xde, 0xc4, 0xbf,
+	0xa6, 0x9d, 0x81, 0x7b, 0x5c, 0x61, 0x40, 0xc7,
+	0xc0, 0xae, 0xa9, 0x8c, 0x83, 0x6a, 0x62, 0x50,
+	0x3e, 0xce, 0xc2, 0xae, 0xa3, 0x8c, 0x7b, 0x6a,
+	0x5a, 0x50, 0x35, 0xd7, 0xc2, 0xb7, 0xa4, 0x95,
+	0x7e, 0x72, 0x5a, 0x59, 0x37, 0xfe, 0x02, 0xf8,
+	0x8c, 0x95, 0x90, 0x8f, 0x00, 0xd7, 0xc0, 0xb7,
+	0xa2, 0x95, 0x7b, 0x72, 0x56, 0x59, 0x32, 0xc7,
+	0xc3, 0xae, 0xad, 0x8c, 0x85, 0x6a, 0x63, 0x50,
+	0x3e, 0xce, 0xc3, 0xae, 0xa4, 0x8c, 0x7c, 0x6a,
+	0x59, 0x50, 0x34, 0xd7, 0xc2, 0xb7, 0xa5, 0x95,
+	0x7e, 0x72, 0x59, 0x59, 0x36, 0xfc, 0x05, 0x00,
+	0x02, 0xce, 0xc5, 0xae, 0xa5, 0x95, 0x83, 0x72,
+	0x5c, 0x59, 0x36, 0xbf, 0xc6, 0xa5, 0xab, 0x8c,
+	0x8c, 0x6a, 0x67, 0x50, 0x41, 0x64, 0x07, 0x00,
+	0x02, 0x95, 0x8c, 0x72, 0x65, 0x59, 0x3f, 0xce,
+	0xc7, 0xae, 0xa8, 0x95, 0x86, 0x72, 0x5f, 0x59,
+	0x39, 0xfe, 0x02, 0xf8, 0x8b, 0x7c, 0x0b, 0x09,
+	0xb7, 0xc2, 0x9d, 0xa4, 0x83, 0x85, 0x6a, 0x6b,
+	0x50, 0x44, 0xb7, 0xc1, 0x64, 0x01, 0x00, 0x06,
+	0x61, 0x5d, 0x48, 0x3d, 0xae, 0xc4, 0x9d, 0xad,
+	0x7b, 0x85, 0x61, 0x66, 0x48, 0x46, 0xae, 0xc3,
+	0x95, 0xa3, 0x72, 0x7c, 0x59, 0x56, 0x38, 0x31,
+	0x7c, 0x0b, 0x00, 0x0c, 0x96, 0x91, 0x8f, 0x00,
+	0xb7, 0xc0, 0xa5, 0xab, 0x8c, 0x8a, 0x6a, 0x64,
+	0x50, 0x3c, 0xb7, 0xc0, 0x9d, 0xa0, 0x83, 0x80,
+	0x6a, 0x64, 0x50, 0x3d, 0xb7, 0xc5, 0x9d, 0xa5,
+	0x83, 0x87, 0x6c, 0x08, 0x07, 0xae, 0xc0, 0x9d,
+	0xa8, 0x83, 0x88, 0x6a, 0x6d, 0x50, 0x46, 0xfc,
+	0x05, 0x00, 0x16, 0xbf, 0xc0, 0xa5, 0xa2, 0x8c,
+	0x7f, 0x6a, 0x57, 0x50, 0x2f, 0xb7, 0xc7, 0xa5,
+	0xb1, 0x8c, 0x8e, 0x72, 0x6d, 0x59, 0x45, 0xbf,
+	0xc6, 0xa5, 0xa8, 0x8c, 0x87, 0x6a, 0x5f, 0x50,
+	0x37, 0xbf, 0xc2, 0xa5, 0xa4, 0x8c, 0x83, 0x6a,
+	0x5c, 0x50, 0x34, 0xbc, 0x05, 0x00, 0x0e, 0x90,
+	0x00, 0xc7, 0xc2, 0xae, 0xaa, 0x95, 0x82, 0x7b,
+	0x60, 0x61, 0x3f, 0xb7, 0xc6, 0xa5, 0xb1, 0x8c,
+	0x8d, 0x72, 0x6b, 0x61, 0x51, 0xbf, 0xc4, 0xa5,
+	0xa5, 0x8c, 0x82, 0x72, 0x61, 0x59, 0x39, 0x6c,
+	0x26, 0x03, 0x95, 0x82, 0x7b, 0x61, 0x61, 0x40,
+	0xfc, 0x05, 0x00, 0x00, 0x7e, 0xd7, 0xc3, 0xb7,
+	0xa8, 0x9d, 0x80, 0x83, 0x5d, 0x6a, 0x3f, 0xbf,
+	0xc7, 0xa5, 0xa8, 0x8c, 0x84, 0x72, 0x60, 0x61,
+	0x46, 0xbf, 0xc2, 0xae, 0xb0, 0x9d, 0x92, 0x83,
+	0x6f, 0x6a, 0x50, 0xd7, 0xc3, 0xb7, 0xa7, 0x9d,
+	0x80, 0x83, 0x5e, 0x6a, 0x40, 0xfe, 0x02, 0xf8,
+	0x8d, 0x96, 0x90, 0x90, 0xfe, 0x05, 0x00, 0x8a,
+	0xc4, 0x63, 0xb8, 0x3c, 0xa6, 0x29, 0x97, 0x16,
+	0x81, 0x84, 0xb7, 0x5b, 0xa9, 0x33, 0x94, 0x1e,
+	0x83, 0x11, 0x70, 0xb8, 0xc2, 0x70, 0xb1, 0x4d,
+	0xa3, 0x2a, 0x8d, 0x1b, 0x7b, 0xa8, 0xbc, 0x68,
+	0xab, 0x47, 0x9d, 0x27, 0x87, 0x18, 0x75, 0xae,
+	0xc6, 0x7d, 0xbb, 0x4d, 0xaa, 0x1c, 0x84, 0x11,
+	0x72, 0xa3, 0xbb, 0x6e, 0xad, 0x3c, 0x97, 0x24,
+	0x85, 0x16, 0x71, 0x80, 0xb2, 0x57, 0xa4, 0x30,
+	0x8e, 0x1c, 0x7c, 0x10, 0x68, 0xbb, 0xbd, 0x75,
+	0xac, 0x4f, 0x9e, 0x2b, 0x87, 0x1a, 0x76, 0x96,
+	0xc5, 0x5e, 0xb5, 0x3e, 0xa5, 0x1f, 0x8c, 0x12,
+	0x7a, 0xc1, 0xc6, 0x42, 0x9f, 0x27, 0x8c, 0x16,
+	0x77, 0x0f, 0x67, 0x9d, 0xbc, 0x68, 0xad, 0x36,
+	0x95, 0x20, 0x83, 0x11, 0x6d, 0x9b, 0xb8, 0x67,
+	0xa8, 0x34, 0x90, 0x1f, 0x7c, 0x10, 0x67, 0x9e,
+	0xc9, 0x6a, 0xbb, 0x37, 0xa4, 0x20, 0x90, 0x11,
+	0x7b, 0xc6, 0xc8, 0x47, 0xa4, 0x2a, 0x90, 0x18,
+	0x7b, 0x10, 0x6c, 0xae, 0xc4, 0x5d, 0xad, 0x37,
+	0x9a, 0x1f, 0x85, 0x13, 0x75, 0x70, 0xad, 0x42,
+	0x99, 0x25, 0x84, 0x17, 0x74, 0x0b, 0x56, 0x87,
+	0xc8, 0x57, 0xb8, 0x2b, 0x9e, 0x19, 0x8a, 0x0d,
+	0x74, 0xa7, 0xc8, 0x6e, 0xb9, 0x36, 0xa0, 0x1f,
+	0x8b, 0x11, 0x75, 0x94, 0xbe, 0x4b, 0xa5, 0x2a,
+	0x92, 0x18, 0x7c, 0x0f, 0x6b, 0xaf, 0xc0, 0x58,
+	0xa8, 0x34, 0x94, 0x1d, 0x7d, 0x12, 0x6d, 0x82,
+	0xc0, 0x52, 0xb0, 0x25, 0x94, 0x14, 0x7f, 0x0c,
+	0x68, 0x84, 0xbf, 0x3e, 0xa4, 0x22, 0x8e, 0x10,
+	0x76, 0x0b, 0x65, 0x88, 0xb6, 0x42, 0x9b, 0x26,
+	0x87, 0x14, 0x70, 0x0c, 0x5f, 0xc5, 0xc2, 0x3e,
+	0x97, 0x23, 0x83, 0x13, 0x6c, 0x0c, 0x5c, 0xb1,
+	0xc9, 0x76, 0xbc, 0x4a, 0xaa, 0x20, 0x8d, 0x12,
+	0x78, 0x93, 0xbf, 0x46, 0xa3, 0x26, 0x8d, 0x14,
+	0x74, 0x0c, 0x62, 0xc8, 0xc4, 0x3b, 0x97, 0x21,
+	0x82, 0x11, 0x6a, 0x0a, 0x59, 0xa3, 0xb9, 0x68,
+	0xa9, 0x30, 0x8d, 0x1a, 0x78, 0x0f, 0x61, 0xa0,
+	0xc9, 0x73, 0xbe, 0x50, 0xb1, 0x30, 0x9f, 0x14,
+	0x80, 0x83, 0xb7, 0x3c, 0x9a, 0x20, 0x84, 0x0e,
+	0x6a, 0x0a, 0x57, 0xac, 0xc2, 0x68, 0xb0, 0x2e,
+	0x92, 0x19, 0x7c, 0x0d, 0x63, 0x93, 0xbe, 0x62,
+	0xb0, 0x3c, 0x9e, 0x1a, 0x80, 0x0e, 0x6b, 0xbb,
+	0x02, 0xa0, 0x02, 0xa0, 0x02, 0x6f, 0x00, 0x75,
+	0x00, 0x75, 0x00, 0x00, 0x00, 0xad, 0x02, 0xb3,
+	0x02, 0x6f, 0x00, 0x87, 0x00, 0x85, 0xfe, 0x03,
+	0x00, 0xc2, 0x02, 0x82, 0x4d, 0x92, 0x6e, 0x4d,
+	0xb1, 0xa8, 0x84, 0x01, 0x00, 0x07, 0x7e, 0x00,
+	0xa8, 0x02, 0xa4, 0x02, 0xa4, 0x02, 0xa2, 0x00,
+	0xa6, 0x00, 0xa6, 0x00, 0x00, 0x00, 0xb4, 0x02,
+	0xb4, 0x02, 0x92, 0x00, 0x96, 0x00, 0x96, 0x46,
+	0x04, 0xb0, 0x02, 0x64, 0x02, 0x0a, 0x8c, 0x00,
+	0x90, 0x02, 0x98, 0x02, 0x98, 0x02, 0x0e, 0x01,
+	0x11, 0x01, 0x11, 0x50, 0xc3, 0x08, 0x88, 0x02,
+	0x88, 0x02, 0x19, 0x01, 0x02, 0x01, 0x02, 0x01,
+	0xf3, 0x2d, 0x00, 0x00
+};
+
+/* Array of known hw_options bits with human-friendly parsing */
+static struct hc_hwopt {
+	const u32 bit;
+	const char *str;
+} const hc_hwopts[] = {
+	{
+		.bit = RB_HW_OPT_NO_UART,
+		.str = "no UART\t\t",
+	}, {
+		.bit = RB_HW_OPT_HAS_VOLTAGE,
+		.str = "has Vreg\t",
+	}, {
+		.bit = RB_HW_OPT_HAS_USB,
+		.str = "has usb\t\t",
+	}, {
+		.bit = RB_HW_OPT_HAS_ATTINY,
+		.str = "has ATtiny\t",
+	}, {
+		.bit = RB_HW_OPT_NO_NAND,
+		.str = "no NAND\t\t",
+	}, {
+		.bit = RB_HW_OPT_HAS_LCD,
+		.str = "has LCD\t\t",
+	}, {
+		.bit = RB_HW_OPT_HAS_POE_OUT,
+		.str = "has POE out\t",
+	}, {
+		.bit = RB_HW_OPT_HAS_uSD,
+		.str = "has MicroSD\t",
+	}, {
+		.bit = RB_HW_OPT_HAS_SIM,
+		.str = "has SIM\t\t",
+	}, {
+		.bit = RB_HW_OPT_HAS_SFP,
+		.str = "has SFP\t\t",
+	}, {
+		.bit = RB_HW_OPT_HAS_WIFI,
+		.str = "has WiFi\t",
+	}, {
+		.bit = RB_HW_OPT_HAS_TS_FOR_ADC,
+		.str = "has TS ADC\t",
+	}, {
+		.bit = RB_HW_OPT_HAS_PLC,
+		.str = "has PLC\t\t",
+	},
+};
+
+static ssize_t hc_tag_show_string(const u8 *pld, u16 pld_len, char *buf)
+{
+	return snprintf(buf, pld_len+1, "%s\n", pld);
+}
+
+static ssize_t hc_tag_show_u32(const u8 *pld, u16 pld_len, char *buf)
+{
+	char *out = buf;
+	u32 data;	// cpu-endian
+
+	/* Caller ensures pld_len > 0 */
+	if (pld_len % sizeof(data))
+		return -EINVAL;
+
+	data = *(u32 *)pld;
+
+	do {
+		out += sprintf(out, "0x%08x\n", data);
+		data++;
+	} while ((pld_len -= sizeof(data)));
+
+	return out - buf;
+}
+
+/*
+ * The MAC is stored network-endian on all devices, in 2 32-bit segments:
+ * <XX:XX:XX:XX> <XX:XX:00:00>. Kernel print has us covered.
+ */
+static ssize_t hc_tag_show_mac(const u8 *pld, u16 pld_len, char *buf)
+{
+	if (8 != pld_len)
+		return -EINVAL;
+
+	return sprintf(buf, "%pM\n", pld);
+}
+
+/*
+ * Print HW options in a human readable way:
+ * The raw number and in decoded form
+ */
+static ssize_t hc_tag_show_hwoptions(const u8 *pld, u16 pld_len, char *buf)
+{
+	char *out = buf;
+	u32 data;	// cpu-endian
+	int i;
+
+	if (sizeof(data) != pld_len)
+		return -EINVAL;
+
+	data = *(u32 *)pld;
+	out += sprintf(out, "raw\t\t: 0x%08x\n\n", data);
+
+	for (i = 0; i < ARRAY_SIZE(hc_hwopts); i++)
+		out += sprintf(out, "%s: %s\n", hc_hwopts[i].str,
+			       (data & hc_hwopts[i].bit) ? "true" : "false");
+
+	return out - buf;
+}
+
+static ssize_t hc_wlan_data_bin_read(struct file *filp, struct kobject *kobj,
+				     struct bin_attribute *attr, char *buf,
+				     loff_t off, size_t count);
+
+static struct hc_wlan_attr {
+	struct bin_attribute battr;
+	u16 pld_ofs;
+	u16 pld_len;
+} hc_wlandata_battr = {
+	.battr = __BIN_ATTR(wlan_data, S_IRUSR, hc_wlan_data_bin_read, NULL, 0),
+};
+
+static ssize_t hc_attr_show(struct kobject *kobj, struct kobj_attribute *attr,
+			    char *buf);
+
+/* Array of known tags to publish in sysfs */
+static struct hc_attr {
+	const u16 tag_id;
+	ssize_t (* const tshow)(const u8 *pld, u16 pld_len, char *buf);
+	struct kobj_attribute kattr;
+	u16 pld_ofs;
+	u16 pld_len;
+} hc_attrs[] = {
+	{
+		.tag_id = RB_ID_FLASH_INFO,
+		.tshow = hc_tag_show_u32,
+		.kattr = __ATTR(flash_info, S_IRUSR, hc_attr_show, NULL),
+	}, {
+		.tag_id = RB_ID_MAC_ADDRESS_PACK,
+		.tshow = hc_tag_show_mac,
+		.kattr = __ATTR(mac_base, S_IRUSR, hc_attr_show, NULL),
+	}, {
+		.tag_id = RB_ID_BOARD_PRODUCT_CODE,
+		.tshow = hc_tag_show_string,
+		.kattr = __ATTR(board_product_code, S_IRUSR, hc_attr_show, NULL),
+	}, {
+		.tag_id = RB_ID_BIOS_VERSION,
+		.tshow = hc_tag_show_string,
+		.kattr = __ATTR(booter_version, S_IRUSR, hc_attr_show, NULL),
+	}, {
+		.tag_id = RB_ID_SERIAL_NUMBER,
+		.tshow = hc_tag_show_string,
+		.kattr = __ATTR(board_serial, S_IRUSR, hc_attr_show, NULL),
+	}, {
+		.tag_id = RB_ID_MEMORY_SIZE,
+		.tshow = hc_tag_show_u32,
+		.kattr = __ATTR(mem_size, S_IRUSR, hc_attr_show, NULL),
+	}, {
+		.tag_id = RB_ID_MAC_ADDRESS_COUNT,
+		.tshow = hc_tag_show_u32,
+		.kattr = __ATTR(mac_count, S_IRUSR, hc_attr_show, NULL),
+	}, {
+		.tag_id = RB_ID_HW_OPTIONS,
+		.tshow = hc_tag_show_hwoptions,
+		.kattr = __ATTR(hw_options, S_IRUSR, hc_attr_show, NULL),
+	}, {
+		.tag_id = RB_ID_WLAN_DATA,
+		.tshow = NULL,
+	}, {
+		.tag_id = RB_ID_BOARD_IDENTIFIER,
+		.tshow = hc_tag_show_string,
+		.kattr = __ATTR(board_identifier, S_IRUSR, hc_attr_show, NULL),
+	}, {
+		.tag_id = RB_ID_PRODUCT_NAME,
+		.tshow = hc_tag_show_string,
+		.kattr = __ATTR(product_name, S_IRUSR, hc_attr_show, NULL),
+	}, {
+		.tag_id = RB_ID_DEFCONF,
+		.tshow = hc_tag_show_string,
+		.kattr = __ATTR(defconf, S_IRUSR, hc_attr_show, NULL),
+	}
+};
+
+/*
+ * If the RB_ID_WLAN_DATA payload starts with RB_MAGIC_ERD, then past
+ * that magic number the payload itself contains a routerboot tag node
+ * locating the LZO-compressed calibration data at id 0x1.
+ */
+static int hc_wlan_data_unpack_erd(const u8 *inbuf, size_t inlen,
+				   void *outbuf, size_t *outlen)
+{
+	u16 lzo_ofs, lzo_len;
+	int ret;
+
+	/* Find embedded tag */
+	ret = routerboot_tag_find(inbuf, inlen, 0x1,	// always id 1
+				  &lzo_ofs, &lzo_len);
+	if (ret) {
+		pr_debug(RB_HC_PR_PFX "ERD data not found\n");
+		goto fail;
+	}
+
+	if (lzo_len > inlen) {
+		pr_debug(RB_HC_PR_PFX "Invalid ERD data length\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	ret = lzo1x_decompress_safe(inbuf+lzo_ofs, lzo_len, outbuf, outlen);
+	if (ret)
+		pr_debug(RB_HC_PR_PFX "LZO decompression error (%d)\n", ret);
+
+fail:
+	return ret;
+}
+
+/*
+ * If the RB_ID_WLAN_DATA payload starts with RB_MAGIC_LZOR, then past
+ * that magic number is a payload that must be appended to the hc_lzor_prefix,
+ * the resulting blob is LZO-compressed. In the LZO decompression result,
+ * the RB_MAGIC_ERD magic number (aligned) must be located. Following that
+ * magic, there is a routerboot tag node (id 0x1) locating the RLE-encoded
+ * calibration data payload.
+ */
+static int hc_wlan_data_unpack_lzor(const u8 *inbuf, size_t inlen,
+				    void *outbuf, size_t *outlen)
+{
+	u16 rle_ofs, rle_len;
+	const u32 *needle;
+	u8 *tempbuf;
+	size_t templen, lzo_len;
+	int ret;
+
+	lzo_len = inlen + sizeof(hc_lzor_prefix);
+	if (lzo_len > *outlen)
+		return -EFBIG;
+
+	/* Temporary buffer same size as the outbuf */
+	templen = *outlen;
+	tempbuf = kmalloc(templen, GFP_KERNEL);
+	if (!tempbuf)
+		return -ENOMEM;
+
+	/* Concatenate into the outbuf */
+	memcpy(outbuf, hc_lzor_prefix, sizeof(hc_lzor_prefix));
+	memcpy(outbuf + sizeof(hc_lzor_prefix), inbuf, inlen);
+
+	/* LZO-decompress lzo_len bytes of outbuf into the tempbuf */
+	ret = lzo1x_decompress_safe(outbuf, lzo_len, tempbuf, &templen);
+	if (ret) {
+		if (LZO_E_INPUT_NOT_CONSUMED == ret) {
+			/*
+			 * It is assumed that because the LZO payload is embedded
+			 * in a "root" RB_ID_WLAN_DATA tag, the tag length is aligned
+			 * and the payload is padded at the end, which triggers a
+			 * spurious error which we ignore here.
+			 */
+			pr_debug(RB_HC_PR_PFX "LZOR: LZO EOF before buffer end - this may be harmless\n");
+		} else {
+			pr_debug(RB_HC_PR_PFX "LZOR: LZO decompression error (%d)\n", ret);
+			goto fail;
+		}
+	}
+
+	/*
+	 * Post decompression we have a blob (possibly byproduct of the lzo
+	 * dictionary). We need to find RB_MAGIC_ERD. The magic number seems to
+	 * be 32bit-aligned in the decompression output.
+	 */
+	needle = (const u32 *)tempbuf;
+	while (RB_MAGIC_ERD != *needle++) {
+		if ((u8 *)needle >= tempbuf+templen) {
+			pr_debug(RB_HC_PR_PFX "LZOR: ERD magic not found\n");
+			goto fail;
+		}
+	};
+	templen -= (u8 *)needle - tempbuf;
+
+	/* Past magic. Look for tag node */
+	ret = routerboot_tag_find((u8 *)needle, templen, 0x1, &rle_ofs, &rle_len);
+	if (ret) {
+		pr_debug(RB_HC_PR_PFX "LZOR: RLE data not found\n");
+		goto fail;
+	}
+
+	if (rle_len > templen) {
+		pr_debug(RB_HC_PR_PFX "LZOR: Invalid RLE data length\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	/* RLE-decode tempbuf from needle back into the outbuf */
+	ret = routerboot_rle_decode((u8 *)needle+rle_ofs, rle_len, outbuf, outlen);
+	if (ret)
+		pr_debug(RB_HC_PR_PFX "LZOR: RLE decoding error (%d)\n", ret);
+
+fail:
+	kfree(tempbuf);
+	return ret;
+}
+
+static int hc_wlan_data_unpack(const size_t tofs, size_t tlen,
+			       void *outbuf, size_t *outlen)
+{
+	const u8 *lbuf;
+	u32 magic;
+	int ret;
+
+	/* Caller ensure tlen > 0. tofs is aligned */
+	if ((tofs + tlen) > hc_buflen)
+		return -EIO;
+
+	lbuf = hc_buf + tofs;
+	magic = *(u32 *)lbuf;
+
+	ret = -ENODATA;
+	switch (magic) {
+	case RB_MAGIC_LZOR:
+		/* Skip magic */
+		lbuf += sizeof(magic);
+		tlen -= sizeof(magic);
+		ret = hc_wlan_data_unpack_lzor(lbuf, tlen, outbuf, outlen);
+		break;
+	case RB_MAGIC_ERD:
+		/* Skip magic */
+		lbuf += sizeof(magic);
+		tlen -= sizeof(magic);
+		ret = hc_wlan_data_unpack_erd(lbuf, tlen, outbuf, outlen);
+		break;
+	default:
+		/*
+		 * If the RB_ID_WLAN_DATA payload doesn't start with a
+		 * magic number, the payload itself is the raw RLE-encoded
+		 * calibration data.
+		 */
+		ret = routerboot_rle_decode(lbuf, tlen, outbuf, outlen);
+		if (ret)
+			pr_debug(RB_HC_PR_PFX "RLE decoding error (%d)\n", ret);
+		break;
+	}
+
+	return ret;
+}
+
+static ssize_t hc_attr_show(struct kobject *kobj, struct kobj_attribute *attr,
+			    char *buf)
+{
+	struct hc_attr *hc_attr;
+	const u8 *pld;
+	u16 pld_len;
+
+	hc_attr = container_of(attr, typeof(*hc_attr), kattr);
+
+	if (!hc_attr->pld_len)
+		return -ENOENT;
+
+	pld = hc_buf + hc_attr->pld_ofs;
+	pld_len = hc_attr->pld_len;
+
+	return hc_attr->tshow(pld, pld_len, buf);
+}
+
+/*
+ * This function will allocate and free memory every time it is called. This
+ * is not the fastest way to do this, but since the data is rarely read (mainly
+ * at boot time to load wlan caldata), this makes it possible to save memory for
+ * the system.
+ */
+static ssize_t hc_wlan_data_bin_read(struct file *filp, struct kobject *kobj,
+				     struct bin_attribute *attr, char *buf,
+				     loff_t off, size_t count)
+{
+	struct hc_wlan_attr *hc_wattr;
+	size_t outlen;
+	void *outbuf;
+	int ret;
+
+	hc_wattr = container_of(attr, typeof(*hc_wattr), battr);
+
+	if (!hc_wattr->pld_len)
+		return -ENOENT;
+
+	outlen = RB_ART_SIZE;
+
+	/* Don't bother unpacking if the source is already too large */
+	if (hc_wattr->pld_len > outlen)
+		return -EFBIG;
+
+	outbuf = kmalloc(outlen, GFP_KERNEL);
+	if (!outbuf)
+		return -ENOMEM;
+
+	ret = hc_wlan_data_unpack(hc_wattr->pld_ofs, hc_wattr->pld_len, outbuf, &outlen);
+	if (ret) {
+		kfree(outbuf);
+		return ret;
+	}
+
+	if (off >= outlen) {
+		kfree(outbuf);
+		return 0;
+	}
+
+	if (off + count > outlen)
+		count = outlen - off;
+
+	memcpy(buf, outbuf + off, count);
+
+	kfree(outbuf);
+	return count;
+}
+
+int __init rb_hardconfig_init(struct kobject *rb_kobj)
+{
+	struct mtd_info *mtd;
+	size_t bytes_read, buflen;
+	const u8 *buf;
+	int i, ret;
+	u32 magic;
+
+	// TODO allow override
+	mtd = get_mtd_device_nm(RB_MTD_HARD_CONFIG);
+	if (IS_ERR(mtd))
+		return -ENODEV;
+
+	hc_buflen = mtd->size;
+	hc_buf = kmalloc(hc_buflen, GFP_KERNEL);
+	if (!hc_buf) {
+		return -ENOMEM;
+		put_mtd_device(mtd);
+	}
+
+	ret = mtd_read(mtd, 0, hc_buflen, &bytes_read, hc_buf);
+	put_mtd_device(mtd);
+
+	if (bytes_read != hc_buflen) {
+		ret = -EIO;
+		goto fail;
+	}
+
+	/* Check we have what we expect */
+	magic = *(const u32 *)hc_buf;
+	if (RB_MAGIC_HARD != magic) {
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	/* Skip magic */
+	buf = hc_buf + sizeof(magic);
+	buflen = hc_buflen - sizeof(magic);
+
+	/* Populate sysfs */
+	ret = -ENOMEM;
+	hc_kobj = kobject_create_and_add(RB_MTD_HARD_CONFIG, rb_kobj);
+	if (!hc_kobj)
+		goto fail;
+
+	/* Locate and publish all known tags */
+	for (i = 0; i < ARRAY_SIZE(hc_attrs); i++) {
+		ret = routerboot_tag_find(buf, buflen, hc_attrs[i].tag_id,
+					  &hc_attrs[i].pld_ofs, &hc_attrs[i].pld_len);
+		if (ret) {
+			hc_attrs[i].pld_ofs = hc_attrs[i].pld_len = 0;
+			continue;
+		}
+
+		/* Account for skipped magic */
+		hc_attrs[i].pld_ofs += sizeof(magic);
+
+		/* Special case RB_ID_WLAN_DATA to prep and create the binary attribute */
+		if ((RB_ID_WLAN_DATA == hc_attrs[i].tag_id) && hc_attrs[i].pld_len) {
+			hc_wlandata_battr.pld_ofs = hc_attrs[i].pld_ofs;
+			hc_wlandata_battr.pld_len = hc_attrs[i].pld_len;
+
+			ret = sysfs_create_bin_file(hc_kobj, &hc_wlandata_battr.battr);
+			if (ret)
+				pr_err(RB_HC_PR_PFX "Could not create %s sysfs entry (%d)\n",
+				       hc_wlandata_battr.battr.attr.name, ret);
+		}
+		/* All other tags are published via standard attributes */
+		else {
+			ret = sysfs_create_file(hc_kobj, &hc_attrs[i].kattr.attr);
+			if (ret)
+				pr_err(RB_HC_PR_PFX "Could not create %s sysfs entry (%d)\n",
+				       hc_attrs[i].kattr.attr.name, ret);
+		}
+	}
+
+	pr_info("MikroTik RouterBOARD hardware configuration sysfs driver v" RB_HARDCONFIG_VER "\n");
+
+	return 0;
+
+fail:
+	kfree(hc_buf);
+	return ret;
+}
+
+void __exit rb_hardconfig_exit(void)
+{
+	kobject_put(hc_kobj);
+	kfree(hc_buf);
+}
--- a/target/linux/generic/files/drivers/platform/mikrotik/routerboot.c	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/files/drivers/platform/mikrotik/routerboot.c	2022-03-22 12:15:54.112429053 +0800
@@ -0,0 +1,183 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Driver for MikroTik RouterBoot flash data. Common routines.
+ *
+ * Copyright (C) 2020 Thibaut VARNE <hacks+kernel@slashdirt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sysfs.h>
+
+#include "routerboot.h"
+
+static struct kobject *rb_kobj;
+
+/**
+ * routerboot_tag_find() - Locate a given tag in routerboot config data.
+ * @bufhead: the buffer to look into. Must start with a tag node.
+ * @buflen: size of bufhead
+ * @tag_id: the tag identifier to look for
+ * @pld_ofs: will be updated with tag payload offset in bufhead, if tag found
+ * @pld_len: will be updated with tag payload size, if tag found
+ *
+ * This incarnation of tag_find() does only that: it finds a specific routerboot
+ * tag node in the input buffer. Routerboot tag nodes are u32 values:
+ * - The low nibble is the tag identification number,
+ * - The high nibble is the tag payload length (node excluded) in bytes.
+ * The payload immediately follows the tag node. Tag nodes are 32bit-aligned.
+ * The returned pld_ofs will always be aligned. pld_len may not end on 32bit
+ * boundary (the only known case is when parsing ERD data).
+ * The nodes are cpu-endian on the flash media. The payload is cpu-endian when
+ * applicable. Tag nodes are not ordered (by ID) on flash.
+ *
+ * Return: 0 on success (tag found) or errno
+ */
+int routerboot_tag_find(const u8 *bufhead, const size_t buflen, const u16 tag_id,
+			u16 *pld_ofs, u16 *pld_len)
+{
+	const u32 *datum, *bufend;
+	u32 node;
+	u16 id, len;
+	int ret;
+
+	if (!bufhead || !tag_id)
+		return -EINVAL;
+
+	ret = -ENOENT;
+	datum = (const u32 *)bufhead;
+	bufend = (const u32 *)(bufhead + buflen);
+
+	while (datum < bufend) {
+		node = *datum++;
+
+		/* Tag list ends with null node */
+		if (!node)
+			break;
+
+		id = node & 0xFFFF;
+		len = node >> 16;
+
+		if (tag_id == id) {
+			if (datum >= bufend)
+				break;
+
+			if (pld_ofs)
+				*pld_ofs = (u16)((u8 *)datum - bufhead);
+			if (pld_len)
+				*pld_len = len;
+
+			ret = 0;
+			break;
+		}
+
+		/*
+		 * The only known situation where len may not end on 32bit
+		 * boundary is within ERD data. Since we're only extracting
+		 * one tag (the first and only one) from that data, we should
+		 * never need to forcefully ALIGN(). Do it anyway, this is not a
+		 * performance path.
+		 */
+		len = ALIGN(len, sizeof(*datum));
+		datum += len / sizeof(*datum);
+	}
+
+	return ret;
+}
+
+/**
+ * routerboot_rle_decode() - Simple RLE (MikroTik variant) decoding routine.
+ * @in: input buffer to decode
+ * @inlen: size of in
+ * @out: output buffer to write decoded data to
+ * @outlen: pointer to out size when function is called, will be updated with
+ * size of decoded output on return
+ *
+ * MikroTik's variant of RLE operates as follows, considering a signed run byte:
+ * - positive run => classic RLE
+ * - negative run => the next -<run> bytes must be copied verbatim
+ * The API is matched to the lzo1x routines for convenience.
+ *
+ * NB: The output buffer cannot overlap with the input buffer.
+ *
+ * Return: 0 on success or errno
+ */
+int routerboot_rle_decode(const u8 *in, size_t inlen, u8 *out, size_t *outlen)
+{
+	int ret, run, nbytes;	// use native types for speed
+	u8 byte;
+
+	if (!in || (inlen < 2) || !out)
+		return -EINVAL;
+
+	ret = -ENOSPC;
+	nbytes = 0;
+	while (inlen >= 2) {
+		run = *in++;
+		inlen--;
+
+		/* Verbatim copies */
+		if (run & 0x80) {
+			/* Invert run byte sign */
+			run = ~run & 0xFF;
+			run++;
+
+			if (run > inlen)
+				goto fail;
+
+			inlen -= run;
+
+			nbytes += run;
+			if (nbytes > *outlen)
+				goto fail;
+
+			/* Basic memcpy */
+			while (run-- > 0)
+				*out++ = *in++;
+		}
+		/* Stream of half-words RLE: <run><byte>. run == 0 is ignored */
+		else {
+			byte = *in++;
+			inlen--;
+
+			nbytes += run;
+			if (nbytes > *outlen)
+				goto fail;
+
+			while (run-- > 0)
+				*out++ = byte;
+		}
+	}
+
+	ret = 0;
+fail:
+	*outlen = nbytes;
+	return ret;
+}
+
+static int __init routerboot_init(void)
+{
+	rb_kobj = kobject_create_and_add("mikrotik", firmware_kobj);
+	if (!rb_kobj)
+		return -ENOMEM;
+
+	return rb_hardconfig_init(rb_kobj);
+}
+
+static void __exit routerboot_exit(void)
+{
+	rb_hardconfig_exit();
+	kobject_put(rb_kobj);	// recursive afaict
+}
+
+module_init(routerboot_init);
+module_exit(routerboot_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("MikroTik RouterBoot sysfs support");
+MODULE_AUTHOR("Thibaut VARENE");
--- a/target/linux/generic/files/drivers/platform/mikrotik/routerboot.h	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/files/drivers/platform/mikrotik/routerboot.h	2022-03-22 12:15:54.112429053 +0800
@@ -0,0 +1,31 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Common definitions for MikroTik RouterBoot data.
+ *
+ * Copyright (C) 2020 Thibaut VARNE <hacks+kernel@slashdirt.org>
+ */
+
+
+#ifndef _ROUTERBOOT_H_
+#define _ROUTERBOOT_H_
+
+#include <linux/types.h>
+
+// these magic values are stored in cpu-endianness on flash
+#define RB_MAGIC_HARD	(('H') | ('a' << 8) | ('r' << 16) | ('d' << 24))
+#define RB_MAGIC_SOFT	(('S') | ('o' << 8) | ('f' << 16) | ('t' << 24))
+#define RB_MAGIC_LZOR	(('L') | ('Z' << 8) | ('O' << 16) | ('R' << 24))
+#define RB_MAGIC_ERD	(('E' << 16) | ('R' << 8) | ('D'))
+
+#define RB_ART_SIZE	0x10000
+
+#define RB_MTD_HARD_CONFIG	"hard_config"
+#define RB_MTD_SOFT_CONFIG	"soft_config"
+
+int routerboot_tag_find(const u8 *bufhead, const size_t buflen, const u16 tag_id, u16 *pld_ofs, u16 *pld_len);
+int routerboot_rle_decode(const u8 *in, size_t inlen, u8 *out, size_t *outlen);
+
+int __init rb_hardconfig_init(struct kobject *rb_kobj);
+void __exit rb_hardconfig_exit(void);
+
+#endif /* _ROUTERBOOT_H_ */
--- a/target/linux/generic/hack-4.14/202-reduce_module_size.patch	2022-03-22 08:54:47.182464628 +0800
+++ b/target/linux/generic/hack-4.14/202-reduce_module_size.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,24 +0,0 @@
-From fd66884da2f96d2a7ea73f58b1b86251b959a913 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 16:56:19 +0200
-Subject: kernel: strip unnecessary symbol table information from kernel modules
-
-reduces default squashfs size on ar71xx by about 4k
-
-lede-commit: 058d331a39077f159ca8922f1f422a1346d6aa67
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- Makefile | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/Makefile
-+++ b/Makefile
-@@ -425,7 +425,7 @@ KBUILD_AFLAGS_KERNEL :=
- KBUILD_CFLAGS_KERNEL :=
- KBUILD_AFLAGS_MODULE  := -DMODULE
- KBUILD_CFLAGS_MODULE  := -DMODULE
--KBUILD_LDFLAGS_MODULE := -T $(srctree)/scripts/module-common.lds
-+KBUILD_LDFLAGS_MODULE = -T $(srctree)/scripts/module-common.lds $(if $(CONFIG_PROFILING),,-s)
- GCC_PLUGINS_CFLAGS :=
- 
- export ARCH SRCARCH SUBARCH CONFIG_SHELL HOSTCC HOSTCFLAGS CROSS_COMPILE AS LD
--- a/target/linux/generic/hack-4.14/204-module_strip.patch	2022-03-22 08:54:47.183464629 +0800
+++ b/target/linux/generic/hack-4.14/204-module_strip.patch	2022-03-22 12:15:54.119429005 +0800
@@ -114,7 +114,7 @@
  config MODULES_TREE_LOOKUP
 --- a/kernel/module.c
 +++ b/kernel/module.c
-@@ -3020,9 +3020,11 @@ static struct module *setup_load_info(st
+@@ -3068,9 +3068,11 @@ static struct module *setup_load_info(st
  
  static int check_modinfo(struct module *mod, struct load_info *info, int flags)
  {
@@ -127,7 +127,7 @@
  	if (flags & MODULE_INIT_IGNORE_VERMAGIC)
  		modmagic = NULL;
  
-@@ -3043,6 +3045,7 @@ static int check_modinfo(struct module *
+@@ -3091,6 +3093,7 @@ static int check_modinfo(struct module *
  				mod->name);
  		add_taint_module(mod, TAINT_OOT_MODULE, LOCKDEP_STILL_OK);
  	}
@@ -137,7 +137,7 @@
  
 --- a/scripts/mod/modpost.c
 +++ b/scripts/mod/modpost.c
-@@ -1984,7 +1984,9 @@ static void read_symbols(char *modname)
+@@ -1996,7 +1996,9 @@ static void read_symbols(char *modname)
  		symname = remove_dot(info.strtab + sym->st_name);
  
  		handle_modversions(mod, &info, sym, symname);
@@ -147,7 +147,7 @@
  	}
  	if (!is_vmlinux(modname) ||
  	     (is_vmlinux(modname) && vmlinux_section_warnings))
-@@ -2145,8 +2147,10 @@ static void add_header(struct buffer *b,
+@@ -2157,8 +2159,10 @@ static void add_header(struct buffer *b,
  	buf_printf(b, "#include <linux/vermagic.h>\n");
  	buf_printf(b, "#include <linux/compiler.h>\n");
  	buf_printf(b, "\n");
@@ -158,7 +158,7 @@
  	buf_printf(b, "\n");
  	buf_printf(b, "__visible struct module __this_module\n");
  	buf_printf(b, "__attribute__((section(\".gnu.linkonce.this_module\"))) = {\n");
-@@ -2163,8 +2167,10 @@ static void add_header(struct buffer *b,
+@@ -2175,8 +2179,10 @@ static void add_header(struct buffer *b,
  
  static void add_intree_flag(struct buffer *b, int is_intree)
  {
@@ -169,7 +169,7 @@
  }
  
  /* Cannot check for assembler */
-@@ -2177,10 +2183,12 @@ static void add_retpoline(struct buffer
+@@ -2189,10 +2195,12 @@ static void add_retpoline(struct buffer
  
  static void add_staging_flag(struct buffer *b, const char *name)
  {
@@ -182,7 +182,7 @@
  }
  
  /**
-@@ -2279,11 +2287,13 @@ static void add_depends(struct buffer *b
+@@ -2291,11 +2299,13 @@ static void add_depends(struct buffer *b
  
  static void add_srcversion(struct buffer *b, struct module *mod)
  {
@@ -196,7 +196,7 @@
  }
  
  static void write_if_changed(struct buffer *b, const char *fname)
-@@ -2520,7 +2530,9 @@ int main(int argc, char **argv)
+@@ -2532,7 +2542,9 @@ int main(int argc, char **argv)
  		add_staging_flag(&buf, mod->name);
  		err |= add_versions(&buf, mod);
  		add_depends(&buf, mod, modules);
--- a/target/linux/generic/hack-4.14/207-disable-modorder.patch	2022-03-22 08:54:47.183464629 +0800
+++ b/target/linux/generic/hack-4.14/207-disable-modorder.patch	2022-03-22 12:15:54.119429005 +0800
@@ -15,7 +15,7 @@
 
 --- a/Makefile
 +++ b/Makefile
-@@ -1252,7 +1252,6 @@ all: modules
+@@ -1260,7 +1260,6 @@ endif
  
  PHONY += modules
  modules: $(vmlinux-dirs) $(if $(KBUILD_BUILTIN),vmlinux) modules.builtin
@@ -23,7 +23,7 @@
  	@$(kecho) '  Building modules, stage 2.';
  	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modpost
  
-@@ -1281,7 +1280,6 @@ _modinst_:
+@@ -1289,7 +1288,6 @@ _modinst_:
  		rm -f $(MODLIB)/build ; \
  		ln -s $(CURDIR) $(MODLIB)/build ; \
  	fi
--- a/target/linux/generic/hack-4.14/211-host_tools_portability.patch	2022-03-22 08:54:47.189464639 +0800
+++ b/target/linux/generic/hack-4.14/211-host_tools_portability.patch	2022-03-22 12:15:54.124428970 +0800
@@ -12,7 +12,7 @@
 
 --- a/tools/build/Build.include
 +++ b/tools/build/Build.include
-@@ -98,4 +98,4 @@ cxx_flags = -Wp,-MD,$(depfile) -Wp,-MT,$
+@@ -99,4 +99,4 @@ cxx_flags = -Wp,-MD,$(depfile) -Wp,-MT,$
  ###
  ## HOSTCC C flags
  
--- a/target/linux/generic/hack-4.14/220-gc_sections.patch	2022-03-22 08:54:47.190464641 +0800
+++ b/target/linux/generic/hack-4.14/220-gc_sections.patch	2022-03-22 12:15:54.126428956 +0800
@@ -33,7 +33,7 @@
  # Read KERNELRELEASE from include/config/kernel.release (if it exists)
  KERNELRELEASE = $(shell cat include/config/kernel.release 2> /dev/null)
  KERNELVERSION = $(VERSION)$(if $(PATCHLEVEL),.$(PATCHLEVEL)$(if $(SUBLEVEL),.$(SUBLEVEL)))$(EXTRAVERSION)
-@@ -789,11 +794,6 @@ ifdef CONFIG_DEBUG_SECTION_MISMATCH
+@@ -785,11 +790,6 @@ ifdef CONFIG_DEBUG_SECTION_MISMATCH
  KBUILD_CFLAGS += $(call cc-option, -fno-inline-functions-called-once)
  endif
  
@@ -190,7 +190,7 @@
  		__stop___dbe_table = .;
  	}
  
-@@ -123,7 +123,7 @@ SECTIONS
+@@ -124,7 +124,7 @@ SECTIONS
  	. = ALIGN(4);
  	.mips.machines.init : AT(ADDR(.mips.machines.init) - LOAD_OFFSET) {
  		__mips_machines_start = .;
@@ -238,7 +238,7 @@
  
  /*
   * Data section helpers
-@@ -496,7 +497,7 @@
+@@ -500,7 +501,7 @@
  #define ENTRY_TEXT							\
  		ALIGN_FUNCTION();					\
  		VMLINUX_SYMBOL(__entry_text_start) = .;			\
@@ -247,7 +247,7 @@
  		VMLINUX_SYMBOL(__entry_text_end) = .;
  
  #define IRQENTRY_TEXT							\
-@@ -603,7 +604,7 @@
+@@ -607,7 +608,7 @@
  	. = ALIGN(sbss_align);						\
  	.sbss : AT(ADDR(.sbss) - LOAD_OFFSET) {				\
  		*(.dynsbss)						\
--- a/target/linux/generic/hack-4.14/221-module_exports.patch	2022-03-22 08:54:47.191464643 +0800
+++ b/target/linux/generic/hack-4.14/221-module_exports.patch	2022-03-22 12:15:54.126428956 +0800
@@ -30,7 +30,7 @@
  #include <linux/export.h>
  
  /* Align . to a 8 byte boundary equals to maximum function alignment. */
-@@ -341,14 +351,14 @@
+@@ -342,14 +352,14 @@
  	/* Kernel symbol table: Normal symbols */			\
  	__ksymtab         : AT(ADDR(__ksymtab) - LOAD_OFFSET) {		\
  		VMLINUX_SYMBOL(__start___ksymtab) = .;			\
@@ -47,7 +47,7 @@
  		VMLINUX_SYMBOL(__stop___ksymtab_gpl) = .;		\
  	}								\
  									\
-@@ -410,7 +420,7 @@
+@@ -411,7 +421,7 @@
  									\
  	/* Kernel symbol table: strings */				\
          __ksymtab_strings : AT(ADDR(__ksymtab_strings) - LOAD_OFFSET) {	\
@@ -56,7 +56,7 @@
  	}								\
  									\
  	/* __*init sections */						\
-@@ -793,6 +803,8 @@
+@@ -804,6 +814,8 @@
  	EXIT_TEXT							\
  	EXIT_DATA							\
  	EXIT_CALL							\
@@ -90,7 +90,7 @@
  	__used								\
 --- a/scripts/Makefile.build
 +++ b/scripts/Makefile.build
-@@ -432,7 +432,7 @@ targets += $(extra-y) $(MAKECMDGOALS) $(
+@@ -435,7 +435,7 @@ targets += $(extra-y) $(MAKECMDGOALS) $(
  # Linker scripts preprocessor (.lds.S -> .lds)
  # ---------------------------------------------------------------------------
  quiet_cmd_cpp_lds_S = LDS     $@
--- a/target/linux/generic/hack-4.14/260-crypto_test_dependencies.patch	2022-03-22 08:54:47.193464646 +0800
+++ b/target/linux/generic/hack-4.14/260-crypto_test_dependencies.patch	2022-03-22 12:15:54.128428943 +0800
@@ -45,7 +45,7 @@
  	  algorithm registration.
 --- a/crypto/algboss.c
 +++ b/crypto/algboss.c
-@@ -248,8 +248,12 @@ static int cryptomgr_schedule_test(struc
+@@ -246,8 +246,12 @@ static int cryptomgr_schedule_test(struc
  	type = alg->cra_flags;
  
  	/* Do not test internal algorithms. */
--- a/target/linux/generic/hack-4.14/301-mips_image_cmdline_hack.patch	2022-03-22 08:54:47.193464646 +0800
+++ b/target/linux/generic/hack-4.14/301-mips_image_cmdline_hack.patch	2022-03-22 12:15:54.129428936 +0800
@@ -10,7 +10,7 @@
 
 --- a/arch/mips/Kconfig
 +++ b/arch/mips/Kconfig
-@@ -1158,6 +1158,10 @@ config SYNC_R4K
+@@ -1160,6 +1160,10 @@ config SYNC_R4K
  config MIPS_MACHINE
  	def_bool n
  
--- a/target/linux/generic/hack-4.14/400-mt29f_spinand-fix-memleak.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/hack-4.14/400-mt29f_spinand-fix-memleak.patch	2022-03-22 12:15:54.130428929 +0800
@@ -0,0 +1,90 @@
+--- a/drivers/staging/mt29f_spinand/mt29f_spinand.c
++++ b/drivers/staging/mt29f_spinand/mt29f_spinand.c
+@@ -492,7 +492,7 @@ static int spinand_program_page(struct s
+ #ifdef CONFIG_MTD_SPINAND_ONDIEECC
+ 	unsigned int i, j;
+ 
+-	wbuf = devm_kzalloc(&spi_nand->dev, CACHE_BUF, GFP_KERNEL);
++	wbuf = kzalloc(CACHE_BUF, GFP_KERNEL);
+ 	if (!wbuf)
+ 		return -ENOMEM;
+ 
+@@ -500,7 +500,7 @@ static int spinand_program_page(struct s
+ 	retval = spinand_read_page(spi_nand, page_id, 0, CACHE_BUF, wbuf);
+ 	if (retval < 0) {
+ 		dev_err(&spi_nand->dev, "ecc error on read page!!!\n");
+-		return retval;
++		goto cleanup;
+ 	}
+ 
+ 	for (i = offset, j = 0; i < len; i++, j++)
+@@ -510,7 +510,7 @@ static int spinand_program_page(struct s
+ 		retval = spinand_enable_ecc(spi_nand);
+ 		if (retval < 0) {
+ 			dev_err(&spi_nand->dev, "enable ecc failed!!\n");
+-			return retval;
++			goto cleanup;
+ 		}
+ 	}
+ #else
+@@ -519,7 +519,7 @@ static int spinand_program_page(struct s
+ 	retval = spinand_write_enable(spi_nand);
+ 	if (retval < 0) {
+ 		dev_err(&spi_nand->dev, "write enable failed!!\n");
+-		return retval;
++		goto cleanup;
+ 	}
+ 	if (wait_till_ready(spi_nand))
+ 		dev_err(&spi_nand->dev, "wait timedout!!!\n");
+@@ -527,23 +527,24 @@ static int spinand_program_page(struct s
+ 	retval = spinand_program_data_to_cache(spi_nand, page_id,
+ 					       offset, len, wbuf);
+ 	if (retval < 0)
+-		return retval;
++		goto cleanup;
+ 	retval = spinand_program_execute(spi_nand, page_id);
+ 	if (retval < 0)
+-		return retval;
++		goto cleanup;
+ 	while (1) {
+ 		retval = spinand_read_status(spi_nand, &status);
+ 		if (retval < 0) {
+ 			dev_err(&spi_nand->dev,
+ 				"error %d reading status register\n", retval);
+-			return retval;
++			goto cleanup;
+ 		}
+ 
+ 		if ((status & STATUS_OIP_MASK) == STATUS_READY) {
+ 			if ((status & STATUS_P_FAIL_MASK) == STATUS_P_FAIL) {
+ 				dev_err(&spi_nand->dev,
+ 					"program error, page %d\n", page_id);
+-				return -1;
++				retval = -1;
++				goto cleanup;
+ 			}
+ 			break;
+ 		}
+@@ -553,13 +554,20 @@ static int spinand_program_page(struct s
+ 		retval = spinand_disable_ecc(spi_nand);
+ 		if (retval < 0) {
+ 			dev_err(&spi_nand->dev, "disable ecc failed!!\n");
+-			return retval;
++			goto cleanup;
+ 		}
+ 		enable_hw_ecc = 0;
+ 	}
++	kfree(wbuf);
+ #endif
+-
+ 	return 0;
++
++cleanup:
++#ifdef CONFIG_MTD_SPINAND_ONDIEECC
++	kfree(wbuf);
++#endif
++	return retval;
++
+ }
+ 
+ /**
--- a/target/linux/generic/hack-4.14/640-bridge-only-accept-EAP-locally.patch	2022-03-22 08:54:47.196464651 +0800
+++ b/target/linux/generic/hack-4.14/640-bridge-only-accept-EAP-locally.patch	2022-03-22 12:15:54.131428922 +0800
@@ -1,4 +1,3 @@
-From c6905cfdeb31a5c049db3da434b10fa0d3e83569 Mon Sep 17 00:00:00 2001
 From: Felix Fietkau <nbd@nbd.name>
 Date: Fri, 7 Jul 2017 17:18:54 +0200
 Subject: bridge: only accept EAP locally
@@ -7,9 +6,9 @@
 them locally, regardless of the state.
 
 Signed-off-by: Felix Fietkau <nbd@nbd.name>
+[add disable_eap_hack sysfs attribute]
+Signed-off-by: Etienne Champetier <champetier.etienne@gmail.com>
 ---
- net/bridge/br_input.c | 7 +++++--
- 1 file changed, 5 insertions(+), 2 deletions(-)
 
 --- a/net/bridge/br_input.c
 +++ b/net/bridge/br_input.c
@@ -19,7 +18,7 @@
  
 +	BR_INPUT_SKB_CB(skb)->brdev = br->dev;
 +
-+	if (skb->protocol == htons(ETH_P_PAE))
++	if (skb->protocol == htons(ETH_P_PAE) && !br->disable_eap_hack)
 +		return br_pass_frame_up(skb);
 +
  	if (p->state == BR_STATE_LEARNING)
@@ -29,3 +28,55 @@
  	BR_INPUT_SKB_CB(skb)->src_port_isolated = !!(p->flags & BR_ISOLATED);
  
  	if (IS_ENABLED(CONFIG_INET) && skb->protocol == htons(ETH_P_ARP))
+--- a/net/bridge/br_private.h
++++ b/net/bridge/br_private.h
+@@ -320,6 +320,8 @@ struct net_bridge {
+ 	u16				group_fwd_mask;
+ 	u16				group_fwd_mask_required;
+ 
++	bool				disable_eap_hack;
++
+ 	/* STP */
+ 	bridge_id			designated_root;
+ 	bridge_id			bridge_id;
+--- a/net/bridge/br_sysfs_br.c
++++ b/net/bridge/br_sysfs_br.c
+@@ -170,6 +170,30 @@ static ssize_t group_fwd_mask_store(stru
+ }
+ static DEVICE_ATTR_RW(group_fwd_mask);
+ 
++static ssize_t disable_eap_hack_show(struct device *d,
++				   struct device_attribute *attr,
++				   char *buf)
++{
++	struct net_bridge *br = to_bridge(d);
++	return sprintf(buf, "%u\n", br->disable_eap_hack);
++}
++
++static int set_disable_eap_hack(struct net_bridge *br, unsigned long val)
++{
++	br->disable_eap_hack = !!val;
++
++	return 0;
++}
++
++static ssize_t disable_eap_hack_store(struct device *d,
++				    struct device_attribute *attr,
++				    const char *buf,
++				    size_t len)
++{
++	return store_bridge_parm(d, buf, len, set_disable_eap_hack);
++}
++static DEVICE_ATTR_RW(disable_eap_hack);
++
+ static ssize_t priority_show(struct device *d, struct device_attribute *attr,
+ 			     char *buf)
+ {
+@@ -817,6 +841,7 @@ static struct attribute *bridge_attrs[]
+ 	&dev_attr_ageing_time.attr,
+ 	&dev_attr_stp_state.attr,
+ 	&dev_attr_group_fwd_mask.attr,
++	&dev_attr_disable_eap_hack.attr,
+ 	&dev_attr_priority.attr,
+ 	&dev_attr_bridge_id.attr,
+ 	&dev_attr_root_id.attr,
--- a/target/linux/generic/hack-4.14/645-netfilter-connmark-introduce-savedscp.patch	2022-03-22 08:54:47.196464651 +0800
+++ b/target/linux/generic/hack-4.14/645-netfilter-connmark-introduce-savedscp.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,100 +0,0 @@
-From 5a4d7714faa28c03e85d696fba82716fbda5c432 Mon Sep 17 00:00:00 2001
-From: Kevin Darbyshire-Bryant <ldir@darbyshire-bryant.me.uk>
-Date: Sat, 23 Mar 2019 09:29:49 +0000
-Subject: [PATCH] netfilter: connmark: introduce savedscp
-
-savedscp is a method of storing the DSCP of an ip packet into conntrack
-mark.  In combination with a suitable tc filter action (conndscp but may
-end up being integrated into connmark) DSCP values are able to be stored
-on egress and restored on ingress across links that otherwise alter or
-bleach DSCP.
-
-This is useful for qdiscs such as CAKE which are able to shape according
-to policies based on DSCP.
-
-Ingress classification is traditionally a challenging task since
-iptables rules haven't yet run and tc filter/eBPF programs are pre-NAT
-lookups, hence are unable to see internal IPv4 addresses as used on the
-typical home masquerading gateway.
-
-The ingress problem is solved by the tc filter, but the tc people didn't
-like the idea of tc setting conntrack mark values, though they are ok
-with reading conntrack values and hence restoring DSCP from conntrack
-marks.
-
-x_tables CONNMARK with the new savedscp action solves the problem of
-storing the DSCP to the conntrack mark.
-
-It accepts 2 parameters.  The mark is a 32bit value with usually one 1
-bit set.  This bit is set when savedscp saves the DSCP to the mark.
-This is useful to implement a 'one shot'
-iptables based classification where the 'complicated' iptables rules are
-only run once to classify the connection on initial (egress) packet and
-subsequent packets are all marked/restored with the same DSCP.  A mark
-of zero disables the setting of a status bit/s.
-
-The mask is a 32bit value of at least 6 contiguous bits and represents
-the area where the DSCP will be stored.
-
-e.g.
-
-iptables -A QOS_MARK_eth0 -t mangle -j CONNMARK --savedscp-mark 0xfc000000/0x01000000
-
-Would store the DSCP in the top 6 bits of the 32bit mark field, and use
-the LSB of the top byte as the 'DSCP has been stored' marker.
-
-Signed-off-by: Kevin Darbyshire-Bryant <ldir@darbyshire-bryant.me.uk>
----
- include/uapi/linux/netfilter/xt_connmark.h |  3 ++-
- net/netfilter/xt_connmark.c                | 21 ++++++++++++++++++++-
- 2 files changed, 22 insertions(+), 2 deletions(-)
-
---- a/include/uapi/linux/netfilter/xt_connmark.h
-+++ b/include/uapi/linux/netfilter/xt_connmark.h
-@@ -16,7 +16,8 @@
- enum {
- 	XT_CONNMARK_SET = 0,
- 	XT_CONNMARK_SAVE,
--	XT_CONNMARK_RESTORE
-+	XT_CONNMARK_RESTORE,
-+	XT_CONNMARK_SAVEDSCP
- };
- 
- struct xt_connmark_tginfo1 {
---- a/net/netfilter/xt_connmark.c
-+++ b/net/netfilter/xt_connmark.c
-@@ -42,6 +42,7 @@ connmark_tg(struct sk_buff *skb, const s
- 	enum ip_conntrack_info ctinfo;
- 	struct nf_conn *ct;
- 	u_int32_t newmark;
-+	u_int8_t dscp, maskshift;
- 
- 	ct = nf_ct_get(skb, &ctinfo);
- 	if (ct == NULL)
-@@ -57,7 +58,25 @@ connmark_tg(struct sk_buff *skb, const s
- 		break;
- 	case XT_CONNMARK_SAVE:
- 		newmark = (ct->mark & ~info->ctmask) ^
--		          (skb->mark & info->nfmask);
-+			  (skb->mark & info->nfmask);
-+		if (ct->mark != newmark) {
-+			ct->mark = newmark;
-+			nf_conntrack_event_cache(IPCT_MARK, ct);
-+		}
-+		break;
-+	case XT_CONNMARK_SAVEDSCP:
-+		if (skb->protocol == htons(ETH_P_IP))
-+			dscp = ipv4_get_dsfield(ip_hdr(skb)) >> 2;
-+		else if (skb->protocol == htons(ETH_P_IPV6))
-+			dscp = ipv6_get_dsfield(ipv6_hdr(skb)) >> 2;
-+		else	/* protocol doesn't have diffserv */
-+			break;
-+
-+		/* nfmask contains the mask shift value */
-+		maskshift = info->nfmask & 0x1f;
-+		newmark = (ct->mark & ~info->ctmark) |
-+			  (info->ctmask | (dscp << maskshift));
-+
- 		if (ct->mark != newmark) {
- 			ct->mark = newmark;
- 			nf_conntrack_event_cache(IPCT_MARK, ct);
--- a/target/linux/generic/hack-4.14/650-netfilter-add-xt_OFFLOAD-target.patch	2022-03-22 08:54:47.197464653 +0800
+++ b/target/linux/generic/hack-4.14/650-netfilter-add-xt_OFFLOAD-target.patch	2022-03-22 12:15:54.132428915 +0800
@@ -98,7 +98,7 @@
  obj-$(CONFIG_NETFILTER_XT_TARGET_LED) += xt_LED.o
 --- /dev/null
 +++ b/net/netfilter/xt_FLOWOFFLOAD.c
-@@ -0,0 +1,421 @@
+@@ -0,0 +1,422 @@
 +/*
 + * Copyright (C) 2018 Felix Fietkau <nbd@nbd.name>
 + *
@@ -330,15 +330,16 @@
 +
 +	this_dst = xt_flowoffload_dst(ct, !dir, par, xt_out(par)->ifindex);
 +	other_dst = xt_flowoffload_dst(ct, dir, par, xt_in(par)->ifindex);
++
++	route->tuple[dir].dst		= this_dst;
++	route->tuple[!dir].dst		= other_dst;
++
 +	if (!this_dst || !other_dst)
 +		return -ENOENT;
 +
 +	if (dst_xfrm(this_dst) || dst_xfrm(other_dst))
 +		return -EINVAL;
 +
-+	route->tuple[dir].dst		= this_dst;
-+	route->tuple[!dir].dst		= other_dst;
-+
 +	return 0;
 +}
 +
@@ -350,7 +351,7 @@
 +	enum ip_conntrack_info ctinfo;
 +	enum ip_conntrack_dir dir;
 +	struct nf_flow_route route;
-+	struct flow_offload *flow;
++	struct flow_offload *flow = NULL;
 +	struct nf_conn *ct;
 +	struct net *net;
 +
@@ -392,12 +393,14 @@
 +
 +	dir = CTINFO2DIR(ctinfo);
 +
-+	if (xt_flowoffload_route(skb, ct, par, &route, dir) < 0)
-+		goto err_flow_route;
++	if (xt_flowoffload_route(skb, ct, par, &route, dir) == 0)
++		flow = flow_offload_alloc(ct, &route);
++
++	dst_release(route.tuple[dir].dst);
++	dst_release(route.tuple[!dir].dst);
 +
-+	flow = flow_offload_alloc(ct, &route);
 +	if (!flow)
-+		goto err_flow_alloc;
++		goto err_flow_route;
 +
 +	if (tcph) {
 +		ct->proto.tcp.seen[0].flags |= IP_CT_TCP_FLAG_BE_LIBERAL;
@@ -421,8 +424,6 @@
 +
 +err_flow_add:
 +	flow_offload_free(flow);
-+err_flow_alloc:
-+	dst_release(route.tuple[!dir].dst);
 +err_flow_route:
 +	clear_bit(IPS_OFFLOAD_BIT, &ct->status);
 +	return XT_CONTINUE;
--- a/target/linux/generic/hack-4.14/661-use_fq_codel_by_default.patch	2022-03-22 08:54:47.198464654 +0800
+++ b/target/linux/generic/hack-4.14/661-use_fq_codel_by_default.patch	2022-03-22 12:15:54.133428908 +0800
@@ -44,7 +44,7 @@
  	  device, it has to decide which ones to send first, which ones to
 --- a/net/sched/sch_api.c
 +++ b/net/sched/sch_api.c
-@@ -2031,7 +2031,7 @@ static int __init pktsched_init(void)
+@@ -2032,7 +2032,7 @@ static int __init pktsched_init(void)
  		return err;
  	}
  
@@ -83,7 +83,7 @@
  EXPORT_SYMBOL(default_qdisc_ops);
  
  /* Main transmission queue. */
-@@ -764,7 +764,7 @@ static void attach_one_default_qdisc(str
+@@ -765,7 +765,7 @@ static void attach_one_default_qdisc(str
  				     void *_unused)
  {
  	struct Qdisc *qdisc;
--- a/target/linux/generic/hack-4.14/662-remove_pfifo_fast.patch	2022-03-22 08:54:47.199464656 +0800
+++ b/target/linux/generic/hack-4.14/662-remove_pfifo_fast.patch	2022-03-22 12:15:54.134428901 +0800
@@ -10,7 +10,7 @@
 
 --- a/net/sched/sch_generic.c
 +++ b/net/sched/sch_generic.c
-@@ -453,146 +453,6 @@ struct Qdisc_ops noqueue_qdisc_ops __rea
+@@ -454,146 +454,6 @@ struct Qdisc_ops noqueue_qdisc_ops __rea
  	.owner		=	THIS_MODULE,
  };
  
--- a/target/linux/generic/hack-4.14/700-swconfig_switch_drivers.patch	2022-03-22 08:54:47.199464656 +0800
+++ b/target/linux/generic/hack-4.14/700-swconfig_switch_drivers.patch	2022-03-22 12:15:54.134428901 +0800
@@ -12,7 +12,7 @@
 
 --- a/drivers/net/phy/Kconfig
 +++ b/drivers/net/phy/Kconfig
-@@ -198,6 +198,89 @@ config LED_TRIGGER_PHY
+@@ -199,6 +199,89 @@ config LED_TRIGGER_PHY
  		<Speed in megabits>Mbps or <Speed in gigabits>Gbps
  
  
--- a/target/linux/generic/hack-4.14/702-phy_add_aneg_done_function.patch	2022-03-22 08:54:47.200464658 +0800
+++ b/target/linux/generic/hack-4.14/702-phy_add_aneg_done_function.patch	2022-03-22 12:15:54.135428894 +0800
@@ -1,6 +1,6 @@
 --- a/include/linux/phy.h
 +++ b/include/linux/phy.h
-@@ -547,6 +547,12 @@ struct phy_driver {
+@@ -549,6 +549,12 @@ struct phy_driver {
  	/* Determines the negotiated speed and duplex */
  	int (*read_status)(struct phy_device *phydev);
  
@@ -15,7 +15,7 @@
  
 --- a/drivers/net/phy/phy_device.c
 +++ b/drivers/net/phy/phy_device.c
-@@ -1461,6 +1461,9 @@ int genphy_update_link(struct phy_device
+@@ -1467,6 +1467,9 @@ int genphy_update_link(struct phy_device
  {
  	int status;
  
--- a/target/linux/generic/hack-4.14/721-phy_packets.patch	2022-03-22 08:54:47.200464658 +0800
+++ b/target/linux/generic/hack-4.14/721-phy_packets.patch	2022-03-22 12:15:54.135428894 +0800
@@ -15,7 +15,7 @@
 
 --- a/include/linux/netdevice.h
 +++ b/include/linux/netdevice.h
-@@ -1412,6 +1412,7 @@ enum netdev_priv_flags {
+@@ -1413,6 +1413,7 @@ enum netdev_priv_flags {
  	IFF_PHONY_HEADROOM		= 1<<26,
  	IFF_MACSEC			= 1<<27,
  	IFF_L3MDEV_RX_HANDLER		= 1<<28,
@@ -23,7 +23,7 @@
  };
  
  #define IFF_802_1Q_VLAN			IFF_802_1Q_VLAN
-@@ -1442,6 +1443,7 @@ enum netdev_priv_flags {
+@@ -1443,6 +1444,7 @@ enum netdev_priv_flags {
  #define IFF_RXFH_CONFIGURED		IFF_RXFH_CONFIGURED
  #define IFF_MACSEC			IFF_MACSEC
  #define IFF_L3MDEV_RX_HANDLER		IFF_L3MDEV_RX_HANDLER
@@ -31,7 +31,7 @@
  
  /**
   *	struct net_device - The DEVICE structure.
-@@ -1728,6 +1730,11 @@ struct net_device {
+@@ -1729,6 +1731,11 @@ struct net_device {
  	const struct xfrmdev_ops *xfrmdev_ops;
  #endif
  
@@ -43,7 +43,7 @@
  	const struct header_ops *header_ops;
  
  	unsigned int		flags;
-@@ -1797,6 +1804,10 @@ struct net_device {
+@@ -1803,6 +1810,10 @@ struct net_device {
  	struct mpls_dev __rcu	*mpls_ptr;
  #endif
  
@@ -56,7 +56,7 @@
   */
 --- a/include/linux/skbuff.h
 +++ b/include/linux/skbuff.h
-@@ -2530,6 +2530,10 @@ static inline int pskb_trim(struct sk_bu
+@@ -2560,6 +2560,10 @@ static inline int pskb_trim(struct sk_bu
  	return (len < skb->len) ? __pskb_trim(skb, len) : 0;
  }
  
@@ -67,7 +67,7 @@
  /**
   *	pskb_trim_unique - remove end from a paged unique (not cloned) buffer
   *	@skb: buffer to alter
-@@ -2661,16 +2665,6 @@ static inline struct sk_buff *dev_alloc_
+@@ -2691,16 +2695,6 @@ static inline struct sk_buff *dev_alloc_
  }
  
  
@@ -101,7 +101,7 @@
  	help
 --- a/net/core/dev.c
 +++ b/net/core/dev.c
-@@ -3004,10 +3004,20 @@ static int xmit_one(struct sk_buff *skb,
+@@ -3000,10 +3000,20 @@ static int xmit_one(struct sk_buff *skb,
  	if (!list_empty(&ptype_all) || !list_empty(&dev->ptype_all))
  		dev_queue_xmit_nit(skb, dev);
  
@@ -136,7 +136,7 @@
  
  #include <net/protocol.h>
  #include <net/dst.h>
-@@ -503,6 +504,22 @@ skb_fail:
+@@ -512,6 +513,22 @@ skb_fail:
  }
  EXPORT_SYMBOL(__napi_alloc_skb);
  
--- a/target/linux/generic/hack-4.14/901-debloat_sock_diag.patch	2022-03-22 08:54:47.201464659 +0800
+++ b/target/linux/generic/hack-4.14/901-debloat_sock_diag.patch	2022-03-22 12:15:54.136428887 +0800
@@ -61,7 +61,7 @@
  struct dst_entry *__sk_dst_check(struct sock *sk, u32 cookie)
  {
  	struct dst_entry *dst = __sk_dst_get(sk);
-@@ -1598,9 +1610,11 @@ void sk_destruct(struct sock *sk)
+@@ -1599,9 +1611,11 @@ void sk_destruct(struct sock *sk)
  
  static void __sk_free(struct sock *sk)
  {
@@ -96,7 +96,7 @@
  	u64 res;
 --- a/net/ipv4/Kconfig
 +++ b/net/ipv4/Kconfig
-@@ -420,6 +420,7 @@ config INET_XFRM_MODE_BEET
+@@ -421,6 +421,7 @@ config INET_XFRM_MODE_BEET
  
  config INET_DIAG
  	tristate "INET: socket monitoring interface"
--- a/target/linux/generic/hack-4.14/902-debloat_proc.patch	2022-03-22 08:54:47.202464661 +0800
+++ b/target/linux/generic/hack-4.14/902-debloat_proc.patch	2022-03-22 12:15:54.137428881 +0800
@@ -189,7 +189,7 @@
  }
 --- a/kernel/irq/proc.c
 +++ b/kernel/irq/proc.c
-@@ -396,6 +396,9 @@ void register_irq_proc(unsigned int irq,
+@@ -418,6 +418,9 @@ void register_irq_proc(unsigned int irq,
  	void __maybe_unused *irqp = (void *)(unsigned long) irq;
  	char name [MAX_NAMELEN];
  
@@ -199,7 +199,7 @@
  	if (!root_irq_dir || (desc->irq_data.chip == &no_irq_chip))
  		return;
  
-@@ -449,6 +452,9 @@ void unregister_irq_proc(unsigned int ir
+@@ -471,6 +474,9 @@ void unregister_irq_proc(unsigned int ir
  {
  	char name [MAX_NAMELEN];
  
@@ -209,7 +209,7 @@
  	if (!root_irq_dir || !desc->dir)
  		return;
  #ifdef CONFIG_SMP
-@@ -487,6 +493,9 @@ void init_irq_proc(void)
+@@ -509,6 +515,9 @@ void init_irq_proc(void)
  	unsigned int irq;
  	struct irq_desc *desc;
  
@@ -232,7 +232,7 @@
  		return -ENOMEM;
 --- a/mm/vmalloc.c
 +++ b/mm/vmalloc.c
-@@ -2783,6 +2783,8 @@ static const struct file_operations proc
+@@ -2798,6 +2798,8 @@ static const struct file_operations proc
  
  static int __init proc_vmalloc_init(void)
  {
@@ -243,7 +243,7 @@
  }
 --- a/mm/vmstat.c
 +++ b/mm/vmstat.c
-@@ -1950,10 +1950,12 @@ void __init init_mm_internals(void)
+@@ -1954,10 +1954,12 @@ void __init init_mm_internals(void)
  	start_shepherd_timer();
  #endif
  #ifdef CONFIG_PROC_FS
@@ -327,7 +327,7 @@
  
 --- a/net/core/sock.c
 +++ b/net/core/sock.c
-@@ -3384,6 +3384,8 @@ static __net_initdata struct pernet_oper
+@@ -3410,6 +3410,8 @@ static __net_initdata struct pernet_oper
  
  static int __init proto_init(void)
  {
@@ -338,7 +338,7 @@
  
 --- a/net/ipv4/fib_trie.c
 +++ b/net/ipv4/fib_trie.c
-@@ -2740,10 +2740,12 @@ static const struct file_operations fib_
+@@ -2743,10 +2743,12 @@ static const struct file_operations fib_
  
  int __net_init fib_proc_init(struct net *net)
  {
@@ -353,7 +353,7 @@
  			 &fib_triestat_fops))
  		goto out2;
  
-@@ -2753,17 +2755,21 @@ int __net_init fib_proc_init(struct net
+@@ -2756,17 +2758,21 @@ int __net_init fib_proc_init(struct net
  	return 0;
  
  out3:
@@ -393,7 +393,7 @@
  
 --- a/net/ipv4/route.c
 +++ b/net/ipv4/route.c
-@@ -427,6 +427,9 @@ static struct pernet_operations ip_rt_pr
+@@ -428,6 +428,9 @@ static struct pernet_operations ip_rt_pr
  
  static int __init ip_rt_proc_init(void)
  {
--- a/target/linux/generic/hack-4.14/911-kobject_add_broadcast_uevent.patch	2022-03-22 08:54:47.203464663 +0800
+++ b/target/linux/generic/hack-4.14/911-kobject_add_broadcast_uevent.patch	2022-03-22 12:15:54.138428874 +0800
@@ -30,7 +30,7 @@
  #endif /* _KOBJECT_H_ */
 --- a/lib/kobject_uevent.c
 +++ b/lib/kobject_uevent.c
-@@ -602,6 +602,43 @@ int add_uevent_var(struct kobj_uevent_en
+@@ -603,6 +603,43 @@ int add_uevent_var(struct kobj_uevent_en
  EXPORT_SYMBOL_GPL(add_uevent_var);
  
  #if defined(CONFIG_NET)
--- a/target/linux/generic/hack-4.14/930-crashlog.patch	2022-03-22 08:54:47.204464664 +0800
+++ b/target/linux/generic/hack-4.14/930-crashlog.patch	2022-03-22 12:15:54.139428867 +0800
@@ -54,7 +54,7 @@
  	depends on BROKEN || !FRV
 --- a/kernel/Makefile
 +++ b/kernel/Makefile
-@@ -110,6 +110,7 @@ obj-$(CONFIG_CONTEXT_TRACKING) += contex
+@@ -109,6 +109,7 @@ obj-$(CONFIG_CONTEXT_TRACKING) += contex
  obj-$(CONFIG_TORTURE_TEST) += torture.o
  
  obj-$(CONFIG_HAS_IOMEM) += memremap.o
@@ -318,7 +318,7 @@
  
  #include <asm/sections.h>
  #include <linux/io.h>
-@@ -483,6 +484,8 @@ static void __init_memblock memblock_ins
+@@ -447,6 +448,8 @@ static void __init_memblock memblock_ins
  	memblock_set_region_node(rgn, nid);
  	type->cnt++;
  	type->total_size += size;
@@ -327,7 +327,7 @@
  }
  
  /**
-@@ -522,6 +525,8 @@ int __init_memblock memblock_add_range(s
+@@ -486,6 +489,8 @@ int __init_memblock memblock_add_range(s
  		type->regions[0].flags = flags;
  		memblock_set_region_node(&type->regions[0], nid);
  		type->total_size = size;
--- a/target/linux/generic/hack-4.14/952-net-conntrack-events-support-multiple-registrant.patch	2022-03-22 08:54:47.205464666 +0800
+++ b/target/linux/generic/hack-4.14/952-net-conntrack-events-support-multiple-registrant.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,325 +0,0 @@
-diff --git a/include/net/netfilter/nf_conntrack_ecache.h b/include/net/netfilter/nf_conntrack_ecache.h
-index 12d967b..c2b98b6 100644
---- a/include/net/netfilter/nf_conntrack_ecache.h
-+++ b/include/net/netfilter/nf_conntrack_ecache.h
-@@ -71,6 +71,10 @@ struct nf_ct_event {
- 	int report;
- };
- 
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+extern int nf_conntrack_register_notifier(struct net *net, struct notifier_block *nb);
-+extern int nf_conntrack_unregister_notifier(struct net *net, struct notifier_block *nb);
-+#else
- struct nf_ct_event_notifier {
- 	int (*fcn)(unsigned int events, struct nf_ct_event *item);
- };
-@@ -79,7 +83,7 @@ int nf_conntrack_register_notifier(struc
- 				   struct nf_ct_event_notifier *nb);
- void nf_conntrack_unregister_notifier(struct net *net,
- 				      struct nf_ct_event_notifier *nb);
--
-+#endif
- void nf_ct_deliver_cached_events(struct nf_conn *ct);
- int nf_conntrack_eventmask_report(unsigned int eventmask, struct nf_conn *ct,
- 				  u32 portid, int report);
-@@ -87,12 +91,15 @@ int nf_conntrack_eventmask_report(unsign
- static inline void
- nf_conntrack_event_cache(enum ip_conntrack_events event, struct nf_conn *ct)
- {
--	struct net *net = nf_ct_net(ct);
- 	struct nf_conntrack_ecache *e;
-+#ifndef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+	struct net *net = nf_ct_net(ct);
- 
- 	if (!rcu_access_pointer(net->ct.nf_conntrack_event_cb))
- 		return;
- 
-+#endif
-+
- 	e = nf_ct_ecache_find(ct);
- 	if (e == NULL)
- 		return;
-@@ -104,10 +111,12 @@ static inline int
- nf_conntrack_event_report(enum ip_conntrack_events event, struct nf_conn *ct,
- 			  u32 portid, int report)
- {
-+#ifndef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
- 	const struct net *net = nf_ct_net(ct);
- 
- 	if (!rcu_access_pointer(net->ct.nf_conntrack_event_cb))
- 		return 0;
-+#endif
- 
- 	return nf_conntrack_eventmask_report(1 << event, ct, portid, report);
- }
-@@ -115,11 +124,14 @@ nf_conntrack_event_report(enum ip_conntr
- static inline int
- nf_conntrack_event(enum ip_conntrack_events event, struct nf_conn *ct)
- {
-+#ifndef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
- 	const struct net *net = nf_ct_net(ct);
- 
- 	if (!rcu_access_pointer(net->ct.nf_conntrack_event_cb))
- 		return 0;
- 
-+#endif
-+
- 	return nf_conntrack_eventmask_report(1 << event, ct, 0, 0);
- }
- 
-diff --git a/include/net/netns/conntrack.h b/include/net/netns/conntrack.h
-index e469e85..1d31db8 100644
---- a/include/net/netns/conntrack.h
-+++ b/include/net/netns/conntrack.h
-@@ -114,7 +114,11 @@ struct netns_ct {
- 
- 	struct ct_pcpu __percpu *pcpu_lists;
- 	struct ip_conntrack_stat __percpu *stat;
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+	struct atomic_notifier_head nf_conntrack_chain;
-+#else
- 	struct nf_ct_event_notifier __rcu *nf_conntrack_event_cb;
-+#endif
- 	struct nf_exp_event_notifier __rcu *nf_expect_event_cb;
- 	struct nf_ip_net	nf_ct_proto;
- #if defined(CONFIG_NF_CONNTRACK_LABELS)
-diff --git a/net/netfilter/Kconfig b/net/netfilter/Kconfig
-index 63073be..08d7aab 100644
---- a/net/netfilter/Kconfig
-+++ b/net/netfilter/Kconfig
-@@ -118,6 +118,14 @@ config NF_CONNTRACK_EVENTS
- 
- 	  If unsure, say `N'.
- 
-+config NF_CONNTRACK_CHAIN_EVENTS
-+	bool "Register multiple callbacks to ct events"
-+	depends on NF_CONNTRACK_EVENTS
-+	help
-+	  Support multiple registrations.
-+
-+	  If unsure, say `N'.
-+
- config NF_CONNTRACK_TIMEOUT
- 	bool  'Connection tracking timeout'
- 	depends on NETFILTER_ADVANCED
-diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c
-index 6bd1508..9b81c7c 100644
---- a/net/netfilter/nf_conntrack_core.c
-+++ b/net/netfilter/nf_conntrack_core.c
-@@ -2167,6 +2167,10 @@ int nf_conntrack_init_net(struct net *ne
- 	ret = nf_conntrack_proto_pernet_init(net);
- 	if (ret < 0)
- 		goto err_proto;
-+
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+	ATOMIC_INIT_NOTIFIER_HEAD(&net->ct.nf_conntrack_chain);
-+#endif
- 	return 0;
- 
- err_proto:
-diff --git a/net/netfilter/nf_conntrack_ecache.c b/net/netfilter/nf_conntrack_ecache.c
-index da9df2d..e0e2a8f 100644
---- a/net/netfilter/nf_conntrack_ecache.c
-+++ b/net/netfilter/nf_conntrack_ecache.c
-@@ -18,6 +18,9 @@
- #include <linux/stddef.h>
- #include <linux/err.h>
- #include <linux/percpu.h>
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+#include <linux/notifier.h>
-+#endif
- #include <linux/kernel.h>
- #include <linux/netdevice.h>
- #include <linux/slab.h>
-@@ -117,6 +120,38 @@ static void ecache_work(struct work_stru
- 		schedule_delayed_work(&ctnet->ecache_dwork, delay);
- }
- 
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+int
-+nf_conntrack_eventmask_report(unsigned int eventmask,
-+			      struct nf_conn *ct,
-+			      u32 portid,
-+			      int report)
-+{
-+	struct nf_conntrack_ecache *e;
-+	struct net *net = nf_ct_net(ct);
-+
-+	e = nf_ct_ecache_find(ct);
-+	if (e == NULL)
-+		return 0;
-+
-+	if (nf_ct_is_confirmed(ct)) {
-+		struct nf_ct_event item = {
-+			.ct = ct,
-+			.portid	= e->portid ? e->portid : portid,
-+			.report = report
-+		};
-+		/* This is a resent of a destroy event? If so, skip missed */
-+		unsigned long missed = e->portid ? 0 : e->missed;
-+
-+		if (!((eventmask | missed) & e->ctmask))
-+			return 0;
-+
-+		atomic_notifier_call_chain(&net->ct.nf_conntrack_chain, eventmask | missed, &item);
-+	}
-+
-+	return 0;
-+}
-+#else
- int nf_conntrack_eventmask_report(unsigned int eventmask, struct nf_conn *ct,
- 				  u32 portid, int report)
- {
-@@ -171,10 +206,52 @@ out_unlock:
- 	rcu_read_unlock();
- 	return ret;
- }
-+#endif
- EXPORT_SYMBOL_GPL(nf_conntrack_eventmask_report);
- 
- /* deliver cached events and clear cache entry - must be called with locally
-  * disabled softirqs */
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+void nf_ct_deliver_cached_events(struct nf_conn *ct)
-+{
-+	unsigned long events, missed;
-+	struct nf_conntrack_ecache *e;
-+	struct nf_ct_event item;
-+	struct net *net = nf_ct_net(ct);
-+
-+	e = nf_ct_ecache_find(ct);
-+	if (e == NULL)
-+		return;
-+
-+	events = xchg(&e->cache, 0);
-+
-+	if (!nf_ct_is_confirmed(ct) || nf_ct_is_dying(ct) || !events)
-+		return;
-+
-+	/* We make a copy of the missed event cache without taking
-+	 * the lock, thus we may send missed events twice. However,
-+	 * this does not harm and it happens very rarely. */
-+	missed = e->missed;
-+
-+	if (!((events | missed) & e->ctmask))
-+		return;
-+
-+	item.ct = ct;
-+	item.portid = 0;
-+	item.report = 0;
-+
-+	atomic_notifier_call_chain(&net->ct.nf_conntrack_chain,
-+			events | missed,
-+			&item);
-+
-+	if (likely(!missed))
-+		return;
-+
-+	spin_lock_bh(&ct->lock);
-+		e->missed &= ~missed;
-+	spin_unlock_bh(&ct->lock);
-+}
-+#else
- void nf_ct_deliver_cached_events(struct nf_conn *ct)
- {
- 	struct net *net = nf_ct_net(ct);
-@@ -225,6 +302,7 @@ void nf_ct_deliver_cached_events(struct
- out_unlock:
- 	rcu_read_unlock();
- }
-+#endif
- EXPORT_SYMBOL_GPL(nf_ct_deliver_cached_events);
- 
- void nf_ct_expect_event_report(enum ip_conntrack_expect_events event,
-@@ -257,6 +335,12 @@ out_unlock:
- 	rcu_read_unlock();
- }
- 
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+int nf_conntrack_register_notifier(struct net *net, struct notifier_block *nb)
-+{
-+        return atomic_notifier_chain_register(&net->ct.nf_conntrack_chain, nb);
-+}
-+#else
- int nf_conntrack_register_notifier(struct net *net,
- 				   struct nf_ct_event_notifier *new)
- {
-@@ -277,8 +361,15 @@ out_unlock:
- 	mutex_unlock(&nf_ct_ecache_mutex);
- 	return ret;
- }
-+#endif
- EXPORT_SYMBOL_GPL(nf_conntrack_register_notifier);
- 
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+int nf_conntrack_unregister_notifier(struct net *net, struct notifier_block *nb)
-+{
-+	return atomic_notifier_chain_unregister(&net->ct.nf_conntrack_chain, nb);
-+}
-+#else
- void nf_conntrack_unregister_notifier(struct net *net,
- 				      struct nf_ct_event_notifier *new)
- {
-@@ -292,6 +383,7 @@ void nf_conntrack_unregister_notifier(st
- 	mutex_unlock(&nf_ct_ecache_mutex);
- 	/* synchronize_rcu() is called from ctnetlink_exit. */
- }
-+#endif
- EXPORT_SYMBOL_GPL(nf_conntrack_unregister_notifier);
- 
- int nf_ct_expect_register_notifier(struct net *net,
-diff --git a/net/netfilter/nf_conntrack_netlink.c b/net/netfilter/nf_conntrack_netlink.c
-index 04111c1..8c741f7 100644
---- a/net/netfilter/nf_conntrack_netlink.c
-+++ b/net/netfilter/nf_conntrack_netlink.c
-@@ -28,6 +28,11 @@
- #include <linux/netlink.h>
- #include <linux/spinlock.h>
- #include <linux/interrupt.h>
-+
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+#include <linux/notifier.h>
-+#endif
-+
- #include <linux/slab.h>
- 
- #include <linux/netfilter.h>
-@@ -618,14 +623,22 @@ static size_t ctnetlink_nlmsg_size(const
- 	       ;
- }
- 
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+static int ctnetlink_conntrack_event(struct notifier_block *this,
-+                           unsigned long events, void *ptr)
-+#else
- static int
- ctnetlink_conntrack_event(unsigned int events, struct nf_ct_event *item)
-+#endif
- {
- 	const struct nf_conntrack_zone *zone;
- 	struct net *net;
- 	struct nlmsghdr *nlh;
- 	struct nfgenmsg *nfmsg;
- 	struct nlattr *nest_parms;
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+	struct nf_ct_event *item = (struct nf_ct_event *)ptr;
-+#endif
- 	struct nf_conn *ct = item->ct;
- 	struct sk_buff *skb;
- 	unsigned int type;
-@@ -3290,9 +3303,15 @@ static int ctnetlink_stat_exp_cpu(struct
- }
- 
- #ifdef CONFIG_NF_CONNTRACK_EVENTS
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+static struct notifier_block ctnl_notifier = {
-+	.notifier_call = ctnetlink_conntrack_event,
-+};
-+#else
- static struct nf_ct_event_notifier ctnl_notifier = {
- 	.fcn = ctnetlink_conntrack_event,
- };
-+#endif
- 
- static struct nf_exp_event_notifier ctnl_notifier_exp = {
- 	.fcn = ctnetlink_expect_event,
--- a/target/linux/generic/hack-4.14/953-use-nf_ct_helper_log.patch	2022-03-22 08:54:47.205464666 +0800
+++ b/target/linux/generic/hack-4.14/953-use-nf_ct_helper_log.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,33 +0,0 @@
-diff --git a/net/ipv4/netfilter/nf_nat_snmp_basic.c b/net/ipv4/netfilter/nf_nat_snmp_basic.c
-index c8ac57f..7f7d847 100644
---- a/net/ipv4/netfilter/nf_nat_snmp_basic.c
-+++ b/net/ipv4/netfilter/nf_nat_snmp_basic.c
-@@ -1196,7 +1196,7 @@ static int snmp_translate(struct nf_conn
- 
- 	if (!snmp_parse_mangle((unsigned char *)udph + sizeof(struct udphdr),
- 			       paylen, &map, &udph->check)) {
--		net_warn_ratelimited("bsalg: parser failed\n");
-+		nf_ct_helper_log(skb, ct, "parser failed\n");
- 		return NF_DROP;
- 	}
- 	return NF_ACCEPT;
-@@ -1230,13 +1230,14 @@ static int help(struct sk_buff *skb, uns
- 	 * can mess around with the payload.
- 	 */
- 	if (ntohs(udph->len) != skb->len - (iph->ihl << 2)) {
--		net_warn_ratelimited("SNMP: dropping malformed packet src=%pI4 dst=%pI4\n",
--				     &iph->saddr, &iph->daddr);
--		 return NF_DROP;
-+		nf_ct_helper_log(skb, ct, "dropping malformed packet\n");
-+		return NF_DROP;;
- 	}
- 
--	if (!skb_make_writable(skb, skb->len))
--		return NF_DROP;
-+	if (!skb_make_writable(skb, skb->len)) {
-+		nf_ct_helper_log(skb, ct, "cannot mangle packet");
-+ 		return NF_DROP;
-+	}
- 
- 	spin_lock_bh(&snmp_lock);
- 	ret = snmp_translate(ct, ctinfo, skb);
--- a/target/linux/generic/hack-4.19/204-module_strip.patch	2022-03-22 08:54:47.206464668 +0800
+++ b/target/linux/generic/hack-4.19/204-module_strip.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,206 +0,0 @@
-From a779a482fb9b9f8fcdf8b2519c789b4b9bb5dd05 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 16:56:48 +0200
-Subject: build: add a hack for removing non-essential module info
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/linux/module.h      | 13 ++++++++-----
- include/linux/moduleparam.h | 15 ++++++++++++---
- init/Kconfig                |  7 +++++++
- kernel/module.c             |  5 ++++-
- scripts/mod/modpost.c       | 12 ++++++++++++
- 5 files changed, 43 insertions(+), 9 deletions(-)
-
---- a/include/linux/module.h
-+++ b/include/linux/module.h
-@@ -160,6 +160,7 @@ extern void cleanup_module(void);
- 
- /* Generic info of form tag = "info" */
- #define MODULE_INFO(tag, info) __MODULE_INFO(tag, tag, info)
-+#define MODULE_INFO_STRIP(tag, info) __MODULE_INFO_STRIP(tag, tag, info)
- 
- /* For userspace: you can also call me... */
- #define MODULE_ALIAS(_alias) MODULE_INFO(alias, _alias)
-@@ -203,12 +204,12 @@ extern void cleanup_module(void);
-  * Author(s), use "Name <email>" or just "Name", for multiple
-  * authors use multiple MODULE_AUTHOR() statements/lines.
-  */
--#define MODULE_AUTHOR(_author) MODULE_INFO(author, _author)
-+#define MODULE_AUTHOR(_author) MODULE_INFO_STRIP(author, _author)
- 
- /* What your module does. */
--#define MODULE_DESCRIPTION(_description) MODULE_INFO(description, _description)
-+#define MODULE_DESCRIPTION(_description) MODULE_INFO_STRIP(description, _description)
- 
--#ifdef MODULE
-+#if defined(MODULE) && !defined(CONFIG_MODULE_STRIPPED)
- /* Creates an alias so file2alias.c can find device table. */
- #define MODULE_DEVICE_TABLE(type, name)					\
- extern typeof(name) __mod_##type##__##name##_device_table		\
-@@ -235,7 +236,9 @@ extern typeof(name) __mod_##type##__##na
-  */
- 
- #if defined(MODULE) || !defined(CONFIG_SYSFS)
--#define MODULE_VERSION(_version) MODULE_INFO(version, _version)
-+#define MODULE_VERSION(_version) MODULE_INFO_STRIP(version, _version)
-+#elif defined(CONFIG_MODULE_STRIPPED)
-+#define MODULE_VERSION(_version) __MODULE_INFO_DISABLED(version)
- #else
- #define MODULE_VERSION(_version)					\
- 	static struct module_version_attribute ___modver_attr = {	\
-@@ -257,7 +260,7 @@ extern typeof(name) __mod_##type##__##na
- /* Optional firmware file (or files) needed by the module
-  * format is simply firmware file name.  Multiple firmware
-  * files require multiple MODULE_FIRMWARE() specifiers */
--#define MODULE_FIRMWARE(_firmware) MODULE_INFO(firmware, _firmware)
-+#define MODULE_FIRMWARE(_firmware) MODULE_INFO_STRIP(firmware, _firmware)
- 
- struct notifier_block;
- 
---- a/include/linux/moduleparam.h
-+++ b/include/linux/moduleparam.h
-@@ -17,6 +17,16 @@
- /* Chosen so that structs with an unsigned long line up. */
- #define MAX_PARAM_PREFIX_LEN (64 - sizeof(unsigned long))
- 
-+/* This struct is here for syntactic coherency, it is not used */
-+#define __MODULE_INFO_DISABLED(name)					  \
-+  struct __UNIQUE_ID(name) {}
-+
-+#ifdef CONFIG_MODULE_STRIPPED
-+#define __MODULE_INFO_STRIP(tag, name, info) __MODULE_INFO_DISABLED(name)
-+#else
-+#define __MODULE_INFO_STRIP(tag, name, info) __MODULE_INFO(tag, name, info)
-+#endif
-+
- #ifdef MODULE
- #define __MODULE_INFO(tag, name, info)					  \
- static const char __UNIQUE_ID(name)[]					  \
-@@ -24,8 +34,7 @@ static const char __UNIQUE_ID(name)[]
-   = __stringify(tag) "=" info
- #else  /* !MODULE */
- /* This struct is here for syntactic coherency, it is not used */
--#define __MODULE_INFO(tag, name, info)					  \
--  struct __UNIQUE_ID(name) {}
-+#define __MODULE_INFO(tag, name, info) __MODULE_INFO_DISABLED(name)
- #endif
- #define __MODULE_PARM_TYPE(name, _type)					  \
-   __MODULE_INFO(parmtype, name##type, #name ":" _type)
-@@ -33,7 +42,7 @@ static const char __UNIQUE_ID(name)[]
- /* One for each parameter, describing how to use it.  Some files do
-    multiple of these per line, so can't just use MODULE_INFO. */
- #define MODULE_PARM_DESC(_parm, desc) \
--	__MODULE_INFO(parm, _parm, #_parm ":" desc)
-+	__MODULE_INFO_STRIP(parm, _parm, #_parm ":" desc)
- 
- struct kernel_param;
- 
---- a/init/Kconfig
-+++ b/init/Kconfig
-@@ -1997,6 +1997,13 @@ config TRIM_UNUSED_KSYMS
- 
- 	  If unsure, or if you need to build out-of-tree modules, say N.
- 
-+config MODULE_STRIPPED
-+	bool "Reduce module size"
-+	depends on MODULES
-+	help
-+	  Remove module parameter descriptions, author info, version, aliases,
-+	  device tables, etc.
-+
- endif # MODULES
- 
- config MODULES_TREE_LOOKUP
---- a/kernel/module.c
-+++ b/kernel/module.c
-@@ -3025,9 +3025,11 @@ static int setup_load_info(struct load_i
- 
- static int check_modinfo(struct module *mod, struct load_info *info, int flags)
- {
--	const char *modmagic = get_modinfo(info, "vermagic");
- 	int err;
- 
-+#ifndef CONFIG_MODULE_STRIPPED
-+	const char *modmagic = get_modinfo(info, "vermagic");
-+
- 	if (flags & MODULE_INIT_IGNORE_VERMAGIC)
- 		modmagic = NULL;
- 
-@@ -3048,6 +3050,7 @@ static int check_modinfo(struct module *
- 				mod->name);
- 		add_taint_module(mod, TAINT_OOT_MODULE, LOCKDEP_STILL_OK);
- 	}
-+#endif
- 
- 	check_modinfo_retpoline(mod, info);
- 
---- a/scripts/mod/modpost.c
-+++ b/scripts/mod/modpost.c
-@@ -1971,7 +1971,9 @@ static void read_symbols(const char *mod
- 		symname = remove_dot(info.strtab + sym->st_name);
- 
- 		handle_modversions(mod, &info, sym, symname);
-+#ifndef CONFIG_MODULE_STRIPPED
- 		handle_moddevtable(mod, &info, sym, symname);
-+#endif
- 	}
- 	if (!is_vmlinux(modname) || vmlinux_section_warnings)
- 		check_sec_ref(mod, modname, &info);
-@@ -2134,8 +2136,10 @@ static void add_header(struct buffer *b,
- 	buf_printf(b, "\n");
- 	buf_printf(b, "BUILD_SALT;\n");
- 	buf_printf(b, "\n");
-+#ifndef CONFIG_MODULE_STRIPPED
- 	buf_printf(b, "MODULE_INFO(vermagic, VERMAGIC_STRING);\n");
- 	buf_printf(b, "MODULE_INFO(name, KBUILD_MODNAME);\n");
-+#endif
- 	buf_printf(b, "\n");
- 	buf_printf(b, "__visible struct module __this_module\n");
- 	buf_printf(b, "__attribute__((section(\".gnu.linkonce.this_module\"))) = {\n");
-@@ -2152,8 +2156,10 @@ static void add_header(struct buffer *b,
- 
- static void add_intree_flag(struct buffer *b, int is_intree)
- {
-+#ifndef CONFIG_MODULE_STRIPPED
- 	if (is_intree)
- 		buf_printf(b, "\nMODULE_INFO(intree, \"Y\");\n");
-+#endif
- }
- 
- /* Cannot check for assembler */
-@@ -2166,8 +2172,10 @@ static void add_retpoline(struct buffer
- 
- static void add_staging_flag(struct buffer *b, const char *name)
- {
-+#ifndef CONFIG_MODULE_STRIPPED
- 	if (strstarts(name, "drivers/staging"))
- 		buf_printf(b, "\nMODULE_INFO(staging, \"Y\");\n");
-+#endif
- }
- 
- /**
-@@ -2266,11 +2274,13 @@ static void add_depends(struct buffer *b
- 
- static void add_srcversion(struct buffer *b, struct module *mod)
- {
-+#ifndef CONFIG_MODULE_STRIPPED
- 	if (mod->srcversion[0]) {
- 		buf_printf(b, "\n");
- 		buf_printf(b, "MODULE_INFO(srcversion, \"%s\");\n",
- 			   mod->srcversion);
- 	}
-+#endif
- }
- 
- static void write_if_changed(struct buffer *b, const char *fname)
-@@ -2507,7 +2517,9 @@ int main(int argc, char **argv)
- 		add_staging_flag(&buf, mod->name);
- 		err |= add_versions(&buf, mod);
- 		add_depends(&buf, mod, modules);
-+#ifndef CONFIG_MODULE_STRIPPED
- 		add_moddevtable(&buf, mod);
-+#endif
- 		add_srcversion(&buf, mod);
- 
- 		sprintf(fname, "%s.mod.c", mod->name);
--- a/target/linux/generic/hack-4.19/207-disable-modorder.patch	2022-03-22 08:54:47.206464668 +0800
+++ b/target/linux/generic/hack-4.19/207-disable-modorder.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,44 +0,0 @@
-From c9ef4ab0f54356ee9f91d9676ea0ec123840ddc7 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 16:57:33 +0200
-Subject: kernel: do not build modules.order
-
-It is not needed for anything on the system and skipping this saves some
-build time, especially in cases where there is nothing to do.
-
-lede-commit: afc1675833a7bf5df094f59f7250369520646d04
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- Makefile               | 2 --
- scripts/Makefile.build | 2 +-
- 2 files changed, 1 insertion(+), 3 deletions(-)
-
---- a/Makefile
-+++ b/Makefile
-@@ -1232,7 +1232,6 @@ all: modules
- 
- PHONY += modules
- modules: $(vmlinux-dirs) $(if $(KBUILD_BUILTIN),vmlinux) modules.builtin
--	$(Q)$(AWK) '!x[$$0]++' $(vmlinux-dirs:%=$(objtree)/%/modules.order) > $(objtree)/modules.order
- 	@$(kecho) '  Building modules, stage 2.';
- 	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modpost
- 
-@@ -1261,7 +1260,6 @@ _modinst_:
- 		rm -f $(MODLIB)/build ; \
- 		ln -s $(CURDIR) $(MODLIB)/build ; \
- 	fi
--	@cp -f $(objtree)/modules.order $(MODLIB)/
- 	@cp -f $(objtree)/modules.builtin $(MODLIB)/
- 	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modinst
- 
---- a/scripts/Makefile.build
-+++ b/scripts/Makefile.build
-@@ -78,7 +78,7 @@ modorder-target := $(obj)/modules.order
- # We keep a list of all modules in $(MODVERDIR)
- 
- __build: $(if $(KBUILD_BUILTIN),$(builtin-target) $(lib-target) $(extra-y)) \
--	 $(if $(KBUILD_MODULES),$(obj-m) $(modorder-target)) \
-+	 $(if $(KBUILD_MODULES),$(obj-m)) \
- 	 $(subdir-ym) $(always)
- 	@:
- 
--- a/target/linux/generic/hack-4.19/210-darwin_scripts_include.patch	2022-03-22 08:54:47.209464673 +0800
+++ b/target/linux/generic/hack-4.19/210-darwin_scripts_include.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,3053 +0,0 @@
-From db7c30dcd9a0391bf13b62c9f91e144d762ef43a Mon Sep 17 00:00:00 2001
-From: Florian Fainelli <f.fainelli@gmail.com>
-Date: Fri, 7 Jul 2017 17:00:49 +0200
-Subject: Add an OSX specific patch to make the kernel be compiled
-
-lede-commit: 3fc2a24f0422b2f55f9ed43f116db3111f700526
-Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
----
- scripts/kconfig/Makefile   |    3 +
- scripts/mod/elf.h          | 3007 ++++++++++++++++++++++++++++++++++++++++++++
- scripts/mod/mk_elfconfig.c |    4 +
- scripts/mod/modpost.h      |    4 +
- 4 files changed, 3018 insertions(+)
- create mode 100644 scripts/mod/elf.h
-
---- /dev/null
-+++ b/scripts/mod/elf.h
-@@ -0,0 +1,3007 @@
-+/* This file defines standard ELF types, structures, and macros.
-+   Copyright (C) 1995-2012 Free Software Foundation, Inc.
-+   This file is part of the GNU C Library.
-+
-+   The GNU C Library is free software; you can redistribute it and/or
-+   modify it under the terms of the GNU Lesser General Public
-+   License as published by the Free Software Foundation; either
-+   version 2.1 of the License, or (at your option) any later version.
-+
-+   The GNU C Library is distributed in the hope that it will be useful,
-+   but WITHOUT ANY WARRANTY; without even the implied warranty of
-+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-+   Lesser General Public License for more details.
-+
-+   You should have received a copy of the GNU Lesser General Public
-+   License along with the GNU C Library; if not, see
-+   <http://www.gnu.org/licenses/>.  */
-+
-+#ifndef _ELF_H
-+#define	_ELF_H 1
-+
-+/* Standard ELF types.  */
-+
-+#include <stdint.h>
-+
-+/* Type for a 16-bit quantity.  */
-+typedef uint16_t Elf32_Half;
-+typedef uint16_t Elf64_Half;
-+
-+/* Types for signed and unsigned 32-bit quantities.  */
-+typedef uint32_t Elf32_Word;
-+typedef	int32_t  Elf32_Sword;
-+typedef uint32_t Elf64_Word;
-+typedef	int32_t  Elf64_Sword;
-+
-+/* Types for signed and unsigned 64-bit quantities.  */
-+typedef uint64_t Elf32_Xword;
-+typedef	int64_t  Elf32_Sxword;
-+typedef uint64_t Elf64_Xword;
-+typedef	int64_t  Elf64_Sxword;
-+
-+/* Type of addresses.  */
-+typedef uint32_t Elf32_Addr;
-+typedef uint64_t Elf64_Addr;
-+
-+/* Type of file offsets.  */
-+typedef uint32_t Elf32_Off;
-+typedef uint64_t Elf64_Off;
-+
-+/* Type for section indices, which are 16-bit quantities.  */
-+typedef uint16_t Elf32_Section;
-+typedef uint16_t Elf64_Section;
-+
-+/* Type for version symbol information.  */
-+typedef Elf32_Half Elf32_Versym;
-+typedef Elf64_Half Elf64_Versym;
-+
-+
-+/* The ELF file header.  This appears at the start of every ELF file.  */
-+
-+#define EI_NIDENT (16)
-+
-+typedef struct
-+{
-+  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
-+  Elf32_Half	e_type;			/* Object file type */
-+  Elf32_Half	e_machine;		/* Architecture */
-+  Elf32_Word	e_version;		/* Object file version */
-+  Elf32_Addr	e_entry;		/* Entry point virtual address */
-+  Elf32_Off	e_phoff;		/* Program header table file offset */
-+  Elf32_Off	e_shoff;		/* Section header table file offset */
-+  Elf32_Word	e_flags;		/* Processor-specific flags */
-+  Elf32_Half	e_ehsize;		/* ELF header size in bytes */
-+  Elf32_Half	e_phentsize;		/* Program header table entry size */
-+  Elf32_Half	e_phnum;		/* Program header table entry count */
-+  Elf32_Half	e_shentsize;		/* Section header table entry size */
-+  Elf32_Half	e_shnum;		/* Section header table entry count */
-+  Elf32_Half	e_shstrndx;		/* Section header string table index */
-+} Elf32_Ehdr;
-+
-+typedef struct
-+{
-+  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
-+  Elf64_Half	e_type;			/* Object file type */
-+  Elf64_Half	e_machine;		/* Architecture */
-+  Elf64_Word	e_version;		/* Object file version */
-+  Elf64_Addr	e_entry;		/* Entry point virtual address */
-+  Elf64_Off	e_phoff;		/* Program header table file offset */
-+  Elf64_Off	e_shoff;		/* Section header table file offset */
-+  Elf64_Word	e_flags;		/* Processor-specific flags */
-+  Elf64_Half	e_ehsize;		/* ELF header size in bytes */
-+  Elf64_Half	e_phentsize;		/* Program header table entry size */
-+  Elf64_Half	e_phnum;		/* Program header table entry count */
-+  Elf64_Half	e_shentsize;		/* Section header table entry size */
-+  Elf64_Half	e_shnum;		/* Section header table entry count */
-+  Elf64_Half	e_shstrndx;		/* Section header string table index */
-+} Elf64_Ehdr;
-+
-+/* Fields in the e_ident array.  The EI_* macros are indices into the
-+   array.  The macros under each EI_* macro are the values the byte
-+   may have.  */
-+
-+#define EI_MAG0		0		/* File identification byte 0 index */
-+#define ELFMAG0		0x7f		/* Magic number byte 0 */
-+
-+#define EI_MAG1		1		/* File identification byte 1 index */
-+#define ELFMAG1		'E'		/* Magic number byte 1 */
-+
-+#define EI_MAG2		2		/* File identification byte 2 index */
-+#define ELFMAG2		'L'		/* Magic number byte 2 */
-+
-+#define EI_MAG3		3		/* File identification byte 3 index */
-+#define ELFMAG3		'F'		/* Magic number byte 3 */
-+
-+/* Conglomeration of the identification bytes, for easy testing as a word.  */
-+#define	ELFMAG		"\177ELF"
-+#define	SELFMAG		4
-+
-+#define EI_CLASS	4		/* File class byte index */
-+#define ELFCLASSNONE	0		/* Invalid class */
-+#define ELFCLASS32	1		/* 32-bit objects */
-+#define ELFCLASS64	2		/* 64-bit objects */
-+#define ELFCLASSNUM	3
-+
-+#define EI_DATA		5		/* Data encoding byte index */
-+#define ELFDATANONE	0		/* Invalid data encoding */
-+#define ELFDATA2LSB	1		/* 2's complement, little endian */
-+#define ELFDATA2MSB	2		/* 2's complement, big endian */
-+#define ELFDATANUM	3
-+
-+#define EI_VERSION	6		/* File version byte index */
-+					/* Value must be EV_CURRENT */
-+
-+#define EI_OSABI	7		/* OS ABI identification */
-+#define ELFOSABI_NONE		0	/* UNIX System V ABI */
-+#define ELFOSABI_SYSV		0	/* Alias.  */
-+#define ELFOSABI_HPUX		1	/* HP-UX */
-+#define ELFOSABI_NETBSD		2	/* NetBSD.  */
-+#define ELFOSABI_GNU		3	/* Object uses GNU ELF extensions.  */
-+#define ELFOSABI_LINUX		ELFOSABI_GNU /* Compatibility alias.  */
-+#define ELFOSABI_SOLARIS	6	/* Sun Solaris.  */
-+#define ELFOSABI_AIX		7	/* IBM AIX.  */
-+#define ELFOSABI_IRIX		8	/* SGI Irix.  */
-+#define ELFOSABI_FREEBSD	9	/* FreeBSD.  */
-+#define ELFOSABI_TRU64		10	/* Compaq TRU64 UNIX.  */
-+#define ELFOSABI_MODESTO	11	/* Novell Modesto.  */
-+#define ELFOSABI_OPENBSD	12	/* OpenBSD.  */
-+#define ELFOSABI_ARM_AEABI	64	/* ARM EABI */
-+#define ELFOSABI_ARM		97	/* ARM */
-+#define ELFOSABI_STANDALONE	255	/* Standalone (embedded) application */
-+
-+#define EI_ABIVERSION	8		/* ABI version */
-+
-+#define EI_PAD		9		/* Byte index of padding bytes */
-+
-+/* Legal values for e_type (object file type).  */
-+
-+#define ET_NONE		0		/* No file type */
-+#define ET_REL		1		/* Relocatable file */
-+#define ET_EXEC		2		/* Executable file */
-+#define ET_DYN		3		/* Shared object file */
-+#define ET_CORE		4		/* Core file */
-+#define	ET_NUM		5		/* Number of defined types */
-+#define ET_LOOS		0xfe00		/* OS-specific range start */
-+#define ET_HIOS		0xfeff		/* OS-specific range end */
-+#define ET_LOPROC	0xff00		/* Processor-specific range start */
-+#define ET_HIPROC	0xffff		/* Processor-specific range end */
-+
-+/* Legal values for e_machine (architecture).  */
-+
-+#define EM_NONE		 0		/* No machine */
-+#define EM_M32		 1		/* AT&T WE 32100 */
-+#define EM_SPARC	 2		/* SUN SPARC */
-+#define EM_386		 3		/* Intel 80386 */
-+#define EM_68K		 4		/* Motorola m68k family */
-+#define EM_88K		 5		/* Motorola m88k family */
-+#define EM_860		 7		/* Intel 80860 */
-+#define EM_MIPS		 8		/* MIPS R3000 big-endian */
-+#define EM_S370		 9		/* IBM System/370 */
-+#define EM_MIPS_RS3_LE	10		/* MIPS R3000 little-endian */
-+
-+#define EM_PARISC	15		/* HPPA */
-+#define EM_VPP500	17		/* Fujitsu VPP500 */
-+#define EM_SPARC32PLUS	18		/* Sun's "v8plus" */
-+#define EM_960		19		/* Intel 80960 */
-+#define EM_PPC		20		/* PowerPC */
-+#define EM_PPC64	21		/* PowerPC 64-bit */
-+#define EM_S390		22		/* IBM S390 */
-+
-+#define EM_V800		36		/* NEC V800 series */
-+#define EM_FR20		37		/* Fujitsu FR20 */
-+#define EM_RH32		38		/* TRW RH-32 */
-+#define EM_RCE		39		/* Motorola RCE */
-+#define EM_ARM		40		/* ARM */
-+#define EM_FAKE_ALPHA	41		/* Digital Alpha */
-+#define EM_SH		42		/* Hitachi SH */
-+#define EM_SPARCV9	43		/* SPARC v9 64-bit */
-+#define EM_TRICORE	44		/* Siemens Tricore */
-+#define EM_ARC		45		/* Argonaut RISC Core */
-+#define EM_H8_300	46		/* Hitachi H8/300 */
-+#define EM_H8_300H	47		/* Hitachi H8/300H */
-+#define EM_H8S		48		/* Hitachi H8S */
-+#define EM_H8_500	49		/* Hitachi H8/500 */
-+#define EM_IA_64	50		/* Intel Merced */
-+#define EM_MIPS_X	51		/* Stanford MIPS-X */
-+#define EM_COLDFIRE	52		/* Motorola Coldfire */
-+#define EM_68HC12	53		/* Motorola M68HC12 */
-+#define EM_MMA		54		/* Fujitsu MMA Multimedia Accelerator*/
-+#define EM_PCP		55		/* Siemens PCP */
-+#define EM_NCPU		56		/* Sony nCPU embeeded RISC */
-+#define EM_NDR1		57		/* Denso NDR1 microprocessor */
-+#define EM_STARCORE	58		/* Motorola Start*Core processor */
-+#define EM_ME16		59		/* Toyota ME16 processor */
-+#define EM_ST100	60		/* STMicroelectronic ST100 processor */
-+#define EM_TINYJ	61		/* Advanced Logic Corp. Tinyj emb.fam*/
-+#define EM_X86_64	62		/* AMD x86-64 architecture */
-+#define EM_PDSP		63		/* Sony DSP Processor */
-+
-+#define EM_FX66		66		/* Siemens FX66 microcontroller */
-+#define EM_ST9PLUS	67		/* STMicroelectronics ST9+ 8/16 mc */
-+#define EM_ST7		68		/* STmicroelectronics ST7 8 bit mc */
-+#define EM_68HC16	69		/* Motorola MC68HC16 microcontroller */
-+#define EM_68HC11	70		/* Motorola MC68HC11 microcontroller */
-+#define EM_68HC08	71		/* Motorola MC68HC08 microcontroller */
-+#define EM_68HC05	72		/* Motorola MC68HC05 microcontroller */
-+#define EM_SVX		73		/* Silicon Graphics SVx */
-+#define EM_ST19		74		/* STMicroelectronics ST19 8 bit mc */
-+#define EM_VAX		75		/* Digital VAX */
-+#define EM_CRIS		76		/* Axis Communications 32-bit embedded processor */
-+#define EM_JAVELIN	77		/* Infineon Technologies 32-bit embedded processor */
-+#define EM_FIREPATH	78		/* Element 14 64-bit DSP Processor */
-+#define EM_ZSP		79		/* LSI Logic 16-bit DSP Processor */
-+#define EM_MMIX		80		/* Donald Knuth's educational 64-bit processor */
-+#define EM_HUANY	81		/* Harvard University machine-independent object files */
-+#define EM_PRISM	82		/* SiTera Prism */
-+#define EM_AVR		83		/* Atmel AVR 8-bit microcontroller */
-+#define EM_FR30		84		/* Fujitsu FR30 */
-+#define EM_D10V		85		/* Mitsubishi D10V */
-+#define EM_D30V		86		/* Mitsubishi D30V */
-+#define EM_V850		87		/* NEC v850 */
-+#define EM_M32R		88		/* Mitsubishi M32R */
-+#define EM_MN10300	89		/* Matsushita MN10300 */
-+#define EM_MN10200	90		/* Matsushita MN10200 */
-+#define EM_PJ		91		/* picoJava */
-+#define EM_OPENRISC	92		/* OpenRISC 32-bit embedded processor */
-+#define EM_ARC_A5	93		/* ARC Cores Tangent-A5 */
-+#define EM_XTENSA	94		/* Tensilica Xtensa Architecture */
-+#define EM_TILEPRO	188		/* Tilera TILEPro */
-+#define EM_TILEGX	191		/* Tilera TILE-Gx */
-+#define EM_NUM		192
-+
-+/* If it is necessary to assign new unofficial EM_* values, please
-+   pick large random numbers (0x8523, 0xa7f2, etc.) to minimize the
-+   chances of collision with official or non-GNU unofficial values.  */
-+
-+#define EM_ALPHA	0x9026
-+
-+/* Legal values for e_version (version).  */
-+
-+#define EV_NONE		0		/* Invalid ELF version */
-+#define EV_CURRENT	1		/* Current version */
-+#define EV_NUM		2
-+
-+/* Section header.  */
-+
-+typedef struct
-+{
-+  Elf32_Word	sh_name;		/* Section name (string tbl index) */
-+  Elf32_Word	sh_type;		/* Section type */
-+  Elf32_Word	sh_flags;		/* Section flags */
-+  Elf32_Addr	sh_addr;		/* Section virtual addr at execution */
-+  Elf32_Off	sh_offset;		/* Section file offset */
-+  Elf32_Word	sh_size;		/* Section size in bytes */
-+  Elf32_Word	sh_link;		/* Link to another section */
-+  Elf32_Word	sh_info;		/* Additional section information */
-+  Elf32_Word	sh_addralign;		/* Section alignment */
-+  Elf32_Word	sh_entsize;		/* Entry size if section holds table */
-+} Elf32_Shdr;
-+
-+typedef struct
-+{
-+  Elf64_Word	sh_name;		/* Section name (string tbl index) */
-+  Elf64_Word	sh_type;		/* Section type */
-+  Elf64_Xword	sh_flags;		/* Section flags */
-+  Elf64_Addr	sh_addr;		/* Section virtual addr at execution */
-+  Elf64_Off	sh_offset;		/* Section file offset */
-+  Elf64_Xword	sh_size;		/* Section size in bytes */
-+  Elf64_Word	sh_link;		/* Link to another section */
-+  Elf64_Word	sh_info;		/* Additional section information */
-+  Elf64_Xword	sh_addralign;		/* Section alignment */
-+  Elf64_Xword	sh_entsize;		/* Entry size if section holds table */
-+} Elf64_Shdr;
-+
-+/* Special section indices.  */
-+
-+#define SHN_UNDEF	0		/* Undefined section */
-+#define SHN_LORESERVE	0xff00		/* Start of reserved indices */
-+#define SHN_LOPROC	0xff00		/* Start of processor-specific */
-+#define SHN_BEFORE	0xff00		/* Order section before all others
-+					   (Solaris).  */
-+#define SHN_AFTER	0xff01		/* Order section after all others
-+					   (Solaris).  */
-+#define SHN_HIPROC	0xff1f		/* End of processor-specific */
-+#define SHN_LOOS	0xff20		/* Start of OS-specific */
-+#define SHN_HIOS	0xff3f		/* End of OS-specific */
-+#define SHN_ABS		0xfff1		/* Associated symbol is absolute */
-+#define SHN_COMMON	0xfff2		/* Associated symbol is common */
-+#define SHN_XINDEX	0xffff		/* Index is in extra table.  */
-+#define SHN_HIRESERVE	0xffff		/* End of reserved indices */
-+
-+/* Legal values for sh_type (section type).  */
-+
-+#define SHT_NULL	  0		/* Section header table entry unused */
-+#define SHT_PROGBITS	  1		/* Program data */
-+#define SHT_SYMTAB	  2		/* Symbol table */
-+#define SHT_STRTAB	  3		/* String table */
-+#define SHT_RELA	  4		/* Relocation entries with addends */
-+#define SHT_HASH	  5		/* Symbol hash table */
-+#define SHT_DYNAMIC	  6		/* Dynamic linking information */
-+#define SHT_NOTE	  7		/* Notes */
-+#define SHT_NOBITS	  8		/* Program space with no data (bss) */
-+#define SHT_REL		  9		/* Relocation entries, no addends */
-+#define SHT_SHLIB	  10		/* Reserved */
-+#define SHT_DYNSYM	  11		/* Dynamic linker symbol table */
-+#define SHT_INIT_ARRAY	  14		/* Array of constructors */
-+#define SHT_FINI_ARRAY	  15		/* Array of destructors */
-+#define SHT_PREINIT_ARRAY 16		/* Array of pre-constructors */
-+#define SHT_GROUP	  17		/* Section group */
-+#define SHT_SYMTAB_SHNDX  18		/* Extended section indeces */
-+#define	SHT_NUM		  19		/* Number of defined types.  */
-+#define SHT_LOOS	  0x60000000	/* Start OS-specific.  */
-+#define SHT_GNU_ATTRIBUTES 0x6ffffff5	/* Object attributes.  */
-+#define SHT_GNU_HASH	  0x6ffffff6	/* GNU-style hash table.  */
-+#define SHT_GNU_LIBLIST	  0x6ffffff7	/* Prelink library list */
-+#define SHT_CHECKSUM	  0x6ffffff8	/* Checksum for DSO content.  */
-+#define SHT_LOSUNW	  0x6ffffffa	/* Sun-specific low bound.  */
-+#define SHT_SUNW_move	  0x6ffffffa
-+#define SHT_SUNW_COMDAT   0x6ffffffb
-+#define SHT_SUNW_syminfo  0x6ffffffc
-+#define SHT_GNU_verdef	  0x6ffffffd	/* Version definition section.  */
-+#define SHT_GNU_verneed	  0x6ffffffe	/* Version needs section.  */
-+#define SHT_GNU_versym	  0x6fffffff	/* Version symbol table.  */
-+#define SHT_HISUNW	  0x6fffffff	/* Sun-specific high bound.  */
-+#define SHT_HIOS	  0x6fffffff	/* End OS-specific type */
-+#define SHT_LOPROC	  0x70000000	/* Start of processor-specific */
-+#define SHT_HIPROC	  0x7fffffff	/* End of processor-specific */
-+#define SHT_LOUSER	  0x80000000	/* Start of application-specific */
-+#define SHT_HIUSER	  0x8fffffff	/* End of application-specific */
-+
-+/* Legal values for sh_flags (section flags).  */
-+
-+#define SHF_WRITE	     (1 << 0)	/* Writable */
-+#define SHF_ALLOC	     (1 << 1)	/* Occupies memory during execution */
-+#define SHF_EXECINSTR	     (1 << 2)	/* Executable */
-+#define SHF_MERGE	     (1 << 4)	/* Might be merged */
-+#define SHF_STRINGS	     (1 << 5)	/* Contains nul-terminated strings */
-+#define SHF_INFO_LINK	     (1 << 6)	/* `sh_info' contains SHT index */
-+#define SHF_LINK_ORDER	     (1 << 7)	/* Preserve order after combining */
-+#define SHF_OS_NONCONFORMING (1 << 8)	/* Non-standard OS specific handling
-+					   required */
-+#define SHF_GROUP	     (1 << 9)	/* Section is member of a group.  */
-+#define SHF_TLS		     (1 << 10)	/* Section hold thread-local data.  */
-+#define SHF_MASKOS	     0x0ff00000	/* OS-specific.  */
-+#define SHF_MASKPROC	     0xf0000000	/* Processor-specific */
-+#define SHF_ORDERED	     (1 << 30)	/* Special ordering requirement
-+					   (Solaris).  */
-+#define SHF_EXCLUDE	     (1 << 31)	/* Section is excluded unless
-+					   referenced or allocated (Solaris).*/
-+
-+/* Section group handling.  */
-+#define GRP_COMDAT	0x1		/* Mark group as COMDAT.  */
-+
-+/* Symbol table entry.  */
-+
-+typedef struct
-+{
-+  Elf32_Word	st_name;		/* Symbol name (string tbl index) */
-+  Elf32_Addr	st_value;		/* Symbol value */
-+  Elf32_Word	st_size;		/* Symbol size */
-+  unsigned char	st_info;		/* Symbol type and binding */
-+  unsigned char	st_other;		/* Symbol visibility */
-+  Elf32_Section	st_shndx;		/* Section index */
-+} Elf32_Sym;
-+
-+typedef struct
-+{
-+  Elf64_Word	st_name;		/* Symbol name (string tbl index) */
-+  unsigned char	st_info;		/* Symbol type and binding */
-+  unsigned char st_other;		/* Symbol visibility */
-+  Elf64_Section	st_shndx;		/* Section index */
-+  Elf64_Addr	st_value;		/* Symbol value */
-+  Elf64_Xword	st_size;		/* Symbol size */
-+} Elf64_Sym;
-+
-+/* The syminfo section if available contains additional information about
-+   every dynamic symbol.  */
-+
-+typedef struct
-+{
-+  Elf32_Half si_boundto;		/* Direct bindings, symbol bound to */
-+  Elf32_Half si_flags;			/* Per symbol flags */
-+} Elf32_Syminfo;
-+
-+typedef struct
-+{
-+  Elf64_Half si_boundto;		/* Direct bindings, symbol bound to */
-+  Elf64_Half si_flags;			/* Per symbol flags */
-+} Elf64_Syminfo;
-+
-+/* Possible values for si_boundto.  */
-+#define SYMINFO_BT_SELF		0xffff	/* Symbol bound to self */
-+#define SYMINFO_BT_PARENT	0xfffe	/* Symbol bound to parent */
-+#define SYMINFO_BT_LOWRESERVE	0xff00	/* Beginning of reserved entries */
-+
-+/* Possible bitmasks for si_flags.  */
-+#define SYMINFO_FLG_DIRECT	0x0001	/* Direct bound symbol */
-+#define SYMINFO_FLG_PASSTHRU	0x0002	/* Pass-thru symbol for translator */
-+#define SYMINFO_FLG_COPY	0x0004	/* Symbol is a copy-reloc */
-+#define SYMINFO_FLG_LAZYLOAD	0x0008	/* Symbol bound to object to be lazy
-+					   loaded */
-+/* Syminfo version values.  */
-+#define SYMINFO_NONE		0
-+#define SYMINFO_CURRENT		1
-+#define SYMINFO_NUM		2
-+
-+
-+/* How to extract and insert information held in the st_info field.  */
-+
-+#define ELF32_ST_BIND(val)		(((unsigned char) (val)) >> 4)
-+#define ELF32_ST_TYPE(val)		((val) & 0xf)
-+#define ELF32_ST_INFO(bind, type)	(((bind) << 4) + ((type) & 0xf))
-+
-+/* Both Elf32_Sym and Elf64_Sym use the same one-byte st_info field.  */
-+#define ELF64_ST_BIND(val)		ELF32_ST_BIND (val)
-+#define ELF64_ST_TYPE(val)		ELF32_ST_TYPE (val)
-+#define ELF64_ST_INFO(bind, type)	ELF32_ST_INFO ((bind), (type))
-+
-+/* Legal values for ST_BIND subfield of st_info (symbol binding).  */
-+
-+#define STB_LOCAL	0		/* Local symbol */
-+#define STB_GLOBAL	1		/* Global symbol */
-+#define STB_WEAK	2		/* Weak symbol */
-+#define	STB_NUM		3		/* Number of defined types.  */
-+#define STB_LOOS	10		/* Start of OS-specific */
-+#define STB_GNU_UNIQUE	10		/* Unique symbol.  */
-+#define STB_HIOS	12		/* End of OS-specific */
-+#define STB_LOPROC	13		/* Start of processor-specific */
-+#define STB_HIPROC	15		/* End of processor-specific */
-+
-+/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
-+
-+#define STT_NOTYPE	0		/* Symbol type is unspecified */
-+#define STT_OBJECT	1		/* Symbol is a data object */
-+#define STT_FUNC	2		/* Symbol is a code object */
-+#define STT_SECTION	3		/* Symbol associated with a section */
-+#define STT_FILE	4		/* Symbol's name is file name */
-+#define STT_COMMON	5		/* Symbol is a common data object */
-+#define STT_TLS		6		/* Symbol is thread-local data object*/
-+#define	STT_NUM		7		/* Number of defined types.  */
-+#define STT_LOOS	10		/* Start of OS-specific */
-+#define STT_GNU_IFUNC	10		/* Symbol is indirect code object */
-+#define STT_HIOS	12		/* End of OS-specific */
-+#define STT_LOPROC	13		/* Start of processor-specific */
-+#define STT_HIPROC	15		/* End of processor-specific */
-+
-+
-+/* Symbol table indices are found in the hash buckets and chain table
-+   of a symbol hash table section.  This special index value indicates
-+   the end of a chain, meaning no further symbols are found in that bucket.  */
-+
-+#define STN_UNDEF	0		/* End of a chain.  */
-+
-+
-+/* How to extract and insert information held in the st_other field.  */
-+
-+#define ELF32_ST_VISIBILITY(o)	((o) & 0x03)
-+
-+/* For ELF64 the definitions are the same.  */
-+#define ELF64_ST_VISIBILITY(o)	ELF32_ST_VISIBILITY (o)
-+
-+/* Symbol visibility specification encoded in the st_other field.  */
-+#define STV_DEFAULT	0		/* Default symbol visibility rules */
-+#define STV_INTERNAL	1		/* Processor specific hidden class */
-+#define STV_HIDDEN	2		/* Sym unavailable in other modules */
-+#define STV_PROTECTED	3		/* Not preemptible, not exported */
-+
-+
-+/* Relocation table entry without addend (in section of type SHT_REL).  */
-+
-+typedef struct
-+{
-+  Elf32_Addr	r_offset;		/* Address */
-+  Elf32_Word	r_info;			/* Relocation type and symbol index */
-+} Elf32_Rel;
-+
-+/* I have seen two different definitions of the Elf64_Rel and
-+   Elf64_Rela structures, so we'll leave them out until Novell (or
-+   whoever) gets their act together.  */
-+/* The following, at least, is used on Sparc v9, MIPS, and Alpha.  */
-+
-+typedef struct
-+{
-+  Elf64_Addr	r_offset;		/* Address */
-+  Elf64_Xword	r_info;			/* Relocation type and symbol index */
-+} Elf64_Rel;
-+
-+/* Relocation table entry with addend (in section of type SHT_RELA).  */
-+
-+typedef struct
-+{
-+  Elf32_Addr	r_offset;		/* Address */
-+  Elf32_Word	r_info;			/* Relocation type and symbol index */
-+  Elf32_Sword	r_addend;		/* Addend */
-+} Elf32_Rela;
-+
-+typedef struct
-+{
-+  Elf64_Addr	r_offset;		/* Address */
-+  Elf64_Xword	r_info;			/* Relocation type and symbol index */
-+  Elf64_Sxword	r_addend;		/* Addend */
-+} Elf64_Rela;
-+
-+/* How to extract and insert information held in the r_info field.  */
-+
-+#define ELF32_R_SYM(val)		((val) >> 8)
-+#define ELF32_R_TYPE(val)		((val) & 0xff)
-+#define ELF32_R_INFO(sym, type)		(((sym) << 8) + ((type) & 0xff))
-+
-+#define ELF64_R_SYM(i)			((i) >> 32)
-+#define ELF64_R_TYPE(i)			((i) & 0xffffffff)
-+#define ELF64_R_INFO(sym,type)		((((Elf64_Xword) (sym)) << 32) + (type))
-+
-+/* Program segment header.  */
-+
-+typedef struct
-+{
-+  Elf32_Word	p_type;			/* Segment type */
-+  Elf32_Off	p_offset;		/* Segment file offset */
-+  Elf32_Addr	p_vaddr;		/* Segment virtual address */
-+  Elf32_Addr	p_paddr;		/* Segment physical address */
-+  Elf32_Word	p_filesz;		/* Segment size in file */
-+  Elf32_Word	p_memsz;		/* Segment size in memory */
-+  Elf32_Word	p_flags;		/* Segment flags */
-+  Elf32_Word	p_align;		/* Segment alignment */
-+} Elf32_Phdr;
-+
-+typedef struct
-+{
-+  Elf64_Word	p_type;			/* Segment type */
-+  Elf64_Word	p_flags;		/* Segment flags */
-+  Elf64_Off	p_offset;		/* Segment file offset */
-+  Elf64_Addr	p_vaddr;		/* Segment virtual address */
-+  Elf64_Addr	p_paddr;		/* Segment physical address */
-+  Elf64_Xword	p_filesz;		/* Segment size in file */
-+  Elf64_Xword	p_memsz;		/* Segment size in memory */
-+  Elf64_Xword	p_align;		/* Segment alignment */
-+} Elf64_Phdr;
-+
-+/* Special value for e_phnum.  This indicates that the real number of
-+   program headers is too large to fit into e_phnum.  Instead the real
-+   value is in the field sh_info of section 0.  */
-+
-+#define PN_XNUM		0xffff
-+
-+/* Legal values for p_type (segment type).  */
-+
-+#define	PT_NULL		0		/* Program header table entry unused */
-+#define PT_LOAD		1		/* Loadable program segment */
-+#define PT_DYNAMIC	2		/* Dynamic linking information */
-+#define PT_INTERP	3		/* Program interpreter */
-+#define PT_NOTE		4		/* Auxiliary information */
-+#define PT_SHLIB	5		/* Reserved */
-+#define PT_PHDR		6		/* Entry for header table itself */
-+#define PT_TLS		7		/* Thread-local storage segment */
-+#define	PT_NUM		8		/* Number of defined types */
-+#define PT_LOOS		0x60000000	/* Start of OS-specific */
-+#define PT_GNU_EH_FRAME	0x6474e550	/* GCC .eh_frame_hdr segment */
-+#define PT_GNU_STACK	0x6474e551	/* Indicates stack executability */
-+#define PT_GNU_RELRO	0x6474e552	/* Read-only after relocation */
-+#define PT_LOSUNW	0x6ffffffa
-+#define PT_SUNWBSS	0x6ffffffa	/* Sun Specific segment */
-+#define PT_SUNWSTACK	0x6ffffffb	/* Stack segment */
-+#define PT_HISUNW	0x6fffffff
-+#define PT_HIOS		0x6fffffff	/* End of OS-specific */
-+#define PT_LOPROC	0x70000000	/* Start of processor-specific */
-+#define PT_HIPROC	0x7fffffff	/* End of processor-specific */
-+
-+/* Legal values for p_flags (segment flags).  */
-+
-+#define PF_X		(1 << 0)	/* Segment is executable */
-+#define PF_W		(1 << 1)	/* Segment is writable */
-+#define PF_R		(1 << 2)	/* Segment is readable */
-+#define PF_MASKOS	0x0ff00000	/* OS-specific */
-+#define PF_MASKPROC	0xf0000000	/* Processor-specific */
-+
-+/* Legal values for note segment descriptor types for core files. */
-+
-+#define NT_PRSTATUS	1		/* Contains copy of prstatus struct */
-+#define NT_FPREGSET	2		/* Contains copy of fpregset struct */
-+#define NT_PRPSINFO	3		/* Contains copy of prpsinfo struct */
-+#define NT_PRXREG	4		/* Contains copy of prxregset struct */
-+#define NT_TASKSTRUCT	4		/* Contains copy of task structure */
-+#define NT_PLATFORM	5		/* String from sysinfo(SI_PLATFORM) */
-+#define NT_AUXV		6		/* Contains copy of auxv array */
-+#define NT_GWINDOWS	7		/* Contains copy of gwindows struct */
-+#define NT_ASRS		8		/* Contains copy of asrset struct */
-+#define NT_PSTATUS	10		/* Contains copy of pstatus struct */
-+#define NT_PSINFO	13		/* Contains copy of psinfo struct */
-+#define NT_PRCRED	14		/* Contains copy of prcred struct */
-+#define NT_UTSNAME	15		/* Contains copy of utsname struct */
-+#define NT_LWPSTATUS	16		/* Contains copy of lwpstatus struct */
-+#define NT_LWPSINFO	17		/* Contains copy of lwpinfo struct */
-+#define NT_PRFPXREG	20		/* Contains copy of fprxregset struct */
-+#define NT_PRXFPREG	0x46e62b7f	/* Contains copy of user_fxsr_struct */
-+#define NT_PPC_VMX	0x100		/* PowerPC Altivec/VMX registers */
-+#define NT_PPC_SPE	0x101		/* PowerPC SPE/EVR registers */
-+#define NT_PPC_VSX	0x102		/* PowerPC VSX registers */
-+#define NT_386_TLS	0x200		/* i386 TLS slots (struct user_desc) */
-+#define NT_386_IOPERM	0x201		/* x86 io permission bitmap (1=deny) */
-+#define NT_X86_XSTATE	0x202		/* x86 extended state using xsave */
-+
-+/* Legal values for the note segment descriptor types for object files.  */
-+
-+#define NT_VERSION	1		/* Contains a version string.  */
-+
-+
-+/* Dynamic section entry.  */
-+
-+typedef struct
-+{
-+  Elf32_Sword	d_tag;			/* Dynamic entry type */
-+  union
-+    {
-+      Elf32_Word d_val;			/* Integer value */
-+      Elf32_Addr d_ptr;			/* Address value */
-+    } d_un;
-+} Elf32_Dyn;
-+
-+typedef struct
-+{
-+  Elf64_Sxword	d_tag;			/* Dynamic entry type */
-+  union
-+    {
-+      Elf64_Xword d_val;		/* Integer value */
-+      Elf64_Addr d_ptr;			/* Address value */
-+    } d_un;
-+} Elf64_Dyn;
-+
-+/* Legal values for d_tag (dynamic entry type).  */
-+
-+#define DT_NULL		0		/* Marks end of dynamic section */
-+#define DT_NEEDED	1		/* Name of needed library */
-+#define DT_PLTRELSZ	2		/* Size in bytes of PLT relocs */
-+#define DT_PLTGOT	3		/* Processor defined value */
-+#define DT_HASH		4		/* Address of symbol hash table */
-+#define DT_STRTAB	5		/* Address of string table */
-+#define DT_SYMTAB	6		/* Address of symbol table */
-+#define DT_RELA		7		/* Address of Rela relocs */
-+#define DT_RELASZ	8		/* Total size of Rela relocs */
-+#define DT_RELAENT	9		/* Size of one Rela reloc */
-+#define DT_STRSZ	10		/* Size of string table */
-+#define DT_SYMENT	11		/* Size of one symbol table entry */
-+#define DT_INIT		12		/* Address of init function */
-+#define DT_FINI		13		/* Address of termination function */
-+#define DT_SONAME	14		/* Name of shared object */
-+#define DT_RPATH	15		/* Library search path (deprecated) */
-+#define DT_SYMBOLIC	16		/* Start symbol search here */
-+#define DT_REL		17		/* Address of Rel relocs */
-+#define DT_RELSZ	18		/* Total size of Rel relocs */
-+#define DT_RELENT	19		/* Size of one Rel reloc */
-+#define DT_PLTREL	20		/* Type of reloc in PLT */
-+#define DT_DEBUG	21		/* For debugging; unspecified */
-+#define DT_TEXTREL	22		/* Reloc might modify .text */
-+#define DT_JMPREL	23		/* Address of PLT relocs */
-+#define	DT_BIND_NOW	24		/* Process relocations of object */
-+#define	DT_INIT_ARRAY	25		/* Array with addresses of init fct */
-+#define	DT_FINI_ARRAY	26		/* Array with addresses of fini fct */
-+#define	DT_INIT_ARRAYSZ	27		/* Size in bytes of DT_INIT_ARRAY */
-+#define	DT_FINI_ARRAYSZ	28		/* Size in bytes of DT_FINI_ARRAY */
-+#define DT_RUNPATH	29		/* Library search path */
-+#define DT_FLAGS	30		/* Flags for the object being loaded */
-+#define DT_ENCODING	32		/* Start of encoded range */
-+#define DT_PREINIT_ARRAY 32		/* Array with addresses of preinit fct*/
-+#define DT_PREINIT_ARRAYSZ 33		/* size in bytes of DT_PREINIT_ARRAY */
-+#define	DT_NUM		34		/* Number used */
-+#define DT_LOOS		0x6000000d	/* Start of OS-specific */
-+#define DT_HIOS		0x6ffff000	/* End of OS-specific */
-+#define DT_LOPROC	0x70000000	/* Start of processor-specific */
-+#define DT_HIPROC	0x7fffffff	/* End of processor-specific */
-+#define	DT_PROCNUM	DT_MIPS_NUM	/* Most used by any processor */
-+
-+/* DT_* entries which fall between DT_VALRNGHI & DT_VALRNGLO use the
-+   Dyn.d_un.d_val field of the Elf*_Dyn structure.  This follows Sun's
-+   approach.  */
-+#define DT_VALRNGLO	0x6ffffd00
-+#define DT_GNU_PRELINKED 0x6ffffdf5	/* Prelinking timestamp */
-+#define DT_GNU_CONFLICTSZ 0x6ffffdf6	/* Size of conflict section */
-+#define DT_GNU_LIBLISTSZ 0x6ffffdf7	/* Size of library list */
-+#define DT_CHECKSUM	0x6ffffdf8
-+#define DT_PLTPADSZ	0x6ffffdf9
-+#define DT_MOVEENT	0x6ffffdfa
-+#define DT_MOVESZ	0x6ffffdfb
-+#define DT_FEATURE_1	0x6ffffdfc	/* Feature selection (DTF_*).  */
-+#define DT_POSFLAG_1	0x6ffffdfd	/* Flags for DT_* entries, effecting
-+					   the following DT_* entry.  */
-+#define DT_SYMINSZ	0x6ffffdfe	/* Size of syminfo table (in bytes) */
-+#define DT_SYMINENT	0x6ffffdff	/* Entry size of syminfo */
-+#define DT_VALRNGHI	0x6ffffdff
-+#define DT_VALTAGIDX(tag)	(DT_VALRNGHI - (tag))	/* Reverse order! */
-+#define DT_VALNUM 12
-+
-+/* DT_* entries which fall between DT_ADDRRNGHI & DT_ADDRRNGLO use the
-+   Dyn.d_un.d_ptr field of the Elf*_Dyn structure.
-+
-+   If any adjustment is made to the ELF object after it has been
-+   built these entries will need to be adjusted.  */
-+#define DT_ADDRRNGLO	0x6ffffe00
-+#define DT_GNU_HASH	0x6ffffef5	/* GNU-style hash table.  */
-+#define DT_TLSDESC_PLT	0x6ffffef6
-+#define DT_TLSDESC_GOT	0x6ffffef7
-+#define DT_GNU_CONFLICT	0x6ffffef8	/* Start of conflict section */
-+#define DT_GNU_LIBLIST	0x6ffffef9	/* Library list */
-+#define DT_CONFIG	0x6ffffefa	/* Configuration information.  */
-+#define DT_DEPAUDIT	0x6ffffefb	/* Dependency auditing.  */
-+#define DT_AUDIT	0x6ffffefc	/* Object auditing.  */
-+#define	DT_PLTPAD	0x6ffffefd	/* PLT padding.  */
-+#define	DT_MOVETAB	0x6ffffefe	/* Move table.  */
-+#define DT_SYMINFO	0x6ffffeff	/* Syminfo table.  */
-+#define DT_ADDRRNGHI	0x6ffffeff
-+#define DT_ADDRTAGIDX(tag)	(DT_ADDRRNGHI - (tag))	/* Reverse order! */
-+#define DT_ADDRNUM 11
-+
-+/* The versioning entry types.  The next are defined as part of the
-+   GNU extension.  */
-+#define DT_VERSYM	0x6ffffff0
-+
-+#define DT_RELACOUNT	0x6ffffff9
-+#define DT_RELCOUNT	0x6ffffffa
-+
-+/* These were chosen by Sun.  */
-+#define DT_FLAGS_1	0x6ffffffb	/* State flags, see DF_1_* below.  */
-+#define	DT_VERDEF	0x6ffffffc	/* Address of version definition
-+					   table */
-+#define	DT_VERDEFNUM	0x6ffffffd	/* Number of version definitions */
-+#define	DT_VERNEED	0x6ffffffe	/* Address of table with needed
-+					   versions */
-+#define	DT_VERNEEDNUM	0x6fffffff	/* Number of needed versions */
-+#define DT_VERSIONTAGIDX(tag)	(DT_VERNEEDNUM - (tag))	/* Reverse order! */
-+#define DT_VERSIONTAGNUM 16
-+
-+/* Sun added these machine-independent extensions in the "processor-specific"
-+   range.  Be compatible.  */
-+#define DT_AUXILIARY    0x7ffffffd      /* Shared object to load before self */
-+#define DT_FILTER       0x7fffffff      /* Shared object to get values from */
-+#define DT_EXTRATAGIDX(tag)	((Elf32_Word)-((Elf32_Sword) (tag) <<1>>1)-1)
-+#define DT_EXTRANUM	3
-+
-+/* Values of `d_un.d_val' in the DT_FLAGS entry.  */
-+#define DF_ORIGIN	0x00000001	/* Object may use DF_ORIGIN */
-+#define DF_SYMBOLIC	0x00000002	/* Symbol resolutions starts here */
-+#define DF_TEXTREL	0x00000004	/* Object contains text relocations */
-+#define DF_BIND_NOW	0x00000008	/* No lazy binding for this object */
-+#define DF_STATIC_TLS	0x00000010	/* Module uses the static TLS model */
-+
-+/* State flags selectable in the `d_un.d_val' element of the DT_FLAGS_1
-+   entry in the dynamic section.  */
-+#define DF_1_NOW	0x00000001	/* Set RTLD_NOW for this object.  */
-+#define DF_1_GLOBAL	0x00000002	/* Set RTLD_GLOBAL for this object.  */
-+#define DF_1_GROUP	0x00000004	/* Set RTLD_GROUP for this object.  */
-+#define DF_1_NODELETE	0x00000008	/* Set RTLD_NODELETE for this object.*/
-+#define DF_1_LOADFLTR	0x00000010	/* Trigger filtee loading at runtime.*/
-+#define DF_1_INITFIRST	0x00000020	/* Set RTLD_INITFIRST for this object*/
-+#define DF_1_NOOPEN	0x00000040	/* Set RTLD_NOOPEN for this object.  */
-+#define DF_1_ORIGIN	0x00000080	/* $ORIGIN must be handled.  */
-+#define DF_1_DIRECT	0x00000100	/* Direct binding enabled.  */
-+#define DF_1_TRANS	0x00000200
-+#define DF_1_INTERPOSE	0x00000400	/* Object is used to interpose.  */
-+#define DF_1_NODEFLIB	0x00000800	/* Ignore default lib search path.  */
-+#define DF_1_NODUMP	0x00001000	/* Object can't be dldump'ed.  */
-+#define DF_1_CONFALT	0x00002000	/* Configuration alternative created.*/
-+#define DF_1_ENDFILTEE	0x00004000	/* Filtee terminates filters search. */
-+#define	DF_1_DISPRELDNE	0x00008000	/* Disp reloc applied at build time. */
-+#define	DF_1_DISPRELPND	0x00010000	/* Disp reloc applied at run-time.  */
-+
-+/* Flags for the feature selection in DT_FEATURE_1.  */
-+#define DTF_1_PARINIT	0x00000001
-+#define DTF_1_CONFEXP	0x00000002
-+
-+/* Flags in the DT_POSFLAG_1 entry effecting only the next DT_* entry.  */
-+#define DF_P1_LAZYLOAD	0x00000001	/* Lazyload following object.  */
-+#define DF_P1_GROUPPERM	0x00000002	/* Symbols from next object are not
-+					   generally available.  */
-+
-+/* Version definition sections.  */
-+
-+typedef struct
-+{
-+  Elf32_Half	vd_version;		/* Version revision */
-+  Elf32_Half	vd_flags;		/* Version information */
-+  Elf32_Half	vd_ndx;			/* Version Index */
-+  Elf32_Half	vd_cnt;			/* Number of associated aux entries */
-+  Elf32_Word	vd_hash;		/* Version name hash value */
-+  Elf32_Word	vd_aux;			/* Offset in bytes to verdaux array */
-+  Elf32_Word	vd_next;		/* Offset in bytes to next verdef
-+					   entry */
-+} Elf32_Verdef;
-+
-+typedef struct
-+{
-+  Elf64_Half	vd_version;		/* Version revision */
-+  Elf64_Half	vd_flags;		/* Version information */
-+  Elf64_Half	vd_ndx;			/* Version Index */
-+  Elf64_Half	vd_cnt;			/* Number of associated aux entries */
-+  Elf64_Word	vd_hash;		/* Version name hash value */
-+  Elf64_Word	vd_aux;			/* Offset in bytes to verdaux array */
-+  Elf64_Word	vd_next;		/* Offset in bytes to next verdef
-+					   entry */
-+} Elf64_Verdef;
-+
-+
-+/* Legal values for vd_version (version revision).  */
-+#define VER_DEF_NONE	0		/* No version */
-+#define VER_DEF_CURRENT	1		/* Current version */
-+#define VER_DEF_NUM	2		/* Given version number */
-+
-+/* Legal values for vd_flags (version information flags).  */
-+#define VER_FLG_BASE	0x1		/* Version definition of file itself */
-+#define VER_FLG_WEAK	0x2		/* Weak version identifier */
-+
-+/* Versym symbol index values.  */
-+#define	VER_NDX_LOCAL		0	/* Symbol is local.  */
-+#define	VER_NDX_GLOBAL		1	/* Symbol is global.  */
-+#define	VER_NDX_LORESERVE	0xff00	/* Beginning of reserved entries.  */
-+#define	VER_NDX_ELIMINATE	0xff01	/* Symbol is to be eliminated.  */
-+
-+/* Auxialiary version information.  */
-+
-+typedef struct
-+{
-+  Elf32_Word	vda_name;		/* Version or dependency names */
-+  Elf32_Word	vda_next;		/* Offset in bytes to next verdaux
-+					   entry */
-+} Elf32_Verdaux;
-+
-+typedef struct
-+{
-+  Elf64_Word	vda_name;		/* Version or dependency names */
-+  Elf64_Word	vda_next;		/* Offset in bytes to next verdaux
-+					   entry */
-+} Elf64_Verdaux;
-+
-+
-+/* Version dependency section.  */
-+
-+typedef struct
-+{
-+  Elf32_Half	vn_version;		/* Version of structure */
-+  Elf32_Half	vn_cnt;			/* Number of associated aux entries */
-+  Elf32_Word	vn_file;		/* Offset of filename for this
-+					   dependency */
-+  Elf32_Word	vn_aux;			/* Offset in bytes to vernaux array */
-+  Elf32_Word	vn_next;		/* Offset in bytes to next verneed
-+					   entry */
-+} Elf32_Verneed;
-+
-+typedef struct
-+{
-+  Elf64_Half	vn_version;		/* Version of structure */
-+  Elf64_Half	vn_cnt;			/* Number of associated aux entries */
-+  Elf64_Word	vn_file;		/* Offset of filename for this
-+					   dependency */
-+  Elf64_Word	vn_aux;			/* Offset in bytes to vernaux array */
-+  Elf64_Word	vn_next;		/* Offset in bytes to next verneed
-+					   entry */
-+} Elf64_Verneed;
-+
-+
-+/* Legal values for vn_version (version revision).  */
-+#define VER_NEED_NONE	 0		/* No version */
-+#define VER_NEED_CURRENT 1		/* Current version */
-+#define VER_NEED_NUM	 2		/* Given version number */
-+
-+/* Auxiliary needed version information.  */
-+
-+typedef struct
-+{
-+  Elf32_Word	vna_hash;		/* Hash value of dependency name */
-+  Elf32_Half	vna_flags;		/* Dependency specific information */
-+  Elf32_Half	vna_other;		/* Unused */
-+  Elf32_Word	vna_name;		/* Dependency name string offset */
-+  Elf32_Word	vna_next;		/* Offset in bytes to next vernaux
-+					   entry */
-+} Elf32_Vernaux;
-+
-+typedef struct
-+{
-+  Elf64_Word	vna_hash;		/* Hash value of dependency name */
-+  Elf64_Half	vna_flags;		/* Dependency specific information */
-+  Elf64_Half	vna_other;		/* Unused */
-+  Elf64_Word	vna_name;		/* Dependency name string offset */
-+  Elf64_Word	vna_next;		/* Offset in bytes to next vernaux
-+					   entry */
-+} Elf64_Vernaux;
-+
-+
-+/* Legal values for vna_flags.  */
-+#define VER_FLG_WEAK	0x2		/* Weak version identifier */
-+
-+
-+/* Auxiliary vector.  */
-+
-+/* This vector is normally only used by the program interpreter.  The
-+   usual definition in an ABI supplement uses the name auxv_t.  The
-+   vector is not usually defined in a standard <elf.h> file, but it
-+   can't hurt.  We rename it to avoid conflicts.  The sizes of these
-+   types are an arrangement between the exec server and the program
-+   interpreter, so we don't fully specify them here.  */
-+
-+typedef struct
-+{
-+  uint32_t a_type;		/* Entry type */
-+  union
-+    {
-+      uint32_t a_val;		/* Integer value */
-+      /* We use to have pointer elements added here.  We cannot do that,
-+	 though, since it does not work when using 32-bit definitions
-+	 on 64-bit platforms and vice versa.  */
-+    } a_un;
-+} Elf32_auxv_t;
-+
-+typedef struct
-+{
-+  uint64_t a_type;		/* Entry type */
-+  union
-+    {
-+      uint64_t a_val;		/* Integer value */
-+      /* We use to have pointer elements added here.  We cannot do that,
-+	 though, since it does not work when using 32-bit definitions
-+	 on 64-bit platforms and vice versa.  */
-+    } a_un;
-+} Elf64_auxv_t;
-+
-+/* Legal values for a_type (entry type).  */
-+
-+#define AT_NULL		0		/* End of vector */
-+#define AT_IGNORE	1		/* Entry should be ignored */
-+#define AT_EXECFD	2		/* File descriptor of program */
-+#define AT_PHDR		3		/* Program headers for program */
-+#define AT_PHENT	4		/* Size of program header entry */
-+#define AT_PHNUM	5		/* Number of program headers */
-+#define AT_PAGESZ	6		/* System page size */
-+#define AT_BASE		7		/* Base address of interpreter */
-+#define AT_FLAGS	8		/* Flags */
-+#define AT_ENTRY	9		/* Entry point of program */
-+#define AT_NOTELF	10		/* Program is not ELF */
-+#define AT_UID		11		/* Real uid */
-+#define AT_EUID		12		/* Effective uid */
-+#define AT_GID		13		/* Real gid */
-+#define AT_EGID		14		/* Effective gid */
-+#define AT_CLKTCK	17		/* Frequency of times() */
-+
-+/* Some more special a_type values describing the hardware.  */
-+#define AT_PLATFORM	15		/* String identifying platform.  */
-+#define AT_HWCAP	16		/* Machine dependent hints about
-+					   processor capabilities.  */
-+
-+/* This entry gives some information about the FPU initialization
-+   performed by the kernel.  */
-+#define AT_FPUCW	18		/* Used FPU control word.  */
-+
-+/* Cache block sizes.  */
-+#define AT_DCACHEBSIZE	19		/* Data cache block size.  */
-+#define AT_ICACHEBSIZE	20		/* Instruction cache block size.  */
-+#define AT_UCACHEBSIZE	21		/* Unified cache block size.  */
-+
-+/* A special ignored value for PPC, used by the kernel to control the
-+   interpretation of the AUXV. Must be > 16.  */
-+#define AT_IGNOREPPC	22		/* Entry should be ignored.  */
-+
-+#define	AT_SECURE	23		/* Boolean, was exec setuid-like?  */
-+
-+#define AT_BASE_PLATFORM 24		/* String identifying real platforms.*/
-+
-+#define AT_RANDOM	25		/* Address of 16 random bytes.  */
-+
-+#define AT_EXECFN	31		/* Filename of executable.  */
-+
-+/* Pointer to the global system page used for system calls and other
-+   nice things.  */
-+#define AT_SYSINFO	32
-+#define AT_SYSINFO_EHDR	33
-+
-+/* Shapes of the caches.  Bits 0-3 contains associativity; bits 4-7 contains
-+   log2 of line size; mask those to get cache size.  */
-+#define AT_L1I_CACHESHAPE	34
-+#define AT_L1D_CACHESHAPE	35
-+#define AT_L2_CACHESHAPE	36
-+#define AT_L3_CACHESHAPE	37
-+
-+/* Note section contents.  Each entry in the note section begins with
-+   a header of a fixed form.  */
-+
-+typedef struct
-+{
-+  Elf32_Word n_namesz;			/* Length of the note's name.  */
-+  Elf32_Word n_descsz;			/* Length of the note's descriptor.  */
-+  Elf32_Word n_type;			/* Type of the note.  */
-+} Elf32_Nhdr;
-+
-+typedef struct
-+{
-+  Elf64_Word n_namesz;			/* Length of the note's name.  */
-+  Elf64_Word n_descsz;			/* Length of the note's descriptor.  */
-+  Elf64_Word n_type;			/* Type of the note.  */
-+} Elf64_Nhdr;
-+
-+/* Known names of notes.  */
-+
-+/* Solaris entries in the note section have this name.  */
-+#define ELF_NOTE_SOLARIS	"SUNW Solaris"
-+
-+/* Note entries for GNU systems have this name.  */
-+#define ELF_NOTE_GNU		"GNU"
-+
-+
-+/* Defined types of notes for Solaris.  */
-+
-+/* Value of descriptor (one word) is desired pagesize for the binary.  */
-+#define ELF_NOTE_PAGESIZE_HINT	1
-+
-+
-+/* Defined note types for GNU systems.  */
-+
-+/* ABI information.  The descriptor consists of words:
-+   word 0: OS descriptor
-+   word 1: major version of the ABI
-+   word 2: minor version of the ABI
-+   word 3: subminor version of the ABI
-+*/
-+#define NT_GNU_ABI_TAG	1
-+#define ELF_NOTE_ABI	NT_GNU_ABI_TAG /* Old name.  */
-+
-+/* Known OSes.  These values can appear in word 0 of an
-+   NT_GNU_ABI_TAG note section entry.  */
-+#define ELF_NOTE_OS_LINUX	0
-+#define ELF_NOTE_OS_GNU		1
-+#define ELF_NOTE_OS_SOLARIS2	2
-+#define ELF_NOTE_OS_FREEBSD	3
-+
-+/* Synthetic hwcap information.  The descriptor begins with two words:
-+   word 0: number of entries
-+   word 1: bitmask of enabled entries
-+   Then follow variable-length entries, one byte followed by a
-+   '\0'-terminated hwcap name string.  The byte gives the bit
-+   number to test if enabled, (1U << bit) & bitmask.  */
-+#define NT_GNU_HWCAP	2
-+
-+/* Build ID bits as generated by ld --build-id.
-+   The descriptor consists of any nonzero number of bytes.  */
-+#define NT_GNU_BUILD_ID	3
-+
-+/* Version note generated by GNU gold containing a version string.  */
-+#define NT_GNU_GOLD_VERSION	4
-+
-+
-+/* Move records.  */
-+typedef struct
-+{
-+  Elf32_Xword m_value;		/* Symbol value.  */
-+  Elf32_Word m_info;		/* Size and index.  */
-+  Elf32_Word m_poffset;		/* Symbol offset.  */
-+  Elf32_Half m_repeat;		/* Repeat count.  */
-+  Elf32_Half m_stride;		/* Stride info.  */
-+} Elf32_Move;
-+
-+typedef struct
-+{
-+  Elf64_Xword m_value;		/* Symbol value.  */
-+  Elf64_Xword m_info;		/* Size and index.  */
-+  Elf64_Xword m_poffset;	/* Symbol offset.  */
-+  Elf64_Half m_repeat;		/* Repeat count.  */
-+  Elf64_Half m_stride;		/* Stride info.  */
-+} Elf64_Move;
-+
-+/* Macro to construct move records.  */
-+#define ELF32_M_SYM(info)	((info) >> 8)
-+#define ELF32_M_SIZE(info)	((unsigned char) (info))
-+#define ELF32_M_INFO(sym, size)	(((sym) << 8) + (unsigned char) (size))
-+
-+#define ELF64_M_SYM(info)	ELF32_M_SYM (info)
-+#define ELF64_M_SIZE(info)	ELF32_M_SIZE (info)
-+#define ELF64_M_INFO(sym, size)	ELF32_M_INFO (sym, size)
-+
-+
-+/* Motorola 68k specific definitions.  */
-+
-+/* Values for Elf32_Ehdr.e_flags.  */
-+#define EF_CPU32	0x00810000
-+
-+/* m68k relocs.  */
-+
-+#define R_68K_NONE	0		/* No reloc */
-+#define R_68K_32	1		/* Direct 32 bit  */
-+#define R_68K_16	2		/* Direct 16 bit  */
-+#define R_68K_8		3		/* Direct 8 bit  */
-+#define R_68K_PC32	4		/* PC relative 32 bit */
-+#define R_68K_PC16	5		/* PC relative 16 bit */
-+#define R_68K_PC8	6		/* PC relative 8 bit */
-+#define R_68K_GOT32	7		/* 32 bit PC relative GOT entry */
-+#define R_68K_GOT16	8		/* 16 bit PC relative GOT entry */
-+#define R_68K_GOT8	9		/* 8 bit PC relative GOT entry */
-+#define R_68K_GOT32O	10		/* 32 bit GOT offset */
-+#define R_68K_GOT16O	11		/* 16 bit GOT offset */
-+#define R_68K_GOT8O	12		/* 8 bit GOT offset */
-+#define R_68K_PLT32	13		/* 32 bit PC relative PLT address */
-+#define R_68K_PLT16	14		/* 16 bit PC relative PLT address */
-+#define R_68K_PLT8	15		/* 8 bit PC relative PLT address */
-+#define R_68K_PLT32O	16		/* 32 bit PLT offset */
-+#define R_68K_PLT16O	17		/* 16 bit PLT offset */
-+#define R_68K_PLT8O	18		/* 8 bit PLT offset */
-+#define R_68K_COPY	19		/* Copy symbol at runtime */
-+#define R_68K_GLOB_DAT	20		/* Create GOT entry */
-+#define R_68K_JMP_SLOT	21		/* Create PLT entry */
-+#define R_68K_RELATIVE	22		/* Adjust by program base */
-+#define R_68K_TLS_GD32      25          /* 32 bit GOT offset for GD */
-+#define R_68K_TLS_GD16      26          /* 16 bit GOT offset for GD */
-+#define R_68K_TLS_GD8       27          /* 8 bit GOT offset for GD */
-+#define R_68K_TLS_LDM32     28          /* 32 bit GOT offset for LDM */
-+#define R_68K_TLS_LDM16     29          /* 16 bit GOT offset for LDM */
-+#define R_68K_TLS_LDM8      30          /* 8 bit GOT offset for LDM */
-+#define R_68K_TLS_LDO32     31          /* 32 bit module-relative offset */
-+#define R_68K_TLS_LDO16     32          /* 16 bit module-relative offset */
-+#define R_68K_TLS_LDO8      33          /* 8 bit module-relative offset */
-+#define R_68K_TLS_IE32      34          /* 32 bit GOT offset for IE */
-+#define R_68K_TLS_IE16      35          /* 16 bit GOT offset for IE */
-+#define R_68K_TLS_IE8       36          /* 8 bit GOT offset for IE */
-+#define R_68K_TLS_LE32      37          /* 32 bit offset relative to
-+					   static TLS block */
-+#define R_68K_TLS_LE16      38          /* 16 bit offset relative to
-+					   static TLS block */
-+#define R_68K_TLS_LE8       39          /* 8 bit offset relative to
-+					   static TLS block */
-+#define R_68K_TLS_DTPMOD32  40          /* 32 bit module number */
-+#define R_68K_TLS_DTPREL32  41          /* 32 bit module-relative offset */
-+#define R_68K_TLS_TPREL32   42          /* 32 bit TP-relative offset */
-+/* Keep this the last entry.  */
-+#define R_68K_NUM	43
-+
-+/* Intel 80386 specific definitions.  */
-+
-+/* i386 relocs.  */
-+
-+#define R_386_NONE	   0		/* No reloc */
-+#define R_386_32	   1		/* Direct 32 bit  */
-+#define R_386_PC32	   2		/* PC relative 32 bit */
-+#define R_386_GOT32	   3		/* 32 bit GOT entry */
-+#define R_386_PLT32	   4		/* 32 bit PLT address */
-+#define R_386_COPY	   5		/* Copy symbol at runtime */
-+#define R_386_GLOB_DAT	   6		/* Create GOT entry */
-+#define R_386_JMP_SLOT	   7		/* Create PLT entry */
-+#define R_386_RELATIVE	   8		/* Adjust by program base */
-+#define R_386_GOTOFF	   9		/* 32 bit offset to GOT */
-+#define R_386_GOTPC	   10		/* 32 bit PC relative offset to GOT */
-+#define R_386_32PLT	   11
-+#define R_386_TLS_TPOFF	   14		/* Offset in static TLS block */
-+#define R_386_TLS_IE	   15		/* Address of GOT entry for static TLS
-+					   block offset */
-+#define R_386_TLS_GOTIE	   16		/* GOT entry for static TLS block
-+					   offset */
-+#define R_386_TLS_LE	   17		/* Offset relative to static TLS
-+					   block */
-+#define R_386_TLS_GD	   18		/* Direct 32 bit for GNU version of
-+					   general dynamic thread local data */
-+#define R_386_TLS_LDM	   19		/* Direct 32 bit for GNU version of
-+					   local dynamic thread local data
-+					   in LE code */
-+#define R_386_16	   20
-+#define R_386_PC16	   21
-+#define R_386_8		   22
-+#define R_386_PC8	   23
-+#define R_386_TLS_GD_32	   24		/* Direct 32 bit for general dynamic
-+					   thread local data */
-+#define R_386_TLS_GD_PUSH  25		/* Tag for pushl in GD TLS code */
-+#define R_386_TLS_GD_CALL  26		/* Relocation for call to
-+					   __tls_get_addr() */
-+#define R_386_TLS_GD_POP   27		/* Tag for popl in GD TLS code */
-+#define R_386_TLS_LDM_32   28		/* Direct 32 bit for local dynamic
-+					   thread local data in LE code */
-+#define R_386_TLS_LDM_PUSH 29		/* Tag for pushl in LDM TLS code */
-+#define R_386_TLS_LDM_CALL 30		/* Relocation for call to
-+					   __tls_get_addr() in LDM code */
-+#define R_386_TLS_LDM_POP  31		/* Tag for popl in LDM TLS code */
-+#define R_386_TLS_LDO_32   32		/* Offset relative to TLS block */
-+#define R_386_TLS_IE_32	   33		/* GOT entry for negated static TLS
-+					   block offset */
-+#define R_386_TLS_LE_32	   34		/* Negated offset relative to static
-+					   TLS block */
-+#define R_386_TLS_DTPMOD32 35		/* ID of module containing symbol */
-+#define R_386_TLS_DTPOFF32 36		/* Offset in TLS block */
-+#define R_386_TLS_TPOFF32  37		/* Negated offset in static TLS block */
-+/* 38? */
-+#define R_386_TLS_GOTDESC  39		/* GOT offset for TLS descriptor.  */
-+#define R_386_TLS_DESC_CALL 40		/* Marker of call through TLS
-+					   descriptor for
-+					   relaxation.  */
-+#define R_386_TLS_DESC     41		/* TLS descriptor containing
-+					   pointer to code and to
-+					   argument, returning the TLS
-+					   offset for the symbol.  */
-+#define R_386_IRELATIVE	   42		/* Adjust indirectly by program base */
-+/* Keep this the last entry.  */
-+#define R_386_NUM	   43
-+
-+/* SUN SPARC specific definitions.  */
-+
-+/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
-+
-+#define STT_SPARC_REGISTER	13	/* Global register reserved to app. */
-+
-+/* Values for Elf64_Ehdr.e_flags.  */
-+
-+#define EF_SPARCV9_MM		3
-+#define EF_SPARCV9_TSO		0
-+#define EF_SPARCV9_PSO		1
-+#define EF_SPARCV9_RMO		2
-+#define EF_SPARC_LEDATA		0x800000 /* little endian data */
-+#define EF_SPARC_EXT_MASK	0xFFFF00
-+#define EF_SPARC_32PLUS		0x000100 /* generic V8+ features */
-+#define EF_SPARC_SUN_US1	0x000200 /* Sun UltraSPARC1 extensions */
-+#define EF_SPARC_HAL_R1		0x000400 /* HAL R1 extensions */
-+#define EF_SPARC_SUN_US3	0x000800 /* Sun UltraSPARCIII extensions */
-+
-+/* SPARC relocs.  */
-+
-+#define R_SPARC_NONE		0	/* No reloc */
-+#define R_SPARC_8		1	/* Direct 8 bit */
-+#define R_SPARC_16		2	/* Direct 16 bit */
-+#define R_SPARC_32		3	/* Direct 32 bit */
-+#define R_SPARC_DISP8		4	/* PC relative 8 bit */
-+#define R_SPARC_DISP16		5	/* PC relative 16 bit */
-+#define R_SPARC_DISP32		6	/* PC relative 32 bit */
-+#define R_SPARC_WDISP30		7	/* PC relative 30 bit shifted */
-+#define R_SPARC_WDISP22		8	/* PC relative 22 bit shifted */
-+#define R_SPARC_HI22		9	/* High 22 bit */
-+#define R_SPARC_22		10	/* Direct 22 bit */
-+#define R_SPARC_13		11	/* Direct 13 bit */
-+#define R_SPARC_LO10		12	/* Truncated 10 bit */
-+#define R_SPARC_GOT10		13	/* Truncated 10 bit GOT entry */
-+#define R_SPARC_GOT13		14	/* 13 bit GOT entry */
-+#define R_SPARC_GOT22		15	/* 22 bit GOT entry shifted */
-+#define R_SPARC_PC10		16	/* PC relative 10 bit truncated */
-+#define R_SPARC_PC22		17	/* PC relative 22 bit shifted */
-+#define R_SPARC_WPLT30		18	/* 30 bit PC relative PLT address */
-+#define R_SPARC_COPY		19	/* Copy symbol at runtime */
-+#define R_SPARC_GLOB_DAT	20	/* Create GOT entry */
-+#define R_SPARC_JMP_SLOT	21	/* Create PLT entry */
-+#define R_SPARC_RELATIVE	22	/* Adjust by program base */
-+#define R_SPARC_UA32		23	/* Direct 32 bit unaligned */
-+
-+/* Additional Sparc64 relocs.  */
-+
-+#define R_SPARC_PLT32		24	/* Direct 32 bit ref to PLT entry */
-+#define R_SPARC_HIPLT22		25	/* High 22 bit PLT entry */
-+#define R_SPARC_LOPLT10		26	/* Truncated 10 bit PLT entry */
-+#define R_SPARC_PCPLT32		27	/* PC rel 32 bit ref to PLT entry */
-+#define R_SPARC_PCPLT22		28	/* PC rel high 22 bit PLT entry */
-+#define R_SPARC_PCPLT10		29	/* PC rel trunc 10 bit PLT entry */
-+#define R_SPARC_10		30	/* Direct 10 bit */
-+#define R_SPARC_11		31	/* Direct 11 bit */
-+#define R_SPARC_64		32	/* Direct 64 bit */
-+#define R_SPARC_OLO10		33	/* 10bit with secondary 13bit addend */
-+#define R_SPARC_HH22		34	/* Top 22 bits of direct 64 bit */
-+#define R_SPARC_HM10		35	/* High middle 10 bits of ... */
-+#define R_SPARC_LM22		36	/* Low middle 22 bits of ... */
-+#define R_SPARC_PC_HH22		37	/* Top 22 bits of pc rel 64 bit */
-+#define R_SPARC_PC_HM10		38	/* High middle 10 bit of ... */
-+#define R_SPARC_PC_LM22		39	/* Low miggle 22 bits of ... */
-+#define R_SPARC_WDISP16		40	/* PC relative 16 bit shifted */
-+#define R_SPARC_WDISP19		41	/* PC relative 19 bit shifted */
-+#define R_SPARC_GLOB_JMP	42	/* was part of v9 ABI but was removed */
-+#define R_SPARC_7		43	/* Direct 7 bit */
-+#define R_SPARC_5		44	/* Direct 5 bit */
-+#define R_SPARC_6		45	/* Direct 6 bit */
-+#define R_SPARC_DISP64		46	/* PC relative 64 bit */
-+#define R_SPARC_PLT64		47	/* Direct 64 bit ref to PLT entry */
-+#define R_SPARC_HIX22		48	/* High 22 bit complemented */
-+#define R_SPARC_LOX10		49	/* Truncated 11 bit complemented */
-+#define R_SPARC_H44		50	/* Direct high 12 of 44 bit */
-+#define R_SPARC_M44		51	/* Direct mid 22 of 44 bit */
-+#define R_SPARC_L44		52	/* Direct low 10 of 44 bit */
-+#define R_SPARC_REGISTER	53	/* Global register usage */
-+#define R_SPARC_UA64		54	/* Direct 64 bit unaligned */
-+#define R_SPARC_UA16		55	/* Direct 16 bit unaligned */
-+#define R_SPARC_TLS_GD_HI22	56
-+#define R_SPARC_TLS_GD_LO10	57
-+#define R_SPARC_TLS_GD_ADD	58
-+#define R_SPARC_TLS_GD_CALL	59
-+#define R_SPARC_TLS_LDM_HI22	60
-+#define R_SPARC_TLS_LDM_LO10	61
-+#define R_SPARC_TLS_LDM_ADD	62
-+#define R_SPARC_TLS_LDM_CALL	63
-+#define R_SPARC_TLS_LDO_HIX22	64
-+#define R_SPARC_TLS_LDO_LOX10	65
-+#define R_SPARC_TLS_LDO_ADD	66
-+#define R_SPARC_TLS_IE_HI22	67
-+#define R_SPARC_TLS_IE_LO10	68
-+#define R_SPARC_TLS_IE_LD	69
-+#define R_SPARC_TLS_IE_LDX	70
-+#define R_SPARC_TLS_IE_ADD	71
-+#define R_SPARC_TLS_LE_HIX22	72
-+#define R_SPARC_TLS_LE_LOX10	73
-+#define R_SPARC_TLS_DTPMOD32	74
-+#define R_SPARC_TLS_DTPMOD64	75
-+#define R_SPARC_TLS_DTPOFF32	76
-+#define R_SPARC_TLS_DTPOFF64	77
-+#define R_SPARC_TLS_TPOFF32	78
-+#define R_SPARC_TLS_TPOFF64	79
-+#define R_SPARC_GOTDATA_HIX22	80
-+#define R_SPARC_GOTDATA_LOX10	81
-+#define R_SPARC_GOTDATA_OP_HIX22	82
-+#define R_SPARC_GOTDATA_OP_LOX10	83
-+#define R_SPARC_GOTDATA_OP	84
-+#define R_SPARC_H34		85
-+#define R_SPARC_SIZE32		86
-+#define R_SPARC_SIZE64		87
-+#define R_SPARC_WDISP10		88
-+#define R_SPARC_JMP_IREL	248
-+#define R_SPARC_IRELATIVE	249
-+#define R_SPARC_GNU_VTINHERIT	250
-+#define R_SPARC_GNU_VTENTRY	251
-+#define R_SPARC_REV32		252
-+/* Keep this the last entry.  */
-+#define R_SPARC_NUM		253
-+
-+/* For Sparc64, legal values for d_tag of Elf64_Dyn.  */
-+
-+#define DT_SPARC_REGISTER 0x70000001
-+#define DT_SPARC_NUM	2
-+
-+/* MIPS R3000 specific definitions.  */
-+
-+/* Legal values for e_flags field of Elf32_Ehdr.  */
-+
-+#define EF_MIPS_NOREORDER   1		/* A .noreorder directive was used */
-+#define EF_MIPS_PIC	    2		/* Contains PIC code */
-+#define EF_MIPS_CPIC	    4		/* Uses PIC calling sequence */
-+#define EF_MIPS_XGOT	    8
-+#define EF_MIPS_64BIT_WHIRL 16
-+#define EF_MIPS_ABI2	    32
-+#define EF_MIPS_ABI_ON32    64
-+#define EF_MIPS_ARCH	    0xf0000000	/* MIPS architecture level */
-+
-+/* Legal values for MIPS architecture level.  */
-+
-+#define EF_MIPS_ARCH_1	    0x00000000	/* -mips1 code.  */
-+#define EF_MIPS_ARCH_2	    0x10000000	/* -mips2 code.  */
-+#define EF_MIPS_ARCH_3	    0x20000000	/* -mips3 code.  */
-+#define EF_MIPS_ARCH_4	    0x30000000	/* -mips4 code.  */
-+#define EF_MIPS_ARCH_5	    0x40000000	/* -mips5 code.  */
-+#define EF_MIPS_ARCH_32	    0x60000000	/* MIPS32 code.  */
-+#define EF_MIPS_ARCH_64	    0x70000000	/* MIPS64 code.  */
-+
-+/* The following are non-official names and should not be used.  */
-+
-+#define E_MIPS_ARCH_1	  0x00000000	/* -mips1 code.  */
-+#define E_MIPS_ARCH_2	  0x10000000	/* -mips2 code.  */
-+#define E_MIPS_ARCH_3	  0x20000000	/* -mips3 code.  */
-+#define E_MIPS_ARCH_4	  0x30000000	/* -mips4 code.  */
-+#define E_MIPS_ARCH_5	  0x40000000	/* -mips5 code.  */
-+#define E_MIPS_ARCH_32	  0x60000000	/* MIPS32 code.  */
-+#define E_MIPS_ARCH_64	  0x70000000	/* MIPS64 code.  */
-+
-+/* Special section indices.  */
-+
-+#define SHN_MIPS_ACOMMON    0xff00	/* Allocated common symbols */
-+#define SHN_MIPS_TEXT	    0xff01	/* Allocated test symbols.  */
-+#define SHN_MIPS_DATA	    0xff02	/* Allocated data symbols.  */
-+#define SHN_MIPS_SCOMMON    0xff03	/* Small common symbols */
-+#define SHN_MIPS_SUNDEFINED 0xff04	/* Small undefined symbols */
-+
-+/* Legal values for sh_type field of Elf32_Shdr.  */
-+
-+#define SHT_MIPS_LIBLIST       0x70000000 /* Shared objects used in link */
-+#define SHT_MIPS_MSYM	       0x70000001
-+#define SHT_MIPS_CONFLICT      0x70000002 /* Conflicting symbols */
-+#define SHT_MIPS_GPTAB	       0x70000003 /* Global data area sizes */
-+#define SHT_MIPS_UCODE	       0x70000004 /* Reserved for SGI/MIPS compilers */
-+#define SHT_MIPS_DEBUG	       0x70000005 /* MIPS ECOFF debugging information*/
-+#define SHT_MIPS_REGINFO       0x70000006 /* Register usage information */
-+#define SHT_MIPS_PACKAGE       0x70000007
-+#define SHT_MIPS_PACKSYM       0x70000008
-+#define SHT_MIPS_RELD	       0x70000009
-+#define SHT_MIPS_IFACE         0x7000000b
-+#define SHT_MIPS_CONTENT       0x7000000c
-+#define SHT_MIPS_OPTIONS       0x7000000d /* Miscellaneous options.  */
-+#define SHT_MIPS_SHDR	       0x70000010
-+#define SHT_MIPS_FDESC	       0x70000011
-+#define SHT_MIPS_EXTSYM	       0x70000012
-+#define SHT_MIPS_DENSE	       0x70000013
-+#define SHT_MIPS_PDESC	       0x70000014
-+#define SHT_MIPS_LOCSYM	       0x70000015
-+#define SHT_MIPS_AUXSYM	       0x70000016
-+#define SHT_MIPS_OPTSYM	       0x70000017
-+#define SHT_MIPS_LOCSTR	       0x70000018
-+#define SHT_MIPS_LINE	       0x70000019
-+#define SHT_MIPS_RFDESC	       0x7000001a
-+#define SHT_MIPS_DELTASYM      0x7000001b
-+#define SHT_MIPS_DELTAINST     0x7000001c
-+#define SHT_MIPS_DELTACLASS    0x7000001d
-+#define SHT_MIPS_DWARF         0x7000001e /* DWARF debugging information.  */
-+#define SHT_MIPS_DELTADECL     0x7000001f
-+#define SHT_MIPS_SYMBOL_LIB    0x70000020
-+#define SHT_MIPS_EVENTS	       0x70000021 /* Event section.  */
-+#define SHT_MIPS_TRANSLATE     0x70000022
-+#define SHT_MIPS_PIXIE	       0x70000023
-+#define SHT_MIPS_XLATE	       0x70000024
-+#define SHT_MIPS_XLATE_DEBUG   0x70000025
-+#define SHT_MIPS_WHIRL	       0x70000026
-+#define SHT_MIPS_EH_REGION     0x70000027
-+#define SHT_MIPS_XLATE_OLD     0x70000028
-+#define SHT_MIPS_PDR_EXCEPTION 0x70000029
-+
-+/* Legal values for sh_flags field of Elf32_Shdr.  */
-+
-+#define SHF_MIPS_GPREL	 0x10000000	/* Must be part of global data area */
-+#define SHF_MIPS_MERGE	 0x20000000
-+#define SHF_MIPS_ADDR	 0x40000000
-+#define SHF_MIPS_STRINGS 0x80000000
-+#define SHF_MIPS_NOSTRIP 0x08000000
-+#define SHF_MIPS_LOCAL	 0x04000000
-+#define SHF_MIPS_NAMES	 0x02000000
-+#define SHF_MIPS_NODUPE	 0x01000000
-+
-+
-+/* Symbol tables.  */
-+
-+/* MIPS specific values for `st_other'.  */
-+#define STO_MIPS_DEFAULT		0x0
-+#define STO_MIPS_INTERNAL		0x1
-+#define STO_MIPS_HIDDEN			0x2
-+#define STO_MIPS_PROTECTED		0x3
-+#define STO_MIPS_PLT			0x8
-+#define STO_MIPS_SC_ALIGN_UNUSED	0xff
-+
-+/* MIPS specific values for `st_info'.  */
-+#define STB_MIPS_SPLIT_COMMON		13
-+
-+/* Entries found in sections of type SHT_MIPS_GPTAB.  */
-+
-+typedef union
-+{
-+  struct
-+    {
-+      Elf32_Word gt_current_g_value;	/* -G value used for compilation */
-+      Elf32_Word gt_unused;		/* Not used */
-+    } gt_header;			/* First entry in section */
-+  struct
-+    {
-+      Elf32_Word gt_g_value;		/* If this value were used for -G */
-+      Elf32_Word gt_bytes;		/* This many bytes would be used */
-+    } gt_entry;				/* Subsequent entries in section */
-+} Elf32_gptab;
-+
-+/* Entry found in sections of type SHT_MIPS_REGINFO.  */
-+
-+typedef struct
-+{
-+  Elf32_Word	ri_gprmask;		/* General registers used */
-+  Elf32_Word	ri_cprmask[4];		/* Coprocessor registers used */
-+  Elf32_Sword	ri_gp_value;		/* $gp register value */
-+} Elf32_RegInfo;
-+
-+/* Entries found in sections of type SHT_MIPS_OPTIONS.  */
-+
-+typedef struct
-+{
-+  unsigned char kind;		/* Determines interpretation of the
-+				   variable part of descriptor.  */
-+  unsigned char size;		/* Size of descriptor, including header.  */
-+  Elf32_Section section;	/* Section header index of section affected,
-+				   0 for global options.  */
-+  Elf32_Word info;		/* Kind-specific information.  */
-+} Elf_Options;
-+
-+/* Values for `kind' field in Elf_Options.  */
-+
-+#define ODK_NULL	0	/* Undefined.  */
-+#define ODK_REGINFO	1	/* Register usage information.  */
-+#define ODK_EXCEPTIONS	2	/* Exception processing options.  */
-+#define ODK_PAD		3	/* Section padding options.  */
-+#define ODK_HWPATCH	4	/* Hardware workarounds performed */
-+#define ODK_FILL	5	/* record the fill value used by the linker. */
-+#define ODK_TAGS	6	/* reserve space for desktop tools to write. */
-+#define ODK_HWAND	7	/* HW workarounds.  'AND' bits when merging. */
-+#define ODK_HWOR	8	/* HW workarounds.  'OR' bits when merging.  */
-+
-+/* Values for `info' in Elf_Options for ODK_EXCEPTIONS entries.  */
-+
-+#define OEX_FPU_MIN	0x1f	/* FPE's which MUST be enabled.  */
-+#define OEX_FPU_MAX	0x1f00	/* FPE's which MAY be enabled.  */
-+#define OEX_PAGE0	0x10000	/* page zero must be mapped.  */
-+#define OEX_SMM		0x20000	/* Force sequential memory mode?  */
-+#define OEX_FPDBUG	0x40000	/* Force floating point debug mode?  */
-+#define OEX_PRECISEFP	OEX_FPDBUG
-+#define OEX_DISMISS	0x80000	/* Dismiss invalid address faults?  */
-+
-+#define OEX_FPU_INVAL	0x10
-+#define OEX_FPU_DIV0	0x08
-+#define OEX_FPU_OFLO	0x04
-+#define OEX_FPU_UFLO	0x02
-+#define OEX_FPU_INEX	0x01
-+
-+/* Masks for `info' in Elf_Options for an ODK_HWPATCH entry.  */
-+
-+#define OHW_R4KEOP	0x1	/* R4000 end-of-page patch.  */
-+#define OHW_R8KPFETCH	0x2	/* may need R8000 prefetch patch.  */
-+#define OHW_R5KEOP	0x4	/* R5000 end-of-page patch.  */
-+#define OHW_R5KCVTL	0x8	/* R5000 cvt.[ds].l bug.  clean=1.  */
-+
-+#define OPAD_PREFIX	0x1
-+#define OPAD_POSTFIX	0x2
-+#define OPAD_SYMBOL	0x4
-+
-+/* Entry found in `.options' section.  */
-+
-+typedef struct
-+{
-+  Elf32_Word hwp_flags1;	/* Extra flags.  */
-+  Elf32_Word hwp_flags2;	/* Extra flags.  */
-+} Elf_Options_Hw;
-+
-+/* Masks for `info' in ElfOptions for ODK_HWAND and ODK_HWOR entries.  */
-+
-+#define OHWA0_R4KEOP_CHECKED	0x00000001
-+#define OHWA1_R4KEOP_CLEAN	0x00000002
-+
-+/* MIPS relocs.  */
-+
-+#define R_MIPS_NONE		0	/* No reloc */
-+#define R_MIPS_16		1	/* Direct 16 bit */
-+#define R_MIPS_32		2	/* Direct 32 bit */
-+#define R_MIPS_REL32		3	/* PC relative 32 bit */
-+#define R_MIPS_26		4	/* Direct 26 bit shifted */
-+#define R_MIPS_HI16		5	/* High 16 bit */
-+#define R_MIPS_LO16		6	/* Low 16 bit */
-+#define R_MIPS_GPREL16		7	/* GP relative 16 bit */
-+#define R_MIPS_LITERAL		8	/* 16 bit literal entry */
-+#define R_MIPS_GOT16		9	/* 16 bit GOT entry */
-+#define R_MIPS_PC16		10	/* PC relative 16 bit */
-+#define R_MIPS_CALL16		11	/* 16 bit GOT entry for function */
-+#define R_MIPS_GPREL32		12	/* GP relative 32 bit */
-+
-+#define R_MIPS_SHIFT5		16
-+#define R_MIPS_SHIFT6		17
-+#define R_MIPS_64		18
-+#define R_MIPS_GOT_DISP		19
-+#define R_MIPS_GOT_PAGE		20
-+#define R_MIPS_GOT_OFST		21
-+#define R_MIPS_GOT_HI16		22
-+#define R_MIPS_GOT_LO16		23
-+#define R_MIPS_SUB		24
-+#define R_MIPS_INSERT_A		25
-+#define R_MIPS_INSERT_B		26
-+#define R_MIPS_DELETE		27
-+#define R_MIPS_HIGHER		28
-+#define R_MIPS_HIGHEST		29
-+#define R_MIPS_CALL_HI16	30
-+#define R_MIPS_CALL_LO16	31
-+#define R_MIPS_SCN_DISP		32
-+#define R_MIPS_REL16		33
-+#define R_MIPS_ADD_IMMEDIATE	34
-+#define R_MIPS_PJUMP		35
-+#define R_MIPS_RELGOT		36
-+#define R_MIPS_JALR		37
-+#define R_MIPS_TLS_DTPMOD32	38	/* Module number 32 bit */
-+#define R_MIPS_TLS_DTPREL32	39	/* Module-relative offset 32 bit */
-+#define R_MIPS_TLS_DTPMOD64	40	/* Module number 64 bit */
-+#define R_MIPS_TLS_DTPREL64	41	/* Module-relative offset 64 bit */
-+#define R_MIPS_TLS_GD		42	/* 16 bit GOT offset for GD */
-+#define R_MIPS_TLS_LDM		43	/* 16 bit GOT offset for LDM */
-+#define R_MIPS_TLS_DTPREL_HI16	44	/* Module-relative offset, high 16 bits */
-+#define R_MIPS_TLS_DTPREL_LO16	45	/* Module-relative offset, low 16 bits */
-+#define R_MIPS_TLS_GOTTPREL	46	/* 16 bit GOT offset for IE */
-+#define R_MIPS_TLS_TPREL32	47	/* TP-relative offset, 32 bit */
-+#define R_MIPS_TLS_TPREL64	48	/* TP-relative offset, 64 bit */
-+#define R_MIPS_TLS_TPREL_HI16	49	/* TP-relative offset, high 16 bits */
-+#define R_MIPS_TLS_TPREL_LO16	50	/* TP-relative offset, low 16 bits */
-+#define R_MIPS_GLOB_DAT		51
-+#define R_MIPS_COPY		126
-+#define R_MIPS_JUMP_SLOT        127
-+/* Keep this the last entry.  */
-+#define R_MIPS_NUM		128
-+
-+/* Legal values for p_type field of Elf32_Phdr.  */
-+
-+#define PT_MIPS_REGINFO	0x70000000	/* Register usage information */
-+#define PT_MIPS_RTPROC  0x70000001	/* Runtime procedure table. */
-+#define PT_MIPS_OPTIONS 0x70000002
-+
-+/* Special program header types.  */
-+
-+#define PF_MIPS_LOCAL	0x10000000
-+
-+/* Legal values for d_tag field of Elf32_Dyn.  */
-+
-+#define DT_MIPS_RLD_VERSION  0x70000001	/* Runtime linker interface version */
-+#define DT_MIPS_TIME_STAMP   0x70000002	/* Timestamp */
-+#define DT_MIPS_ICHECKSUM    0x70000003	/* Checksum */
-+#define DT_MIPS_IVERSION     0x70000004	/* Version string (string tbl index) */
-+#define DT_MIPS_FLAGS	     0x70000005	/* Flags */
-+#define DT_MIPS_BASE_ADDRESS 0x70000006	/* Base address */
-+#define DT_MIPS_MSYM	     0x70000007
-+#define DT_MIPS_CONFLICT     0x70000008	/* Address of CONFLICT section */
-+#define DT_MIPS_LIBLIST	     0x70000009	/* Address of LIBLIST section */
-+#define DT_MIPS_LOCAL_GOTNO  0x7000000a	/* Number of local GOT entries */
-+#define DT_MIPS_CONFLICTNO   0x7000000b	/* Number of CONFLICT entries */
-+#define DT_MIPS_LIBLISTNO    0x70000010	/* Number of LIBLIST entries */
-+#define DT_MIPS_SYMTABNO     0x70000011	/* Number of DYNSYM entries */
-+#define DT_MIPS_UNREFEXTNO   0x70000012	/* First external DYNSYM */
-+#define DT_MIPS_GOTSYM	     0x70000013	/* First GOT entry in DYNSYM */
-+#define DT_MIPS_HIPAGENO     0x70000014	/* Number of GOT page table entries */
-+#define DT_MIPS_RLD_MAP	     0x70000016	/* Address of run time loader map.  */
-+#define DT_MIPS_DELTA_CLASS  0x70000017	/* Delta C++ class definition.  */
-+#define DT_MIPS_DELTA_CLASS_NO    0x70000018 /* Number of entries in
-+						DT_MIPS_DELTA_CLASS.  */
-+#define DT_MIPS_DELTA_INSTANCE    0x70000019 /* Delta C++ class instances.  */
-+#define DT_MIPS_DELTA_INSTANCE_NO 0x7000001a /* Number of entries in
-+						DT_MIPS_DELTA_INSTANCE.  */
-+#define DT_MIPS_DELTA_RELOC  0x7000001b /* Delta relocations.  */
-+#define DT_MIPS_DELTA_RELOC_NO 0x7000001c /* Number of entries in
-+					     DT_MIPS_DELTA_RELOC.  */
-+#define DT_MIPS_DELTA_SYM    0x7000001d /* Delta symbols that Delta
-+					   relocations refer to.  */
-+#define DT_MIPS_DELTA_SYM_NO 0x7000001e /* Number of entries in
-+					   DT_MIPS_DELTA_SYM.  */
-+#define DT_MIPS_DELTA_CLASSSYM 0x70000020 /* Delta symbols that hold the
-+					     class declaration.  */
-+#define DT_MIPS_DELTA_CLASSSYM_NO 0x70000021 /* Number of entries in
-+						DT_MIPS_DELTA_CLASSSYM.  */
-+#define DT_MIPS_CXX_FLAGS    0x70000022 /* Flags indicating for C++ flavor.  */
-+#define DT_MIPS_PIXIE_INIT   0x70000023
-+#define DT_MIPS_SYMBOL_LIB   0x70000024
-+#define DT_MIPS_LOCALPAGE_GOTIDX 0x70000025
-+#define DT_MIPS_LOCAL_GOTIDX 0x70000026
-+#define DT_MIPS_HIDDEN_GOTIDX 0x70000027
-+#define DT_MIPS_PROTECTED_GOTIDX 0x70000028
-+#define DT_MIPS_OPTIONS	     0x70000029 /* Address of .options.  */
-+#define DT_MIPS_INTERFACE    0x7000002a /* Address of .interface.  */
-+#define DT_MIPS_DYNSTR_ALIGN 0x7000002b
-+#define DT_MIPS_INTERFACE_SIZE 0x7000002c /* Size of the .interface section. */
-+#define DT_MIPS_RLD_TEXT_RESOLVE_ADDR 0x7000002d /* Address of rld_text_rsolve
-+						    function stored in GOT.  */
-+#define DT_MIPS_PERF_SUFFIX  0x7000002e /* Default suffix of dso to be added
-+					   by rld on dlopen() calls.  */
-+#define DT_MIPS_COMPACT_SIZE 0x7000002f /* (O32)Size of compact rel section. */
-+#define DT_MIPS_GP_VALUE     0x70000030 /* GP value for aux GOTs.  */
-+#define DT_MIPS_AUX_DYNAMIC  0x70000031 /* Address of aux .dynamic.  */
-+/* The address of .got.plt in an executable using the new non-PIC ABI.  */
-+#define DT_MIPS_PLTGOT	     0x70000032
-+/* The base of the PLT in an executable using the new non-PIC ABI if that
-+   PLT is writable.  For a non-writable PLT, this is omitted or has a zero
-+   value.  */
-+#define DT_MIPS_RWPLT        0x70000034
-+#define DT_MIPS_NUM	     0x35
-+
-+/* Legal values for DT_MIPS_FLAGS Elf32_Dyn entry.  */
-+
-+#define RHF_NONE		   0		/* No flags */
-+#define RHF_QUICKSTART		   (1 << 0)	/* Use quickstart */
-+#define RHF_NOTPOT		   (1 << 1)	/* Hash size not power of 2 */
-+#define RHF_NO_LIBRARY_REPLACEMENT (1 << 2)	/* Ignore LD_LIBRARY_PATH */
-+#define RHF_NO_MOVE		   (1 << 3)
-+#define RHF_SGI_ONLY		   (1 << 4)
-+#define RHF_GUARANTEE_INIT	   (1 << 5)
-+#define RHF_DELTA_C_PLUS_PLUS	   (1 << 6)
-+#define RHF_GUARANTEE_START_INIT   (1 << 7)
-+#define RHF_PIXIE		   (1 << 8)
-+#define RHF_DEFAULT_DELAY_LOAD	   (1 << 9)
-+#define RHF_REQUICKSTART	   (1 << 10)
-+#define RHF_REQUICKSTARTED	   (1 << 11)
-+#define RHF_CORD		   (1 << 12)
-+#define RHF_NO_UNRES_UNDEF	   (1 << 13)
-+#define RHF_RLD_ORDER_SAFE	   (1 << 14)
-+
-+/* Entries found in sections of type SHT_MIPS_LIBLIST.  */
-+
-+typedef struct
-+{
-+  Elf32_Word l_name;		/* Name (string table index) */
-+  Elf32_Word l_time_stamp;	/* Timestamp */
-+  Elf32_Word l_checksum;	/* Checksum */
-+  Elf32_Word l_version;		/* Interface version */
-+  Elf32_Word l_flags;		/* Flags */
-+} Elf32_Lib;
-+
-+typedef struct
-+{
-+  Elf64_Word l_name;		/* Name (string table index) */
-+  Elf64_Word l_time_stamp;	/* Timestamp */
-+  Elf64_Word l_checksum;	/* Checksum */
-+  Elf64_Word l_version;		/* Interface version */
-+  Elf64_Word l_flags;		/* Flags */
-+} Elf64_Lib;
-+
-+
-+/* Legal values for l_flags.  */
-+
-+#define LL_NONE		  0
-+#define LL_EXACT_MATCH	  (1 << 0)	/* Require exact match */
-+#define LL_IGNORE_INT_VER (1 << 1)	/* Ignore interface version */
-+#define LL_REQUIRE_MINOR  (1 << 2)
-+#define LL_EXPORTS	  (1 << 3)
-+#define LL_DELAY_LOAD	  (1 << 4)
-+#define LL_DELTA	  (1 << 5)
-+
-+/* Entries found in sections of type SHT_MIPS_CONFLICT.  */
-+
-+typedef Elf32_Addr Elf32_Conflict;
-+
-+
-+/* HPPA specific definitions.  */
-+
-+/* Legal values for e_flags field of Elf32_Ehdr.  */
-+
-+#define EF_PARISC_TRAPNIL	0x00010000 /* Trap nil pointer dereference.  */
-+#define EF_PARISC_EXT		0x00020000 /* Program uses arch. extensions. */
-+#define EF_PARISC_LSB		0x00040000 /* Program expects little endian. */
-+#define EF_PARISC_WIDE		0x00080000 /* Program expects wide mode.  */
-+#define EF_PARISC_NO_KABP	0x00100000 /* No kernel assisted branch
-+					      prediction.  */
-+#define EF_PARISC_LAZYSWAP	0x00400000 /* Allow lazy swapping.  */
-+#define EF_PARISC_ARCH		0x0000ffff /* Architecture version.  */
-+
-+/* Defined values for `e_flags & EF_PARISC_ARCH' are:  */
-+
-+#define EFA_PARISC_1_0		    0x020b /* PA-RISC 1.0 big-endian.  */
-+#define EFA_PARISC_1_1		    0x0210 /* PA-RISC 1.1 big-endian.  */
-+#define EFA_PARISC_2_0		    0x0214 /* PA-RISC 2.0 big-endian.  */
-+
-+/* Additional section indeces.  */
-+
-+#define SHN_PARISC_ANSI_COMMON	0xff00	   /* Section for tenatively declared
-+					      symbols in ANSI C.  */
-+#define SHN_PARISC_HUGE_COMMON	0xff01	   /* Common blocks in huge model.  */
-+
-+/* Legal values for sh_type field of Elf32_Shdr.  */
-+
-+#define SHT_PARISC_EXT		0x70000000 /* Contains product specific ext. */
-+#define SHT_PARISC_UNWIND	0x70000001 /* Unwind information.  */
-+#define SHT_PARISC_DOC		0x70000002 /* Debug info for optimized code. */
-+
-+/* Legal values for sh_flags field of Elf32_Shdr.  */
-+
-+#define SHF_PARISC_SHORT	0x20000000 /* Section with short addressing. */
-+#define SHF_PARISC_HUGE		0x40000000 /* Section far from gp.  */
-+#define SHF_PARISC_SBP		0x80000000 /* Static branch prediction code. */
-+
-+/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
-+
-+#define STT_PARISC_MILLICODE	13	/* Millicode function entry point.  */
-+
-+#define STT_HP_OPAQUE		(STT_LOOS + 0x1)
-+#define STT_HP_STUB		(STT_LOOS + 0x2)
-+
-+/* HPPA relocs.  */
-+
-+#define R_PARISC_NONE		0	/* No reloc.  */
-+#define R_PARISC_DIR32		1	/* Direct 32-bit reference.  */
-+#define R_PARISC_DIR21L		2	/* Left 21 bits of eff. address.  */
-+#define R_PARISC_DIR17R		3	/* Right 17 bits of eff. address.  */
-+#define R_PARISC_DIR17F		4	/* 17 bits of eff. address.  */
-+#define R_PARISC_DIR14R		6	/* Right 14 bits of eff. address.  */
-+#define R_PARISC_PCREL32	9	/* 32-bit rel. address.  */
-+#define R_PARISC_PCREL21L	10	/* Left 21 bits of rel. address.  */
-+#define R_PARISC_PCREL17R	11	/* Right 17 bits of rel. address.  */
-+#define R_PARISC_PCREL17F	12	/* 17 bits of rel. address.  */
-+#define R_PARISC_PCREL14R	14	/* Right 14 bits of rel. address.  */
-+#define R_PARISC_DPREL21L	18	/* Left 21 bits of rel. address.  */
-+#define R_PARISC_DPREL14R	22	/* Right 14 bits of rel. address.  */
-+#define R_PARISC_GPREL21L	26	/* GP-relative, left 21 bits.  */
-+#define R_PARISC_GPREL14R	30	/* GP-relative, right 14 bits.  */
-+#define R_PARISC_LTOFF21L	34	/* LT-relative, left 21 bits.  */
-+#define R_PARISC_LTOFF14R	38	/* LT-relative, right 14 bits.  */
-+#define R_PARISC_SECREL32	41	/* 32 bits section rel. address.  */
-+#define R_PARISC_SEGBASE	48	/* No relocation, set segment base.  */
-+#define R_PARISC_SEGREL32	49	/* 32 bits segment rel. address.  */
-+#define R_PARISC_PLTOFF21L	50	/* PLT rel. address, left 21 bits.  */
-+#define R_PARISC_PLTOFF14R	54	/* PLT rel. address, right 14 bits.  */
-+#define R_PARISC_LTOFF_FPTR32	57	/* 32 bits LT-rel. function pointer. */
-+#define R_PARISC_LTOFF_FPTR21L	58	/* LT-rel. fct ptr, left 21 bits. */
-+#define R_PARISC_LTOFF_FPTR14R	62	/* LT-rel. fct ptr, right 14 bits. */
-+#define R_PARISC_FPTR64		64	/* 64 bits function address.  */
-+#define R_PARISC_PLABEL32	65	/* 32 bits function address.  */
-+#define R_PARISC_PLABEL21L	66	/* Left 21 bits of fdesc address.  */
-+#define R_PARISC_PLABEL14R	70	/* Right 14 bits of fdesc address.  */
-+#define R_PARISC_PCREL64	72	/* 64 bits PC-rel. address.  */
-+#define R_PARISC_PCREL22F	74	/* 22 bits PC-rel. address.  */
-+#define R_PARISC_PCREL14WR	75	/* PC-rel. address, right 14 bits.  */
-+#define R_PARISC_PCREL14DR	76	/* PC rel. address, right 14 bits.  */
-+#define R_PARISC_PCREL16F	77	/* 16 bits PC-rel. address.  */
-+#define R_PARISC_PCREL16WF	78	/* 16 bits PC-rel. address.  */
-+#define R_PARISC_PCREL16DF	79	/* 16 bits PC-rel. address.  */
-+#define R_PARISC_DIR64		80	/* 64 bits of eff. address.  */
-+#define R_PARISC_DIR14WR	83	/* 14 bits of eff. address.  */
-+#define R_PARISC_DIR14DR	84	/* 14 bits of eff. address.  */
-+#define R_PARISC_DIR16F		85	/* 16 bits of eff. address.  */
-+#define R_PARISC_DIR16WF	86	/* 16 bits of eff. address.  */
-+#define R_PARISC_DIR16DF	87	/* 16 bits of eff. address.  */
-+#define R_PARISC_GPREL64	88	/* 64 bits of GP-rel. address.  */
-+#define R_PARISC_GPREL14WR	91	/* GP-rel. address, right 14 bits.  */
-+#define R_PARISC_GPREL14DR	92	/* GP-rel. address, right 14 bits.  */
-+#define R_PARISC_GPREL16F	93	/* 16 bits GP-rel. address.  */
-+#define R_PARISC_GPREL16WF	94	/* 16 bits GP-rel. address.  */
-+#define R_PARISC_GPREL16DF	95	/* 16 bits GP-rel. address.  */
-+#define R_PARISC_LTOFF64	96	/* 64 bits LT-rel. address.  */
-+#define R_PARISC_LTOFF14WR	99	/* LT-rel. address, right 14 bits.  */
-+#define R_PARISC_LTOFF14DR	100	/* LT-rel. address, right 14 bits.  */
-+#define R_PARISC_LTOFF16F	101	/* 16 bits LT-rel. address.  */
-+#define R_PARISC_LTOFF16WF	102	/* 16 bits LT-rel. address.  */
-+#define R_PARISC_LTOFF16DF	103	/* 16 bits LT-rel. address.  */
-+#define R_PARISC_SECREL64	104	/* 64 bits section rel. address.  */
-+#define R_PARISC_SEGREL64	112	/* 64 bits segment rel. address.  */
-+#define R_PARISC_PLTOFF14WR	115	/* PLT-rel. address, right 14 bits.  */
-+#define R_PARISC_PLTOFF14DR	116	/* PLT-rel. address, right 14 bits.  */
-+#define R_PARISC_PLTOFF16F	117	/* 16 bits LT-rel. address.  */
-+#define R_PARISC_PLTOFF16WF	118	/* 16 bits PLT-rel. address.  */
-+#define R_PARISC_PLTOFF16DF	119	/* 16 bits PLT-rel. address.  */
-+#define R_PARISC_LTOFF_FPTR64	120	/* 64 bits LT-rel. function ptr.  */
-+#define R_PARISC_LTOFF_FPTR14WR	123	/* LT-rel. fct. ptr., right 14 bits. */
-+#define R_PARISC_LTOFF_FPTR14DR	124	/* LT-rel. fct. ptr., right 14 bits. */
-+#define R_PARISC_LTOFF_FPTR16F	125	/* 16 bits LT-rel. function ptr.  */
-+#define R_PARISC_LTOFF_FPTR16WF	126	/* 16 bits LT-rel. function ptr.  */
-+#define R_PARISC_LTOFF_FPTR16DF	127	/* 16 bits LT-rel. function ptr.  */
-+#define R_PARISC_LORESERVE	128
-+#define R_PARISC_COPY		128	/* Copy relocation.  */
-+#define R_PARISC_IPLT		129	/* Dynamic reloc, imported PLT */
-+#define R_PARISC_EPLT		130	/* Dynamic reloc, exported PLT */
-+#define R_PARISC_TPREL32	153	/* 32 bits TP-rel. address.  */
-+#define R_PARISC_TPREL21L	154	/* TP-rel. address, left 21 bits.  */
-+#define R_PARISC_TPREL14R	158	/* TP-rel. address, right 14 bits.  */
-+#define R_PARISC_LTOFF_TP21L	162	/* LT-TP-rel. address, left 21 bits. */
-+#define R_PARISC_LTOFF_TP14R	166	/* LT-TP-rel. address, right 14 bits.*/
-+#define R_PARISC_LTOFF_TP14F	167	/* 14 bits LT-TP-rel. address.  */
-+#define R_PARISC_TPREL64	216	/* 64 bits TP-rel. address.  */
-+#define R_PARISC_TPREL14WR	219	/* TP-rel. address, right 14 bits.  */
-+#define R_PARISC_TPREL14DR	220	/* TP-rel. address, right 14 bits.  */
-+#define R_PARISC_TPREL16F	221	/* 16 bits TP-rel. address.  */
-+#define R_PARISC_TPREL16WF	222	/* 16 bits TP-rel. address.  */
-+#define R_PARISC_TPREL16DF	223	/* 16 bits TP-rel. address.  */
-+#define R_PARISC_LTOFF_TP64	224	/* 64 bits LT-TP-rel. address.  */
-+#define R_PARISC_LTOFF_TP14WR	227	/* LT-TP-rel. address, right 14 bits.*/
-+#define R_PARISC_LTOFF_TP14DR	228	/* LT-TP-rel. address, right 14 bits.*/
-+#define R_PARISC_LTOFF_TP16F	229	/* 16 bits LT-TP-rel. address.  */
-+#define R_PARISC_LTOFF_TP16WF	230	/* 16 bits LT-TP-rel. address.  */
-+#define R_PARISC_LTOFF_TP16DF	231	/* 16 bits LT-TP-rel. address.  */
-+#define R_PARISC_GNU_VTENTRY	232
-+#define R_PARISC_GNU_VTINHERIT	233
-+#define R_PARISC_TLS_GD21L	234	/* GD 21-bit left.  */
-+#define R_PARISC_TLS_GD14R	235	/* GD 14-bit right.  */
-+#define R_PARISC_TLS_GDCALL	236	/* GD call to __t_g_a.  */
-+#define R_PARISC_TLS_LDM21L	237	/* LD module 21-bit left.  */
-+#define R_PARISC_TLS_LDM14R	238	/* LD module 14-bit right.  */
-+#define R_PARISC_TLS_LDMCALL	239	/* LD module call to __t_g_a.  */
-+#define R_PARISC_TLS_LDO21L	240	/* LD offset 21-bit left.  */
-+#define R_PARISC_TLS_LDO14R	241	/* LD offset 14-bit right.  */
-+#define R_PARISC_TLS_DTPMOD32	242	/* DTP module 32-bit.  */
-+#define R_PARISC_TLS_DTPMOD64	243	/* DTP module 64-bit.  */
-+#define R_PARISC_TLS_DTPOFF32	244	/* DTP offset 32-bit.  */
-+#define R_PARISC_TLS_DTPOFF64	245	/* DTP offset 32-bit.  */
-+#define R_PARISC_TLS_LE21L	R_PARISC_TPREL21L
-+#define R_PARISC_TLS_LE14R	R_PARISC_TPREL14R
-+#define R_PARISC_TLS_IE21L	R_PARISC_LTOFF_TP21L
-+#define R_PARISC_TLS_IE14R	R_PARISC_LTOFF_TP14R
-+#define R_PARISC_TLS_TPREL32	R_PARISC_TPREL32
-+#define R_PARISC_TLS_TPREL64	R_PARISC_TPREL64
-+#define R_PARISC_HIRESERVE	255
-+
-+/* Legal values for p_type field of Elf32_Phdr/Elf64_Phdr.  */
-+
-+#define PT_HP_TLS		(PT_LOOS + 0x0)
-+#define PT_HP_CORE_NONE		(PT_LOOS + 0x1)
-+#define PT_HP_CORE_VERSION	(PT_LOOS + 0x2)
-+#define PT_HP_CORE_KERNEL	(PT_LOOS + 0x3)
-+#define PT_HP_CORE_COMM		(PT_LOOS + 0x4)
-+#define PT_HP_CORE_PROC		(PT_LOOS + 0x5)
-+#define PT_HP_CORE_LOADABLE	(PT_LOOS + 0x6)
-+#define PT_HP_CORE_STACK	(PT_LOOS + 0x7)
-+#define PT_HP_CORE_SHM		(PT_LOOS + 0x8)
-+#define PT_HP_CORE_MMF		(PT_LOOS + 0x9)
-+#define PT_HP_PARALLEL		(PT_LOOS + 0x10)
-+#define PT_HP_FASTBIND		(PT_LOOS + 0x11)
-+#define PT_HP_OPT_ANNOT		(PT_LOOS + 0x12)
-+#define PT_HP_HSL_ANNOT		(PT_LOOS + 0x13)
-+#define PT_HP_STACK		(PT_LOOS + 0x14)
-+
-+#define PT_PARISC_ARCHEXT	0x70000000
-+#define PT_PARISC_UNWIND	0x70000001
-+
-+/* Legal values for p_flags field of Elf32_Phdr/Elf64_Phdr.  */
-+
-+#define PF_PARISC_SBP		0x08000000
-+
-+#define PF_HP_PAGE_SIZE		0x00100000
-+#define PF_HP_FAR_SHARED	0x00200000
-+#define PF_HP_NEAR_SHARED	0x00400000
-+#define PF_HP_CODE		0x01000000
-+#define PF_HP_MODIFY		0x02000000
-+#define PF_HP_LAZYSWAP		0x04000000
-+#define PF_HP_SBP		0x08000000
-+
-+
-+/* Alpha specific definitions.  */
-+
-+/* Legal values for e_flags field of Elf64_Ehdr.  */
-+
-+#define EF_ALPHA_32BIT		1	/* All addresses must be < 2GB.  */
-+#define EF_ALPHA_CANRELAX	2	/* Relocations for relaxing exist.  */
-+
-+/* Legal values for sh_type field of Elf64_Shdr.  */
-+
-+/* These two are primerily concerned with ECOFF debugging info.  */
-+#define SHT_ALPHA_DEBUG		0x70000001
-+#define SHT_ALPHA_REGINFO	0x70000002
-+
-+/* Legal values for sh_flags field of Elf64_Shdr.  */
-+
-+#define SHF_ALPHA_GPREL		0x10000000
-+
-+/* Legal values for st_other field of Elf64_Sym.  */
-+#define STO_ALPHA_NOPV		0x80	/* No PV required.  */
-+#define STO_ALPHA_STD_GPLOAD	0x88	/* PV only used for initial ldgp.  */
-+
-+/* Alpha relocs.  */
-+
-+#define R_ALPHA_NONE		0	/* No reloc */
-+#define R_ALPHA_REFLONG		1	/* Direct 32 bit */
-+#define R_ALPHA_REFQUAD		2	/* Direct 64 bit */
-+#define R_ALPHA_GPREL32		3	/* GP relative 32 bit */
-+#define R_ALPHA_LITERAL		4	/* GP relative 16 bit w/optimization */
-+#define R_ALPHA_LITUSE		5	/* Optimization hint for LITERAL */
-+#define R_ALPHA_GPDISP		6	/* Add displacement to GP */
-+#define R_ALPHA_BRADDR		7	/* PC+4 relative 23 bit shifted */
-+#define R_ALPHA_HINT		8	/* PC+4 relative 16 bit shifted */
-+#define R_ALPHA_SREL16		9	/* PC relative 16 bit */
-+#define R_ALPHA_SREL32		10	/* PC relative 32 bit */
-+#define R_ALPHA_SREL64		11	/* PC relative 64 bit */
-+#define R_ALPHA_GPRELHIGH	17	/* GP relative 32 bit, high 16 bits */
-+#define R_ALPHA_GPRELLOW	18	/* GP relative 32 bit, low 16 bits */
-+#define R_ALPHA_GPREL16		19	/* GP relative 16 bit */
-+#define R_ALPHA_COPY		24	/* Copy symbol at runtime */
-+#define R_ALPHA_GLOB_DAT	25	/* Create GOT entry */
-+#define R_ALPHA_JMP_SLOT	26	/* Create PLT entry */
-+#define R_ALPHA_RELATIVE	27	/* Adjust by program base */
-+#define R_ALPHA_TLS_GD_HI	28
-+#define R_ALPHA_TLSGD		29
-+#define R_ALPHA_TLS_LDM		30
-+#define R_ALPHA_DTPMOD64	31
-+#define R_ALPHA_GOTDTPREL	32
-+#define R_ALPHA_DTPREL64	33
-+#define R_ALPHA_DTPRELHI	34
-+#define R_ALPHA_DTPRELLO	35
-+#define R_ALPHA_DTPREL16	36
-+#define R_ALPHA_GOTTPREL	37
-+#define R_ALPHA_TPREL64		38
-+#define R_ALPHA_TPRELHI		39
-+#define R_ALPHA_TPRELLO		40
-+#define R_ALPHA_TPREL16		41
-+/* Keep this the last entry.  */
-+#define R_ALPHA_NUM		46
-+
-+/* Magic values of the LITUSE relocation addend.  */
-+#define LITUSE_ALPHA_ADDR	0
-+#define LITUSE_ALPHA_BASE	1
-+#define LITUSE_ALPHA_BYTOFF	2
-+#define LITUSE_ALPHA_JSR	3
-+#define LITUSE_ALPHA_TLS_GD	4
-+#define LITUSE_ALPHA_TLS_LDM	5
-+
-+/* Legal values for d_tag of Elf64_Dyn.  */
-+#define DT_ALPHA_PLTRO		(DT_LOPROC + 0)
-+#define DT_ALPHA_NUM		1
-+
-+/* PowerPC specific declarations */
-+
-+/* Values for Elf32/64_Ehdr.e_flags.  */
-+#define EF_PPC_EMB		0x80000000	/* PowerPC embedded flag */
-+
-+/* Cygnus local bits below */
-+#define EF_PPC_RELOCATABLE	0x00010000	/* PowerPC -mrelocatable flag*/
-+#define EF_PPC_RELOCATABLE_LIB	0x00008000	/* PowerPC -mrelocatable-lib
-+						   flag */
-+
-+/* PowerPC relocations defined by the ABIs */
-+#define R_PPC_NONE		0
-+#define R_PPC_ADDR32		1	/* 32bit absolute address */
-+#define R_PPC_ADDR24		2	/* 26bit address, 2 bits ignored.  */
-+#define R_PPC_ADDR16		3	/* 16bit absolute address */
-+#define R_PPC_ADDR16_LO		4	/* lower 16bit of absolute address */
-+#define R_PPC_ADDR16_HI		5	/* high 16bit of absolute address */
-+#define R_PPC_ADDR16_HA		6	/* adjusted high 16bit */
-+#define R_PPC_ADDR14		7	/* 16bit address, 2 bits ignored */
-+#define R_PPC_ADDR14_BRTAKEN	8
-+#define R_PPC_ADDR14_BRNTAKEN	9
-+#define R_PPC_REL24		10	/* PC relative 26 bit */
-+#define R_PPC_REL14		11	/* PC relative 16 bit */
-+#define R_PPC_REL14_BRTAKEN	12
-+#define R_PPC_REL14_BRNTAKEN	13
-+#define R_PPC_GOT16		14
-+#define R_PPC_GOT16_LO		15
-+#define R_PPC_GOT16_HI		16
-+#define R_PPC_GOT16_HA		17
-+#define R_PPC_PLTREL24		18
-+#define R_PPC_COPY		19
-+#define R_PPC_GLOB_DAT		20
-+#define R_PPC_JMP_SLOT		21
-+#define R_PPC_RELATIVE		22
-+#define R_PPC_LOCAL24PC		23
-+#define R_PPC_UADDR32		24
-+#define R_PPC_UADDR16		25
-+#define R_PPC_REL32		26
-+#define R_PPC_PLT32		27
-+#define R_PPC_PLTREL32		28
-+#define R_PPC_PLT16_LO		29
-+#define R_PPC_PLT16_HI		30
-+#define R_PPC_PLT16_HA		31
-+#define R_PPC_SDAREL16		32
-+#define R_PPC_SECTOFF		33
-+#define R_PPC_SECTOFF_LO	34
-+#define R_PPC_SECTOFF_HI	35
-+#define R_PPC_SECTOFF_HA	36
-+
-+/* PowerPC relocations defined for the TLS access ABI.  */
-+#define R_PPC_TLS		67 /* none	(sym+add)@tls */
-+#define R_PPC_DTPMOD32		68 /* word32	(sym+add)@dtpmod */
-+#define R_PPC_TPREL16		69 /* half16*	(sym+add)@tprel */
-+#define R_PPC_TPREL16_LO	70 /* half16	(sym+add)@tprel@l */
-+#define R_PPC_TPREL16_HI	71 /* half16	(sym+add)@tprel@h */
-+#define R_PPC_TPREL16_HA	72 /* half16	(sym+add)@tprel@ha */
-+#define R_PPC_TPREL32		73 /* word32	(sym+add)@tprel */
-+#define R_PPC_DTPREL16		74 /* half16*	(sym+add)@dtprel */
-+#define R_PPC_DTPREL16_LO	75 /* half16	(sym+add)@dtprel@l */
-+#define R_PPC_DTPREL16_HI	76 /* half16	(sym+add)@dtprel@h */
-+#define R_PPC_DTPREL16_HA	77 /* half16	(sym+add)@dtprel@ha */
-+#define R_PPC_DTPREL32		78 /* word32	(sym+add)@dtprel */
-+#define R_PPC_GOT_TLSGD16	79 /* half16*	(sym+add)@got@tlsgd */
-+#define R_PPC_GOT_TLSGD16_LO	80 /* half16	(sym+add)@got@tlsgd@l */
-+#define R_PPC_GOT_TLSGD16_HI	81 /* half16	(sym+add)@got@tlsgd@h */
-+#define R_PPC_GOT_TLSGD16_HA	82 /* half16	(sym+add)@got@tlsgd@ha */
-+#define R_PPC_GOT_TLSLD16	83 /* half16*	(sym+add)@got@tlsld */
-+#define R_PPC_GOT_TLSLD16_LO	84 /* half16	(sym+add)@got@tlsld@l */
-+#define R_PPC_GOT_TLSLD16_HI	85 /* half16	(sym+add)@got@tlsld@h */
-+#define R_PPC_GOT_TLSLD16_HA	86 /* half16	(sym+add)@got@tlsld@ha */
-+#define R_PPC_GOT_TPREL16	87 /* half16*	(sym+add)@got@tprel */
-+#define R_PPC_GOT_TPREL16_LO	88 /* half16	(sym+add)@got@tprel@l */
-+#define R_PPC_GOT_TPREL16_HI	89 /* half16	(sym+add)@got@tprel@h */
-+#define R_PPC_GOT_TPREL16_HA	90 /* half16	(sym+add)@got@tprel@ha */
-+#define R_PPC_GOT_DTPREL16	91 /* half16*	(sym+add)@got@dtprel */
-+#define R_PPC_GOT_DTPREL16_LO	92 /* half16*	(sym+add)@got@dtprel@l */
-+#define R_PPC_GOT_DTPREL16_HI	93 /* half16*	(sym+add)@got@dtprel@h */
-+#define R_PPC_GOT_DTPREL16_HA	94 /* half16*	(sym+add)@got@dtprel@ha */
-+
-+/* The remaining relocs are from the Embedded ELF ABI, and are not
-+   in the SVR4 ELF ABI.  */
-+#define R_PPC_EMB_NADDR32	101
-+#define R_PPC_EMB_NADDR16	102
-+#define R_PPC_EMB_NADDR16_LO	103
-+#define R_PPC_EMB_NADDR16_HI	104
-+#define R_PPC_EMB_NADDR16_HA	105
-+#define R_PPC_EMB_SDAI16	106
-+#define R_PPC_EMB_SDA2I16	107
-+#define R_PPC_EMB_SDA2REL	108
-+#define R_PPC_EMB_SDA21		109	/* 16 bit offset in SDA */
-+#define R_PPC_EMB_MRKREF	110
-+#define R_PPC_EMB_RELSEC16	111
-+#define R_PPC_EMB_RELST_LO	112
-+#define R_PPC_EMB_RELST_HI	113
-+#define R_PPC_EMB_RELST_HA	114
-+#define R_PPC_EMB_BIT_FLD	115
-+#define R_PPC_EMB_RELSDA	116	/* 16 bit relative offset in SDA */
-+
-+/* Diab tool relocations.  */
-+#define R_PPC_DIAB_SDA21_LO	180	/* like EMB_SDA21, but lower 16 bit */
-+#define R_PPC_DIAB_SDA21_HI	181	/* like EMB_SDA21, but high 16 bit */
-+#define R_PPC_DIAB_SDA21_HA	182	/* like EMB_SDA21, adjusted high 16 */
-+#define R_PPC_DIAB_RELSDA_LO	183	/* like EMB_RELSDA, but lower 16 bit */
-+#define R_PPC_DIAB_RELSDA_HI	184	/* like EMB_RELSDA, but high 16 bit */
-+#define R_PPC_DIAB_RELSDA_HA	185	/* like EMB_RELSDA, adjusted high 16 */
-+
-+/* GNU extension to support local ifunc.  */
-+#define R_PPC_IRELATIVE		248
-+
-+/* GNU relocs used in PIC code sequences.  */
-+#define R_PPC_REL16		249	/* half16   (sym+add-.) */
-+#define R_PPC_REL16_LO		250	/* half16   (sym+add-.)@l */
-+#define R_PPC_REL16_HI		251	/* half16   (sym+add-.)@h */
-+#define R_PPC_REL16_HA		252	/* half16   (sym+add-.)@ha */
-+
-+/* This is a phony reloc to handle any old fashioned TOC16 references
-+   that may still be in object files.  */
-+#define R_PPC_TOC16		255
-+
-+/* PowerPC specific values for the Dyn d_tag field.  */
-+#define DT_PPC_GOT		(DT_LOPROC + 0)
-+#define DT_PPC_NUM		1
-+
-+/* PowerPC64 relocations defined by the ABIs */
-+#define R_PPC64_NONE		R_PPC_NONE
-+#define R_PPC64_ADDR32		R_PPC_ADDR32 /* 32bit absolute address */
-+#define R_PPC64_ADDR24		R_PPC_ADDR24 /* 26bit address, word aligned */
-+#define R_PPC64_ADDR16		R_PPC_ADDR16 /* 16bit absolute address */
-+#define R_PPC64_ADDR16_LO	R_PPC_ADDR16_LO	/* lower 16bits of address */
-+#define R_PPC64_ADDR16_HI	R_PPC_ADDR16_HI	/* high 16bits of address. */
-+#define R_PPC64_ADDR16_HA	R_PPC_ADDR16_HA /* adjusted high 16bits.  */
-+#define R_PPC64_ADDR14		R_PPC_ADDR14 /* 16bit address, word aligned */
-+#define R_PPC64_ADDR14_BRTAKEN	R_PPC_ADDR14_BRTAKEN
-+#define R_PPC64_ADDR14_BRNTAKEN	R_PPC_ADDR14_BRNTAKEN
-+#define R_PPC64_REL24		R_PPC_REL24 /* PC-rel. 26 bit, word aligned */
-+#define R_PPC64_REL14		R_PPC_REL14 /* PC relative 16 bit */
-+#define R_PPC64_REL14_BRTAKEN	R_PPC_REL14_BRTAKEN
-+#define R_PPC64_REL14_BRNTAKEN	R_PPC_REL14_BRNTAKEN
-+#define R_PPC64_GOT16		R_PPC_GOT16
-+#define R_PPC64_GOT16_LO	R_PPC_GOT16_LO
-+#define R_PPC64_GOT16_HI	R_PPC_GOT16_HI
-+#define R_PPC64_GOT16_HA	R_PPC_GOT16_HA
-+
-+#define R_PPC64_COPY		R_PPC_COPY
-+#define R_PPC64_GLOB_DAT	R_PPC_GLOB_DAT
-+#define R_PPC64_JMP_SLOT	R_PPC_JMP_SLOT
-+#define R_PPC64_RELATIVE	R_PPC_RELATIVE
-+
-+#define R_PPC64_UADDR32		R_PPC_UADDR32
-+#define R_PPC64_UADDR16		R_PPC_UADDR16
-+#define R_PPC64_REL32		R_PPC_REL32
-+#define R_PPC64_PLT32		R_PPC_PLT32
-+#define R_PPC64_PLTREL32	R_PPC_PLTREL32
-+#define R_PPC64_PLT16_LO	R_PPC_PLT16_LO
-+#define R_PPC64_PLT16_HI	R_PPC_PLT16_HI
-+#define R_PPC64_PLT16_HA	R_PPC_PLT16_HA
-+
-+#define R_PPC64_SECTOFF		R_PPC_SECTOFF
-+#define R_PPC64_SECTOFF_LO	R_PPC_SECTOFF_LO
-+#define R_PPC64_SECTOFF_HI	R_PPC_SECTOFF_HI
-+#define R_PPC64_SECTOFF_HA	R_PPC_SECTOFF_HA
-+#define R_PPC64_ADDR30		37 /* word30 (S + A - P) >> 2 */
-+#define R_PPC64_ADDR64		38 /* doubleword64 S + A */
-+#define R_PPC64_ADDR16_HIGHER	39 /* half16 #higher(S + A) */
-+#define R_PPC64_ADDR16_HIGHERA	40 /* half16 #highera(S + A) */
-+#define R_PPC64_ADDR16_HIGHEST	41 /* half16 #highest(S + A) */
-+#define R_PPC64_ADDR16_HIGHESTA	42 /* half16 #highesta(S + A) */
-+#define R_PPC64_UADDR64		43 /* doubleword64 S + A */
-+#define R_PPC64_REL64		44 /* doubleword64 S + A - P */
-+#define R_PPC64_PLT64		45 /* doubleword64 L + A */
-+#define R_PPC64_PLTREL64	46 /* doubleword64 L + A - P */
-+#define R_PPC64_TOC16		47 /* half16* S + A - .TOC */
-+#define R_PPC64_TOC16_LO	48 /* half16 #lo(S + A - .TOC.) */
-+#define R_PPC64_TOC16_HI	49 /* half16 #hi(S + A - .TOC.) */
-+#define R_PPC64_TOC16_HA	50 /* half16 #ha(S + A - .TOC.) */
-+#define R_PPC64_TOC		51 /* doubleword64 .TOC */
-+#define R_PPC64_PLTGOT16	52 /* half16* M + A */
-+#define R_PPC64_PLTGOT16_LO	53 /* half16 #lo(M + A) */
-+#define R_PPC64_PLTGOT16_HI	54 /* half16 #hi(M + A) */
-+#define R_PPC64_PLTGOT16_HA	55 /* half16 #ha(M + A) */
-+
-+#define R_PPC64_ADDR16_DS	56 /* half16ds* (S + A) >> 2 */
-+#define R_PPC64_ADDR16_LO_DS	57 /* half16ds  #lo(S + A) >> 2 */
-+#define R_PPC64_GOT16_DS	58 /* half16ds* (G + A) >> 2 */
-+#define R_PPC64_GOT16_LO_DS	59 /* half16ds  #lo(G + A) >> 2 */
-+#define R_PPC64_PLT16_LO_DS	60 /* half16ds  #lo(L + A) >> 2 */
-+#define R_PPC64_SECTOFF_DS	61 /* half16ds* (R + A) >> 2 */
-+#define R_PPC64_SECTOFF_LO_DS	62 /* half16ds  #lo(R + A) >> 2 */
-+#define R_PPC64_TOC16_DS	63 /* half16ds* (S + A - .TOC.) >> 2 */
-+#define R_PPC64_TOC16_LO_DS	64 /* half16ds  #lo(S + A - .TOC.) >> 2 */
-+#define R_PPC64_PLTGOT16_DS	65 /* half16ds* (M + A) >> 2 */
-+#define R_PPC64_PLTGOT16_LO_DS	66 /* half16ds  #lo(M + A) >> 2 */
-+
-+/* PowerPC64 relocations defined for the TLS access ABI.  */
-+#define R_PPC64_TLS		67 /* none	(sym+add)@tls */
-+#define R_PPC64_DTPMOD64	68 /* doubleword64 (sym+add)@dtpmod */
-+#define R_PPC64_TPREL16		69 /* half16*	(sym+add)@tprel */
-+#define R_PPC64_TPREL16_LO	70 /* half16	(sym+add)@tprel@l */
-+#define R_PPC64_TPREL16_HI	71 /* half16	(sym+add)@tprel@h */
-+#define R_PPC64_TPREL16_HA	72 /* half16	(sym+add)@tprel@ha */
-+#define R_PPC64_TPREL64		73 /* doubleword64 (sym+add)@tprel */
-+#define R_PPC64_DTPREL16	74 /* half16*	(sym+add)@dtprel */
-+#define R_PPC64_DTPREL16_LO	75 /* half16	(sym+add)@dtprel@l */
-+#define R_PPC64_DTPREL16_HI	76 /* half16	(sym+add)@dtprel@h */
-+#define R_PPC64_DTPREL16_HA	77 /* half16	(sym+add)@dtprel@ha */
-+#define R_PPC64_DTPREL64	78 /* doubleword64 (sym+add)@dtprel */
-+#define R_PPC64_GOT_TLSGD16	79 /* half16*	(sym+add)@got@tlsgd */
-+#define R_PPC64_GOT_TLSGD16_LO	80 /* half16	(sym+add)@got@tlsgd@l */
-+#define R_PPC64_GOT_TLSGD16_HI	81 /* half16	(sym+add)@got@tlsgd@h */
-+#define R_PPC64_GOT_TLSGD16_HA	82 /* half16	(sym+add)@got@tlsgd@ha */
-+#define R_PPC64_GOT_TLSLD16	83 /* half16*	(sym+add)@got@tlsld */
-+#define R_PPC64_GOT_TLSLD16_LO	84 /* half16	(sym+add)@got@tlsld@l */
-+#define R_PPC64_GOT_TLSLD16_HI	85 /* half16	(sym+add)@got@tlsld@h */
-+#define R_PPC64_GOT_TLSLD16_HA	86 /* half16	(sym+add)@got@tlsld@ha */
-+#define R_PPC64_GOT_TPREL16_DS	87 /* half16ds*	(sym+add)@got@tprel */
-+#define R_PPC64_GOT_TPREL16_LO_DS 88 /* half16ds (sym+add)@got@tprel@l */
-+#define R_PPC64_GOT_TPREL16_HI	89 /* half16	(sym+add)@got@tprel@h */
-+#define R_PPC64_GOT_TPREL16_HA	90 /* half16	(sym+add)@got@tprel@ha */
-+#define R_PPC64_GOT_DTPREL16_DS	91 /* half16ds*	(sym+add)@got@dtprel */
-+#define R_PPC64_GOT_DTPREL16_LO_DS 92 /* half16ds (sym+add)@got@dtprel@l */
-+#define R_PPC64_GOT_DTPREL16_HI	93 /* half16	(sym+add)@got@dtprel@h */
-+#define R_PPC64_GOT_DTPREL16_HA	94 /* half16	(sym+add)@got@dtprel@ha */
-+#define R_PPC64_TPREL16_DS	95 /* half16ds*	(sym+add)@tprel */
-+#define R_PPC64_TPREL16_LO_DS	96 /* half16ds	(sym+add)@tprel@l */
-+#define R_PPC64_TPREL16_HIGHER	97 /* half16	(sym+add)@tprel@higher */
-+#define R_PPC64_TPREL16_HIGHERA	98 /* half16	(sym+add)@tprel@highera */
-+#define R_PPC64_TPREL16_HIGHEST	99 /* half16	(sym+add)@tprel@highest */
-+#define R_PPC64_TPREL16_HIGHESTA 100 /* half16	(sym+add)@tprel@highesta */
-+#define R_PPC64_DTPREL16_DS	101 /* half16ds* (sym+add)@dtprel */
-+#define R_PPC64_DTPREL16_LO_DS	102 /* half16ds	(sym+add)@dtprel@l */
-+#define R_PPC64_DTPREL16_HIGHER	103 /* half16	(sym+add)@dtprel@higher */
-+#define R_PPC64_DTPREL16_HIGHERA 104 /* half16	(sym+add)@dtprel@highera */
-+#define R_PPC64_DTPREL16_HIGHEST 105 /* half16	(sym+add)@dtprel@highest */
-+#define R_PPC64_DTPREL16_HIGHESTA 106 /* half16	(sym+add)@dtprel@highesta */
-+
-+/* GNU extension to support local ifunc.  */
-+#define R_PPC64_JMP_IREL	247
-+#define R_PPC64_IRELATIVE	248
-+#define R_PPC64_REL16		249	/* half16   (sym+add-.) */
-+#define R_PPC64_REL16_LO	250	/* half16   (sym+add-.)@l */
-+#define R_PPC64_REL16_HI	251	/* half16   (sym+add-.)@h */
-+#define R_PPC64_REL16_HA	252	/* half16   (sym+add-.)@ha */
-+
-+/* PowerPC64 specific values for the Dyn d_tag field.  */
-+#define DT_PPC64_GLINK  (DT_LOPROC + 0)
-+#define DT_PPC64_OPD	(DT_LOPROC + 1)
-+#define DT_PPC64_OPDSZ	(DT_LOPROC + 2)
-+#define DT_PPC64_NUM    3
-+
-+
-+/* ARM specific declarations */
-+
-+/* Processor specific flags for the ELF header e_flags field.  */
-+#define EF_ARM_RELEXEC		0x01
-+#define EF_ARM_HASENTRY		0x02
-+#define EF_ARM_INTERWORK	0x04
-+#define EF_ARM_APCS_26		0x08
-+#define EF_ARM_APCS_FLOAT	0x10
-+#define EF_ARM_PIC		0x20
-+#define EF_ARM_ALIGN8		0x40 /* 8-bit structure alignment is in use */
-+#define EF_ARM_NEW_ABI		0x80
-+#define EF_ARM_OLD_ABI		0x100
-+#define EF_ARM_SOFT_FLOAT	0x200
-+#define EF_ARM_VFP_FLOAT	0x400
-+#define EF_ARM_MAVERICK_FLOAT	0x800
-+
-+
-+/* Other constants defined in the ARM ELF spec. version B-01.  */
-+/* NB. These conflict with values defined above.  */
-+#define EF_ARM_SYMSARESORTED	0x04
-+#define EF_ARM_DYNSYMSUSESEGIDX	0x08
-+#define EF_ARM_MAPSYMSFIRST	0x10
-+#define EF_ARM_EABIMASK		0XFF000000
-+
-+/* Constants defined in AAELF.  */
-+#define EF_ARM_BE8	    0x00800000
-+#define EF_ARM_LE8	    0x00400000
-+
-+#define EF_ARM_EABI_VERSION(flags)	((flags) & EF_ARM_EABIMASK)
-+#define EF_ARM_EABI_UNKNOWN	0x00000000
-+#define EF_ARM_EABI_VER1	0x01000000
-+#define EF_ARM_EABI_VER2	0x02000000
-+#define EF_ARM_EABI_VER3	0x03000000
-+#define EF_ARM_EABI_VER4	0x04000000
-+#define EF_ARM_EABI_VER5	0x05000000
-+
-+/* Additional symbol types for Thumb.  */
-+#define STT_ARM_TFUNC		STT_LOPROC /* A Thumb function.  */
-+#define STT_ARM_16BIT		STT_HIPROC /* A Thumb label.  */
-+
-+/* ARM-specific values for sh_flags */
-+#define SHF_ARM_ENTRYSECT	0x10000000 /* Section contains an entry point */
-+#define SHF_ARM_COMDEF		0x80000000 /* Section may be multiply defined
-+					      in the input to a link step.  */
-+
-+/* ARM-specific program header flags */
-+#define PF_ARM_SB		0x10000000 /* Segment contains the location
-+					      addressed by the static base. */
-+#define PF_ARM_PI		0x20000000 /* Position-independent segment.  */
-+#define PF_ARM_ABS		0x40000000 /* Absolute segment.  */
-+
-+/* Processor specific values for the Phdr p_type field.  */
-+#define PT_ARM_EXIDX		(PT_LOPROC + 1)	/* ARM unwind segment.  */
-+
-+/* Processor specific values for the Shdr sh_type field.  */
-+#define SHT_ARM_EXIDX		(SHT_LOPROC + 1) /* ARM unwind section.  */
-+#define SHT_ARM_PREEMPTMAP	(SHT_LOPROC + 2) /* Preemption details.  */
-+#define SHT_ARM_ATTRIBUTES	(SHT_LOPROC + 3) /* ARM attributes section.  */
-+
-+
-+/* ARM relocs.  */
-+
-+#define R_ARM_NONE		0	/* No reloc */
-+#define R_ARM_PC24		1	/* PC relative 26 bit branch */
-+#define R_ARM_ABS32		2	/* Direct 32 bit  */
-+#define R_ARM_REL32		3	/* PC relative 32 bit */
-+#define R_ARM_PC13		4
-+#define R_ARM_ABS16		5	/* Direct 16 bit */
-+#define R_ARM_ABS12		6	/* Direct 12 bit */
-+#define R_ARM_THM_ABS5		7
-+#define R_ARM_ABS8		8	/* Direct 8 bit */
-+#define R_ARM_SBREL32		9
-+#define R_ARM_THM_PC22		10
-+#define R_ARM_THM_PC8		11
-+#define R_ARM_AMP_VCALL9	12
-+#define R_ARM_SWI24		13	/* Obsolete static relocation.  */
-+#define R_ARM_TLS_DESC		13      /* Dynamic relocation.  */
-+#define R_ARM_THM_SWI8		14
-+#define R_ARM_XPC25		15
-+#define R_ARM_THM_XPC22		16
-+#define R_ARM_TLS_DTPMOD32	17	/* ID of module containing symbol */
-+#define R_ARM_TLS_DTPOFF32	18	/* Offset in TLS block */
-+#define R_ARM_TLS_TPOFF32	19	/* Offset in static TLS block */
-+#define R_ARM_COPY		20	/* Copy symbol at runtime */
-+#define R_ARM_GLOB_DAT		21	/* Create GOT entry */
-+#define R_ARM_JUMP_SLOT		22	/* Create PLT entry */
-+#define R_ARM_RELATIVE		23	/* Adjust by program base */
-+#define R_ARM_GOTOFF		24	/* 32 bit offset to GOT */
-+#define R_ARM_GOTPC		25	/* 32 bit PC relative offset to GOT */
-+#define R_ARM_GOT32		26	/* 32 bit GOT entry */
-+#define R_ARM_PLT32		27	/* 32 bit PLT address */
-+#define R_ARM_ALU_PCREL_7_0	32
-+#define R_ARM_ALU_PCREL_15_8	33
-+#define R_ARM_ALU_PCREL_23_15	34
-+#define R_ARM_LDR_SBREL_11_0	35
-+#define R_ARM_ALU_SBREL_19_12	36
-+#define R_ARM_ALU_SBREL_27_20	37
-+#define R_ARM_TLS_GOTDESC	90
-+#define R_ARM_TLS_CALL		91
-+#define R_ARM_TLS_DESCSEQ	92
-+#define R_ARM_THM_TLS_CALL	93
-+#define R_ARM_GNU_VTENTRY	100
-+#define R_ARM_GNU_VTINHERIT	101
-+#define R_ARM_THM_PC11		102	/* thumb unconditional branch */
-+#define R_ARM_THM_PC9		103	/* thumb conditional branch */
-+#define R_ARM_TLS_GD32		104	/* PC-rel 32 bit for global dynamic
-+					   thread local data */
-+#define R_ARM_TLS_LDM32		105	/* PC-rel 32 bit for local dynamic
-+					   thread local data */
-+#define R_ARM_TLS_LDO32		106	/* 32 bit offset relative to TLS
-+					   block */
-+#define R_ARM_TLS_IE32		107	/* PC-rel 32 bit for GOT entry of
-+					   static TLS block offset */
-+#define R_ARM_TLS_LE32		108	/* 32 bit offset relative to static
-+					   TLS block */
-+#define	R_ARM_THM_TLS_DESCSEQ	129
-+#define R_ARM_IRELATIVE		160
-+#define R_ARM_RXPC25		249
-+#define R_ARM_RSBREL32		250
-+#define R_ARM_THM_RPC22		251
-+#define R_ARM_RREL32		252
-+#define R_ARM_RABS22		253
-+#define R_ARM_RPC24		254
-+#define R_ARM_RBASE		255
-+/* Keep this the last entry.  */
-+#define R_ARM_NUM		256
-+
-+/* IA-64 specific declarations.  */
-+
-+/* Processor specific flags for the Ehdr e_flags field.  */
-+#define EF_IA_64_MASKOS		0x0000000f	/* os-specific flags */
-+#define EF_IA_64_ABI64		0x00000010	/* 64-bit ABI */
-+#define EF_IA_64_ARCH		0xff000000	/* arch. version mask */
-+
-+/* Processor specific values for the Phdr p_type field.  */
-+#define PT_IA_64_ARCHEXT	(PT_LOPROC + 0)	/* arch extension bits */
-+#define PT_IA_64_UNWIND		(PT_LOPROC + 1)	/* ia64 unwind bits */
-+#define PT_IA_64_HP_OPT_ANOT	(PT_LOOS + 0x12)
-+#define PT_IA_64_HP_HSL_ANOT	(PT_LOOS + 0x13)
-+#define PT_IA_64_HP_STACK	(PT_LOOS + 0x14)
-+
-+/* Processor specific flags for the Phdr p_flags field.  */
-+#define PF_IA_64_NORECOV	0x80000000	/* spec insns w/o recovery */
-+
-+/* Processor specific values for the Shdr sh_type field.  */
-+#define SHT_IA_64_EXT		(SHT_LOPROC + 0) /* extension bits */
-+#define SHT_IA_64_UNWIND	(SHT_LOPROC + 1) /* unwind bits */
-+
-+/* Processor specific flags for the Shdr sh_flags field.  */
-+#define SHF_IA_64_SHORT		0x10000000	/* section near gp */
-+#define SHF_IA_64_NORECOV	0x20000000	/* spec insns w/o recovery */
-+
-+/* Processor specific values for the Dyn d_tag field.  */
-+#define DT_IA_64_PLT_RESERVE	(DT_LOPROC + 0)
-+#define DT_IA_64_NUM		1
-+
-+/* IA-64 relocations.  */
-+#define R_IA64_NONE		0x00	/* none */
-+#define R_IA64_IMM14		0x21	/* symbol + addend, add imm14 */
-+#define R_IA64_IMM22		0x22	/* symbol + addend, add imm22 */
-+#define R_IA64_IMM64		0x23	/* symbol + addend, mov imm64 */
-+#define R_IA64_DIR32MSB		0x24	/* symbol + addend, data4 MSB */
-+#define R_IA64_DIR32LSB		0x25	/* symbol + addend, data4 LSB */
-+#define R_IA64_DIR64MSB		0x26	/* symbol + addend, data8 MSB */
-+#define R_IA64_DIR64LSB		0x27	/* symbol + addend, data8 LSB */
-+#define R_IA64_GPREL22		0x2a	/* @gprel(sym + add), add imm22 */
-+#define R_IA64_GPREL64I		0x2b	/* @gprel(sym + add), mov imm64 */
-+#define R_IA64_GPREL32MSB	0x2c	/* @gprel(sym + add), data4 MSB */
-+#define R_IA64_GPREL32LSB	0x2d	/* @gprel(sym + add), data4 LSB */
-+#define R_IA64_GPREL64MSB	0x2e	/* @gprel(sym + add), data8 MSB */
-+#define R_IA64_GPREL64LSB	0x2f	/* @gprel(sym + add), data8 LSB */
-+#define R_IA64_LTOFF22		0x32	/* @ltoff(sym + add), add imm22 */
-+#define R_IA64_LTOFF64I		0x33	/* @ltoff(sym + add), mov imm64 */
-+#define R_IA64_PLTOFF22		0x3a	/* @pltoff(sym + add), add imm22 */
-+#define R_IA64_PLTOFF64I	0x3b	/* @pltoff(sym + add), mov imm64 */
-+#define R_IA64_PLTOFF64MSB	0x3e	/* @pltoff(sym + add), data8 MSB */
-+#define R_IA64_PLTOFF64LSB	0x3f	/* @pltoff(sym + add), data8 LSB */
-+#define R_IA64_FPTR64I		0x43	/* @fptr(sym + add), mov imm64 */
-+#define R_IA64_FPTR32MSB	0x44	/* @fptr(sym + add), data4 MSB */
-+#define R_IA64_FPTR32LSB	0x45	/* @fptr(sym + add), data4 LSB */
-+#define R_IA64_FPTR64MSB	0x46	/* @fptr(sym + add), data8 MSB */
-+#define R_IA64_FPTR64LSB	0x47	/* @fptr(sym + add), data8 LSB */
-+#define R_IA64_PCREL60B		0x48	/* @pcrel(sym + add), brl */
-+#define R_IA64_PCREL21B		0x49	/* @pcrel(sym + add), ptb, call */
-+#define R_IA64_PCREL21M		0x4a	/* @pcrel(sym + add), chk.s */
-+#define R_IA64_PCREL21F		0x4b	/* @pcrel(sym + add), fchkf */
-+#define R_IA64_PCREL32MSB	0x4c	/* @pcrel(sym + add), data4 MSB */
-+#define R_IA64_PCREL32LSB	0x4d	/* @pcrel(sym + add), data4 LSB */
-+#define R_IA64_PCREL64MSB	0x4e	/* @pcrel(sym + add), data8 MSB */
-+#define R_IA64_PCREL64LSB	0x4f	/* @pcrel(sym + add), data8 LSB */
-+#define R_IA64_LTOFF_FPTR22	0x52	/* @ltoff(@fptr(s+a)), imm22 */
-+#define R_IA64_LTOFF_FPTR64I	0x53	/* @ltoff(@fptr(s+a)), imm64 */
-+#define R_IA64_LTOFF_FPTR32MSB	0x54	/* @ltoff(@fptr(s+a)), data4 MSB */
-+#define R_IA64_LTOFF_FPTR32LSB	0x55	/* @ltoff(@fptr(s+a)), data4 LSB */
-+#define R_IA64_LTOFF_FPTR64MSB	0x56	/* @ltoff(@fptr(s+a)), data8 MSB */
-+#define R_IA64_LTOFF_FPTR64LSB	0x57	/* @ltoff(@fptr(s+a)), data8 LSB */
-+#define R_IA64_SEGREL32MSB	0x5c	/* @segrel(sym + add), data4 MSB */
-+#define R_IA64_SEGREL32LSB	0x5d	/* @segrel(sym + add), data4 LSB */
-+#define R_IA64_SEGREL64MSB	0x5e	/* @segrel(sym + add), data8 MSB */
-+#define R_IA64_SEGREL64LSB	0x5f	/* @segrel(sym + add), data8 LSB */
-+#define R_IA64_SECREL32MSB	0x64	/* @secrel(sym + add), data4 MSB */
-+#define R_IA64_SECREL32LSB	0x65	/* @secrel(sym + add), data4 LSB */
-+#define R_IA64_SECREL64MSB	0x66	/* @secrel(sym + add), data8 MSB */
-+#define R_IA64_SECREL64LSB	0x67	/* @secrel(sym + add), data8 LSB */
-+#define R_IA64_REL32MSB		0x6c	/* data 4 + REL */
-+#define R_IA64_REL32LSB		0x6d	/* data 4 + REL */
-+#define R_IA64_REL64MSB		0x6e	/* data 8 + REL */
-+#define R_IA64_REL64LSB		0x6f	/* data 8 + REL */
-+#define R_IA64_LTV32MSB		0x74	/* symbol + addend, data4 MSB */
-+#define R_IA64_LTV32LSB		0x75	/* symbol + addend, data4 LSB */
-+#define R_IA64_LTV64MSB		0x76	/* symbol + addend, data8 MSB */
-+#define R_IA64_LTV64LSB		0x77	/* symbol + addend, data8 LSB */
-+#define R_IA64_PCREL21BI	0x79	/* @pcrel(sym + add), 21bit inst */
-+#define R_IA64_PCREL22		0x7a	/* @pcrel(sym + add), 22bit inst */
-+#define R_IA64_PCREL64I		0x7b	/* @pcrel(sym + add), 64bit inst */
-+#define R_IA64_IPLTMSB		0x80	/* dynamic reloc, imported PLT, MSB */
-+#define R_IA64_IPLTLSB		0x81	/* dynamic reloc, imported PLT, LSB */
-+#define R_IA64_COPY		0x84	/* copy relocation */
-+#define R_IA64_SUB		0x85	/* Addend and symbol difference */
-+#define R_IA64_LTOFF22X		0x86	/* LTOFF22, relaxable.  */
-+#define R_IA64_LDXMOV		0x87	/* Use of LTOFF22X.  */
-+#define R_IA64_TPREL14		0x91	/* @tprel(sym + add), imm14 */
-+#define R_IA64_TPREL22		0x92	/* @tprel(sym + add), imm22 */
-+#define R_IA64_TPREL64I		0x93	/* @tprel(sym + add), imm64 */
-+#define R_IA64_TPREL64MSB	0x96	/* @tprel(sym + add), data8 MSB */
-+#define R_IA64_TPREL64LSB	0x97	/* @tprel(sym + add), data8 LSB */
-+#define R_IA64_LTOFF_TPREL22	0x9a	/* @ltoff(@tprel(s+a)), imm2 */
-+#define R_IA64_DTPMOD64MSB	0xa6	/* @dtpmod(sym + add), data8 MSB */
-+#define R_IA64_DTPMOD64LSB	0xa7	/* @dtpmod(sym + add), data8 LSB */
-+#define R_IA64_LTOFF_DTPMOD22	0xaa	/* @ltoff(@dtpmod(sym + add)), imm22 */
-+#define R_IA64_DTPREL14		0xb1	/* @dtprel(sym + add), imm14 */
-+#define R_IA64_DTPREL22		0xb2	/* @dtprel(sym + add), imm22 */
-+#define R_IA64_DTPREL64I	0xb3	/* @dtprel(sym + add), imm64 */
-+#define R_IA64_DTPREL32MSB	0xb4	/* @dtprel(sym + add), data4 MSB */
-+#define R_IA64_DTPREL32LSB	0xb5	/* @dtprel(sym + add), data4 LSB */
-+#define R_IA64_DTPREL64MSB	0xb6	/* @dtprel(sym + add), data8 MSB */
-+#define R_IA64_DTPREL64LSB	0xb7	/* @dtprel(sym + add), data8 LSB */
-+#define R_IA64_LTOFF_DTPREL22	0xba	/* @ltoff(@dtprel(s+a)), imm22 */
-+
-+/* SH specific declarations */
-+
-+/* Processor specific flags for the ELF header e_flags field.  */
-+#define EF_SH_MACH_MASK		0x1f
-+#define EF_SH_UNKNOWN		0x0
-+#define EF_SH1			0x1
-+#define EF_SH2			0x2
-+#define EF_SH3			0x3
-+#define EF_SH_DSP		0x4
-+#define EF_SH3_DSP		0x5
-+#define EF_SH4AL_DSP		0x6
-+#define EF_SH3E			0x8
-+#define EF_SH4			0x9
-+#define EF_SH2E			0xb
-+#define EF_SH4A			0xc
-+#define EF_SH2A			0xd
-+#define EF_SH4_NOFPU		0x10
-+#define EF_SH4A_NOFPU		0x11
-+#define EF_SH4_NOMMU_NOFPU	0x12
-+#define EF_SH2A_NOFPU		0x13
-+#define EF_SH3_NOMMU		0x14
-+#define EF_SH2A_SH4_NOFPU	0x15
-+#define EF_SH2A_SH3_NOFPU	0x16
-+#define EF_SH2A_SH4		0x17
-+#define EF_SH2A_SH3E		0x18
-+
-+/* SH relocs.  */
-+#define	R_SH_NONE		0
-+#define	R_SH_DIR32		1
-+#define	R_SH_REL32		2
-+#define	R_SH_DIR8WPN		3
-+#define	R_SH_IND12W		4
-+#define	R_SH_DIR8WPL		5
-+#define	R_SH_DIR8WPZ		6
-+#define	R_SH_DIR8BP		7
-+#define	R_SH_DIR8W		8
-+#define	R_SH_DIR8L		9
-+#define	R_SH_SWITCH16		25
-+#define	R_SH_SWITCH32		26
-+#define	R_SH_USES		27
-+#define	R_SH_COUNT		28
-+#define	R_SH_ALIGN		29
-+#define	R_SH_CODE		30
-+#define	R_SH_DATA		31
-+#define	R_SH_LABEL		32
-+#define	R_SH_SWITCH8		33
-+#define	R_SH_GNU_VTINHERIT	34
-+#define	R_SH_GNU_VTENTRY	35
-+#define	R_SH_TLS_GD_32		144
-+#define	R_SH_TLS_LD_32		145
-+#define	R_SH_TLS_LDO_32		146
-+#define	R_SH_TLS_IE_32		147
-+#define	R_SH_TLS_LE_32		148
-+#define	R_SH_TLS_DTPMOD32	149
-+#define	R_SH_TLS_DTPOFF32	150
-+#define	R_SH_TLS_TPOFF32	151
-+#define	R_SH_GOT32		160
-+#define	R_SH_PLT32		161
-+#define	R_SH_COPY		162
-+#define	R_SH_GLOB_DAT		163
-+#define	R_SH_JMP_SLOT		164
-+#define	R_SH_RELATIVE		165
-+#define	R_SH_GOTOFF		166
-+#define	R_SH_GOTPC		167
-+/* Keep this the last entry.  */
-+#define	R_SH_NUM		256
-+
-+/* S/390 specific definitions.  */
-+
-+/* Valid values for the e_flags field.  */
-+
-+#define EF_S390_HIGH_GPRS    0x00000001  /* High GPRs kernel facility needed.  */
-+
-+/* Additional s390 relocs */
-+
-+#define R_390_NONE		0	/* No reloc.  */
-+#define R_390_8			1	/* Direct 8 bit.  */
-+#define R_390_12		2	/* Direct 12 bit.  */
-+#define R_390_16		3	/* Direct 16 bit.  */
-+#define R_390_32		4	/* Direct 32 bit.  */
-+#define R_390_PC32		5	/* PC relative 32 bit.	*/
-+#define R_390_GOT12		6	/* 12 bit GOT offset.  */
-+#define R_390_GOT32		7	/* 32 bit GOT offset.  */
-+#define R_390_PLT32		8	/* 32 bit PC relative PLT address.  */
-+#define R_390_COPY		9	/* Copy symbol at runtime.  */
-+#define R_390_GLOB_DAT		10	/* Create GOT entry.  */
-+#define R_390_JMP_SLOT		11	/* Create PLT entry.  */
-+#define R_390_RELATIVE		12	/* Adjust by program base.  */
-+#define R_390_GOTOFF32		13	/* 32 bit offset to GOT.	 */
-+#define R_390_GOTPC		14	/* 32 bit PC relative offset to GOT.  */
-+#define R_390_GOT16		15	/* 16 bit GOT offset.  */
-+#define R_390_PC16		16	/* PC relative 16 bit.	*/
-+#define R_390_PC16DBL		17	/* PC relative 16 bit shifted by 1.  */
-+#define R_390_PLT16DBL		18	/* 16 bit PC rel. PLT shifted by 1.  */
-+#define R_390_PC32DBL		19	/* PC relative 32 bit shifted by 1.  */
-+#define R_390_PLT32DBL		20	/* 32 bit PC rel. PLT shifted by 1.  */
-+#define R_390_GOTPCDBL		21	/* 32 bit PC rel. GOT shifted by 1.  */
-+#define R_390_64		22	/* Direct 64 bit.  */
-+#define R_390_PC64		23	/* PC relative 64 bit.	*/
-+#define R_390_GOT64		24	/* 64 bit GOT offset.  */
-+#define R_390_PLT64		25	/* 64 bit PC relative PLT address.  */
-+#define R_390_GOTENT		26	/* 32 bit PC rel. to GOT entry >> 1. */
-+#define R_390_GOTOFF16		27	/* 16 bit offset to GOT. */
-+#define R_390_GOTOFF64		28	/* 64 bit offset to GOT. */
-+#define R_390_GOTPLT12		29	/* 12 bit offset to jump slot.	*/
-+#define R_390_GOTPLT16		30	/* 16 bit offset to jump slot.	*/
-+#define R_390_GOTPLT32		31	/* 32 bit offset to jump slot.	*/
-+#define R_390_GOTPLT64		32	/* 64 bit offset to jump slot.	*/
-+#define R_390_GOTPLTENT		33	/* 32 bit rel. offset to jump slot.  */
-+#define R_390_PLTOFF16		34	/* 16 bit offset from GOT to PLT. */
-+#define R_390_PLTOFF32		35	/* 32 bit offset from GOT to PLT. */
-+#define R_390_PLTOFF64		36	/* 16 bit offset from GOT to PLT. */
-+#define R_390_TLS_LOAD		37	/* Tag for load insn in TLS code.  */
-+#define R_390_TLS_GDCALL	38	/* Tag for function call in general
-+					   dynamic TLS code. */
-+#define R_390_TLS_LDCALL	39	/* Tag for function call in local
-+					   dynamic TLS code. */
-+#define R_390_TLS_GD32		40	/* Direct 32 bit for general dynamic
-+					   thread local data.  */
-+#define R_390_TLS_GD64		41	/* Direct 64 bit for general dynamic
-+					  thread local data.  */
-+#define R_390_TLS_GOTIE12	42	/* 12 bit GOT offset for static TLS
-+					   block offset.  */
-+#define R_390_TLS_GOTIE32	43	/* 32 bit GOT offset for static TLS
-+					   block offset.  */
-+#define R_390_TLS_GOTIE64	44	/* 64 bit GOT offset for static TLS
-+					   block offset. */
-+#define R_390_TLS_LDM32		45	/* Direct 32 bit for local dynamic
-+					   thread local data in LE code.  */
-+#define R_390_TLS_LDM64		46	/* Direct 64 bit for local dynamic
-+					   thread local data in LE code.  */
-+#define R_390_TLS_IE32		47	/* 32 bit address of GOT entry for
-+					   negated static TLS block offset.  */
-+#define R_390_TLS_IE64		48	/* 64 bit address of GOT entry for
-+					   negated static TLS block offset.  */
-+#define R_390_TLS_IEENT		49	/* 32 bit rel. offset to GOT entry for
-+					   negated static TLS block offset.  */
-+#define R_390_TLS_LE32		50	/* 32 bit negated offset relative to
-+					   static TLS block.  */
-+#define R_390_TLS_LE64		51	/* 64 bit negated offset relative to
-+					   static TLS block.  */
-+#define R_390_TLS_LDO32		52	/* 32 bit offset relative to TLS
-+					   block.  */
-+#define R_390_TLS_LDO64		53	/* 64 bit offset relative to TLS
-+					   block.  */
-+#define R_390_TLS_DTPMOD	54	/* ID of module containing symbol.  */
-+#define R_390_TLS_DTPOFF	55	/* Offset in TLS block.	 */
-+#define R_390_TLS_TPOFF		56	/* Negated offset in static TLS
-+					   block.  */
-+#define R_390_20		57	/* Direct 20 bit.  */
-+#define R_390_GOT20		58	/* 20 bit GOT offset.  */
-+#define R_390_GOTPLT20		59	/* 20 bit offset to jump slot.  */
-+#define R_390_TLS_GOTIE20	60	/* 20 bit GOT offset for static TLS
-+					   block offset.  */
-+#define R_390_IRELATIVE         61      /* STT_GNU_IFUNC relocation.  */
-+/* Keep this the last entry.  */
-+#define R_390_NUM		62
-+
-+
-+/* CRIS relocations.  */
-+#define R_CRIS_NONE		0
-+#define R_CRIS_8		1
-+#define R_CRIS_16		2
-+#define R_CRIS_32		3
-+#define R_CRIS_8_PCREL		4
-+#define R_CRIS_16_PCREL		5
-+#define R_CRIS_32_PCREL		6
-+#define R_CRIS_GNU_VTINHERIT	7
-+#define R_CRIS_GNU_VTENTRY	8
-+#define R_CRIS_COPY		9
-+#define R_CRIS_GLOB_DAT		10
-+#define R_CRIS_JUMP_SLOT	11
-+#define R_CRIS_RELATIVE		12
-+#define R_CRIS_16_GOT		13
-+#define R_CRIS_32_GOT		14
-+#define R_CRIS_16_GOTPLT	15
-+#define R_CRIS_32_GOTPLT	16
-+#define R_CRIS_32_GOTREL	17
-+#define R_CRIS_32_PLT_GOTREL	18
-+#define R_CRIS_32_PLT_PCREL	19
-+
-+#define R_CRIS_NUM		20
-+
-+
-+/* AMD x86-64 relocations.  */
-+#define R_X86_64_NONE		0	/* No reloc */
-+#define R_X86_64_64		1	/* Direct 64 bit  */
-+#define R_X86_64_PC32		2	/* PC relative 32 bit signed */
-+#define R_X86_64_GOT32		3	/* 32 bit GOT entry */
-+#define R_X86_64_PLT32		4	/* 32 bit PLT address */
-+#define R_X86_64_COPY		5	/* Copy symbol at runtime */
-+#define R_X86_64_GLOB_DAT	6	/* Create GOT entry */
-+#define R_X86_64_JUMP_SLOT	7	/* Create PLT entry */
-+#define R_X86_64_RELATIVE	8	/* Adjust by program base */
-+#define R_X86_64_GOTPCREL	9	/* 32 bit signed PC relative
-+					   offset to GOT */
-+#define R_X86_64_32		10	/* Direct 32 bit zero extended */
-+#define R_X86_64_32S		11	/* Direct 32 bit sign extended */
-+#define R_X86_64_16		12	/* Direct 16 bit zero extended */
-+#define R_X86_64_PC16		13	/* 16 bit sign extended pc relative */
-+#define R_X86_64_8		14	/* Direct 8 bit sign extended  */
-+#define R_X86_64_PC8		15	/* 8 bit sign extended pc relative */
-+#define R_X86_64_DTPMOD64	16	/* ID of module containing symbol */
-+#define R_X86_64_DTPOFF64	17	/* Offset in module's TLS block */
-+#define R_X86_64_TPOFF64	18	/* Offset in initial TLS block */
-+#define R_X86_64_TLSGD		19	/* 32 bit signed PC relative offset
-+					   to two GOT entries for GD symbol */
-+#define R_X86_64_TLSLD		20	/* 32 bit signed PC relative offset
-+					   to two GOT entries for LD symbol */
-+#define R_X86_64_DTPOFF32	21	/* Offset in TLS block */
-+#define R_X86_64_GOTTPOFF	22	/* 32 bit signed PC relative offset
-+					   to GOT entry for IE symbol */
-+#define R_X86_64_TPOFF32	23	/* Offset in initial TLS block */
-+#define R_X86_64_PC64		24	/* PC relative 64 bit */
-+#define R_X86_64_GOTOFF64	25	/* 64 bit offset to GOT */
-+#define R_X86_64_GOTPC32	26	/* 32 bit signed pc relative
-+					   offset to GOT */
-+#define R_X86_64_GOT64		27	/* 64-bit GOT entry offset */
-+#define R_X86_64_GOTPCREL64	28	/* 64-bit PC relative offset
-+					   to GOT entry */
-+#define R_X86_64_GOTPC64	29	/* 64-bit PC relative offset to GOT */
-+#define R_X86_64_GOTPLT64	30 	/* like GOT64, says PLT entry needed */
-+#define R_X86_64_PLTOFF64	31	/* 64-bit GOT relative offset
-+					   to PLT entry */
-+#define R_X86_64_SIZE32		32	/* Size of symbol plus 32-bit addend */
-+#define R_X86_64_SIZE64		33	/* Size of symbol plus 64-bit addend */
-+#define R_X86_64_GOTPC32_TLSDESC 34	/* GOT offset for TLS descriptor.  */
-+#define R_X86_64_TLSDESC_CALL   35	/* Marker for call through TLS
-+					   descriptor.  */
-+#define R_X86_64_TLSDESC        36	/* TLS descriptor.  */
-+#define R_X86_64_IRELATIVE	37	/* Adjust indirectly by program base */
-+#define R_X86_64_RELATIVE64	38	/* 64-bit adjust by program base */
-+
-+#define R_X86_64_NUM		39
-+
-+
-+/* AM33 relocations.  */
-+#define R_MN10300_NONE		0	/* No reloc.  */
-+#define R_MN10300_32		1	/* Direct 32 bit.  */
-+#define R_MN10300_16		2	/* Direct 16 bit.  */
-+#define R_MN10300_8		3	/* Direct 8 bit.  */
-+#define R_MN10300_PCREL32	4	/* PC-relative 32-bit.  */
-+#define R_MN10300_PCREL16	5	/* PC-relative 16-bit signed.  */
-+#define R_MN10300_PCREL8	6	/* PC-relative 8-bit signed.  */
-+#define R_MN10300_GNU_VTINHERIT	7	/* Ancient C++ vtable garbage... */
-+#define R_MN10300_GNU_VTENTRY	8	/* ... collection annotation.  */
-+#define R_MN10300_24		9	/* Direct 24 bit.  */
-+#define R_MN10300_GOTPC32	10	/* 32-bit PCrel offset to GOT.  */
-+#define R_MN10300_GOTPC16	11	/* 16-bit PCrel offset to GOT.  */
-+#define R_MN10300_GOTOFF32	12	/* 32-bit offset from GOT.  */
-+#define R_MN10300_GOTOFF24	13	/* 24-bit offset from GOT.  */
-+#define R_MN10300_GOTOFF16	14	/* 16-bit offset from GOT.  */
-+#define R_MN10300_PLT32		15	/* 32-bit PCrel to PLT entry.  */
-+#define R_MN10300_PLT16		16	/* 16-bit PCrel to PLT entry.  */
-+#define R_MN10300_GOT32		17	/* 32-bit offset to GOT entry.  */
-+#define R_MN10300_GOT24		18	/* 24-bit offset to GOT entry.  */
-+#define R_MN10300_GOT16		19	/* 16-bit offset to GOT entry.  */
-+#define R_MN10300_COPY		20	/* Copy symbol at runtime.  */
-+#define R_MN10300_GLOB_DAT	21	/* Create GOT entry.  */
-+#define R_MN10300_JMP_SLOT	22	/* Create PLT entry.  */
-+#define R_MN10300_RELATIVE	23	/* Adjust by program base.  */
-+
-+#define R_MN10300_NUM		24
-+
-+
-+/* M32R relocs.  */
-+#define R_M32R_NONE		0	/* No reloc. */
-+#define R_M32R_16		1	/* Direct 16 bit. */
-+#define R_M32R_32		2	/* Direct 32 bit. */
-+#define R_M32R_24		3	/* Direct 24 bit. */
-+#define R_M32R_10_PCREL		4	/* PC relative 10 bit shifted. */
-+#define R_M32R_18_PCREL		5	/* PC relative 18 bit shifted. */
-+#define R_M32R_26_PCREL		6	/* PC relative 26 bit shifted. */
-+#define R_M32R_HI16_ULO		7	/* High 16 bit with unsigned low. */
-+#define R_M32R_HI16_SLO		8	/* High 16 bit with signed low. */
-+#define R_M32R_LO16		9	/* Low 16 bit. */
-+#define R_M32R_SDA16		10	/* 16 bit offset in SDA. */
-+#define R_M32R_GNU_VTINHERIT	11
-+#define R_M32R_GNU_VTENTRY	12
-+/* M32R relocs use SHT_RELA.  */
-+#define R_M32R_16_RELA		33	/* Direct 16 bit. */
-+#define R_M32R_32_RELA		34	/* Direct 32 bit. */
-+#define R_M32R_24_RELA		35	/* Direct 24 bit. */
-+#define R_M32R_10_PCREL_RELA	36	/* PC relative 10 bit shifted. */
-+#define R_M32R_18_PCREL_RELA	37	/* PC relative 18 bit shifted. */
-+#define R_M32R_26_PCREL_RELA	38	/* PC relative 26 bit shifted. */
-+#define R_M32R_HI16_ULO_RELA	39	/* High 16 bit with unsigned low */
-+#define R_M32R_HI16_SLO_RELA	40	/* High 16 bit with signed low */
-+#define R_M32R_LO16_RELA	41	/* Low 16 bit */
-+#define R_M32R_SDA16_RELA	42	/* 16 bit offset in SDA */
-+#define R_M32R_RELA_GNU_VTINHERIT	43
-+#define R_M32R_RELA_GNU_VTENTRY	44
-+#define R_M32R_REL32		45	/* PC relative 32 bit.  */
-+
-+#define R_M32R_GOT24		48	/* 24 bit GOT entry */
-+#define R_M32R_26_PLTREL	49	/* 26 bit PC relative to PLT shifted */
-+#define R_M32R_COPY		50	/* Copy symbol at runtime */
-+#define R_M32R_GLOB_DAT		51	/* Create GOT entry */
-+#define R_M32R_JMP_SLOT		52	/* Create PLT entry */
-+#define R_M32R_RELATIVE		53	/* Adjust by program base */
-+#define R_M32R_GOTOFF		54	/* 24 bit offset to GOT */
-+#define R_M32R_GOTPC24		55	/* 24 bit PC relative offset to GOT */
-+#define R_M32R_GOT16_HI_ULO	56	/* High 16 bit GOT entry with unsigned
-+					   low */
-+#define R_M32R_GOT16_HI_SLO	57	/* High 16 bit GOT entry with signed
-+					   low */
-+#define R_M32R_GOT16_LO		58	/* Low 16 bit GOT entry */
-+#define R_M32R_GOTPC_HI_ULO	59	/* High 16 bit PC relative offset to
-+					   GOT with unsigned low */
-+#define R_M32R_GOTPC_HI_SLO	60	/* High 16 bit PC relative offset to
-+					   GOT with signed low */
-+#define R_M32R_GOTPC_LO		61	/* Low 16 bit PC relative offset to
-+					   GOT */
-+#define R_M32R_GOTOFF_HI_ULO	62	/* High 16 bit offset to GOT
-+					   with unsigned low */
-+#define R_M32R_GOTOFF_HI_SLO	63	/* High 16 bit offset to GOT
-+					   with signed low */
-+#define R_M32R_GOTOFF_LO	64	/* Low 16 bit offset to GOT */
-+#define R_M32R_NUM		256	/* Keep this the last entry. */
-+
-+
-+/* TILEPro relocations.  */
-+#define R_TILEPRO_NONE		0	/* No reloc */
-+#define R_TILEPRO_32		1	/* Direct 32 bit */
-+#define R_TILEPRO_16		2	/* Direct 16 bit */
-+#define R_TILEPRO_8		3	/* Direct 8 bit */
-+#define R_TILEPRO_32_PCREL	4	/* PC relative 32 bit */
-+#define R_TILEPRO_16_PCREL	5	/* PC relative 16 bit */
-+#define R_TILEPRO_8_PCREL	6	/* PC relative 8 bit */
-+#define R_TILEPRO_LO16		7	/* Low 16 bit */
-+#define R_TILEPRO_HI16		8	/* High 16 bit */
-+#define R_TILEPRO_HA16		9	/* High 16 bit, adjusted */
-+#define R_TILEPRO_COPY		10	/* Copy relocation */
-+#define R_TILEPRO_GLOB_DAT	11	/* Create GOT entry */
-+#define R_TILEPRO_JMP_SLOT	12	/* Create PLT entry */
-+#define R_TILEPRO_RELATIVE	13	/* Adjust by program base */
-+#define R_TILEPRO_BROFF_X1	14	/* X1 pipe branch offset */
-+#define R_TILEPRO_JOFFLONG_X1	15	/* X1 pipe jump offset */
-+#define R_TILEPRO_JOFFLONG_X1_PLT 16	/* X1 pipe jump offset to PLT */
-+#define R_TILEPRO_IMM8_X0	17	/* X0 pipe 8-bit */
-+#define R_TILEPRO_IMM8_Y0	18	/* Y0 pipe 8-bit */
-+#define R_TILEPRO_IMM8_X1	19	/* X1 pipe 8-bit */
-+#define R_TILEPRO_IMM8_Y1	20	/* Y1 pipe 8-bit */
-+#define R_TILEPRO_MT_IMM15_X1	21	/* X1 pipe mtspr */
-+#define R_TILEPRO_MF_IMM15_X1	22	/* X1 pipe mfspr */
-+#define R_TILEPRO_IMM16_X0	23	/* X0 pipe 16-bit */
-+#define R_TILEPRO_IMM16_X1	24	/* X1 pipe 16-bit */
-+#define R_TILEPRO_IMM16_X0_LO	25	/* X0 pipe low 16-bit */
-+#define R_TILEPRO_IMM16_X1_LO	26	/* X1 pipe low 16-bit */
-+#define R_TILEPRO_IMM16_X0_HI	27	/* X0 pipe high 16-bit */
-+#define R_TILEPRO_IMM16_X1_HI	28	/* X1 pipe high 16-bit */
-+#define R_TILEPRO_IMM16_X0_HA	29	/* X0 pipe high 16-bit, adjusted */
-+#define R_TILEPRO_IMM16_X1_HA	30	/* X1 pipe high 16-bit, adjusted */
-+#define R_TILEPRO_IMM16_X0_PCREL 31	/* X0 pipe PC relative 16 bit */
-+#define R_TILEPRO_IMM16_X1_PCREL 32	/* X1 pipe PC relative 16 bit */
-+#define R_TILEPRO_IMM16_X0_LO_PCREL 33	/* X0 pipe PC relative low 16 bit */
-+#define R_TILEPRO_IMM16_X1_LO_PCREL 34	/* X1 pipe PC relative low 16 bit */
-+#define R_TILEPRO_IMM16_X0_HI_PCREL 35	/* X0 pipe PC relative high 16 bit */
-+#define R_TILEPRO_IMM16_X1_HI_PCREL 36	/* X1 pipe PC relative high 16 bit */
-+#define R_TILEPRO_IMM16_X0_HA_PCREL 37	/* X0 pipe PC relative ha() 16 bit */
-+#define R_TILEPRO_IMM16_X1_HA_PCREL 38	/* X1 pipe PC relative ha() 16 bit */
-+#define R_TILEPRO_IMM16_X0_GOT	39	/* X0 pipe 16-bit GOT offset */
-+#define R_TILEPRO_IMM16_X1_GOT	40	/* X1 pipe 16-bit GOT offset */
-+#define R_TILEPRO_IMM16_X0_GOT_LO 41	/* X0 pipe low 16-bit GOT offset */
-+#define R_TILEPRO_IMM16_X1_GOT_LO 42	/* X1 pipe low 16-bit GOT offset */
-+#define R_TILEPRO_IMM16_X0_GOT_HI 43	/* X0 pipe high 16-bit GOT offset */
-+#define R_TILEPRO_IMM16_X1_GOT_HI 44	/* X1 pipe high 16-bit GOT offset */
-+#define R_TILEPRO_IMM16_X0_GOT_HA 45	/* X0 pipe ha() 16-bit GOT offset */
-+#define R_TILEPRO_IMM16_X1_GOT_HA 46	/* X1 pipe ha() 16-bit GOT offset */
-+#define R_TILEPRO_MMSTART_X0	47	/* X0 pipe mm "start" */
-+#define R_TILEPRO_MMEND_X0	48	/* X0 pipe mm "end" */
-+#define R_TILEPRO_MMSTART_X1	49	/* X1 pipe mm "start" */
-+#define R_TILEPRO_MMEND_X1	50	/* X1 pipe mm "end" */
-+#define R_TILEPRO_SHAMT_X0	51	/* X0 pipe shift amount */
-+#define R_TILEPRO_SHAMT_X1	52	/* X1 pipe shift amount */
-+#define R_TILEPRO_SHAMT_Y0	53	/* Y0 pipe shift amount */
-+#define R_TILEPRO_SHAMT_Y1	54	/* Y1 pipe shift amount */
-+#define R_TILEPRO_DEST_IMM8_X1	55	/* X1 pipe destination 8-bit */
-+/* Relocs 56-59 are currently not defined.  */
-+#define R_TILEPRO_TLS_GD_CALL	60	/* "jal" for TLS GD */
-+#define R_TILEPRO_IMM8_X0_TLS_GD_ADD 61	/* X0 pipe "addi" for TLS GD */
-+#define R_TILEPRO_IMM8_X1_TLS_GD_ADD 62	/* X1 pipe "addi" for TLS GD */
-+#define R_TILEPRO_IMM8_Y0_TLS_GD_ADD 63	/* Y0 pipe "addi" for TLS GD */
-+#define R_TILEPRO_IMM8_Y1_TLS_GD_ADD 64	/* Y1 pipe "addi" for TLS GD */
-+#define R_TILEPRO_TLS_IE_LOAD	65	/* "lw_tls" for TLS IE */
-+#define R_TILEPRO_IMM16_X0_TLS_GD 66	/* X0 pipe 16-bit TLS GD offset */
-+#define R_TILEPRO_IMM16_X1_TLS_GD 67	/* X1 pipe 16-bit TLS GD offset */
-+#define R_TILEPRO_IMM16_X0_TLS_GD_LO 68	/* X0 pipe low 16-bit TLS GD offset */
-+#define R_TILEPRO_IMM16_X1_TLS_GD_LO 69	/* X1 pipe low 16-bit TLS GD offset */
-+#define R_TILEPRO_IMM16_X0_TLS_GD_HI 70	/* X0 pipe high 16-bit TLS GD offset */
-+#define R_TILEPRO_IMM16_X1_TLS_GD_HI 71	/* X1 pipe high 16-bit TLS GD offset */
-+#define R_TILEPRO_IMM16_X0_TLS_GD_HA 72	/* X0 pipe ha() 16-bit TLS GD offset */
-+#define R_TILEPRO_IMM16_X1_TLS_GD_HA 73	/* X1 pipe ha() 16-bit TLS GD offset */
-+#define R_TILEPRO_IMM16_X0_TLS_IE 74	/* X0 pipe 16-bit TLS IE offset */
-+#define R_TILEPRO_IMM16_X1_TLS_IE 75	/* X1 pipe 16-bit TLS IE offset */
-+#define R_TILEPRO_IMM16_X0_TLS_IE_LO 76	/* X0 pipe low 16-bit TLS IE offset */
-+#define R_TILEPRO_IMM16_X1_TLS_IE_LO 77	/* X1 pipe low 16-bit TLS IE offset */
-+#define R_TILEPRO_IMM16_X0_TLS_IE_HI 78	/* X0 pipe high 16-bit TLS IE offset */
-+#define R_TILEPRO_IMM16_X1_TLS_IE_HI 79	/* X1 pipe high 16-bit TLS IE offset */
-+#define R_TILEPRO_IMM16_X0_TLS_IE_HA 80	/* X0 pipe ha() 16-bit TLS IE offset */
-+#define R_TILEPRO_IMM16_X1_TLS_IE_HA 81	/* X1 pipe ha() 16-bit TLS IE offset */
-+#define R_TILEPRO_TLS_DTPMOD32	82	/* ID of module containing symbol */
-+#define R_TILEPRO_TLS_DTPOFF32	83	/* Offset in TLS block */
-+#define R_TILEPRO_TLS_TPOFF32	84	/* Offset in static TLS block */
-+#define R_TILEPRO_IMM16_X0_TLS_LE 85	/* X0 pipe 16-bit TLS LE offset */
-+#define R_TILEPRO_IMM16_X1_TLS_LE 86	/* X1 pipe 16-bit TLS LE offset */
-+#define R_TILEPRO_IMM16_X0_TLS_LE_LO 87	/* X0 pipe low 16-bit TLS LE offset */
-+#define R_TILEPRO_IMM16_X1_TLS_LE_LO 88	/* X1 pipe low 16-bit TLS LE offset */
-+#define R_TILEPRO_IMM16_X0_TLS_LE_HI 89	/* X0 pipe high 16-bit TLS LE offset */
-+#define R_TILEPRO_IMM16_X1_TLS_LE_HI 90	/* X1 pipe high 16-bit TLS LE offset */
-+#define R_TILEPRO_IMM16_X0_TLS_LE_HA 91	/* X0 pipe ha() 16-bit TLS LE offset */
-+#define R_TILEPRO_IMM16_X1_TLS_LE_HA 92	/* X1 pipe ha() 16-bit TLS LE offset */
-+
-+#define R_TILEPRO_GNU_VTINHERIT	128	/* GNU C++ vtable hierarchy */
-+#define R_TILEPRO_GNU_VTENTRY	129	/* GNU C++ vtable member usage */
-+
-+#define R_TILEPRO_NUM		130
-+
-+
-+/* TILE-Gx relocations.  */
-+#define R_TILEGX_NONE		0	/* No reloc */
-+#define R_TILEGX_64		1	/* Direct 64 bit */
-+#define R_TILEGX_32		2	/* Direct 32 bit */
-+#define R_TILEGX_16		3	/* Direct 16 bit */
-+#define R_TILEGX_8		4	/* Direct 8 bit */
-+#define R_TILEGX_64_PCREL	5	/* PC relative 64 bit */
-+#define R_TILEGX_32_PCREL	6	/* PC relative 32 bit */
-+#define R_TILEGX_16_PCREL	7	/* PC relative 16 bit */
-+#define R_TILEGX_8_PCREL	8	/* PC relative 8 bit */
-+#define R_TILEGX_HW0		9	/* hword 0 16-bit */
-+#define R_TILEGX_HW1		10	/* hword 1 16-bit */
-+#define R_TILEGX_HW2		11	/* hword 2 16-bit */
-+#define R_TILEGX_HW3		12	/* hword 3 16-bit */
-+#define R_TILEGX_HW0_LAST	13	/* last hword 0 16-bit */
-+#define R_TILEGX_HW1_LAST	14	/* last hword 1 16-bit */
-+#define R_TILEGX_HW2_LAST	15	/* last hword 2 16-bit */
-+#define R_TILEGX_COPY		16	/* Copy relocation */
-+#define R_TILEGX_GLOB_DAT	17	/* Create GOT entry */
-+#define R_TILEGX_JMP_SLOT	18	/* Create PLT entry */
-+#define R_TILEGX_RELATIVE	19	/* Adjust by program base */
-+#define R_TILEGX_BROFF_X1	20	/* X1 pipe branch offset */
-+#define R_TILEGX_JUMPOFF_X1	21	/* X1 pipe jump offset */
-+#define R_TILEGX_JUMPOFF_X1_PLT	22	/* X1 pipe jump offset to PLT */
-+#define R_TILEGX_IMM8_X0	23	/* X0 pipe 8-bit */
-+#define R_TILEGX_IMM8_Y0	24	/* Y0 pipe 8-bit */
-+#define R_TILEGX_IMM8_X1	25	/* X1 pipe 8-bit */
-+#define R_TILEGX_IMM8_Y1	26	/* Y1 pipe 8-bit */
-+#define R_TILEGX_DEST_IMM8_X1	27	/* X1 pipe destination 8-bit */
-+#define R_TILEGX_MT_IMM14_X1	28	/* X1 pipe mtspr */
-+#define R_TILEGX_MF_IMM14_X1	29	/* X1 pipe mfspr */
-+#define R_TILEGX_MMSTART_X0	30	/* X0 pipe mm "start" */
-+#define R_TILEGX_MMEND_X0	31	/* X0 pipe mm "end" */
-+#define R_TILEGX_SHAMT_X0	32	/* X0 pipe shift amount */
-+#define R_TILEGX_SHAMT_X1	33	/* X1 pipe shift amount */
-+#define R_TILEGX_SHAMT_Y0	34	/* Y0 pipe shift amount */
-+#define R_TILEGX_SHAMT_Y1	35	/* Y1 pipe shift amount */
-+#define R_TILEGX_IMM16_X0_HW0	36	/* X0 pipe hword 0 */
-+#define R_TILEGX_IMM16_X1_HW0	37	/* X1 pipe hword 0 */
-+#define R_TILEGX_IMM16_X0_HW1	38	/* X0 pipe hword 1 */
-+#define R_TILEGX_IMM16_X1_HW1	39	/* X1 pipe hword 1 */
-+#define R_TILEGX_IMM16_X0_HW2	40	/* X0 pipe hword 2 */
-+#define R_TILEGX_IMM16_X1_HW2	41	/* X1 pipe hword 2 */
-+#define R_TILEGX_IMM16_X0_HW3	42	/* X0 pipe hword 3 */
-+#define R_TILEGX_IMM16_X1_HW3	43	/* X1 pipe hword 3 */
-+#define R_TILEGX_IMM16_X0_HW0_LAST 44	/* X0 pipe last hword 0 */
-+#define R_TILEGX_IMM16_X1_HW0_LAST 45	/* X1 pipe last hword 0 */
-+#define R_TILEGX_IMM16_X0_HW1_LAST 46	/* X0 pipe last hword 1 */
-+#define R_TILEGX_IMM16_X1_HW1_LAST 47	/* X1 pipe last hword 1 */
-+#define R_TILEGX_IMM16_X0_HW2_LAST 48	/* X0 pipe last hword 2 */
-+#define R_TILEGX_IMM16_X1_HW2_LAST 49	/* X1 pipe last hword 2 */
-+#define R_TILEGX_IMM16_X0_HW0_PCREL 50	/* X0 pipe PC relative hword 0 */
-+#define R_TILEGX_IMM16_X1_HW0_PCREL 51	/* X1 pipe PC relative hword 0 */
-+#define R_TILEGX_IMM16_X0_HW1_PCREL 52	/* X0 pipe PC relative hword 1 */
-+#define R_TILEGX_IMM16_X1_HW1_PCREL 53	/* X1 pipe PC relative hword 1 */
-+#define R_TILEGX_IMM16_X0_HW2_PCREL 54	/* X0 pipe PC relative hword 2 */
-+#define R_TILEGX_IMM16_X1_HW2_PCREL 55	/* X1 pipe PC relative hword 2 */
-+#define R_TILEGX_IMM16_X0_HW3_PCREL 56	/* X0 pipe PC relative hword 3 */
-+#define R_TILEGX_IMM16_X1_HW3_PCREL 57	/* X1 pipe PC relative hword 3 */
-+#define R_TILEGX_IMM16_X0_HW0_LAST_PCREL 58 /* X0 pipe PC-rel last hword 0 */
-+#define R_TILEGX_IMM16_X1_HW0_LAST_PCREL 59 /* X1 pipe PC-rel last hword 0 */
-+#define R_TILEGX_IMM16_X0_HW1_LAST_PCREL 60 /* X0 pipe PC-rel last hword 1 */
-+#define R_TILEGX_IMM16_X1_HW1_LAST_PCREL 61 /* X1 pipe PC-rel last hword 1 */
-+#define R_TILEGX_IMM16_X0_HW2_LAST_PCREL 62 /* X0 pipe PC-rel last hword 2 */
-+#define R_TILEGX_IMM16_X1_HW2_LAST_PCREL 63 /* X1 pipe PC-rel last hword 2 */
-+#define R_TILEGX_IMM16_X0_HW0_GOT 64	/* X0 pipe hword 0 GOT offset */
-+#define R_TILEGX_IMM16_X1_HW0_GOT 65	/* X1 pipe hword 0 GOT offset */
-+/* Relocs 66-71 are currently not defined.  */
-+#define R_TILEGX_IMM16_X0_HW0_LAST_GOT 72 /* X0 pipe last hword 0 GOT offset */
-+#define R_TILEGX_IMM16_X1_HW0_LAST_GOT 73 /* X1 pipe last hword 0 GOT offset */
-+#define R_TILEGX_IMM16_X0_HW1_LAST_GOT 74 /* X0 pipe last hword 1 GOT offset */
-+#define R_TILEGX_IMM16_X1_HW1_LAST_GOT 75 /* X1 pipe last hword 1 GOT offset */
-+/* Relocs 76-77 are currently not defined.  */
-+#define R_TILEGX_IMM16_X0_HW0_TLS_GD 78	/* X0 pipe hword 0 TLS GD offset */
-+#define R_TILEGX_IMM16_X1_HW0_TLS_GD 79	/* X1 pipe hword 0 TLS GD offset */
-+#define R_TILEGX_IMM16_X0_HW0_TLS_LE 80	/* X0 pipe hword 0 TLS LE offset */
-+#define R_TILEGX_IMM16_X1_HW0_TLS_LE 81	/* X1 pipe hword 0 TLS LE offset */
-+#define R_TILEGX_IMM16_X0_HW0_LAST_TLS_LE 82 /* X0 pipe last hword 0 LE off */
-+#define R_TILEGX_IMM16_X1_HW0_LAST_TLS_LE 83 /* X1 pipe last hword 0 LE off */
-+#define R_TILEGX_IMM16_X0_HW1_LAST_TLS_LE 84 /* X0 pipe last hword 1 LE off */
-+#define R_TILEGX_IMM16_X1_HW1_LAST_TLS_LE 85 /* X1 pipe last hword 1 LE off */
-+#define R_TILEGX_IMM16_X0_HW0_LAST_TLS_GD 86 /* X0 pipe last hword 0 GD off */
-+#define R_TILEGX_IMM16_X1_HW0_LAST_TLS_GD 87 /* X1 pipe last hword 0 GD off */
-+#define R_TILEGX_IMM16_X0_HW1_LAST_TLS_GD 88 /* X0 pipe last hword 1 GD off */
-+#define R_TILEGX_IMM16_X1_HW1_LAST_TLS_GD 89 /* X1 pipe last hword 1 GD off */
-+/* Relocs 90-91 are currently not defined.  */
-+#define R_TILEGX_IMM16_X0_HW0_TLS_IE 92	/* X0 pipe hword 0 TLS IE offset */
-+#define R_TILEGX_IMM16_X1_HW0_TLS_IE 93	/* X1 pipe hword 0 TLS IE offset */
-+/* Relocs 94-99 are currently not defined.  */
-+#define R_TILEGX_IMM16_X0_HW0_LAST_TLS_IE 100 /* X0 pipe last hword 0 IE off */
-+#define R_TILEGX_IMM16_X1_HW0_LAST_TLS_IE 101 /* X1 pipe last hword 0 IE off */
-+#define R_TILEGX_IMM16_X0_HW1_LAST_TLS_IE 102 /* X0 pipe last hword 1 IE off */
-+#define R_TILEGX_IMM16_X1_HW1_LAST_TLS_IE 103 /* X1 pipe last hword 1 IE off */
-+/* Relocs 104-105 are currently not defined.  */
-+#define R_TILEGX_TLS_DTPMOD64	106	/* 64-bit ID of symbol's module */
-+#define R_TILEGX_TLS_DTPOFF64	107	/* 64-bit offset in TLS block */
-+#define R_TILEGX_TLS_TPOFF64	108	/* 64-bit offset in static TLS block */
-+#define R_TILEGX_TLS_DTPMOD32	109	/* 32-bit ID of symbol's module */
-+#define R_TILEGX_TLS_DTPOFF32	110	/* 32-bit offset in TLS block */
-+#define R_TILEGX_TLS_TPOFF32	111	/* 32-bit offset in static TLS block */
-+#define R_TILEGX_TLS_GD_CALL	112	/* "jal" for TLS GD */
-+#define R_TILEGX_IMM8_X0_TLS_GD_ADD 113	/* X0 pipe "addi" for TLS GD */
-+#define R_TILEGX_IMM8_X1_TLS_GD_ADD 114	/* X1 pipe "addi" for TLS GD */
-+#define R_TILEGX_IMM8_Y0_TLS_GD_ADD 115	/* Y0 pipe "addi" for TLS GD */
-+#define R_TILEGX_IMM8_Y1_TLS_GD_ADD 116	/* Y1 pipe "addi" for TLS GD */
-+#define R_TILEGX_TLS_IE_LOAD	117	/* "ld_tls" for TLS IE */
-+#define R_TILEGX_IMM8_X0_TLS_ADD 118	/* X0 pipe "addi" for TLS GD/IE */
-+#define R_TILEGX_IMM8_X1_TLS_ADD 119	/* X1 pipe "addi" for TLS GD/IE */
-+#define R_TILEGX_IMM8_Y0_TLS_ADD 120	/* Y0 pipe "addi" for TLS GD/IE */
-+#define R_TILEGX_IMM8_Y1_TLS_ADD 121	/* Y1 pipe "addi" for TLS GD/IE */
-+
-+#define R_TILEGX_GNU_VTINHERIT	128	/* GNU C++ vtable hierarchy */
-+#define R_TILEGX_GNU_VTENTRY	129	/* GNU C++ vtable member usage */
-+
-+#define R_TILEGX_NUM		130
-+
-+#endif	/* elf.h */
---- a/scripts/mod/mk_elfconfig.c
-+++ b/scripts/mod/mk_elfconfig.c
-@@ -2,7 +2,11 @@
- #include <stdio.h>
- #include <stdlib.h>
- #include <string.h>
-+#ifndef __APPLE__
- #include <elf.h>
-+#else
-+#include "elf.h"
-+#endif
- 
- int
- main(int argc, char **argv)
---- a/scripts/mod/modpost.h
-+++ b/scripts/mod/modpost.h
-@@ -8,7 +8,11 @@
- #include <sys/mman.h>
- #include <fcntl.h>
- #include <unistd.h>
-+#if !(defined(__APPLE__) || defined(__CYGWIN__))
- #include <elf.h>
-+#else
-+#include "elf.h"
-+#endif
- 
- #include "elfconfig.h"
- 
--- a/target/linux/generic/hack-4.19/212-byteshift_portability.patch	2022-03-22 08:54:47.209464673 +0800
+++ b/target/linux/generic/hack-4.19/212-byteshift_portability.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,65 +0,0 @@
-From 48232d3d931c95953ce2ddfe7da7bb164aef6a73 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 17:03:16 +0200
-Subject: linux-3.6: fix portability of some includes files in tools/ used on the host
-
-lede-commit: 6040b1d29ab1f047c5e49b748abcb6a3196add28
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- tools/include/tools/be_byteshift.h |  4 ++++
- tools/include/tools/le_byteshift.h |  4 ++++
- tools/include/tools/linux_types.h  | 22 ++++++++++++++++++++++
- 3 files changed, 30 insertions(+)
- create mode 100644 tools/include/tools/linux_types.h
-
---- a/tools/include/tools/be_byteshift.h
-+++ b/tools/include/tools/be_byteshift.h
-@@ -2,6 +2,10 @@
- #ifndef _TOOLS_BE_BYTESHIFT_H
- #define _TOOLS_BE_BYTESHIFT_H
- 
-+#ifndef __linux__
-+#include "linux_types.h"
-+#endif
-+
- #include <stdint.h>
- 
- static inline uint16_t __get_unaligned_be16(const uint8_t *p)
---- a/tools/include/tools/le_byteshift.h
-+++ b/tools/include/tools/le_byteshift.h
-@@ -2,6 +2,10 @@
- #ifndef _TOOLS_LE_BYTESHIFT_H
- #define _TOOLS_LE_BYTESHIFT_H
- 
-+#ifndef __linux__
-+#include "linux_types.h"
-+#endif
-+
- #include <stdint.h>
- 
- static inline uint16_t __get_unaligned_le16(const uint8_t *p)
---- /dev/null
-+++ b/tools/include/tools/linux_types.h
-@@ -0,0 +1,22 @@
-+#ifndef __LINUX_TYPES_H
-+#define __LINUX_TYPES_H
-+
-+#include <stdint.h>
-+
-+typedef uint8_t __u8;
-+typedef uint8_t __be8;
-+typedef uint8_t __le8;
-+
-+typedef uint16_t __u16;
-+typedef uint16_t __be16;
-+typedef uint16_t __le16;
-+
-+typedef uint32_t __u32;
-+typedef uint32_t __be32;
-+typedef uint32_t __le32;
-+
-+typedef uint64_t __u64;
-+typedef uint64_t __be64;
-+typedef uint64_t __le64;
-+
-+#endif
--- a/target/linux/generic/hack-4.19/214-spidev_h_portability.patch	2022-03-22 08:54:47.210464674 +0800
+++ b/target/linux/generic/hack-4.19/214-spidev_h_portability.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,24 +0,0 @@
-From be9be95ff10e16a5b4ad36f903978d0cc5747024 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 17:04:08 +0200
-Subject: kernel: fix linux/spi/spidev.h portability issues with musl
-
-Felix will try to get this define included into musl
-
-lede-commit: 795e7cf60de19e7a076a46874fab7bb88b43bbff
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/uapi/linux/spi/spidev.h | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/include/uapi/linux/spi/spidev.h
-+++ b/include/uapi/linux/spi/spidev.h
-@@ -113,7 +113,7 @@ struct spi_ioc_transfer {
- 
- /* not all platforms use <asm-generic/ioctl.h> or _IOC_TYPECHECK() ... */
- #define SPI_MSGSIZE(N) \
--	((((N)*(sizeof (struct spi_ioc_transfer))) < (1 << _IOC_SIZEBITS)) \
-+	((((N)*(sizeof (struct spi_ioc_transfer))) < (1 << 13)) \
- 		? ((N)*(sizeof (struct spi_ioc_transfer))) : 0)
- #define SPI_IOC_MESSAGE(N) _IOW(SPI_IOC_MAGIC, 0, char[SPI_MSGSIZE(N)])
- 
--- a/target/linux/generic/hack-4.19/220-gc_sections.patch	2022-03-22 08:54:47.210464674 +0800
+++ b/target/linux/generic/hack-4.19/220-gc_sections.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,192 +0,0 @@
-From e3d8676f5722b7622685581e06e8f53e6138e3ab Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 15 Jul 2017 23:42:36 +0200
-Subject: use -ffunction-sections, -fdata-sections and --gc-sections
-
-In combination with kernel symbol export stripping this significantly reduces
-the kernel image size. Used on both ARM and MIPS architectures.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
-Signed-off-by: Jonas Gorski <jogo@openwrt.org>
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- Makefile                          | 10 +++----
- arch/arm/Kconfig                  |  1 +
- arch/arm/boot/compressed/Makefile |  1 +
- arch/arm/kernel/vmlinux.lds.S     | 26 ++++++++--------
- arch/mips/Kconfig                 |  1 +
- arch/mips/kernel/vmlinux.lds.S    |  4 +--
- include/asm-generic/vmlinux.lds.h | 63 ++++++++++++++++++++-------------------
- 7 files changed, 55 insertions(+), 51 deletions(-)
-
---- a/Makefile
-+++ b/Makefile
-@@ -294,6 +294,11 @@ else
- scripts/Kbuild.include: ;
- include scripts/Kbuild.include
- 
-+ifdef CONFIG_LD_DEAD_CODE_DATA_ELIMINATION
-+KBUILD_CFLAGS_KERNEL += -ffunction-sections -fdata-sections
-+LDFLAGS_vmlinux += --gc-sections
-+endif
-+
- # Read KERNELRELEASE from include/config/kernel.release (if it exists)
- KERNELRELEASE = $(shell cat include/config/kernel.release 2> /dev/null)
- KERNELVERSION = $(VERSION)$(if $(PATCHLEVEL),.$(PATCHLEVEL)$(if $(SUBLEVEL),.$(SUBLEVEL)))$(EXTRAVERSION)
-@@ -782,11 +787,6 @@ ifdef CONFIG_DEBUG_SECTION_MISMATCH
- KBUILD_CFLAGS += $(call cc-option, -fno-inline-functions-called-once)
- endif
- 
--ifdef CONFIG_LD_DEAD_CODE_DATA_ELIMINATION
--KBUILD_CFLAGS_KERNEL += -ffunction-sections -fdata-sections
--LDFLAGS_vmlinux += --gc-sections
--endif
--
- # arch Makefile may override CC so keep this after arch Makefile is included
- NOSTDINC_FLAGS += -nostdinc -isystem $(shell $(CC) -print-file-name=include)
- 
---- a/arch/arm/Kconfig
-+++ b/arch/arm/Kconfig
-@@ -98,6 +98,7 @@ config ARM
- 	select HAVE_UID16
- 	select HAVE_VIRT_CPU_ACCOUNTING_GEN
- 	select IRQ_FORCED_THREADING
-+	select HAVE_LD_DEAD_CODE_DATA_ELIMINATION
- 	select MODULES_USE_ELF_REL
- 	select NEED_DMA_MAP_STATE
- 	select NO_BOOTMEM
---- a/arch/arm/boot/compressed/Makefile
-+++ b/arch/arm/boot/compressed/Makefile
-@@ -106,6 +106,7 @@ ifeq ($(CONFIG_FUNCTION_TRACER),y)
- ORIG_CFLAGS := $(KBUILD_CFLAGS)
- KBUILD_CFLAGS = $(subst -pg, , $(ORIG_CFLAGS))
- endif
-+KBUILD_CFLAGS_KERNEL := $(patsubst -f%-sections,,$(KBUILD_CFLAGS_KERNEL))
- 
- # -fstack-protector-strong triggers protection checks in this code,
- # but it is being used too early to link to meaningful stack_chk logic.
---- a/arch/arm/kernel/vmlinux.lds.S
-+++ b/arch/arm/kernel/vmlinux.lds.S
-@@ -100,24 +100,24 @@ SECTIONS
- 	}
- 	.init.arch.info : {
- 		__arch_info_begin = .;
--		*(.arch.info.init)
-+		KEEP(*(.arch.info.init))
- 		__arch_info_end = .;
- 	}
- 	.init.tagtable : {
- 		__tagtable_begin = .;
--		*(.taglist.init)
-+		KEEP(*(.taglist.init))
- 		__tagtable_end = .;
- 	}
- #ifdef CONFIG_SMP_ON_UP
- 	.init.smpalt : {
- 		__smpalt_begin = .;
--		*(.alt.smp.init)
-+		KEEP(*(.alt.smp.init))
- 		__smpalt_end = .;
- 	}
- #endif
- 	.init.pv_table : {
- 		__pv_table_begin = .;
--		*(.pv_table)
-+		KEEP(*(.pv_table))
- 		__pv_table_end = .;
- 	}
- 
---- a/arch/arm/kernel/vmlinux.lds.h
-+++ b/arch/arm/kernel/vmlinux.lds.h
-@@ -22,13 +22,13 @@
- #define ARM_MMU_DISCARD(x)
- #else
- #define ARM_MMU_KEEP(x)
--#define ARM_MMU_DISCARD(x)	x
-+#define ARM_MMU_DISCARD(x)	KEEP(x)
- #endif
- 
- #define PROC_INFO							\
- 		. = ALIGN(4);						\
- 		__proc_info_begin = .;					\
--		*(.proc.info.init)					\
-+		KEEP(*(.proc.info.init))				\
- 		__proc_info_end = .;
- 
- #define HYPERVISOR_TEXT							\
-@@ -39,11 +39,11 @@
- #define IDMAP_TEXT							\
- 		ALIGN_FUNCTION();					\
- 		__idmap_text_start = .;					\
--		*(.idmap.text)						\
-+		KEEP(*(.idmap.text))					\
- 		__idmap_text_end = .;					\
- 		. = ALIGN(PAGE_SIZE);					\
- 		__hyp_idmap_text_start = .;				\
--		*(.hyp.idmap.text)					\
-+		KEEP(*(.hyp.idmap.text))				\
- 		__hyp_idmap_text_end = .;
- 
- #define ARM_DISCARD							\
-@@ -86,12 +86,12 @@
- 	. = ALIGN(8);							\
- 	.ARM.unwind_idx : {						\
- 		__start_unwind_idx = .;					\
--		*(.ARM.exidx*)						\
-+		KEEP(*(.ARM.exidx*))					\
- 		__stop_unwind_idx = .;					\
- 	}								\
- 	.ARM.unwind_tab : {						\
- 		__start_unwind_tab = .;					\
--		*(.ARM.extab*)						\
-+		KEEP(*(.ARM.extab*))					\
- 		__stop_unwind_tab = .;					\
- 	}
- 
-@@ -102,14 +102,14 @@
- #define ARM_VECTORS							\
- 	__vectors_start = .;						\
- 	.vectors 0xffff0000 : AT(__vectors_start) {			\
--		*(.vectors)						\
-+		KEEP(*(.vectors))					\
- 	}								\
- 	. = __vectors_start + SIZEOF(.vectors);				\
- 	__vectors_end = .;						\
- 									\
- 	__stubs_start = .;						\
- 	.stubs ADDR(.vectors) + 0x1000 : AT(__stubs_start) {		\
--		*(.stubs)						\
-+		KEEP(*(.stubs))						\
- 	}								\
- 	. = __stubs_start + SIZEOF(.stubs);				\
- 	__stubs_end = .;						\
---- a/arch/mips/Kconfig
-+++ b/arch/mips/Kconfig
-@@ -43,6 +43,7 @@ config MIPS
- 	select HAVE_ARCH_TRANSPARENT_HUGEPAGE if CPU_SUPPORTS_HUGEPAGES && 64BIT
- 	select HAVE_CBPF_JIT if (!64BIT && !CPU_MICROMIPS)
- 	select HAVE_EBPF_JIT if (64BIT && !CPU_MICROMIPS)
-+	select HAVE_LD_DEAD_CODE_DATA_ELIMINATION
- 	select HAVE_CONTEXT_TRACKING
- 	select HAVE_COPY_THREAD_TLS
- 	select HAVE_C_RECORDMCOUNT
---- a/arch/mips/kernel/vmlinux.lds.S
-+++ b/arch/mips/kernel/vmlinux.lds.S
-@@ -72,7 +72,7 @@ SECTIONS
- 	/* Exception table for data bus errors */
- 	__dbe_table : {
- 		__start___dbe_table = .;
--		*(__dbe_table)
-+		KEEP(*(__dbe_table))
- 		__stop___dbe_table = .;
- 	}
- 
-@@ -123,7 +123,7 @@ SECTIONS
- 	. = ALIGN(4);
- 	.mips.machines.init : AT(ADDR(.mips.machines.init) - LOAD_OFFSET) {
- 		__mips_machines_start = .;
--		*(.mips.machines.init)
-+		KEEP(*(.mips.machines.init))
- 		__mips_machines_end = .;
- 	}
- 
--- a/target/linux/generic/hack-4.19/221-module_exports.patch	2022-03-22 08:54:47.211464676 +0800
+++ b/target/linux/generic/hack-4.19/221-module_exports.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,101 +0,0 @@
-From b14784e7883390c20ed3ff904892255404a5914b Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 17:05:53 +0200
-Subject: add an optional config option for stripping all unnecessary symbol exports from the kernel image
-
-lede-commit: bb5a40c64b7c4f4848509fa0a6625055fc9e66cc
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/asm-generic/vmlinux.lds.h | 18 +++++++++++++++---
- include/linux/export.h            |  9 ++++++++-
- scripts/Makefile.build            |  2 +-
- 3 files changed, 24 insertions(+), 5 deletions(-)
-
---- a/include/asm-generic/vmlinux.lds.h
-+++ b/include/asm-generic/vmlinux.lds.h
-@@ -54,6 +54,16 @@
- #define LOAD_OFFSET 0
- #endif
- 
-+#ifndef SYMTAB_KEEP
-+#define SYMTAB_KEEP KEEP(*(SORT(___ksymtab+*)))
-+#define SYMTAB_KEEP_GPL KEEP(*(SORT(___ksymtab_gpl+*)))
-+#endif
-+
-+#ifndef SYMTAB_DISCARD
-+#define SYMTAB_DISCARD
-+#define SYMTAB_DISCARD_GPL
-+#endif
-+
- /* Align . to a 8 byte boundary equals to maximum function alignment. */
- #define ALIGN_FUNCTION()  . = ALIGN(8)
- 
-@@ -372,14 +382,14 @@
- 	/* Kernel symbol table: Normal symbols */			\
- 	__ksymtab         : AT(ADDR(__ksymtab) - LOAD_OFFSET) {		\
- 		__start___ksymtab = .;					\
--		KEEP(*(SORT(___ksymtab+*)))				\
-+		SYMTAB_KEEP						\
- 		__stop___ksymtab = .;					\
- 	}								\
- 									\
- 	/* Kernel symbol table: GPL-only symbols */			\
- 	__ksymtab_gpl     : AT(ADDR(__ksymtab_gpl) - LOAD_OFFSET) {	\
- 		__start___ksymtab_gpl = .;				\
--		KEEP(*(SORT(___ksymtab_gpl+*)))				\
-+		SYMTAB_KEEP_GPL						\
- 		__stop___ksymtab_gpl = .;				\
- 	}								\
- 									\
-@@ -441,7 +451,7 @@
- 									\
- 	/* Kernel symbol table: strings */				\
-         __ksymtab_strings : AT(ADDR(__ksymtab_strings) - LOAD_OFFSET) {	\
--		*(__ksymtab_strings)					\
-+		*(__ksymtab_strings+*)					\
- 	}								\
- 									\
- 	/* __*init sections */						\
-@@ -841,6 +851,8 @@
- 	EXIT_TEXT							\
- 	EXIT_DATA							\
- 	EXIT_CALL							\
-+	SYMTAB_DISCARD							\
-+	SYMTAB_DISCARD_GPL						\
- 	*(.discard)							\
- 	*(.discard.*)							\
- 	}
---- a/include/linux/export.h
-+++ b/include/linux/export.h
-@@ -74,12 +74,19 @@ struct kernel_symbol {
- };
- #endif
- 
-+#ifdef MODULE
-+#define __EXPORT_SUFFIX(sym)
-+#else
-+#define __EXPORT_SUFFIX(sym) "+" #sym
-+#endif
-+
- /* For every exported symbol, place a struct in the __ksymtab section */
- #define ___EXPORT_SYMBOL(sym, sec)					\
- 	extern typeof(sym) sym;						\
- 	__CRC_SYMBOL(sym, sec)						\
- 	static const char __kstrtab_##sym[]				\
--	__attribute__((section("__ksymtab_strings"), used, aligned(1)))	\
-+	__attribute__((section("__ksymtab_strings"			\
-+	  __EXPORT_SUFFIX(sym)), used, aligned(1)))			\
- 	= #sym;								\
- 	__KSYMTAB_ENTRY(sym, sec)
- 
---- a/scripts/Makefile.build
-+++ b/scripts/Makefile.build
-@@ -408,7 +408,7 @@ targets += $(extra-y) $(MAKECMDGOALS) $(
- # Linker scripts preprocessor (.lds.S -> .lds)
- # ---------------------------------------------------------------------------
- quiet_cmd_cpp_lds_S = LDS     $@
--      cmd_cpp_lds_S = $(CPP) $(cpp_flags) -P -U$(ARCH) \
-+      cmd_cpp_lds_S = $(CPP) $(EXTRA_LDSFLAGS) $(cpp_flags) -P -U$(ARCH) \
- 	                     -D__ASSEMBLY__ -DLINKER_SCRIPT -o $@ $<
- 
- $(obj)/%.lds: $(src)/%.lds.S FORCE
--- a/target/linux/generic/hack-4.19/230-openwrt_lzma_options.patch	2022-03-22 08:54:47.211464676 +0800
+++ b/target/linux/generic/hack-4.19/230-openwrt_lzma_options.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,71 +0,0 @@
-From b3d00b452467f621317953d9e4c6f9ae8dcfd271 Mon Sep 17 00:00:00 2001
-From: Imre Kaloz <kaloz@openwrt.org>
-Date: Fri, 7 Jul 2017 17:06:55 +0200
-Subject: use the openwrt lzma options for now
-
-lede-commit: 548de949f392049420a6a1feeef118b30ab8ea8c
-Signed-off-by: Imre Kaloz <kaloz@openwrt.org>
----
- lib/decompress.c              |  1 +
- scripts/Makefile.lib          |  2 +-
- usr/gen_initramfs_list.sh | 10 +++++-----
- 3 files changed, 7 insertions(+), 6 deletions(-)
-
---- a/lib/decompress.c
-+++ b/lib/decompress.c
-@@ -49,6 +49,7 @@ static const struct compress_format comp
- 	{ {0x1f, 0x9e}, "gzip", gunzip },
- 	{ {0x42, 0x5a}, "bzip2", bunzip2 },
- 	{ {0x5d, 0x00}, "lzma", unlzma },
-+	{ {0x6d, 0x00}, "lzma-openwrt", unlzma },
- 	{ {0xfd, 0x37}, "xz", unxz },
- 	{ {0x89, 0x4c}, "lzo", unlzo },
- 	{ {0x02, 0x21}, "lz4", unlz4 },
---- a/scripts/Makefile.lib
-+++ b/scripts/Makefile.lib
-@@ -324,7 +324,7 @@ cmd_bzip2 = (cat $(filter-out FORCE,$^)
- 
- quiet_cmd_lzma = LZMA    $@
- cmd_lzma = (cat $(filter-out FORCE,$^) | \
--	lzma -9 && $(call size_append, $(filter-out FORCE,$^))) > $@ || \
-+	lzma e -d20 -lc1 -lp2 -pb2 -eos -si -so && $(call size_append, $(filter-out FORCE,$^))) > $@ || \
- 	(rm -f $@ ; false)
- 
- quiet_cmd_lzo = LZO     $@
---- a/usr/gen_initramfs_list.sh
-+++ b/usr/gen_initramfs_list.sh
-@@ -229,7 +229,7 @@ cpio_list=
- output="/dev/stdout"
- output_file=""
- is_cpio_compressed=
--compr="gzip -n -9 -f"
-+compr="gzip -n -9 -f -"
- 
- arg="$1"
- case "$arg" in
-@@ -245,13 +245,13 @@ case "$arg" in
- 		output=${cpio_list}
- 		echo "$output_file" | grep -q "\.gz$" \
-                 && [ -x "`which gzip 2> /dev/null`" ] \
--                && compr="gzip -n -9 -f"
-+                && compr="gzip -n -9 -f -"
- 		echo "$output_file" | grep -q "\.bz2$" \
-                 && [ -x "`which bzip2 2> /dev/null`" ] \
--                && compr="bzip2 -9 -f"
-+                && compr="bzip2 -9 -f -"
- 		echo "$output_file" | grep -q "\.lzma$" \
-                 && [ -x "`which lzma 2> /dev/null`" ] \
--                && compr="lzma -9 -f"
-+                && compr="lzma e -d20 -lc1 -lp2 -pb2 -eos -si -so"
- 		echo "$output_file" | grep -q "\.xz$" \
-                 && [ -x "`which xz 2> /dev/null`" ] \
-                 && compr="xz --check=crc32 --lzma2=dict=1MiB"
-@@ -320,7 +320,7 @@ if [ ! -z ${output_file} ]; then
- 	if [ "${is_cpio_compressed}" = "compressed" ]; then
- 		cat ${cpio_tfile} > ${output_file}
- 	else
--		(cat ${cpio_tfile} | ${compr}  - > ${output_file}) \
-+		(cat ${cpio_tfile} | ${compr} > ${output_file}) \
- 		|| (rm -f ${output_file} ; false)
- 	fi
- 	[ -z ${cpio_file} ] && rm ${cpio_tfile}
--- a/target/linux/generic/hack-4.19/250-netfilter_depends.patch	2022-03-22 08:54:47.211464676 +0800
+++ b/target/linux/generic/hack-4.19/250-netfilter_depends.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,27 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: hack: net: remove bogus netfilter dependencies
-
-lede-commit: 589d2a377dee27d206fc3725325309cf649e4df6
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- net/netfilter/Kconfig | 2 --
- 1 file changed, 2 deletions(-)
-
---- a/net/netfilter/Kconfig
-+++ b/net/netfilter/Kconfig
-@@ -241,7 +241,6 @@ config NF_CONNTRACK_FTP
- 
- config NF_CONNTRACK_H323
- 	tristate "H.323 protocol support"
--	depends on IPV6 || IPV6=n
- 	depends on NETFILTER_ADVANCED
- 	help
- 	  H.323 is a VoIP signalling protocol from ITU-T. As one of the most
-@@ -1077,7 +1076,6 @@ config NETFILTER_XT_TARGET_SECMARK
- 
- config NETFILTER_XT_TARGET_TCPMSS
- 	tristate '"TCPMSS" target support'
--	depends on IPV6 || IPV6=n
- 	default m if NETFILTER_ADVANCED=n
- 	---help---
- 	  This option adds a `TCPMSS' target, which allows you to alter the
--- a/target/linux/generic/hack-4.19/251-sound_kconfig.patch	2022-03-22 08:54:47.211464676 +0800
+++ b/target/linux/generic/hack-4.19/251-sound_kconfig.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,197 +0,0 @@
-From da3c50704f14132f4adf80d48e9a4cd5d46e54c9 Mon Sep 17 00:00:00 2001
-From: John Crispin <john@phrozen.org>
-Date: Fri, 7 Jul 2017 17:09:21 +0200
-Subject: kconfig: owrt specifc dependencies
-
-Signed-off-by: John Crispin <john@phrozen.org>
----
- crypto/Kconfig        | 10 +++++-----
- drivers/bcma/Kconfig  |  1 +
- drivers/ssb/Kconfig   |  3 ++-
- lib/Kconfig           |  8 ++++----
- net/netfilter/Kconfig |  2 +-
- net/wireless/Kconfig  | 17 ++++++++++-------
- sound/core/Kconfig    |  4 ++--
- 7 files changed, 25 insertions(+), 20 deletions(-)
-
---- a/crypto/Kconfig
-+++ b/crypto/Kconfig
-@@ -33,7 +33,7 @@ config CRYPTO_FIPS
- 	  this is.
- 
- config CRYPTO_ALGAPI
--	tristate
-+	tristate "ALGAPI"
- 	select CRYPTO_ALGAPI2
- 	help
- 	  This option provides the API for cryptographic algorithms.
-@@ -42,7 +42,7 @@ config CRYPTO_ALGAPI2
- 	tristate
- 
- config CRYPTO_AEAD
--	tristate
-+	tristate "AEAD"
- 	select CRYPTO_AEAD2
- 	select CRYPTO_ALGAPI
- 
-@@ -53,7 +53,7 @@ config CRYPTO_AEAD2
- 	select CRYPTO_RNG2
- 
- config CRYPTO_BLKCIPHER
--	tristate
-+	tristate "BLKCIPHER"
- 	select CRYPTO_BLKCIPHER2
- 	select CRYPTO_ALGAPI
- 
-@@ -64,7 +64,7 @@ config CRYPTO_BLKCIPHER2
- 	select CRYPTO_WORKQUEUE
- 
- config CRYPTO_HASH
--	tristate
-+	tristate "HASH"
- 	select CRYPTO_HASH2
- 	select CRYPTO_ALGAPI
- 
-@@ -73,7 +73,7 @@ config CRYPTO_HASH2
- 	select CRYPTO_ALGAPI2
- 
- config CRYPTO_RNG
--	tristate
-+	tristate "RNG"
- 	select CRYPTO_RNG2
- 	select CRYPTO_ALGAPI
- 
---- a/drivers/bcma/Kconfig
-+++ b/drivers/bcma/Kconfig
-@@ -16,6 +16,7 @@ if BCMA
- # Support for Block-I/O. SELECT this from the driver that needs it.
- config BCMA_BLOCKIO
- 	bool
-+	default y
- 
- config BCMA_HOST_PCI_POSSIBLE
- 	bool
---- a/drivers/ssb/Kconfig
-+++ b/drivers/ssb/Kconfig
-@@ -28,6 +28,7 @@ config SSB_SPROM
- config SSB_BLOCKIO
- 	bool
- 	depends on SSB
-+	default y
- 
- config SSB_PCIHOST_POSSIBLE
- 	bool
-@@ -48,7 +49,7 @@ config SSB_PCIHOST
- config SSB_B43_PCI_BRIDGE
- 	bool
- 	depends on SSB_PCIHOST
--	default n
-+	default y
- 
- config SSB_PCMCIAHOST_POSSIBLE
- 	bool
---- a/lib/Kconfig
-+++ b/lib/Kconfig
-@@ -377,16 +377,16 @@ config BCH_CONST_T
- # Textsearch support is select'ed if needed
- #
- config TEXTSEARCH
--	bool
-+	bool "Textsearch support"
- 
- config TEXTSEARCH_KMP
--	tristate
-+	tristate "Textsearch KMP"
- 
- config TEXTSEARCH_BM
--	tristate
-+	tristate "Textsearch BM"
- 
- config TEXTSEARCH_FSM
--	tristate
-+	tristate "Textsearch FSM"
- 
- config BTREE
- 	bool
---- a/net/netfilter/Kconfig
-+++ b/net/netfilter/Kconfig
-@@ -10,7 +10,7 @@ config NETFILTER_INGRESS
- 	  infrastructure.
- 
- config NETFILTER_NETLINK
--	tristate
-+	tristate "Netfilter NFNETLINK interface"
- 
- config NETFILTER_FAMILY_BRIDGE
- 	bool
---- a/net/wireless/Kconfig
-+++ b/net/wireless/Kconfig
-@@ -1,5 +1,5 @@
- config WIRELESS_EXT
--	bool
-+	bool "Wireless extensions"
- 
- config WEXT_CORE
- 	def_bool y
-@@ -11,10 +11,10 @@ config WEXT_PROC
- 	depends on WEXT_CORE
- 
- config WEXT_SPY
--	bool
-+	bool "WEXT_SPY"
- 
- config WEXT_PRIV
--	bool
-+	bool "WEXT_PRIV"
- 
- config CFG80211
- 	tristate "cfg80211 - wireless configuration API"
-@@ -202,7 +202,7 @@ config CFG80211_WEXT_EXPORT
- endif # CFG80211
- 
- config LIB80211
--	tristate
-+	tristate "LIB80211"
- 	default n
- 	help
- 	  This options enables a library of common routines used
-@@ -211,13 +211,16 @@ config LIB80211
- 	  Drivers should select this themselves if needed.
- 
- config LIB80211_CRYPT_WEP
--	tristate
-+	tristate "LIB80211_CRYPT_WEP"
-+	select LIB80211
- 
- config LIB80211_CRYPT_CCMP
--	tristate
-+	tristate "LIB80211_CRYPT_CCMP"
-+	select LIB80211
- 
- config LIB80211_CRYPT_TKIP
--	tristate
-+	tristate "LIB80211_CRYPT_TKIP"
-+	select LIB80211
- 
- config LIB80211_DEBUG
- 	bool "lib80211 debugging messages"
---- a/sound/core/Kconfig
-+++ b/sound/core/Kconfig
-@@ -16,7 +16,7 @@ config SND_DMAENGINE_PCM
- 	tristate
- 
- config SND_HWDEP
--	tristate
-+	tristate "Sound hardware support"
- 
- config SND_SEQ_DEVICE
- 	tristate
-@@ -26,7 +26,7 @@ config SND_RAWMIDI
- 	select SND_SEQ_DEVICE if SND_SEQUENCER != n
- 
- config SND_COMPRESS_OFFLOAD
--	tristate
-+	tristate "Compression offloading support"
- 
- config SND_JACK
- 	bool
--- a/target/linux/generic/hack-4.19/259-regmap_dynamic.patch	2022-03-22 08:54:47.212464678 +0800
+++ b/target/linux/generic/hack-4.19/259-regmap_dynamic.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,110 +0,0 @@
-From 811d9e2268a62b830cfe93cd8bc929afcb8b198b Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 15 Jul 2017 21:12:38 +0200
-Subject: kernel: move regmap bloat out of the kernel image if it is only being used in modules
-
-lede-commit: 96f39119815028073583e4fca3a9c5fe9141e998
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- drivers/base/regmap/Kconfig  | 15 ++++++++++-----
- drivers/base/regmap/Makefile | 12 ++++++++----
- drivers/base/regmap/regmap.c |  3 +++
- include/linux/regmap.h       |  2 +-
- 4 files changed, 22 insertions(+), 10 deletions(-)
-
---- a/drivers/base/regmap/Kconfig
-+++ b/drivers/base/regmap/Kconfig
-@@ -4,9 +4,8 @@
- # subsystems should select the appropriate symbols.
- 
- config REGMAP
--	default y if (REGMAP_I2C || REGMAP_SPI || REGMAP_SPMI || REGMAP_W1 || REGMAP_AC97 || REGMAP_MMIO || REGMAP_IRQ)
- 	select IRQ_DOMAIN if REGMAP_IRQ
--	bool
-+	tristate
- 
- config REGCACHE_COMPRESSED
- 	select LZO_COMPRESS
-@@ -18,6 +17,7 @@ config REGMAP_AC97
- 
- config REGMAP_I2C
- 	tristate
-+	select REGMAP
- 	depends on I2C
- 
- config REGMAP_SLIMBUS
-@@ -26,20 +26,26 @@ config REGMAP_SLIMBUS
- 
- config REGMAP_SPI
- 	tristate
-+	select REGMAP
-+	depends on SPI_MASTER
- 	depends on SPI
- 
- config REGMAP_SPMI
-+	select REGMAP
- 	tristate
- 	depends on SPMI
- 
- config REGMAP_W1
-+	select REGMAP
- 	tristate
- 	depends on W1
- 
- config REGMAP_MMIO
- 	tristate
-+	select REGMAP
- 
- config REGMAP_IRQ
-+	select REGMAP
- 	bool
- 
- config REGMAP_SOUNDWIRE
---- a/drivers/base/regmap/Makefile
-+++ b/drivers/base/regmap/Makefile
-@@ -2,10 +2,14 @@
- # For include/trace/define_trace.h to include trace.h
- CFLAGS_regmap.o := -I$(src)
- 
--obj-$(CONFIG_REGMAP) += regmap.o regcache.o
--obj-$(CONFIG_REGMAP) += regcache-rbtree.o regcache-flat.o
--obj-$(CONFIG_REGCACHE_COMPRESSED) += regcache-lzo.o
--obj-$(CONFIG_DEBUG_FS) += regmap-debugfs.o
-+regmap-core-objs = regmap.o regcache.o regcache-rbtree.o regcache-flat.o
-+ifdef CONFIG_DEBUG_FS
-+regmap-core-objs += regmap-debugfs.o
-+endif
-+ifdef CONFIG_REGCACHE_COMPRESSED
-+regmap-core-objs += regcache-lzo.o
-+endif
-+obj-$(CONFIG_REGMAP) += regmap-core.o
- obj-$(CONFIG_REGMAP_AC97) += regmap-ac97.o
- obj-$(CONFIG_REGMAP_I2C) += regmap-i2c.o
- obj-$(CONFIG_REGMAP_SLIMBUS) += regmap-slimbus.o
---- a/drivers/base/regmap/regmap.c
-+++ b/drivers/base/regmap/regmap.c
-@@ -13,6 +13,7 @@
- #include <linux/device.h>
- #include <linux/slab.h>
- #include <linux/export.h>
-+#include <linux/module.h>
- #include <linux/mutex.h>
- #include <linux/err.h>
- #include <linux/of.h>
-@@ -3039,3 +3040,5 @@ static int __init regmap_initcall(void)
- 	return 0;
- }
- postcore_initcall(regmap_initcall);
-+
-+MODULE_LICENSE("GPL");
---- a/include/linux/regmap.h
-+++ b/include/linux/regmap.h
-@@ -187,7 +187,7 @@ struct reg_sequence {
- 	pollret ?: ((cond) ? 0 : -ETIMEDOUT); \
- })
- 
--#ifdef CONFIG_REGMAP
-+#if IS_REACHABLE(CONFIG_REGMAP)
- 
- enum regmap_endian {
- 	/* Unspecified -> 0 -> Backwards compatible default */
--- a/target/linux/generic/hack-4.19/260-crypto_test_dependencies.patch	2022-03-22 08:54:47.212464678 +0800
+++ b/target/linux/generic/hack-4.19/260-crypto_test_dependencies.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,60 +0,0 @@
-From fd1799b0bf5efa46dd3e6dfbbf3955564807e508 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 17:12:51 +0200
-Subject: kernel: prevent cryptomgr from pulling in useless extra dependencies for tests that are not run
-
-Reduces kernel size after LZMA by about 5k on MIPS
-
-lede-commit: 044c316167e076479a344c59905e5b435b84a77f
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- crypto/Kconfig   | 13 ++++++-------
- crypto/algboss.c |  4 ++++
- 2 files changed, 10 insertions(+), 7 deletions(-)
-
---- a/crypto/Kconfig
-+++ b/crypto/Kconfig
-@@ -144,13 +144,13 @@ config CRYPTO_MANAGER
- 	  cbc(aes).
- 
- config CRYPTO_MANAGER2
--	def_tristate CRYPTO_MANAGER || (CRYPTO_MANAGER!=n && CRYPTO_ALGAPI=y)
--	select CRYPTO_AEAD2
--	select CRYPTO_HASH2
--	select CRYPTO_BLKCIPHER2
--	select CRYPTO_AKCIPHER2
--	select CRYPTO_KPP2
--	select CRYPTO_ACOMP2
-+	def_tristate CRYPTO_MANAGER || (CRYPTO_MANAGER!=n && CRYPTO_ALGAPI=y && !CRYPTO_MANAGER_DISABLE_TESTS)
-+	select CRYPTO_AEAD2 if !CRYPTO_MANAGER_DISABLE_TESTS
-+	select CRYPTO_HASH2 if !CRYPTO_MANAGER_DISABLE_TESTS
-+	select CRYPTO_BLKCIPHER2 if !CRYPTO_MANAGER_DISABLE_TESTS
-+	select CRYPTO_AKCIPHER2 if !CRYPTO_MANAGER_DISABLE_TESTS
-+	select CRYPTO_KPP2 if !CRYPTO_MANAGER_DISABLE_TESTS
-+	select CRYPTO_ACOMP2 if !CRYPTO_MANAGER_DISABLE_TESTS
- 
- config CRYPTO_USER
- 	tristate "Userspace cryptographic algorithm configuration"
-@@ -163,7 +163,6 @@ config CRYPTO_USER
- config CRYPTO_MANAGER_DISABLE_TESTS
- 	bool "Disable run-time self tests"
- 	default y
--	depends on CRYPTO_MANAGER2
- 	help
- 	  Disable run-time self tests that normally take place at
- 	  algorithm registration.
---- a/crypto/algboss.c
-+++ b/crypto/algboss.c
-@@ -247,8 +247,12 @@ static int cryptomgr_schedule_test(struc
- 	type = alg->cra_flags;
- 
- 	/* Do not test internal algorithms. */
-+#ifdef CONFIG_CRYPTO_MANAGER_DISABLE_TESTS
-+	type |= CRYPTO_ALG_TESTED;
-+#else
- 	if (type & CRYPTO_ALG_INTERNAL)
- 		type |= CRYPTO_ALG_TESTED;
-+#endif
- 
- 	param->type = type;
- 
--- a/target/linux/generic/hack-4.19/280-rfkill-stubs.patch	2022-03-22 08:54:47.212464678 +0800
+++ b/target/linux/generic/hack-4.19/280-rfkill-stubs.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,84 +0,0 @@
-From 236c1acdfef5958010ac9814a9872e0a46fd78ee Mon Sep 17 00:00:00 2001
-From: John Crispin <john@phrozen.org>
-Date: Fri, 7 Jul 2017 17:13:44 +0200
-Subject: rfkill: add fake rfkill support
-
-allow building of modules depending on RFKILL even if RFKILL is not enabled.
-
-Signed-off-by: John Crispin <john@phrozen.org>
----
- include/linux/rfkill.h |  2 +-
- net/Makefile           |  2 +-
- net/rfkill/Kconfig     | 14 +++++++++-----
- net/rfkill/Makefile    |  2 +-
- 4 files changed, 12 insertions(+), 8 deletions(-)
-
---- a/include/linux/rfkill.h
-+++ b/include/linux/rfkill.h
-@@ -64,7 +64,7 @@ struct rfkill_ops {
- 	int	(*set_block)(void *data, bool blocked);
- };
- 
--#if defined(CONFIG_RFKILL) || defined(CONFIG_RFKILL_MODULE)
-+#if defined(CONFIG_RFKILL_FULL) || defined(CONFIG_RFKILL_FULL_MODULE)
- /**
-  * rfkill_alloc - Allocate rfkill structure
-  * @name: name of the struct -- the string is not copied internally
---- a/net/Makefile
-+++ b/net/Makefile
-@@ -53,7 +53,7 @@ obj-$(CONFIG_TIPC)		+= tipc/
- obj-$(CONFIG_NETLABEL)		+= netlabel/
- obj-$(CONFIG_IUCV)		+= iucv/
- obj-$(CONFIG_SMC)		+= smc/
--obj-$(CONFIG_RFKILL)		+= rfkill/
-+obj-$(CONFIG_RFKILL_FULL)	+= rfkill/
- obj-$(CONFIG_NET_9P)		+= 9p/
- obj-$(CONFIG_CAIF)		+= caif/
- ifneq ($(CONFIG_DCB),)
---- a/net/rfkill/Kconfig
-+++ b/net/rfkill/Kconfig
-@@ -1,7 +1,11 @@
- #
- # RF switch subsystem configuration
- #
--menuconfig RFKILL
-+config RFKILL
-+	bool
-+	default y
-+
-+menuconfig RFKILL_FULL
- 	tristate "RF switch subsystem support"
- 	help
- 	  Say Y here if you want to have control over RF switches
-@@ -13,19 +17,19 @@ menuconfig RFKILL
- # LED trigger support
- config RFKILL_LEDS
- 	bool
--	depends on RFKILL
-+	depends on RFKILL_FULL
- 	depends on LEDS_TRIGGERS = y || RFKILL = LEDS_TRIGGERS
- 	default y
- 
- config RFKILL_INPUT
- 	bool "RF switch input support" if EXPERT
--	depends on RFKILL
-+	depends on RFKILL_FULL
- 	depends on INPUT = y || RFKILL = INPUT
- 	default y if !EXPERT
- 
- config RFKILL_GPIO
- 	tristate "GPIO RFKILL driver"
--	depends on RFKILL
-+	depends on RFKILL_FULL
- 	depends on GPIOLIB || COMPILE_TEST
- 	default n
- 	help
---- a/net/rfkill/Makefile
-+++ b/net/rfkill/Makefile
-@@ -4,5 +4,5 @@
- 
- rfkill-y			+= core.o
- rfkill-$(CONFIG_RFKILL_INPUT)	+= input.o
--obj-$(CONFIG_RFKILL)		+= rfkill.o
-+obj-$(CONFIG_RFKILL_FULL)	+= rfkill.o
- obj-$(CONFIG_RFKILL_GPIO)	+= rfkill-gpio.o
--- a/target/linux/generic/hack-4.19/290-nvmem-make-CONFIG_NVMEM-tristate-again.patch	2022-03-22 08:54:47.212464678 +0800
+++ b/target/linux/generic/hack-4.19/290-nvmem-make-CONFIG_NVMEM-tristate-again.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,33 +0,0 @@
-From 2579d9b982c7232f9354bcca5262e26a84c38799 Mon Sep 17 00:00:00 2001
-From: Hauke Mehrtens <hauke@hauke-m.de>
-Date: Fri, 2 Nov 2018 17:40:32 +0100
-Subject: [PATCH] nvmem: make CONFIG_NVMEM tristate again
-
-Only build it in when OF_NET is selected and make it possible to build
-it as module otherwise.
-
-Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
----
- drivers/nvmem/Kconfig | 2 +-
- drivers/of/Kconfig    | 1 +
- 2 files changed, 2 insertions(+), 1 deletion(-)
-
---- a/drivers/nvmem/Kconfig
-+++ b/drivers/nvmem/Kconfig
-@@ -1,5 +1,5 @@
- menuconfig NVMEM
--	bool "NVMEM Support"
-+	tristate "NVMEM Support"
- 	help
- 	  Support for NVMEM(Non Volatile Memory) devices like EEPROM, EFUSES...
- 
---- a/drivers/of/Kconfig
-+++ b/drivers/of/Kconfig
-@@ -71,6 +71,7 @@ config OF_IRQ
- 
- config OF_NET
- 	depends on NETDEVICES
-+	select NVMEM
- 	def_bool y
- 
- config OF_MDIO
--- a/target/linux/generic/hack-4.19/300-MIPS-r4k_cache-use-more-efficient-cache-blast.patch	2022-03-22 08:54:47.213464679 +0800
+++ b/target/linux/generic/hack-4.19/300-MIPS-r4k_cache-use-more-efficient-cache-blast.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,66 +0,0 @@
-From: Ben Menchaca <ben.menchaca@qca.qualcomm.com>
-Date: Fri, 7 Jun 2013 18:35:22 -0500
-Subject: MIPS: r4k_cache: use more efficient cache blast
-
-Optimize the compiler output for larger cache blast cases that are
-common for DMA-based networking.
-
-Signed-off-by: Ben Menchaca <ben.menchaca@qca.qualcomm.com>
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
---- a/arch/mips/include/asm/r4kcache.h
-+++ b/arch/mips/include/asm/r4kcache.h
-@@ -683,16 +683,48 @@ static inline void prot##extra##blast_##
- 						    unsigned long end)	\
- {									\
- 	unsigned long lsize = cpu_##desc##_line_size();			\
-+	unsigned long lsize_2 = lsize * 2;				\
-+	unsigned long lsize_3 = lsize * 3;				\
-+	unsigned long lsize_4 = lsize * 4;				\
-+	unsigned long lsize_5 = lsize * 5;				\
-+	unsigned long lsize_6 = lsize * 6;				\
-+	unsigned long lsize_7 = lsize * 7;				\
-+	unsigned long lsize_8 = lsize * 8;				\
- 	unsigned long addr = start & ~(lsize - 1);			\
--	unsigned long aend = (end - 1) & ~(lsize - 1);			\
-+	unsigned long aend = (end + lsize - 1) & ~(lsize - 1);		\
-+	int lines = (aend - addr) / lsize;				\
- 									\
- 	__##pfx##flush_prologue						\
- 									\
--	while (1) {							\
-+	while (lines >= 8) {						\
-+		prot##cache_op(hitop, addr);				\
-+		prot##cache_op(hitop, addr + lsize);			\
-+		prot##cache_op(hitop, addr + lsize_2);			\
-+		prot##cache_op(hitop, addr + lsize_3);			\
-+		prot##cache_op(hitop, addr + lsize_4);			\
-+		prot##cache_op(hitop, addr + lsize_5);			\
-+		prot##cache_op(hitop, addr + lsize_6);			\
-+		prot##cache_op(hitop, addr + lsize_7);			\
-+		addr += lsize_8;					\
-+		lines -= 8;						\
-+	}								\
-+									\
-+	if (lines & 0x4) {						\
-+		prot##cache_op(hitop, addr);				\
-+		prot##cache_op(hitop, addr + lsize);			\
-+		prot##cache_op(hitop, addr + lsize_2);			\
-+		prot##cache_op(hitop, addr + lsize_3);			\
-+		addr += lsize_4;					\
-+	}								\
-+									\
-+	if (lines & 0x2) {						\
-+		prot##cache_op(hitop, addr);				\
-+		prot##cache_op(hitop, addr + lsize);			\
-+		addr += lsize_2;					\
-+	}								\
-+									\
-+	if (lines & 0x1) {						\
- 		prot##cache_op(hitop, addr);				\
--		if (addr == aend)					\
--			break;						\
--		addr += lsize;						\
- 	}								\
- 									\
- 	__##pfx##flush_epilogue						\
--- a/target/linux/generic/hack-4.19/301-mips_image_cmdline_hack.patch	2022-03-22 08:54:47.213464679 +0800
+++ b/target/linux/generic/hack-4.19/301-mips_image_cmdline_hack.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,38 +0,0 @@
-From: John Crispin <john@phrozen.org>
-Subject: hack: kernel: add generic image_cmdline hack to MIPS targets
-
-lede-commit: d59f5b3a987a48508257a0ddbaeadc7909f9f976
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- arch/mips/Kconfig       | 4 ++++
- arch/mips/kernel/head.S | 6 ++++++
- 2 files changed, 10 insertions(+)
-
---- a/arch/mips/Kconfig
-+++ b/arch/mips/Kconfig
-@@ -1143,6 +1143,10 @@ config SYNC_R4K
- config MIPS_MACHINE
- 	def_bool n
- 
-+config IMAGE_CMDLINE_HACK
-+	bool "OpenWrt specific image command line hack"
-+	default n
-+
- config NO_IOPORT_MAP
- 	def_bool n
- 
---- a/arch/mips/kernel/head.S
-+++ b/arch/mips/kernel/head.S
-@@ -79,6 +79,12 @@ FEXPORT(__kernel_entry)
- 	j	kernel_entry
- #endif
- 
-+#ifdef CONFIG_IMAGE_CMDLINE_HACK
-+	.ascii	"CMDLINE:"
-+EXPORT(__image_cmdline)
-+	.fill	0x400
-+#endif /* CONFIG_IMAGE_CMDLINE_HACK */
-+
- 	__REF
- 
- NESTED(kernel_entry, 16, sp)			# kernel entry point
--- a/target/linux/generic/hack-4.19/321-powerpc_crtsavres_prereq.patch	2022-03-22 08:54:47.213464679 +0800
+++ b/target/linux/generic/hack-4.19/321-powerpc_crtsavres_prereq.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,39 +0,0 @@
-From 107c0964cb8db7ca28ac5199426414fdab3c274d Mon Sep 17 00:00:00 2001
-From: "Alexandros C. Couloumbis" <alex@ozo.com>
-Date: Fri, 7 Jul 2017 17:14:51 +0200
-Subject: hack: arch: powerpc: drop register save/restore library from modules
-
-Upstream GCC uses a libgcc function for saving/restoring registers. This
-makes the code bigger, and upstream kernels need to carry that function
-for every single kernel module. Our GCC is patched to avoid those
-references, so we can drop the extra bloat for modules.
-
-lede-commit: e8e1084654f50904e6bf77b70b2de3f137d7b3ec
-Signed-off-by: Alexandros C. Couloumbis <alex@ozo.com>
----
- arch/powerpc/Makefile | 1 -
- 1 file changed, 1 deletion(-)
-
---- a/arch/powerpc/Makefile
-+++ b/arch/powerpc/Makefile
-@@ -60,20 +60,6 @@ machine-$(CONFIG_PPC64) += 64
- machine-$(CONFIG_CPU_LITTLE_ENDIAN) += le
- UTS_MACHINE := $(subst $(space),,$(machine-y))
- 
--# XXX This needs to be before we override LD below
--ifdef CONFIG_PPC32
--KBUILD_LDFLAGS_MODULE += arch/powerpc/lib/crtsavres.o
--else
--KBUILD_LDFLAGS_MODULE += -T $(srctree)/arch/powerpc/kernel/module.lds
--ifeq ($(call ld-ifversion, -ge, 225000000, y),y)
--# Have the linker provide sfpr if possible.
--# There is a corresponding test in arch/powerpc/lib/Makefile
--KBUILD_LDFLAGS_MODULE += --save-restore-funcs
--else
--KBUILD_LDFLAGS_MODULE += arch/powerpc/lib/crtsavres.o
--endif
--endif
--
- ifdef CONFIG_CPU_LITTLE_ENDIAN
- KBUILD_CFLAGS	+= -mlittle-endian
- KBUILD_LDFLAGS	+= -EL
--- a/target/linux/generic/hack-4.19/531-debloat_lzma.patch	2022-03-22 08:54:47.214464681 +0800
+++ b/target/linux/generic/hack-4.19/531-debloat_lzma.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,1040 +0,0 @@
-From 3fd297761ac246c54d7723c57fca95c112b99465 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 15 Jul 2017 21:15:44 +0200
-Subject: lzma: de-bloat the lzma library used by jffs2
-
-lede-commit: 3fd1dd08fbcbb78b34efefd32c3032e5c99108d6
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/linux/lzma/LzFind.h  |  17 ---
- include/linux/lzma/LzmaDec.h | 101 ---------------
- include/linux/lzma/LzmaEnc.h |  20 ---
- lib/lzma/LzFind.c            | 287 ++++---------------------------------------
- lib/lzma/LzmaDec.c           |  86 +------------
- lib/lzma/LzmaEnc.c           | 172 ++------------------------
- 6 files changed, 42 insertions(+), 641 deletions(-)
-
---- a/include/linux/lzma/LzFind.h
-+++ b/include/linux/lzma/LzFind.h
-@@ -55,11 +55,6 @@ typedef struct _CMatchFinder
- 
- #define Inline_MatchFinder_GetNumAvailableBytes(p) ((p)->streamPos - (p)->pos)
- 
--int MatchFinder_NeedMove(CMatchFinder *p);
--Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p);
--void MatchFinder_MoveBlock(CMatchFinder *p);
--void MatchFinder_ReadIfRequired(CMatchFinder *p);
--
- void MatchFinder_Construct(CMatchFinder *p);
- 
- /* Conditions:
-@@ -70,12 +65,6 @@ int MatchFinder_Create(CMatchFinder *p,
-     UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
-     ISzAlloc *alloc);
- void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc);
--void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems);
--void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue);
--
--UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *buffer, CLzRef *son,
--    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
--    UInt32 *distances, UInt32 maxLen);
- 
- /*
- Conditions:
-@@ -102,12 +91,6 @@ typedef struct _IMatchFinder
- 
- void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable);
- 
--void MatchFinder_Init(CMatchFinder *p);
--UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
--UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
--void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
--void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
--
- #ifdef __cplusplus
- }
- #endif
---- a/include/linux/lzma/LzmaDec.h
-+++ b/include/linux/lzma/LzmaDec.h
-@@ -31,14 +31,6 @@ typedef struct _CLzmaProps
-   UInt32 dicSize;
- } CLzmaProps;
- 
--/* LzmaProps_Decode - decodes properties
--Returns:
--  SZ_OK
--  SZ_ERROR_UNSUPPORTED - Unsupported properties
--*/
--
--SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size);
--
- 
- /* ---------- LZMA Decoder state ---------- */
- 
-@@ -70,8 +62,6 @@ typedef struct
- 
- #define LzmaDec_Construct(p) { (p)->dic = 0; (p)->probs = 0; }
- 
--void LzmaDec_Init(CLzmaDec *p);
--
- /* There are two types of LZMA streams:
-      0) Stream with end mark. That end mark adds about 6 bytes to compressed size.
-      1) Stream without end mark. You must know exact uncompressed size to decompress such stream. */
-@@ -108,97 +98,6 @@ typedef enum
- 
- /* ELzmaStatus is used only as output value for function call */
- 
--
--/* ---------- Interfaces ---------- */
--
--/* There are 3 levels of interfaces:
--     1) Dictionary Interface
--     2) Buffer Interface
--     3) One Call Interface
--   You can select any of these interfaces, but don't mix functions from different
--   groups for same object. */
--
--
--/* There are two variants to allocate state for Dictionary Interface:
--     1) LzmaDec_Allocate / LzmaDec_Free
--     2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs
--   You can use variant 2, if you set dictionary buffer manually.
--   For Buffer Interface you must always use variant 1.
--
--LzmaDec_Allocate* can return:
--  SZ_OK
--  SZ_ERROR_MEM         - Memory allocation error
--  SZ_ERROR_UNSUPPORTED - Unsupported properties
--*/
--   
--SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc);
--void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc);
--
--SRes LzmaDec_Allocate(CLzmaDec *state, const Byte *prop, unsigned propsSize, ISzAlloc *alloc);
--void LzmaDec_Free(CLzmaDec *state, ISzAlloc *alloc);
--
--/* ---------- Dictionary Interface ---------- */
--
--/* You can use it, if you want to eliminate the overhead for data copying from
--   dictionary to some other external buffer.
--   You must work with CLzmaDec variables directly in this interface.
--
--   STEPS:
--     LzmaDec_Constr()
--     LzmaDec_Allocate()
--     for (each new stream)
--     {
--       LzmaDec_Init()
--       while (it needs more decompression)
--       {
--         LzmaDec_DecodeToDic()
--         use data from CLzmaDec::dic and update CLzmaDec::dicPos
--       }
--     }
--     LzmaDec_Free()
--*/
--
--/* LzmaDec_DecodeToDic
--   
--   The decoding to internal dictionary buffer (CLzmaDec::dic).
--   You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!
--
--finishMode:
--  It has meaning only if the decoding reaches output limit (dicLimit).
--  LZMA_FINISH_ANY - Decode just dicLimit bytes.
--  LZMA_FINISH_END - Stream must be finished after dicLimit.
--
--Returns:
--  SZ_OK
--    status:
--      LZMA_STATUS_FINISHED_WITH_MARK
--      LZMA_STATUS_NOT_FINISHED
--      LZMA_STATUS_NEEDS_MORE_INPUT
--      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
--  SZ_ERROR_DATA - Data error
--*/
--
--SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit,
--    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
--
--
--/* ---------- Buffer Interface ---------- */
--
--/* It's zlib-like interface.
--   See LzmaDec_DecodeToDic description for information about STEPS and return results,
--   but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need
--   to work with CLzmaDec variables manually.
--
--finishMode:
--  It has meaning only if the decoding reaches output limit (*destLen).
--  LZMA_FINISH_ANY - Decode just destLen bytes.
--  LZMA_FINISH_END - Stream must be finished after (*destLen).
--*/
--
--SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen,
--    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
--
--
- /* ---------- One Call Interface ---------- */
- 
- /* LzmaDecode
---- a/include/linux/lzma/LzmaEnc.h
-+++ b/include/linux/lzma/LzmaEnc.h
-@@ -31,9 +31,6 @@ typedef struct _CLzmaEncProps
- } CLzmaEncProps;
- 
- void LzmaEncProps_Init(CLzmaEncProps *p);
--void LzmaEncProps_Normalize(CLzmaEncProps *p);
--UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2);
--
- 
- /* ---------- CLzmaEncHandle Interface ---------- */
- 
-@@ -53,26 +50,9 @@ CLzmaEncHandle LzmaEnc_Create(ISzAlloc *
- void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig);
- SRes LzmaEnc_SetProps(CLzmaEncHandle p, const CLzmaEncProps *props);
- SRes LzmaEnc_WriteProperties(CLzmaEncHandle p, Byte *properties, SizeT *size);
--SRes LzmaEnc_Encode(CLzmaEncHandle p, ISeqOutStream *outStream, ISeqInStream *inStream,
--    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
- SRes LzmaEnc_MemEncode(CLzmaEncHandle p, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-     int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
- 
--/* ---------- One Call Interface ---------- */
--
--/* LzmaEncode
--Return code:
--  SZ_OK               - OK
--  SZ_ERROR_MEM        - Memory allocation error
--  SZ_ERROR_PARAM      - Incorrect paramater
--  SZ_ERROR_OUTPUT_EOF - output buffer overflow
--  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
--*/
--
--SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
--    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
--    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
--
- #ifdef __cplusplus
- }
- #endif
---- a/lib/lzma/LzFind.c
-+++ b/lib/lzma/LzFind.c
-@@ -14,9 +14,15 @@
- 
- #define kStartMaxLen 3
- 
-+#if 0
-+#define DIRECT_INPUT	p->directInput
-+#else
-+#define DIRECT_INPUT	1
-+#endif
-+
- static void LzInWindow_Free(CMatchFinder *p, ISzAlloc *alloc)
- {
--  if (!p->directInput)
-+  if (!DIRECT_INPUT)
-   {
-     alloc->Free(alloc, p->bufferBase);
-     p->bufferBase = 0;
-@@ -28,7 +34,7 @@ static void LzInWindow_Free(CMatchFinder
- static int LzInWindow_Create(CMatchFinder *p, UInt32 keepSizeReserv, ISzAlloc *alloc)
- {
-   UInt32 blockSize = p->keepSizeBefore + p->keepSizeAfter + keepSizeReserv;
--  if (p->directInput)
-+  if (DIRECT_INPUT)
-   {
-     p->blockSize = blockSize;
-     return 1;
-@@ -42,12 +48,12 @@ static int LzInWindow_Create(CMatchFinde
-   return (p->bufferBase != 0);
- }
- 
--Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }
--Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p->buffer[index]; }
-+static Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }
-+static Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p->buffer[index]; }
- 
--UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }
-+static UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }
- 
--void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
-+static void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
- {
-   p->posLimit -= subValue;
-   p->pos -= subValue;
-@@ -58,7 +64,7 @@ static void MatchFinder_ReadBlock(CMatch
- {
-   if (p->streamEndWasReached || p->result != SZ_OK)
-     return;
--  if (p->directInput)
-+  if (DIRECT_INPUT)
-   {
-     UInt32 curSize = 0xFFFFFFFF - p->streamPos;
-     if (curSize > p->directInputRem)
-@@ -89,7 +95,7 @@ static void MatchFinder_ReadBlock(CMatch
-   }
- }
- 
--void MatchFinder_MoveBlock(CMatchFinder *p)
-+static void MatchFinder_MoveBlock(CMatchFinder *p)
- {
-   memmove(p->bufferBase,
-     p->buffer - p->keepSizeBefore,
-@@ -97,22 +103,14 @@ void MatchFinder_MoveBlock(CMatchFinder
-   p->buffer = p->bufferBase + p->keepSizeBefore;
- }
- 
--int MatchFinder_NeedMove(CMatchFinder *p)
-+static int MatchFinder_NeedMove(CMatchFinder *p)
- {
--  if (p->directInput)
-+  if (DIRECT_INPUT)
-     return 0;
-   /* if (p->streamEndWasReached) return 0; */
-   return ((size_t)(p->bufferBase + p->blockSize - p->buffer) <= p->keepSizeAfter);
- }
- 
--void MatchFinder_ReadIfRequired(CMatchFinder *p)
--{
--  if (p->streamEndWasReached)
--    return;
--  if (p->keepSizeAfter >= p->streamPos - p->pos)
--    MatchFinder_ReadBlock(p);
--}
--
- static void MatchFinder_CheckAndMoveAndRead(CMatchFinder *p)
- {
-   if (MatchFinder_NeedMove(p))
-@@ -268,7 +266,7 @@ static void MatchFinder_SetLimits(CMatch
-   p->posLimit = p->pos + limit;
- }
- 
--void MatchFinder_Init(CMatchFinder *p)
-+static void MatchFinder_Init(CMatchFinder *p)
- {
-   UInt32 i;
-   for (i = 0; i < p->hashSizeSum; i++)
-@@ -287,7 +285,7 @@ static UInt32 MatchFinder_GetSubValue(CM
-   return (p->pos - p->historySize - 1) & kNormalizeMask;
- }
- 
--void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems)
-+static void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems)
- {
-   UInt32 i;
-   for (i = 0; i < numItems; i++)
-@@ -319,38 +317,7 @@ static void MatchFinder_CheckLimits(CMat
-   MatchFinder_SetLimits(p);
- }
- 
--static UInt32 * Hc_GetMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
--    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
--    UInt32 *distances, UInt32 maxLen)
--{
--  son[_cyclicBufferPos] = curMatch;
--  for (;;)
--  {
--    UInt32 delta = pos - curMatch;
--    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
--      return distances;
--    {
--      const Byte *pb = cur - delta;
--      curMatch = son[_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)];
--      if (pb[maxLen] == cur[maxLen] && *pb == *cur)
--      {
--        UInt32 len = 0;
--        while (++len != lenLimit)
--          if (pb[len] != cur[len])
--            break;
--        if (maxLen < len)
--        {
--          *distances++ = maxLen = len;
--          *distances++ = delta - 1;
--          if (len == lenLimit)
--            return distances;
--        }
--      }
--    }
--  }
--}
--
--UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
-+static UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
-     UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
-     UInt32 *distances, UInt32 maxLen)
- {
-@@ -460,10 +427,10 @@ static void SkipMatchesSpec(UInt32 lenLi
-   p->buffer++; \
-   if (++p->pos == p->posLimit) MatchFinder_CheckLimits(p);
- 
--#define MOVE_POS_RET MOVE_POS return offset;
--
- static void MatchFinder_MovePos(CMatchFinder *p) { MOVE_POS; }
- 
-+#define MOVE_POS_RET MatchFinder_MovePos(p); return offset;
-+
- #define GET_MATCHES_HEADER2(minLen, ret_op) \
-   UInt32 lenLimit; UInt32 hashValue; const Byte *cur; UInt32 curMatch; \
-   lenLimit = p->lenLimit; { if (lenLimit < minLen) { MatchFinder_MovePos(p); ret_op; }} \
-@@ -479,62 +446,7 @@ static void MatchFinder_MovePos(CMatchFi
-   distances + offset, maxLen) - distances); MOVE_POS_RET;
- 
- #define SKIP_FOOTER \
--  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MOVE_POS;
--
--static UInt32 Bt2_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
--{
--  UInt32 offset;
--  GET_MATCHES_HEADER(2)
--  HASH2_CALC;
--  curMatch = p->hash[hashValue];
--  p->hash[hashValue] = p->pos;
--  offset = 0;
--  GET_MATCHES_FOOTER(offset, 1)
--}
--
--UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
--{
--  UInt32 offset;
--  GET_MATCHES_HEADER(3)
--  HASH_ZIP_CALC;
--  curMatch = p->hash[hashValue];
--  p->hash[hashValue] = p->pos;
--  offset = 0;
--  GET_MATCHES_FOOTER(offset, 2)
--}
--
--static UInt32 Bt3_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
--{
--  UInt32 hash2Value, delta2, maxLen, offset;
--  GET_MATCHES_HEADER(3)
--
--  HASH3_CALC;
--
--  delta2 = p->pos - p->hash[hash2Value];
--  curMatch = p->hash[kFix3HashSize + hashValue];
--  
--  p->hash[hash2Value] =
--  p->hash[kFix3HashSize + hashValue] = p->pos;
--
--
--  maxLen = 2;
--  offset = 0;
--  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
--  {
--    for (; maxLen != lenLimit; maxLen++)
--      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
--        break;
--    distances[0] = maxLen;
--    distances[1] = delta2 - 1;
--    offset = 2;
--    if (maxLen == lenLimit)
--    {
--      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
--      MOVE_POS_RET;
--    }
--  }
--  GET_MATCHES_FOOTER(offset, maxLen)
--}
-+  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MatchFinder_MovePos(p);
- 
- static UInt32 Bt4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
- {
-@@ -583,108 +495,6 @@ static UInt32 Bt4_MatchFinder_GetMatches
-   GET_MATCHES_FOOTER(offset, maxLen)
- }
- 
--static UInt32 Hc4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
--{
--  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
--  GET_MATCHES_HEADER(4)
--
--  HASH4_CALC;
--
--  delta2 = p->pos - p->hash[                hash2Value];
--  delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
--  curMatch = p->hash[kFix4HashSize + hashValue];
--
--  p->hash[                hash2Value] =
--  p->hash[kFix3HashSize + hash3Value] =
--  p->hash[kFix4HashSize + hashValue] = p->pos;
--
--  maxLen = 1;
--  offset = 0;
--  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
--  {
--    distances[0] = maxLen = 2;
--    distances[1] = delta2 - 1;
--    offset = 2;
--  }
--  if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
--  {
--    maxLen = 3;
--    distances[offset + 1] = delta3 - 1;
--    offset += 2;
--    delta2 = delta3;
--  }
--  if (offset != 0)
--  {
--    for (; maxLen != lenLimit; maxLen++)
--      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
--        break;
--    distances[offset - 2] = maxLen;
--    if (maxLen == lenLimit)
--    {
--      p->son[p->cyclicBufferPos] = curMatch;
--      MOVE_POS_RET;
--    }
--  }
--  if (maxLen < 3)
--    maxLen = 3;
--  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
--    distances + offset, maxLen) - (distances));
--  MOVE_POS_RET
--}
--
--UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
--{
--  UInt32 offset;
--  GET_MATCHES_HEADER(3)
--  HASH_ZIP_CALC;
--  curMatch = p->hash[hashValue];
--  p->hash[hashValue] = p->pos;
--  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
--    distances, 2) - (distances));
--  MOVE_POS_RET
--}
--
--static void Bt2_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
--{
--  do
--  {
--    SKIP_HEADER(2)
--    HASH2_CALC;
--    curMatch = p->hash[hashValue];
--    p->hash[hashValue] = p->pos;
--    SKIP_FOOTER
--  }
--  while (--num != 0);
--}
--
--void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
--{
--  do
--  {
--    SKIP_HEADER(3)
--    HASH_ZIP_CALC;
--    curMatch = p->hash[hashValue];
--    p->hash[hashValue] = p->pos;
--    SKIP_FOOTER
--  }
--  while (--num != 0);
--}
--
--static void Bt3_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
--{
--  do
--  {
--    UInt32 hash2Value;
--    SKIP_HEADER(3)
--    HASH3_CALC;
--    curMatch = p->hash[kFix3HashSize + hashValue];
--    p->hash[hash2Value] =
--    p->hash[kFix3HashSize + hashValue] = p->pos;
--    SKIP_FOOTER
--  }
--  while (--num != 0);
--}
--
- static void Bt4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
- {
-   do
-@@ -701,61 +511,12 @@ static void Bt4_MatchFinder_Skip(CMatchF
-   while (--num != 0);
- }
- 
--static void Hc4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
--{
--  do
--  {
--    UInt32 hash2Value, hash3Value;
--    SKIP_HEADER(4)
--    HASH4_CALC;
--    curMatch = p->hash[kFix4HashSize + hashValue];
--    p->hash[                hash2Value] =
--    p->hash[kFix3HashSize + hash3Value] =
--    p->hash[kFix4HashSize + hashValue] = p->pos;
--    p->son[p->cyclicBufferPos] = curMatch;
--    MOVE_POS
--  }
--  while (--num != 0);
--}
--
--void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
--{
--  do
--  {
--    SKIP_HEADER(3)
--    HASH_ZIP_CALC;
--    curMatch = p->hash[hashValue];
--    p->hash[hashValue] = p->pos;
--    p->son[p->cyclicBufferPos] = curMatch;
--    MOVE_POS
--  }
--  while (--num != 0);
--}
--
- void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable)
- {
-   vTable->Init = (Mf_Init_Func)MatchFinder_Init;
-   vTable->GetIndexByte = (Mf_GetIndexByte_Func)MatchFinder_GetIndexByte;
-   vTable->GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinder_GetNumAvailableBytes;
-   vTable->GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinder_GetPointerToCurrentPos;
--  if (!p->btMode)
--  {
--    vTable->GetMatches = (Mf_GetMatches_Func)Hc4_MatchFinder_GetMatches;
--    vTable->Skip = (Mf_Skip_Func)Hc4_MatchFinder_Skip;
--  }
--  else if (p->numHashBytes == 2)
--  {
--    vTable->GetMatches = (Mf_GetMatches_Func)Bt2_MatchFinder_GetMatches;
--    vTable->Skip = (Mf_Skip_Func)Bt2_MatchFinder_Skip;
--  }
--  else if (p->numHashBytes == 3)
--  {
--    vTable->GetMatches = (Mf_GetMatches_Func)Bt3_MatchFinder_GetMatches;
--    vTable->Skip = (Mf_Skip_Func)Bt3_MatchFinder_Skip;
--  }
--  else
--  {
--    vTable->GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
--    vTable->Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
--  }
-+  vTable->GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
-+  vTable->Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
- }
---- a/lib/lzma/LzmaDec.c
-+++ b/lib/lzma/LzmaDec.c
-@@ -682,7 +682,7 @@ static void LzmaDec_InitRc(CLzmaDec *p,
-   p->needFlush = 0;
- }
- 
--void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
-+static void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
- {
-   p->needFlush = 1;
-   p->remainLen = 0;
-@@ -698,7 +698,7 @@ void LzmaDec_InitDicAndState(CLzmaDec *p
-     p->needInitState = 1;
- }
- 
--void LzmaDec_Init(CLzmaDec *p)
-+static void LzmaDec_Init(CLzmaDec *p)
- {
-   p->dicPos = 0;
-   LzmaDec_InitDicAndState(p, True, True);
-@@ -716,7 +716,7 @@ static void LzmaDec_InitStateReal(CLzmaD
-   p->needInitState = 0;
- }
- 
--SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
-+static SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
-     ELzmaFinishMode finishMode, ELzmaStatus *status)
- {
-   SizeT inSize = *srcLen;
-@@ -837,65 +837,13 @@ SRes LzmaDec_DecodeToDic(CLzmaDec *p, Si
-   return (p->code == 0) ? SZ_OK : SZ_ERROR_DATA;
- }
- 
--SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
--{
--  SizeT outSize = *destLen;
--  SizeT inSize = *srcLen;
--  *srcLen = *destLen = 0;
--  for (;;)
--  {
--    SizeT inSizeCur = inSize, outSizeCur, dicPos;
--    ELzmaFinishMode curFinishMode;
--    SRes res;
--    if (p->dicPos == p->dicBufSize)
--      p->dicPos = 0;
--    dicPos = p->dicPos;
--    if (outSize > p->dicBufSize - dicPos)
--    {
--      outSizeCur = p->dicBufSize;
--      curFinishMode = LZMA_FINISH_ANY;
--    }
--    else
--    {
--      outSizeCur = dicPos + outSize;
--      curFinishMode = finishMode;
--    }
--
--    res = LzmaDec_DecodeToDic(p, outSizeCur, src, &inSizeCur, curFinishMode, status);
--    src += inSizeCur;
--    inSize -= inSizeCur;
--    *srcLen += inSizeCur;
--    outSizeCur = p->dicPos - dicPos;
--    memcpy(dest, p->dic + dicPos, outSizeCur);
--    dest += outSizeCur;
--    outSize -= outSizeCur;
--    *destLen += outSizeCur;
--    if (res != 0)
--      return res;
--    if (outSizeCur == 0 || outSize == 0)
--      return SZ_OK;
--  }
--}
--
--void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
-+static void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
- {
-   alloc->Free(alloc, p->probs);
-   p->probs = 0;
- }
- 
--static void LzmaDec_FreeDict(CLzmaDec *p, ISzAlloc *alloc)
--{
--  alloc->Free(alloc, p->dic);
--  p->dic = 0;
--}
--
--void LzmaDec_Free(CLzmaDec *p, ISzAlloc *alloc)
--{
--  LzmaDec_FreeProbs(p, alloc);
--  LzmaDec_FreeDict(p, alloc);
--}
--
--SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
-+static SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
- {
-   UInt32 dicSize;
-   Byte d;
-@@ -935,7 +883,7 @@ static SRes LzmaDec_AllocateProbs2(CLzma
-   return SZ_OK;
- }
- 
--SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
-+static SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
- {
-   CLzmaProps propNew;
-   RINOK(LzmaProps_Decode(&propNew, props, propsSize));
-@@ -943,28 +891,6 @@ SRes LzmaDec_AllocateProbs(CLzmaDec *p,
-   p->prop = propNew;
-   return SZ_OK;
- }
--
--SRes LzmaDec_Allocate(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
--{
--  CLzmaProps propNew;
--  SizeT dicBufSize;
--  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
--  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
--  dicBufSize = propNew.dicSize;
--  if (p->dic == 0 || dicBufSize != p->dicBufSize)
--  {
--    LzmaDec_FreeDict(p, alloc);
--    p->dic = (Byte *)alloc->Alloc(alloc, dicBufSize);
--    if (p->dic == 0)
--    {
--      LzmaDec_FreeProbs(p, alloc);
--      return SZ_ERROR_MEM;
--    }
--  }
--  p->dicBufSize = dicBufSize;
--  p->prop = propNew;
--  return SZ_OK;
--}
- 
- SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
-     const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
---- a/lib/lzma/LzmaEnc.c
-+++ b/lib/lzma/LzmaEnc.c
-@@ -53,7 +53,7 @@ void LzmaEncProps_Init(CLzmaEncProps *p)
-   p->writeEndMark = 0;
- }
- 
--void LzmaEncProps_Normalize(CLzmaEncProps *p)
-+static void LzmaEncProps_Normalize(CLzmaEncProps *p)
- {
-   int level = p->level;
-   if (level < 0) level = 5;
-@@ -76,7 +76,7 @@ void LzmaEncProps_Normalize(CLzmaEncProp
-       #endif
- }
- 
--UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
-+static UInt32 __maybe_unused LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
- {
-   CLzmaEncProps props = *props2;
-   LzmaEncProps_Normalize(&props);
-@@ -93,7 +93,7 @@ UInt32 LzmaEncProps_GetDictSize(const CL
- 
- #define BSR2_RET(pos, res) { unsigned long i; _BitScanReverse(&i, (pos)); res = (i + i) + ((pos >> (i - 1)) & 1); }
- 
--UInt32 GetPosSlot1(UInt32 pos)
-+static UInt32 GetPosSlot1(UInt32 pos)
- {
-   UInt32 res;
-   BSR2_RET(pos, res);
-@@ -107,7 +107,7 @@ UInt32 GetPosSlot1(UInt32 pos)
- #define kNumLogBits (9 + (int)sizeof(size_t) / 2)
- #define kDicLogSizeMaxCompress ((kNumLogBits - 1) * 2 + 7)
- 
--void LzmaEnc_FastPosInit(Byte *g_FastPos)
-+static void LzmaEnc_FastPosInit(Byte *g_FastPos)
- {
-   int c = 2, slotFast;
-   g_FastPos[0] = 0;
-@@ -339,58 +339,6 @@ typedef struct
-   CSaveState saveState;
- } CLzmaEnc;
- 
--void LzmaEnc_SaveState(CLzmaEncHandle pp)
--{
--  CLzmaEnc *p = (CLzmaEnc *)pp;
--  CSaveState *dest = &p->saveState;
--  int i;
--  dest->lenEnc = p->lenEnc;
--  dest->repLenEnc = p->repLenEnc;
--  dest->state = p->state;
--
--  for (i = 0; i < kNumStates; i++)
--  {
--    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
--    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
--  }
--  for (i = 0; i < kNumLenToPosStates; i++)
--    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
--  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
--  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
--  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
--  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
--  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
--  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
--  memcpy(dest->reps, p->reps, sizeof(p->reps));
--  memcpy(dest->litProbs, p->litProbs, (0x300 << p->lclp) * sizeof(CLzmaProb));
--}
--
--void LzmaEnc_RestoreState(CLzmaEncHandle pp)
--{
--  CLzmaEnc *dest = (CLzmaEnc *)pp;
--  const CSaveState *p = &dest->saveState;
--  int i;
--  dest->lenEnc = p->lenEnc;
--  dest->repLenEnc = p->repLenEnc;
--  dest->state = p->state;
--
--  for (i = 0; i < kNumStates; i++)
--  {
--    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
--    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
--  }
--  for (i = 0; i < kNumLenToPosStates; i++)
--    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
--  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
--  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
--  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
--  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
--  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
--  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
--  memcpy(dest->reps, p->reps, sizeof(p->reps));
--  memcpy(dest->litProbs, p->litProbs, (0x300 << dest->lclp) * sizeof(CLzmaProb));
--}
--
- SRes LzmaEnc_SetProps(CLzmaEncHandle pp, const CLzmaEncProps *props2)
- {
-   CLzmaEnc *p = (CLzmaEnc *)pp;
-@@ -600,7 +548,7 @@ static void LitEnc_EncodeMatched(CRangeE
-   while (symbol < 0x10000);
- }
- 
--void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
-+static void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
- {
-   UInt32 i;
-   for (i = (1 << kNumMoveReducingBits) / 2; i < kBitModelTotal; i += (1 << kNumMoveReducingBits))
-@@ -1676,7 +1624,7 @@ static void FillDistancesPrices(CLzmaEnc
-   p->matchPriceCount = 0;
- }
- 
--void LzmaEnc_Construct(CLzmaEnc *p)
-+static void LzmaEnc_Construct(CLzmaEnc *p)
- {
-   RangeEnc_Construct(&p->rc);
-   MatchFinder_Construct(&p->matchFinderBase);
-@@ -1709,7 +1657,7 @@ CLzmaEncHandle LzmaEnc_Create(ISzAlloc *
-   return p;
- }
- 
--void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
-+static void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
- {
-   alloc->Free(alloc, p->litProbs);
-   alloc->Free(alloc, p->saveState.litProbs);
-@@ -1717,7 +1665,7 @@ void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAl
-   p->saveState.litProbs = 0;
- }
- 
--void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
-+static void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
- {
-   #ifndef _7ZIP_ST
-   MatchFinderMt_Destruct(&p->matchFinderMt, allocBig);
-@@ -1947,7 +1895,7 @@ static SRes LzmaEnc_Alloc(CLzmaEnc *p, U
-   return SZ_OK;
- }
- 
--void LzmaEnc_Init(CLzmaEnc *p)
-+static void LzmaEnc_Init(CLzmaEnc *p)
- {
-   UInt32 i;
-   p->state = 0;
-@@ -2005,7 +1953,7 @@ void LzmaEnc_Init(CLzmaEnc *p)
-   p->lpMask = (1 << p->lp) - 1;
- }
- 
--void LzmaEnc_InitPrices(CLzmaEnc *p)
-+static void LzmaEnc_InitPrices(CLzmaEnc *p)
- {
-   if (!p->fastMode)
-   {
-@@ -2037,26 +1985,6 @@ static SRes LzmaEnc_AllocAndInit(CLzmaEn
-   return SZ_OK;
- }
- 
--static SRes LzmaEnc_Prepare(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream,
--    ISzAlloc *alloc, ISzAlloc *allocBig)
--{
--  CLzmaEnc *p = (CLzmaEnc *)pp;
--  p->matchFinderBase.stream = inStream;
--  p->needInit = 1;
--  p->rc.outStream = outStream;
--  return LzmaEnc_AllocAndInit(p, 0, alloc, allocBig);
--}
--
--SRes LzmaEnc_PrepareForLzma2(CLzmaEncHandle pp,
--    ISeqInStream *inStream, UInt32 keepWindowSize,
--    ISzAlloc *alloc, ISzAlloc *allocBig)
--{
--  CLzmaEnc *p = (CLzmaEnc *)pp;
--  p->matchFinderBase.stream = inStream;
--  p->needInit = 1;
--  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
--}
--
- static void LzmaEnc_SetInputBuf(CLzmaEnc *p, const Byte *src, SizeT srcLen)
- {
-   p->matchFinderBase.directInput = 1;
-@@ -2064,7 +1992,7 @@ static void LzmaEnc_SetInputBuf(CLzmaEnc
-   p->matchFinderBase.directInputRem = srcLen;
- }
- 
--SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
-+static SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
-     UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
- {
-   CLzmaEnc *p = (CLzmaEnc *)pp;
-@@ -2074,7 +2002,7 @@ SRes LzmaEnc_MemPrepare(CLzmaEncHandle p
-   return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
- }
- 
--void LzmaEnc_Finish(CLzmaEncHandle pp)
-+static void LzmaEnc_Finish(CLzmaEncHandle pp)
- {
-   #ifndef _7ZIP_ST
-   CLzmaEnc *p = (CLzmaEnc *)pp;
-@@ -2107,53 +2035,6 @@ static size_t MyWrite(void *pp, const vo
-   return size;
- }
- 
--
--UInt32 LzmaEnc_GetNumAvailableBytes(CLzmaEncHandle pp)
--{
--  const CLzmaEnc *p = (CLzmaEnc *)pp;
--  return p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
--}
--
--const Byte *LzmaEnc_GetCurBuf(CLzmaEncHandle pp)
--{
--  const CLzmaEnc *p = (CLzmaEnc *)pp;
--  return p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
--}
--
--SRes LzmaEnc_CodeOneMemBlock(CLzmaEncHandle pp, Bool reInit,
--    Byte *dest, size_t *destLen, UInt32 desiredPackSize, UInt32 *unpackSize)
--{
--  CLzmaEnc *p = (CLzmaEnc *)pp;
--  UInt64 nowPos64;
--  SRes res;
--  CSeqOutStreamBuf outStream;
--
--  outStream.funcTable.Write = MyWrite;
--  outStream.data = dest;
--  outStream.rem = *destLen;
--  outStream.overflow = False;
--
--  p->writeEndMark = False;
--  p->finished = False;
--  p->result = SZ_OK;
--
--  if (reInit)
--    LzmaEnc_Init(p);
--  LzmaEnc_InitPrices(p);
--  nowPos64 = p->nowPos64;
--  RangeEnc_Init(&p->rc);
--  p->rc.outStream = &outStream.funcTable;
--
--  res = LzmaEnc_CodeOneBlock(p, True, desiredPackSize, *unpackSize);
--  
--  *unpackSize = (UInt32)(p->nowPos64 - nowPos64);
--  *destLen -= outStream.rem;
--  if (outStream.overflow)
--    return SZ_ERROR_OUTPUT_EOF;
--
--  return res;
--}
--
- static SRes LzmaEnc_Encode2(CLzmaEnc *p, ICompressProgress *progress)
- {
-   SRes res = SZ_OK;
-@@ -2184,13 +2065,6 @@ static SRes LzmaEnc_Encode2(CLzmaEnc *p,
-   return res;
- }
- 
--SRes LzmaEnc_Encode(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress,
--    ISzAlloc *alloc, ISzAlloc *allocBig)
--{
--  RINOK(LzmaEnc_Prepare(pp, outStream, inStream, alloc, allocBig));
--  return LzmaEnc_Encode2((CLzmaEnc *)pp, progress);
--}
--
- SRes LzmaEnc_WriteProperties(CLzmaEncHandle pp, Byte *props, SizeT *size)
- {
-   CLzmaEnc *p = (CLzmaEnc *)pp;
-@@ -2247,25 +2121,3 @@ SRes LzmaEnc_MemEncode(CLzmaEncHandle pp
-     return SZ_ERROR_OUTPUT_EOF;
-   return res;
- }
--
--SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
--    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
--    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
--{
--  CLzmaEnc *p = (CLzmaEnc *)LzmaEnc_Create(alloc);
--  SRes res;
--  if (p == 0)
--    return SZ_ERROR_MEM;
--
--  res = LzmaEnc_SetProps(p, props);
--  if (res == SZ_OK)
--  {
--    res = LzmaEnc_WriteProperties(p, propsEncoded, propsSize);
--    if (res == SZ_OK)
--      res = LzmaEnc_MemEncode(p, dest, destLen, src, srcLen,
--          writeEndMark, progress, alloc, allocBig);
--  }
--
--  LzmaEnc_Destroy(p, alloc, allocBig);
--  return res;
--}
--- a/target/linux/generic/hack-4.19/550-loop-better-discard-for-block-devices.patch	2022-03-22 08:54:47.215464683 +0800
+++ b/target/linux/generic/hack-4.19/550-loop-better-discard-for-block-devices.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,164 +0,0 @@
-From: Evan Green <evgreen@chromium.org>
-Subject: [PATCH v5 0/2] loop: Better discard for block devices
-Date: Mon,  6 May 2019 11:27:35 -0700
-Message-Id: <20190506182736.21064-2-evgreen@chromium.org>
-
-This series addresses some errors seen when using the loop
-device directly backed by a block device.
-
-The first change titled "loop: Better discard for block devices"
-plumbs out the correct error message, and the second change prevents
-the error from occurring in many cases.
-
-The errors look like this:
-[   90.880875] print_req_error: I/O error, dev loop5, sector 0
-
-The errors occur when trying to do a discard or write zeroes operation
-on a loop device backed by a block device that does not support write zeroes.
-Firstly, the error itself is incorrectly reported as I/O error, but is
-actually EOPNOTSUPP. The first patch plumbs out EOPNOTSUPP to properly
-report the error.
-
-The second patch called "loop: Better discard support for block devices"
-prevents these errors from occurring by mirroring the zeroing capabilities
-of the underlying block device into the loop device.
-Before this change, discard was always reported as being supported, and
-the loop device simply turns around and does an fallocate operation on the
-backing device. After this change, backing block devices that do support
-zeroing will continue to work as before, and continue to get all the
-benefits of doing that. Backing devices that do not support zeroing will
-fail earlier, avoiding hitting the loop device at all and ultimately
-avoiding this error in the logs.
-
-I can also confirm that this fixes test block/003 in the blktests, when
-running blktests on a loop device backed by a block device.
-
-Signed-off-by: Evan Green <evgreen@chromium.org>
-Reviewed-by: Ming Lei <ming.lei@redhat.com>
-Reviewed-by: Bart Van Assche <bvanassche@acm.org>
-Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
-Reviewed-by: Gwendal Grignou <gwendal@chromium.org>
-Reviewed-by: Chaitanya Kulkarni <chaitanya.kulkarni@wdc.com>
----
-
---- a/drivers/block/loop.c
-+++ b/drivers/block/loop.c
-@@ -416,19 +416,14 @@ out_free_page:
- 	return ret;
- }
- 
--static int lo_discard(struct loop_device *lo, struct request *rq, loff_t pos)
-+static int lo_discard(struct loop_device *lo, struct request *rq,
-+		int mode, loff_t pos)
- {
--	/*
--	 * We use punch hole to reclaim the free space used by the
--	 * image a.k.a. discard. However we do not support discard if
--	 * encryption is enabled, because it may give an attacker
--	 * useful information.
--	 */
- 	struct file *file = lo->lo_backing_file;
--	int mode = FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE;
-+	struct request_queue *q = lo->lo_queue;
- 	int ret;
- 
--	if ((!file->f_op->fallocate) || lo->lo_encrypt_key_size) {
-+	if (!blk_queue_discard(q)) {
- 		ret = -EOPNOTSUPP;
- 		goto out;
- 	}
-@@ -457,7 +452,9 @@ static void lo_complete_rq(struct reques
- 
- 	if (!cmd->use_aio || cmd->ret < 0 || cmd->ret == blk_rq_bytes(rq) ||
- 	    req_op(rq) != REQ_OP_READ) {
--		if (cmd->ret < 0)
-+		if (cmd->ret == -EOPNOTSUPP)
-+			ret = BLK_STS_NOTSUPP;
-+		else if (cmd->ret < 0)
- 			ret = BLK_STS_IOERR;
- 		goto end_io;
- 	}
-@@ -597,8 +594,13 @@ static int do_req_filebacked(struct loop
- 	case REQ_OP_FLUSH:
- 		return lo_req_flush(lo, rq);
- 	case REQ_OP_DISCARD:
-+		return lo_discard(lo, rq,
-+			FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE, pos);
-+
- 	case REQ_OP_WRITE_ZEROES:
--		return lo_discard(lo, rq, pos);
-+		return lo_discard(lo, rq,
-+			FALLOC_FL_ZERO_RANGE | FALLOC_FL_KEEP_SIZE, pos);
-+
- 	case REQ_OP_WRITE:
- 		if (lo->transfer)
- 			return lo_write_transfer(lo, rq, pos);
-@@ -853,6 +855,21 @@ static void loop_config_discard(struct l
- 	struct file *file = lo->lo_backing_file;
- 	struct inode *inode = file->f_mapping->host;
- 	struct request_queue *q = lo->lo_queue;
-+	struct request_queue *backingq;
-+
-+	/*
-+	 * If the backing device is a block device, mirror its zeroing
-+	 * capability. REQ_OP_DISCARD translates to a zero-out even when backed
-+	 * by block devices to keep consistent behavior with file-backed loop
-+	 * devices.
-+	 */
-+	if (S_ISBLK(inode->i_mode) && !lo->lo_encrypt_key_size) {
-+		backingq = bdev_get_queue(inode->i_bdev);
-+		blk_queue_max_discard_sectors(q,
-+			backingq->limits.max_write_zeroes_sectors);
-+
-+		blk_queue_max_write_zeroes_sectors(q,
-+			backingq->limits.max_write_zeroes_sectors);
- 
- 	/*
- 	 * We use punch hole to reclaim the free space used by the
-@@ -860,22 +877,24 @@ static void loop_config_discard(struct l
- 	 * encryption is enabled, because it may give an attacker
- 	 * useful information.
- 	 */
--	if ((!file->f_op->fallocate) ||
--	    lo->lo_encrypt_key_size) {
-+	} else if ((!file->f_op->fallocate) || lo->lo_encrypt_key_size) {
- 		q->limits.discard_granularity = 0;
- 		q->limits.discard_alignment = 0;
- 		blk_queue_max_discard_sectors(q, 0);
- 		blk_queue_max_write_zeroes_sectors(q, 0);
--		blk_queue_flag_clear(QUEUE_FLAG_DISCARD, q);
--		return;
--	}
- 
--	q->limits.discard_granularity = inode->i_sb->s_blocksize;
--	q->limits.discard_alignment = 0;
-+	} else {
-+		q->limits.discard_granularity = inode->i_sb->s_blocksize;
-+		q->limits.discard_alignment = 0;
- 
--	blk_queue_max_discard_sectors(q, UINT_MAX >> 9);
--	blk_queue_max_write_zeroes_sectors(q, UINT_MAX >> 9);
--	blk_queue_flag_set(QUEUE_FLAG_DISCARD, q);
-+		blk_queue_max_discard_sectors(q, UINT_MAX >> 9);
-+		blk_queue_max_write_zeroes_sectors(q, UINT_MAX >> 9);
-+	}
-+
-+	if (q->limits.max_write_zeroes_sectors)
-+		blk_queue_flag_set(QUEUE_FLAG_DISCARD, q);
-+	else
-+		blk_queue_flag_clear(QUEUE_FLAG_DISCARD, q);
- }
- 
- static void loop_unprepare_queue(struct loop_device *lo)
-@@ -1894,7 +1913,10 @@ static void loop_handle_cmd(struct loop_
-  failed:
- 	/* complete non-aio request */
- 	if (!cmd->use_aio || ret) {
--		cmd->ret = ret ? -EIO : 0;
-+		if (ret == -EOPNOTSUPP)
-+			cmd->ret = ret;
-+		else
-+			cmd->ret = ret ? -EIO : 0;
- 		blk_mq_complete_request(rq);
- 	}
- }
--- a/target/linux/generic/hack-4.19/640-bridge-only-accept-EAP-locally.patch	2022-03-22 08:54:47.215464683 +0800
+++ b/target/linux/generic/hack-4.19/640-bridge-only-accept-EAP-locally.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,82 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 17:18:54 +0200
-Subject: bridge: only accept EAP locally
-
-When bridging, do not forward EAP frames to other ports, only deliver
-them locally, regardless of the state.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
-[add disable_eap_hack sysfs attribute]
-Signed-off-by: Etienne Champetier <champetier.etienne@gmail.com>
----
-
---- a/net/bridge/br_input.c
-+++ b/net/bridge/br_input.c
-@@ -108,10 +108,14 @@ int br_handle_frame_finish(struct net *n
- 		}
- 	}
- 
-+	BR_INPUT_SKB_CB(skb)->brdev = br->dev;
-+
-+	if (skb->protocol == htons(ETH_P_PAE) && !br->disable_eap_hack)
-+		return br_pass_frame_up(skb);
-+
- 	if (p->state == BR_STATE_LEARNING)
- 		goto drop;
- 
--	BR_INPUT_SKB_CB(skb)->brdev = br->dev;
- 	BR_INPUT_SKB_CB(skb)->src_port_isolated = !!(p->flags & BR_ISOLATED);
- 
- 	if (IS_ENABLED(CONFIG_INET) &&
---- a/net/bridge/br_private.h
-+++ b/net/bridge/br_private.h
-@@ -337,6 +337,8 @@ struct net_bridge {
- 	u16				group_fwd_mask;
- 	u16				group_fwd_mask_required;
- 
-+	bool				disable_eap_hack;
-+
- 	/* STP */
- 	bridge_id			designated_root;
- 	bridge_id			bridge_id;
---- a/net/bridge/br_sysfs_br.c
-+++ b/net/bridge/br_sysfs_br.c
-@@ -170,6 +170,30 @@ static ssize_t group_fwd_mask_store(stru
- }
- static DEVICE_ATTR_RW(group_fwd_mask);
- 
-+static ssize_t disable_eap_hack_show(struct device *d,
-+				   struct device_attribute *attr,
-+				   char *buf)
-+{
-+	struct net_bridge *br = to_bridge(d);
-+	return sprintf(buf, "%u\n", br->disable_eap_hack);
-+}
-+
-+static int set_disable_eap_hack(struct net_bridge *br, unsigned long val)
-+{
-+	br->disable_eap_hack = !!val;
-+
-+	return 0;
-+}
-+
-+static ssize_t disable_eap_hack_store(struct device *d,
-+				    struct device_attribute *attr,
-+				    const char *buf,
-+				    size_t len)
-+{
-+	return store_bridge_parm(d, buf, len, set_disable_eap_hack);
-+}
-+static DEVICE_ATTR_RW(disable_eap_hack);
-+
- static ssize_t priority_show(struct device *d, struct device_attribute *attr,
- 			     char *buf)
- {
-@@ -810,6 +834,7 @@ static struct attribute *bridge_attrs[]
- 	&dev_attr_ageing_time.attr,
- 	&dev_attr_stp_state.attr,
- 	&dev_attr_group_fwd_mask.attr,
-+	&dev_attr_disable_eap_hack.attr,
- 	&dev_attr_priority.attr,
- 	&dev_attr_bridge_id.attr,
- 	&dev_attr_root_id.attr,
--- a/target/linux/generic/hack-4.19/645-netfilter-connmark-introduce-savedscp.patch	2022-03-22 08:54:47.215464683 +0800
+++ b/target/linux/generic/hack-4.19/645-netfilter-connmark-introduce-savedscp.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,135 +0,0 @@
-From f171924dcf1d0b31fb7bd1cff113d7a1f7f05ec2 Mon Sep 17 00:00:00 2001
-From: Kevin Darbyshire-Bryant <ldir@darbyshire-bryant.me.uk>
-Date: Sat, 23 Mar 2019 09:29:49 +0000
-Subject: [PATCH] netfilter: connmark: introduce savedscp
-
-savedscp is a method of storing the DSCP of an ip packet into conntrack
-mark.  In combination with a suitable tc filter action (act_ctinfo) DSCP
-values are able to be stored in the mark on egress and restored on
-ingress across links that otherwise alter or bleach DSCP.
-
-This is useful for qdiscs such as CAKE which are able to shape according
-to policies based on DSCP.
-
-Ingress classification is traditionally a challenging task since
-iptables rules haven't yet run and tc filter/eBPF programs are pre-NAT
-lookups, hence are unable to see internal IPv4 addresses as used on the
-typical home masquerading gateway.
-
-x_tables CONNMARK savedscp action solves the problem of storing the DSCP
-to the conntrack mark in a way suitable for the new act_ctinfo tc action
-to restore.
-
-The savedsp option accepts 2 parameters, a 32bit 'dscpmask' and a 32bit
-'statemask'.  The dscp mask must be a minimum of 6 contiguous bits and
-represents the area where the DSCP will be stored in the connmark.  The
-state mask is a minimum 1 bit length mask that must not overlap with the
-dscpmask.  It represents a flag which is set when the DSCP has been
-stored in the conntrack mark. This is useful to implement a 'one shot'
-iptables based classification where the 'complicated' iptables rules are
-only run once to classify the connection on initial (egress) packet and
-subsequent packets are all marked/restored with the same DSCP.  A state
-mask of zero disables the setting of a status bit/s.
-
-example syntax with a suitably modified iptables user space application:
-
-iptables -A QOS_MARK_eth0 -t mangle -j CONNMARK --savedscp-mark 0xfc000000/0x01000000
-
-Would store the DSCP in the top 6 bits of the 32bit mark field, and use
-the LSB of the top byte as the 'DSCP has been stored' marker.
-
-|----0xFC----conntrack mark----000000---|
-| Bits 31-26 | bit 25 | bit24 |~~~ Bit 0|
-| DSCP       | unused | flag  |unused   |
-|-----------------------0x01---000000---|
-      ^                   ^
-      |                   |
-      ---|             Conditional flag
-         |             set this when dscp
-|-ip diffserv-|        stored in mark
-| 6 bits      |
-|-------------|
-
-an identically configured tc action to restore looks like:
-
-tc filter show dev eth0 ingress
-filter parent ffff: protocol all pref 10 u32 chain 0
-filter parent ffff: protocol all pref 10 u32 chain 0 fh 800: ht divisor 1
-filter parent ffff: protocol all pref 10 u32 chain 0 fh 800::800 order 2048 key ht 800 bkt 0 flowid 1:1 not_in_hw
-  match 00000000/00000000 at 0
-	action order 1: ctinfo zone 0 pipe
-	 index 2 ref 1 bind 1 dscp 0xfc000000/0x1000000
-
-	action order 2: mirred (Egress Redirect to device ifb4eth0) stolen
-	index 1 ref 1 bind 1
-
-|----0xFC----conntrack mark----000000---|
-| Bits 31-26 | bit 25 | bit24 |~~~ Bit 0|
-| DSCP       | unused | flag  |unused   |
-|-----------------------0x01---000000---|
-      |                   |
-      |                   |
-      ---|             Conditional flag
-         v             only restore if set
-|-ip diffserv-|
-| 6 bits      |
-|-------------|
-
-Signed-off-by: Kevin Darbyshire-Bryant <ldir@darbyshire-bryant.me.uk>
----
- include/uapi/linux/netfilter/xt_connmark.h |  3 ++-
- net/netfilter/xt_connmark.c                | 17 +++++++++++++++++
- 2 files changed, 19 insertions(+), 1 deletion(-)
-
---- a/include/uapi/linux/netfilter/xt_connmark.h
-+++ b/include/uapi/linux/netfilter/xt_connmark.h
-@@ -16,7 +16,8 @@
- enum {
- 	XT_CONNMARK_SET = 0,
- 	XT_CONNMARK_SAVE,
--	XT_CONNMARK_RESTORE
-+	XT_CONNMARK_RESTORE,
-+	XT_CONNMARK_SAVEDSCP
- };
- 
- enum {
---- a/net/netfilter/xt_connmark.c
-+++ b/net/netfilter/xt_connmark.c
-@@ -42,6 +42,7 @@ connmark_tg_shift(struct sk_buff *skb, c
- 	u_int32_t new_targetmark;
- 	struct nf_conn *ct;
- 	u_int32_t newmark;
-+	u_int8_t dscp;
- 
- 	ct = nf_ct_get(skb, &ctinfo);
- 	if (ct == NULL)
-@@ -74,6 +75,21 @@ connmark_tg_shift(struct sk_buff *skb, c
- 			nf_conntrack_event_cache(IPCT_MARK, ct);
- 		}
- 		break;
-+	case XT_CONNMARK_SAVEDSCP:
-+		if (skb->protocol == htons(ETH_P_IP))
-+			dscp = ipv4_get_dsfield(ip_hdr(skb)) >> 2;
-+		else if (skb->protocol == htons(ETH_P_IPV6))
-+			dscp = ipv6_get_dsfield(ipv6_hdr(skb)) >> 2;
-+		else	/* protocol doesn't have diffserv */
-+			break;
-+
-+		newmark = (ct->mark & ~info->ctmark) |
-+			  (info->ctmask | (dscp << info->shift_bits));
-+		if (ct->mark != newmark) {
-+			ct->mark = newmark;
-+			nf_conntrack_event_cache(IPCT_MARK, ct);
-+		}
-+		break;
- 	case XT_CONNMARK_RESTORE:
- 		new_targetmark = (ct->mark & info->ctmask);
- 		if (info->shift_dir == D_SHIFT_RIGHT)
-@@ -86,6 +102,7 @@ connmark_tg_shift(struct sk_buff *skb, c
- 		skb->mark = newmark;
- 		break;
- 	}
-+out:
- 	return XT_CONTINUE;
- }
- 
--- a/target/linux/generic/hack-4.19/647-netfilter-flow-acct.patch	2022-03-22 08:54:47.216464684 +0800
+++ b/target/linux/generic/hack-4.19/647-netfilter-flow-acct.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,70 +0,0 @@
---- a/include/net/netfilter/nf_flow_table.h
-+++ b/include/net/netfilter/nf_flow_table.h
-@@ -163,6 +163,8 @@ struct nf_flow_table_hw {
- int nf_flow_table_hw_register(const struct nf_flow_table_hw *offload);
- void nf_flow_table_hw_unregister(const struct nf_flow_table_hw *offload);
- 
-+void nf_flow_table_acct(struct flow_offload *flow, struct sk_buff *skb, int dir);
-+
- extern struct work_struct nf_flow_offload_hw_work;
- 
- #define MODULE_ALIAS_NF_FLOWTABLE(family)	\
---- a/net/netfilter/nf_flow_table_core.c
-+++ b/net/netfilter/nf_flow_table_core.c
-@@ -11,6 +11,7 @@
- #include <net/netfilter/nf_conntrack.h>
- #include <net/netfilter/nf_conntrack_core.h>
- #include <net/netfilter/nf_conntrack_tuple.h>
-+#include <net/netfilter/nf_conntrack_acct.h>
- 
- struct flow_offload_entry {
- 	struct flow_offload	flow;
-@@ -149,6 +150,22 @@ void flow_offload_free(struct flow_offlo
- }
- EXPORT_SYMBOL_GPL(flow_offload_free);
- 
-+void nf_flow_table_acct(struct flow_offload *flow, struct sk_buff *skb, int dir)
-+{
-+	struct flow_offload_entry *entry;
-+	struct nf_conn_acct *acct;
-+
-+	entry = container_of(flow, struct flow_offload_entry, flow);
-+	acct = nf_conn_acct_find(entry->ct);
-+	if (acct) {
-+		struct nf_conn_counter *counter = acct->counter;
-+
-+		atomic64_inc(&counter[dir].packets);
-+		atomic64_add(skb->len, &counter[dir].bytes);
-+	}
-+}
-+EXPORT_SYMBOL_GPL(nf_flow_table_acct);
-+
- static u32 flow_offload_hash(const void *data, u32 len, u32 seed)
- {
- 	const struct flow_offload_tuple *tuple = data;
---- a/net/netfilter/nf_flow_table_ip.c
-+++ b/net/netfilter/nf_flow_table_ip.c
-@@ -11,6 +11,7 @@
- #include <net/ip6_route.h>
- #include <net/neighbour.h>
- #include <net/netfilter/nf_flow_table.h>
-+
- /* For layer 4 checksum field offset. */
- #include <linux/tcp.h>
- #include <linux/udp.h>
-@@ -267,6 +268,7 @@ nf_flow_offload_ip_hook(void *priv, stru
- 	skb->dev = outdev;
- 	nexthop = rt_nexthop(rt, flow->tuplehash[!dir].tuple.src_v4.s_addr);
- 	skb_dst_set_noref(skb, &rt->dst);
-+	nf_flow_table_acct(flow, skb, dir);
- 	neigh_xmit(NEIGH_ARP_TABLE, outdev, &nexthop, skb);
- 
- 	return NF_STOLEN;
-@@ -487,6 +489,7 @@ nf_flow_offload_ipv6_hook(void *priv, st
- 	skb->dev = outdev;
- 	nexthop = rt6_nexthop(rt, &flow->tuplehash[!dir].tuple.src_v6);
- 	skb_dst_set_noref(skb, &rt->dst);
-+	nf_flow_table_acct(flow, skb, dir);
- 	neigh_xmit(NEIGH_ND_TABLE, outdev, nexthop, skb);
- 
- 	return NF_STOLEN;
--- a/target/linux/generic/hack-4.19/650-netfilter-add-xt_OFFLOAD-target.patch	2022-03-22 08:54:47.216464684 +0800
+++ b/target/linux/generic/hack-4.19/650-netfilter-add-xt_OFFLOAD-target.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,552 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Tue, 20 Feb 2018 15:56:02 +0100
-Subject: [PATCH] netfilter: add xt_OFFLOAD target
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- create mode 100644 net/netfilter/xt_OFFLOAD.c
-
---- a/net/ipv4/netfilter/Kconfig
-+++ b/net/ipv4/netfilter/Kconfig
-@@ -63,8 +63,6 @@ config NF_TABLES_ARP
- 	help
- 	  This option enables the ARP support for nf_tables.
- 
--endif # NF_TABLES
--
- config NF_FLOW_TABLE_IPV4
- 	tristate "Netfilter flow table IPv4 module"
- 	depends on NF_FLOW_TABLE
-@@ -73,6 +71,8 @@ config NF_FLOW_TABLE_IPV4
- 
- 	  To compile it as a module, choose M here.
- 
-+endif # NF_TABLES
-+
- config NF_DUP_IPV4
- 	tristate "Netfilter IPv4 packet duplication to alternate destination"
- 	depends on !NF_CONNTRACK || NF_CONNTRACK
---- a/net/ipv6/netfilter/Kconfig
-+++ b/net/ipv6/netfilter/Kconfig
-@@ -80,7 +80,6 @@ config NFT_FIB_IPV6
- 	  multicast or blackhole.
- 
- endif # NF_TABLES_IPV6
--endif # NF_TABLES
- 
- config NF_FLOW_TABLE_IPV6
- 	tristate "Netfilter flow table IPv6 module"
-@@ -90,6 +89,8 @@ config NF_FLOW_TABLE_IPV6
- 
- 	  To compile it as a module, choose M here.
- 
-+endif # NF_TABLES
-+
- config NF_DUP_IPV6
- 	tristate "Netfilter IPv6 packet duplication to alternate destination"
- 	depends on !NF_CONNTRACK || NF_CONNTRACK
---- a/net/netfilter/Kconfig
-+++ b/net/netfilter/Kconfig
-@@ -693,8 +693,6 @@ config NFT_FIB_NETDEV
- 
- endif # NF_TABLES_NETDEV
- 
--endif # NF_TABLES
--
- config NF_FLOW_TABLE_INET
- 	tristate "Netfilter flow table mixed IPv4/IPv6 module"
- 	depends on NF_FLOW_TABLE
-@@ -703,11 +701,12 @@ config NF_FLOW_TABLE_INET
- 
- 	  To compile it as a module, choose M here.
- 
-+endif # NF_TABLES
-+
- config NF_FLOW_TABLE
- 	tristate "Netfilter flow table module"
- 	depends on NETFILTER_INGRESS
- 	depends on NF_CONNTRACK
--	depends on NF_TABLES
- 	help
- 	  This option adds the flow table core infrastructure.
- 
-@@ -996,6 +995,15 @@ config NETFILTER_XT_TARGET_NOTRACK
- 	depends on NETFILTER_ADVANCED
- 	select NETFILTER_XT_TARGET_CT
- 
-+config NETFILTER_XT_TARGET_FLOWOFFLOAD
-+	tristate '"FLOWOFFLOAD" target support'
-+	depends on NF_FLOW_TABLE
-+	depends on NETFILTER_INGRESS
-+	help
-+	  This option adds a `FLOWOFFLOAD' target, which uses the nf_flow_offload
-+	  module to speed up processing of packets by bypassing the usual
-+	  netfilter chains
-+
- config NETFILTER_XT_TARGET_RATEEST
- 	tristate '"RATEEST" target support'
- 	depends on NETFILTER_ADVANCED
---- a/net/netfilter/Makefile
-+++ b/net/netfilter/Makefile
-@@ -144,6 +144,7 @@ obj-$(CONFIG_NETFILTER_XT_TARGET_CLASSIF
- obj-$(CONFIG_NETFILTER_XT_TARGET_CONNSECMARK) += xt_CONNSECMARK.o
- obj-$(CONFIG_NETFILTER_XT_TARGET_CT) += xt_CT.o
- obj-$(CONFIG_NETFILTER_XT_TARGET_DSCP) += xt_DSCP.o
-+obj-$(CONFIG_NETFILTER_XT_TARGET_FLOWOFFLOAD) += xt_FLOWOFFLOAD.o
- obj-$(CONFIG_NETFILTER_XT_TARGET_HL) += xt_HL.o
- obj-$(CONFIG_NETFILTER_XT_TARGET_HMARK) += xt_HMARK.o
- obj-$(CONFIG_NETFILTER_XT_TARGET_LED) += xt_LED.o
---- /dev/null
-+++ b/net/netfilter/xt_FLOWOFFLOAD.c
-@@ -0,0 +1,421 @@
-+/*
-+ * Copyright (C) 2018 Felix Fietkau <nbd@nbd.name>
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License version 2 as
-+ * published by the Free Software Foundation.
-+ */
-+#include <linux/module.h>
-+#include <linux/init.h>
-+#include <linux/netfilter.h>
-+#include <linux/netfilter/xt_FLOWOFFLOAD.h>
-+#include <net/ip.h>
-+#include <net/netfilter/nf_conntrack.h>
-+#include <net/netfilter/nf_conntrack_extend.h>
-+#include <net/netfilter/nf_conntrack_helper.h>
-+#include <net/netfilter/nf_flow_table.h>
-+
-+static struct nf_flowtable nf_flowtable;
-+static HLIST_HEAD(hooks);
-+static DEFINE_SPINLOCK(hooks_lock);
-+static struct delayed_work hook_work;
-+
-+struct xt_flowoffload_hook {
-+	struct hlist_node list;
-+	struct nf_hook_ops ops;
-+	struct net *net;
-+	bool registered;
-+	bool used;
-+};
-+
-+static unsigned int
-+xt_flowoffload_net_hook(void *priv, struct sk_buff *skb,
-+			  const struct nf_hook_state *state)
-+{
-+	switch (skb->protocol) {
-+	case htons(ETH_P_IP):
-+		return nf_flow_offload_ip_hook(priv, skb, state);
-+	case htons(ETH_P_IPV6):
-+		return nf_flow_offload_ipv6_hook(priv, skb, state);
-+	}
-+
-+	return NF_ACCEPT;
-+}
-+
-+static int
-+xt_flowoffload_create_hook(struct net_device *dev)
-+{
-+	struct xt_flowoffload_hook *hook;
-+	struct nf_hook_ops *ops;
-+
-+	hook = kzalloc(sizeof(*hook), GFP_ATOMIC);
-+	if (!hook)
-+		return -ENOMEM;
-+
-+	ops = &hook->ops;
-+	ops->pf = NFPROTO_NETDEV;
-+	ops->hooknum = NF_NETDEV_INGRESS;
-+	ops->priority = 10;
-+	ops->priv = &nf_flowtable;
-+	ops->hook = xt_flowoffload_net_hook;
-+	ops->dev = dev;
-+
-+	hlist_add_head(&hook->list, &hooks);
-+	mod_delayed_work(system_power_efficient_wq, &hook_work, 0);
-+
-+	return 0;
-+}
-+
-+static struct xt_flowoffload_hook *
-+flow_offload_lookup_hook(struct net_device *dev)
-+{
-+	struct xt_flowoffload_hook *hook;
-+
-+	hlist_for_each_entry(hook, &hooks, list) {
-+		if (hook->ops.dev == dev)
-+			return hook;
-+	}
-+
-+	return NULL;
-+}
-+
-+static void
-+xt_flowoffload_check_device(struct net_device *dev)
-+{
-+	struct xt_flowoffload_hook *hook;
-+
-+	spin_lock_bh(&hooks_lock);
-+	hook = flow_offload_lookup_hook(dev);
-+	if (hook)
-+		hook->used = true;
-+	else
-+		xt_flowoffload_create_hook(dev);
-+	spin_unlock_bh(&hooks_lock);
-+}
-+
-+static void
-+xt_flowoffload_register_hooks(void)
-+{
-+	struct xt_flowoffload_hook *hook;
-+
-+restart:
-+	hlist_for_each_entry(hook, &hooks, list) {
-+		if (hook->registered)
-+			continue;
-+
-+		hook->registered = true;
-+		hook->net = dev_net(hook->ops.dev);
-+		spin_unlock_bh(&hooks_lock);
-+		nf_register_net_hook(hook->net, &hook->ops);
-+		spin_lock_bh(&hooks_lock);
-+		goto restart;
-+	}
-+
-+}
-+
-+static void
-+xt_flowoffload_cleanup_hooks(void)
-+{
-+	struct xt_flowoffload_hook *hook;
-+
-+restart:
-+	hlist_for_each_entry(hook, &hooks, list) {
-+		if (hook->used || !hook->registered)
-+			continue;
-+
-+		hlist_del(&hook->list);
-+		spin_unlock_bh(&hooks_lock);
-+		nf_unregister_net_hook(hook->net, &hook->ops);
-+		kfree(hook);
-+		spin_lock_bh(&hooks_lock);
-+		goto restart;
-+	}
-+
-+}
-+
-+static void
-+xt_flowoffload_check_hook(struct flow_offload *flow, void *data)
-+{
-+	struct flow_offload_tuple *tuple = &flow->tuplehash[0].tuple;
-+	struct xt_flowoffload_hook *hook;
-+	bool *found = data;
-+
-+	spin_lock_bh(&hooks_lock);
-+	hlist_for_each_entry(hook, &hooks, list) {
-+		if (hook->ops.dev->ifindex != tuple->iifidx &&
-+		    hook->ops.dev->ifindex != tuple->oifidx)
-+			continue;
-+
-+		hook->used = true;
-+		*found = true;
-+	}
-+	spin_unlock_bh(&hooks_lock);
-+}
-+
-+static void
-+xt_flowoffload_hook_work(struct work_struct *work)
-+{
-+	struct xt_flowoffload_hook *hook;
-+	bool found = false;
-+	int err;
-+
-+	spin_lock_bh(&hooks_lock);
-+	xt_flowoffload_register_hooks();
-+	hlist_for_each_entry(hook, &hooks, list)
-+		hook->used = false;
-+	spin_unlock_bh(&hooks_lock);
-+
-+	err = nf_flow_table_iterate(&nf_flowtable, xt_flowoffload_check_hook,
-+				    &found);
-+	if (err && err != -EAGAIN)
-+	    goto out;
-+
-+	spin_lock_bh(&hooks_lock);
-+	xt_flowoffload_cleanup_hooks();
-+	spin_unlock_bh(&hooks_lock);
-+
-+out:
-+	if (found)
-+		queue_delayed_work(system_power_efficient_wq, &hook_work, HZ);
-+}
-+
-+static bool
-+xt_flowoffload_skip(struct sk_buff *skb, int family)
-+{
-+	if (skb_sec_path(skb))
-+		return true;
-+
-+	if (family == NFPROTO_IPV4) {
-+		const struct ip_options *opt = &(IPCB(skb)->opt);
-+
-+		if (unlikely(opt->optlen))
-+			return true;
-+	}
-+
-+	return false;
-+}
-+
-+static struct dst_entry *
-+xt_flowoffload_dst(const struct nf_conn *ct, enum ip_conntrack_dir dir,
-+		   const struct xt_action_param *par, int ifindex)
-+{
-+	struct dst_entry *dst = NULL;
-+	struct flowi fl;
-+
-+	memset(&fl, 0, sizeof(fl));
-+	switch (xt_family(par)) {
-+	case NFPROTO_IPV4:
-+		fl.u.ip4.daddr = ct->tuplehash[dir].tuple.src.u3.ip;
-+		fl.u.ip4.flowi4_oif = ifindex;
-+		break;
-+	case NFPROTO_IPV6:
-+		fl.u.ip6.saddr = ct->tuplehash[dir].tuple.dst.u3.in6;
-+		fl.u.ip6.daddr = ct->tuplehash[dir].tuple.src.u3.in6;
-+		fl.u.ip6.flowi6_oif = ifindex;
-+		break;
-+	}
-+
-+	nf_route(xt_net(par), &dst, &fl, false, xt_family(par));
-+
-+	return dst;
-+}
-+
-+static int
-+xt_flowoffload_route(struct sk_buff *skb, const struct nf_conn *ct,
-+		   const struct xt_action_param *par,
-+		   struct nf_flow_route *route, enum ip_conntrack_dir dir)
-+{
-+	struct dst_entry *this_dst, *other_dst;
-+
-+	this_dst = xt_flowoffload_dst(ct, !dir, par, xt_out(par)->ifindex);
-+	other_dst = xt_flowoffload_dst(ct, dir, par, xt_in(par)->ifindex);
-+	if (!this_dst || !other_dst)
-+		return -ENOENT;
-+
-+	if (dst_xfrm(this_dst) || dst_xfrm(other_dst))
-+		return -EINVAL;
-+
-+	route->tuple[dir].dst		= this_dst;
-+	route->tuple[!dir].dst		= other_dst;
-+
-+	return 0;
-+}
-+
-+static unsigned int
-+flowoffload_tg(struct sk_buff *skb, const struct xt_action_param *par)
-+{
-+	const struct xt_flowoffload_target_info *info = par->targinfo;
-+	struct tcphdr _tcph, *tcph = NULL;
-+	enum ip_conntrack_info ctinfo;
-+	enum ip_conntrack_dir dir;
-+	struct nf_flow_route route;
-+	struct flow_offload *flow;
-+	struct nf_conn *ct;
-+	struct net *net;
-+
-+	if (xt_flowoffload_skip(skb, xt_family(par)))
-+		return XT_CONTINUE;
-+
-+	ct = nf_ct_get(skb, &ctinfo);
-+	if (ct == NULL)
-+		return XT_CONTINUE;
-+
-+	switch (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.protonum) {
-+	case IPPROTO_TCP:
-+		if (ct->proto.tcp.state != TCP_CONNTRACK_ESTABLISHED)
-+			return XT_CONTINUE;
-+
-+		tcph = skb_header_pointer(skb, par->thoff,
-+					  sizeof(_tcph), &_tcph);
-+		if (unlikely(!tcph || tcph->fin || tcph->rst))
-+			return XT_CONTINUE;
-+		break;
-+	case IPPROTO_UDP:
-+		break;
-+	default:
-+		return XT_CONTINUE;
-+	}
-+
-+	if (nf_ct_ext_exist(ct, NF_CT_EXT_HELPER) ||
-+	    ct->status & IPS_SEQ_ADJUST)
-+		return XT_CONTINUE;
-+
-+	if (!nf_ct_is_confirmed(ct))
-+		return XT_CONTINUE;
-+
-+	if (!xt_in(par) || !xt_out(par))
-+		return XT_CONTINUE;
-+
-+	if (test_and_set_bit(IPS_OFFLOAD_BIT, &ct->status))
-+		return XT_CONTINUE;
-+
-+	dir = CTINFO2DIR(ctinfo);
-+
-+	if (xt_flowoffload_route(skb, ct, par, &route, dir) < 0)
-+		goto err_flow_route;
-+
-+	flow = flow_offload_alloc(ct, &route);
-+	if (!flow)
-+		goto err_flow_alloc;
-+
-+	if (tcph) {
-+		ct->proto.tcp.seen[0].flags |= IP_CT_TCP_FLAG_BE_LIBERAL;
-+		ct->proto.tcp.seen[1].flags |= IP_CT_TCP_FLAG_BE_LIBERAL;
-+	}
-+
-+	if (flow_offload_add(&nf_flowtable, flow) < 0)
-+		goto err_flow_add;
-+
-+	xt_flowoffload_check_device(xt_in(par));
-+	xt_flowoffload_check_device(xt_out(par));
-+
-+	net = read_pnet(&nf_flowtable.ft_net);
-+	if (!net)
-+		write_pnet(&nf_flowtable.ft_net, xt_net(par));
-+
-+	if (info->flags & XT_FLOWOFFLOAD_HW)
-+		nf_flow_offload_hw_add(xt_net(par), flow, ct);
-+
-+	return XT_CONTINUE;
-+
-+err_flow_add:
-+	flow_offload_free(flow);
-+err_flow_alloc:
-+	dst_release(route.tuple[!dir].dst);
-+err_flow_route:
-+	clear_bit(IPS_OFFLOAD_BIT, &ct->status);
-+	return XT_CONTINUE;
-+}
-+
-+
-+static int flowoffload_chk(const struct xt_tgchk_param *par)
-+{
-+	struct xt_flowoffload_target_info *info = par->targinfo;
-+
-+	if (info->flags & ~XT_FLOWOFFLOAD_MASK)
-+		return -EINVAL;
-+
-+	return 0;
-+}
-+
-+static struct xt_target offload_tg_reg __read_mostly = {
-+	.family		= NFPROTO_UNSPEC,
-+	.name		= "FLOWOFFLOAD",
-+	.revision	= 0,
-+	.targetsize	= sizeof(struct xt_flowoffload_target_info),
-+	.usersize	= sizeof(struct xt_flowoffload_target_info),
-+	.checkentry	= flowoffload_chk,
-+	.target		= flowoffload_tg,
-+	.me		= THIS_MODULE,
-+};
-+
-+static int xt_flowoffload_table_init(struct nf_flowtable *table)
-+{
-+	table->flags = NF_FLOWTABLE_F_HW;
-+	nf_flow_table_init(table);
-+	return 0;
-+}
-+
-+static void xt_flowoffload_table_cleanup(struct nf_flowtable *table)
-+{
-+	nf_flow_table_free(table);
-+}
-+
-+static int flow_offload_netdev_event(struct notifier_block *this,
-+				     unsigned long event, void *ptr)
-+{
-+	struct xt_flowoffload_hook *hook = NULL;
-+	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
-+
-+	if (event != NETDEV_UNREGISTER)
-+		return NOTIFY_DONE;
-+
-+	spin_lock_bh(&hooks_lock);
-+	hook = flow_offload_lookup_hook(dev);
-+	if (hook) {
-+		hlist_del(&hook->list);
-+	}
-+	spin_unlock_bh(&hooks_lock);
-+	if (hook) {
-+		nf_unregister_net_hook(hook->net, &hook->ops);
-+		kfree(hook);
-+	}
-+
-+	nf_flow_table_cleanup(dev_net(dev), dev);
-+
-+	return NOTIFY_DONE;
-+}
-+
-+static struct notifier_block flow_offload_netdev_notifier = {
-+	.notifier_call	= flow_offload_netdev_event,
-+};
-+
-+static int __init xt_flowoffload_tg_init(void)
-+{
-+	int ret;
-+
-+	register_netdevice_notifier(&flow_offload_netdev_notifier);
-+
-+	INIT_DELAYED_WORK(&hook_work, xt_flowoffload_hook_work);
-+
-+	ret = xt_flowoffload_table_init(&nf_flowtable);
-+	if (ret)
-+		return ret;
-+
-+	ret = xt_register_target(&offload_tg_reg);
-+	if (ret)
-+		xt_flowoffload_table_cleanup(&nf_flowtable);
-+
-+	return ret;
-+}
-+
-+static void __exit xt_flowoffload_tg_exit(void)
-+{
-+	xt_unregister_target(&offload_tg_reg);
-+	xt_flowoffload_table_cleanup(&nf_flowtable);
-+	unregister_netdevice_notifier(&flow_offload_netdev_notifier);
-+}
-+
-+MODULE_LICENSE("GPL");
-+module_init(xt_flowoffload_tg_init);
-+module_exit(xt_flowoffload_tg_exit);
---- a/net/netfilter/nf_flow_table_core.c
-+++ b/net/netfilter/nf_flow_table_core.c
-@@ -6,7 +6,6 @@
- #include <linux/netdevice.h>
- #include <net/ip.h>
- #include <net/ip6_route.h>
--#include <net/netfilter/nf_tables.h>
- #include <net/netfilter/nf_flow_table.h>
- #include <net/netfilter/nf_conntrack.h>
- #include <net/netfilter/nf_conntrack_core.h>
---- /dev/null
-+++ b/include/uapi/linux/netfilter/xt_FLOWOFFLOAD.h
-@@ -0,0 +1,17 @@
-+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
-+#ifndef _XT_FLOWOFFLOAD_H
-+#define _XT_FLOWOFFLOAD_H
-+
-+#include <linux/types.h>
-+
-+enum {
-+	XT_FLOWOFFLOAD_HW	= 1 << 0,
-+
-+	XT_FLOWOFFLOAD_MASK	= XT_FLOWOFFLOAD_HW
-+};
-+
-+struct xt_flowoffload_target_info {
-+	__u32 flags;
-+};
-+
-+#endif /* _XT_FLOWOFFLOAD_H */
--- a/target/linux/generic/hack-4.19/651-wireless_mesh_header.patch	2022-03-22 08:54:47.216464684 +0800
+++ b/target/linux/generic/hack-4.19/651-wireless_mesh_header.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,24 +0,0 @@
-From 6d3bc769657b0ee7c7506dad9911111c4226a7ea Mon Sep 17 00:00:00 2001
-From: Imre Kaloz <kaloz@openwrt.org>
-Date: Fri, 7 Jul 2017 17:21:05 +0200
-Subject: mac80211: increase wireless mesh header size
-
-lede-commit 3d4466cfd8f75f717efdb1f96fdde3c70d865fc1
-Signed-off-by: Imre Kaloz <kaloz@openwrt.org>
----
- include/linux/netdevice.h | 4 ++--
- 1 file changed, 2 insertions(+), 2 deletions(-)
-
---- a/include/linux/netdevice.h
-+++ b/include/linux/netdevice.h
-@@ -140,8 +140,8 @@ static inline bool dev_xmit_complete(int
- 
- #if defined(CONFIG_HYPERV_NET)
- # define LL_MAX_HEADER 128
--#elif defined(CONFIG_WLAN) || IS_ENABLED(CONFIG_AX25)
--# if defined(CONFIG_MAC80211_MESH)
-+#elif defined(CONFIG_WLAN) || IS_ENABLED(CONFIG_AX25) || 1
-+# if defined(CONFIG_MAC80211_MESH) || 1
- #  define LL_MAX_HEADER 128
- # else
- #  define LL_MAX_HEADER 96
--- a/target/linux/generic/hack-4.19/660-fq_codel_defaults.patch	2022-03-22 08:54:47.217464686 +0800
+++ b/target/linux/generic/hack-4.19/660-fq_codel_defaults.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,27 +0,0 @@
-From a6ccb238939b25851474a279b20367fd24a0e816 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 17:21:53 +0200
-Subject:  hack: net: fq_codel: tune defaults for small devices
-
-Assume that x86_64 devices always have a big memory and do not need this 
-optimization compared to devices with only 32 MB or 64 MB RAM.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- net/sched/sch_fq_codel.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/net/sched/sch_fq_codel.c
-+++ b/net/sched/sch_fq_codel.c
-@@ -474,7 +474,11 @@ static int fq_codel_init(struct Qdisc *s
- 
- 	sch->limit = 10*1024;
- 	q->flows_cnt = 1024;
-+#ifdef CONFIG_X86_64
- 	q->memory_limit = 32 << 20; /* 32 MBytes */
-+#else
-+	q->memory_limit = 4 << 20; /* 4 MBytes */
-+#endif
- 	q->drop_batch_size = 64;
- 	q->quantum = psched_mtu(qdisc_dev(sch));
- 	INIT_LIST_HEAD(&q->new_flows);
--- a/target/linux/generic/hack-4.19/661-use_fq_codel_by_default.patch	2022-03-22 08:54:47.217464686 +0800
+++ b/target/linux/generic/hack-4.19/661-use_fq_codel_by_default.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,94 +0,0 @@
-From 1d418f7e88035ed7a94073f6354246c66e9193e9 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 17:22:58 +0200
-Subject: fq_codel: switch default qdisc from pfifo_fast to fq_codel and remove pfifo_fast
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/net/sch_generic.h | 3 ++-
- net/sched/Kconfig         | 3 ++-
- net/sched/sch_api.c       | 2 +-
- net/sched/sch_fq_codel.c  | 3 ++-
- net/sched/sch_generic.c   | 4 ++--
- 5 files changed, 9 insertions(+), 6 deletions(-)
-
---- a/include/net/sch_generic.h
-+++ b/include/net/sch_generic.h
-@@ -486,12 +486,13 @@ extern struct Qdisc_ops noop_qdisc_ops;
- extern struct Qdisc_ops pfifo_fast_ops;
- extern struct Qdisc_ops mq_qdisc_ops;
- extern struct Qdisc_ops noqueue_qdisc_ops;
-+extern struct Qdisc_ops fq_codel_qdisc_ops;
- extern const struct Qdisc_ops *default_qdisc_ops;
- static inline const struct Qdisc_ops *
- get_default_qdisc_ops(const struct net_device *dev, int ntx)
- {
- 	return ntx < dev->real_num_tx_queues ?
--			default_qdisc_ops : &pfifo_fast_ops;
-+			default_qdisc_ops : &fq_codel_qdisc_ops;
- }
- 
- struct Qdisc_class_common {
---- a/net/sched/Kconfig
-+++ b/net/sched/Kconfig
-@@ -3,8 +3,9 @@
- #
- 
- menuconfig NET_SCHED
--	bool "QoS and/or fair queueing"
-+	def_bool y
- 	select NET_SCH_FIFO
-+	select NET_SCH_FQ_CODEL
- 	---help---
- 	  When the kernel has several packets to send out over a network
- 	  device, it has to decide which ones to send first, which ones to
---- a/net/sched/sch_api.c
-+++ b/net/sched/sch_api.c
-@@ -2160,7 +2160,7 @@ static int __init pktsched_init(void)
- 		return err;
- 	}
- 
--	register_qdisc(&pfifo_fast_ops);
-+	register_qdisc(&fq_codel_qdisc_ops);
- 	register_qdisc(&pfifo_qdisc_ops);
- 	register_qdisc(&bfifo_qdisc_ops);
- 	register_qdisc(&pfifo_head_drop_qdisc_ops);
---- a/net/sched/sch_fq_codel.c
-+++ b/net/sched/sch_fq_codel.c
-@@ -714,7 +714,7 @@ static const struct Qdisc_class_ops fq_c
- 	.walk		=	fq_codel_walk,
- };
- 
--static struct Qdisc_ops fq_codel_qdisc_ops __read_mostly = {
-+struct Qdisc_ops fq_codel_qdisc_ops __read_mostly = {
- 	.cl_ops		=	&fq_codel_class_ops,
- 	.id		=	"fq_codel",
- 	.priv_size	=	sizeof(struct fq_codel_sched_data),
-@@ -729,6 +729,7 @@ static struct Qdisc_ops fq_codel_qdisc_o
- 	.dump_stats =	fq_codel_dump_stats,
- 	.owner		=	THIS_MODULE,
- };
-+EXPORT_SYMBOL(fq_codel_qdisc_ops);
- 
- static int __init fq_codel_module_init(void)
- {
---- a/net/sched/sch_generic.c
-+++ b/net/sched/sch_generic.c
-@@ -35,7 +35,7 @@
- #include <net/xfrm.h>
- 
- /* Qdisc to use by default */
--const struct Qdisc_ops *default_qdisc_ops = &pfifo_fast_ops;
-+const struct Qdisc_ops *default_qdisc_ops = &fq_codel_qdisc_ops;
- EXPORT_SYMBOL(default_qdisc_ops);
- 
- /* Main transmission queue. */
-@@ -1025,7 +1025,7 @@ static void attach_one_default_qdisc(str
- 				     void *_unused)
- {
- 	struct Qdisc *qdisc;
--	const struct Qdisc_ops *ops = default_qdisc_ops;
-+	const struct Qdisc_ops *ops = &fq_codel_qdisc_ops;
- 
- 	if (dev->priv_flags & IFF_NO_QUEUE)
- 		ops = &noqueue_qdisc_ops;
--- a/target/linux/generic/hack-4.19/662-remove_pfifo_fast.patch	2022-03-22 08:54:47.217464686 +0800
+++ b/target/linux/generic/hack-4.19/662-remove_pfifo_fast.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,220 +0,0 @@
-From b531d492d5ef1cf9dba0f4888eb5fd8624a6d762 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 17:23:42 +0200
-Subject: net: sched: switch default qdisc from pfifo_fast to fq_codel and remove pfifo_fast
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- net/sched/sch_generic.c | 140 ------------------------------------------------
- 1 file changed, 140 deletions(-)
-
---- a/net/sched/sch_generic.c
-+++ b/net/sched/sch_generic.c
-@@ -612,207 +612,6 @@ struct Qdisc_ops noqueue_qdisc_ops __rea
- 	.owner		=	THIS_MODULE,
- };
- 
--static const u8 prio2band[TC_PRIO_MAX + 1] = {
--	1, 2, 2, 2, 1, 2, 0, 0 , 1, 1, 1, 1, 1, 1, 1, 1
--};
--
--/* 3-band FIFO queue: old style, but should be a bit faster than
--   generic prio+fifo combination.
-- */
--
--#define PFIFO_FAST_BANDS 3
--
--/*
-- * Private data for a pfifo_fast scheduler containing:
-- *	- rings for priority bands
-- */
--struct pfifo_fast_priv {
--	struct skb_array q[PFIFO_FAST_BANDS];
--};
--
--static inline struct skb_array *band2list(struct pfifo_fast_priv *priv,
--					  int band)
--{
--	return &priv->q[band];
--}
--
--static int pfifo_fast_enqueue(struct sk_buff *skb, struct Qdisc *qdisc,
--			      struct sk_buff **to_free)
--{
--	int band = prio2band[skb->priority & TC_PRIO_MAX];
--	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--	struct skb_array *q = band2list(priv, band);
--	unsigned int pkt_len = qdisc_pkt_len(skb);
--	int err;
--
--	err = skb_array_produce(q, skb);
--
--	if (unlikely(err))
--		return qdisc_drop_cpu(skb, qdisc, to_free);
--
--	qdisc_qstats_atomic_qlen_inc(qdisc);
--	/* Note: skb can not be used after skb_array_produce(),
--	 * so we better not use qdisc_qstats_cpu_backlog_inc()
--	 */
--	this_cpu_add(qdisc->cpu_qstats->backlog, pkt_len);
--	return NET_XMIT_SUCCESS;
--}
--
--static struct sk_buff *pfifo_fast_dequeue(struct Qdisc *qdisc)
--{
--	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--	struct sk_buff *skb = NULL;
--	int band;
--
--	for (band = 0; band < PFIFO_FAST_BANDS && !skb; band++) {
--		struct skb_array *q = band2list(priv, band);
--
--		if (__skb_array_empty(q))
--			continue;
--
--		skb = __skb_array_consume(q);
--	}
--	if (likely(skb)) {
--		qdisc_qstats_cpu_backlog_dec(qdisc, skb);
--		qdisc_bstats_cpu_update(qdisc, skb);
--		qdisc_qstats_atomic_qlen_dec(qdisc);
--	}
--
--	return skb;
--}
--
--static struct sk_buff *pfifo_fast_peek(struct Qdisc *qdisc)
--{
--	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--	struct sk_buff *skb = NULL;
--	int band;
--
--	for (band = 0; band < PFIFO_FAST_BANDS && !skb; band++) {
--		struct skb_array *q = band2list(priv, band);
--
--		skb = __skb_array_peek(q);
--	}
--
--	return skb;
--}
--
--static void pfifo_fast_reset(struct Qdisc *qdisc)
--{
--	int i, band;
--	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--
--	for (band = 0; band < PFIFO_FAST_BANDS; band++) {
--		struct skb_array *q = band2list(priv, band);
--		struct sk_buff *skb;
--
--		/* NULL ring is possible if destroy path is due to a failed
--		 * skb_array_init() in pfifo_fast_init() case.
--		 */
--		if (!q->ring.queue)
--			continue;
--
--		while ((skb = __skb_array_consume(q)) != NULL)
--			kfree_skb(skb);
--	}
--
--	for_each_possible_cpu(i) {
--		struct gnet_stats_queue *q = per_cpu_ptr(qdisc->cpu_qstats, i);
--
--		q->backlog = 0;
--	}
--}
--
--static int pfifo_fast_dump(struct Qdisc *qdisc, struct sk_buff *skb)
--{
--	struct tc_prio_qopt opt = { .bands = PFIFO_FAST_BANDS };
--
--	memcpy(&opt.priomap, prio2band, TC_PRIO_MAX + 1);
--	if (nla_put(skb, TCA_OPTIONS, sizeof(opt), &opt))
--		goto nla_put_failure;
--	return skb->len;
--
--nla_put_failure:
--	return -1;
--}
--
--static int pfifo_fast_init(struct Qdisc *qdisc, struct nlattr *opt,
--			   struct netlink_ext_ack *extack)
--{
--	unsigned int qlen = qdisc_dev(qdisc)->tx_queue_len;
--	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--	int prio;
--
--	/* guard against zero length rings */
--	if (!qlen)
--		return -EINVAL;
--
--	for (prio = 0; prio < PFIFO_FAST_BANDS; prio++) {
--		struct skb_array *q = band2list(priv, prio);
--		int err;
--
--		err = skb_array_init(q, qlen, GFP_KERNEL);
--		if (err)
--			return -ENOMEM;
--	}
--
--	/* Can by-pass the queue discipline */
--	qdisc->flags |= TCQ_F_CAN_BYPASS;
--	return 0;
--}
--
--static void pfifo_fast_destroy(struct Qdisc *sch)
--{
--	struct pfifo_fast_priv *priv = qdisc_priv(sch);
--	int prio;
--
--	for (prio = 0; prio < PFIFO_FAST_BANDS; prio++) {
--		struct skb_array *q = band2list(priv, prio);
--
--		/* NULL ring is possible if destroy path is due to a failed
--		 * skb_array_init() in pfifo_fast_init() case.
--		 */
--		if (!q->ring.queue)
--			continue;
--		/* Destroy ring but no need to kfree_skb because a call to
--		 * pfifo_fast_reset() has already done that work.
--		 */
--		ptr_ring_cleanup(&q->ring, NULL);
--	}
--}
--
--static int pfifo_fast_change_tx_queue_len(struct Qdisc *sch,
--					  unsigned int new_len)
--{
--	struct pfifo_fast_priv *priv = qdisc_priv(sch);
--	struct skb_array *bands[PFIFO_FAST_BANDS];
--	int prio;
--
--	for (prio = 0; prio < PFIFO_FAST_BANDS; prio++) {
--		struct skb_array *q = band2list(priv, prio);
--
--		bands[prio] = q;
--	}
--
--	return skb_array_resize_multiple(bands, PFIFO_FAST_BANDS, new_len,
--					 GFP_KERNEL);
--}
--
--struct Qdisc_ops pfifo_fast_ops __read_mostly = {
--	.id		=	"pfifo_fast",
--	.priv_size	=	sizeof(struct pfifo_fast_priv),
--	.enqueue	=	pfifo_fast_enqueue,
--	.dequeue	=	pfifo_fast_dequeue,
--	.peek		=	pfifo_fast_peek,
--	.init		=	pfifo_fast_init,
--	.destroy	=	pfifo_fast_destroy,
--	.reset		=	pfifo_fast_reset,
--	.dump		=	pfifo_fast_dump,
--	.change_tx_queue_len =  pfifo_fast_change_tx_queue_len,
--	.owner		=	THIS_MODULE,
--	.static_flags	=	TCQ_F_NOLOCK | TCQ_F_CPUSTATS,
--};
--EXPORT_SYMBOL(pfifo_fast_ops);
--
- static struct lock_class_key qdisc_tx_busylock;
- static struct lock_class_key qdisc_running_key;
- 
--- a/target/linux/generic/hack-4.19/700-swconfig_switch_drivers.patch	2022-03-22 08:54:47.218464688 +0800
+++ b/target/linux/generic/hack-4.19/700-swconfig_switch_drivers.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,140 +0,0 @@
-From 36e516290611e613aa92996cb4339561452695b4 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 17:24:23 +0200
-Subject: net: swconfig: adds openwrt switch layer
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- drivers/net/phy/Kconfig   | 83 +++++++++++++++++++++++++++++++++++++++++++++++
- drivers/net/phy/Makefile  | 15 +++++++++
- include/uapi/linux/Kbuild |  1 +
- 3 files changed, 99 insertions(+)
-
---- a/drivers/net/phy/Kconfig
-+++ b/drivers/net/phy/Kconfig
-@@ -209,6 +209,89 @@ config LED_TRIGGER_PHY
- 		for any speed known to the PHY.
- 
- 
-+comment "Switch configuration API + drivers"
-+
-+config SWCONFIG
-+	tristate "Switch configuration API"
-+	---help---
-+	  Switch configuration API using netlink. This allows
-+	  you to configure the VLAN features of certain switches.
-+
-+config SWCONFIG_LEDS
-+	bool "Switch LED trigger support"
-+	depends on (SWCONFIG && LEDS_TRIGGERS)
-+
-+config ADM6996_PHY
-+	tristate "Driver for ADM6996 switches"
-+	select SWCONFIG
-+	---help---
-+	  Currently supports the ADM6996FC and ADM6996M switches.
-+	  Support for FC is very limited.
-+
-+config AR8216_PHY
-+	tristate "Driver for Atheros AR8216 switches"
-+	select ETHERNET_PACKET_MANGLE
-+	select SWCONFIG
-+
-+config AR8216_PHY_LEDS
-+	bool "Atheros AR8216 switch LED support"
-+	depends on (AR8216_PHY && LEDS_CLASS)
-+
-+source "drivers/net/phy/b53/Kconfig"
-+
-+config IP17XX_PHY
-+	tristate "Driver for IC+ IP17xx switches"
-+	select SWCONFIG
-+
-+config MVSWITCH_PHY
-+	tristate "Driver for Marvell 88E6060 switches"
-+	select ETHERNET_PACKET_MANGLE
-+
-+config MVSW61XX_PHY
-+	tristate "Driver for Marvell 88E6171/6172 switches"
-+	select SWCONFIG
-+
-+config PSB6970_PHY
-+	tristate "Lantiq XWAY Tantos (PSB6970) Ethernet switch"
-+	select SWCONFIG
-+	select ETHERNET_PACKET_MANGLE
-+
-+config RTL8306_PHY
-+	tristate "Driver for Realtek RTL8306S switches"
-+	select SWCONFIG
-+
-+config RTL8366_SMI
-+	tristate "Driver for the RTL8366 SMI interface"
-+	depends on GPIOLIB
-+	---help---
-+	  This module implements the SMI interface protocol which is used
-+	  by some RTL8366 ethernet switch devices via the generic GPIO API.
-+
-+if RTL8366_SMI
-+
-+config RTL8366_SMI_DEBUG_FS
-+	bool "RTL8366 SMI interface debugfs support"
-+        depends on DEBUG_FS
-+        default n
-+
-+config RTL8366S_PHY
-+	tristate "Driver for the Realtek RTL8366S switch"
-+	select SWCONFIG
-+
-+config RTL8366RB_PHY
-+	tristate "Driver for the Realtek RTL8366RB switch"
-+	select SWCONFIG
-+
-+config RTL8367_PHY
-+	tristate "Driver for the Realtek RTL8367R/M switches"
-+	select SWCONFIG
-+
-+config RTL8367B_PHY
-+	tristate "Driver fot the Realtek RTL8367R-VB switch"
-+	select SWCONFIG
-+
-+endif # RTL8366_SMI
-+
- comment "MII PHY device drivers"
- 
- config SFP
---- a/drivers/net/phy/Makefile
-+++ b/drivers/net/phy/Makefile
-@@ -22,6 +22,21 @@ libphy-$(CONFIG_LED_TRIGGER_PHY)	+= phy_
- obj-$(CONFIG_PHYLINK)		+= phylink.o
- obj-$(CONFIG_PHYLIB)		+= libphy.o
- 
-+obj-$(CONFIG_SWCONFIG)		+= swconfig.o
-+obj-$(CONFIG_ADM6996_PHY)	+= adm6996.o
-+obj-$(CONFIG_AR8216_PHY)	+= ar8216.o ar8327.o
-+obj-$(CONFIG_SWCONFIG_B53)	+= b53/
-+obj-$(CONFIG_IP17XX_PHY)	+= ip17xx.o
-+obj-$(CONFIG_MVSWITCH_PHY)	+= mvswitch.o
-+obj-$(CONFIG_MVSW61XX_PHY)	+= mvsw61xx.o
-+obj-$(CONFIG_PSB6970_PHY)	+= psb6970.o
-+obj-$(CONFIG_RTL8306_PHY)	+= rtl8306.o
-+obj-$(CONFIG_RTL8366_SMI)	+= rtl8366_smi.o
-+obj-$(CONFIG_RTL8366S_PHY)	+= rtl8366s.o
-+obj-$(CONFIG_RTL8366RB_PHY)	+= rtl8366rb.o
-+obj-$(CONFIG_RTL8367_PHY)	+= rtl8367.o
-+obj-$(CONFIG_RTL8367B_PHY)	+= rtl8367b.o
-+
- obj-$(CONFIG_MDIO_BCM_IPROC)	+= mdio-bcm-iproc.o
- obj-$(CONFIG_MDIO_BCM_UNIMAC)	+= mdio-bcm-unimac.o
- obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
---- a/include/linux/platform_data/b53.h
-+++ b/include/linux/platform_data/b53.h
-@@ -29,6 +29,9 @@ struct b53_platform_data {
- 	u32 chip_id;
- 	u16 enabled_ports;
- 
-+	/* allow to specify an ethX alias */
-+	const char *alias;
-+
- 	/* only used by MMAP'd driver */
- 	unsigned big_endian:1;
- 	void __iomem *regs;
--- a/target/linux/generic/hack-4.19/702-phy_add_aneg_done_function.patch	2022-03-22 08:54:47.218464688 +0800
+++ b/target/linux/generic/hack-4.19/702-phy_add_aneg_done_function.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,27 +0,0 @@
---- a/include/linux/phy.h
-+++ b/include/linux/phy.h
-@@ -548,6 +548,12 @@ struct phy_driver {
- 	/* Determines the negotiated speed and duplex */
- 	int (*read_status)(struct phy_device *phydev);
- 
-+	/* 
-+	 * Update the value in phydev->link to reflect the 
-+	 * current link value
-+	 */
-+	int (*update_link)(struct phy_device *phydev);
-+
- 	/* Clears any pending interrupts */
- 	int (*ack_interrupt)(struct phy_device *phydev);
- 
---- a/drivers/net/phy/phy_device.c
-+++ b/drivers/net/phy/phy_device.c
-@@ -1512,6 +1512,9 @@ int genphy_update_link(struct phy_device
- {
- 	int status;
- 
-+	if (phydev->drv && phydev->drv->update_link)
-+		return phydev->drv->update_link(phydev);
-+
- 	/* The link state is latched low so that momentary link
- 	 * drops can be detected. Do not double-read the status
- 	 * in polling mode to detect such short link drops.
--- a/target/linux/generic/hack-4.19/721-phy_packets.patch	2022-03-22 08:54:47.218464688 +0800
+++ b/target/linux/generic/hack-4.19/721-phy_packets.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,176 +0,0 @@
-From ffe387740bbe88dd88bbe04d6375902708003d6e Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 17:25:00 +0200
-Subject: net: add packet mangeling patch
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/linux/netdevice.h | 11 +++++++++++
- include/linux/skbuff.h    | 14 ++++----------
- net/Kconfig               |  6 ++++++
- net/core/dev.c            | 18 ++++++++++++++----
- net/core/skbuff.c         | 17 +++++++++++++++++
- net/ethernet/eth.c        |  6 ++++++
- 6 files changed, 58 insertions(+), 14 deletions(-)
-
---- a/include/linux/netdevice.h
-+++ b/include/linux/netdevice.h
-@@ -1514,6 +1514,7 @@ enum netdev_priv_flags {
- 	IFF_FAILOVER_SLAVE		= 1<<28,
- 	IFF_L3MDEV_RX_HANDLER		= 1<<29,
- 	IFF_LIVE_RENAME_OK		= 1<<30,
-+	IFF_NO_IP_ALIGN			= 1<<31,
- };
- 
- #define IFF_802_1Q_VLAN			IFF_802_1Q_VLAN
-@@ -1546,6 +1547,7 @@ enum netdev_priv_flags {
- #define IFF_FAILOVER_SLAVE		IFF_FAILOVER_SLAVE
- #define IFF_L3MDEV_RX_HANDLER		IFF_L3MDEV_RX_HANDLER
- #define IFF_LIVE_RENAME_OK		IFF_LIVE_RENAME_OK
-+#define IFF_NO_IP_ALIGN			IFF_NO_IP_ALIGN
- 
- /**
-  *	struct net_device - The DEVICE structure.
-@@ -1844,6 +1846,11 @@ struct net_device {
- 	const struct tlsdev_ops *tlsdev_ops;
- #endif
- 
-+#ifdef CONFIG_ETHERNET_PACKET_MANGLE
-+	void (*eth_mangle_rx)(struct net_device *dev, struct sk_buff *skb);
-+	struct sk_buff *(*eth_mangle_tx)(struct net_device *dev, struct sk_buff *skb);
-+#endif
-+
- 	const struct header_ops *header_ops;
- 
- 	unsigned int		flags;
-@@ -1919,6 +1926,10 @@ struct net_device {
- 	struct mpls_dev __rcu	*mpls_ptr;
- #endif
- 
-+#ifdef CONFIG_ETHERNET_PACKET_MANGLE
-+	void			*phy_ptr; /* PHY device specific data */
-+#endif
-+
- /*
-  * Cache lines mostly used on receive path (including eth_type_trans())
-  */
---- a/include/linux/skbuff.h
-+++ b/include/linux/skbuff.h
-@@ -2545,6 +2545,10 @@ static inline int pskb_trim(struct sk_bu
- 	return (len < skb->len) ? __pskb_trim(skb, len) : 0;
- }
- 
-+extern struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
-+		unsigned int length, gfp_t gfp);
-+
-+
- /**
-  *	pskb_trim_unique - remove end from a paged unique (not cloned) buffer
-  *	@skb: buffer to alter
-@@ -2676,16 +2680,6 @@ static inline struct sk_buff *dev_alloc_
- }
- 
- 
--static inline struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
--		unsigned int length, gfp_t gfp)
--{
--	struct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);
--
--	if (NET_IP_ALIGN && skb)
--		skb_reserve(skb, NET_IP_ALIGN);
--	return skb;
--}
--
- static inline struct sk_buff *netdev_alloc_skb_ip_align(struct net_device *dev,
- 		unsigned int length)
- {
---- a/net/Kconfig
-+++ b/net/Kconfig
-@@ -25,6 +25,12 @@ menuconfig NET
- 
- if NET
- 
-+config ETHERNET_PACKET_MANGLE
-+	bool
-+	help
-+	  This option can be selected by phy drivers that need to mangle
-+	  packets going in or out of an ethernet device.
-+
- config WANT_COMPAT_NETLINK_MESSAGES
- 	bool
- 	help
---- a/net/core/dev.c
-+++ b/net/core/dev.c
-@@ -3252,10 +3252,20 @@ static int xmit_one(struct sk_buff *skb,
- 	if (!list_empty(&ptype_all) || !list_empty(&dev->ptype_all))
- 		dev_queue_xmit_nit(skb, dev);
- 
--	len = skb->len;
--	trace_net_dev_start_xmit(skb, dev);
--	rc = netdev_start_xmit(skb, dev, txq, more);
--	trace_net_dev_xmit(skb, rc, dev, len);
-+#ifdef CONFIG_ETHERNET_PACKET_MANGLE
-+	if (!dev->eth_mangle_tx ||
-+	    (skb = dev->eth_mangle_tx(dev, skb)) != NULL)
-+#else
-+	if (1)
-+#endif
-+	{
-+		len = skb->len;
-+		trace_net_dev_start_xmit(skb, dev);
-+		rc = netdev_start_xmit(skb, dev, txq, more);
-+		trace_net_dev_xmit(skb, rc, dev, len);
-+	} else {
-+		rc = NETDEV_TX_OK;
-+	}
- 
- 	return rc;
- }
---- a/net/core/skbuff.c
-+++ b/net/core/skbuff.c
-@@ -63,6 +63,7 @@
- #include <linux/errqueue.h>
- #include <linux/prefetch.h>
- #include <linux/if_vlan.h>
-+#include <linux/if.h>
- 
- #include <net/protocol.h>
- #include <net/dst.h>
-@@ -503,6 +504,22 @@ skb_fail:
- }
- EXPORT_SYMBOL(__napi_alloc_skb);
- 
-+struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
-+		unsigned int length, gfp_t gfp)
-+{
-+	struct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);
-+
-+#ifdef CONFIG_ETHERNET_PACKET_MANGLE
-+	if (dev && (dev->priv_flags & IFF_NO_IP_ALIGN))
-+		return skb;
-+#endif
-+
-+	if (NET_IP_ALIGN && skb)
-+		skb_reserve(skb, NET_IP_ALIGN);
-+	return skb;
-+}
-+EXPORT_SYMBOL(__netdev_alloc_skb_ip_align);
-+
- void skb_add_rx_frag(struct sk_buff *skb, int i, struct page *page, int off,
- 		     int size, unsigned int truesize)
- {
---- a/net/ethernet/eth.c
-+++ b/net/ethernet/eth.c
-@@ -172,6 +172,12 @@ __be16 eth_type_trans(struct sk_buff *sk
- 	const struct ethhdr *eth;
- 
- 	skb->dev = dev;
-+
-+#ifdef CONFIG_ETHERNET_PACKET_MANGLE
-+	if (dev->eth_mangle_rx)
-+		dev->eth_mangle_rx(dev, skb);
-+#endif
-+
- 	skb_reset_mac_header(skb);
- 
- 	eth = (struct ethhdr *)skb->data;
--- a/target/linux/generic/hack-4.19/773-bgmac-add-srab-switch.patch	2022-03-22 08:54:47.218464688 +0800
+++ b/target/linux/generic/hack-4.19/773-bgmac-add-srab-switch.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,98 +0,0 @@
-From 3cb240533ab787899dc7f17aa7d6c5b4810e2e58 Mon Sep 17 00:00:00 2001
-From: Hauke Mehrtens <hauke@hauke-m.de>
-Date: Fri, 7 Jul 2017 17:26:01 +0200
-Subject: bcm53xx: bgmac: use srab switch driver
-
-use the srab switch driver on these SoCs.
-
-Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
----
- drivers/net/ethernet/broadcom/bgmac-bcma.c |  1 +
- drivers/net/ethernet/broadcom/bgmac.c      | 24 ++++++++++++++++++++++++
- drivers/net/ethernet/broadcom/bgmac.h      |  4 ++++
- 3 files changed, 29 insertions(+)
-
---- a/drivers/net/ethernet/broadcom/bgmac-bcma.c
-+++ b/drivers/net/ethernet/broadcom/bgmac-bcma.c
-@@ -268,6 +268,7 @@ static int bgmac_probe(struct bcma_devic
- 		bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
- 		bgmac->feature_flags |= BGMAC_FEAT_NO_RESET;
- 		bgmac->feature_flags |= BGMAC_FEAT_FORCE_SPEED_2500;
-+		bgmac->feature_flags |= BGMAC_FEAT_SRAB;
- 		break;
- 	default:
- 		bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
---- a/drivers/net/ethernet/broadcom/bgmac.c
-+++ b/drivers/net/ethernet/broadcom/bgmac.c
-@@ -12,6 +12,7 @@
- #include <linux/bcma/bcma.h>
- #include <linux/etherdevice.h>
- #include <linux/interrupt.h>
-+#include <linux/platform_data/b53.h>
- #include <linux/bcm47xx_nvram.h>
- #include <linux/phy.h>
- #include <linux/phy_fixed.h>
-@@ -1409,6 +1410,17 @@ static const struct ethtool_ops bgmac_et
- 	.set_link_ksettings     = phy_ethtool_set_link_ksettings,
- };
- 
-+static struct b53_platform_data bgmac_b53_pdata = {
-+};
-+
-+static struct platform_device bgmac_b53_dev = {
-+	.name		= "b53-srab-switch",
-+	.id		= -1,
-+	.dev		= {
-+		.platform_data = &bgmac_b53_pdata,
-+	},
-+};
-+
- /**************************************************
-  * MII
-  **************************************************/
-@@ -1540,6 +1552,14 @@ int bgmac_enet_probe(struct bgmac *bgmac
- 	net_dev->hw_features = net_dev->features;
- 	net_dev->vlan_features = net_dev->features;
- 
-+	if ((bgmac->feature_flags & BGMAC_FEAT_SRAB) && !bgmac_b53_pdata.regs) {
-+		bgmac_b53_pdata.regs = ioremap_nocache(0x18007000, 0x1000);
-+
-+		err = platform_device_register(&bgmac_b53_dev);
-+		if (!err)
-+			bgmac->b53_device = &bgmac_b53_dev;
-+	}
-+
- 	err = register_netdev(bgmac->net_dev);
- 	if (err) {
- 		dev_err(bgmac->dev, "Cannot register net device\n");
-@@ -1562,6 +1582,10 @@ EXPORT_SYMBOL_GPL(bgmac_enet_probe);
- 
- void bgmac_enet_remove(struct bgmac *bgmac)
- {
-+	if (bgmac->b53_device)
-+		platform_device_unregister(&bgmac_b53_dev);
-+	bgmac->b53_device = NULL;
-+
- 	unregister_netdev(bgmac->net_dev);
- 	phy_disconnect(bgmac->net_dev->phydev);
- 	netif_napi_del(&bgmac->napi);
---- a/drivers/net/ethernet/broadcom/bgmac.h
-+++ b/drivers/net/ethernet/broadcom/bgmac.h
-@@ -427,6 +427,7 @@
- #define BGMAC_FEAT_CC4_IF_SW_TYPE_RGMII	BIT(18)
- #define BGMAC_FEAT_CC7_IF_TYPE_RGMII	BIT(19)
- #define BGMAC_FEAT_IDM_MASK		BIT(20)
-+#define BGMAC_FEAT_SRAB			BIT(21)
- 
- struct bgmac_slot_info {
- 	union {
-@@ -532,6 +533,9 @@ struct bgmac {
- 	void (*cmn_maskset32)(struct bgmac *bgmac, u16 offset, u32 mask,
- 			      u32 set);
- 	int (*phy_connect)(struct bgmac *bgmac);
-+
-+	/* platform device for associated switch */
-+	struct platform_device *b53_device;
- };
- 
- struct bgmac *bgmac_alloc(struct device *dev);
--- a/target/linux/generic/hack-4.19/835-misc-owl_loader.patch	2022-03-22 08:54:47.219464689 +0800
+++ b/target/linux/generic/hack-4.19/835-misc-owl_loader.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,52 +0,0 @@
-From dd36f935973d91644449bd9749f6062a2bed821b Mon Sep 17 00:00:00 2001
-From: Christian Lamparter <chunkeey@googlemail.com>
-Date: Fri, 7 Jul 2017 17:26:46 +0200
-Subject: misc: owl-loader for delayed Atheros ath9k fixup
-
-Some devices (like the Cisco Meraki Z1 Cloud Managed Teleworker Gateway)
-need to be able to initialize the PCIe wifi device. Normally, this is done
-during the early stages of booting linux, because the necessary init code
-is read from the memory mapped SPI and passed to pci_enable_ath9k_fixup.
-However,this isn't possible for devices which have the init code for the
-Atheros chip stored on NAND in an UBI volume. Hence, this module can be
-used to initialze the chip when the user-space is ready to extract the
-init code.
-
-Signed-off-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
-Signed-off-by: Christian Lamparter <chunkeey@googlemail.com>
----
- drivers/misc/Kconfig  | 12 ++++++++++++
- drivers/misc/Makefile |  1 +
- 2 files changed, 13 insertions(+)
-
---- a/drivers/misc/Kconfig
-+++ b/drivers/misc/Kconfig
-@@ -164,6 +164,18 @@ config SGI_IOC4
- 	  If you have an SGI Altix with an IOC4-based card say Y.
- 	  Otherwise say N.
- 
-+config OWL_LOADER
-+	tristate "Owl loader for initializing Atheros PCI(e) Wifi chips"
-+	depends on PCI
-+	---help---
-+	This kernel module helps to initialize certain Qualcomm
-+	Atheros' PCI(e) Wifi chips, which have the init data
-+	(which contains the PCI device ID for example) stored
-+	together with the calibration data in the file system.
-+
-+	This is necessary for devices like the Cisco Meraki Z1, say M.
-+	Otherwise say N.
-+
- config TIFM_CORE
- 	tristate "TI Flash Media interface support"
- 	depends on PCI
---- a/drivers/misc/Makefile
-+++ b/drivers/misc/Makefile
-@@ -14,6 +14,7 @@ obj-$(CONFIG_ATMEL_TCLIB)	+= atmel_tclib
- obj-$(CONFIG_DUMMY_IRQ)		+= dummy-irq.o
- obj-$(CONFIG_ICS932S401)	+= ics932s401.o
- obj-$(CONFIG_LKDTM)		+= lkdtm/
-+obj-$(CONFIG_OWL_LOADER)	+= owl-loader.o
- obj-$(CONFIG_TIFM_CORE)       	+= tifm_core.o
- obj-$(CONFIG_TIFM_7XX1)       	+= tifm_7xx1.o
- obj-$(CONFIG_PHANTOM)		+= phantom.o
--- a/target/linux/generic/hack-4.19/901-debloat_sock_diag.patch	2022-03-22 08:54:47.219464689 +0800
+++ b/target/linux/generic/hack-4.19/901-debloat_sock_diag.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,136 +0,0 @@
-From 3b6115d6b57a263bdc8c9b1df273bd4a7955eead Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 8 Jul 2017 08:16:31 +0200
-Subject: debloat: add some debloat patches, strip down procfs and make O_DIRECT support optional, saves ~15K after lzma on MIPS
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- net/Kconfig         | 3 +++
- net/core/Makefile   | 3 ++-
- net/core/sock.c     | 2 ++
- net/ipv4/Kconfig    | 1 +
- net/netlink/Kconfig | 1 +
- net/packet/Kconfig  | 1 +
- net/unix/Kconfig    | 1 +
- 7 files changed, 11 insertions(+), 1 deletion(-)
-
---- a/net/Kconfig
-+++ b/net/Kconfig
-@@ -98,6 +98,9 @@ source "net/netlabel/Kconfig"
- 
- endif # if INET
- 
-+config SOCK_DIAG
-+	bool
-+
- config NETWORK_SECMARK
- 	bool "Security Marking"
- 	help
---- a/net/core/Makefile
-+++ b/net/core/Makefile
-@@ -10,9 +10,10 @@ obj-$(CONFIG_SYSCTL) += sysctl_net_core.
- 
- obj-y		     += dev.o ethtool.o dev_addr_lists.o dst.o netevent.o \
- 			neighbour.o rtnetlink.o utils.o link_watch.o filter.o \
--			sock_diag.o dev_ioctl.o tso.o sock_reuseport.o \
-+ 			dev_ioctl.o tso.o sock_reuseport.o \
- 			fib_notifier.o xdp.o
- 
-+obj-$(CONFIG_SOCK_DIAG) += sock_diag.o
- obj-y += net-sysfs.o
- obj-$(CONFIG_PAGE_POOL) += page_pool.o
- obj-$(CONFIG_PROC_FS) += net-procfs.o
---- a/net/core/sock.c
-+++ b/net/core/sock.c
-@@ -490,6 +490,18 @@ discard_and_relse:
- }
- EXPORT_SYMBOL(__sk_receive_skb);
- 
-+u64 sock_gen_cookie(struct sock *sk)
-+{
-+	while (1) {
-+		u64 res = atomic64_read(&sk->sk_cookie);
-+
-+		if (res)
-+			return res;
-+		res = atomic64_inc_return(&sock_net(sk)->cookie_gen);
-+		atomic64_cmpxchg(&sk->sk_cookie, 0, res);
-+	}
-+}
-+
- struct dst_entry *__sk_dst_check(struct sock *sk, u32 cookie)
- {
- 	struct dst_entry *dst = __sk_dst_get(sk);
-@@ -1603,9 +1615,11 @@ static void __sk_free(struct sock *sk)
- 	if (likely(sk->sk_net_refcnt))
- 		sock_inuse_add(sock_net(sk), -1);
- 
-+#ifdef CONFIG_SOCK_DIAG
- 	if (unlikely(sk->sk_net_refcnt && sock_diag_has_destroy_listeners(sk)))
- 		sock_diag_broadcast_destroy(sk);
- 	else
-+#endif
- 		sk_destruct(sk);
- }
- 
---- a/net/core/sock_diag.c
-+++ b/net/core/sock_diag.c
-@@ -20,18 +20,6 @@ static int (*inet_rcv_compat)(struct sk_
- static DEFINE_MUTEX(sock_diag_table_mutex);
- static struct workqueue_struct *broadcast_wq;
- 
--u64 sock_gen_cookie(struct sock *sk)
--{
--	while (1) {
--		u64 res = atomic64_read(&sk->sk_cookie);
--
--		if (res)
--			return res;
--		res = atomic64_inc_return(&sock_net(sk)->cookie_gen);
--		atomic64_cmpxchg(&sk->sk_cookie, 0, res);
--	}
--}
--
- int sock_diag_check_cookie(struct sock *sk, const __u32 *cookie)
- {
- 	u64 res;
---- a/net/ipv4/Kconfig
-+++ b/net/ipv4/Kconfig
-@@ -425,6 +425,7 @@ config INET_XFRM_MODE_BEET
- 
- config INET_DIAG
- 	tristate "INET: socket monitoring interface"
-+	select SOCK_DIAG
- 	default y
- 	---help---
- 	  Support for INET (TCP, DCCP, etc) socket monitoring interface used by
---- a/net/netlink/Kconfig
-+++ b/net/netlink/Kconfig
-@@ -4,6 +4,7 @@
- 
- config NETLINK_DIAG
- 	tristate "NETLINK: socket monitoring interface"
-+	select SOCK_DIAG
- 	default n
- 	---help---
- 	  Support for NETLINK socket monitoring interface used by the ss tool.
---- a/net/packet/Kconfig
-+++ b/net/packet/Kconfig
-@@ -18,6 +18,7 @@ config PACKET
- config PACKET_DIAG
- 	tristate "Packet: sockets monitoring interface"
- 	depends on PACKET
-+	select SOCK_DIAG
- 	default n
- 	---help---
- 	  Support for PF_PACKET sockets monitoring interface used by the ss tool.
---- a/net/unix/Kconfig
-+++ b/net/unix/Kconfig
-@@ -22,6 +22,7 @@ config UNIX
- config UNIX_DIAG
- 	tristate "UNIX: socket monitoring interface"
- 	depends on UNIX
-+	select SOCK_DIAG
- 	default n
- 	---help---
- 	  Support for UNIX socket monitoring interface used by the ss tool.
--- a/target/linux/generic/hack-4.19/902-debloat_proc.patch	2022-03-22 08:54:47.219464689 +0800
+++ b/target/linux/generic/hack-4.19/902-debloat_proc.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,405 +0,0 @@
-From 9e3f1d0805b2d919904dd9a4ff0d956314cc3cba Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 8 Jul 2017 08:20:09 +0200
-Subject: debloat: procfs
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- fs/locks.c               |  2 ++
- fs/proc/Kconfig          |  5 +++++
- fs/proc/consoles.c       |  3 +++
- fs/proc/proc_tty.c       | 11 ++++++++++-
- include/net/snmp.h       | 18 +++++++++++++++++-
- ipc/msg.c                |  3 +++
- ipc/sem.c                |  2 ++
- ipc/shm.c                |  2 ++
- ipc/util.c               |  3 +++
- kernel/exec_domain.c     |  2 ++
- kernel/irq/proc.c        |  9 +++++++++
- kernel/time/timer_list.c |  2 ++
- mm/vmalloc.c             |  2 ++
- mm/vmstat.c              |  8 +++++---
- net/8021q/vlanproc.c     |  6 ++++++
- net/core/net-procfs.c    | 18 ++++++++++++------
- net/core/sock.c          |  2 ++
- net/ipv4/fib_trie.c      | 18 ++++++++++++------
- net/ipv4/proc.c          |  3 +++
- net/ipv4/route.c         |  3 +++
- 20 files changed, 105 insertions(+), 17 deletions(-)
-
---- a/fs/locks.c
-+++ b/fs/locks.c
-@@ -2786,6 +2786,8 @@ static const struct seq_operations locks
- 
- static int __init proc_locks_init(void)
- {
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return 0;
- 	proc_create_seq_private("locks", 0, NULL, &locks_seq_operations,
- 			sizeof(struct locks_iterator), NULL);
- 	return 0;
---- a/fs/proc/Kconfig
-+++ b/fs/proc/Kconfig
-@@ -97,3 +97,8 @@ config PROC_CHILDREN
- 
- 	  Say Y if you are running any user-space software which takes benefit from
- 	  this interface. For example, rkt is such a piece of software.
-+
-+config PROC_STRIPPED
-+	default n
-+	depends on EXPERT
-+	bool "Strip non-essential /proc functionality to reduce code size"
---- a/fs/proc/consoles.c
-+++ b/fs/proc/consoles.c
-@@ -93,6 +93,9 @@ static const struct seq_operations conso
- 
- static int __init proc_consoles_init(void)
- {
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return 0;
-+
- 	proc_create_seq("consoles", 0, NULL, &consoles_op);
- 	return 0;
- }
---- a/fs/proc/proc_tty.c
-+++ b/fs/proc/proc_tty.c
-@@ -133,7 +133,10 @@ static const struct seq_operations tty_d
- void proc_tty_register_driver(struct tty_driver *driver)
- {
- 	struct proc_dir_entry *ent;
--		
-+
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return;
-+
- 	if (!driver->driver_name || driver->proc_entry ||
- 	    !driver->ops->proc_show)
- 		return;
-@@ -150,6 +153,9 @@ void proc_tty_unregister_driver(struct t
- {
- 	struct proc_dir_entry *ent;
- 
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return;
-+
- 	ent = driver->proc_entry;
- 	if (!ent)
- 		return;
-@@ -164,6 +170,9 @@ void proc_tty_unregister_driver(struct t
-  */
- void __init proc_tty_init(void)
- {
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return;
-+
- 	if (!proc_mkdir("tty", NULL))
- 		return;
- 	proc_mkdir("tty/ldisc", NULL);	/* Preserved: it's userspace visible */
---- a/include/net/snmp.h
-+++ b/include/net/snmp.h
-@@ -123,6 +123,21 @@ struct linux_xfrm_mib {
- #define DECLARE_SNMP_STAT(type, name)	\
- 	extern __typeof__(type) __percpu *name
- 
-+#ifdef CONFIG_PROC_STRIPPED
-+#define __SNMP_STATS_DUMMY(mib)	\
-+	do { (void) mib->mibs[0]; } while(0)
-+
-+#define __SNMP_INC_STATS(mib, field) __SNMP_STATS_DUMMY(mib)
-+#define SNMP_INC_STATS_ATOMIC_LONG(mib, field) __SNMP_STATS_DUMMY(mib)
-+#define SNMP_INC_STATS(mib, field) __SNMP_STATS_DUMMY(mib)
-+#define SNMP_DEC_STATS(mib, field) __SNMP_STATS_DUMMY(mib)
-+#define __SNMP_ADD_STATS(mib, field, addend) __SNMP_STATS_DUMMY(mib)
-+#define SNMP_ADD_STATS(mib, field, addend) __SNMP_STATS_DUMMY(mib)
-+#define SNMP_UPD_PO_STATS(mib, basefield, addend) __SNMP_STATS_DUMMY(mib)
-+#define __SNMP_UPD_PO_STATS(mib, basefield, addend) __SNMP_STATS_DUMMY(mib)
-+
-+#else
-+
- #define __SNMP_INC_STATS(mib, field)	\
- 			__this_cpu_inc(mib->mibs[field])
- 
-@@ -153,8 +168,9 @@ struct linux_xfrm_mib {
- 		__this_cpu_add(ptr[basefield##OCTETS], addend);	\
- 	} while (0)
- 
-+#endif
- 
--#if BITS_PER_LONG==32
-+#if (BITS_PER_LONG==32) && !defined(CONFIG_PROC_STRIPPED)
- 
- #define __SNMP_ADD_STATS64(mib, field, addend) 				\
- 	do {								\
---- a/ipc/msg.c
-+++ b/ipc/msg.c
-@@ -1291,6 +1291,9 @@ void __init msg_init(void)
- {
- 	msg_init_ns(&init_ipc_ns);
- 
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return;
-+
- 	ipc_init_proc_interface("sysvipc/msg",
- 				"       key      msqid perms      cbytes       qnum lspid lrpid   uid   gid  cuid  cgid      stime      rtime      ctime\n",
- 				IPC_MSG_IDS, sysvipc_msg_proc_show);
---- a/ipc/sem.c
-+++ b/ipc/sem.c
-@@ -243,6 +243,8 @@ void sem_exit_ns(struct ipc_namespace *n
- void __init sem_init(void)
- {
- 	sem_init_ns(&init_ipc_ns);
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return;
- 	ipc_init_proc_interface("sysvipc/sem",
- 				"       key      semid perms      nsems   uid   gid  cuid  cgid      otime      ctime\n",
- 				IPC_SEM_IDS, sysvipc_sem_proc_show);
---- a/ipc/shm.c
-+++ b/ipc/shm.c
-@@ -144,6 +144,8 @@ pure_initcall(ipc_ns_init);
- 
- void __init shm_init(void)
- {
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return;
- 	ipc_init_proc_interface("sysvipc/shm",
- #if BITS_PER_LONG <= 32
- 				"       key      shmid perms       size  cpid  lpid nattch   uid   gid  cuid  cgid      atime      dtime      ctime        rss       swap\n",
---- a/ipc/util.c
-+++ b/ipc/util.c
-@@ -140,6 +140,9 @@ void __init ipc_init_proc_interface(cons
- 	struct proc_dir_entry *pde;
- 	struct ipc_proc_iface *iface;
- 
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return;
-+
- 	iface = kmalloc(sizeof(*iface), GFP_KERNEL);
- 	if (!iface)
- 		return;
---- a/kernel/exec_domain.c
-+++ b/kernel/exec_domain.c
-@@ -29,6 +29,8 @@ static int execdomains_proc_show(struct
- 
- static int __init proc_execdomains_init(void)
- {
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return 0;
- 	proc_create_single("execdomains", 0, NULL, execdomains_proc_show);
- 	return 0;
- }
---- a/kernel/irq/proc.c
-+++ b/kernel/irq/proc.c
-@@ -333,6 +333,9 @@ void register_irq_proc(unsigned int irq,
- 	void __maybe_unused *irqp = (void *)(unsigned long) irq;
- 	char name [MAX_NAMELEN];
- 
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED) && !IS_ENABLED(CONFIG_SMP))
-+		return;
-+
- 	if (!root_irq_dir || (desc->irq_data.chip == &no_irq_chip))
- 		return;
- 
-@@ -386,6 +389,9 @@ void unregister_irq_proc(unsigned int ir
- {
- 	char name [MAX_NAMELEN];
- 
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED) && !IS_ENABLED(CONFIG_SMP))
-+		return;
-+
- 	if (!root_irq_dir || !desc->dir)
- 		return;
- #ifdef CONFIG_SMP
-@@ -424,6 +430,9 @@ void init_irq_proc(void)
- 	unsigned int irq;
- 	struct irq_desc *desc;
- 
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED) && !IS_ENABLED(CONFIG_SMP))
-+		return;
-+
- 	/* create /proc/irq */
- 	root_irq_dir = proc_mkdir("irq", NULL);
- 	if (!root_irq_dir)
---- a/kernel/time/timer_list.c
-+++ b/kernel/time/timer_list.c
-@@ -375,6 +375,8 @@ static int __init init_timer_list_procfs
- {
- 	struct proc_dir_entry *pe;
- 
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return 0;
- 	pe = proc_create_seq_private("timer_list", 0400, NULL, &timer_list_sops,
- 			sizeof(struct timer_list_iter), NULL);
- 	if (!pe)
---- a/mm/vmalloc.c
-+++ b/mm/vmalloc.c
-@@ -2749,6 +2749,8 @@ static const struct seq_operations vmall
- 
- static int __init proc_vmalloc_init(void)
- {
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return 0;
- 	if (IS_ENABLED(CONFIG_NUMA))
- 		proc_create_seq_private("vmallocinfo", 0400, NULL,
- 				&vmalloc_op,
---- a/mm/vmstat.c
-+++ b/mm/vmstat.c
-@@ -1971,10 +1971,12 @@ void __init init_mm_internals(void)
- 	start_shepherd_timer();
- #endif
- #ifdef CONFIG_PROC_FS
--	proc_create_seq("buddyinfo", 0444, NULL, &fragmentation_op);
--	proc_create_seq("pagetypeinfo", 0400, NULL, &pagetypeinfo_op);
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED)) {
-+		proc_create_seq("buddyinfo", 0444, NULL, &fragmentation_op);
-+		proc_create_seq("pagetypeinfo", 0400, NULL, &pagetypeinfo_op);
-+		proc_create_seq("zoneinfo", 0444, NULL, &zoneinfo_op);
-+	}
- 	proc_create_seq("vmstat", 0444, NULL, &vmstat_op);
--	proc_create_seq("zoneinfo", 0444, NULL, &zoneinfo_op);
- #endif
- }
- 
---- a/net/8021q/vlanproc.c
-+++ b/net/8021q/vlanproc.c
-@@ -96,6 +96,9 @@ void vlan_proc_cleanup(struct net *net)
- {
- 	struct vlan_net *vn = net_generic(net, vlan_net_id);
- 
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return;
-+
- 	if (vn->proc_vlan_conf)
- 		remove_proc_entry(name_conf, vn->proc_vlan_dir);
- 
-@@ -115,6 +118,9 @@ int __net_init vlan_proc_init(struct net
- {
- 	struct vlan_net *vn = net_generic(net, vlan_net_id);
- 
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return 0;
-+
- 	vn->proc_vlan_dir = proc_net_mkdir(net, name_root, net->proc_net);
- 	if (!vn->proc_vlan_dir)
- 		goto err;
---- a/net/core/net-procfs.c
-+++ b/net/core/net-procfs.c
-@@ -279,10 +279,12 @@ static int __net_init dev_proc_net_init(
- 	if (!proc_create_net("dev", 0444, net->proc_net, &dev_seq_ops,
- 			sizeof(struct seq_net_private)))
- 		goto out;
--	if (!proc_create_seq("softnet_stat", 0444, net->proc_net,
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED) &&
-+			!proc_create_seq("softnet_stat", 0444, net->proc_net,
- 			 &softnet_seq_ops))
- 		goto out_dev;
--	if (!proc_create_net("ptype", 0444, net->proc_net, &ptype_seq_ops,
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED) &&
-+			!proc_create_net("ptype", 0444, net->proc_net, &ptype_seq_ops,
- 			sizeof(struct seq_net_private)))
- 		goto out_softnet;
- 
-@@ -292,9 +294,11 @@ static int __net_init dev_proc_net_init(
- out:
- 	return rc;
- out_ptype:
--	remove_proc_entry("ptype", net->proc_net);
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		remove_proc_entry("ptype", net->proc_net);
- out_softnet:
--	remove_proc_entry("softnet_stat", net->proc_net);
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		remove_proc_entry("softnet_stat", net->proc_net);
- out_dev:
- 	remove_proc_entry("dev", net->proc_net);
- 	goto out;
-@@ -304,8 +308,10 @@ static void __net_exit dev_proc_net_exit
- {
- 	wext_proc_exit(net);
- 
--	remove_proc_entry("ptype", net->proc_net);
--	remove_proc_entry("softnet_stat", net->proc_net);
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED)) {
-+		remove_proc_entry("ptype", net->proc_net);
-+		remove_proc_entry("softnet_stat", net->proc_net);
-+	}
- 	remove_proc_entry("dev", net->proc_net);
- }
- 
---- a/net/core/sock.c
-+++ b/net/core/sock.c
-@@ -3486,6 +3486,8 @@ static __net_initdata struct pernet_oper
- 
- static int __init proto_init(void)
- {
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return 0;
- 	return register_pernet_subsys(&proto_net_ops);
- }
- 
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -2717,11 +2717,13 @@ static const struct seq_operations fib_r
- 
- int __net_init fib_proc_init(struct net *net)
- {
--	if (!proc_create_net("fib_trie", 0444, net->proc_net, &fib_trie_seq_ops,
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED) &&
-+			!proc_create_net("fib_trie", 0444, net->proc_net, &fib_trie_seq_ops,
- 			sizeof(struct fib_trie_iter)))
- 		goto out1;
- 
--	if (!proc_create_net_single("fib_triestat", 0444, net->proc_net,
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED) &&
-+			!proc_create_net_single("fib_triestat", 0444, net->proc_net,
- 			fib_triestat_seq_show, NULL))
- 		goto out2;
- 
-@@ -2732,17 +2734,21 @@ int __net_init fib_proc_init(struct net
- 	return 0;
- 
- out3:
--	remove_proc_entry("fib_triestat", net->proc_net);
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		remove_proc_entry("fib_triestat", net->proc_net);
- out2:
--	remove_proc_entry("fib_trie", net->proc_net);
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		remove_proc_entry("fib_trie", net->proc_net);
- out1:
- 	return -ENOMEM;
- }
- 
- void __net_exit fib_proc_exit(struct net *net)
- {
--	remove_proc_entry("fib_trie", net->proc_net);
--	remove_proc_entry("fib_triestat", net->proc_net);
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED)) {
-+		remove_proc_entry("fib_trie", net->proc_net);
-+		remove_proc_entry("fib_triestat", net->proc_net);
-+	}
- 	remove_proc_entry("route", net->proc_net);
- }
- 
---- a/net/ipv4/proc.c
-+++ b/net/ipv4/proc.c
-@@ -524,5 +524,8 @@ static __net_initdata struct pernet_oper
- 
- int __init ip_misc_proc_init(void)
- {
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return 0;
-+
- 	return register_pernet_subsys(&ip_proc_ops);
- }
---- a/net/ipv4/route.c
-+++ b/net/ipv4/route.c
-@@ -410,6 +410,9 @@ static struct pernet_operations ip_rt_pr
- 
- static int __init ip_rt_proc_init(void)
- {
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return 0;
-+
- 	return register_pernet_subsys(&ip_rt_proc_ops);
- }
- 
--- a/target/linux/generic/hack-4.19/904-debloat_dma_buf.patch	2022-03-22 08:54:47.220464691 +0800
+++ b/target/linux/generic/hack-4.19/904-debloat_dma_buf.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,64 +0,0 @@
-From e3692cb2fcd5ba1244512a0f43b8118f65f1c375 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 8 Jul 2017 08:20:43 +0200
-Subject: debloat: dmabuf
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- drivers/base/Kconfig      |  2 +-
- drivers/dma-buf/Makefile  | 10 +++++++---
- drivers/dma-buf/dma-buf.c |  4 +++-
- kernel/sched/core.c       |  1 +
- 4 files changed, 12 insertions(+), 5 deletions(-)
-
---- a/drivers/base/Kconfig
-+++ b/drivers/base/Kconfig
-@@ -172,7 +172,7 @@ config SOC_BUS
- source "drivers/base/regmap/Kconfig"
- 
- config DMA_SHARED_BUFFER
--	bool
-+	tristate
- 	default n
- 	select ANON_INODES
- 	select IRQ_WORK
---- a/drivers/dma-buf/Makefile
-+++ b/drivers/dma-buf/Makefile
-@@ -1,3 +1,7 @@
--obj-y := dma-buf.o dma-fence.o dma-fence-array.o reservation.o seqno-fence.o
--obj-$(CONFIG_SYNC_FILE)		+= sync_file.o
--obj-$(CONFIG_SW_SYNC)		+= sw_sync.o sync_debug.o
-+obj-$(CONFIG_DMA_SHARED_BUFFER) := dma-shared-buffer.o
-+
-+dma-buf-objs-y := dma-buf.o dma-fence.o dma-fence-array.o reservation.o seqno-fence.o
-+dma-buf-objs-$(CONFIG_SYNC_FILE)		+= sync_file.o
-+dma-buf-objs-$(CONFIG_SW_SYNC)		+= sw_sync.o sync_debug.o
-+
-+dma-shared-buffer-objs :=  $(dma-buf-objs-y)
---- a/drivers/dma-buf/dma-buf.c
-+++ b/drivers/dma-buf/dma-buf.c
-@@ -34,6 +34,7 @@
- #include <linux/poll.h>
- #include <linux/reservation.h>
- #include <linux/mm.h>
-+#include <linux/module.h>
- 
- #include <uapi/linux/dma-buf.h>
- 
-@@ -1159,4 +1160,5 @@ static void __exit dma_buf_deinit(void)
- {
- 	dma_buf_uninit_debugfs();
- }
--__exitcall(dma_buf_deinit);
-+module_exit(dma_buf_deinit);
-+MODULE_LICENSE("GPL");
---- a/kernel/sched/core.c
-+++ b/kernel/sched/core.c
-@@ -2129,6 +2129,7 @@ int wake_up_state(struct task_struct *p,
- {
- 	return try_to_wake_up(p, state, 0);
- }
-+EXPORT_SYMBOL_GPL(wake_up_state);
- 
- /*
-  * Perform scheduler related setup for a newly forked process p.
--- a/target/linux/generic/hack-4.19/910-kobject_uevent.patch	2022-03-22 08:54:47.220464691 +0800
+++ b/target/linux/generic/hack-4.19/910-kobject_uevent.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,32 +0,0 @@
-From 0d37e6edc09c99e683dd91ca0e83bbc0df8477b3 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sun, 16 Jul 2017 16:56:10 +0200
-Subject: lib: add uevent_next_seqnum()
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/linux/kobject.h |  5 +++++
- lib/kobject_uevent.c    | 37 +++++++++++++++++++++++++++++++++++++
- 2 files changed, 42 insertions(+)
-
---- a/lib/kobject_uevent.c
-+++ b/lib/kobject_uevent.c
-@@ -179,6 +179,18 @@ out:
- 	return r;
- }
- 
-+u64 uevent_next_seqnum(void)
-+{
-+	u64 seq;
-+
-+	mutex_lock(&uevent_sock_mutex);
-+	seq = ++uevent_seqnum;
-+	mutex_unlock(&uevent_sock_mutex);
-+
-+	return seq;
-+}
-+EXPORT_SYMBOL_GPL(uevent_next_seqnum);
-+
- /**
-  * kobject_synth_uevent - send synthetic uevent with arguments
-  *
--- a/target/linux/generic/hack-4.19/911-kobject_add_broadcast_uevent.patch	2022-03-22 08:54:47.220464691 +0800
+++ b/target/linux/generic/hack-4.19/911-kobject_add_broadcast_uevent.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,76 +0,0 @@
-From 0d37e6edc09c99e683dd91ca0e83bbc0df8477b3 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sun, 16 Jul 2017 16:56:10 +0200
-Subject: lib: add uevent_next_seqnum()
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/linux/kobject.h |  5 +++++
- lib/kobject_uevent.c    | 37 +++++++++++++++++++++++++++++++++++++
- 2 files changed, 42 insertions(+)
-
---- a/include/linux/kobject.h
-+++ b/include/linux/kobject.h
-@@ -32,6 +32,8 @@
- #define UEVENT_NUM_ENVP			32	/* number of env pointers */
- #define UEVENT_BUFFER_SIZE		2048	/* buffer for the variables */
- 
-+struct sk_buff;
-+
- #ifdef CONFIG_UEVENT_HELPER
- /* path to the userspace helper executed on an event */
- extern char uevent_helper[];
-@@ -244,4 +246,7 @@ int kobject_synth_uevent(struct kobject
- __printf(2, 3)
- int add_uevent_var(struct kobj_uevent_env *env, const char *format, ...);
- 
-+int broadcast_uevent(struct sk_buff *skb, __u32 pid, __u32 group,
-+		     gfp_t allocation);
-+
- #endif /* _KOBJECT_H_ */
---- a/lib/kobject_uevent.c
-+++ b/lib/kobject_uevent.c
-@@ -688,6 +688,43 @@ int add_uevent_var(struct kobj_uevent_en
- EXPORT_SYMBOL_GPL(add_uevent_var);
- 
- #if defined(CONFIG_NET)
-+int broadcast_uevent(struct sk_buff *skb, __u32 pid, __u32 group,
-+		     gfp_t allocation)
-+{
-+	struct uevent_sock *ue_sk;
-+	int err = 0;
-+
-+	/* send netlink message */
-+	mutex_lock(&uevent_sock_mutex);
-+	list_for_each_entry(ue_sk, &uevent_sock_list, list) {
-+		struct sock *uevent_sock = ue_sk->sk;
-+		struct sk_buff *skb2;
-+
-+		skb2 = skb_clone(skb, allocation);
-+		if (!skb2)
-+			break;
-+
-+		err = netlink_broadcast(uevent_sock, skb2, pid, group,
-+					allocation);
-+		if (err)
-+			break;
-+	}
-+	mutex_unlock(&uevent_sock_mutex);
-+
-+	kfree_skb(skb);
-+	return err;
-+}
-+#else
-+int broadcast_uevent(struct sk_buff *skb, __u32 pid, __u32 group,
-+		     gfp_t allocation)
-+{
-+	kfree_skb(skb);
-+	return 0;
-+}
-+#endif
-+EXPORT_SYMBOL_GPL(broadcast_uevent);
-+
-+#if defined(CONFIG_NET)
- static int uevent_net_broadcast(struct sock *usk, struct sk_buff *skb,
- 				struct netlink_ext_ack *extack)
- {
--- a/target/linux/generic/hack-4.19/921-always-create-console-node-in-initramfs.patch	2022-03-22 08:54:47.221464693 +0800
+++ b/target/linux/generic/hack-4.19/921-always-create-console-node-in-initramfs.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,40 +0,0 @@
-From 5d301596fdc72f6cb672f72eb3c66e7cddefb103 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 8 Jul 2017 08:26:02 +0200
-Subject: initramfs: always create console node
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- usr/gen_initramfs_list.sh | 14 ++++++++++++++
- 1 file changed, 14 insertions(+)
-
---- a/usr/gen_initramfs_list.sh
-+++ b/usr/gen_initramfs_list.sh
-@@ -59,6 +59,18 @@ default_initramfs() {
- 	EOF
- }
- 
-+list_openwrt_initramfs() {
-+	:
-+}
-+
-+openwrt_initramfs() {
-+	# make sure that /dev/console exists
-+	cat <<-EOF >> ${output}
-+		dir /dev 0755 0 0
-+		nod /dev/console 0600 0 0 c 5 1
-+	EOF
-+}
-+
- filetype() {
- 	local argv1="$1"
- 
-@@ -180,6 +192,8 @@ dir_filelist() {
- 	if [  "$(echo "${dirlist}" | wc -l)" -gt 1 ]; then
- 		${dep_list}print_mtime "$1"
- 
-+		${dep_list}openwrt_initramfs
-+
- 		echo "${dirlist}" | \
- 		while read x; do
- 			${dep_list}parse ${x}
--- a/target/linux/generic/hack-4.19/930-crashlog.patch	2022-03-22 08:54:47.221464693 +0800
+++ b/target/linux/generic/hack-4.19/930-crashlog.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,338 +0,0 @@
-From 6b1ab74a9917012d0c559edc4ed299d9228ac89f Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 8 Jul 2017 08:26:47 +0200
-Subject: kernel: add the new 'crashlog' feature
-
-this tries to store kernel oops/panic logs in a fixed location in RAM to
-recover them available to user space using debugfs
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/linux/crashlog.h |  17 ++++
- init/Kconfig             |   4 +
- kernel/Makefile          |   1 +
- kernel/crashlog.c        | 213 +++++++++++++++++++++++++++++++++++++++++++++++
- kernel/module.c          |   3 +
- mm/bootmem.c             |   2 +
- mm/memblock.c            |   5 ++
- 7 files changed, 245 insertions(+)
- create mode 100644 include/linux/crashlog.h
- create mode 100644 kernel/crashlog.c
-
---- /dev/null
-+++ b/include/linux/crashlog.h
-@@ -0,0 +1,17 @@
-+#ifndef __CRASHLOG_H
-+#define __CRASHLOG_H
-+
-+#ifdef CONFIG_CRASHLOG
-+void crashlog_init_bootmem(struct bootmem_data *bdata);
-+void crashlog_init_memblock(phys_addr_t addr, phys_addr_t size);
-+#else
-+static inline void crashlog_init_bootmem(struct bootmem_data *bdata)
-+{
-+}
-+
-+static inline void crashlog_init_memblock(phys_addr_t addr, phys_addr_t size)
-+{
-+}
-+#endif
-+
-+#endif
---- a/init/Kconfig
-+++ b/init/Kconfig
-@@ -1049,6 +1049,10 @@ config RELAY
- 
- 	  If unsure, say N.
- 
-+config CRASHLOG
-+	bool "Crash logging"
-+	depends on (!NO_BOOTMEM || HAVE_MEMBLOCK)
-+
- config BLK_DEV_INITRD
- 	bool "Initial RAM filesystem and RAM disk (initramfs/initrd) support"
- 	help
---- a/kernel/Makefile
-+++ b/kernel/Makefile
-@@ -114,6 +114,7 @@ obj-$(CONFIG_TORTURE_TEST) += torture.o
- obj-$(CONFIG_HAS_IOMEM) += iomem.o
- obj-$(CONFIG_ZONE_DEVICE) += memremap.o
- obj-$(CONFIG_RSEQ) += rseq.o
-+obj-$(CONFIG_CRASHLOG) += crashlog.o
- 
- $(obj)/configs.o: $(obj)/config_data.h
- 
---- /dev/null
-+++ b/kernel/crashlog.c
-@@ -0,0 +1,213 @@
-+/*
-+ * Crash information logger
-+ * Copyright (C) 2010 Felix Fietkau <nbd@nbd.name>
-+ *
-+ * Based on ramoops.c
-+ *   Copyright (C) 2010 Marco Stornelli <marco.stornelli@gmail.com>
-+ *
-+ * This program is free software; you can redistribute it and/or
-+ * modify it under the terms of the GNU General Public License
-+ * version 2 as published by the Free Software Foundation.
-+ *
-+ * This program is distributed in the hope that it will be useful, but
-+ * WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-+ * General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-+ * 02110-1301 USA
-+ *
-+ */
-+
-+#include <linux/module.h>
-+#include <linux/bootmem.h>
-+#include <linux/memblock.h>
-+#include <linux/debugfs.h>
-+#include <linux/crashlog.h>
-+#include <linux/kmsg_dump.h>
-+#include <linux/module.h>
-+#include <linux/pfn.h>
-+#include <linux/vmalloc.h>
-+#include <asm/io.h>
-+
-+#define CRASHLOG_PAGES	4
-+#define CRASHLOG_SIZE	(CRASHLOG_PAGES * PAGE_SIZE)
-+#define CRASHLOG_MAGIC	0xa1eedead
-+
-+/*
-+ * Start the log at 1M before the end of RAM, as some boot loaders like
-+ * to use the end of the RAM for stack usage and other things
-+ * If this fails, fall back to using the last part.
-+ */
-+#define CRASHLOG_OFFSET	(1024 * 1024)
-+
-+struct crashlog_data {
-+	u32 magic;
-+	u32 len;
-+	u8 data[];
-+};
-+
-+static struct debugfs_blob_wrapper crashlog_blob;
-+static unsigned long crashlog_addr = 0;
-+static struct crashlog_data *crashlog_buf;
-+static struct kmsg_dumper dump;
-+static bool first = true;
-+
-+extern struct list_head *crashlog_modules;
-+
-+static bool crashlog_set_addr(phys_addr_t addr, phys_addr_t size)
-+{
-+	/* Limit to lower 64 MB to avoid highmem */
-+	phys_addr_t limit = 64 * 1024 * 1024;
-+
-+	if (crashlog_addr)
-+		return false;
-+
-+	if (addr > limit)
-+		return false;
-+
-+	if (addr + size > limit)
-+		size = limit - addr;
-+
-+	crashlog_addr = addr;
-+
-+	if (addr + size > CRASHLOG_OFFSET)
-+		crashlog_addr += size - CRASHLOG_OFFSET;
-+
-+	return true;
-+}
-+
-+#ifndef CONFIG_NO_BOOTMEM
-+void __init crashlog_init_bootmem(bootmem_data_t *bdata)
-+{
-+	phys_addr_t start, end;
-+
-+	start = PFN_PHYS(bdata->node_low_pfn);
-+	end = PFN_PHYS(bdata->node_min_pfn);
-+	if (!crashlog_set_addr(start, end - start))
-+		return;
-+
-+	if (reserve_bootmem(crashlog_addr, CRASHLOG_SIZE, BOOTMEM_EXCLUSIVE) < 0) {
-+		printk("Crashlog failed to allocate RAM at address 0x%lx\n",
-+		       crashlog_addr);
-+		crashlog_addr = 0;
-+	}
-+}
-+#endif
-+
-+#ifdef CONFIG_HAVE_MEMBLOCK
-+void __init_memblock crashlog_init_memblock(phys_addr_t addr, phys_addr_t size)
-+{
-+	if (!crashlog_set_addr(addr, size))
-+		return;
-+
-+	if (memblock_reserve(crashlog_addr, CRASHLOG_SIZE)) {
-+		printk("Crashlog failed to allocate RAM at address 0x%lx\n",
-+		       crashlog_addr);
-+		crashlog_addr = 0;
-+	}
-+}
-+#endif
-+
-+static void __init crashlog_copy(void)
-+{
-+	if (crashlog_buf->magic != CRASHLOG_MAGIC)
-+		return;
-+
-+	if (!crashlog_buf->len || crashlog_buf->len >
-+	    CRASHLOG_SIZE - sizeof(*crashlog_buf))
-+		return;
-+
-+	crashlog_blob.size = crashlog_buf->len;
-+	crashlog_blob.data = kmemdup(crashlog_buf->data,
-+		crashlog_buf->len, GFP_KERNEL);
-+
-+	debugfs_create_blob("crashlog", 0700, NULL, &crashlog_blob);
-+}
-+
-+static int get_maxlen(void)
-+{
-+	return CRASHLOG_SIZE - sizeof(*crashlog_buf) - crashlog_buf->len;
-+}
-+
-+static void crashlog_printf(const char *fmt, ...)
-+{
-+	va_list args;
-+	int len = get_maxlen();
-+
-+	if (!len)
-+		return;
-+
-+	va_start(args, fmt);
-+	crashlog_buf->len += vscnprintf(
-+		&crashlog_buf->data[crashlog_buf->len],
-+		len, fmt, args);
-+	va_end(args);
-+}
-+
-+static void crashlog_do_dump(struct kmsg_dumper *dumper,
-+		enum kmsg_dump_reason reason)
-+{
-+	struct timeval tv;
-+	struct module *m;
-+	char *buf;
-+	size_t len;
-+
-+	if (!first)
-+		crashlog_printf("\n===================================\n");
-+
-+	do_gettimeofday(&tv);
-+	crashlog_printf("Time: %lu.%lu\n",
-+		(long)tv.tv_sec, (long)tv.tv_usec);
-+
-+	if (first) {
-+		crashlog_printf("Modules:");
-+		list_for_each_entry(m, crashlog_modules, list) {
-+			crashlog_printf("\t%s@%p+%x", m->name,
-+			m->core_layout.base, m->core_layout.size,
-+			m->init_layout.base, m->init_layout.size);
-+		}
-+		crashlog_printf("\n");
-+		first = false;
-+	}
-+
-+	buf = (char *)&crashlog_buf->data[crashlog_buf->len];
-+
-+	kmsg_dump_get_buffer(dumper, true, buf, get_maxlen(), &len);
-+
-+	crashlog_buf->len += len;
-+}
-+
-+
-+int __init crashlog_init_fs(void)
-+{
-+	struct page *pages[CRASHLOG_PAGES];
-+	pgprot_t prot;
-+	int i;
-+
-+	if (!crashlog_addr) {
-+		printk("No memory allocated for crashlog\n");
-+		return -ENOMEM;
-+	}
-+
-+	printk("Crashlog allocated RAM at address 0x%lx\n", (unsigned long) crashlog_addr);
-+	for (i = 0; i < CRASHLOG_PAGES; i++)
-+		pages[i] = pfn_to_page((crashlog_addr >> PAGE_SHIFT) + i);
-+
-+	prot = pgprot_writecombine(PAGE_KERNEL);
-+	crashlog_buf = vmap(pages, CRASHLOG_PAGES, VM_MAP, prot);
-+
-+	crashlog_copy();
-+
-+	crashlog_buf->magic = CRASHLOG_MAGIC;
-+	crashlog_buf->len = 0;
-+
-+	dump.max_reason = KMSG_DUMP_OOPS;
-+	dump.dump = crashlog_do_dump;
-+	kmsg_dump_register(&dump);
-+
-+	return 0;
-+}
-+module_init(crashlog_init_fs);
---- a/kernel/module.c
-+++ b/kernel/module.c
-@@ -251,6 +251,9 @@ static void mod_update_bounds(struct mod
- #ifdef CONFIG_KGDB_KDB
- struct list_head *kdb_modules = &modules; /* kdb needs the list of modules */
- #endif /* CONFIG_KGDB_KDB */
-+#ifdef CONFIG_CRASHLOG
-+struct list_head *crashlog_modules = &modules;
-+#endif
- 
- static void module_assert_mutex(void)
- {
---- a/mm/bootmem.c
-+++ b/mm/bootmem.c
-@@ -15,6 +15,7 @@
- #include <linux/export.h>
- #include <linux/kmemleak.h>
- #include <linux/range.h>
-+#include <linux/crashlog.h>
- #include <linux/bug.h>
- #include <linux/io.h>
- #include <linux/bootmem.h>
-@@ -215,6 +216,7 @@ static unsigned long __init free_all_boo
- 	if (!bdata->node_bootmem_map)
- 		return 0;
- 
-+	crashlog_init_bootmem(bdata);
- 	map = bdata->node_bootmem_map;
- 	start = bdata->node_min_pfn;
- 	end = bdata->node_low_pfn;
---- a/mm/memblock.c
-+++ b/mm/memblock.c
-@@ -21,6 +21,7 @@
- #include <linux/seq_file.h>
- #include <linux/memblock.h>
- #include <linux/bootmem.h>
-+#include <linux/crashlog.h>
- 
- #include <asm/sections.h>
- #include <linux/io.h>
-@@ -547,6 +548,8 @@ static void __init_memblock memblock_ins
- 	memblock_set_region_node(rgn, nid);
- 	type->cnt++;
- 	type->total_size += size;
-+	if (type == &memblock.memory)
-+		crashlog_init_memblock(base, size);
- }
- 
- /**
-@@ -586,6 +589,8 @@ int __init_memblock memblock_add_range(s
- 		type->regions[0].flags = flags;
- 		memblock_set_region_node(&type->regions[0], nid);
- 		type->total_size = size;
-+		if (type == &memblock.memory)
-+			crashlog_init_memblock(base, size);
- 		return 0;
- 	}
- repeat:
--- a/target/linux/generic/hack-4.19/952-net-conntrack-events-support-multiple-registrant.patch	2022-03-22 08:54:47.221464693 +0800
+++ b/target/linux/generic/hack-4.19/952-net-conntrack-events-support-multiple-registrant.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,325 +0,0 @@
-diff --git a/include/net/netfilter/nf_conntrack_ecache.h b/include/net/netfilter/nf_conntrack_ecache.h
-index 12d967b..c2b98b6 100644
---- a/include/net/netfilter/nf_conntrack_ecache.h
-+++ b/include/net/netfilter/nf_conntrack_ecache.h
-@@ -71,6 +71,10 @@ struct nf_ct_event {
- 	int report;
- };
- 
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+extern int nf_conntrack_register_notifier(struct net *net, struct notifier_block *nb);
-+extern int nf_conntrack_unregister_notifier(struct net *net, struct notifier_block *nb);
-+#else
- struct nf_ct_event_notifier {
- 	int (*fcn)(unsigned int events, struct nf_ct_event *item);
- };
-@@ -79,7 +83,7 @@ int nf_conntrack_register_notifier(struc
- 				   struct nf_ct_event_notifier *nb);
- void nf_conntrack_unregister_notifier(struct net *net,
- 				      struct nf_ct_event_notifier *nb);
--
-+#endif
- void nf_ct_deliver_cached_events(struct nf_conn *ct);
- int nf_conntrack_eventmask_report(unsigned int eventmask, struct nf_conn *ct,
- 				  u32 portid, int report);
-@@ -87,12 +91,15 @@ int nf_conntrack_eventmask_report(unsign
- static inline void
- nf_conntrack_event_cache(enum ip_conntrack_events event, struct nf_conn *ct)
- {
--	struct net *net = nf_ct_net(ct);
- 	struct nf_conntrack_ecache *e;
-+#ifndef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+	struct net *net = nf_ct_net(ct);
- 
- 	if (!rcu_access_pointer(net->ct.nf_conntrack_event_cb))
- 		return;
- 
-+#endif
-+
- 	e = nf_ct_ecache_find(ct);
- 	if (e == NULL)
- 		return;
-@@ -104,10 +111,12 @@ static inline int
- nf_conntrack_event_report(enum ip_conntrack_events event, struct nf_conn *ct,
- 			  u32 portid, int report)
- {
-+#ifndef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
- 	const struct net *net = nf_ct_net(ct);
- 
- 	if (!rcu_access_pointer(net->ct.nf_conntrack_event_cb))
- 		return 0;
-+#endif
- 
- 	return nf_conntrack_eventmask_report(1 << event, ct, portid, report);
- }
-@@ -115,11 +124,14 @@ nf_conntrack_event_report(enum ip_conntr
- static inline int
- nf_conntrack_event(enum ip_conntrack_events event, struct nf_conn *ct)
- {
-+#ifndef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
- 	const struct net *net = nf_ct_net(ct);
- 
- 	if (!rcu_access_pointer(net->ct.nf_conntrack_event_cb))
- 		return 0;
- 
-+#endif
-+
- 	return nf_conntrack_eventmask_report(1 << event, ct, 0, 0);
- }
- 
-diff --git a/include/net/netns/conntrack.h b/include/net/netns/conntrack.h
-index e469e85..1d31db8 100644
---- a/include/net/netns/conntrack.h
-+++ b/include/net/netns/conntrack.h
-@@ -114,7 +114,11 @@ struct netns_ct {
- 
- 	struct ct_pcpu __percpu *pcpu_lists;
- 	struct ip_conntrack_stat __percpu *stat;
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+	struct atomic_notifier_head nf_conntrack_chain;
-+#else
- 	struct nf_ct_event_notifier __rcu *nf_conntrack_event_cb;
-+#endif
- 	struct nf_exp_event_notifier __rcu *nf_expect_event_cb;
- 	struct nf_ip_net	nf_ct_proto;
- #if defined(CONFIG_NF_CONNTRACK_LABELS)
-diff --git a/net/netfilter/Kconfig b/net/netfilter/Kconfig
-index 63073be..08d7aab 100644
---- a/net/netfilter/Kconfig
-+++ b/net/netfilter/Kconfig
-@@ -118,6 +118,14 @@ config NF_CONNTRACK_EVENTS
- 
- 	  If unsure, say `N'.
- 
-+config NF_CONNTRACK_CHAIN_EVENTS
-+	bool "Register multiple callbacks to ct events"
-+	depends on NF_CONNTRACK_EVENTS
-+	help
-+	  Support multiple registrations.
-+
-+	  If unsure, say `N'.
-+
- config NF_CONNTRACK_TIMEOUT
- 	bool  'Connection tracking timeout'
- 	depends on NETFILTER_ADVANCED
-diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c
-index 6bd1508..9b81c7c 100644
---- a/net/netfilter/nf_conntrack_core.c
-+++ b/net/netfilter/nf_conntrack_core.c
-@@ -2167,6 +2167,10 @@ int nf_conntrack_init_net(struct net *ne
- 	ret = nf_conntrack_proto_pernet_init(net);
- 	if (ret < 0)
- 		goto err_proto;
-+
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+	ATOMIC_INIT_NOTIFIER_HEAD(&net->ct.nf_conntrack_chain);
-+#endif
- 	return 0;
- 
- err_proto:
-diff --git a/net/netfilter/nf_conntrack_ecache.c b/net/netfilter/nf_conntrack_ecache.c
-index da9df2d..e0e2a8f 100644
---- a/net/netfilter/nf_conntrack_ecache.c
-+++ b/net/netfilter/nf_conntrack_ecache.c
-@@ -18,6 +18,9 @@
- #include <linux/stddef.h>
- #include <linux/err.h>
- #include <linux/percpu.h>
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+#include <linux/notifier.h>
-+#endif
- #include <linux/kernel.h>
- #include <linux/netdevice.h>
- #include <linux/slab.h>
-@@ -117,6 +120,38 @@ static void ecache_work(struct work_stru
- 		schedule_delayed_work(&ctnet->ecache_dwork, delay);
- }
- 
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+int
-+nf_conntrack_eventmask_report(unsigned int eventmask,
-+			      struct nf_conn *ct,
-+			      u32 portid,
-+			      int report)
-+{
-+	struct nf_conntrack_ecache *e;
-+	struct net *net = nf_ct_net(ct);
-+
-+	e = nf_ct_ecache_find(ct);
-+	if (e == NULL)
-+		return 0;
-+
-+	if (nf_ct_is_confirmed(ct)) {
-+		struct nf_ct_event item = {
-+			.ct = ct,
-+			.portid	= e->portid ? e->portid : portid,
-+			.report = report
-+		};
-+		/* This is a resent of a destroy event? If so, skip missed */
-+		unsigned long missed = e->portid ? 0 : e->missed;
-+
-+		if (!((eventmask | missed) & e->ctmask))
-+			return 0;
-+
-+		atomic_notifier_call_chain(&net->ct.nf_conntrack_chain, eventmask | missed, &item);
-+	}
-+
-+	return 0;
-+}
-+#else
- int nf_conntrack_eventmask_report(unsigned int eventmask, struct nf_conn *ct,
- 				  u32 portid, int report)
- {
-@@ -171,10 +206,52 @@ out_unlock:
- 	rcu_read_unlock();
- 	return ret;
- }
-+#endif
- EXPORT_SYMBOL_GPL(nf_conntrack_eventmask_report);
- 
- /* deliver cached events and clear cache entry - must be called with locally
-  * disabled softirqs */
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+void nf_ct_deliver_cached_events(struct nf_conn *ct)
-+{
-+	unsigned long events, missed;
-+	struct nf_conntrack_ecache *e;
-+	struct nf_ct_event item;
-+	struct net *net = nf_ct_net(ct);
-+
-+	e = nf_ct_ecache_find(ct);
-+	if (e == NULL)
-+		return;
-+
-+	events = xchg(&e->cache, 0);
-+
-+	if (!nf_ct_is_confirmed(ct) || nf_ct_is_dying(ct) || !events)
-+		return;
-+
-+	/* We make a copy of the missed event cache without taking
-+	 * the lock, thus we may send missed events twice. However,
-+	 * this does not harm and it happens very rarely. */
-+	missed = e->missed;
-+
-+	if (!((events | missed) & e->ctmask))
-+		return;
-+
-+	item.ct = ct;
-+	item.portid = 0;
-+	item.report = 0;
-+
-+	atomic_notifier_call_chain(&net->ct.nf_conntrack_chain,
-+			events | missed,
-+			&item);
-+
-+	if (likely(!missed))
-+		return;
-+
-+	spin_lock_bh(&ct->lock);
-+		e->missed &= ~missed;
-+	spin_unlock_bh(&ct->lock);
-+}
-+#else
- void nf_ct_deliver_cached_events(struct nf_conn *ct)
- {
- 	struct net *net = nf_ct_net(ct);
-@@ -225,6 +302,7 @@ void nf_ct_deliver_cached_events(struct
- out_unlock:
- 	rcu_read_unlock();
- }
-+#endif
- EXPORT_SYMBOL_GPL(nf_ct_deliver_cached_events);
- 
- void nf_ct_expect_event_report(enum ip_conntrack_expect_events event,
-@@ -257,6 +335,12 @@ out_unlock:
- 	rcu_read_unlock();
- }
- 
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+int nf_conntrack_register_notifier(struct net *net, struct notifier_block *nb)
-+{
-+        return atomic_notifier_chain_register(&net->ct.nf_conntrack_chain, nb);
-+}
-+#else
- int nf_conntrack_register_notifier(struct net *net,
- 				   struct nf_ct_event_notifier *new)
- {
-@@ -277,8 +361,15 @@ out_unlock:
- 	mutex_unlock(&nf_ct_ecache_mutex);
- 	return ret;
- }
-+#endif
- EXPORT_SYMBOL_GPL(nf_conntrack_register_notifier);
- 
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+int nf_conntrack_unregister_notifier(struct net *net, struct notifier_block *nb)
-+{
-+	return atomic_notifier_chain_unregister(&net->ct.nf_conntrack_chain, nb);
-+}
-+#else
- void nf_conntrack_unregister_notifier(struct net *net,
- 				      struct nf_ct_event_notifier *new)
- {
-@@ -292,6 +383,7 @@ void nf_conntrack_unregister_notifier(st
- 	mutex_unlock(&nf_ct_ecache_mutex);
- 	/* synchronize_rcu() is called from ctnetlink_exit. */
- }
-+#endif
- EXPORT_SYMBOL_GPL(nf_conntrack_unregister_notifier);
- 
- int nf_ct_expect_register_notifier(struct net *net,
-diff --git a/net/netfilter/nf_conntrack_netlink.c b/net/netfilter/nf_conntrack_netlink.c
-index 04111c1..8c741f7 100644
---- a/net/netfilter/nf_conntrack_netlink.c
-+++ b/net/netfilter/nf_conntrack_netlink.c
-@@ -28,6 +28,11 @@
- #include <linux/netlink.h>
- #include <linux/spinlock.h>
- #include <linux/interrupt.h>
-+
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+#include <linux/notifier.h>
-+#endif
-+
- #include <linux/slab.h>
- 
- #include <linux/netfilter.h>
-@@ -618,14 +623,22 @@ static size_t ctnetlink_nlmsg_size(const
- 	       ;
- }
- 
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+static int ctnetlink_conntrack_event(struct notifier_block *this,
-+                           unsigned long events, void *ptr)
-+#else
- static int
- ctnetlink_conntrack_event(unsigned int events, struct nf_ct_event *item)
-+#endif
- {
- 	const struct nf_conntrack_zone *zone;
- 	struct net *net;
- 	struct nlmsghdr *nlh;
- 	struct nfgenmsg *nfmsg;
- 	struct nlattr *nest_parms;
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+	struct nf_ct_event *item = (struct nf_ct_event *)ptr;
-+#endif
- 	struct nf_conn *ct = item->ct;
- 	struct sk_buff *skb;
- 	unsigned int type;
-@@ -3290,9 +3303,15 @@ static int ctnetlink_stat_exp_cpu(struct
- }
- 
- #ifdef CONFIG_NF_CONNTRACK_EVENTS
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+static struct notifier_block ctnl_notifier = {
-+	.notifier_call = ctnetlink_conntrack_event,
-+};
-+#else
- static struct nf_ct_event_notifier ctnl_notifier = {
- 	.fcn = ctnetlink_conntrack_event,
- };
-+#endif
- 
- static struct nf_exp_event_notifier ctnl_notifier_exp = {
- 	.fcn = ctnetlink_expect_event,
--- a/target/linux/generic/hack-4.9/204-module_strip.patch	2022-03-22 08:54:47.222464694 +0800
+++ b/target/linux/generic/hack-4.9/204-module_strip.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,214 +0,0 @@
-From a779a482fb9b9f8fcdf8b2519c789b4b9bb5dd05 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 16:56:48 +0200
-Subject: build: add a hack for removing non-essential module info
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/linux/module.h      | 13 ++++++++-----
- include/linux/moduleparam.h | 15 ++++++++++++---
- init/Kconfig                |  7 +++++++
- kernel/module.c             |  5 ++++-
- scripts/mod/modpost.c       | 12 ++++++++++++
- 5 files changed, 43 insertions(+), 9 deletions(-)
-
---- a/include/linux/module.h
-+++ b/include/linux/module.h
-@@ -159,6 +159,7 @@ extern void cleanup_module(void);
- 
- /* Generic info of form tag = "info" */
- #define MODULE_INFO(tag, info) __MODULE_INFO(tag, tag, info)
-+#define MODULE_INFO_STRIP(tag, info) __MODULE_INFO_STRIP(tag, tag, info)
- 
- /* For userspace: you can also call me... */
- #define MODULE_ALIAS(_alias) MODULE_INFO(alias, _alias)
-@@ -202,12 +203,12 @@ extern void cleanup_module(void);
-  * Author(s), use "Name <email>" or just "Name", for multiple
-  * authors use multiple MODULE_AUTHOR() statements/lines.
-  */
--#define MODULE_AUTHOR(_author) MODULE_INFO(author, _author)
-+#define MODULE_AUTHOR(_author) MODULE_INFO_STRIP(author, _author)
- 
- /* What your module does. */
--#define MODULE_DESCRIPTION(_description) MODULE_INFO(description, _description)
-+#define MODULE_DESCRIPTION(_description) MODULE_INFO_STRIP(description, _description)
- 
--#ifdef MODULE
-+#if defined(MODULE) && !defined(CONFIG_MODULE_STRIPPED)
- /* Creates an alias so file2alias.c can find device table. */
- #define MODULE_DEVICE_TABLE(type, name)					\
- extern const typeof(name) __mod_##type##__##name##_device_table		\
-@@ -234,7 +235,9 @@ extern const typeof(name) __mod_##type##
-  */
- 
- #if defined(MODULE) || !defined(CONFIG_SYSFS)
--#define MODULE_VERSION(_version) MODULE_INFO(version, _version)
-+#define MODULE_VERSION(_version) MODULE_INFO_STRIP(version, _version)
-+#elif defined(CONFIG_MODULE_STRIPPED)
-+#define MODULE_VERSION(_version) __MODULE_INFO_DISABLED(version)
- #else
- #define MODULE_VERSION(_version)					\
- 	static struct module_version_attribute ___modver_attr = {	\
-@@ -256,7 +259,7 @@ extern const typeof(name) __mod_##type##
- /* Optional firmware file (or files) needed by the module
-  * format is simply firmware file name.  Multiple firmware
-  * files require multiple MODULE_FIRMWARE() specifiers */
--#define MODULE_FIRMWARE(_firmware) MODULE_INFO(firmware, _firmware)
-+#define MODULE_FIRMWARE(_firmware) MODULE_INFO_STRIP(firmware, _firmware)
- 
- struct notifier_block;
- 
---- a/include/linux/moduleparam.h
-+++ b/include/linux/moduleparam.h
-@@ -16,6 +16,16 @@
- /* Chosen so that structs with an unsigned long line up. */
- #define MAX_PARAM_PREFIX_LEN (64 - sizeof(unsigned long))
- 
-+/* This struct is here for syntactic coherency, it is not used */
-+#define __MODULE_INFO_DISABLED(name)					  \
-+  struct __UNIQUE_ID(name) {}
-+
-+#ifdef CONFIG_MODULE_STRIPPED
-+#define __MODULE_INFO_STRIP(tag, name, info) __MODULE_INFO_DISABLED(name)
-+#else
-+#define __MODULE_INFO_STRIP(tag, name, info) __MODULE_INFO(tag, name, info)
-+#endif
-+
- #ifdef MODULE
- #define __MODULE_INFO(tag, name, info)					  \
- static const char __UNIQUE_ID(name)[]					  \
-@@ -23,8 +33,7 @@ static const char __UNIQUE_ID(name)[]
-   = __stringify(tag) "=" info
- #else  /* !MODULE */
- /* This struct is here for syntactic coherency, it is not used */
--#define __MODULE_INFO(tag, name, info)					  \
--  struct __UNIQUE_ID(name) {}
-+#define __MODULE_INFO(tag, name, info) __MODULE_INFO_DISABLED(name)
- #endif
- #define __MODULE_PARM_TYPE(name, _type)					  \
-   __MODULE_INFO(parmtype, name##type, #name ":" _type)
-@@ -32,7 +41,7 @@ static const char __UNIQUE_ID(name)[]
- /* One for each parameter, describing how to use it.  Some files do
-    multiple of these per line, so can't just use MODULE_INFO. */
- #define MODULE_PARM_DESC(_parm, desc) \
--	__MODULE_INFO(parm, _parm, #_parm ":" desc)
-+	__MODULE_INFO_STRIP(parm, _parm, #_parm ":" desc)
- 
- struct kernel_param;
- 
---- a/init/Kconfig
-+++ b/init/Kconfig
-@@ -2122,6 +2122,13 @@ config TRIM_UNUSED_KSYMS
- 
- 	  If unsure, or if you need to build out-of-tree modules, say N.
- 
-+config MODULE_STRIPPED
-+	bool "Reduce module size"
-+	depends on MODULES
-+	help
-+	  Remove module parameter descriptions, author info, version, aliases,
-+	  device tables, etc.
-+
- endif # MODULES
- 
- config MODULES_TREE_LOOKUP
---- a/kernel/module.c
-+++ b/kernel/module.c
-@@ -2968,9 +2968,11 @@ static struct module *setup_load_info(st
- 
- static int check_modinfo(struct module *mod, struct load_info *info, int flags)
- {
--	const char *modmagic = get_modinfo(info, "vermagic");
- 	int err;
- 
-+#ifndef CONFIG_MODULE_STRIPPED
-+	const char *modmagic = get_modinfo(info, "vermagic");
-+
- 	if (flags & MODULE_INIT_IGNORE_VERMAGIC)
- 		modmagic = NULL;
- 
-@@ -2991,6 +2993,7 @@ static int check_modinfo(struct module *
- 				mod->name);
- 		add_taint_module(mod, TAINT_OOT_MODULE, LOCKDEP_STILL_OK);
- 	}
-+#endif
- 
- 	check_modinfo_retpoline(mod, info);
- 
---- a/scripts/mod/modpost.c
-+++ b/scripts/mod/modpost.c
-@@ -1967,7 +1967,9 @@ static void read_symbols(char *modname)
- 		symname = remove_dot(info.strtab + sym->st_name);
- 
- 		handle_modversions(mod, &info, sym, symname);
-+#ifndef CONFIG_MODULE_STRIPPED
- 		handle_moddevtable(mod, &info, sym, symname);
-+#endif
- 	}
- 	if (!is_vmlinux(modname) ||
- 	     (is_vmlinux(modname) && vmlinux_section_warnings))
-@@ -2111,7 +2113,9 @@ static void add_header(struct buffer *b,
- 	buf_printf(b, "#include <linux/vermagic.h>\n");
- 	buf_printf(b, "#include <linux/compiler.h>\n");
- 	buf_printf(b, "\n");
-+#ifndef CONFIG_MODULE_STRIPPED
- 	buf_printf(b, "MODULE_INFO(vermagic, VERMAGIC_STRING);\n");
-+#endif
- 	buf_printf(b, "\n");
- 	buf_printf(b, "__visible struct module __this_module\n");
- 	buf_printf(b, "__attribute__((section(\".gnu.linkonce.this_module\"))) = {\n");
-@@ -2128,24 +2132,30 @@ static void add_header(struct buffer *b,
- 
- static void add_intree_flag(struct buffer *b, int is_intree)
- {
-+#ifndef CONFIG_MODULE_STRIPPED
- 	if (is_intree)
- 		buf_printf(b, "\nMODULE_INFO(intree, \"Y\");\n");
-+#endif
- }
- 
- /* Cannot check for assembler */
- static void add_retpoline(struct buffer *b)
- {
-+#ifndef CONFIG_MODULE_STRIPPED
- 	buf_printf(b, "\n#ifdef RETPOLINE\n");
- 	buf_printf(b, "MODULE_INFO(retpoline, \"Y\");\n");
- 	buf_printf(b, "#endif\n");
-+#endif
- }
- 
- static void add_staging_flag(struct buffer *b, const char *name)
- {
-+#ifndef CONFIG_MODULE_STRIPPED
- 	static const char *staging_dir = "drivers/staging";
- 
- 	if (strncmp(staging_dir, name, strlen(staging_dir)) == 0)
- 		buf_printf(b, "\nMODULE_INFO(staging, \"Y\");\n");
-+#endif
- }
- 
- /* In kernel, this size is defined in linux/module.h;
-@@ -2249,11 +2259,13 @@ static void add_depends(struct buffer *b
- 
- static void add_srcversion(struct buffer *b, struct module *mod)
- {
-+#ifndef CONFIG_MODULE_STRIPPED
- 	if (mod->srcversion[0]) {
- 		buf_printf(b, "\n");
- 		buf_printf(b, "MODULE_INFO(srcversion, \"%s\");\n",
- 			   mod->srcversion);
- 	}
-+#endif
- }
- 
- static void write_if_changed(struct buffer *b, const char *fname)
-@@ -2488,7 +2500,9 @@ int main(int argc, char **argv)
- 		add_staging_flag(&buf, mod->name);
- 		err |= add_versions(&buf, mod);
- 		add_depends(&buf, mod, modules);
-+#ifndef CONFIG_MODULE_STRIPPED
- 		add_moddevtable(&buf, mod);
-+#endif
- 		add_srcversion(&buf, mod);
- 
- 		sprintf(fname, "%s.mod.c", mod->name);
--- a/target/linux/generic/hack-4.9/207-disable-modorder.patch	2022-03-22 08:54:47.222464694 +0800
+++ b/target/linux/generic/hack-4.9/207-disable-modorder.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,44 +0,0 @@
-From c9ef4ab0f54356ee9f91d9676ea0ec123840ddc7 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 16:57:33 +0200
-Subject: kernel: do not build modules.order
-
-It is not needed for anything on the system and skipping this saves some
-build time, especially in cases where there is nothing to do.
-
-lede-commit: afc1675833a7bf5df094f59f7250369520646d04
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- Makefile               | 2 --
- scripts/Makefile.build | 2 +-
- 2 files changed, 1 insertion(+), 3 deletions(-)
-
---- a/Makefile
-+++ b/Makefile
-@@ -1240,7 +1240,6 @@ all: modules
- 
- PHONY += modules
- modules: $(vmlinux-dirs) $(if $(KBUILD_BUILTIN),vmlinux) modules.builtin
--	$(Q)$(AWK) '!x[$$0]++' $(vmlinux-dirs:%=$(objtree)/%/modules.order) > $(objtree)/modules.order
- 	@$(kecho) '  Building modules, stage 2.';
- 	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modpost
- 	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.fwinst obj=firmware __fw_modbuild
-@@ -1270,7 +1269,6 @@ _modinst_:
- 		rm -f $(MODLIB)/build ; \
- 		ln -s $(CURDIR) $(MODLIB)/build ; \
- 	fi
--	@cp -f $(objtree)/modules.order $(MODLIB)/
- 	@cp -f $(objtree)/modules.builtin $(MODLIB)/
- 	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modinst
- 
---- a/scripts/Makefile.build
-+++ b/scripts/Makefile.build
-@@ -93,7 +93,7 @@ modorder-target := $(obj)/modules.order
- # We keep a list of all modules in $(MODVERDIR)
- 
- __build: $(if $(KBUILD_BUILTIN),$(builtin-target) $(lib-target) $(extra-y)) \
--	 $(if $(KBUILD_MODULES),$(obj-m) $(modorder-target)) \
-+	 $(if $(KBUILD_MODULES),$(obj-m)) \
- 	 $(subdir-ym) $(always)
- 	@:
- 
--- a/target/linux/generic/hack-4.9/210-darwin_scripts_include.patch	2022-03-22 08:54:47.224464698 +0800
+++ b/target/linux/generic/hack-4.9/210-darwin_scripts_include.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,3065 +0,0 @@
-From db7c30dcd9a0391bf13b62c9f91e144d762ef43a Mon Sep 17 00:00:00 2001
-From: Florian Fainelli <f.fainelli@gmail.com>
-Date: Fri, 7 Jul 2017 17:00:49 +0200
-Subject: Add an OSX specific patch to make the kernel be compiled
-
-lede-commit: 3fc2a24f0422b2f55f9ed43f116db3111f700526
-Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
----
- scripts/kconfig/Makefile   |    3 +
- scripts/mod/elf.h          | 3007 ++++++++++++++++++++++++++++++++++++++++++++
- scripts/mod/mk_elfconfig.c |    4 +
- scripts/mod/modpost.h      |    4 +
- 4 files changed, 3018 insertions(+)
- create mode 100644 scripts/mod/elf.h
-
---- a/scripts/kconfig/Makefile
-+++ b/scripts/kconfig/Makefile
-@@ -163,6 +163,9 @@ check-lxdialog  := $(srctree)/$(src)/lxd
- # we really need to do so. (Do not call gcc as part of make mrproper)
- HOST_EXTRACFLAGS += $(shell $(CONFIG_SHELL) $(check-lxdialog) -ccflags) \
-                     -DLOCALE
-+ifeq ($(shell uname -s),Darwin)
-+HOST_LOADLIBES  += -lncurses
-+endif
- 
- # ===========================================================================
- # Shared Makefile for the various kconfig executables:
---- /dev/null
-+++ b/scripts/mod/elf.h
-@@ -0,0 +1,3007 @@
-+/* This file defines standard ELF types, structures, and macros.
-+   Copyright (C) 1995-2012 Free Software Foundation, Inc.
-+   This file is part of the GNU C Library.
-+
-+   The GNU C Library is free software; you can redistribute it and/or
-+   modify it under the terms of the GNU Lesser General Public
-+   License as published by the Free Software Foundation; either
-+   version 2.1 of the License, or (at your option) any later version.
-+
-+   The GNU C Library is distributed in the hope that it will be useful,
-+   but WITHOUT ANY WARRANTY; without even the implied warranty of
-+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-+   Lesser General Public License for more details.
-+
-+   You should have received a copy of the GNU Lesser General Public
-+   License along with the GNU C Library; if not, see
-+   <http://www.gnu.org/licenses/>.  */
-+
-+#ifndef _ELF_H
-+#define	_ELF_H 1
-+
-+/* Standard ELF types.  */
-+
-+#include <stdint.h>
-+
-+/* Type for a 16-bit quantity.  */
-+typedef uint16_t Elf32_Half;
-+typedef uint16_t Elf64_Half;
-+
-+/* Types for signed and unsigned 32-bit quantities.  */
-+typedef uint32_t Elf32_Word;
-+typedef	int32_t  Elf32_Sword;
-+typedef uint32_t Elf64_Word;
-+typedef	int32_t  Elf64_Sword;
-+
-+/* Types for signed and unsigned 64-bit quantities.  */
-+typedef uint64_t Elf32_Xword;
-+typedef	int64_t  Elf32_Sxword;
-+typedef uint64_t Elf64_Xword;
-+typedef	int64_t  Elf64_Sxword;
-+
-+/* Type of addresses.  */
-+typedef uint32_t Elf32_Addr;
-+typedef uint64_t Elf64_Addr;
-+
-+/* Type of file offsets.  */
-+typedef uint32_t Elf32_Off;
-+typedef uint64_t Elf64_Off;
-+
-+/* Type for section indices, which are 16-bit quantities.  */
-+typedef uint16_t Elf32_Section;
-+typedef uint16_t Elf64_Section;
-+
-+/* Type for version symbol information.  */
-+typedef Elf32_Half Elf32_Versym;
-+typedef Elf64_Half Elf64_Versym;
-+
-+
-+/* The ELF file header.  This appears at the start of every ELF file.  */
-+
-+#define EI_NIDENT (16)
-+
-+typedef struct
-+{
-+  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
-+  Elf32_Half	e_type;			/* Object file type */
-+  Elf32_Half	e_machine;		/* Architecture */
-+  Elf32_Word	e_version;		/* Object file version */
-+  Elf32_Addr	e_entry;		/* Entry point virtual address */
-+  Elf32_Off	e_phoff;		/* Program header table file offset */
-+  Elf32_Off	e_shoff;		/* Section header table file offset */
-+  Elf32_Word	e_flags;		/* Processor-specific flags */
-+  Elf32_Half	e_ehsize;		/* ELF header size in bytes */
-+  Elf32_Half	e_phentsize;		/* Program header table entry size */
-+  Elf32_Half	e_phnum;		/* Program header table entry count */
-+  Elf32_Half	e_shentsize;		/* Section header table entry size */
-+  Elf32_Half	e_shnum;		/* Section header table entry count */
-+  Elf32_Half	e_shstrndx;		/* Section header string table index */
-+} Elf32_Ehdr;
-+
-+typedef struct
-+{
-+  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
-+  Elf64_Half	e_type;			/* Object file type */
-+  Elf64_Half	e_machine;		/* Architecture */
-+  Elf64_Word	e_version;		/* Object file version */
-+  Elf64_Addr	e_entry;		/* Entry point virtual address */
-+  Elf64_Off	e_phoff;		/* Program header table file offset */
-+  Elf64_Off	e_shoff;		/* Section header table file offset */
-+  Elf64_Word	e_flags;		/* Processor-specific flags */
-+  Elf64_Half	e_ehsize;		/* ELF header size in bytes */
-+  Elf64_Half	e_phentsize;		/* Program header table entry size */
-+  Elf64_Half	e_phnum;		/* Program header table entry count */
-+  Elf64_Half	e_shentsize;		/* Section header table entry size */
-+  Elf64_Half	e_shnum;		/* Section header table entry count */
-+  Elf64_Half	e_shstrndx;		/* Section header string table index */
-+} Elf64_Ehdr;
-+
-+/* Fields in the e_ident array.  The EI_* macros are indices into the
-+   array.  The macros under each EI_* macro are the values the byte
-+   may have.  */
-+
-+#define EI_MAG0		0		/* File identification byte 0 index */
-+#define ELFMAG0		0x7f		/* Magic number byte 0 */
-+
-+#define EI_MAG1		1		/* File identification byte 1 index */
-+#define ELFMAG1		'E'		/* Magic number byte 1 */
-+
-+#define EI_MAG2		2		/* File identification byte 2 index */
-+#define ELFMAG2		'L'		/* Magic number byte 2 */
-+
-+#define EI_MAG3		3		/* File identification byte 3 index */
-+#define ELFMAG3		'F'		/* Magic number byte 3 */
-+
-+/* Conglomeration of the identification bytes, for easy testing as a word.  */
-+#define	ELFMAG		"\177ELF"
-+#define	SELFMAG		4
-+
-+#define EI_CLASS	4		/* File class byte index */
-+#define ELFCLASSNONE	0		/* Invalid class */
-+#define ELFCLASS32	1		/* 32-bit objects */
-+#define ELFCLASS64	2		/* 64-bit objects */
-+#define ELFCLASSNUM	3
-+
-+#define EI_DATA		5		/* Data encoding byte index */
-+#define ELFDATANONE	0		/* Invalid data encoding */
-+#define ELFDATA2LSB	1		/* 2's complement, little endian */
-+#define ELFDATA2MSB	2		/* 2's complement, big endian */
-+#define ELFDATANUM	3
-+
-+#define EI_VERSION	6		/* File version byte index */
-+					/* Value must be EV_CURRENT */
-+
-+#define EI_OSABI	7		/* OS ABI identification */
-+#define ELFOSABI_NONE		0	/* UNIX System V ABI */
-+#define ELFOSABI_SYSV		0	/* Alias.  */
-+#define ELFOSABI_HPUX		1	/* HP-UX */
-+#define ELFOSABI_NETBSD		2	/* NetBSD.  */
-+#define ELFOSABI_GNU		3	/* Object uses GNU ELF extensions.  */
-+#define ELFOSABI_LINUX		ELFOSABI_GNU /* Compatibility alias.  */
-+#define ELFOSABI_SOLARIS	6	/* Sun Solaris.  */
-+#define ELFOSABI_AIX		7	/* IBM AIX.  */
-+#define ELFOSABI_IRIX		8	/* SGI Irix.  */
-+#define ELFOSABI_FREEBSD	9	/* FreeBSD.  */
-+#define ELFOSABI_TRU64		10	/* Compaq TRU64 UNIX.  */
-+#define ELFOSABI_MODESTO	11	/* Novell Modesto.  */
-+#define ELFOSABI_OPENBSD	12	/* OpenBSD.  */
-+#define ELFOSABI_ARM_AEABI	64	/* ARM EABI */
-+#define ELFOSABI_ARM		97	/* ARM */
-+#define ELFOSABI_STANDALONE	255	/* Standalone (embedded) application */
-+
-+#define EI_ABIVERSION	8		/* ABI version */
-+
-+#define EI_PAD		9		/* Byte index of padding bytes */
-+
-+/* Legal values for e_type (object file type).  */
-+
-+#define ET_NONE		0		/* No file type */
-+#define ET_REL		1		/* Relocatable file */
-+#define ET_EXEC		2		/* Executable file */
-+#define ET_DYN		3		/* Shared object file */
-+#define ET_CORE		4		/* Core file */
-+#define	ET_NUM		5		/* Number of defined types */
-+#define ET_LOOS		0xfe00		/* OS-specific range start */
-+#define ET_HIOS		0xfeff		/* OS-specific range end */
-+#define ET_LOPROC	0xff00		/* Processor-specific range start */
-+#define ET_HIPROC	0xffff		/* Processor-specific range end */
-+
-+/* Legal values for e_machine (architecture).  */
-+
-+#define EM_NONE		 0		/* No machine */
-+#define EM_M32		 1		/* AT&T WE 32100 */
-+#define EM_SPARC	 2		/* SUN SPARC */
-+#define EM_386		 3		/* Intel 80386 */
-+#define EM_68K		 4		/* Motorola m68k family */
-+#define EM_88K		 5		/* Motorola m88k family */
-+#define EM_860		 7		/* Intel 80860 */
-+#define EM_MIPS		 8		/* MIPS R3000 big-endian */
-+#define EM_S370		 9		/* IBM System/370 */
-+#define EM_MIPS_RS3_LE	10		/* MIPS R3000 little-endian */
-+
-+#define EM_PARISC	15		/* HPPA */
-+#define EM_VPP500	17		/* Fujitsu VPP500 */
-+#define EM_SPARC32PLUS	18		/* Sun's "v8plus" */
-+#define EM_960		19		/* Intel 80960 */
-+#define EM_PPC		20		/* PowerPC */
-+#define EM_PPC64	21		/* PowerPC 64-bit */
-+#define EM_S390		22		/* IBM S390 */
-+
-+#define EM_V800		36		/* NEC V800 series */
-+#define EM_FR20		37		/* Fujitsu FR20 */
-+#define EM_RH32		38		/* TRW RH-32 */
-+#define EM_RCE		39		/* Motorola RCE */
-+#define EM_ARM		40		/* ARM */
-+#define EM_FAKE_ALPHA	41		/* Digital Alpha */
-+#define EM_SH		42		/* Hitachi SH */
-+#define EM_SPARCV9	43		/* SPARC v9 64-bit */
-+#define EM_TRICORE	44		/* Siemens Tricore */
-+#define EM_ARC		45		/* Argonaut RISC Core */
-+#define EM_H8_300	46		/* Hitachi H8/300 */
-+#define EM_H8_300H	47		/* Hitachi H8/300H */
-+#define EM_H8S		48		/* Hitachi H8S */
-+#define EM_H8_500	49		/* Hitachi H8/500 */
-+#define EM_IA_64	50		/* Intel Merced */
-+#define EM_MIPS_X	51		/* Stanford MIPS-X */
-+#define EM_COLDFIRE	52		/* Motorola Coldfire */
-+#define EM_68HC12	53		/* Motorola M68HC12 */
-+#define EM_MMA		54		/* Fujitsu MMA Multimedia Accelerator*/
-+#define EM_PCP		55		/* Siemens PCP */
-+#define EM_NCPU		56		/* Sony nCPU embeeded RISC */
-+#define EM_NDR1		57		/* Denso NDR1 microprocessor */
-+#define EM_STARCORE	58		/* Motorola Start*Core processor */
-+#define EM_ME16		59		/* Toyota ME16 processor */
-+#define EM_ST100	60		/* STMicroelectronic ST100 processor */
-+#define EM_TINYJ	61		/* Advanced Logic Corp. Tinyj emb.fam*/
-+#define EM_X86_64	62		/* AMD x86-64 architecture */
-+#define EM_PDSP		63		/* Sony DSP Processor */
-+
-+#define EM_FX66		66		/* Siemens FX66 microcontroller */
-+#define EM_ST9PLUS	67		/* STMicroelectronics ST9+ 8/16 mc */
-+#define EM_ST7		68		/* STmicroelectronics ST7 8 bit mc */
-+#define EM_68HC16	69		/* Motorola MC68HC16 microcontroller */
-+#define EM_68HC11	70		/* Motorola MC68HC11 microcontroller */
-+#define EM_68HC08	71		/* Motorola MC68HC08 microcontroller */
-+#define EM_68HC05	72		/* Motorola MC68HC05 microcontroller */
-+#define EM_SVX		73		/* Silicon Graphics SVx */
-+#define EM_ST19		74		/* STMicroelectronics ST19 8 bit mc */
-+#define EM_VAX		75		/* Digital VAX */
-+#define EM_CRIS		76		/* Axis Communications 32-bit embedded processor */
-+#define EM_JAVELIN	77		/* Infineon Technologies 32-bit embedded processor */
-+#define EM_FIREPATH	78		/* Element 14 64-bit DSP Processor */
-+#define EM_ZSP		79		/* LSI Logic 16-bit DSP Processor */
-+#define EM_MMIX		80		/* Donald Knuth's educational 64-bit processor */
-+#define EM_HUANY	81		/* Harvard University machine-independent object files */
-+#define EM_PRISM	82		/* SiTera Prism */
-+#define EM_AVR		83		/* Atmel AVR 8-bit microcontroller */
-+#define EM_FR30		84		/* Fujitsu FR30 */
-+#define EM_D10V		85		/* Mitsubishi D10V */
-+#define EM_D30V		86		/* Mitsubishi D30V */
-+#define EM_V850		87		/* NEC v850 */
-+#define EM_M32R		88		/* Mitsubishi M32R */
-+#define EM_MN10300	89		/* Matsushita MN10300 */
-+#define EM_MN10200	90		/* Matsushita MN10200 */
-+#define EM_PJ		91		/* picoJava */
-+#define EM_OPENRISC	92		/* OpenRISC 32-bit embedded processor */
-+#define EM_ARC_A5	93		/* ARC Cores Tangent-A5 */
-+#define EM_XTENSA	94		/* Tensilica Xtensa Architecture */
-+#define EM_TILEPRO	188		/* Tilera TILEPro */
-+#define EM_TILEGX	191		/* Tilera TILE-Gx */
-+#define EM_NUM		192
-+
-+/* If it is necessary to assign new unofficial EM_* values, please
-+   pick large random numbers (0x8523, 0xa7f2, etc.) to minimize the
-+   chances of collision with official or non-GNU unofficial values.  */
-+
-+#define EM_ALPHA	0x9026
-+
-+/* Legal values for e_version (version).  */
-+
-+#define EV_NONE		0		/* Invalid ELF version */
-+#define EV_CURRENT	1		/* Current version */
-+#define EV_NUM		2
-+
-+/* Section header.  */
-+
-+typedef struct
-+{
-+  Elf32_Word	sh_name;		/* Section name (string tbl index) */
-+  Elf32_Word	sh_type;		/* Section type */
-+  Elf32_Word	sh_flags;		/* Section flags */
-+  Elf32_Addr	sh_addr;		/* Section virtual addr at execution */
-+  Elf32_Off	sh_offset;		/* Section file offset */
-+  Elf32_Word	sh_size;		/* Section size in bytes */
-+  Elf32_Word	sh_link;		/* Link to another section */
-+  Elf32_Word	sh_info;		/* Additional section information */
-+  Elf32_Word	sh_addralign;		/* Section alignment */
-+  Elf32_Word	sh_entsize;		/* Entry size if section holds table */
-+} Elf32_Shdr;
-+
-+typedef struct
-+{
-+  Elf64_Word	sh_name;		/* Section name (string tbl index) */
-+  Elf64_Word	sh_type;		/* Section type */
-+  Elf64_Xword	sh_flags;		/* Section flags */
-+  Elf64_Addr	sh_addr;		/* Section virtual addr at execution */
-+  Elf64_Off	sh_offset;		/* Section file offset */
-+  Elf64_Xword	sh_size;		/* Section size in bytes */
-+  Elf64_Word	sh_link;		/* Link to another section */
-+  Elf64_Word	sh_info;		/* Additional section information */
-+  Elf64_Xword	sh_addralign;		/* Section alignment */
-+  Elf64_Xword	sh_entsize;		/* Entry size if section holds table */
-+} Elf64_Shdr;
-+
-+/* Special section indices.  */
-+
-+#define SHN_UNDEF	0		/* Undefined section */
-+#define SHN_LORESERVE	0xff00		/* Start of reserved indices */
-+#define SHN_LOPROC	0xff00		/* Start of processor-specific */
-+#define SHN_BEFORE	0xff00		/* Order section before all others
-+					   (Solaris).  */
-+#define SHN_AFTER	0xff01		/* Order section after all others
-+					   (Solaris).  */
-+#define SHN_HIPROC	0xff1f		/* End of processor-specific */
-+#define SHN_LOOS	0xff20		/* Start of OS-specific */
-+#define SHN_HIOS	0xff3f		/* End of OS-specific */
-+#define SHN_ABS		0xfff1		/* Associated symbol is absolute */
-+#define SHN_COMMON	0xfff2		/* Associated symbol is common */
-+#define SHN_XINDEX	0xffff		/* Index is in extra table.  */
-+#define SHN_HIRESERVE	0xffff		/* End of reserved indices */
-+
-+/* Legal values for sh_type (section type).  */
-+
-+#define SHT_NULL	  0		/* Section header table entry unused */
-+#define SHT_PROGBITS	  1		/* Program data */
-+#define SHT_SYMTAB	  2		/* Symbol table */
-+#define SHT_STRTAB	  3		/* String table */
-+#define SHT_RELA	  4		/* Relocation entries with addends */
-+#define SHT_HASH	  5		/* Symbol hash table */
-+#define SHT_DYNAMIC	  6		/* Dynamic linking information */
-+#define SHT_NOTE	  7		/* Notes */
-+#define SHT_NOBITS	  8		/* Program space with no data (bss) */
-+#define SHT_REL		  9		/* Relocation entries, no addends */
-+#define SHT_SHLIB	  10		/* Reserved */
-+#define SHT_DYNSYM	  11		/* Dynamic linker symbol table */
-+#define SHT_INIT_ARRAY	  14		/* Array of constructors */
-+#define SHT_FINI_ARRAY	  15		/* Array of destructors */
-+#define SHT_PREINIT_ARRAY 16		/* Array of pre-constructors */
-+#define SHT_GROUP	  17		/* Section group */
-+#define SHT_SYMTAB_SHNDX  18		/* Extended section indeces */
-+#define	SHT_NUM		  19		/* Number of defined types.  */
-+#define SHT_LOOS	  0x60000000	/* Start OS-specific.  */
-+#define SHT_GNU_ATTRIBUTES 0x6ffffff5	/* Object attributes.  */
-+#define SHT_GNU_HASH	  0x6ffffff6	/* GNU-style hash table.  */
-+#define SHT_GNU_LIBLIST	  0x6ffffff7	/* Prelink library list */
-+#define SHT_CHECKSUM	  0x6ffffff8	/* Checksum for DSO content.  */
-+#define SHT_LOSUNW	  0x6ffffffa	/* Sun-specific low bound.  */
-+#define SHT_SUNW_move	  0x6ffffffa
-+#define SHT_SUNW_COMDAT   0x6ffffffb
-+#define SHT_SUNW_syminfo  0x6ffffffc
-+#define SHT_GNU_verdef	  0x6ffffffd	/* Version definition section.  */
-+#define SHT_GNU_verneed	  0x6ffffffe	/* Version needs section.  */
-+#define SHT_GNU_versym	  0x6fffffff	/* Version symbol table.  */
-+#define SHT_HISUNW	  0x6fffffff	/* Sun-specific high bound.  */
-+#define SHT_HIOS	  0x6fffffff	/* End OS-specific type */
-+#define SHT_LOPROC	  0x70000000	/* Start of processor-specific */
-+#define SHT_HIPROC	  0x7fffffff	/* End of processor-specific */
-+#define SHT_LOUSER	  0x80000000	/* Start of application-specific */
-+#define SHT_HIUSER	  0x8fffffff	/* End of application-specific */
-+
-+/* Legal values for sh_flags (section flags).  */
-+
-+#define SHF_WRITE	     (1 << 0)	/* Writable */
-+#define SHF_ALLOC	     (1 << 1)	/* Occupies memory during execution */
-+#define SHF_EXECINSTR	     (1 << 2)	/* Executable */
-+#define SHF_MERGE	     (1 << 4)	/* Might be merged */
-+#define SHF_STRINGS	     (1 << 5)	/* Contains nul-terminated strings */
-+#define SHF_INFO_LINK	     (1 << 6)	/* `sh_info' contains SHT index */
-+#define SHF_LINK_ORDER	     (1 << 7)	/* Preserve order after combining */
-+#define SHF_OS_NONCONFORMING (1 << 8)	/* Non-standard OS specific handling
-+					   required */
-+#define SHF_GROUP	     (1 << 9)	/* Section is member of a group.  */
-+#define SHF_TLS		     (1 << 10)	/* Section hold thread-local data.  */
-+#define SHF_MASKOS	     0x0ff00000	/* OS-specific.  */
-+#define SHF_MASKPROC	     0xf0000000	/* Processor-specific */
-+#define SHF_ORDERED	     (1 << 30)	/* Special ordering requirement
-+					   (Solaris).  */
-+#define SHF_EXCLUDE	     (1 << 31)	/* Section is excluded unless
-+					   referenced or allocated (Solaris).*/
-+
-+/* Section group handling.  */
-+#define GRP_COMDAT	0x1		/* Mark group as COMDAT.  */
-+
-+/* Symbol table entry.  */
-+
-+typedef struct
-+{
-+  Elf32_Word	st_name;		/* Symbol name (string tbl index) */
-+  Elf32_Addr	st_value;		/* Symbol value */
-+  Elf32_Word	st_size;		/* Symbol size */
-+  unsigned char	st_info;		/* Symbol type and binding */
-+  unsigned char	st_other;		/* Symbol visibility */
-+  Elf32_Section	st_shndx;		/* Section index */
-+} Elf32_Sym;
-+
-+typedef struct
-+{
-+  Elf64_Word	st_name;		/* Symbol name (string tbl index) */
-+  unsigned char	st_info;		/* Symbol type and binding */
-+  unsigned char st_other;		/* Symbol visibility */
-+  Elf64_Section	st_shndx;		/* Section index */
-+  Elf64_Addr	st_value;		/* Symbol value */
-+  Elf64_Xword	st_size;		/* Symbol size */
-+} Elf64_Sym;
-+
-+/* The syminfo section if available contains additional information about
-+   every dynamic symbol.  */
-+
-+typedef struct
-+{
-+  Elf32_Half si_boundto;		/* Direct bindings, symbol bound to */
-+  Elf32_Half si_flags;			/* Per symbol flags */
-+} Elf32_Syminfo;
-+
-+typedef struct
-+{
-+  Elf64_Half si_boundto;		/* Direct bindings, symbol bound to */
-+  Elf64_Half si_flags;			/* Per symbol flags */
-+} Elf64_Syminfo;
-+
-+/* Possible values for si_boundto.  */
-+#define SYMINFO_BT_SELF		0xffff	/* Symbol bound to self */
-+#define SYMINFO_BT_PARENT	0xfffe	/* Symbol bound to parent */
-+#define SYMINFO_BT_LOWRESERVE	0xff00	/* Beginning of reserved entries */
-+
-+/* Possible bitmasks for si_flags.  */
-+#define SYMINFO_FLG_DIRECT	0x0001	/* Direct bound symbol */
-+#define SYMINFO_FLG_PASSTHRU	0x0002	/* Pass-thru symbol for translator */
-+#define SYMINFO_FLG_COPY	0x0004	/* Symbol is a copy-reloc */
-+#define SYMINFO_FLG_LAZYLOAD	0x0008	/* Symbol bound to object to be lazy
-+					   loaded */
-+/* Syminfo version values.  */
-+#define SYMINFO_NONE		0
-+#define SYMINFO_CURRENT		1
-+#define SYMINFO_NUM		2
-+
-+
-+/* How to extract and insert information held in the st_info field.  */
-+
-+#define ELF32_ST_BIND(val)		(((unsigned char) (val)) >> 4)
-+#define ELF32_ST_TYPE(val)		((val) & 0xf)
-+#define ELF32_ST_INFO(bind, type)	(((bind) << 4) + ((type) & 0xf))
-+
-+/* Both Elf32_Sym and Elf64_Sym use the same one-byte st_info field.  */
-+#define ELF64_ST_BIND(val)		ELF32_ST_BIND (val)
-+#define ELF64_ST_TYPE(val)		ELF32_ST_TYPE (val)
-+#define ELF64_ST_INFO(bind, type)	ELF32_ST_INFO ((bind), (type))
-+
-+/* Legal values for ST_BIND subfield of st_info (symbol binding).  */
-+
-+#define STB_LOCAL	0		/* Local symbol */
-+#define STB_GLOBAL	1		/* Global symbol */
-+#define STB_WEAK	2		/* Weak symbol */
-+#define	STB_NUM		3		/* Number of defined types.  */
-+#define STB_LOOS	10		/* Start of OS-specific */
-+#define STB_GNU_UNIQUE	10		/* Unique symbol.  */
-+#define STB_HIOS	12		/* End of OS-specific */
-+#define STB_LOPROC	13		/* Start of processor-specific */
-+#define STB_HIPROC	15		/* End of processor-specific */
-+
-+/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
-+
-+#define STT_NOTYPE	0		/* Symbol type is unspecified */
-+#define STT_OBJECT	1		/* Symbol is a data object */
-+#define STT_FUNC	2		/* Symbol is a code object */
-+#define STT_SECTION	3		/* Symbol associated with a section */
-+#define STT_FILE	4		/* Symbol's name is file name */
-+#define STT_COMMON	5		/* Symbol is a common data object */
-+#define STT_TLS		6		/* Symbol is thread-local data object*/
-+#define	STT_NUM		7		/* Number of defined types.  */
-+#define STT_LOOS	10		/* Start of OS-specific */
-+#define STT_GNU_IFUNC	10		/* Symbol is indirect code object */
-+#define STT_HIOS	12		/* End of OS-specific */
-+#define STT_LOPROC	13		/* Start of processor-specific */
-+#define STT_HIPROC	15		/* End of processor-specific */
-+
-+
-+/* Symbol table indices are found in the hash buckets and chain table
-+   of a symbol hash table section.  This special index value indicates
-+   the end of a chain, meaning no further symbols are found in that bucket.  */
-+
-+#define STN_UNDEF	0		/* End of a chain.  */
-+
-+
-+/* How to extract and insert information held in the st_other field.  */
-+
-+#define ELF32_ST_VISIBILITY(o)	((o) & 0x03)
-+
-+/* For ELF64 the definitions are the same.  */
-+#define ELF64_ST_VISIBILITY(o)	ELF32_ST_VISIBILITY (o)
-+
-+/* Symbol visibility specification encoded in the st_other field.  */
-+#define STV_DEFAULT	0		/* Default symbol visibility rules */
-+#define STV_INTERNAL	1		/* Processor specific hidden class */
-+#define STV_HIDDEN	2		/* Sym unavailable in other modules */
-+#define STV_PROTECTED	3		/* Not preemptible, not exported */
-+
-+
-+/* Relocation table entry without addend (in section of type SHT_REL).  */
-+
-+typedef struct
-+{
-+  Elf32_Addr	r_offset;		/* Address */
-+  Elf32_Word	r_info;			/* Relocation type and symbol index */
-+} Elf32_Rel;
-+
-+/* I have seen two different definitions of the Elf64_Rel and
-+   Elf64_Rela structures, so we'll leave them out until Novell (or
-+   whoever) gets their act together.  */
-+/* The following, at least, is used on Sparc v9, MIPS, and Alpha.  */
-+
-+typedef struct
-+{
-+  Elf64_Addr	r_offset;		/* Address */
-+  Elf64_Xword	r_info;			/* Relocation type and symbol index */
-+} Elf64_Rel;
-+
-+/* Relocation table entry with addend (in section of type SHT_RELA).  */
-+
-+typedef struct
-+{
-+  Elf32_Addr	r_offset;		/* Address */
-+  Elf32_Word	r_info;			/* Relocation type and symbol index */
-+  Elf32_Sword	r_addend;		/* Addend */
-+} Elf32_Rela;
-+
-+typedef struct
-+{
-+  Elf64_Addr	r_offset;		/* Address */
-+  Elf64_Xword	r_info;			/* Relocation type and symbol index */
-+  Elf64_Sxword	r_addend;		/* Addend */
-+} Elf64_Rela;
-+
-+/* How to extract and insert information held in the r_info field.  */
-+
-+#define ELF32_R_SYM(val)		((val) >> 8)
-+#define ELF32_R_TYPE(val)		((val) & 0xff)
-+#define ELF32_R_INFO(sym, type)		(((sym) << 8) + ((type) & 0xff))
-+
-+#define ELF64_R_SYM(i)			((i) >> 32)
-+#define ELF64_R_TYPE(i)			((i) & 0xffffffff)
-+#define ELF64_R_INFO(sym,type)		((((Elf64_Xword) (sym)) << 32) + (type))
-+
-+/* Program segment header.  */
-+
-+typedef struct
-+{
-+  Elf32_Word	p_type;			/* Segment type */
-+  Elf32_Off	p_offset;		/* Segment file offset */
-+  Elf32_Addr	p_vaddr;		/* Segment virtual address */
-+  Elf32_Addr	p_paddr;		/* Segment physical address */
-+  Elf32_Word	p_filesz;		/* Segment size in file */
-+  Elf32_Word	p_memsz;		/* Segment size in memory */
-+  Elf32_Word	p_flags;		/* Segment flags */
-+  Elf32_Word	p_align;		/* Segment alignment */
-+} Elf32_Phdr;
-+
-+typedef struct
-+{
-+  Elf64_Word	p_type;			/* Segment type */
-+  Elf64_Word	p_flags;		/* Segment flags */
-+  Elf64_Off	p_offset;		/* Segment file offset */
-+  Elf64_Addr	p_vaddr;		/* Segment virtual address */
-+  Elf64_Addr	p_paddr;		/* Segment physical address */
-+  Elf64_Xword	p_filesz;		/* Segment size in file */
-+  Elf64_Xword	p_memsz;		/* Segment size in memory */
-+  Elf64_Xword	p_align;		/* Segment alignment */
-+} Elf64_Phdr;
-+
-+/* Special value for e_phnum.  This indicates that the real number of
-+   program headers is too large to fit into e_phnum.  Instead the real
-+   value is in the field sh_info of section 0.  */
-+
-+#define PN_XNUM		0xffff
-+
-+/* Legal values for p_type (segment type).  */
-+
-+#define	PT_NULL		0		/* Program header table entry unused */
-+#define PT_LOAD		1		/* Loadable program segment */
-+#define PT_DYNAMIC	2		/* Dynamic linking information */
-+#define PT_INTERP	3		/* Program interpreter */
-+#define PT_NOTE		4		/* Auxiliary information */
-+#define PT_SHLIB	5		/* Reserved */
-+#define PT_PHDR		6		/* Entry for header table itself */
-+#define PT_TLS		7		/* Thread-local storage segment */
-+#define	PT_NUM		8		/* Number of defined types */
-+#define PT_LOOS		0x60000000	/* Start of OS-specific */
-+#define PT_GNU_EH_FRAME	0x6474e550	/* GCC .eh_frame_hdr segment */
-+#define PT_GNU_STACK	0x6474e551	/* Indicates stack executability */
-+#define PT_GNU_RELRO	0x6474e552	/* Read-only after relocation */
-+#define PT_LOSUNW	0x6ffffffa
-+#define PT_SUNWBSS	0x6ffffffa	/* Sun Specific segment */
-+#define PT_SUNWSTACK	0x6ffffffb	/* Stack segment */
-+#define PT_HISUNW	0x6fffffff
-+#define PT_HIOS		0x6fffffff	/* End of OS-specific */
-+#define PT_LOPROC	0x70000000	/* Start of processor-specific */
-+#define PT_HIPROC	0x7fffffff	/* End of processor-specific */
-+
-+/* Legal values for p_flags (segment flags).  */
-+
-+#define PF_X		(1 << 0)	/* Segment is executable */
-+#define PF_W		(1 << 1)	/* Segment is writable */
-+#define PF_R		(1 << 2)	/* Segment is readable */
-+#define PF_MASKOS	0x0ff00000	/* OS-specific */
-+#define PF_MASKPROC	0xf0000000	/* Processor-specific */
-+
-+/* Legal values for note segment descriptor types for core files. */
-+
-+#define NT_PRSTATUS	1		/* Contains copy of prstatus struct */
-+#define NT_FPREGSET	2		/* Contains copy of fpregset struct */
-+#define NT_PRPSINFO	3		/* Contains copy of prpsinfo struct */
-+#define NT_PRXREG	4		/* Contains copy of prxregset struct */
-+#define NT_TASKSTRUCT	4		/* Contains copy of task structure */
-+#define NT_PLATFORM	5		/* String from sysinfo(SI_PLATFORM) */
-+#define NT_AUXV		6		/* Contains copy of auxv array */
-+#define NT_GWINDOWS	7		/* Contains copy of gwindows struct */
-+#define NT_ASRS		8		/* Contains copy of asrset struct */
-+#define NT_PSTATUS	10		/* Contains copy of pstatus struct */
-+#define NT_PSINFO	13		/* Contains copy of psinfo struct */
-+#define NT_PRCRED	14		/* Contains copy of prcred struct */
-+#define NT_UTSNAME	15		/* Contains copy of utsname struct */
-+#define NT_LWPSTATUS	16		/* Contains copy of lwpstatus struct */
-+#define NT_LWPSINFO	17		/* Contains copy of lwpinfo struct */
-+#define NT_PRFPXREG	20		/* Contains copy of fprxregset struct */
-+#define NT_PRXFPREG	0x46e62b7f	/* Contains copy of user_fxsr_struct */
-+#define NT_PPC_VMX	0x100		/* PowerPC Altivec/VMX registers */
-+#define NT_PPC_SPE	0x101		/* PowerPC SPE/EVR registers */
-+#define NT_PPC_VSX	0x102		/* PowerPC VSX registers */
-+#define NT_386_TLS	0x200		/* i386 TLS slots (struct user_desc) */
-+#define NT_386_IOPERM	0x201		/* x86 io permission bitmap (1=deny) */
-+#define NT_X86_XSTATE	0x202		/* x86 extended state using xsave */
-+
-+/* Legal values for the note segment descriptor types for object files.  */
-+
-+#define NT_VERSION	1		/* Contains a version string.  */
-+
-+
-+/* Dynamic section entry.  */
-+
-+typedef struct
-+{
-+  Elf32_Sword	d_tag;			/* Dynamic entry type */
-+  union
-+    {
-+      Elf32_Word d_val;			/* Integer value */
-+      Elf32_Addr d_ptr;			/* Address value */
-+    } d_un;
-+} Elf32_Dyn;
-+
-+typedef struct
-+{
-+  Elf64_Sxword	d_tag;			/* Dynamic entry type */
-+  union
-+    {
-+      Elf64_Xword d_val;		/* Integer value */
-+      Elf64_Addr d_ptr;			/* Address value */
-+    } d_un;
-+} Elf64_Dyn;
-+
-+/* Legal values for d_tag (dynamic entry type).  */
-+
-+#define DT_NULL		0		/* Marks end of dynamic section */
-+#define DT_NEEDED	1		/* Name of needed library */
-+#define DT_PLTRELSZ	2		/* Size in bytes of PLT relocs */
-+#define DT_PLTGOT	3		/* Processor defined value */
-+#define DT_HASH		4		/* Address of symbol hash table */
-+#define DT_STRTAB	5		/* Address of string table */
-+#define DT_SYMTAB	6		/* Address of symbol table */
-+#define DT_RELA		7		/* Address of Rela relocs */
-+#define DT_RELASZ	8		/* Total size of Rela relocs */
-+#define DT_RELAENT	9		/* Size of one Rela reloc */
-+#define DT_STRSZ	10		/* Size of string table */
-+#define DT_SYMENT	11		/* Size of one symbol table entry */
-+#define DT_INIT		12		/* Address of init function */
-+#define DT_FINI		13		/* Address of termination function */
-+#define DT_SONAME	14		/* Name of shared object */
-+#define DT_RPATH	15		/* Library search path (deprecated) */
-+#define DT_SYMBOLIC	16		/* Start symbol search here */
-+#define DT_REL		17		/* Address of Rel relocs */
-+#define DT_RELSZ	18		/* Total size of Rel relocs */
-+#define DT_RELENT	19		/* Size of one Rel reloc */
-+#define DT_PLTREL	20		/* Type of reloc in PLT */
-+#define DT_DEBUG	21		/* For debugging; unspecified */
-+#define DT_TEXTREL	22		/* Reloc might modify .text */
-+#define DT_JMPREL	23		/* Address of PLT relocs */
-+#define	DT_BIND_NOW	24		/* Process relocations of object */
-+#define	DT_INIT_ARRAY	25		/* Array with addresses of init fct */
-+#define	DT_FINI_ARRAY	26		/* Array with addresses of fini fct */
-+#define	DT_INIT_ARRAYSZ	27		/* Size in bytes of DT_INIT_ARRAY */
-+#define	DT_FINI_ARRAYSZ	28		/* Size in bytes of DT_FINI_ARRAY */
-+#define DT_RUNPATH	29		/* Library search path */
-+#define DT_FLAGS	30		/* Flags for the object being loaded */
-+#define DT_ENCODING	32		/* Start of encoded range */
-+#define DT_PREINIT_ARRAY 32		/* Array with addresses of preinit fct*/
-+#define DT_PREINIT_ARRAYSZ 33		/* size in bytes of DT_PREINIT_ARRAY */
-+#define	DT_NUM		34		/* Number used */
-+#define DT_LOOS		0x6000000d	/* Start of OS-specific */
-+#define DT_HIOS		0x6ffff000	/* End of OS-specific */
-+#define DT_LOPROC	0x70000000	/* Start of processor-specific */
-+#define DT_HIPROC	0x7fffffff	/* End of processor-specific */
-+#define	DT_PROCNUM	DT_MIPS_NUM	/* Most used by any processor */
-+
-+/* DT_* entries which fall between DT_VALRNGHI & DT_VALRNGLO use the
-+   Dyn.d_un.d_val field of the Elf*_Dyn structure.  This follows Sun's
-+   approach.  */
-+#define DT_VALRNGLO	0x6ffffd00
-+#define DT_GNU_PRELINKED 0x6ffffdf5	/* Prelinking timestamp */
-+#define DT_GNU_CONFLICTSZ 0x6ffffdf6	/* Size of conflict section */
-+#define DT_GNU_LIBLISTSZ 0x6ffffdf7	/* Size of library list */
-+#define DT_CHECKSUM	0x6ffffdf8
-+#define DT_PLTPADSZ	0x6ffffdf9
-+#define DT_MOVEENT	0x6ffffdfa
-+#define DT_MOVESZ	0x6ffffdfb
-+#define DT_FEATURE_1	0x6ffffdfc	/* Feature selection (DTF_*).  */
-+#define DT_POSFLAG_1	0x6ffffdfd	/* Flags for DT_* entries, effecting
-+					   the following DT_* entry.  */
-+#define DT_SYMINSZ	0x6ffffdfe	/* Size of syminfo table (in bytes) */
-+#define DT_SYMINENT	0x6ffffdff	/* Entry size of syminfo */
-+#define DT_VALRNGHI	0x6ffffdff
-+#define DT_VALTAGIDX(tag)	(DT_VALRNGHI - (tag))	/* Reverse order! */
-+#define DT_VALNUM 12
-+
-+/* DT_* entries which fall between DT_ADDRRNGHI & DT_ADDRRNGLO use the
-+   Dyn.d_un.d_ptr field of the Elf*_Dyn structure.
-+
-+   If any adjustment is made to the ELF object after it has been
-+   built these entries will need to be adjusted.  */
-+#define DT_ADDRRNGLO	0x6ffffe00
-+#define DT_GNU_HASH	0x6ffffef5	/* GNU-style hash table.  */
-+#define DT_TLSDESC_PLT	0x6ffffef6
-+#define DT_TLSDESC_GOT	0x6ffffef7
-+#define DT_GNU_CONFLICT	0x6ffffef8	/* Start of conflict section */
-+#define DT_GNU_LIBLIST	0x6ffffef9	/* Library list */
-+#define DT_CONFIG	0x6ffffefa	/* Configuration information.  */
-+#define DT_DEPAUDIT	0x6ffffefb	/* Dependency auditing.  */
-+#define DT_AUDIT	0x6ffffefc	/* Object auditing.  */
-+#define	DT_PLTPAD	0x6ffffefd	/* PLT padding.  */
-+#define	DT_MOVETAB	0x6ffffefe	/* Move table.  */
-+#define DT_SYMINFO	0x6ffffeff	/* Syminfo table.  */
-+#define DT_ADDRRNGHI	0x6ffffeff
-+#define DT_ADDRTAGIDX(tag)	(DT_ADDRRNGHI - (tag))	/* Reverse order! */
-+#define DT_ADDRNUM 11
-+
-+/* The versioning entry types.  The next are defined as part of the
-+   GNU extension.  */
-+#define DT_VERSYM	0x6ffffff0
-+
-+#define DT_RELACOUNT	0x6ffffff9
-+#define DT_RELCOUNT	0x6ffffffa
-+
-+/* These were chosen by Sun.  */
-+#define DT_FLAGS_1	0x6ffffffb	/* State flags, see DF_1_* below.  */
-+#define	DT_VERDEF	0x6ffffffc	/* Address of version definition
-+					   table */
-+#define	DT_VERDEFNUM	0x6ffffffd	/* Number of version definitions */
-+#define	DT_VERNEED	0x6ffffffe	/* Address of table with needed
-+					   versions */
-+#define	DT_VERNEEDNUM	0x6fffffff	/* Number of needed versions */
-+#define DT_VERSIONTAGIDX(tag)	(DT_VERNEEDNUM - (tag))	/* Reverse order! */
-+#define DT_VERSIONTAGNUM 16
-+
-+/* Sun added these machine-independent extensions in the "processor-specific"
-+   range.  Be compatible.  */
-+#define DT_AUXILIARY    0x7ffffffd      /* Shared object to load before self */
-+#define DT_FILTER       0x7fffffff      /* Shared object to get values from */
-+#define DT_EXTRATAGIDX(tag)	((Elf32_Word)-((Elf32_Sword) (tag) <<1>>1)-1)
-+#define DT_EXTRANUM	3
-+
-+/* Values of `d_un.d_val' in the DT_FLAGS entry.  */
-+#define DF_ORIGIN	0x00000001	/* Object may use DF_ORIGIN */
-+#define DF_SYMBOLIC	0x00000002	/* Symbol resolutions starts here */
-+#define DF_TEXTREL	0x00000004	/* Object contains text relocations */
-+#define DF_BIND_NOW	0x00000008	/* No lazy binding for this object */
-+#define DF_STATIC_TLS	0x00000010	/* Module uses the static TLS model */
-+
-+/* State flags selectable in the `d_un.d_val' element of the DT_FLAGS_1
-+   entry in the dynamic section.  */
-+#define DF_1_NOW	0x00000001	/* Set RTLD_NOW for this object.  */
-+#define DF_1_GLOBAL	0x00000002	/* Set RTLD_GLOBAL for this object.  */
-+#define DF_1_GROUP	0x00000004	/* Set RTLD_GROUP for this object.  */
-+#define DF_1_NODELETE	0x00000008	/* Set RTLD_NODELETE for this object.*/
-+#define DF_1_LOADFLTR	0x00000010	/* Trigger filtee loading at runtime.*/
-+#define DF_1_INITFIRST	0x00000020	/* Set RTLD_INITFIRST for this object*/
-+#define DF_1_NOOPEN	0x00000040	/* Set RTLD_NOOPEN for this object.  */
-+#define DF_1_ORIGIN	0x00000080	/* $ORIGIN must be handled.  */
-+#define DF_1_DIRECT	0x00000100	/* Direct binding enabled.  */
-+#define DF_1_TRANS	0x00000200
-+#define DF_1_INTERPOSE	0x00000400	/* Object is used to interpose.  */
-+#define DF_1_NODEFLIB	0x00000800	/* Ignore default lib search path.  */
-+#define DF_1_NODUMP	0x00001000	/* Object can't be dldump'ed.  */
-+#define DF_1_CONFALT	0x00002000	/* Configuration alternative created.*/
-+#define DF_1_ENDFILTEE	0x00004000	/* Filtee terminates filters search. */
-+#define	DF_1_DISPRELDNE	0x00008000	/* Disp reloc applied at build time. */
-+#define	DF_1_DISPRELPND	0x00010000	/* Disp reloc applied at run-time.  */
-+
-+/* Flags for the feature selection in DT_FEATURE_1.  */
-+#define DTF_1_PARINIT	0x00000001
-+#define DTF_1_CONFEXP	0x00000002
-+
-+/* Flags in the DT_POSFLAG_1 entry effecting only the next DT_* entry.  */
-+#define DF_P1_LAZYLOAD	0x00000001	/* Lazyload following object.  */
-+#define DF_P1_GROUPPERM	0x00000002	/* Symbols from next object are not
-+					   generally available.  */
-+
-+/* Version definition sections.  */
-+
-+typedef struct
-+{
-+  Elf32_Half	vd_version;		/* Version revision */
-+  Elf32_Half	vd_flags;		/* Version information */
-+  Elf32_Half	vd_ndx;			/* Version Index */
-+  Elf32_Half	vd_cnt;			/* Number of associated aux entries */
-+  Elf32_Word	vd_hash;		/* Version name hash value */
-+  Elf32_Word	vd_aux;			/* Offset in bytes to verdaux array */
-+  Elf32_Word	vd_next;		/* Offset in bytes to next verdef
-+					   entry */
-+} Elf32_Verdef;
-+
-+typedef struct
-+{
-+  Elf64_Half	vd_version;		/* Version revision */
-+  Elf64_Half	vd_flags;		/* Version information */
-+  Elf64_Half	vd_ndx;			/* Version Index */
-+  Elf64_Half	vd_cnt;			/* Number of associated aux entries */
-+  Elf64_Word	vd_hash;		/* Version name hash value */
-+  Elf64_Word	vd_aux;			/* Offset in bytes to verdaux array */
-+  Elf64_Word	vd_next;		/* Offset in bytes to next verdef
-+					   entry */
-+} Elf64_Verdef;
-+
-+
-+/* Legal values for vd_version (version revision).  */
-+#define VER_DEF_NONE	0		/* No version */
-+#define VER_DEF_CURRENT	1		/* Current version */
-+#define VER_DEF_NUM	2		/* Given version number */
-+
-+/* Legal values for vd_flags (version information flags).  */
-+#define VER_FLG_BASE	0x1		/* Version definition of file itself */
-+#define VER_FLG_WEAK	0x2		/* Weak version identifier */
-+
-+/* Versym symbol index values.  */
-+#define	VER_NDX_LOCAL		0	/* Symbol is local.  */
-+#define	VER_NDX_GLOBAL		1	/* Symbol is global.  */
-+#define	VER_NDX_LORESERVE	0xff00	/* Beginning of reserved entries.  */
-+#define	VER_NDX_ELIMINATE	0xff01	/* Symbol is to be eliminated.  */
-+
-+/* Auxialiary version information.  */
-+
-+typedef struct
-+{
-+  Elf32_Word	vda_name;		/* Version or dependency names */
-+  Elf32_Word	vda_next;		/* Offset in bytes to next verdaux
-+					   entry */
-+} Elf32_Verdaux;
-+
-+typedef struct
-+{
-+  Elf64_Word	vda_name;		/* Version or dependency names */
-+  Elf64_Word	vda_next;		/* Offset in bytes to next verdaux
-+					   entry */
-+} Elf64_Verdaux;
-+
-+
-+/* Version dependency section.  */
-+
-+typedef struct
-+{
-+  Elf32_Half	vn_version;		/* Version of structure */
-+  Elf32_Half	vn_cnt;			/* Number of associated aux entries */
-+  Elf32_Word	vn_file;		/* Offset of filename for this
-+					   dependency */
-+  Elf32_Word	vn_aux;			/* Offset in bytes to vernaux array */
-+  Elf32_Word	vn_next;		/* Offset in bytes to next verneed
-+					   entry */
-+} Elf32_Verneed;
-+
-+typedef struct
-+{
-+  Elf64_Half	vn_version;		/* Version of structure */
-+  Elf64_Half	vn_cnt;			/* Number of associated aux entries */
-+  Elf64_Word	vn_file;		/* Offset of filename for this
-+					   dependency */
-+  Elf64_Word	vn_aux;			/* Offset in bytes to vernaux array */
-+  Elf64_Word	vn_next;		/* Offset in bytes to next verneed
-+					   entry */
-+} Elf64_Verneed;
-+
-+
-+/* Legal values for vn_version (version revision).  */
-+#define VER_NEED_NONE	 0		/* No version */
-+#define VER_NEED_CURRENT 1		/* Current version */
-+#define VER_NEED_NUM	 2		/* Given version number */
-+
-+/* Auxiliary needed version information.  */
-+
-+typedef struct
-+{
-+  Elf32_Word	vna_hash;		/* Hash value of dependency name */
-+  Elf32_Half	vna_flags;		/* Dependency specific information */
-+  Elf32_Half	vna_other;		/* Unused */
-+  Elf32_Word	vna_name;		/* Dependency name string offset */
-+  Elf32_Word	vna_next;		/* Offset in bytes to next vernaux
-+					   entry */
-+} Elf32_Vernaux;
-+
-+typedef struct
-+{
-+  Elf64_Word	vna_hash;		/* Hash value of dependency name */
-+  Elf64_Half	vna_flags;		/* Dependency specific information */
-+  Elf64_Half	vna_other;		/* Unused */
-+  Elf64_Word	vna_name;		/* Dependency name string offset */
-+  Elf64_Word	vna_next;		/* Offset in bytes to next vernaux
-+					   entry */
-+} Elf64_Vernaux;
-+
-+
-+/* Legal values for vna_flags.  */
-+#define VER_FLG_WEAK	0x2		/* Weak version identifier */
-+
-+
-+/* Auxiliary vector.  */
-+
-+/* This vector is normally only used by the program interpreter.  The
-+   usual definition in an ABI supplement uses the name auxv_t.  The
-+   vector is not usually defined in a standard <elf.h> file, but it
-+   can't hurt.  We rename it to avoid conflicts.  The sizes of these
-+   types are an arrangement between the exec server and the program
-+   interpreter, so we don't fully specify them here.  */
-+
-+typedef struct
-+{
-+  uint32_t a_type;		/* Entry type */
-+  union
-+    {
-+      uint32_t a_val;		/* Integer value */
-+      /* We use to have pointer elements added here.  We cannot do that,
-+	 though, since it does not work when using 32-bit definitions
-+	 on 64-bit platforms and vice versa.  */
-+    } a_un;
-+} Elf32_auxv_t;
-+
-+typedef struct
-+{
-+  uint64_t a_type;		/* Entry type */
-+  union
-+    {
-+      uint64_t a_val;		/* Integer value */
-+      /* We use to have pointer elements added here.  We cannot do that,
-+	 though, since it does not work when using 32-bit definitions
-+	 on 64-bit platforms and vice versa.  */
-+    } a_un;
-+} Elf64_auxv_t;
-+
-+/* Legal values for a_type (entry type).  */
-+
-+#define AT_NULL		0		/* End of vector */
-+#define AT_IGNORE	1		/* Entry should be ignored */
-+#define AT_EXECFD	2		/* File descriptor of program */
-+#define AT_PHDR		3		/* Program headers for program */
-+#define AT_PHENT	4		/* Size of program header entry */
-+#define AT_PHNUM	5		/* Number of program headers */
-+#define AT_PAGESZ	6		/* System page size */
-+#define AT_BASE		7		/* Base address of interpreter */
-+#define AT_FLAGS	8		/* Flags */
-+#define AT_ENTRY	9		/* Entry point of program */
-+#define AT_NOTELF	10		/* Program is not ELF */
-+#define AT_UID		11		/* Real uid */
-+#define AT_EUID		12		/* Effective uid */
-+#define AT_GID		13		/* Real gid */
-+#define AT_EGID		14		/* Effective gid */
-+#define AT_CLKTCK	17		/* Frequency of times() */
-+
-+/* Some more special a_type values describing the hardware.  */
-+#define AT_PLATFORM	15		/* String identifying platform.  */
-+#define AT_HWCAP	16		/* Machine dependent hints about
-+					   processor capabilities.  */
-+
-+/* This entry gives some information about the FPU initialization
-+   performed by the kernel.  */
-+#define AT_FPUCW	18		/* Used FPU control word.  */
-+
-+/* Cache block sizes.  */
-+#define AT_DCACHEBSIZE	19		/* Data cache block size.  */
-+#define AT_ICACHEBSIZE	20		/* Instruction cache block size.  */
-+#define AT_UCACHEBSIZE	21		/* Unified cache block size.  */
-+
-+/* A special ignored value for PPC, used by the kernel to control the
-+   interpretation of the AUXV. Must be > 16.  */
-+#define AT_IGNOREPPC	22		/* Entry should be ignored.  */
-+
-+#define	AT_SECURE	23		/* Boolean, was exec setuid-like?  */
-+
-+#define AT_BASE_PLATFORM 24		/* String identifying real platforms.*/
-+
-+#define AT_RANDOM	25		/* Address of 16 random bytes.  */
-+
-+#define AT_EXECFN	31		/* Filename of executable.  */
-+
-+/* Pointer to the global system page used for system calls and other
-+   nice things.  */
-+#define AT_SYSINFO	32
-+#define AT_SYSINFO_EHDR	33
-+
-+/* Shapes of the caches.  Bits 0-3 contains associativity; bits 4-7 contains
-+   log2 of line size; mask those to get cache size.  */
-+#define AT_L1I_CACHESHAPE	34
-+#define AT_L1D_CACHESHAPE	35
-+#define AT_L2_CACHESHAPE	36
-+#define AT_L3_CACHESHAPE	37
-+
-+/* Note section contents.  Each entry in the note section begins with
-+   a header of a fixed form.  */
-+
-+typedef struct
-+{
-+  Elf32_Word n_namesz;			/* Length of the note's name.  */
-+  Elf32_Word n_descsz;			/* Length of the note's descriptor.  */
-+  Elf32_Word n_type;			/* Type of the note.  */
-+} Elf32_Nhdr;
-+
-+typedef struct
-+{
-+  Elf64_Word n_namesz;			/* Length of the note's name.  */
-+  Elf64_Word n_descsz;			/* Length of the note's descriptor.  */
-+  Elf64_Word n_type;			/* Type of the note.  */
-+} Elf64_Nhdr;
-+
-+/* Known names of notes.  */
-+
-+/* Solaris entries in the note section have this name.  */
-+#define ELF_NOTE_SOLARIS	"SUNW Solaris"
-+
-+/* Note entries for GNU systems have this name.  */
-+#define ELF_NOTE_GNU		"GNU"
-+
-+
-+/* Defined types of notes for Solaris.  */
-+
-+/* Value of descriptor (one word) is desired pagesize for the binary.  */
-+#define ELF_NOTE_PAGESIZE_HINT	1
-+
-+
-+/* Defined note types for GNU systems.  */
-+
-+/* ABI information.  The descriptor consists of words:
-+   word 0: OS descriptor
-+   word 1: major version of the ABI
-+   word 2: minor version of the ABI
-+   word 3: subminor version of the ABI
-+*/
-+#define NT_GNU_ABI_TAG	1
-+#define ELF_NOTE_ABI	NT_GNU_ABI_TAG /* Old name.  */
-+
-+/* Known OSes.  These values can appear in word 0 of an
-+   NT_GNU_ABI_TAG note section entry.  */
-+#define ELF_NOTE_OS_LINUX	0
-+#define ELF_NOTE_OS_GNU		1
-+#define ELF_NOTE_OS_SOLARIS2	2
-+#define ELF_NOTE_OS_FREEBSD	3
-+
-+/* Synthetic hwcap information.  The descriptor begins with two words:
-+   word 0: number of entries
-+   word 1: bitmask of enabled entries
-+   Then follow variable-length entries, one byte followed by a
-+   '\0'-terminated hwcap name string.  The byte gives the bit
-+   number to test if enabled, (1U << bit) & bitmask.  */
-+#define NT_GNU_HWCAP	2
-+
-+/* Build ID bits as generated by ld --build-id.
-+   The descriptor consists of any nonzero number of bytes.  */
-+#define NT_GNU_BUILD_ID	3
-+
-+/* Version note generated by GNU gold containing a version string.  */
-+#define NT_GNU_GOLD_VERSION	4
-+
-+
-+/* Move records.  */
-+typedef struct
-+{
-+  Elf32_Xword m_value;		/* Symbol value.  */
-+  Elf32_Word m_info;		/* Size and index.  */
-+  Elf32_Word m_poffset;		/* Symbol offset.  */
-+  Elf32_Half m_repeat;		/* Repeat count.  */
-+  Elf32_Half m_stride;		/* Stride info.  */
-+} Elf32_Move;
-+
-+typedef struct
-+{
-+  Elf64_Xword m_value;		/* Symbol value.  */
-+  Elf64_Xword m_info;		/* Size and index.  */
-+  Elf64_Xword m_poffset;	/* Symbol offset.  */
-+  Elf64_Half m_repeat;		/* Repeat count.  */
-+  Elf64_Half m_stride;		/* Stride info.  */
-+} Elf64_Move;
-+
-+/* Macro to construct move records.  */
-+#define ELF32_M_SYM(info)	((info) >> 8)
-+#define ELF32_M_SIZE(info)	((unsigned char) (info))
-+#define ELF32_M_INFO(sym, size)	(((sym) << 8) + (unsigned char) (size))
-+
-+#define ELF64_M_SYM(info)	ELF32_M_SYM (info)
-+#define ELF64_M_SIZE(info)	ELF32_M_SIZE (info)
-+#define ELF64_M_INFO(sym, size)	ELF32_M_INFO (sym, size)
-+
-+
-+/* Motorola 68k specific definitions.  */
-+
-+/* Values for Elf32_Ehdr.e_flags.  */
-+#define EF_CPU32	0x00810000
-+
-+/* m68k relocs.  */
-+
-+#define R_68K_NONE	0		/* No reloc */
-+#define R_68K_32	1		/* Direct 32 bit  */
-+#define R_68K_16	2		/* Direct 16 bit  */
-+#define R_68K_8		3		/* Direct 8 bit  */
-+#define R_68K_PC32	4		/* PC relative 32 bit */
-+#define R_68K_PC16	5		/* PC relative 16 bit */
-+#define R_68K_PC8	6		/* PC relative 8 bit */
-+#define R_68K_GOT32	7		/* 32 bit PC relative GOT entry */
-+#define R_68K_GOT16	8		/* 16 bit PC relative GOT entry */
-+#define R_68K_GOT8	9		/* 8 bit PC relative GOT entry */
-+#define R_68K_GOT32O	10		/* 32 bit GOT offset */
-+#define R_68K_GOT16O	11		/* 16 bit GOT offset */
-+#define R_68K_GOT8O	12		/* 8 bit GOT offset */
-+#define R_68K_PLT32	13		/* 32 bit PC relative PLT address */
-+#define R_68K_PLT16	14		/* 16 bit PC relative PLT address */
-+#define R_68K_PLT8	15		/* 8 bit PC relative PLT address */
-+#define R_68K_PLT32O	16		/* 32 bit PLT offset */
-+#define R_68K_PLT16O	17		/* 16 bit PLT offset */
-+#define R_68K_PLT8O	18		/* 8 bit PLT offset */
-+#define R_68K_COPY	19		/* Copy symbol at runtime */
-+#define R_68K_GLOB_DAT	20		/* Create GOT entry */
-+#define R_68K_JMP_SLOT	21		/* Create PLT entry */
-+#define R_68K_RELATIVE	22		/* Adjust by program base */
-+#define R_68K_TLS_GD32      25          /* 32 bit GOT offset for GD */
-+#define R_68K_TLS_GD16      26          /* 16 bit GOT offset for GD */
-+#define R_68K_TLS_GD8       27          /* 8 bit GOT offset for GD */
-+#define R_68K_TLS_LDM32     28          /* 32 bit GOT offset for LDM */
-+#define R_68K_TLS_LDM16     29          /* 16 bit GOT offset for LDM */
-+#define R_68K_TLS_LDM8      30          /* 8 bit GOT offset for LDM */
-+#define R_68K_TLS_LDO32     31          /* 32 bit module-relative offset */
-+#define R_68K_TLS_LDO16     32          /* 16 bit module-relative offset */
-+#define R_68K_TLS_LDO8      33          /* 8 bit module-relative offset */
-+#define R_68K_TLS_IE32      34          /* 32 bit GOT offset for IE */
-+#define R_68K_TLS_IE16      35          /* 16 bit GOT offset for IE */
-+#define R_68K_TLS_IE8       36          /* 8 bit GOT offset for IE */
-+#define R_68K_TLS_LE32      37          /* 32 bit offset relative to
-+					   static TLS block */
-+#define R_68K_TLS_LE16      38          /* 16 bit offset relative to
-+					   static TLS block */
-+#define R_68K_TLS_LE8       39          /* 8 bit offset relative to
-+					   static TLS block */
-+#define R_68K_TLS_DTPMOD32  40          /* 32 bit module number */
-+#define R_68K_TLS_DTPREL32  41          /* 32 bit module-relative offset */
-+#define R_68K_TLS_TPREL32   42          /* 32 bit TP-relative offset */
-+/* Keep this the last entry.  */
-+#define R_68K_NUM	43
-+
-+/* Intel 80386 specific definitions.  */
-+
-+/* i386 relocs.  */
-+
-+#define R_386_NONE	   0		/* No reloc */
-+#define R_386_32	   1		/* Direct 32 bit  */
-+#define R_386_PC32	   2		/* PC relative 32 bit */
-+#define R_386_GOT32	   3		/* 32 bit GOT entry */
-+#define R_386_PLT32	   4		/* 32 bit PLT address */
-+#define R_386_COPY	   5		/* Copy symbol at runtime */
-+#define R_386_GLOB_DAT	   6		/* Create GOT entry */
-+#define R_386_JMP_SLOT	   7		/* Create PLT entry */
-+#define R_386_RELATIVE	   8		/* Adjust by program base */
-+#define R_386_GOTOFF	   9		/* 32 bit offset to GOT */
-+#define R_386_GOTPC	   10		/* 32 bit PC relative offset to GOT */
-+#define R_386_32PLT	   11
-+#define R_386_TLS_TPOFF	   14		/* Offset in static TLS block */
-+#define R_386_TLS_IE	   15		/* Address of GOT entry for static TLS
-+					   block offset */
-+#define R_386_TLS_GOTIE	   16		/* GOT entry for static TLS block
-+					   offset */
-+#define R_386_TLS_LE	   17		/* Offset relative to static TLS
-+					   block */
-+#define R_386_TLS_GD	   18		/* Direct 32 bit for GNU version of
-+					   general dynamic thread local data */
-+#define R_386_TLS_LDM	   19		/* Direct 32 bit for GNU version of
-+					   local dynamic thread local data
-+					   in LE code */
-+#define R_386_16	   20
-+#define R_386_PC16	   21
-+#define R_386_8		   22
-+#define R_386_PC8	   23
-+#define R_386_TLS_GD_32	   24		/* Direct 32 bit for general dynamic
-+					   thread local data */
-+#define R_386_TLS_GD_PUSH  25		/* Tag for pushl in GD TLS code */
-+#define R_386_TLS_GD_CALL  26		/* Relocation for call to
-+					   __tls_get_addr() */
-+#define R_386_TLS_GD_POP   27		/* Tag for popl in GD TLS code */
-+#define R_386_TLS_LDM_32   28		/* Direct 32 bit for local dynamic
-+					   thread local data in LE code */
-+#define R_386_TLS_LDM_PUSH 29		/* Tag for pushl in LDM TLS code */
-+#define R_386_TLS_LDM_CALL 30		/* Relocation for call to
-+					   __tls_get_addr() in LDM code */
-+#define R_386_TLS_LDM_POP  31		/* Tag for popl in LDM TLS code */
-+#define R_386_TLS_LDO_32   32		/* Offset relative to TLS block */
-+#define R_386_TLS_IE_32	   33		/* GOT entry for negated static TLS
-+					   block offset */
-+#define R_386_TLS_LE_32	   34		/* Negated offset relative to static
-+					   TLS block */
-+#define R_386_TLS_DTPMOD32 35		/* ID of module containing symbol */
-+#define R_386_TLS_DTPOFF32 36		/* Offset in TLS block */
-+#define R_386_TLS_TPOFF32  37		/* Negated offset in static TLS block */
-+/* 38? */
-+#define R_386_TLS_GOTDESC  39		/* GOT offset for TLS descriptor.  */
-+#define R_386_TLS_DESC_CALL 40		/* Marker of call through TLS
-+					   descriptor for
-+					   relaxation.  */
-+#define R_386_TLS_DESC     41		/* TLS descriptor containing
-+					   pointer to code and to
-+					   argument, returning the TLS
-+					   offset for the symbol.  */
-+#define R_386_IRELATIVE	   42		/* Adjust indirectly by program base */
-+/* Keep this the last entry.  */
-+#define R_386_NUM	   43
-+
-+/* SUN SPARC specific definitions.  */
-+
-+/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
-+
-+#define STT_SPARC_REGISTER	13	/* Global register reserved to app. */
-+
-+/* Values for Elf64_Ehdr.e_flags.  */
-+
-+#define EF_SPARCV9_MM		3
-+#define EF_SPARCV9_TSO		0
-+#define EF_SPARCV9_PSO		1
-+#define EF_SPARCV9_RMO		2
-+#define EF_SPARC_LEDATA		0x800000 /* little endian data */
-+#define EF_SPARC_EXT_MASK	0xFFFF00
-+#define EF_SPARC_32PLUS		0x000100 /* generic V8+ features */
-+#define EF_SPARC_SUN_US1	0x000200 /* Sun UltraSPARC1 extensions */
-+#define EF_SPARC_HAL_R1		0x000400 /* HAL R1 extensions */
-+#define EF_SPARC_SUN_US3	0x000800 /* Sun UltraSPARCIII extensions */
-+
-+/* SPARC relocs.  */
-+
-+#define R_SPARC_NONE		0	/* No reloc */
-+#define R_SPARC_8		1	/* Direct 8 bit */
-+#define R_SPARC_16		2	/* Direct 16 bit */
-+#define R_SPARC_32		3	/* Direct 32 bit */
-+#define R_SPARC_DISP8		4	/* PC relative 8 bit */
-+#define R_SPARC_DISP16		5	/* PC relative 16 bit */
-+#define R_SPARC_DISP32		6	/* PC relative 32 bit */
-+#define R_SPARC_WDISP30		7	/* PC relative 30 bit shifted */
-+#define R_SPARC_WDISP22		8	/* PC relative 22 bit shifted */
-+#define R_SPARC_HI22		9	/* High 22 bit */
-+#define R_SPARC_22		10	/* Direct 22 bit */
-+#define R_SPARC_13		11	/* Direct 13 bit */
-+#define R_SPARC_LO10		12	/* Truncated 10 bit */
-+#define R_SPARC_GOT10		13	/* Truncated 10 bit GOT entry */
-+#define R_SPARC_GOT13		14	/* 13 bit GOT entry */
-+#define R_SPARC_GOT22		15	/* 22 bit GOT entry shifted */
-+#define R_SPARC_PC10		16	/* PC relative 10 bit truncated */
-+#define R_SPARC_PC22		17	/* PC relative 22 bit shifted */
-+#define R_SPARC_WPLT30		18	/* 30 bit PC relative PLT address */
-+#define R_SPARC_COPY		19	/* Copy symbol at runtime */
-+#define R_SPARC_GLOB_DAT	20	/* Create GOT entry */
-+#define R_SPARC_JMP_SLOT	21	/* Create PLT entry */
-+#define R_SPARC_RELATIVE	22	/* Adjust by program base */
-+#define R_SPARC_UA32		23	/* Direct 32 bit unaligned */
-+
-+/* Additional Sparc64 relocs.  */
-+
-+#define R_SPARC_PLT32		24	/* Direct 32 bit ref to PLT entry */
-+#define R_SPARC_HIPLT22		25	/* High 22 bit PLT entry */
-+#define R_SPARC_LOPLT10		26	/* Truncated 10 bit PLT entry */
-+#define R_SPARC_PCPLT32		27	/* PC rel 32 bit ref to PLT entry */
-+#define R_SPARC_PCPLT22		28	/* PC rel high 22 bit PLT entry */
-+#define R_SPARC_PCPLT10		29	/* PC rel trunc 10 bit PLT entry */
-+#define R_SPARC_10		30	/* Direct 10 bit */
-+#define R_SPARC_11		31	/* Direct 11 bit */
-+#define R_SPARC_64		32	/* Direct 64 bit */
-+#define R_SPARC_OLO10		33	/* 10bit with secondary 13bit addend */
-+#define R_SPARC_HH22		34	/* Top 22 bits of direct 64 bit */
-+#define R_SPARC_HM10		35	/* High middle 10 bits of ... */
-+#define R_SPARC_LM22		36	/* Low middle 22 bits of ... */
-+#define R_SPARC_PC_HH22		37	/* Top 22 bits of pc rel 64 bit */
-+#define R_SPARC_PC_HM10		38	/* High middle 10 bit of ... */
-+#define R_SPARC_PC_LM22		39	/* Low miggle 22 bits of ... */
-+#define R_SPARC_WDISP16		40	/* PC relative 16 bit shifted */
-+#define R_SPARC_WDISP19		41	/* PC relative 19 bit shifted */
-+#define R_SPARC_GLOB_JMP	42	/* was part of v9 ABI but was removed */
-+#define R_SPARC_7		43	/* Direct 7 bit */
-+#define R_SPARC_5		44	/* Direct 5 bit */
-+#define R_SPARC_6		45	/* Direct 6 bit */
-+#define R_SPARC_DISP64		46	/* PC relative 64 bit */
-+#define R_SPARC_PLT64		47	/* Direct 64 bit ref to PLT entry */
-+#define R_SPARC_HIX22		48	/* High 22 bit complemented */
-+#define R_SPARC_LOX10		49	/* Truncated 11 bit complemented */
-+#define R_SPARC_H44		50	/* Direct high 12 of 44 bit */
-+#define R_SPARC_M44		51	/* Direct mid 22 of 44 bit */
-+#define R_SPARC_L44		52	/* Direct low 10 of 44 bit */
-+#define R_SPARC_REGISTER	53	/* Global register usage */
-+#define R_SPARC_UA64		54	/* Direct 64 bit unaligned */
-+#define R_SPARC_UA16		55	/* Direct 16 bit unaligned */
-+#define R_SPARC_TLS_GD_HI22	56
-+#define R_SPARC_TLS_GD_LO10	57
-+#define R_SPARC_TLS_GD_ADD	58
-+#define R_SPARC_TLS_GD_CALL	59
-+#define R_SPARC_TLS_LDM_HI22	60
-+#define R_SPARC_TLS_LDM_LO10	61
-+#define R_SPARC_TLS_LDM_ADD	62
-+#define R_SPARC_TLS_LDM_CALL	63
-+#define R_SPARC_TLS_LDO_HIX22	64
-+#define R_SPARC_TLS_LDO_LOX10	65
-+#define R_SPARC_TLS_LDO_ADD	66
-+#define R_SPARC_TLS_IE_HI22	67
-+#define R_SPARC_TLS_IE_LO10	68
-+#define R_SPARC_TLS_IE_LD	69
-+#define R_SPARC_TLS_IE_LDX	70
-+#define R_SPARC_TLS_IE_ADD	71
-+#define R_SPARC_TLS_LE_HIX22	72
-+#define R_SPARC_TLS_LE_LOX10	73
-+#define R_SPARC_TLS_DTPMOD32	74
-+#define R_SPARC_TLS_DTPMOD64	75
-+#define R_SPARC_TLS_DTPOFF32	76
-+#define R_SPARC_TLS_DTPOFF64	77
-+#define R_SPARC_TLS_TPOFF32	78
-+#define R_SPARC_TLS_TPOFF64	79
-+#define R_SPARC_GOTDATA_HIX22	80
-+#define R_SPARC_GOTDATA_LOX10	81
-+#define R_SPARC_GOTDATA_OP_HIX22	82
-+#define R_SPARC_GOTDATA_OP_LOX10	83
-+#define R_SPARC_GOTDATA_OP	84
-+#define R_SPARC_H34		85
-+#define R_SPARC_SIZE32		86
-+#define R_SPARC_SIZE64		87
-+#define R_SPARC_WDISP10		88
-+#define R_SPARC_JMP_IREL	248
-+#define R_SPARC_IRELATIVE	249
-+#define R_SPARC_GNU_VTINHERIT	250
-+#define R_SPARC_GNU_VTENTRY	251
-+#define R_SPARC_REV32		252
-+/* Keep this the last entry.  */
-+#define R_SPARC_NUM		253
-+
-+/* For Sparc64, legal values for d_tag of Elf64_Dyn.  */
-+
-+#define DT_SPARC_REGISTER 0x70000001
-+#define DT_SPARC_NUM	2
-+
-+/* MIPS R3000 specific definitions.  */
-+
-+/* Legal values for e_flags field of Elf32_Ehdr.  */
-+
-+#define EF_MIPS_NOREORDER   1		/* A .noreorder directive was used */
-+#define EF_MIPS_PIC	    2		/* Contains PIC code */
-+#define EF_MIPS_CPIC	    4		/* Uses PIC calling sequence */
-+#define EF_MIPS_XGOT	    8
-+#define EF_MIPS_64BIT_WHIRL 16
-+#define EF_MIPS_ABI2	    32
-+#define EF_MIPS_ABI_ON32    64
-+#define EF_MIPS_ARCH	    0xf0000000	/* MIPS architecture level */
-+
-+/* Legal values for MIPS architecture level.  */
-+
-+#define EF_MIPS_ARCH_1	    0x00000000	/* -mips1 code.  */
-+#define EF_MIPS_ARCH_2	    0x10000000	/* -mips2 code.  */
-+#define EF_MIPS_ARCH_3	    0x20000000	/* -mips3 code.  */
-+#define EF_MIPS_ARCH_4	    0x30000000	/* -mips4 code.  */
-+#define EF_MIPS_ARCH_5	    0x40000000	/* -mips5 code.  */
-+#define EF_MIPS_ARCH_32	    0x60000000	/* MIPS32 code.  */
-+#define EF_MIPS_ARCH_64	    0x70000000	/* MIPS64 code.  */
-+
-+/* The following are non-official names and should not be used.  */
-+
-+#define E_MIPS_ARCH_1	  0x00000000	/* -mips1 code.  */
-+#define E_MIPS_ARCH_2	  0x10000000	/* -mips2 code.  */
-+#define E_MIPS_ARCH_3	  0x20000000	/* -mips3 code.  */
-+#define E_MIPS_ARCH_4	  0x30000000	/* -mips4 code.  */
-+#define E_MIPS_ARCH_5	  0x40000000	/* -mips5 code.  */
-+#define E_MIPS_ARCH_32	  0x60000000	/* MIPS32 code.  */
-+#define E_MIPS_ARCH_64	  0x70000000	/* MIPS64 code.  */
-+
-+/* Special section indices.  */
-+
-+#define SHN_MIPS_ACOMMON    0xff00	/* Allocated common symbols */
-+#define SHN_MIPS_TEXT	    0xff01	/* Allocated test symbols.  */
-+#define SHN_MIPS_DATA	    0xff02	/* Allocated data symbols.  */
-+#define SHN_MIPS_SCOMMON    0xff03	/* Small common symbols */
-+#define SHN_MIPS_SUNDEFINED 0xff04	/* Small undefined symbols */
-+
-+/* Legal values for sh_type field of Elf32_Shdr.  */
-+
-+#define SHT_MIPS_LIBLIST       0x70000000 /* Shared objects used in link */
-+#define SHT_MIPS_MSYM	       0x70000001
-+#define SHT_MIPS_CONFLICT      0x70000002 /* Conflicting symbols */
-+#define SHT_MIPS_GPTAB	       0x70000003 /* Global data area sizes */
-+#define SHT_MIPS_UCODE	       0x70000004 /* Reserved for SGI/MIPS compilers */
-+#define SHT_MIPS_DEBUG	       0x70000005 /* MIPS ECOFF debugging information*/
-+#define SHT_MIPS_REGINFO       0x70000006 /* Register usage information */
-+#define SHT_MIPS_PACKAGE       0x70000007
-+#define SHT_MIPS_PACKSYM       0x70000008
-+#define SHT_MIPS_RELD	       0x70000009
-+#define SHT_MIPS_IFACE         0x7000000b
-+#define SHT_MIPS_CONTENT       0x7000000c
-+#define SHT_MIPS_OPTIONS       0x7000000d /* Miscellaneous options.  */
-+#define SHT_MIPS_SHDR	       0x70000010
-+#define SHT_MIPS_FDESC	       0x70000011
-+#define SHT_MIPS_EXTSYM	       0x70000012
-+#define SHT_MIPS_DENSE	       0x70000013
-+#define SHT_MIPS_PDESC	       0x70000014
-+#define SHT_MIPS_LOCSYM	       0x70000015
-+#define SHT_MIPS_AUXSYM	       0x70000016
-+#define SHT_MIPS_OPTSYM	       0x70000017
-+#define SHT_MIPS_LOCSTR	       0x70000018
-+#define SHT_MIPS_LINE	       0x70000019
-+#define SHT_MIPS_RFDESC	       0x7000001a
-+#define SHT_MIPS_DELTASYM      0x7000001b
-+#define SHT_MIPS_DELTAINST     0x7000001c
-+#define SHT_MIPS_DELTACLASS    0x7000001d
-+#define SHT_MIPS_DWARF         0x7000001e /* DWARF debugging information.  */
-+#define SHT_MIPS_DELTADECL     0x7000001f
-+#define SHT_MIPS_SYMBOL_LIB    0x70000020
-+#define SHT_MIPS_EVENTS	       0x70000021 /* Event section.  */
-+#define SHT_MIPS_TRANSLATE     0x70000022
-+#define SHT_MIPS_PIXIE	       0x70000023
-+#define SHT_MIPS_XLATE	       0x70000024
-+#define SHT_MIPS_XLATE_DEBUG   0x70000025
-+#define SHT_MIPS_WHIRL	       0x70000026
-+#define SHT_MIPS_EH_REGION     0x70000027
-+#define SHT_MIPS_XLATE_OLD     0x70000028
-+#define SHT_MIPS_PDR_EXCEPTION 0x70000029
-+
-+/* Legal values for sh_flags field of Elf32_Shdr.  */
-+
-+#define SHF_MIPS_GPREL	 0x10000000	/* Must be part of global data area */
-+#define SHF_MIPS_MERGE	 0x20000000
-+#define SHF_MIPS_ADDR	 0x40000000
-+#define SHF_MIPS_STRINGS 0x80000000
-+#define SHF_MIPS_NOSTRIP 0x08000000
-+#define SHF_MIPS_LOCAL	 0x04000000
-+#define SHF_MIPS_NAMES	 0x02000000
-+#define SHF_MIPS_NODUPE	 0x01000000
-+
-+
-+/* Symbol tables.  */
-+
-+/* MIPS specific values for `st_other'.  */
-+#define STO_MIPS_DEFAULT		0x0
-+#define STO_MIPS_INTERNAL		0x1
-+#define STO_MIPS_HIDDEN			0x2
-+#define STO_MIPS_PROTECTED		0x3
-+#define STO_MIPS_PLT			0x8
-+#define STO_MIPS_SC_ALIGN_UNUSED	0xff
-+
-+/* MIPS specific values for `st_info'.  */
-+#define STB_MIPS_SPLIT_COMMON		13
-+
-+/* Entries found in sections of type SHT_MIPS_GPTAB.  */
-+
-+typedef union
-+{
-+  struct
-+    {
-+      Elf32_Word gt_current_g_value;	/* -G value used for compilation */
-+      Elf32_Word gt_unused;		/* Not used */
-+    } gt_header;			/* First entry in section */
-+  struct
-+    {
-+      Elf32_Word gt_g_value;		/* If this value were used for -G */
-+      Elf32_Word gt_bytes;		/* This many bytes would be used */
-+    } gt_entry;				/* Subsequent entries in section */
-+} Elf32_gptab;
-+
-+/* Entry found in sections of type SHT_MIPS_REGINFO.  */
-+
-+typedef struct
-+{
-+  Elf32_Word	ri_gprmask;		/* General registers used */
-+  Elf32_Word	ri_cprmask[4];		/* Coprocessor registers used */
-+  Elf32_Sword	ri_gp_value;		/* $gp register value */
-+} Elf32_RegInfo;
-+
-+/* Entries found in sections of type SHT_MIPS_OPTIONS.  */
-+
-+typedef struct
-+{
-+  unsigned char kind;		/* Determines interpretation of the
-+				   variable part of descriptor.  */
-+  unsigned char size;		/* Size of descriptor, including header.  */
-+  Elf32_Section section;	/* Section header index of section affected,
-+				   0 for global options.  */
-+  Elf32_Word info;		/* Kind-specific information.  */
-+} Elf_Options;
-+
-+/* Values for `kind' field in Elf_Options.  */
-+
-+#define ODK_NULL	0	/* Undefined.  */
-+#define ODK_REGINFO	1	/* Register usage information.  */
-+#define ODK_EXCEPTIONS	2	/* Exception processing options.  */
-+#define ODK_PAD		3	/* Section padding options.  */
-+#define ODK_HWPATCH	4	/* Hardware workarounds performed */
-+#define ODK_FILL	5	/* record the fill value used by the linker. */
-+#define ODK_TAGS	6	/* reserve space for desktop tools to write. */
-+#define ODK_HWAND	7	/* HW workarounds.  'AND' bits when merging. */
-+#define ODK_HWOR	8	/* HW workarounds.  'OR' bits when merging.  */
-+
-+/* Values for `info' in Elf_Options for ODK_EXCEPTIONS entries.  */
-+
-+#define OEX_FPU_MIN	0x1f	/* FPE's which MUST be enabled.  */
-+#define OEX_FPU_MAX	0x1f00	/* FPE's which MAY be enabled.  */
-+#define OEX_PAGE0	0x10000	/* page zero must be mapped.  */
-+#define OEX_SMM		0x20000	/* Force sequential memory mode?  */
-+#define OEX_FPDBUG	0x40000	/* Force floating point debug mode?  */
-+#define OEX_PRECISEFP	OEX_FPDBUG
-+#define OEX_DISMISS	0x80000	/* Dismiss invalid address faults?  */
-+
-+#define OEX_FPU_INVAL	0x10
-+#define OEX_FPU_DIV0	0x08
-+#define OEX_FPU_OFLO	0x04
-+#define OEX_FPU_UFLO	0x02
-+#define OEX_FPU_INEX	0x01
-+
-+/* Masks for `info' in Elf_Options for an ODK_HWPATCH entry.  */
-+
-+#define OHW_R4KEOP	0x1	/* R4000 end-of-page patch.  */
-+#define OHW_R8KPFETCH	0x2	/* may need R8000 prefetch patch.  */
-+#define OHW_R5KEOP	0x4	/* R5000 end-of-page patch.  */
-+#define OHW_R5KCVTL	0x8	/* R5000 cvt.[ds].l bug.  clean=1.  */
-+
-+#define OPAD_PREFIX	0x1
-+#define OPAD_POSTFIX	0x2
-+#define OPAD_SYMBOL	0x4
-+
-+/* Entry found in `.options' section.  */
-+
-+typedef struct
-+{
-+  Elf32_Word hwp_flags1;	/* Extra flags.  */
-+  Elf32_Word hwp_flags2;	/* Extra flags.  */
-+} Elf_Options_Hw;
-+
-+/* Masks for `info' in ElfOptions for ODK_HWAND and ODK_HWOR entries.  */
-+
-+#define OHWA0_R4KEOP_CHECKED	0x00000001
-+#define OHWA1_R4KEOP_CLEAN	0x00000002
-+
-+/* MIPS relocs.  */
-+
-+#define R_MIPS_NONE		0	/* No reloc */
-+#define R_MIPS_16		1	/* Direct 16 bit */
-+#define R_MIPS_32		2	/* Direct 32 bit */
-+#define R_MIPS_REL32		3	/* PC relative 32 bit */
-+#define R_MIPS_26		4	/* Direct 26 bit shifted */
-+#define R_MIPS_HI16		5	/* High 16 bit */
-+#define R_MIPS_LO16		6	/* Low 16 bit */
-+#define R_MIPS_GPREL16		7	/* GP relative 16 bit */
-+#define R_MIPS_LITERAL		8	/* 16 bit literal entry */
-+#define R_MIPS_GOT16		9	/* 16 bit GOT entry */
-+#define R_MIPS_PC16		10	/* PC relative 16 bit */
-+#define R_MIPS_CALL16		11	/* 16 bit GOT entry for function */
-+#define R_MIPS_GPREL32		12	/* GP relative 32 bit */
-+
-+#define R_MIPS_SHIFT5		16
-+#define R_MIPS_SHIFT6		17
-+#define R_MIPS_64		18
-+#define R_MIPS_GOT_DISP		19
-+#define R_MIPS_GOT_PAGE		20
-+#define R_MIPS_GOT_OFST		21
-+#define R_MIPS_GOT_HI16		22
-+#define R_MIPS_GOT_LO16		23
-+#define R_MIPS_SUB		24
-+#define R_MIPS_INSERT_A		25
-+#define R_MIPS_INSERT_B		26
-+#define R_MIPS_DELETE		27
-+#define R_MIPS_HIGHER		28
-+#define R_MIPS_HIGHEST		29
-+#define R_MIPS_CALL_HI16	30
-+#define R_MIPS_CALL_LO16	31
-+#define R_MIPS_SCN_DISP		32
-+#define R_MIPS_REL16		33
-+#define R_MIPS_ADD_IMMEDIATE	34
-+#define R_MIPS_PJUMP		35
-+#define R_MIPS_RELGOT		36
-+#define R_MIPS_JALR		37
-+#define R_MIPS_TLS_DTPMOD32	38	/* Module number 32 bit */
-+#define R_MIPS_TLS_DTPREL32	39	/* Module-relative offset 32 bit */
-+#define R_MIPS_TLS_DTPMOD64	40	/* Module number 64 bit */
-+#define R_MIPS_TLS_DTPREL64	41	/* Module-relative offset 64 bit */
-+#define R_MIPS_TLS_GD		42	/* 16 bit GOT offset for GD */
-+#define R_MIPS_TLS_LDM		43	/* 16 bit GOT offset for LDM */
-+#define R_MIPS_TLS_DTPREL_HI16	44	/* Module-relative offset, high 16 bits */
-+#define R_MIPS_TLS_DTPREL_LO16	45	/* Module-relative offset, low 16 bits */
-+#define R_MIPS_TLS_GOTTPREL	46	/* 16 bit GOT offset for IE */
-+#define R_MIPS_TLS_TPREL32	47	/* TP-relative offset, 32 bit */
-+#define R_MIPS_TLS_TPREL64	48	/* TP-relative offset, 64 bit */
-+#define R_MIPS_TLS_TPREL_HI16	49	/* TP-relative offset, high 16 bits */
-+#define R_MIPS_TLS_TPREL_LO16	50	/* TP-relative offset, low 16 bits */
-+#define R_MIPS_GLOB_DAT		51
-+#define R_MIPS_COPY		126
-+#define R_MIPS_JUMP_SLOT        127
-+/* Keep this the last entry.  */
-+#define R_MIPS_NUM		128
-+
-+/* Legal values for p_type field of Elf32_Phdr.  */
-+
-+#define PT_MIPS_REGINFO	0x70000000	/* Register usage information */
-+#define PT_MIPS_RTPROC  0x70000001	/* Runtime procedure table. */
-+#define PT_MIPS_OPTIONS 0x70000002
-+
-+/* Special program header types.  */
-+
-+#define PF_MIPS_LOCAL	0x10000000
-+
-+/* Legal values for d_tag field of Elf32_Dyn.  */
-+
-+#define DT_MIPS_RLD_VERSION  0x70000001	/* Runtime linker interface version */
-+#define DT_MIPS_TIME_STAMP   0x70000002	/* Timestamp */
-+#define DT_MIPS_ICHECKSUM    0x70000003	/* Checksum */
-+#define DT_MIPS_IVERSION     0x70000004	/* Version string (string tbl index) */
-+#define DT_MIPS_FLAGS	     0x70000005	/* Flags */
-+#define DT_MIPS_BASE_ADDRESS 0x70000006	/* Base address */
-+#define DT_MIPS_MSYM	     0x70000007
-+#define DT_MIPS_CONFLICT     0x70000008	/* Address of CONFLICT section */
-+#define DT_MIPS_LIBLIST	     0x70000009	/* Address of LIBLIST section */
-+#define DT_MIPS_LOCAL_GOTNO  0x7000000a	/* Number of local GOT entries */
-+#define DT_MIPS_CONFLICTNO   0x7000000b	/* Number of CONFLICT entries */
-+#define DT_MIPS_LIBLISTNO    0x70000010	/* Number of LIBLIST entries */
-+#define DT_MIPS_SYMTABNO     0x70000011	/* Number of DYNSYM entries */
-+#define DT_MIPS_UNREFEXTNO   0x70000012	/* First external DYNSYM */
-+#define DT_MIPS_GOTSYM	     0x70000013	/* First GOT entry in DYNSYM */
-+#define DT_MIPS_HIPAGENO     0x70000014	/* Number of GOT page table entries */
-+#define DT_MIPS_RLD_MAP	     0x70000016	/* Address of run time loader map.  */
-+#define DT_MIPS_DELTA_CLASS  0x70000017	/* Delta C++ class definition.  */
-+#define DT_MIPS_DELTA_CLASS_NO    0x70000018 /* Number of entries in
-+						DT_MIPS_DELTA_CLASS.  */
-+#define DT_MIPS_DELTA_INSTANCE    0x70000019 /* Delta C++ class instances.  */
-+#define DT_MIPS_DELTA_INSTANCE_NO 0x7000001a /* Number of entries in
-+						DT_MIPS_DELTA_INSTANCE.  */
-+#define DT_MIPS_DELTA_RELOC  0x7000001b /* Delta relocations.  */
-+#define DT_MIPS_DELTA_RELOC_NO 0x7000001c /* Number of entries in
-+					     DT_MIPS_DELTA_RELOC.  */
-+#define DT_MIPS_DELTA_SYM    0x7000001d /* Delta symbols that Delta
-+					   relocations refer to.  */
-+#define DT_MIPS_DELTA_SYM_NO 0x7000001e /* Number of entries in
-+					   DT_MIPS_DELTA_SYM.  */
-+#define DT_MIPS_DELTA_CLASSSYM 0x70000020 /* Delta symbols that hold the
-+					     class declaration.  */
-+#define DT_MIPS_DELTA_CLASSSYM_NO 0x70000021 /* Number of entries in
-+						DT_MIPS_DELTA_CLASSSYM.  */
-+#define DT_MIPS_CXX_FLAGS    0x70000022 /* Flags indicating for C++ flavor.  */
-+#define DT_MIPS_PIXIE_INIT   0x70000023
-+#define DT_MIPS_SYMBOL_LIB   0x70000024
-+#define DT_MIPS_LOCALPAGE_GOTIDX 0x70000025
-+#define DT_MIPS_LOCAL_GOTIDX 0x70000026
-+#define DT_MIPS_HIDDEN_GOTIDX 0x70000027
-+#define DT_MIPS_PROTECTED_GOTIDX 0x70000028
-+#define DT_MIPS_OPTIONS	     0x70000029 /* Address of .options.  */
-+#define DT_MIPS_INTERFACE    0x7000002a /* Address of .interface.  */
-+#define DT_MIPS_DYNSTR_ALIGN 0x7000002b
-+#define DT_MIPS_INTERFACE_SIZE 0x7000002c /* Size of the .interface section. */
-+#define DT_MIPS_RLD_TEXT_RESOLVE_ADDR 0x7000002d /* Address of rld_text_rsolve
-+						    function stored in GOT.  */
-+#define DT_MIPS_PERF_SUFFIX  0x7000002e /* Default suffix of dso to be added
-+					   by rld on dlopen() calls.  */
-+#define DT_MIPS_COMPACT_SIZE 0x7000002f /* (O32)Size of compact rel section. */
-+#define DT_MIPS_GP_VALUE     0x70000030 /* GP value for aux GOTs.  */
-+#define DT_MIPS_AUX_DYNAMIC  0x70000031 /* Address of aux .dynamic.  */
-+/* The address of .got.plt in an executable using the new non-PIC ABI.  */
-+#define DT_MIPS_PLTGOT	     0x70000032
-+/* The base of the PLT in an executable using the new non-PIC ABI if that
-+   PLT is writable.  For a non-writable PLT, this is omitted or has a zero
-+   value.  */
-+#define DT_MIPS_RWPLT        0x70000034
-+#define DT_MIPS_NUM	     0x35
-+
-+/* Legal values for DT_MIPS_FLAGS Elf32_Dyn entry.  */
-+
-+#define RHF_NONE		   0		/* No flags */
-+#define RHF_QUICKSTART		   (1 << 0)	/* Use quickstart */
-+#define RHF_NOTPOT		   (1 << 1)	/* Hash size not power of 2 */
-+#define RHF_NO_LIBRARY_REPLACEMENT (1 << 2)	/* Ignore LD_LIBRARY_PATH */
-+#define RHF_NO_MOVE		   (1 << 3)
-+#define RHF_SGI_ONLY		   (1 << 4)
-+#define RHF_GUARANTEE_INIT	   (1 << 5)
-+#define RHF_DELTA_C_PLUS_PLUS	   (1 << 6)
-+#define RHF_GUARANTEE_START_INIT   (1 << 7)
-+#define RHF_PIXIE		   (1 << 8)
-+#define RHF_DEFAULT_DELAY_LOAD	   (1 << 9)
-+#define RHF_REQUICKSTART	   (1 << 10)
-+#define RHF_REQUICKSTARTED	   (1 << 11)
-+#define RHF_CORD		   (1 << 12)
-+#define RHF_NO_UNRES_UNDEF	   (1 << 13)
-+#define RHF_RLD_ORDER_SAFE	   (1 << 14)
-+
-+/* Entries found in sections of type SHT_MIPS_LIBLIST.  */
-+
-+typedef struct
-+{
-+  Elf32_Word l_name;		/* Name (string table index) */
-+  Elf32_Word l_time_stamp;	/* Timestamp */
-+  Elf32_Word l_checksum;	/* Checksum */
-+  Elf32_Word l_version;		/* Interface version */
-+  Elf32_Word l_flags;		/* Flags */
-+} Elf32_Lib;
-+
-+typedef struct
-+{
-+  Elf64_Word l_name;		/* Name (string table index) */
-+  Elf64_Word l_time_stamp;	/* Timestamp */
-+  Elf64_Word l_checksum;	/* Checksum */
-+  Elf64_Word l_version;		/* Interface version */
-+  Elf64_Word l_flags;		/* Flags */
-+} Elf64_Lib;
-+
-+
-+/* Legal values for l_flags.  */
-+
-+#define LL_NONE		  0
-+#define LL_EXACT_MATCH	  (1 << 0)	/* Require exact match */
-+#define LL_IGNORE_INT_VER (1 << 1)	/* Ignore interface version */
-+#define LL_REQUIRE_MINOR  (1 << 2)
-+#define LL_EXPORTS	  (1 << 3)
-+#define LL_DELAY_LOAD	  (1 << 4)
-+#define LL_DELTA	  (1 << 5)
-+
-+/* Entries found in sections of type SHT_MIPS_CONFLICT.  */
-+
-+typedef Elf32_Addr Elf32_Conflict;
-+
-+
-+/* HPPA specific definitions.  */
-+
-+/* Legal values for e_flags field of Elf32_Ehdr.  */
-+
-+#define EF_PARISC_TRAPNIL	0x00010000 /* Trap nil pointer dereference.  */
-+#define EF_PARISC_EXT		0x00020000 /* Program uses arch. extensions. */
-+#define EF_PARISC_LSB		0x00040000 /* Program expects little endian. */
-+#define EF_PARISC_WIDE		0x00080000 /* Program expects wide mode.  */
-+#define EF_PARISC_NO_KABP	0x00100000 /* No kernel assisted branch
-+					      prediction.  */
-+#define EF_PARISC_LAZYSWAP	0x00400000 /* Allow lazy swapping.  */
-+#define EF_PARISC_ARCH		0x0000ffff /* Architecture version.  */
-+
-+/* Defined values for `e_flags & EF_PARISC_ARCH' are:  */
-+
-+#define EFA_PARISC_1_0		    0x020b /* PA-RISC 1.0 big-endian.  */
-+#define EFA_PARISC_1_1		    0x0210 /* PA-RISC 1.1 big-endian.  */
-+#define EFA_PARISC_2_0		    0x0214 /* PA-RISC 2.0 big-endian.  */
-+
-+/* Additional section indeces.  */
-+
-+#define SHN_PARISC_ANSI_COMMON	0xff00	   /* Section for tenatively declared
-+					      symbols in ANSI C.  */
-+#define SHN_PARISC_HUGE_COMMON	0xff01	   /* Common blocks in huge model.  */
-+
-+/* Legal values for sh_type field of Elf32_Shdr.  */
-+
-+#define SHT_PARISC_EXT		0x70000000 /* Contains product specific ext. */
-+#define SHT_PARISC_UNWIND	0x70000001 /* Unwind information.  */
-+#define SHT_PARISC_DOC		0x70000002 /* Debug info for optimized code. */
-+
-+/* Legal values for sh_flags field of Elf32_Shdr.  */
-+
-+#define SHF_PARISC_SHORT	0x20000000 /* Section with short addressing. */
-+#define SHF_PARISC_HUGE		0x40000000 /* Section far from gp.  */
-+#define SHF_PARISC_SBP		0x80000000 /* Static branch prediction code. */
-+
-+/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
-+
-+#define STT_PARISC_MILLICODE	13	/* Millicode function entry point.  */
-+
-+#define STT_HP_OPAQUE		(STT_LOOS + 0x1)
-+#define STT_HP_STUB		(STT_LOOS + 0x2)
-+
-+/* HPPA relocs.  */
-+
-+#define R_PARISC_NONE		0	/* No reloc.  */
-+#define R_PARISC_DIR32		1	/* Direct 32-bit reference.  */
-+#define R_PARISC_DIR21L		2	/* Left 21 bits of eff. address.  */
-+#define R_PARISC_DIR17R		3	/* Right 17 bits of eff. address.  */
-+#define R_PARISC_DIR17F		4	/* 17 bits of eff. address.  */
-+#define R_PARISC_DIR14R		6	/* Right 14 bits of eff. address.  */
-+#define R_PARISC_PCREL32	9	/* 32-bit rel. address.  */
-+#define R_PARISC_PCREL21L	10	/* Left 21 bits of rel. address.  */
-+#define R_PARISC_PCREL17R	11	/* Right 17 bits of rel. address.  */
-+#define R_PARISC_PCREL17F	12	/* 17 bits of rel. address.  */
-+#define R_PARISC_PCREL14R	14	/* Right 14 bits of rel. address.  */
-+#define R_PARISC_DPREL21L	18	/* Left 21 bits of rel. address.  */
-+#define R_PARISC_DPREL14R	22	/* Right 14 bits of rel. address.  */
-+#define R_PARISC_GPREL21L	26	/* GP-relative, left 21 bits.  */
-+#define R_PARISC_GPREL14R	30	/* GP-relative, right 14 bits.  */
-+#define R_PARISC_LTOFF21L	34	/* LT-relative, left 21 bits.  */
-+#define R_PARISC_LTOFF14R	38	/* LT-relative, right 14 bits.  */
-+#define R_PARISC_SECREL32	41	/* 32 bits section rel. address.  */
-+#define R_PARISC_SEGBASE	48	/* No relocation, set segment base.  */
-+#define R_PARISC_SEGREL32	49	/* 32 bits segment rel. address.  */
-+#define R_PARISC_PLTOFF21L	50	/* PLT rel. address, left 21 bits.  */
-+#define R_PARISC_PLTOFF14R	54	/* PLT rel. address, right 14 bits.  */
-+#define R_PARISC_LTOFF_FPTR32	57	/* 32 bits LT-rel. function pointer. */
-+#define R_PARISC_LTOFF_FPTR21L	58	/* LT-rel. fct ptr, left 21 bits. */
-+#define R_PARISC_LTOFF_FPTR14R	62	/* LT-rel. fct ptr, right 14 bits. */
-+#define R_PARISC_FPTR64		64	/* 64 bits function address.  */
-+#define R_PARISC_PLABEL32	65	/* 32 bits function address.  */
-+#define R_PARISC_PLABEL21L	66	/* Left 21 bits of fdesc address.  */
-+#define R_PARISC_PLABEL14R	70	/* Right 14 bits of fdesc address.  */
-+#define R_PARISC_PCREL64	72	/* 64 bits PC-rel. address.  */
-+#define R_PARISC_PCREL22F	74	/* 22 bits PC-rel. address.  */
-+#define R_PARISC_PCREL14WR	75	/* PC-rel. address, right 14 bits.  */
-+#define R_PARISC_PCREL14DR	76	/* PC rel. address, right 14 bits.  */
-+#define R_PARISC_PCREL16F	77	/* 16 bits PC-rel. address.  */
-+#define R_PARISC_PCREL16WF	78	/* 16 bits PC-rel. address.  */
-+#define R_PARISC_PCREL16DF	79	/* 16 bits PC-rel. address.  */
-+#define R_PARISC_DIR64		80	/* 64 bits of eff. address.  */
-+#define R_PARISC_DIR14WR	83	/* 14 bits of eff. address.  */
-+#define R_PARISC_DIR14DR	84	/* 14 bits of eff. address.  */
-+#define R_PARISC_DIR16F		85	/* 16 bits of eff. address.  */
-+#define R_PARISC_DIR16WF	86	/* 16 bits of eff. address.  */
-+#define R_PARISC_DIR16DF	87	/* 16 bits of eff. address.  */
-+#define R_PARISC_GPREL64	88	/* 64 bits of GP-rel. address.  */
-+#define R_PARISC_GPREL14WR	91	/* GP-rel. address, right 14 bits.  */
-+#define R_PARISC_GPREL14DR	92	/* GP-rel. address, right 14 bits.  */
-+#define R_PARISC_GPREL16F	93	/* 16 bits GP-rel. address.  */
-+#define R_PARISC_GPREL16WF	94	/* 16 bits GP-rel. address.  */
-+#define R_PARISC_GPREL16DF	95	/* 16 bits GP-rel. address.  */
-+#define R_PARISC_LTOFF64	96	/* 64 bits LT-rel. address.  */
-+#define R_PARISC_LTOFF14WR	99	/* LT-rel. address, right 14 bits.  */
-+#define R_PARISC_LTOFF14DR	100	/* LT-rel. address, right 14 bits.  */
-+#define R_PARISC_LTOFF16F	101	/* 16 bits LT-rel. address.  */
-+#define R_PARISC_LTOFF16WF	102	/* 16 bits LT-rel. address.  */
-+#define R_PARISC_LTOFF16DF	103	/* 16 bits LT-rel. address.  */
-+#define R_PARISC_SECREL64	104	/* 64 bits section rel. address.  */
-+#define R_PARISC_SEGREL64	112	/* 64 bits segment rel. address.  */
-+#define R_PARISC_PLTOFF14WR	115	/* PLT-rel. address, right 14 bits.  */
-+#define R_PARISC_PLTOFF14DR	116	/* PLT-rel. address, right 14 bits.  */
-+#define R_PARISC_PLTOFF16F	117	/* 16 bits LT-rel. address.  */
-+#define R_PARISC_PLTOFF16WF	118	/* 16 bits PLT-rel. address.  */
-+#define R_PARISC_PLTOFF16DF	119	/* 16 bits PLT-rel. address.  */
-+#define R_PARISC_LTOFF_FPTR64	120	/* 64 bits LT-rel. function ptr.  */
-+#define R_PARISC_LTOFF_FPTR14WR	123	/* LT-rel. fct. ptr., right 14 bits. */
-+#define R_PARISC_LTOFF_FPTR14DR	124	/* LT-rel. fct. ptr., right 14 bits. */
-+#define R_PARISC_LTOFF_FPTR16F	125	/* 16 bits LT-rel. function ptr.  */
-+#define R_PARISC_LTOFF_FPTR16WF	126	/* 16 bits LT-rel. function ptr.  */
-+#define R_PARISC_LTOFF_FPTR16DF	127	/* 16 bits LT-rel. function ptr.  */
-+#define R_PARISC_LORESERVE	128
-+#define R_PARISC_COPY		128	/* Copy relocation.  */
-+#define R_PARISC_IPLT		129	/* Dynamic reloc, imported PLT */
-+#define R_PARISC_EPLT		130	/* Dynamic reloc, exported PLT */
-+#define R_PARISC_TPREL32	153	/* 32 bits TP-rel. address.  */
-+#define R_PARISC_TPREL21L	154	/* TP-rel. address, left 21 bits.  */
-+#define R_PARISC_TPREL14R	158	/* TP-rel. address, right 14 bits.  */
-+#define R_PARISC_LTOFF_TP21L	162	/* LT-TP-rel. address, left 21 bits. */
-+#define R_PARISC_LTOFF_TP14R	166	/* LT-TP-rel. address, right 14 bits.*/
-+#define R_PARISC_LTOFF_TP14F	167	/* 14 bits LT-TP-rel. address.  */
-+#define R_PARISC_TPREL64	216	/* 64 bits TP-rel. address.  */
-+#define R_PARISC_TPREL14WR	219	/* TP-rel. address, right 14 bits.  */
-+#define R_PARISC_TPREL14DR	220	/* TP-rel. address, right 14 bits.  */
-+#define R_PARISC_TPREL16F	221	/* 16 bits TP-rel. address.  */
-+#define R_PARISC_TPREL16WF	222	/* 16 bits TP-rel. address.  */
-+#define R_PARISC_TPREL16DF	223	/* 16 bits TP-rel. address.  */
-+#define R_PARISC_LTOFF_TP64	224	/* 64 bits LT-TP-rel. address.  */
-+#define R_PARISC_LTOFF_TP14WR	227	/* LT-TP-rel. address, right 14 bits.*/
-+#define R_PARISC_LTOFF_TP14DR	228	/* LT-TP-rel. address, right 14 bits.*/
-+#define R_PARISC_LTOFF_TP16F	229	/* 16 bits LT-TP-rel. address.  */
-+#define R_PARISC_LTOFF_TP16WF	230	/* 16 bits LT-TP-rel. address.  */
-+#define R_PARISC_LTOFF_TP16DF	231	/* 16 bits LT-TP-rel. address.  */
-+#define R_PARISC_GNU_VTENTRY	232
-+#define R_PARISC_GNU_VTINHERIT	233
-+#define R_PARISC_TLS_GD21L	234	/* GD 21-bit left.  */
-+#define R_PARISC_TLS_GD14R	235	/* GD 14-bit right.  */
-+#define R_PARISC_TLS_GDCALL	236	/* GD call to __t_g_a.  */
-+#define R_PARISC_TLS_LDM21L	237	/* LD module 21-bit left.  */
-+#define R_PARISC_TLS_LDM14R	238	/* LD module 14-bit right.  */
-+#define R_PARISC_TLS_LDMCALL	239	/* LD module call to __t_g_a.  */
-+#define R_PARISC_TLS_LDO21L	240	/* LD offset 21-bit left.  */
-+#define R_PARISC_TLS_LDO14R	241	/* LD offset 14-bit right.  */
-+#define R_PARISC_TLS_DTPMOD32	242	/* DTP module 32-bit.  */
-+#define R_PARISC_TLS_DTPMOD64	243	/* DTP module 64-bit.  */
-+#define R_PARISC_TLS_DTPOFF32	244	/* DTP offset 32-bit.  */
-+#define R_PARISC_TLS_DTPOFF64	245	/* DTP offset 32-bit.  */
-+#define R_PARISC_TLS_LE21L	R_PARISC_TPREL21L
-+#define R_PARISC_TLS_LE14R	R_PARISC_TPREL14R
-+#define R_PARISC_TLS_IE21L	R_PARISC_LTOFF_TP21L
-+#define R_PARISC_TLS_IE14R	R_PARISC_LTOFF_TP14R
-+#define R_PARISC_TLS_TPREL32	R_PARISC_TPREL32
-+#define R_PARISC_TLS_TPREL64	R_PARISC_TPREL64
-+#define R_PARISC_HIRESERVE	255
-+
-+/* Legal values for p_type field of Elf32_Phdr/Elf64_Phdr.  */
-+
-+#define PT_HP_TLS		(PT_LOOS + 0x0)
-+#define PT_HP_CORE_NONE		(PT_LOOS + 0x1)
-+#define PT_HP_CORE_VERSION	(PT_LOOS + 0x2)
-+#define PT_HP_CORE_KERNEL	(PT_LOOS + 0x3)
-+#define PT_HP_CORE_COMM		(PT_LOOS + 0x4)
-+#define PT_HP_CORE_PROC		(PT_LOOS + 0x5)
-+#define PT_HP_CORE_LOADABLE	(PT_LOOS + 0x6)
-+#define PT_HP_CORE_STACK	(PT_LOOS + 0x7)
-+#define PT_HP_CORE_SHM		(PT_LOOS + 0x8)
-+#define PT_HP_CORE_MMF		(PT_LOOS + 0x9)
-+#define PT_HP_PARALLEL		(PT_LOOS + 0x10)
-+#define PT_HP_FASTBIND		(PT_LOOS + 0x11)
-+#define PT_HP_OPT_ANNOT		(PT_LOOS + 0x12)
-+#define PT_HP_HSL_ANNOT		(PT_LOOS + 0x13)
-+#define PT_HP_STACK		(PT_LOOS + 0x14)
-+
-+#define PT_PARISC_ARCHEXT	0x70000000
-+#define PT_PARISC_UNWIND	0x70000001
-+
-+/* Legal values for p_flags field of Elf32_Phdr/Elf64_Phdr.  */
-+
-+#define PF_PARISC_SBP		0x08000000
-+
-+#define PF_HP_PAGE_SIZE		0x00100000
-+#define PF_HP_FAR_SHARED	0x00200000
-+#define PF_HP_NEAR_SHARED	0x00400000
-+#define PF_HP_CODE		0x01000000
-+#define PF_HP_MODIFY		0x02000000
-+#define PF_HP_LAZYSWAP		0x04000000
-+#define PF_HP_SBP		0x08000000
-+
-+
-+/* Alpha specific definitions.  */
-+
-+/* Legal values for e_flags field of Elf64_Ehdr.  */
-+
-+#define EF_ALPHA_32BIT		1	/* All addresses must be < 2GB.  */
-+#define EF_ALPHA_CANRELAX	2	/* Relocations for relaxing exist.  */
-+
-+/* Legal values for sh_type field of Elf64_Shdr.  */
-+
-+/* These two are primerily concerned with ECOFF debugging info.  */
-+#define SHT_ALPHA_DEBUG		0x70000001
-+#define SHT_ALPHA_REGINFO	0x70000002
-+
-+/* Legal values for sh_flags field of Elf64_Shdr.  */
-+
-+#define SHF_ALPHA_GPREL		0x10000000
-+
-+/* Legal values for st_other field of Elf64_Sym.  */
-+#define STO_ALPHA_NOPV		0x80	/* No PV required.  */
-+#define STO_ALPHA_STD_GPLOAD	0x88	/* PV only used for initial ldgp.  */
-+
-+/* Alpha relocs.  */
-+
-+#define R_ALPHA_NONE		0	/* No reloc */
-+#define R_ALPHA_REFLONG		1	/* Direct 32 bit */
-+#define R_ALPHA_REFQUAD		2	/* Direct 64 bit */
-+#define R_ALPHA_GPREL32		3	/* GP relative 32 bit */
-+#define R_ALPHA_LITERAL		4	/* GP relative 16 bit w/optimization */
-+#define R_ALPHA_LITUSE		5	/* Optimization hint for LITERAL */
-+#define R_ALPHA_GPDISP		6	/* Add displacement to GP */
-+#define R_ALPHA_BRADDR		7	/* PC+4 relative 23 bit shifted */
-+#define R_ALPHA_HINT		8	/* PC+4 relative 16 bit shifted */
-+#define R_ALPHA_SREL16		9	/* PC relative 16 bit */
-+#define R_ALPHA_SREL32		10	/* PC relative 32 bit */
-+#define R_ALPHA_SREL64		11	/* PC relative 64 bit */
-+#define R_ALPHA_GPRELHIGH	17	/* GP relative 32 bit, high 16 bits */
-+#define R_ALPHA_GPRELLOW	18	/* GP relative 32 bit, low 16 bits */
-+#define R_ALPHA_GPREL16		19	/* GP relative 16 bit */
-+#define R_ALPHA_COPY		24	/* Copy symbol at runtime */
-+#define R_ALPHA_GLOB_DAT	25	/* Create GOT entry */
-+#define R_ALPHA_JMP_SLOT	26	/* Create PLT entry */
-+#define R_ALPHA_RELATIVE	27	/* Adjust by program base */
-+#define R_ALPHA_TLS_GD_HI	28
-+#define R_ALPHA_TLSGD		29
-+#define R_ALPHA_TLS_LDM		30
-+#define R_ALPHA_DTPMOD64	31
-+#define R_ALPHA_GOTDTPREL	32
-+#define R_ALPHA_DTPREL64	33
-+#define R_ALPHA_DTPRELHI	34
-+#define R_ALPHA_DTPRELLO	35
-+#define R_ALPHA_DTPREL16	36
-+#define R_ALPHA_GOTTPREL	37
-+#define R_ALPHA_TPREL64		38
-+#define R_ALPHA_TPRELHI		39
-+#define R_ALPHA_TPRELLO		40
-+#define R_ALPHA_TPREL16		41
-+/* Keep this the last entry.  */
-+#define R_ALPHA_NUM		46
-+
-+/* Magic values of the LITUSE relocation addend.  */
-+#define LITUSE_ALPHA_ADDR	0
-+#define LITUSE_ALPHA_BASE	1
-+#define LITUSE_ALPHA_BYTOFF	2
-+#define LITUSE_ALPHA_JSR	3
-+#define LITUSE_ALPHA_TLS_GD	4
-+#define LITUSE_ALPHA_TLS_LDM	5
-+
-+/* Legal values for d_tag of Elf64_Dyn.  */
-+#define DT_ALPHA_PLTRO		(DT_LOPROC + 0)
-+#define DT_ALPHA_NUM		1
-+
-+/* PowerPC specific declarations */
-+
-+/* Values for Elf32/64_Ehdr.e_flags.  */
-+#define EF_PPC_EMB		0x80000000	/* PowerPC embedded flag */
-+
-+/* Cygnus local bits below */
-+#define EF_PPC_RELOCATABLE	0x00010000	/* PowerPC -mrelocatable flag*/
-+#define EF_PPC_RELOCATABLE_LIB	0x00008000	/* PowerPC -mrelocatable-lib
-+						   flag */
-+
-+/* PowerPC relocations defined by the ABIs */
-+#define R_PPC_NONE		0
-+#define R_PPC_ADDR32		1	/* 32bit absolute address */
-+#define R_PPC_ADDR24		2	/* 26bit address, 2 bits ignored.  */
-+#define R_PPC_ADDR16		3	/* 16bit absolute address */
-+#define R_PPC_ADDR16_LO		4	/* lower 16bit of absolute address */
-+#define R_PPC_ADDR16_HI		5	/* high 16bit of absolute address */
-+#define R_PPC_ADDR16_HA		6	/* adjusted high 16bit */
-+#define R_PPC_ADDR14		7	/* 16bit address, 2 bits ignored */
-+#define R_PPC_ADDR14_BRTAKEN	8
-+#define R_PPC_ADDR14_BRNTAKEN	9
-+#define R_PPC_REL24		10	/* PC relative 26 bit */
-+#define R_PPC_REL14		11	/* PC relative 16 bit */
-+#define R_PPC_REL14_BRTAKEN	12
-+#define R_PPC_REL14_BRNTAKEN	13
-+#define R_PPC_GOT16		14
-+#define R_PPC_GOT16_LO		15
-+#define R_PPC_GOT16_HI		16
-+#define R_PPC_GOT16_HA		17
-+#define R_PPC_PLTREL24		18
-+#define R_PPC_COPY		19
-+#define R_PPC_GLOB_DAT		20
-+#define R_PPC_JMP_SLOT		21
-+#define R_PPC_RELATIVE		22
-+#define R_PPC_LOCAL24PC		23
-+#define R_PPC_UADDR32		24
-+#define R_PPC_UADDR16		25
-+#define R_PPC_REL32		26
-+#define R_PPC_PLT32		27
-+#define R_PPC_PLTREL32		28
-+#define R_PPC_PLT16_LO		29
-+#define R_PPC_PLT16_HI		30
-+#define R_PPC_PLT16_HA		31
-+#define R_PPC_SDAREL16		32
-+#define R_PPC_SECTOFF		33
-+#define R_PPC_SECTOFF_LO	34
-+#define R_PPC_SECTOFF_HI	35
-+#define R_PPC_SECTOFF_HA	36
-+
-+/* PowerPC relocations defined for the TLS access ABI.  */
-+#define R_PPC_TLS		67 /* none	(sym+add)@tls */
-+#define R_PPC_DTPMOD32		68 /* word32	(sym+add)@dtpmod */
-+#define R_PPC_TPREL16		69 /* half16*	(sym+add)@tprel */
-+#define R_PPC_TPREL16_LO	70 /* half16	(sym+add)@tprel@l */
-+#define R_PPC_TPREL16_HI	71 /* half16	(sym+add)@tprel@h */
-+#define R_PPC_TPREL16_HA	72 /* half16	(sym+add)@tprel@ha */
-+#define R_PPC_TPREL32		73 /* word32	(sym+add)@tprel */
-+#define R_PPC_DTPREL16		74 /* half16*	(sym+add)@dtprel */
-+#define R_PPC_DTPREL16_LO	75 /* half16	(sym+add)@dtprel@l */
-+#define R_PPC_DTPREL16_HI	76 /* half16	(sym+add)@dtprel@h */
-+#define R_PPC_DTPREL16_HA	77 /* half16	(sym+add)@dtprel@ha */
-+#define R_PPC_DTPREL32		78 /* word32	(sym+add)@dtprel */
-+#define R_PPC_GOT_TLSGD16	79 /* half16*	(sym+add)@got@tlsgd */
-+#define R_PPC_GOT_TLSGD16_LO	80 /* half16	(sym+add)@got@tlsgd@l */
-+#define R_PPC_GOT_TLSGD16_HI	81 /* half16	(sym+add)@got@tlsgd@h */
-+#define R_PPC_GOT_TLSGD16_HA	82 /* half16	(sym+add)@got@tlsgd@ha */
-+#define R_PPC_GOT_TLSLD16	83 /* half16*	(sym+add)@got@tlsld */
-+#define R_PPC_GOT_TLSLD16_LO	84 /* half16	(sym+add)@got@tlsld@l */
-+#define R_PPC_GOT_TLSLD16_HI	85 /* half16	(sym+add)@got@tlsld@h */
-+#define R_PPC_GOT_TLSLD16_HA	86 /* half16	(sym+add)@got@tlsld@ha */
-+#define R_PPC_GOT_TPREL16	87 /* half16*	(sym+add)@got@tprel */
-+#define R_PPC_GOT_TPREL16_LO	88 /* half16	(sym+add)@got@tprel@l */
-+#define R_PPC_GOT_TPREL16_HI	89 /* half16	(sym+add)@got@tprel@h */
-+#define R_PPC_GOT_TPREL16_HA	90 /* half16	(sym+add)@got@tprel@ha */
-+#define R_PPC_GOT_DTPREL16	91 /* half16*	(sym+add)@got@dtprel */
-+#define R_PPC_GOT_DTPREL16_LO	92 /* half16*	(sym+add)@got@dtprel@l */
-+#define R_PPC_GOT_DTPREL16_HI	93 /* half16*	(sym+add)@got@dtprel@h */
-+#define R_PPC_GOT_DTPREL16_HA	94 /* half16*	(sym+add)@got@dtprel@ha */
-+
-+/* The remaining relocs are from the Embedded ELF ABI, and are not
-+   in the SVR4 ELF ABI.  */
-+#define R_PPC_EMB_NADDR32	101
-+#define R_PPC_EMB_NADDR16	102
-+#define R_PPC_EMB_NADDR16_LO	103
-+#define R_PPC_EMB_NADDR16_HI	104
-+#define R_PPC_EMB_NADDR16_HA	105
-+#define R_PPC_EMB_SDAI16	106
-+#define R_PPC_EMB_SDA2I16	107
-+#define R_PPC_EMB_SDA2REL	108
-+#define R_PPC_EMB_SDA21		109	/* 16 bit offset in SDA */
-+#define R_PPC_EMB_MRKREF	110
-+#define R_PPC_EMB_RELSEC16	111
-+#define R_PPC_EMB_RELST_LO	112
-+#define R_PPC_EMB_RELST_HI	113
-+#define R_PPC_EMB_RELST_HA	114
-+#define R_PPC_EMB_BIT_FLD	115
-+#define R_PPC_EMB_RELSDA	116	/* 16 bit relative offset in SDA */
-+
-+/* Diab tool relocations.  */
-+#define R_PPC_DIAB_SDA21_LO	180	/* like EMB_SDA21, but lower 16 bit */
-+#define R_PPC_DIAB_SDA21_HI	181	/* like EMB_SDA21, but high 16 bit */
-+#define R_PPC_DIAB_SDA21_HA	182	/* like EMB_SDA21, adjusted high 16 */
-+#define R_PPC_DIAB_RELSDA_LO	183	/* like EMB_RELSDA, but lower 16 bit */
-+#define R_PPC_DIAB_RELSDA_HI	184	/* like EMB_RELSDA, but high 16 bit */
-+#define R_PPC_DIAB_RELSDA_HA	185	/* like EMB_RELSDA, adjusted high 16 */
-+
-+/* GNU extension to support local ifunc.  */
-+#define R_PPC_IRELATIVE		248
-+
-+/* GNU relocs used in PIC code sequences.  */
-+#define R_PPC_REL16		249	/* half16   (sym+add-.) */
-+#define R_PPC_REL16_LO		250	/* half16   (sym+add-.)@l */
-+#define R_PPC_REL16_HI		251	/* half16   (sym+add-.)@h */
-+#define R_PPC_REL16_HA		252	/* half16   (sym+add-.)@ha */
-+
-+/* This is a phony reloc to handle any old fashioned TOC16 references
-+   that may still be in object files.  */
-+#define R_PPC_TOC16		255
-+
-+/* PowerPC specific values for the Dyn d_tag field.  */
-+#define DT_PPC_GOT		(DT_LOPROC + 0)
-+#define DT_PPC_NUM		1
-+
-+/* PowerPC64 relocations defined by the ABIs */
-+#define R_PPC64_NONE		R_PPC_NONE
-+#define R_PPC64_ADDR32		R_PPC_ADDR32 /* 32bit absolute address */
-+#define R_PPC64_ADDR24		R_PPC_ADDR24 /* 26bit address, word aligned */
-+#define R_PPC64_ADDR16		R_PPC_ADDR16 /* 16bit absolute address */
-+#define R_PPC64_ADDR16_LO	R_PPC_ADDR16_LO	/* lower 16bits of address */
-+#define R_PPC64_ADDR16_HI	R_PPC_ADDR16_HI	/* high 16bits of address. */
-+#define R_PPC64_ADDR16_HA	R_PPC_ADDR16_HA /* adjusted high 16bits.  */
-+#define R_PPC64_ADDR14		R_PPC_ADDR14 /* 16bit address, word aligned */
-+#define R_PPC64_ADDR14_BRTAKEN	R_PPC_ADDR14_BRTAKEN
-+#define R_PPC64_ADDR14_BRNTAKEN	R_PPC_ADDR14_BRNTAKEN
-+#define R_PPC64_REL24		R_PPC_REL24 /* PC-rel. 26 bit, word aligned */
-+#define R_PPC64_REL14		R_PPC_REL14 /* PC relative 16 bit */
-+#define R_PPC64_REL14_BRTAKEN	R_PPC_REL14_BRTAKEN
-+#define R_PPC64_REL14_BRNTAKEN	R_PPC_REL14_BRNTAKEN
-+#define R_PPC64_GOT16		R_PPC_GOT16
-+#define R_PPC64_GOT16_LO	R_PPC_GOT16_LO
-+#define R_PPC64_GOT16_HI	R_PPC_GOT16_HI
-+#define R_PPC64_GOT16_HA	R_PPC_GOT16_HA
-+
-+#define R_PPC64_COPY		R_PPC_COPY
-+#define R_PPC64_GLOB_DAT	R_PPC_GLOB_DAT
-+#define R_PPC64_JMP_SLOT	R_PPC_JMP_SLOT
-+#define R_PPC64_RELATIVE	R_PPC_RELATIVE
-+
-+#define R_PPC64_UADDR32		R_PPC_UADDR32
-+#define R_PPC64_UADDR16		R_PPC_UADDR16
-+#define R_PPC64_REL32		R_PPC_REL32
-+#define R_PPC64_PLT32		R_PPC_PLT32
-+#define R_PPC64_PLTREL32	R_PPC_PLTREL32
-+#define R_PPC64_PLT16_LO	R_PPC_PLT16_LO
-+#define R_PPC64_PLT16_HI	R_PPC_PLT16_HI
-+#define R_PPC64_PLT16_HA	R_PPC_PLT16_HA
-+
-+#define R_PPC64_SECTOFF		R_PPC_SECTOFF
-+#define R_PPC64_SECTOFF_LO	R_PPC_SECTOFF_LO
-+#define R_PPC64_SECTOFF_HI	R_PPC_SECTOFF_HI
-+#define R_PPC64_SECTOFF_HA	R_PPC_SECTOFF_HA
-+#define R_PPC64_ADDR30		37 /* word30 (S + A - P) >> 2 */
-+#define R_PPC64_ADDR64		38 /* doubleword64 S + A */
-+#define R_PPC64_ADDR16_HIGHER	39 /* half16 #higher(S + A) */
-+#define R_PPC64_ADDR16_HIGHERA	40 /* half16 #highera(S + A) */
-+#define R_PPC64_ADDR16_HIGHEST	41 /* half16 #highest(S + A) */
-+#define R_PPC64_ADDR16_HIGHESTA	42 /* half16 #highesta(S + A) */
-+#define R_PPC64_UADDR64		43 /* doubleword64 S + A */
-+#define R_PPC64_REL64		44 /* doubleword64 S + A - P */
-+#define R_PPC64_PLT64		45 /* doubleword64 L + A */
-+#define R_PPC64_PLTREL64	46 /* doubleword64 L + A - P */
-+#define R_PPC64_TOC16		47 /* half16* S + A - .TOC */
-+#define R_PPC64_TOC16_LO	48 /* half16 #lo(S + A - .TOC.) */
-+#define R_PPC64_TOC16_HI	49 /* half16 #hi(S + A - .TOC.) */
-+#define R_PPC64_TOC16_HA	50 /* half16 #ha(S + A - .TOC.) */
-+#define R_PPC64_TOC		51 /* doubleword64 .TOC */
-+#define R_PPC64_PLTGOT16	52 /* half16* M + A */
-+#define R_PPC64_PLTGOT16_LO	53 /* half16 #lo(M + A) */
-+#define R_PPC64_PLTGOT16_HI	54 /* half16 #hi(M + A) */
-+#define R_PPC64_PLTGOT16_HA	55 /* half16 #ha(M + A) */
-+
-+#define R_PPC64_ADDR16_DS	56 /* half16ds* (S + A) >> 2 */
-+#define R_PPC64_ADDR16_LO_DS	57 /* half16ds  #lo(S + A) >> 2 */
-+#define R_PPC64_GOT16_DS	58 /* half16ds* (G + A) >> 2 */
-+#define R_PPC64_GOT16_LO_DS	59 /* half16ds  #lo(G + A) >> 2 */
-+#define R_PPC64_PLT16_LO_DS	60 /* half16ds  #lo(L + A) >> 2 */
-+#define R_PPC64_SECTOFF_DS	61 /* half16ds* (R + A) >> 2 */
-+#define R_PPC64_SECTOFF_LO_DS	62 /* half16ds  #lo(R + A) >> 2 */
-+#define R_PPC64_TOC16_DS	63 /* half16ds* (S + A - .TOC.) >> 2 */
-+#define R_PPC64_TOC16_LO_DS	64 /* half16ds  #lo(S + A - .TOC.) >> 2 */
-+#define R_PPC64_PLTGOT16_DS	65 /* half16ds* (M + A) >> 2 */
-+#define R_PPC64_PLTGOT16_LO_DS	66 /* half16ds  #lo(M + A) >> 2 */
-+
-+/* PowerPC64 relocations defined for the TLS access ABI.  */
-+#define R_PPC64_TLS		67 /* none	(sym+add)@tls */
-+#define R_PPC64_DTPMOD64	68 /* doubleword64 (sym+add)@dtpmod */
-+#define R_PPC64_TPREL16		69 /* half16*	(sym+add)@tprel */
-+#define R_PPC64_TPREL16_LO	70 /* half16	(sym+add)@tprel@l */
-+#define R_PPC64_TPREL16_HI	71 /* half16	(sym+add)@tprel@h */
-+#define R_PPC64_TPREL16_HA	72 /* half16	(sym+add)@tprel@ha */
-+#define R_PPC64_TPREL64		73 /* doubleword64 (sym+add)@tprel */
-+#define R_PPC64_DTPREL16	74 /* half16*	(sym+add)@dtprel */
-+#define R_PPC64_DTPREL16_LO	75 /* half16	(sym+add)@dtprel@l */
-+#define R_PPC64_DTPREL16_HI	76 /* half16	(sym+add)@dtprel@h */
-+#define R_PPC64_DTPREL16_HA	77 /* half16	(sym+add)@dtprel@ha */
-+#define R_PPC64_DTPREL64	78 /* doubleword64 (sym+add)@dtprel */
-+#define R_PPC64_GOT_TLSGD16	79 /* half16*	(sym+add)@got@tlsgd */
-+#define R_PPC64_GOT_TLSGD16_LO	80 /* half16	(sym+add)@got@tlsgd@l */
-+#define R_PPC64_GOT_TLSGD16_HI	81 /* half16	(sym+add)@got@tlsgd@h */
-+#define R_PPC64_GOT_TLSGD16_HA	82 /* half16	(sym+add)@got@tlsgd@ha */
-+#define R_PPC64_GOT_TLSLD16	83 /* half16*	(sym+add)@got@tlsld */
-+#define R_PPC64_GOT_TLSLD16_LO	84 /* half16	(sym+add)@got@tlsld@l */
-+#define R_PPC64_GOT_TLSLD16_HI	85 /* half16	(sym+add)@got@tlsld@h */
-+#define R_PPC64_GOT_TLSLD16_HA	86 /* half16	(sym+add)@got@tlsld@ha */
-+#define R_PPC64_GOT_TPREL16_DS	87 /* half16ds*	(sym+add)@got@tprel */
-+#define R_PPC64_GOT_TPREL16_LO_DS 88 /* half16ds (sym+add)@got@tprel@l */
-+#define R_PPC64_GOT_TPREL16_HI	89 /* half16	(sym+add)@got@tprel@h */
-+#define R_PPC64_GOT_TPREL16_HA	90 /* half16	(sym+add)@got@tprel@ha */
-+#define R_PPC64_GOT_DTPREL16_DS	91 /* half16ds*	(sym+add)@got@dtprel */
-+#define R_PPC64_GOT_DTPREL16_LO_DS 92 /* half16ds (sym+add)@got@dtprel@l */
-+#define R_PPC64_GOT_DTPREL16_HI	93 /* half16	(sym+add)@got@dtprel@h */
-+#define R_PPC64_GOT_DTPREL16_HA	94 /* half16	(sym+add)@got@dtprel@ha */
-+#define R_PPC64_TPREL16_DS	95 /* half16ds*	(sym+add)@tprel */
-+#define R_PPC64_TPREL16_LO_DS	96 /* half16ds	(sym+add)@tprel@l */
-+#define R_PPC64_TPREL16_HIGHER	97 /* half16	(sym+add)@tprel@higher */
-+#define R_PPC64_TPREL16_HIGHERA	98 /* half16	(sym+add)@tprel@highera */
-+#define R_PPC64_TPREL16_HIGHEST	99 /* half16	(sym+add)@tprel@highest */
-+#define R_PPC64_TPREL16_HIGHESTA 100 /* half16	(sym+add)@tprel@highesta */
-+#define R_PPC64_DTPREL16_DS	101 /* half16ds* (sym+add)@dtprel */
-+#define R_PPC64_DTPREL16_LO_DS	102 /* half16ds	(sym+add)@dtprel@l */
-+#define R_PPC64_DTPREL16_HIGHER	103 /* half16	(sym+add)@dtprel@higher */
-+#define R_PPC64_DTPREL16_HIGHERA 104 /* half16	(sym+add)@dtprel@highera */
-+#define R_PPC64_DTPREL16_HIGHEST 105 /* half16	(sym+add)@dtprel@highest */
-+#define R_PPC64_DTPREL16_HIGHESTA 106 /* half16	(sym+add)@dtprel@highesta */
-+
-+/* GNU extension to support local ifunc.  */
-+#define R_PPC64_JMP_IREL	247
-+#define R_PPC64_IRELATIVE	248
-+#define R_PPC64_REL16		249	/* half16   (sym+add-.) */
-+#define R_PPC64_REL16_LO	250	/* half16   (sym+add-.)@l */
-+#define R_PPC64_REL16_HI	251	/* half16   (sym+add-.)@h */
-+#define R_PPC64_REL16_HA	252	/* half16   (sym+add-.)@ha */
-+
-+/* PowerPC64 specific values for the Dyn d_tag field.  */
-+#define DT_PPC64_GLINK  (DT_LOPROC + 0)
-+#define DT_PPC64_OPD	(DT_LOPROC + 1)
-+#define DT_PPC64_OPDSZ	(DT_LOPROC + 2)
-+#define DT_PPC64_NUM    3
-+
-+
-+/* ARM specific declarations */
-+
-+/* Processor specific flags for the ELF header e_flags field.  */
-+#define EF_ARM_RELEXEC		0x01
-+#define EF_ARM_HASENTRY		0x02
-+#define EF_ARM_INTERWORK	0x04
-+#define EF_ARM_APCS_26		0x08
-+#define EF_ARM_APCS_FLOAT	0x10
-+#define EF_ARM_PIC		0x20
-+#define EF_ARM_ALIGN8		0x40 /* 8-bit structure alignment is in use */
-+#define EF_ARM_NEW_ABI		0x80
-+#define EF_ARM_OLD_ABI		0x100
-+#define EF_ARM_SOFT_FLOAT	0x200
-+#define EF_ARM_VFP_FLOAT	0x400
-+#define EF_ARM_MAVERICK_FLOAT	0x800
-+
-+
-+/* Other constants defined in the ARM ELF spec. version B-01.  */
-+/* NB. These conflict with values defined above.  */
-+#define EF_ARM_SYMSARESORTED	0x04
-+#define EF_ARM_DYNSYMSUSESEGIDX	0x08
-+#define EF_ARM_MAPSYMSFIRST	0x10
-+#define EF_ARM_EABIMASK		0XFF000000
-+
-+/* Constants defined in AAELF.  */
-+#define EF_ARM_BE8	    0x00800000
-+#define EF_ARM_LE8	    0x00400000
-+
-+#define EF_ARM_EABI_VERSION(flags)	((flags) & EF_ARM_EABIMASK)
-+#define EF_ARM_EABI_UNKNOWN	0x00000000
-+#define EF_ARM_EABI_VER1	0x01000000
-+#define EF_ARM_EABI_VER2	0x02000000
-+#define EF_ARM_EABI_VER3	0x03000000
-+#define EF_ARM_EABI_VER4	0x04000000
-+#define EF_ARM_EABI_VER5	0x05000000
-+
-+/* Additional symbol types for Thumb.  */
-+#define STT_ARM_TFUNC		STT_LOPROC /* A Thumb function.  */
-+#define STT_ARM_16BIT		STT_HIPROC /* A Thumb label.  */
-+
-+/* ARM-specific values for sh_flags */
-+#define SHF_ARM_ENTRYSECT	0x10000000 /* Section contains an entry point */
-+#define SHF_ARM_COMDEF		0x80000000 /* Section may be multiply defined
-+					      in the input to a link step.  */
-+
-+/* ARM-specific program header flags */
-+#define PF_ARM_SB		0x10000000 /* Segment contains the location
-+					      addressed by the static base. */
-+#define PF_ARM_PI		0x20000000 /* Position-independent segment.  */
-+#define PF_ARM_ABS		0x40000000 /* Absolute segment.  */
-+
-+/* Processor specific values for the Phdr p_type field.  */
-+#define PT_ARM_EXIDX		(PT_LOPROC + 1)	/* ARM unwind segment.  */
-+
-+/* Processor specific values for the Shdr sh_type field.  */
-+#define SHT_ARM_EXIDX		(SHT_LOPROC + 1) /* ARM unwind section.  */
-+#define SHT_ARM_PREEMPTMAP	(SHT_LOPROC + 2) /* Preemption details.  */
-+#define SHT_ARM_ATTRIBUTES	(SHT_LOPROC + 3) /* ARM attributes section.  */
-+
-+
-+/* ARM relocs.  */
-+
-+#define R_ARM_NONE		0	/* No reloc */
-+#define R_ARM_PC24		1	/* PC relative 26 bit branch */
-+#define R_ARM_ABS32		2	/* Direct 32 bit  */
-+#define R_ARM_REL32		3	/* PC relative 32 bit */
-+#define R_ARM_PC13		4
-+#define R_ARM_ABS16		5	/* Direct 16 bit */
-+#define R_ARM_ABS12		6	/* Direct 12 bit */
-+#define R_ARM_THM_ABS5		7
-+#define R_ARM_ABS8		8	/* Direct 8 bit */
-+#define R_ARM_SBREL32		9
-+#define R_ARM_THM_PC22		10
-+#define R_ARM_THM_PC8		11
-+#define R_ARM_AMP_VCALL9	12
-+#define R_ARM_SWI24		13	/* Obsolete static relocation.  */
-+#define R_ARM_TLS_DESC		13      /* Dynamic relocation.  */
-+#define R_ARM_THM_SWI8		14
-+#define R_ARM_XPC25		15
-+#define R_ARM_THM_XPC22		16
-+#define R_ARM_TLS_DTPMOD32	17	/* ID of module containing symbol */
-+#define R_ARM_TLS_DTPOFF32	18	/* Offset in TLS block */
-+#define R_ARM_TLS_TPOFF32	19	/* Offset in static TLS block */
-+#define R_ARM_COPY		20	/* Copy symbol at runtime */
-+#define R_ARM_GLOB_DAT		21	/* Create GOT entry */
-+#define R_ARM_JUMP_SLOT		22	/* Create PLT entry */
-+#define R_ARM_RELATIVE		23	/* Adjust by program base */
-+#define R_ARM_GOTOFF		24	/* 32 bit offset to GOT */
-+#define R_ARM_GOTPC		25	/* 32 bit PC relative offset to GOT */
-+#define R_ARM_GOT32		26	/* 32 bit GOT entry */
-+#define R_ARM_PLT32		27	/* 32 bit PLT address */
-+#define R_ARM_ALU_PCREL_7_0	32
-+#define R_ARM_ALU_PCREL_15_8	33
-+#define R_ARM_ALU_PCREL_23_15	34
-+#define R_ARM_LDR_SBREL_11_0	35
-+#define R_ARM_ALU_SBREL_19_12	36
-+#define R_ARM_ALU_SBREL_27_20	37
-+#define R_ARM_TLS_GOTDESC	90
-+#define R_ARM_TLS_CALL		91
-+#define R_ARM_TLS_DESCSEQ	92
-+#define R_ARM_THM_TLS_CALL	93
-+#define R_ARM_GNU_VTENTRY	100
-+#define R_ARM_GNU_VTINHERIT	101
-+#define R_ARM_THM_PC11		102	/* thumb unconditional branch */
-+#define R_ARM_THM_PC9		103	/* thumb conditional branch */
-+#define R_ARM_TLS_GD32		104	/* PC-rel 32 bit for global dynamic
-+					   thread local data */
-+#define R_ARM_TLS_LDM32		105	/* PC-rel 32 bit for local dynamic
-+					   thread local data */
-+#define R_ARM_TLS_LDO32		106	/* 32 bit offset relative to TLS
-+					   block */
-+#define R_ARM_TLS_IE32		107	/* PC-rel 32 bit for GOT entry of
-+					   static TLS block offset */
-+#define R_ARM_TLS_LE32		108	/* 32 bit offset relative to static
-+					   TLS block */
-+#define	R_ARM_THM_TLS_DESCSEQ	129
-+#define R_ARM_IRELATIVE		160
-+#define R_ARM_RXPC25		249
-+#define R_ARM_RSBREL32		250
-+#define R_ARM_THM_RPC22		251
-+#define R_ARM_RREL32		252
-+#define R_ARM_RABS22		253
-+#define R_ARM_RPC24		254
-+#define R_ARM_RBASE		255
-+/* Keep this the last entry.  */
-+#define R_ARM_NUM		256
-+
-+/* IA-64 specific declarations.  */
-+
-+/* Processor specific flags for the Ehdr e_flags field.  */
-+#define EF_IA_64_MASKOS		0x0000000f	/* os-specific flags */
-+#define EF_IA_64_ABI64		0x00000010	/* 64-bit ABI */
-+#define EF_IA_64_ARCH		0xff000000	/* arch. version mask */
-+
-+/* Processor specific values for the Phdr p_type field.  */
-+#define PT_IA_64_ARCHEXT	(PT_LOPROC + 0)	/* arch extension bits */
-+#define PT_IA_64_UNWIND		(PT_LOPROC + 1)	/* ia64 unwind bits */
-+#define PT_IA_64_HP_OPT_ANOT	(PT_LOOS + 0x12)
-+#define PT_IA_64_HP_HSL_ANOT	(PT_LOOS + 0x13)
-+#define PT_IA_64_HP_STACK	(PT_LOOS + 0x14)
-+
-+/* Processor specific flags for the Phdr p_flags field.  */
-+#define PF_IA_64_NORECOV	0x80000000	/* spec insns w/o recovery */
-+
-+/* Processor specific values for the Shdr sh_type field.  */
-+#define SHT_IA_64_EXT		(SHT_LOPROC + 0) /* extension bits */
-+#define SHT_IA_64_UNWIND	(SHT_LOPROC + 1) /* unwind bits */
-+
-+/* Processor specific flags for the Shdr sh_flags field.  */
-+#define SHF_IA_64_SHORT		0x10000000	/* section near gp */
-+#define SHF_IA_64_NORECOV	0x20000000	/* spec insns w/o recovery */
-+
-+/* Processor specific values for the Dyn d_tag field.  */
-+#define DT_IA_64_PLT_RESERVE	(DT_LOPROC + 0)
-+#define DT_IA_64_NUM		1
-+
-+/* IA-64 relocations.  */
-+#define R_IA64_NONE		0x00	/* none */
-+#define R_IA64_IMM14		0x21	/* symbol + addend, add imm14 */
-+#define R_IA64_IMM22		0x22	/* symbol + addend, add imm22 */
-+#define R_IA64_IMM64		0x23	/* symbol + addend, mov imm64 */
-+#define R_IA64_DIR32MSB		0x24	/* symbol + addend, data4 MSB */
-+#define R_IA64_DIR32LSB		0x25	/* symbol + addend, data4 LSB */
-+#define R_IA64_DIR64MSB		0x26	/* symbol + addend, data8 MSB */
-+#define R_IA64_DIR64LSB		0x27	/* symbol + addend, data8 LSB */
-+#define R_IA64_GPREL22		0x2a	/* @gprel(sym + add), add imm22 */
-+#define R_IA64_GPREL64I		0x2b	/* @gprel(sym + add), mov imm64 */
-+#define R_IA64_GPREL32MSB	0x2c	/* @gprel(sym + add), data4 MSB */
-+#define R_IA64_GPREL32LSB	0x2d	/* @gprel(sym + add), data4 LSB */
-+#define R_IA64_GPREL64MSB	0x2e	/* @gprel(sym + add), data8 MSB */
-+#define R_IA64_GPREL64LSB	0x2f	/* @gprel(sym + add), data8 LSB */
-+#define R_IA64_LTOFF22		0x32	/* @ltoff(sym + add), add imm22 */
-+#define R_IA64_LTOFF64I		0x33	/* @ltoff(sym + add), mov imm64 */
-+#define R_IA64_PLTOFF22		0x3a	/* @pltoff(sym + add), add imm22 */
-+#define R_IA64_PLTOFF64I	0x3b	/* @pltoff(sym + add), mov imm64 */
-+#define R_IA64_PLTOFF64MSB	0x3e	/* @pltoff(sym + add), data8 MSB */
-+#define R_IA64_PLTOFF64LSB	0x3f	/* @pltoff(sym + add), data8 LSB */
-+#define R_IA64_FPTR64I		0x43	/* @fptr(sym + add), mov imm64 */
-+#define R_IA64_FPTR32MSB	0x44	/* @fptr(sym + add), data4 MSB */
-+#define R_IA64_FPTR32LSB	0x45	/* @fptr(sym + add), data4 LSB */
-+#define R_IA64_FPTR64MSB	0x46	/* @fptr(sym + add), data8 MSB */
-+#define R_IA64_FPTR64LSB	0x47	/* @fptr(sym + add), data8 LSB */
-+#define R_IA64_PCREL60B		0x48	/* @pcrel(sym + add), brl */
-+#define R_IA64_PCREL21B		0x49	/* @pcrel(sym + add), ptb, call */
-+#define R_IA64_PCREL21M		0x4a	/* @pcrel(sym + add), chk.s */
-+#define R_IA64_PCREL21F		0x4b	/* @pcrel(sym + add), fchkf */
-+#define R_IA64_PCREL32MSB	0x4c	/* @pcrel(sym + add), data4 MSB */
-+#define R_IA64_PCREL32LSB	0x4d	/* @pcrel(sym + add), data4 LSB */
-+#define R_IA64_PCREL64MSB	0x4e	/* @pcrel(sym + add), data8 MSB */
-+#define R_IA64_PCREL64LSB	0x4f	/* @pcrel(sym + add), data8 LSB */
-+#define R_IA64_LTOFF_FPTR22	0x52	/* @ltoff(@fptr(s+a)), imm22 */
-+#define R_IA64_LTOFF_FPTR64I	0x53	/* @ltoff(@fptr(s+a)), imm64 */
-+#define R_IA64_LTOFF_FPTR32MSB	0x54	/* @ltoff(@fptr(s+a)), data4 MSB */
-+#define R_IA64_LTOFF_FPTR32LSB	0x55	/* @ltoff(@fptr(s+a)), data4 LSB */
-+#define R_IA64_LTOFF_FPTR64MSB	0x56	/* @ltoff(@fptr(s+a)), data8 MSB */
-+#define R_IA64_LTOFF_FPTR64LSB	0x57	/* @ltoff(@fptr(s+a)), data8 LSB */
-+#define R_IA64_SEGREL32MSB	0x5c	/* @segrel(sym + add), data4 MSB */
-+#define R_IA64_SEGREL32LSB	0x5d	/* @segrel(sym + add), data4 LSB */
-+#define R_IA64_SEGREL64MSB	0x5e	/* @segrel(sym + add), data8 MSB */
-+#define R_IA64_SEGREL64LSB	0x5f	/* @segrel(sym + add), data8 LSB */
-+#define R_IA64_SECREL32MSB	0x64	/* @secrel(sym + add), data4 MSB */
-+#define R_IA64_SECREL32LSB	0x65	/* @secrel(sym + add), data4 LSB */
-+#define R_IA64_SECREL64MSB	0x66	/* @secrel(sym + add), data8 MSB */
-+#define R_IA64_SECREL64LSB	0x67	/* @secrel(sym + add), data8 LSB */
-+#define R_IA64_REL32MSB		0x6c	/* data 4 + REL */
-+#define R_IA64_REL32LSB		0x6d	/* data 4 + REL */
-+#define R_IA64_REL64MSB		0x6e	/* data 8 + REL */
-+#define R_IA64_REL64LSB		0x6f	/* data 8 + REL */
-+#define R_IA64_LTV32MSB		0x74	/* symbol + addend, data4 MSB */
-+#define R_IA64_LTV32LSB		0x75	/* symbol + addend, data4 LSB */
-+#define R_IA64_LTV64MSB		0x76	/* symbol + addend, data8 MSB */
-+#define R_IA64_LTV64LSB		0x77	/* symbol + addend, data8 LSB */
-+#define R_IA64_PCREL21BI	0x79	/* @pcrel(sym + add), 21bit inst */
-+#define R_IA64_PCREL22		0x7a	/* @pcrel(sym + add), 22bit inst */
-+#define R_IA64_PCREL64I		0x7b	/* @pcrel(sym + add), 64bit inst */
-+#define R_IA64_IPLTMSB		0x80	/* dynamic reloc, imported PLT, MSB */
-+#define R_IA64_IPLTLSB		0x81	/* dynamic reloc, imported PLT, LSB */
-+#define R_IA64_COPY		0x84	/* copy relocation */
-+#define R_IA64_SUB		0x85	/* Addend and symbol difference */
-+#define R_IA64_LTOFF22X		0x86	/* LTOFF22, relaxable.  */
-+#define R_IA64_LDXMOV		0x87	/* Use of LTOFF22X.  */
-+#define R_IA64_TPREL14		0x91	/* @tprel(sym + add), imm14 */
-+#define R_IA64_TPREL22		0x92	/* @tprel(sym + add), imm22 */
-+#define R_IA64_TPREL64I		0x93	/* @tprel(sym + add), imm64 */
-+#define R_IA64_TPREL64MSB	0x96	/* @tprel(sym + add), data8 MSB */
-+#define R_IA64_TPREL64LSB	0x97	/* @tprel(sym + add), data8 LSB */
-+#define R_IA64_LTOFF_TPREL22	0x9a	/* @ltoff(@tprel(s+a)), imm2 */
-+#define R_IA64_DTPMOD64MSB	0xa6	/* @dtpmod(sym + add), data8 MSB */
-+#define R_IA64_DTPMOD64LSB	0xa7	/* @dtpmod(sym + add), data8 LSB */
-+#define R_IA64_LTOFF_DTPMOD22	0xaa	/* @ltoff(@dtpmod(sym + add)), imm22 */
-+#define R_IA64_DTPREL14		0xb1	/* @dtprel(sym + add), imm14 */
-+#define R_IA64_DTPREL22		0xb2	/* @dtprel(sym + add), imm22 */
-+#define R_IA64_DTPREL64I	0xb3	/* @dtprel(sym + add), imm64 */
-+#define R_IA64_DTPREL32MSB	0xb4	/* @dtprel(sym + add), data4 MSB */
-+#define R_IA64_DTPREL32LSB	0xb5	/* @dtprel(sym + add), data4 LSB */
-+#define R_IA64_DTPREL64MSB	0xb6	/* @dtprel(sym + add), data8 MSB */
-+#define R_IA64_DTPREL64LSB	0xb7	/* @dtprel(sym + add), data8 LSB */
-+#define R_IA64_LTOFF_DTPREL22	0xba	/* @ltoff(@dtprel(s+a)), imm22 */
-+
-+/* SH specific declarations */
-+
-+/* Processor specific flags for the ELF header e_flags field.  */
-+#define EF_SH_MACH_MASK		0x1f
-+#define EF_SH_UNKNOWN		0x0
-+#define EF_SH1			0x1
-+#define EF_SH2			0x2
-+#define EF_SH3			0x3
-+#define EF_SH_DSP		0x4
-+#define EF_SH3_DSP		0x5
-+#define EF_SH4AL_DSP		0x6
-+#define EF_SH3E			0x8
-+#define EF_SH4			0x9
-+#define EF_SH2E			0xb
-+#define EF_SH4A			0xc
-+#define EF_SH2A			0xd
-+#define EF_SH4_NOFPU		0x10
-+#define EF_SH4A_NOFPU		0x11
-+#define EF_SH4_NOMMU_NOFPU	0x12
-+#define EF_SH2A_NOFPU		0x13
-+#define EF_SH3_NOMMU		0x14
-+#define EF_SH2A_SH4_NOFPU	0x15
-+#define EF_SH2A_SH3_NOFPU	0x16
-+#define EF_SH2A_SH4		0x17
-+#define EF_SH2A_SH3E		0x18
-+
-+/* SH relocs.  */
-+#define	R_SH_NONE		0
-+#define	R_SH_DIR32		1
-+#define	R_SH_REL32		2
-+#define	R_SH_DIR8WPN		3
-+#define	R_SH_IND12W		4
-+#define	R_SH_DIR8WPL		5
-+#define	R_SH_DIR8WPZ		6
-+#define	R_SH_DIR8BP		7
-+#define	R_SH_DIR8W		8
-+#define	R_SH_DIR8L		9
-+#define	R_SH_SWITCH16		25
-+#define	R_SH_SWITCH32		26
-+#define	R_SH_USES		27
-+#define	R_SH_COUNT		28
-+#define	R_SH_ALIGN		29
-+#define	R_SH_CODE		30
-+#define	R_SH_DATA		31
-+#define	R_SH_LABEL		32
-+#define	R_SH_SWITCH8		33
-+#define	R_SH_GNU_VTINHERIT	34
-+#define	R_SH_GNU_VTENTRY	35
-+#define	R_SH_TLS_GD_32		144
-+#define	R_SH_TLS_LD_32		145
-+#define	R_SH_TLS_LDO_32		146
-+#define	R_SH_TLS_IE_32		147
-+#define	R_SH_TLS_LE_32		148
-+#define	R_SH_TLS_DTPMOD32	149
-+#define	R_SH_TLS_DTPOFF32	150
-+#define	R_SH_TLS_TPOFF32	151
-+#define	R_SH_GOT32		160
-+#define	R_SH_PLT32		161
-+#define	R_SH_COPY		162
-+#define	R_SH_GLOB_DAT		163
-+#define	R_SH_JMP_SLOT		164
-+#define	R_SH_RELATIVE		165
-+#define	R_SH_GOTOFF		166
-+#define	R_SH_GOTPC		167
-+/* Keep this the last entry.  */
-+#define	R_SH_NUM		256
-+
-+/* S/390 specific definitions.  */
-+
-+/* Valid values for the e_flags field.  */
-+
-+#define EF_S390_HIGH_GPRS    0x00000001  /* High GPRs kernel facility needed.  */
-+
-+/* Additional s390 relocs */
-+
-+#define R_390_NONE		0	/* No reloc.  */
-+#define R_390_8			1	/* Direct 8 bit.  */
-+#define R_390_12		2	/* Direct 12 bit.  */
-+#define R_390_16		3	/* Direct 16 bit.  */
-+#define R_390_32		4	/* Direct 32 bit.  */
-+#define R_390_PC32		5	/* PC relative 32 bit.	*/
-+#define R_390_GOT12		6	/* 12 bit GOT offset.  */
-+#define R_390_GOT32		7	/* 32 bit GOT offset.  */
-+#define R_390_PLT32		8	/* 32 bit PC relative PLT address.  */
-+#define R_390_COPY		9	/* Copy symbol at runtime.  */
-+#define R_390_GLOB_DAT		10	/* Create GOT entry.  */
-+#define R_390_JMP_SLOT		11	/* Create PLT entry.  */
-+#define R_390_RELATIVE		12	/* Adjust by program base.  */
-+#define R_390_GOTOFF32		13	/* 32 bit offset to GOT.	 */
-+#define R_390_GOTPC		14	/* 32 bit PC relative offset to GOT.  */
-+#define R_390_GOT16		15	/* 16 bit GOT offset.  */
-+#define R_390_PC16		16	/* PC relative 16 bit.	*/
-+#define R_390_PC16DBL		17	/* PC relative 16 bit shifted by 1.  */
-+#define R_390_PLT16DBL		18	/* 16 bit PC rel. PLT shifted by 1.  */
-+#define R_390_PC32DBL		19	/* PC relative 32 bit shifted by 1.  */
-+#define R_390_PLT32DBL		20	/* 32 bit PC rel. PLT shifted by 1.  */
-+#define R_390_GOTPCDBL		21	/* 32 bit PC rel. GOT shifted by 1.  */
-+#define R_390_64		22	/* Direct 64 bit.  */
-+#define R_390_PC64		23	/* PC relative 64 bit.	*/
-+#define R_390_GOT64		24	/* 64 bit GOT offset.  */
-+#define R_390_PLT64		25	/* 64 bit PC relative PLT address.  */
-+#define R_390_GOTENT		26	/* 32 bit PC rel. to GOT entry >> 1. */
-+#define R_390_GOTOFF16		27	/* 16 bit offset to GOT. */
-+#define R_390_GOTOFF64		28	/* 64 bit offset to GOT. */
-+#define R_390_GOTPLT12		29	/* 12 bit offset to jump slot.	*/
-+#define R_390_GOTPLT16		30	/* 16 bit offset to jump slot.	*/
-+#define R_390_GOTPLT32		31	/* 32 bit offset to jump slot.	*/
-+#define R_390_GOTPLT64		32	/* 64 bit offset to jump slot.	*/
-+#define R_390_GOTPLTENT		33	/* 32 bit rel. offset to jump slot.  */
-+#define R_390_PLTOFF16		34	/* 16 bit offset from GOT to PLT. */
-+#define R_390_PLTOFF32		35	/* 32 bit offset from GOT to PLT. */
-+#define R_390_PLTOFF64		36	/* 16 bit offset from GOT to PLT. */
-+#define R_390_TLS_LOAD		37	/* Tag for load insn in TLS code.  */
-+#define R_390_TLS_GDCALL	38	/* Tag for function call in general
-+					   dynamic TLS code. */
-+#define R_390_TLS_LDCALL	39	/* Tag for function call in local
-+					   dynamic TLS code. */
-+#define R_390_TLS_GD32		40	/* Direct 32 bit for general dynamic
-+					   thread local data.  */
-+#define R_390_TLS_GD64		41	/* Direct 64 bit for general dynamic
-+					  thread local data.  */
-+#define R_390_TLS_GOTIE12	42	/* 12 bit GOT offset for static TLS
-+					   block offset.  */
-+#define R_390_TLS_GOTIE32	43	/* 32 bit GOT offset for static TLS
-+					   block offset.  */
-+#define R_390_TLS_GOTIE64	44	/* 64 bit GOT offset for static TLS
-+					   block offset. */
-+#define R_390_TLS_LDM32		45	/* Direct 32 bit for local dynamic
-+					   thread local data in LE code.  */
-+#define R_390_TLS_LDM64		46	/* Direct 64 bit for local dynamic
-+					   thread local data in LE code.  */
-+#define R_390_TLS_IE32		47	/* 32 bit address of GOT entry for
-+					   negated static TLS block offset.  */
-+#define R_390_TLS_IE64		48	/* 64 bit address of GOT entry for
-+					   negated static TLS block offset.  */
-+#define R_390_TLS_IEENT		49	/* 32 bit rel. offset to GOT entry for
-+					   negated static TLS block offset.  */
-+#define R_390_TLS_LE32		50	/* 32 bit negated offset relative to
-+					   static TLS block.  */
-+#define R_390_TLS_LE64		51	/* 64 bit negated offset relative to
-+					   static TLS block.  */
-+#define R_390_TLS_LDO32		52	/* 32 bit offset relative to TLS
-+					   block.  */
-+#define R_390_TLS_LDO64		53	/* 64 bit offset relative to TLS
-+					   block.  */
-+#define R_390_TLS_DTPMOD	54	/* ID of module containing symbol.  */
-+#define R_390_TLS_DTPOFF	55	/* Offset in TLS block.	 */
-+#define R_390_TLS_TPOFF		56	/* Negated offset in static TLS
-+					   block.  */
-+#define R_390_20		57	/* Direct 20 bit.  */
-+#define R_390_GOT20		58	/* 20 bit GOT offset.  */
-+#define R_390_GOTPLT20		59	/* 20 bit offset to jump slot.  */
-+#define R_390_TLS_GOTIE20	60	/* 20 bit GOT offset for static TLS
-+					   block offset.  */
-+#define R_390_IRELATIVE         61      /* STT_GNU_IFUNC relocation.  */
-+/* Keep this the last entry.  */
-+#define R_390_NUM		62
-+
-+
-+/* CRIS relocations.  */
-+#define R_CRIS_NONE		0
-+#define R_CRIS_8		1
-+#define R_CRIS_16		2
-+#define R_CRIS_32		3
-+#define R_CRIS_8_PCREL		4
-+#define R_CRIS_16_PCREL		5
-+#define R_CRIS_32_PCREL		6
-+#define R_CRIS_GNU_VTINHERIT	7
-+#define R_CRIS_GNU_VTENTRY	8
-+#define R_CRIS_COPY		9
-+#define R_CRIS_GLOB_DAT		10
-+#define R_CRIS_JUMP_SLOT	11
-+#define R_CRIS_RELATIVE		12
-+#define R_CRIS_16_GOT		13
-+#define R_CRIS_32_GOT		14
-+#define R_CRIS_16_GOTPLT	15
-+#define R_CRIS_32_GOTPLT	16
-+#define R_CRIS_32_GOTREL	17
-+#define R_CRIS_32_PLT_GOTREL	18
-+#define R_CRIS_32_PLT_PCREL	19
-+
-+#define R_CRIS_NUM		20
-+
-+
-+/* AMD x86-64 relocations.  */
-+#define R_X86_64_NONE		0	/* No reloc */
-+#define R_X86_64_64		1	/* Direct 64 bit  */
-+#define R_X86_64_PC32		2	/* PC relative 32 bit signed */
-+#define R_X86_64_GOT32		3	/* 32 bit GOT entry */
-+#define R_X86_64_PLT32		4	/* 32 bit PLT address */
-+#define R_X86_64_COPY		5	/* Copy symbol at runtime */
-+#define R_X86_64_GLOB_DAT	6	/* Create GOT entry */
-+#define R_X86_64_JUMP_SLOT	7	/* Create PLT entry */
-+#define R_X86_64_RELATIVE	8	/* Adjust by program base */
-+#define R_X86_64_GOTPCREL	9	/* 32 bit signed PC relative
-+					   offset to GOT */
-+#define R_X86_64_32		10	/* Direct 32 bit zero extended */
-+#define R_X86_64_32S		11	/* Direct 32 bit sign extended */
-+#define R_X86_64_16		12	/* Direct 16 bit zero extended */
-+#define R_X86_64_PC16		13	/* 16 bit sign extended pc relative */
-+#define R_X86_64_8		14	/* Direct 8 bit sign extended  */
-+#define R_X86_64_PC8		15	/* 8 bit sign extended pc relative */
-+#define R_X86_64_DTPMOD64	16	/* ID of module containing symbol */
-+#define R_X86_64_DTPOFF64	17	/* Offset in module's TLS block */
-+#define R_X86_64_TPOFF64	18	/* Offset in initial TLS block */
-+#define R_X86_64_TLSGD		19	/* 32 bit signed PC relative offset
-+					   to two GOT entries for GD symbol */
-+#define R_X86_64_TLSLD		20	/* 32 bit signed PC relative offset
-+					   to two GOT entries for LD symbol */
-+#define R_X86_64_DTPOFF32	21	/* Offset in TLS block */
-+#define R_X86_64_GOTTPOFF	22	/* 32 bit signed PC relative offset
-+					   to GOT entry for IE symbol */
-+#define R_X86_64_TPOFF32	23	/* Offset in initial TLS block */
-+#define R_X86_64_PC64		24	/* PC relative 64 bit */
-+#define R_X86_64_GOTOFF64	25	/* 64 bit offset to GOT */
-+#define R_X86_64_GOTPC32	26	/* 32 bit signed pc relative
-+					   offset to GOT */
-+#define R_X86_64_GOT64		27	/* 64-bit GOT entry offset */
-+#define R_X86_64_GOTPCREL64	28	/* 64-bit PC relative offset
-+					   to GOT entry */
-+#define R_X86_64_GOTPC64	29	/* 64-bit PC relative offset to GOT */
-+#define R_X86_64_GOTPLT64	30 	/* like GOT64, says PLT entry needed */
-+#define R_X86_64_PLTOFF64	31	/* 64-bit GOT relative offset
-+					   to PLT entry */
-+#define R_X86_64_SIZE32		32	/* Size of symbol plus 32-bit addend */
-+#define R_X86_64_SIZE64		33	/* Size of symbol plus 64-bit addend */
-+#define R_X86_64_GOTPC32_TLSDESC 34	/* GOT offset for TLS descriptor.  */
-+#define R_X86_64_TLSDESC_CALL   35	/* Marker for call through TLS
-+					   descriptor.  */
-+#define R_X86_64_TLSDESC        36	/* TLS descriptor.  */
-+#define R_X86_64_IRELATIVE	37	/* Adjust indirectly by program base */
-+#define R_X86_64_RELATIVE64	38	/* 64-bit adjust by program base */
-+
-+#define R_X86_64_NUM		39
-+
-+
-+/* AM33 relocations.  */
-+#define R_MN10300_NONE		0	/* No reloc.  */
-+#define R_MN10300_32		1	/* Direct 32 bit.  */
-+#define R_MN10300_16		2	/* Direct 16 bit.  */
-+#define R_MN10300_8		3	/* Direct 8 bit.  */
-+#define R_MN10300_PCREL32	4	/* PC-relative 32-bit.  */
-+#define R_MN10300_PCREL16	5	/* PC-relative 16-bit signed.  */
-+#define R_MN10300_PCREL8	6	/* PC-relative 8-bit signed.  */
-+#define R_MN10300_GNU_VTINHERIT	7	/* Ancient C++ vtable garbage... */
-+#define R_MN10300_GNU_VTENTRY	8	/* ... collection annotation.  */
-+#define R_MN10300_24		9	/* Direct 24 bit.  */
-+#define R_MN10300_GOTPC32	10	/* 32-bit PCrel offset to GOT.  */
-+#define R_MN10300_GOTPC16	11	/* 16-bit PCrel offset to GOT.  */
-+#define R_MN10300_GOTOFF32	12	/* 32-bit offset from GOT.  */
-+#define R_MN10300_GOTOFF24	13	/* 24-bit offset from GOT.  */
-+#define R_MN10300_GOTOFF16	14	/* 16-bit offset from GOT.  */
-+#define R_MN10300_PLT32		15	/* 32-bit PCrel to PLT entry.  */
-+#define R_MN10300_PLT16		16	/* 16-bit PCrel to PLT entry.  */
-+#define R_MN10300_GOT32		17	/* 32-bit offset to GOT entry.  */
-+#define R_MN10300_GOT24		18	/* 24-bit offset to GOT entry.  */
-+#define R_MN10300_GOT16		19	/* 16-bit offset to GOT entry.  */
-+#define R_MN10300_COPY		20	/* Copy symbol at runtime.  */
-+#define R_MN10300_GLOB_DAT	21	/* Create GOT entry.  */
-+#define R_MN10300_JMP_SLOT	22	/* Create PLT entry.  */
-+#define R_MN10300_RELATIVE	23	/* Adjust by program base.  */
-+
-+#define R_MN10300_NUM		24
-+
-+
-+/* M32R relocs.  */
-+#define R_M32R_NONE		0	/* No reloc. */
-+#define R_M32R_16		1	/* Direct 16 bit. */
-+#define R_M32R_32		2	/* Direct 32 bit. */
-+#define R_M32R_24		3	/* Direct 24 bit. */
-+#define R_M32R_10_PCREL		4	/* PC relative 10 bit shifted. */
-+#define R_M32R_18_PCREL		5	/* PC relative 18 bit shifted. */
-+#define R_M32R_26_PCREL		6	/* PC relative 26 bit shifted. */
-+#define R_M32R_HI16_ULO		7	/* High 16 bit with unsigned low. */
-+#define R_M32R_HI16_SLO		8	/* High 16 bit with signed low. */
-+#define R_M32R_LO16		9	/* Low 16 bit. */
-+#define R_M32R_SDA16		10	/* 16 bit offset in SDA. */
-+#define R_M32R_GNU_VTINHERIT	11
-+#define R_M32R_GNU_VTENTRY	12
-+/* M32R relocs use SHT_RELA.  */
-+#define R_M32R_16_RELA		33	/* Direct 16 bit. */
-+#define R_M32R_32_RELA		34	/* Direct 32 bit. */
-+#define R_M32R_24_RELA		35	/* Direct 24 bit. */
-+#define R_M32R_10_PCREL_RELA	36	/* PC relative 10 bit shifted. */
-+#define R_M32R_18_PCREL_RELA	37	/* PC relative 18 bit shifted. */
-+#define R_M32R_26_PCREL_RELA	38	/* PC relative 26 bit shifted. */
-+#define R_M32R_HI16_ULO_RELA	39	/* High 16 bit with unsigned low */
-+#define R_M32R_HI16_SLO_RELA	40	/* High 16 bit with signed low */
-+#define R_M32R_LO16_RELA	41	/* Low 16 bit */
-+#define R_M32R_SDA16_RELA	42	/* 16 bit offset in SDA */
-+#define R_M32R_RELA_GNU_VTINHERIT	43
-+#define R_M32R_RELA_GNU_VTENTRY	44
-+#define R_M32R_REL32		45	/* PC relative 32 bit.  */
-+
-+#define R_M32R_GOT24		48	/* 24 bit GOT entry */
-+#define R_M32R_26_PLTREL	49	/* 26 bit PC relative to PLT shifted */
-+#define R_M32R_COPY		50	/* Copy symbol at runtime */
-+#define R_M32R_GLOB_DAT		51	/* Create GOT entry */
-+#define R_M32R_JMP_SLOT		52	/* Create PLT entry */
-+#define R_M32R_RELATIVE		53	/* Adjust by program base */
-+#define R_M32R_GOTOFF		54	/* 24 bit offset to GOT */
-+#define R_M32R_GOTPC24		55	/* 24 bit PC relative offset to GOT */
-+#define R_M32R_GOT16_HI_ULO	56	/* High 16 bit GOT entry with unsigned
-+					   low */
-+#define R_M32R_GOT16_HI_SLO	57	/* High 16 bit GOT entry with signed
-+					   low */
-+#define R_M32R_GOT16_LO		58	/* Low 16 bit GOT entry */
-+#define R_M32R_GOTPC_HI_ULO	59	/* High 16 bit PC relative offset to
-+					   GOT with unsigned low */
-+#define R_M32R_GOTPC_HI_SLO	60	/* High 16 bit PC relative offset to
-+					   GOT with signed low */
-+#define R_M32R_GOTPC_LO		61	/* Low 16 bit PC relative offset to
-+					   GOT */
-+#define R_M32R_GOTOFF_HI_ULO	62	/* High 16 bit offset to GOT
-+					   with unsigned low */
-+#define R_M32R_GOTOFF_HI_SLO	63	/* High 16 bit offset to GOT
-+					   with signed low */
-+#define R_M32R_GOTOFF_LO	64	/* Low 16 bit offset to GOT */
-+#define R_M32R_NUM		256	/* Keep this the last entry. */
-+
-+
-+/* TILEPro relocations.  */
-+#define R_TILEPRO_NONE		0	/* No reloc */
-+#define R_TILEPRO_32		1	/* Direct 32 bit */
-+#define R_TILEPRO_16		2	/* Direct 16 bit */
-+#define R_TILEPRO_8		3	/* Direct 8 bit */
-+#define R_TILEPRO_32_PCREL	4	/* PC relative 32 bit */
-+#define R_TILEPRO_16_PCREL	5	/* PC relative 16 bit */
-+#define R_TILEPRO_8_PCREL	6	/* PC relative 8 bit */
-+#define R_TILEPRO_LO16		7	/* Low 16 bit */
-+#define R_TILEPRO_HI16		8	/* High 16 bit */
-+#define R_TILEPRO_HA16		9	/* High 16 bit, adjusted */
-+#define R_TILEPRO_COPY		10	/* Copy relocation */
-+#define R_TILEPRO_GLOB_DAT	11	/* Create GOT entry */
-+#define R_TILEPRO_JMP_SLOT	12	/* Create PLT entry */
-+#define R_TILEPRO_RELATIVE	13	/* Adjust by program base */
-+#define R_TILEPRO_BROFF_X1	14	/* X1 pipe branch offset */
-+#define R_TILEPRO_JOFFLONG_X1	15	/* X1 pipe jump offset */
-+#define R_TILEPRO_JOFFLONG_X1_PLT 16	/* X1 pipe jump offset to PLT */
-+#define R_TILEPRO_IMM8_X0	17	/* X0 pipe 8-bit */
-+#define R_TILEPRO_IMM8_Y0	18	/* Y0 pipe 8-bit */
-+#define R_TILEPRO_IMM8_X1	19	/* X1 pipe 8-bit */
-+#define R_TILEPRO_IMM8_Y1	20	/* Y1 pipe 8-bit */
-+#define R_TILEPRO_MT_IMM15_X1	21	/* X1 pipe mtspr */
-+#define R_TILEPRO_MF_IMM15_X1	22	/* X1 pipe mfspr */
-+#define R_TILEPRO_IMM16_X0	23	/* X0 pipe 16-bit */
-+#define R_TILEPRO_IMM16_X1	24	/* X1 pipe 16-bit */
-+#define R_TILEPRO_IMM16_X0_LO	25	/* X0 pipe low 16-bit */
-+#define R_TILEPRO_IMM16_X1_LO	26	/* X1 pipe low 16-bit */
-+#define R_TILEPRO_IMM16_X0_HI	27	/* X0 pipe high 16-bit */
-+#define R_TILEPRO_IMM16_X1_HI	28	/* X1 pipe high 16-bit */
-+#define R_TILEPRO_IMM16_X0_HA	29	/* X0 pipe high 16-bit, adjusted */
-+#define R_TILEPRO_IMM16_X1_HA	30	/* X1 pipe high 16-bit, adjusted */
-+#define R_TILEPRO_IMM16_X0_PCREL 31	/* X0 pipe PC relative 16 bit */
-+#define R_TILEPRO_IMM16_X1_PCREL 32	/* X1 pipe PC relative 16 bit */
-+#define R_TILEPRO_IMM16_X0_LO_PCREL 33	/* X0 pipe PC relative low 16 bit */
-+#define R_TILEPRO_IMM16_X1_LO_PCREL 34	/* X1 pipe PC relative low 16 bit */
-+#define R_TILEPRO_IMM16_X0_HI_PCREL 35	/* X0 pipe PC relative high 16 bit */
-+#define R_TILEPRO_IMM16_X1_HI_PCREL 36	/* X1 pipe PC relative high 16 bit */
-+#define R_TILEPRO_IMM16_X0_HA_PCREL 37	/* X0 pipe PC relative ha() 16 bit */
-+#define R_TILEPRO_IMM16_X1_HA_PCREL 38	/* X1 pipe PC relative ha() 16 bit */
-+#define R_TILEPRO_IMM16_X0_GOT	39	/* X0 pipe 16-bit GOT offset */
-+#define R_TILEPRO_IMM16_X1_GOT	40	/* X1 pipe 16-bit GOT offset */
-+#define R_TILEPRO_IMM16_X0_GOT_LO 41	/* X0 pipe low 16-bit GOT offset */
-+#define R_TILEPRO_IMM16_X1_GOT_LO 42	/* X1 pipe low 16-bit GOT offset */
-+#define R_TILEPRO_IMM16_X0_GOT_HI 43	/* X0 pipe high 16-bit GOT offset */
-+#define R_TILEPRO_IMM16_X1_GOT_HI 44	/* X1 pipe high 16-bit GOT offset */
-+#define R_TILEPRO_IMM16_X0_GOT_HA 45	/* X0 pipe ha() 16-bit GOT offset */
-+#define R_TILEPRO_IMM16_X1_GOT_HA 46	/* X1 pipe ha() 16-bit GOT offset */
-+#define R_TILEPRO_MMSTART_X0	47	/* X0 pipe mm "start" */
-+#define R_TILEPRO_MMEND_X0	48	/* X0 pipe mm "end" */
-+#define R_TILEPRO_MMSTART_X1	49	/* X1 pipe mm "start" */
-+#define R_TILEPRO_MMEND_X1	50	/* X1 pipe mm "end" */
-+#define R_TILEPRO_SHAMT_X0	51	/* X0 pipe shift amount */
-+#define R_TILEPRO_SHAMT_X1	52	/* X1 pipe shift amount */
-+#define R_TILEPRO_SHAMT_Y0	53	/* Y0 pipe shift amount */
-+#define R_TILEPRO_SHAMT_Y1	54	/* Y1 pipe shift amount */
-+#define R_TILEPRO_DEST_IMM8_X1	55	/* X1 pipe destination 8-bit */
-+/* Relocs 56-59 are currently not defined.  */
-+#define R_TILEPRO_TLS_GD_CALL	60	/* "jal" for TLS GD */
-+#define R_TILEPRO_IMM8_X0_TLS_GD_ADD 61	/* X0 pipe "addi" for TLS GD */
-+#define R_TILEPRO_IMM8_X1_TLS_GD_ADD 62	/* X1 pipe "addi" for TLS GD */
-+#define R_TILEPRO_IMM8_Y0_TLS_GD_ADD 63	/* Y0 pipe "addi" for TLS GD */
-+#define R_TILEPRO_IMM8_Y1_TLS_GD_ADD 64	/* Y1 pipe "addi" for TLS GD */
-+#define R_TILEPRO_TLS_IE_LOAD	65	/* "lw_tls" for TLS IE */
-+#define R_TILEPRO_IMM16_X0_TLS_GD 66	/* X0 pipe 16-bit TLS GD offset */
-+#define R_TILEPRO_IMM16_X1_TLS_GD 67	/* X1 pipe 16-bit TLS GD offset */
-+#define R_TILEPRO_IMM16_X0_TLS_GD_LO 68	/* X0 pipe low 16-bit TLS GD offset */
-+#define R_TILEPRO_IMM16_X1_TLS_GD_LO 69	/* X1 pipe low 16-bit TLS GD offset */
-+#define R_TILEPRO_IMM16_X0_TLS_GD_HI 70	/* X0 pipe high 16-bit TLS GD offset */
-+#define R_TILEPRO_IMM16_X1_TLS_GD_HI 71	/* X1 pipe high 16-bit TLS GD offset */
-+#define R_TILEPRO_IMM16_X0_TLS_GD_HA 72	/* X0 pipe ha() 16-bit TLS GD offset */
-+#define R_TILEPRO_IMM16_X1_TLS_GD_HA 73	/* X1 pipe ha() 16-bit TLS GD offset */
-+#define R_TILEPRO_IMM16_X0_TLS_IE 74	/* X0 pipe 16-bit TLS IE offset */
-+#define R_TILEPRO_IMM16_X1_TLS_IE 75	/* X1 pipe 16-bit TLS IE offset */
-+#define R_TILEPRO_IMM16_X0_TLS_IE_LO 76	/* X0 pipe low 16-bit TLS IE offset */
-+#define R_TILEPRO_IMM16_X1_TLS_IE_LO 77	/* X1 pipe low 16-bit TLS IE offset */
-+#define R_TILEPRO_IMM16_X0_TLS_IE_HI 78	/* X0 pipe high 16-bit TLS IE offset */
-+#define R_TILEPRO_IMM16_X1_TLS_IE_HI 79	/* X1 pipe high 16-bit TLS IE offset */
-+#define R_TILEPRO_IMM16_X0_TLS_IE_HA 80	/* X0 pipe ha() 16-bit TLS IE offset */
-+#define R_TILEPRO_IMM16_X1_TLS_IE_HA 81	/* X1 pipe ha() 16-bit TLS IE offset */
-+#define R_TILEPRO_TLS_DTPMOD32	82	/* ID of module containing symbol */
-+#define R_TILEPRO_TLS_DTPOFF32	83	/* Offset in TLS block */
-+#define R_TILEPRO_TLS_TPOFF32	84	/* Offset in static TLS block */
-+#define R_TILEPRO_IMM16_X0_TLS_LE 85	/* X0 pipe 16-bit TLS LE offset */
-+#define R_TILEPRO_IMM16_X1_TLS_LE 86	/* X1 pipe 16-bit TLS LE offset */
-+#define R_TILEPRO_IMM16_X0_TLS_LE_LO 87	/* X0 pipe low 16-bit TLS LE offset */
-+#define R_TILEPRO_IMM16_X1_TLS_LE_LO 88	/* X1 pipe low 16-bit TLS LE offset */
-+#define R_TILEPRO_IMM16_X0_TLS_LE_HI 89	/* X0 pipe high 16-bit TLS LE offset */
-+#define R_TILEPRO_IMM16_X1_TLS_LE_HI 90	/* X1 pipe high 16-bit TLS LE offset */
-+#define R_TILEPRO_IMM16_X0_TLS_LE_HA 91	/* X0 pipe ha() 16-bit TLS LE offset */
-+#define R_TILEPRO_IMM16_X1_TLS_LE_HA 92	/* X1 pipe ha() 16-bit TLS LE offset */
-+
-+#define R_TILEPRO_GNU_VTINHERIT	128	/* GNU C++ vtable hierarchy */
-+#define R_TILEPRO_GNU_VTENTRY	129	/* GNU C++ vtable member usage */
-+
-+#define R_TILEPRO_NUM		130
-+
-+
-+/* TILE-Gx relocations.  */
-+#define R_TILEGX_NONE		0	/* No reloc */
-+#define R_TILEGX_64		1	/* Direct 64 bit */
-+#define R_TILEGX_32		2	/* Direct 32 bit */
-+#define R_TILEGX_16		3	/* Direct 16 bit */
-+#define R_TILEGX_8		4	/* Direct 8 bit */
-+#define R_TILEGX_64_PCREL	5	/* PC relative 64 bit */
-+#define R_TILEGX_32_PCREL	6	/* PC relative 32 bit */
-+#define R_TILEGX_16_PCREL	7	/* PC relative 16 bit */
-+#define R_TILEGX_8_PCREL	8	/* PC relative 8 bit */
-+#define R_TILEGX_HW0		9	/* hword 0 16-bit */
-+#define R_TILEGX_HW1		10	/* hword 1 16-bit */
-+#define R_TILEGX_HW2		11	/* hword 2 16-bit */
-+#define R_TILEGX_HW3		12	/* hword 3 16-bit */
-+#define R_TILEGX_HW0_LAST	13	/* last hword 0 16-bit */
-+#define R_TILEGX_HW1_LAST	14	/* last hword 1 16-bit */
-+#define R_TILEGX_HW2_LAST	15	/* last hword 2 16-bit */
-+#define R_TILEGX_COPY		16	/* Copy relocation */
-+#define R_TILEGX_GLOB_DAT	17	/* Create GOT entry */
-+#define R_TILEGX_JMP_SLOT	18	/* Create PLT entry */
-+#define R_TILEGX_RELATIVE	19	/* Adjust by program base */
-+#define R_TILEGX_BROFF_X1	20	/* X1 pipe branch offset */
-+#define R_TILEGX_JUMPOFF_X1	21	/* X1 pipe jump offset */
-+#define R_TILEGX_JUMPOFF_X1_PLT	22	/* X1 pipe jump offset to PLT */
-+#define R_TILEGX_IMM8_X0	23	/* X0 pipe 8-bit */
-+#define R_TILEGX_IMM8_Y0	24	/* Y0 pipe 8-bit */
-+#define R_TILEGX_IMM8_X1	25	/* X1 pipe 8-bit */
-+#define R_TILEGX_IMM8_Y1	26	/* Y1 pipe 8-bit */
-+#define R_TILEGX_DEST_IMM8_X1	27	/* X1 pipe destination 8-bit */
-+#define R_TILEGX_MT_IMM14_X1	28	/* X1 pipe mtspr */
-+#define R_TILEGX_MF_IMM14_X1	29	/* X1 pipe mfspr */
-+#define R_TILEGX_MMSTART_X0	30	/* X0 pipe mm "start" */
-+#define R_TILEGX_MMEND_X0	31	/* X0 pipe mm "end" */
-+#define R_TILEGX_SHAMT_X0	32	/* X0 pipe shift amount */
-+#define R_TILEGX_SHAMT_X1	33	/* X1 pipe shift amount */
-+#define R_TILEGX_SHAMT_Y0	34	/* Y0 pipe shift amount */
-+#define R_TILEGX_SHAMT_Y1	35	/* Y1 pipe shift amount */
-+#define R_TILEGX_IMM16_X0_HW0	36	/* X0 pipe hword 0 */
-+#define R_TILEGX_IMM16_X1_HW0	37	/* X1 pipe hword 0 */
-+#define R_TILEGX_IMM16_X0_HW1	38	/* X0 pipe hword 1 */
-+#define R_TILEGX_IMM16_X1_HW1	39	/* X1 pipe hword 1 */
-+#define R_TILEGX_IMM16_X0_HW2	40	/* X0 pipe hword 2 */
-+#define R_TILEGX_IMM16_X1_HW2	41	/* X1 pipe hword 2 */
-+#define R_TILEGX_IMM16_X0_HW3	42	/* X0 pipe hword 3 */
-+#define R_TILEGX_IMM16_X1_HW3	43	/* X1 pipe hword 3 */
-+#define R_TILEGX_IMM16_X0_HW0_LAST 44	/* X0 pipe last hword 0 */
-+#define R_TILEGX_IMM16_X1_HW0_LAST 45	/* X1 pipe last hword 0 */
-+#define R_TILEGX_IMM16_X0_HW1_LAST 46	/* X0 pipe last hword 1 */
-+#define R_TILEGX_IMM16_X1_HW1_LAST 47	/* X1 pipe last hword 1 */
-+#define R_TILEGX_IMM16_X0_HW2_LAST 48	/* X0 pipe last hword 2 */
-+#define R_TILEGX_IMM16_X1_HW2_LAST 49	/* X1 pipe last hword 2 */
-+#define R_TILEGX_IMM16_X0_HW0_PCREL 50	/* X0 pipe PC relative hword 0 */
-+#define R_TILEGX_IMM16_X1_HW0_PCREL 51	/* X1 pipe PC relative hword 0 */
-+#define R_TILEGX_IMM16_X0_HW1_PCREL 52	/* X0 pipe PC relative hword 1 */
-+#define R_TILEGX_IMM16_X1_HW1_PCREL 53	/* X1 pipe PC relative hword 1 */
-+#define R_TILEGX_IMM16_X0_HW2_PCREL 54	/* X0 pipe PC relative hword 2 */
-+#define R_TILEGX_IMM16_X1_HW2_PCREL 55	/* X1 pipe PC relative hword 2 */
-+#define R_TILEGX_IMM16_X0_HW3_PCREL 56	/* X0 pipe PC relative hword 3 */
-+#define R_TILEGX_IMM16_X1_HW3_PCREL 57	/* X1 pipe PC relative hword 3 */
-+#define R_TILEGX_IMM16_X0_HW0_LAST_PCREL 58 /* X0 pipe PC-rel last hword 0 */
-+#define R_TILEGX_IMM16_X1_HW0_LAST_PCREL 59 /* X1 pipe PC-rel last hword 0 */
-+#define R_TILEGX_IMM16_X0_HW1_LAST_PCREL 60 /* X0 pipe PC-rel last hword 1 */
-+#define R_TILEGX_IMM16_X1_HW1_LAST_PCREL 61 /* X1 pipe PC-rel last hword 1 */
-+#define R_TILEGX_IMM16_X0_HW2_LAST_PCREL 62 /* X0 pipe PC-rel last hword 2 */
-+#define R_TILEGX_IMM16_X1_HW2_LAST_PCREL 63 /* X1 pipe PC-rel last hword 2 */
-+#define R_TILEGX_IMM16_X0_HW0_GOT 64	/* X0 pipe hword 0 GOT offset */
-+#define R_TILEGX_IMM16_X1_HW0_GOT 65	/* X1 pipe hword 0 GOT offset */
-+/* Relocs 66-71 are currently not defined.  */
-+#define R_TILEGX_IMM16_X0_HW0_LAST_GOT 72 /* X0 pipe last hword 0 GOT offset */
-+#define R_TILEGX_IMM16_X1_HW0_LAST_GOT 73 /* X1 pipe last hword 0 GOT offset */
-+#define R_TILEGX_IMM16_X0_HW1_LAST_GOT 74 /* X0 pipe last hword 1 GOT offset */
-+#define R_TILEGX_IMM16_X1_HW1_LAST_GOT 75 /* X1 pipe last hword 1 GOT offset */
-+/* Relocs 76-77 are currently not defined.  */
-+#define R_TILEGX_IMM16_X0_HW0_TLS_GD 78	/* X0 pipe hword 0 TLS GD offset */
-+#define R_TILEGX_IMM16_X1_HW0_TLS_GD 79	/* X1 pipe hword 0 TLS GD offset */
-+#define R_TILEGX_IMM16_X0_HW0_TLS_LE 80	/* X0 pipe hword 0 TLS LE offset */
-+#define R_TILEGX_IMM16_X1_HW0_TLS_LE 81	/* X1 pipe hword 0 TLS LE offset */
-+#define R_TILEGX_IMM16_X0_HW0_LAST_TLS_LE 82 /* X0 pipe last hword 0 LE off */
-+#define R_TILEGX_IMM16_X1_HW0_LAST_TLS_LE 83 /* X1 pipe last hword 0 LE off */
-+#define R_TILEGX_IMM16_X0_HW1_LAST_TLS_LE 84 /* X0 pipe last hword 1 LE off */
-+#define R_TILEGX_IMM16_X1_HW1_LAST_TLS_LE 85 /* X1 pipe last hword 1 LE off */
-+#define R_TILEGX_IMM16_X0_HW0_LAST_TLS_GD 86 /* X0 pipe last hword 0 GD off */
-+#define R_TILEGX_IMM16_X1_HW0_LAST_TLS_GD 87 /* X1 pipe last hword 0 GD off */
-+#define R_TILEGX_IMM16_X0_HW1_LAST_TLS_GD 88 /* X0 pipe last hword 1 GD off */
-+#define R_TILEGX_IMM16_X1_HW1_LAST_TLS_GD 89 /* X1 pipe last hword 1 GD off */
-+/* Relocs 90-91 are currently not defined.  */
-+#define R_TILEGX_IMM16_X0_HW0_TLS_IE 92	/* X0 pipe hword 0 TLS IE offset */
-+#define R_TILEGX_IMM16_X1_HW0_TLS_IE 93	/* X1 pipe hword 0 TLS IE offset */
-+/* Relocs 94-99 are currently not defined.  */
-+#define R_TILEGX_IMM16_X0_HW0_LAST_TLS_IE 100 /* X0 pipe last hword 0 IE off */
-+#define R_TILEGX_IMM16_X1_HW0_LAST_TLS_IE 101 /* X1 pipe last hword 0 IE off */
-+#define R_TILEGX_IMM16_X0_HW1_LAST_TLS_IE 102 /* X0 pipe last hword 1 IE off */
-+#define R_TILEGX_IMM16_X1_HW1_LAST_TLS_IE 103 /* X1 pipe last hword 1 IE off */
-+/* Relocs 104-105 are currently not defined.  */
-+#define R_TILEGX_TLS_DTPMOD64	106	/* 64-bit ID of symbol's module */
-+#define R_TILEGX_TLS_DTPOFF64	107	/* 64-bit offset in TLS block */
-+#define R_TILEGX_TLS_TPOFF64	108	/* 64-bit offset in static TLS block */
-+#define R_TILEGX_TLS_DTPMOD32	109	/* 32-bit ID of symbol's module */
-+#define R_TILEGX_TLS_DTPOFF32	110	/* 32-bit offset in TLS block */
-+#define R_TILEGX_TLS_TPOFF32	111	/* 32-bit offset in static TLS block */
-+#define R_TILEGX_TLS_GD_CALL	112	/* "jal" for TLS GD */
-+#define R_TILEGX_IMM8_X0_TLS_GD_ADD 113	/* X0 pipe "addi" for TLS GD */
-+#define R_TILEGX_IMM8_X1_TLS_GD_ADD 114	/* X1 pipe "addi" for TLS GD */
-+#define R_TILEGX_IMM8_Y0_TLS_GD_ADD 115	/* Y0 pipe "addi" for TLS GD */
-+#define R_TILEGX_IMM8_Y1_TLS_GD_ADD 116	/* Y1 pipe "addi" for TLS GD */
-+#define R_TILEGX_TLS_IE_LOAD	117	/* "ld_tls" for TLS IE */
-+#define R_TILEGX_IMM8_X0_TLS_ADD 118	/* X0 pipe "addi" for TLS GD/IE */
-+#define R_TILEGX_IMM8_X1_TLS_ADD 119	/* X1 pipe "addi" for TLS GD/IE */
-+#define R_TILEGX_IMM8_Y0_TLS_ADD 120	/* Y0 pipe "addi" for TLS GD/IE */
-+#define R_TILEGX_IMM8_Y1_TLS_ADD 121	/* Y1 pipe "addi" for TLS GD/IE */
-+
-+#define R_TILEGX_GNU_VTINHERIT	128	/* GNU C++ vtable hierarchy */
-+#define R_TILEGX_GNU_VTENTRY	129	/* GNU C++ vtable member usage */
-+
-+#define R_TILEGX_NUM		130
-+
-+#endif	/* elf.h */
---- a/scripts/mod/mk_elfconfig.c
-+++ b/scripts/mod/mk_elfconfig.c
-@@ -1,7 +1,11 @@
- #include <stdio.h>
- #include <stdlib.h>
- #include <string.h>
-+#ifndef __APPLE__
- #include <elf.h>
-+#else
-+#include "elf.h"
-+#endif
- 
- int
- main(int argc, char **argv)
---- a/scripts/mod/modpost.h
-+++ b/scripts/mod/modpost.h
-@@ -7,7 +7,11 @@
- #include <sys/mman.h>
- #include <fcntl.h>
- #include <unistd.h>
-+#if !(defined(__APPLE__) || defined(__CYGWIN__))
- #include <elf.h>
-+#else
-+#include "elf.h"
-+#endif
- 
- #include "elfconfig.h"
- 
--- a/target/linux/generic/hack-4.9/211-host_tools_portability.patch	2022-03-22 08:54:47.225464699 +0800
+++ b/target/linux/generic/hack-4.9/211-host_tools_portability.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,40 +0,0 @@
-From 7f698012384ccb1ed10cc758acfd085096fdb307 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 17:02:03 +0200
-Subject: kernel: fix linux 4.9 host tools portability issues
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- tools/build/Build.include       | 2 +-
- tools/perf/pmu-events/jevents.c | 1 +
- tools/perf/pmu-events/json.c    | 1 -
- 3 files changed, 2 insertions(+), 2 deletions(-)
-
---- a/tools/build/Build.include
-+++ b/tools/build/Build.include
-@@ -96,4 +96,4 @@ cxx_flags = -Wp,-MD,$(depfile),-MT,$@ $(
- ###
- ## HOSTCC C flags
- 
--host_c_flags = -Wp,-MD,$(depfile),-MT,$@ $(CHOSTFLAGS) -D"BUILD_STR(s)=\#s" $(CHOSTFLAGS_$(basetarget).o) $(CHOSTFLAGS_$(obj))
-+host_c_flags = -MD -MF $(depfile) -MT $@ $(CHOSTFLAGS) -D"BUILD_STR(s)=\#s" $(CHOSTFLAGS_$(basetarget).o) $(CHOSTFLAGS_$(obj))
---- a/tools/perf/pmu-events/jevents.c
-+++ b/tools/perf/pmu-events/jevents.c
-@@ -35,6 +35,7 @@
- #include <stdlib.h>
- #include <errno.h>
- #include <string.h>
-+#include <strings.h>
- #include <ctype.h>
- #include <unistd.h>
- #include <stdarg.h>
---- a/tools/perf/pmu-events/json.c
-+++ b/tools/perf/pmu-events/json.c
-@@ -38,7 +38,6 @@
- #include <unistd.h>
- #include "jsmn.h"
- #include "json.h"
--#include <linux/kernel.h>
- 
- 
- static char *mapfile(const char *fn, size_t *size)
--- a/target/linux/generic/hack-4.9/212-byteshift_portability.patch	2022-03-22 08:54:47.225464699 +0800
+++ b/target/linux/generic/hack-4.9/212-byteshift_portability.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,65 +0,0 @@
-From 48232d3d931c95953ce2ddfe7da7bb164aef6a73 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 17:03:16 +0200
-Subject: linux-3.6: fix portability of some includes files in tools/ used on the host
-
-lede-commit: 6040b1d29ab1f047c5e49b748abcb6a3196add28
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- tools/include/tools/be_byteshift.h |  4 ++++
- tools/include/tools/le_byteshift.h |  4 ++++
- tools/include/tools/linux_types.h  | 22 ++++++++++++++++++++++
- 3 files changed, 30 insertions(+)
- create mode 100644 tools/include/tools/linux_types.h
-
---- a/tools/include/tools/be_byteshift.h
-+++ b/tools/include/tools/be_byteshift.h
-@@ -1,6 +1,10 @@
- #ifndef _TOOLS_BE_BYTESHIFT_H
- #define _TOOLS_BE_BYTESHIFT_H
- 
-+#ifndef __linux__
-+#include "linux_types.h"
-+#endif
-+
- #include <stdint.h>
- 
- static inline uint16_t __get_unaligned_be16(const uint8_t *p)
---- a/tools/include/tools/le_byteshift.h
-+++ b/tools/include/tools/le_byteshift.h
-@@ -1,6 +1,10 @@
- #ifndef _TOOLS_LE_BYTESHIFT_H
- #define _TOOLS_LE_BYTESHIFT_H
- 
-+#ifndef __linux__
-+#include "linux_types.h"
-+#endif
-+
- #include <stdint.h>
- 
- static inline uint16_t __get_unaligned_le16(const uint8_t *p)
---- /dev/null
-+++ b/tools/include/tools/linux_types.h
-@@ -0,0 +1,22 @@
-+#ifndef __LINUX_TYPES_H
-+#define __LINUX_TYPES_H
-+
-+#include <stdint.h>
-+
-+typedef uint8_t __u8;
-+typedef uint8_t __be8;
-+typedef uint8_t __le8;
-+
-+typedef uint16_t __u16;
-+typedef uint16_t __be16;
-+typedef uint16_t __le16;
-+
-+typedef uint32_t __u32;
-+typedef uint32_t __be32;
-+typedef uint32_t __le32;
-+
-+typedef uint64_t __u64;
-+typedef uint64_t __be64;
-+typedef uint64_t __le64;
-+
-+#endif
--- a/target/linux/generic/hack-4.9/214-spidev_h_portability.patch	2022-03-22 08:54:47.225464699 +0800
+++ b/target/linux/generic/hack-4.9/214-spidev_h_portability.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,24 +0,0 @@
-From be9be95ff10e16a5b4ad36f903978d0cc5747024 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 17:04:08 +0200
-Subject: kernel: fix linux/spi/spidev.h portability issues with musl
-
-Felix will try to get this define included into musl
-
-lede-commit: 795e7cf60de19e7a076a46874fab7bb88b43bbff
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/uapi/linux/spi/spidev.h | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/include/uapi/linux/spi/spidev.h
-+++ b/include/uapi/linux/spi/spidev.h
-@@ -112,7 +112,7 @@ struct spi_ioc_transfer {
- 
- /* not all platforms use <asm-generic/ioctl.h> or _IOC_TYPECHECK() ... */
- #define SPI_MSGSIZE(N) \
--	((((N)*(sizeof (struct spi_ioc_transfer))) < (1 << _IOC_SIZEBITS)) \
-+	((((N)*(sizeof (struct spi_ioc_transfer))) < (1 << 13)) \
- 		? ((N)*(sizeof (struct spi_ioc_transfer))) : 0)
- #define SPI_IOC_MESSAGE(N) _IOW(SPI_IOC_MAGIC, 0, char[SPI_MSGSIZE(N)])
- 
--- a/target/linux/generic/hack-4.9/220-gc_sections.patch	2022-03-22 08:54:47.226464701 +0800
+++ b/target/linux/generic/hack-4.9/220-gc_sections.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,448 +0,0 @@
-From e3d8676f5722b7622685581e06e8f53e6138e3ab Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 15 Jul 2017 23:42:36 +0200
-Subject: use -ffunction-sections, -fdata-sections and --gc-sections
-
-In combination with kernel symbol export stripping this significantly reduces
-the kernel image size. Used on both ARM and MIPS architectures.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
-Signed-off-by: Jonas Gorski <jogo@openwrt.org>
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- Makefile                          | 10 +++----
- arch/arm/Kconfig                  |  1 +
- arch/arm/boot/compressed/Makefile |  1 +
- arch/arm/kernel/vmlinux.lds.S     | 26 ++++++++--------
- arch/mips/Kconfig                 |  1 +
- arch/mips/kernel/vmlinux.lds.S    |  4 +--
- include/asm-generic/vmlinux.lds.h | 63 ++++++++++++++++++++-------------------
- 7 files changed, 55 insertions(+), 51 deletions(-)
-
---- a/Makefile
-+++ b/Makefile
-@@ -402,6 +402,11 @@ KBUILD_LDFLAGS_MODULE := -T $(srctree)/s
- GCC_PLUGINS_CFLAGS :=
- CLANG_FLAGS :=
- 
-+ifdef CONFIG_LD_DEAD_CODE_DATA_ELIMINATION
-+KBUILD_CFLAGS_KERNEL	+= $(call cc-option,-ffunction-sections,)
-+KBUILD_CFLAGS_KERNEL	+= $(call cc-option,-fdata-sections,)
-+endif
-+
- # Read KERNELRELEASE from include/config/kernel.release (if it exists)
- KERNELRELEASE = $(shell cat include/config/kernel.release 2> /dev/null)
- KERNELVERSION = $(VERSION)$(if $(PATCHLEVEL),.$(PATCHLEVEL)$(if $(SUBLEVEL),.$(SUBLEVEL)))$(EXTRAVERSION)
-@@ -652,11 +657,6 @@ KBUILD_CFLAGS	+= $(call cc-disable-warni
- KBUILD_CFLAGS	+= $(call cc-disable-warning, address-of-packed-member)
- KBUILD_CFLAGS	+= $(call cc-disable-warning, attribute-alias)
- 
--ifdef CONFIG_LD_DEAD_CODE_DATA_ELIMINATION
--KBUILD_CFLAGS	+= $(call cc-option,-ffunction-sections,)
--KBUILD_CFLAGS	+= $(call cc-option,-fdata-sections,)
--endif
--
- ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
- KBUILD_CFLAGS	+= -Os $(call cc-disable-warning,maybe-uninitialized,) $(EXTRA_OPTIMIZATION)
- else
---- a/arch/arm/Kconfig
-+++ b/arch/arm/Kconfig
-@@ -81,6 +81,7 @@ config ARM
- 	select HAVE_UID16
- 	select HAVE_VIRT_CPU_ACCOUNTING_GEN
- 	select IRQ_FORCED_THREADING
-+	select LD_DEAD_CODE_DATA_ELIMINATION
- 	select MODULES_USE_ELF_REL
- 	select NO_BOOTMEM
- 	select OF_EARLY_FLATTREE if OF
---- a/arch/arm/boot/compressed/Makefile
-+++ b/arch/arm/boot/compressed/Makefile
-@@ -102,6 +102,7 @@ ifeq ($(CONFIG_FUNCTION_TRACER),y)
- ORIG_CFLAGS := $(KBUILD_CFLAGS)
- KBUILD_CFLAGS = $(subst -pg, , $(ORIG_CFLAGS))
- endif
-+KBUILD_CFLAGS_KERNEL := $(patsubst -f%-sections,,$(KBUILD_CFLAGS_KERNEL))
- 
- # -fstack-protector-strong triggers protection checks in this code,
- # but it is being used too early to link to meaningful stack_chk logic.
---- a/arch/arm/kernel/vmlinux.lds.S
-+++ b/arch/arm/kernel/vmlinux.lds.S
-@@ -17,7 +17,7 @@
- #define PROC_INFO							\
- 	. = ALIGN(4);							\
- 	VMLINUX_SYMBOL(__proc_info_begin) = .;				\
--	*(.proc.info.init)						\
-+	KEEP(*(.proc.info.init))					\
- 	VMLINUX_SYMBOL(__proc_info_end) = .;
- 
- #define HYPERVISOR_TEXT							\
-@@ -28,11 +28,11 @@
- #define IDMAP_TEXT							\
- 	ALIGN_FUNCTION();						\
- 	VMLINUX_SYMBOL(__idmap_text_start) = .;				\
--	*(.idmap.text)							\
-+	KEEP(*(.idmap.text))						\
- 	VMLINUX_SYMBOL(__idmap_text_end) = .;				\
- 	. = ALIGN(PAGE_SIZE);						\
- 	VMLINUX_SYMBOL(__hyp_idmap_text_start) = .;			\
--	*(.hyp.idmap.text)						\
-+	KEEP(*(.hyp.idmap.text))					\
- 	VMLINUX_SYMBOL(__hyp_idmap_text_end) = .;
- 
- #ifdef CONFIG_HOTPLUG_CPU
-@@ -105,7 +105,7 @@ SECTIONS
- 		_stext = .;		/* Text and read-only data	*/
- 			IDMAP_TEXT
- 			__exception_text_start = .;
--			*(.exception.text)
-+			KEEP(*(.exception.text))
- 			__exception_text_end = .;
- 			IRQENTRY_TEXT
- 			SOFTIRQENTRY_TEXT
-@@ -134,7 +134,7 @@ SECTIONS
- 	__ex_table : AT(ADDR(__ex_table) - LOAD_OFFSET) {
- 		__start___ex_table = .;
- #ifdef CONFIG_MMU
--		*(__ex_table)
-+		KEEP(*(__ex_table))
- #endif
- 		__stop___ex_table = .;
- 	}
-@@ -146,12 +146,12 @@ SECTIONS
- 	. = ALIGN(8);
- 	.ARM.unwind_idx : {
- 		__start_unwind_idx = .;
--		*(.ARM.exidx*)
-+		KEEP(*(.ARM.exidx*))
- 		__stop_unwind_idx = .;
- 	}
- 	.ARM.unwind_tab : {
- 		__start_unwind_tab = .;
--		*(.ARM.extab*)
-+		KEEP(*(.ARM.extab*))
- 		__stop_unwind_tab = .;
- 	}
- #endif
-@@ -171,14 +171,14 @@ SECTIONS
- 	 */
- 	__vectors_start = .;
- 	.vectors 0xffff0000 : AT(__vectors_start) {
--		*(.vectors)
-+		KEEP(*(.vectors))
- 	}
- 	. = __vectors_start + SIZEOF(.vectors);
- 	__vectors_end = .;
- 
- 	__stubs_start = .;
- 	.stubs ADDR(.vectors) + 0x1000 : AT(__stubs_start) {
--		*(.stubs)
-+		KEEP(*(.stubs))
- 	}
- 	. = __stubs_start + SIZEOF(.stubs);
- 	__stubs_end = .;
-@@ -194,24 +194,24 @@ SECTIONS
- 	}
- 	.init.arch.info : {
- 		__arch_info_begin = .;
--		*(.arch.info.init)
-+		KEEP(*(.arch.info.init))
- 		__arch_info_end = .;
- 	}
- 	.init.tagtable : {
- 		__tagtable_begin = .;
--		*(.taglist.init)
-+		KEEP(*(.taglist.init))
- 		__tagtable_end = .;
- 	}
- #ifdef CONFIG_SMP_ON_UP
- 	.init.smpalt : {
- 		__smpalt_begin = .;
--		*(.alt.smp.init)
-+		KEEP(*(.alt.smp.init))
- 		__smpalt_end = .;
- 	}
- #endif
- 	.init.pv_table : {
- 		__pv_table_begin = .;
--		*(.pv_table)
-+		KEEP(*(.pv_table))
- 		__pv_table_end = .;
- 	}
- 	.init.data : {
---- a/arch/mips/Kconfig
-+++ b/arch/mips/Kconfig
-@@ -56,6 +56,7 @@ config MIPS
- 	select CLONE_BACKWARDS
- 	select HAVE_DEBUG_STACKOVERFLOW
- 	select HAVE_CC_STACKPROTECTOR
-+	select LD_DEAD_CODE_DATA_ELIMINATION
- 	select CPU_PM if CPU_IDLE
- 	select ARCH_HAS_TICK_BROADCAST if GENERIC_CLOCKEVENTS_BROADCAST
- 	select ARCH_BINFMT_ELF_STATE
---- a/arch/mips/kernel/vmlinux.lds.S
-+++ b/arch/mips/kernel/vmlinux.lds.S
-@@ -71,7 +71,7 @@ SECTIONS
- 	/* Exception table for data bus errors */
- 	__dbe_table : {
- 		__start___dbe_table = .;
--		*(__dbe_table)
-+		KEEP(*(__dbe_table))
- 		__stop___dbe_table = .;
- 	}
- 
-@@ -121,7 +121,7 @@ SECTIONS
- 	. = ALIGN(4);
- 	.mips.machines.init : AT(ADDR(.mips.machines.init) - LOAD_OFFSET) {
- 		__mips_machines_start = .;
--		*(.mips.machines.init)
-+		KEEP(*(.mips.machines.init))
- 		__mips_machines_end = .;
- 	}
- 
---- a/include/asm-generic/vmlinux.lds.h
-+++ b/include/asm-generic/vmlinux.lds.h
-@@ -105,7 +105,7 @@
- #ifdef CONFIG_FTRACE_MCOUNT_RECORD
- #define MCOUNT_REC()	. = ALIGN(8);				\
- 			VMLINUX_SYMBOL(__start_mcount_loc) = .; \
--			*(__mcount_loc)				\
-+			KEEP(*(__mcount_loc))			\
- 			VMLINUX_SYMBOL(__stop_mcount_loc) = .;
- #else
- #define MCOUNT_REC()
-@@ -113,7 +113,7 @@
- 
- #ifdef CONFIG_TRACE_BRANCH_PROFILING
- #define LIKELY_PROFILE()	VMLINUX_SYMBOL(__start_annotated_branch_profile) = .; \
--				*(_ftrace_annotated_branch)			      \
-+				KEEP(*(_ftrace_annotated_branch))		      \
- 				VMLINUX_SYMBOL(__stop_annotated_branch_profile) = .;
- #else
- #define LIKELY_PROFILE()
-@@ -121,7 +121,7 @@
- 
- #ifdef CONFIG_PROFILE_ALL_BRANCHES
- #define BRANCH_PROFILE()	VMLINUX_SYMBOL(__start_branch_profile) = .;   \
--				*(_ftrace_branch)			      \
-+				KEEP(*(_ftrace_branch))			      \
- 				VMLINUX_SYMBOL(__stop_branch_profile) = .;
- #else
- #define BRANCH_PROFILE()
-@@ -130,7 +130,7 @@
- #ifdef CONFIG_KPROBES
- #define KPROBE_BLACKLIST()	. = ALIGN(8);				      \
- 				VMLINUX_SYMBOL(__start_kprobe_blacklist) = .; \
--				*(_kprobe_blacklist)			      \
-+				KEEP(*(_kprobe_blacklist))		      \
- 				VMLINUX_SYMBOL(__stop_kprobe_blacklist) = .;
- #else
- #define KPROBE_BLACKLIST()
-@@ -139,10 +139,10 @@
- #ifdef CONFIG_EVENT_TRACING
- #define FTRACE_EVENTS()	. = ALIGN(8);					\
- 			VMLINUX_SYMBOL(__start_ftrace_events) = .;	\
--			*(_ftrace_events)				\
-+			KEEP(*(_ftrace_events))				\
- 			VMLINUX_SYMBOL(__stop_ftrace_events) = .;	\
- 			VMLINUX_SYMBOL(__start_ftrace_enum_maps) = .;	\
--			*(_ftrace_enum_map)				\
-+			KEEP(*(_ftrace_enum_map))			\
- 			VMLINUX_SYMBOL(__stop_ftrace_enum_maps) = .;
- #else
- #define FTRACE_EVENTS()
-@@ -163,7 +163,7 @@
- #ifdef CONFIG_FTRACE_SYSCALLS
- #define TRACE_SYSCALLS() . = ALIGN(8);					\
- 			 VMLINUX_SYMBOL(__start_syscalls_metadata) = .;	\
--			 *(__syscalls_metadata)				\
-+			 KEEP(*(__syscalls_metadata))			\
- 			 VMLINUX_SYMBOL(__stop_syscalls_metadata) = .;
- #else
- #define TRACE_SYSCALLS()
-@@ -172,7 +172,7 @@
- #ifdef CONFIG_SERIAL_EARLYCON
- #define EARLYCON_TABLE() . = ALIGN(8);				\
- 			 VMLINUX_SYMBOL(__earlycon_table) = .;	\
--			 *(__earlycon_table)			\
-+			 KEEP(*(__earlycon_table))		\
- 			 VMLINUX_SYMBOL(__earlycon_table_end) = .;
- #else
- #define EARLYCON_TABLE()
-@@ -185,8 +185,8 @@
- #define _OF_TABLE_1(name)						\
- 	. = ALIGN(8);							\
- 	VMLINUX_SYMBOL(__##name##_of_table) = .;			\
--	*(__##name##_of_table)						\
--	*(__##name##_of_table_end)
-+	KEEP(*(__##name##_of_table))					\
-+	KEEP(*(__##name##_of_table_end))
- 
- #define CLKSRC_OF_TABLES()	OF_TABLE(CONFIG_CLKSRC_OF, clksrc)
- #define IRQCHIP_OF_MATCH_TABLE() OF_TABLE(CONFIG_IRQCHIP, irqchip)
-@@ -209,7 +209,7 @@
- #define KERNEL_DTB()							\
- 	STRUCT_ALIGN();							\
- 	VMLINUX_SYMBOL(__dtb_start) = .;				\
--	*(.dtb.init.rodata)						\
-+	KEEP(*(.dtb.init.rodata))					\
- 	VMLINUX_SYMBOL(__dtb_end) = .;
- 
- /*
-@@ -227,16 +227,17 @@
- 	/* implement dynamic printk debug */				\
- 	. = ALIGN(8);                                                   \
- 	VMLINUX_SYMBOL(__start___jump_table) = .;                       \
--	*(__jump_table)                                                 \
-+	KEEP(*(__jump_table))                                           \
- 	VMLINUX_SYMBOL(__stop___jump_table) = .;                        \
- 	. = ALIGN(8);							\
- 	VMLINUX_SYMBOL(__start___verbose) = .;                          \
--	*(__verbose)                                                    \
-+	KEEP(*(__verbose))                                              \
- 	VMLINUX_SYMBOL(__stop___verbose) = .;				\
- 	LIKELY_PROFILE()		       				\
- 	BRANCH_PROFILE()						\
- 	TRACE_PRINTKS()							\
--	TRACEPOINT_STR()
-+	TRACEPOINT_STR()                                                \
-+	*(.data.[a-zA-Z_]*)
- 
- /*
-  * Data section helpers
-@@ -304,35 +305,35 @@
- 	/* PCI quirks */						\
- 	.pci_fixup        : AT(ADDR(.pci_fixup) - LOAD_OFFSET) {	\
- 		VMLINUX_SYMBOL(__start_pci_fixups_early) = .;		\
--		*(.pci_fixup_early)					\
-+		KEEP(*(.pci_fixup_early))				\
- 		VMLINUX_SYMBOL(__end_pci_fixups_early) = .;		\
- 		VMLINUX_SYMBOL(__start_pci_fixups_header) = .;		\
--		*(.pci_fixup_header)					\
-+		KEEP(*(.pci_fixup_header))				\
- 		VMLINUX_SYMBOL(__end_pci_fixups_header) = .;		\
- 		VMLINUX_SYMBOL(__start_pci_fixups_final) = .;		\
--		*(.pci_fixup_final)					\
-+		KEEP(*(.pci_fixup_final))				\
- 		VMLINUX_SYMBOL(__end_pci_fixups_final) = .;		\
- 		VMLINUX_SYMBOL(__start_pci_fixups_enable) = .;		\
--		*(.pci_fixup_enable)					\
-+		KEEP(*(.pci_fixup_enable))				\
- 		VMLINUX_SYMBOL(__end_pci_fixups_enable) = .;		\
- 		VMLINUX_SYMBOL(__start_pci_fixups_resume) = .;		\
--		*(.pci_fixup_resume)					\
-+		KEEP(*(.pci_fixup_resume))				\
- 		VMLINUX_SYMBOL(__end_pci_fixups_resume) = .;		\
- 		VMLINUX_SYMBOL(__start_pci_fixups_resume_early) = .;	\
--		*(.pci_fixup_resume_early)				\
-+		KEEP(*(.pci_fixup_resume_early))			\
- 		VMLINUX_SYMBOL(__end_pci_fixups_resume_early) = .;	\
- 		VMLINUX_SYMBOL(__start_pci_fixups_suspend) = .;		\
--		*(.pci_fixup_suspend)					\
-+		KEEP(*(.pci_fixup_suspend))				\
- 		VMLINUX_SYMBOL(__end_pci_fixups_suspend) = .;		\
- 		VMLINUX_SYMBOL(__start_pci_fixups_suspend_late) = .;	\
--		*(.pci_fixup_suspend_late)				\
-+		KEEP(*(.pci_fixup_suspend_late))			\
- 		VMLINUX_SYMBOL(__end_pci_fixups_suspend_late) = .;	\
- 	}								\
- 									\
- 	/* Built-in firmware blobs */					\
- 	.builtin_fw        : AT(ADDR(.builtin_fw) - LOAD_OFFSET) {	\
- 		VMLINUX_SYMBOL(__start_builtin_fw) = .;			\
--		*(.builtin_fw)						\
-+		KEEP(*(.builtin_fw))					\
- 		VMLINUX_SYMBOL(__end_builtin_fw) = .;			\
- 	}								\
- 									\
-@@ -410,7 +411,7 @@
- 									\
- 	/* Kernel symbol table: strings */				\
-         __ksymtab_strings : AT(ADDR(__ksymtab_strings) - LOAD_OFFSET) {	\
--		KEEP(*(__ksymtab_strings))				\
-+		*(__ksymtab_strings)					\
- 	}								\
- 									\
- 	/* __*init sections */						\
-@@ -423,14 +424,14 @@
- 	/* Built-in module parameters. */				\
- 	__param : AT(ADDR(__param) - LOAD_OFFSET) {			\
- 		VMLINUX_SYMBOL(__start___param) = .;			\
--		*(__param)						\
-+		KEEP(*(__param))					\
- 		VMLINUX_SYMBOL(__stop___param) = .;			\
- 	}								\
- 									\
- 	/* Built-in module versions. */					\
- 	__modver : AT(ADDR(__modver) - LOAD_OFFSET) {			\
- 		VMLINUX_SYMBOL(__start___modver) = .;			\
--		*(__modver)						\
-+		KEEP(*(__modver))					\
- 		VMLINUX_SYMBOL(__stop___modver) = .;			\
- 		. = ALIGN((align));					\
- 		VMLINUX_SYMBOL(__end_rodata) = .;			\
-@@ -496,7 +497,7 @@
- #define ENTRY_TEXT							\
- 		ALIGN_FUNCTION();					\
- 		VMLINUX_SYMBOL(__entry_text_start) = .;			\
--		*(.entry.text)						\
-+		KEEP(*(.entry.text))					\
- 		VMLINUX_SYMBOL(__entry_text_end) = .;
- 
- #if defined(CONFIG_FUNCTION_GRAPH_TRACER) || defined(CONFIG_KASAN)
-@@ -534,7 +535,7 @@
- 	. = ALIGN(align);						\
- 	__ex_table : AT(ADDR(__ex_table) - LOAD_OFFSET) {		\
- 		VMLINUX_SYMBOL(__start___ex_table) = .;			\
--		*(__ex_table)						\
-+		KEEP(*(__ex_table))						\
- 		VMLINUX_SYMBOL(__stop___ex_table) = .;			\
- 	}
- 
-@@ -550,9 +551,9 @@
- #ifdef CONFIG_CONSTRUCTORS
- #define KERNEL_CTORS()	. = ALIGN(8);			   \
- 			VMLINUX_SYMBOL(__ctors_start) = .; \
--			*(.ctors)			   \
-+			KEEP(*(.ctors))			   \
- 			*(SORT(.init_array.*))		   \
--			*(.init_array)			   \
-+			KEEP(*(.init_array))		   \
- 			VMLINUX_SYMBOL(__ctors_end) = .;
- #else
- #define KERNEL_CTORS()
-@@ -609,7 +610,7 @@
- #define SBSS(sbss_align)						\
- 	. = ALIGN(sbss_align);						\
- 	.sbss : AT(ADDR(.sbss) - LOAD_OFFSET) {				\
--		*(.sbss)						\
-+		*(.sbss .sbss.*)					\
- 		*(.scommon)						\
- 	}
- 
-@@ -676,7 +677,7 @@
- 	. = ALIGN(8);							\
- 	__bug_table : AT(ADDR(__bug_table) - LOAD_OFFSET) {		\
- 		VMLINUX_SYMBOL(__start___bug_table) = .;		\
--		*(__bug_table)						\
-+		KEEP(*(__bug_table))					\
- 		VMLINUX_SYMBOL(__stop___bug_table) = .;			\
- 	}
- #else
-@@ -688,7 +689,7 @@
- 	. = ALIGN(4);							\
- 	.tracedata : AT(ADDR(.tracedata) - LOAD_OFFSET) {		\
- 		VMLINUX_SYMBOL(__tracedata_start) = .;			\
--		*(.tracedata)						\
-+		KEEP(*(.tracedata))					\
- 		VMLINUX_SYMBOL(__tracedata_end) = .;			\
- 	}
- #else
-@@ -705,7 +706,7 @@
- #define INIT_SETUP(initsetup_align)					\
- 		. = ALIGN(initsetup_align);				\
- 		VMLINUX_SYMBOL(__setup_start) = .;			\
--		*(.init.setup)						\
-+		KEEP(*(.init.setup))					\
- 		VMLINUX_SYMBOL(__setup_end) = .;
- 
- #define INIT_CALLS_LEVEL(level)						\
--- a/target/linux/generic/hack-4.9/221-module_exports.patch	2022-03-22 08:54:47.226464701 +0800
+++ b/target/linux/generic/hack-4.9/221-module_exports.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,101 +0,0 @@
-From b14784e7883390c20ed3ff904892255404a5914b Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 17:05:53 +0200
-Subject: add an optional config option for stripping all unnecessary symbol exports from the kernel image
-
-lede-commit: bb5a40c64b7c4f4848509fa0a6625055fc9e66cc
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/asm-generic/vmlinux.lds.h | 18 +++++++++++++++---
- include/linux/export.h            |  9 ++++++++-
- scripts/Makefile.build            |  2 +-
- 3 files changed, 24 insertions(+), 5 deletions(-)
-
---- a/include/asm-generic/vmlinux.lds.h
-+++ b/include/asm-generic/vmlinux.lds.h
-@@ -54,6 +54,16 @@
- #define LOAD_OFFSET 0
- #endif
- 
-+#ifndef SYMTAB_KEEP
-+#define SYMTAB_KEEP KEEP(*(SORT(___ksymtab+*)))
-+#define SYMTAB_KEEP_GPL KEEP(*(SORT(___ksymtab_gpl+*)))
-+#endif
-+
-+#ifndef SYMTAB_DISCARD
-+#define SYMTAB_DISCARD
-+#define SYMTAB_DISCARD_GPL
-+#endif
-+
- #include <linux/export.h>
- 
- /* Align . to a 8 byte boundary equals to maximum function alignment. */
-@@ -342,14 +352,14 @@
- 	/* Kernel symbol table: Normal symbols */			\
- 	__ksymtab         : AT(ADDR(__ksymtab) - LOAD_OFFSET) {		\
- 		VMLINUX_SYMBOL(__start___ksymtab) = .;			\
--		KEEP(*(SORT(___ksymtab+*)))				\
-+		SYMTAB_KEEP						\
- 		VMLINUX_SYMBOL(__stop___ksymtab) = .;			\
- 	}								\
- 									\
- 	/* Kernel symbol table: GPL-only symbols */			\
- 	__ksymtab_gpl     : AT(ADDR(__ksymtab_gpl) - LOAD_OFFSET) {	\
- 		VMLINUX_SYMBOL(__start___ksymtab_gpl) = .;		\
--		KEEP(*(SORT(___ksymtab_gpl+*)))				\
-+		SYMTAB_KEEP_GPL						\
- 		VMLINUX_SYMBOL(__stop___ksymtab_gpl) = .;		\
- 	}								\
- 									\
-@@ -411,7 +421,7 @@
- 									\
- 	/* Kernel symbol table: strings */				\
-         __ksymtab_strings : AT(ADDR(__ksymtab_strings) - LOAD_OFFSET) {	\
--		*(__ksymtab_strings)					\
-+		*(__ksymtab_strings+*)					\
- 	}								\
- 									\
- 	/* __*init sections */						\
-@@ -763,6 +773,8 @@
- 	EXIT_TEXT							\
- 	EXIT_DATA							\
- 	EXIT_CALL							\
-+	SYMTAB_DISCARD							\
-+	SYMTAB_DISCARD_GPL						\
- 	*(.discard)							\
- 	*(.discard.*)							\
- 	}
---- a/include/linux/export.h
-+++ b/include/linux/export.h
-@@ -53,12 +53,19 @@ extern struct module __this_module;
- #define __CRC_SYMBOL(sym, sec)
- #endif
- 
-+#ifdef MODULE
-+#define __EXPORT_SUFFIX(sym)
-+#else
-+#define __EXPORT_SUFFIX(sym) "+" #sym
-+#endif
-+
- /* For every exported symbol, place a struct in the __ksymtab section */
- #define ___EXPORT_SYMBOL(sym, sec)					\
- 	extern typeof(sym) sym;						\
- 	__CRC_SYMBOL(sym, sec)						\
- 	static const char __kstrtab_##sym[]				\
--	__attribute__((section("__ksymtab_strings"), aligned(1)))	\
-+	__attribute__((section("__ksymtab_strings"			\
-+	  __EXPORT_SUFFIX(sym)), aligned(1)))				\
- 	= VMLINUX_SYMBOL_STR(sym);					\
- 	static const struct kernel_symbol __ksymtab_##sym		\
- 	__used								\
---- a/scripts/Makefile.build
-+++ b/scripts/Makefile.build
-@@ -409,7 +409,7 @@ targets += $(extra-y) $(MAKECMDGOALS) $(
- # Linker scripts preprocessor (.lds.S -> .lds)
- # ---------------------------------------------------------------------------
- quiet_cmd_cpp_lds_S = LDS     $@
--      cmd_cpp_lds_S = $(CPP) $(cpp_flags) -P -C -U$(ARCH) \
-+      cmd_cpp_lds_S = $(CPP) $(EXTRA_LDSFLAGS) $(cpp_flags) -P -C -U$(ARCH) \
- 	                     -D__ASSEMBLY__ -DLINKER_SCRIPT -o $@ $<
- 
- $(obj)/%.lds: $(src)/%.lds.S FORCE
--- a/target/linux/generic/hack-4.9/230-openwrt_lzma_options.patch	2022-03-22 08:54:47.226464701 +0800
+++ b/target/linux/generic/hack-4.9/230-openwrt_lzma_options.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,71 +0,0 @@
-From b3d00b452467f621317953d9e4c6f9ae8dcfd271 Mon Sep 17 00:00:00 2001
-From: Imre Kaloz <kaloz@openwrt.org>
-Date: Fri, 7 Jul 2017 17:06:55 +0200
-Subject: use the openwrt lzma options for now
-
-lede-commit: 548de949f392049420a6a1feeef118b30ab8ea8c
-Signed-off-by: Imre Kaloz <kaloz@openwrt.org>
----
- lib/decompress.c              |  1 +
- scripts/Makefile.lib          |  2 +-
- scripts/gen_initramfs_list.sh | 10 +++++-----
- 3 files changed, 7 insertions(+), 6 deletions(-)
-
---- a/lib/decompress.c
-+++ b/lib/decompress.c
-@@ -48,6 +48,7 @@ static const struct compress_format comp
- 	{ {0x1f, 0x9e}, "gzip", gunzip },
- 	{ {0x42, 0x5a}, "bzip2", bunzip2 },
- 	{ {0x5d, 0x00}, "lzma", unlzma },
-+	{ {0x6d, 0x00}, "lzma-openwrt", unlzma },
- 	{ {0xfd, 0x37}, "xz", unxz },
- 	{ {0x89, 0x4c}, "lzo", unlzo },
- 	{ {0x02, 0x21}, "lz4", unlz4 },
---- a/scripts/Makefile.lib
-+++ b/scripts/Makefile.lib
-@@ -344,7 +344,7 @@ cmd_bzip2 = (cat $(filter-out FORCE,$^)
- 
- quiet_cmd_lzma = LZMA    $@
- cmd_lzma = (cat $(filter-out FORCE,$^) | \
--	lzma -9 && $(call size_append, $(filter-out FORCE,$^))) > $@ || \
-+	lzma e -d20 -lc1 -lp2 -pb2 -eos -si -so && $(call size_append, $(filter-out FORCE,$^))) > $@ || \
- 	(rm -f $@ ; false)
- 
- quiet_cmd_lzo = LZO     $@
---- a/scripts/gen_initramfs_list.sh
-+++ b/scripts/gen_initramfs_list.sh
-@@ -229,7 +229,7 @@ cpio_list=
- output="/dev/stdout"
- output_file=""
- is_cpio_compressed=
--compr="gzip -n -9 -f"
-+compr="gzip -n -9 -f -"
- 
- arg="$1"
- case "$arg" in
-@@ -245,13 +245,13 @@ case "$arg" in
- 		output=${cpio_list}
- 		echo "$output_file" | grep -q "\.gz$" \
-                 && [ -x "`which gzip 2> /dev/null`" ] \
--                && compr="gzip -n -9 -f"
-+                && compr="gzip -n -9 -f -"
- 		echo "$output_file" | grep -q "\.bz2$" \
-                 && [ -x "`which bzip2 2> /dev/null`" ] \
--                && compr="bzip2 -9 -f"
-+                && compr="bzip2 -9 -f -"
- 		echo "$output_file" | grep -q "\.lzma$" \
-                 && [ -x "`which lzma 2> /dev/null`" ] \
--                && compr="lzma -9 -f"
-+                && compr="lzma e -d20 -lc1 -lp2 -pb2 -eos -si -so"
- 		echo "$output_file" | grep -q "\.xz$" \
-                 && [ -x "`which xz 2> /dev/null`" ] \
-                 && compr="xz --check=crc32 --lzma2=dict=1MiB"
-@@ -318,7 +318,7 @@ if [ ! -z ${output_file} ]; then
- 	if [ "${is_cpio_compressed}" = "compressed" ]; then
- 		cat ${cpio_tfile} > ${output_file}
- 	else
--		(cat ${cpio_tfile} | ${compr}  - > ${output_file}) \
-+		(cat ${cpio_tfile} | ${compr} > ${output_file}) \
- 		|| (rm -f ${output_file} ; false)
- 	fi
- 	[ -z ${cpio_file} ] && rm ${cpio_tfile}
--- a/target/linux/generic/hack-4.9/250-netfilter_depends.patch	2022-03-22 08:54:47.227464703 +0800
+++ b/target/linux/generic/hack-4.9/250-netfilter_depends.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,27 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: hack: net: remove bogus netfilter dependencies
-
-lede-commit: 589d2a377dee27d206fc3725325309cf649e4df6
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- net/netfilter/Kconfig | 2 --
- 1 file changed, 2 deletions(-)
-
---- a/net/netfilter/Kconfig
-+++ b/net/netfilter/Kconfig
-@@ -218,7 +218,6 @@ config NF_CONNTRACK_FTP
- 
- config NF_CONNTRACK_H323
- 	tristate "H.323 protocol support"
--	depends on IPV6 || IPV6=n
- 	depends on NETFILTER_ADVANCED
- 	help
- 	  H.323 is a VoIP signalling protocol from ITU-T. As one of the most
-@@ -968,7 +967,6 @@ config NETFILTER_XT_TARGET_SECMARK
- 
- config NETFILTER_XT_TARGET_TCPMSS
- 	tristate '"TCPMSS" target support'
--	depends on IPV6 || IPV6=n
- 	default m if NETFILTER_ADVANCED=n
- 	---help---
- 	  This option adds a `TCPMSS' target, which allows you to alter the
--- a/target/linux/generic/hack-4.9/251-sound_kconfig.patch	2022-03-22 08:54:47.227464703 +0800
+++ b/target/linux/generic/hack-4.9/251-sound_kconfig.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,195 +0,0 @@
-From da3c50704f14132f4adf80d48e9a4cd5d46e54c9 Mon Sep 17 00:00:00 2001
-From: John Crispin <john@phrozen.org>
-Date: Fri, 7 Jul 2017 17:09:21 +0200
-Subject: kconfig: owrt specifc dependencies
-
-Signed-off-by: John Crispin <john@phrozen.org>
----
- crypto/Kconfig        | 10 +++++-----
- drivers/bcma/Kconfig  |  1 +
- drivers/ssb/Kconfig   |  3 ++-
- lib/Kconfig           |  8 ++++----
- net/netfilter/Kconfig |  2 +-
- net/wireless/Kconfig  | 17 ++++++++++-------
- sound/core/Kconfig    |  4 ++--
- 7 files changed, 25 insertions(+), 20 deletions(-)
-
---- a/crypto/Kconfig
-+++ b/crypto/Kconfig
-@@ -32,7 +32,7 @@ config CRYPTO_FIPS
- 	  this is.
- 
- config CRYPTO_ALGAPI
--	tristate
-+	tristate "ALGAPI"
- 	select CRYPTO_ALGAPI2
- 	help
- 	  This option provides the API for cryptographic algorithms.
-@@ -41,7 +41,7 @@ config CRYPTO_ALGAPI2
- 	tristate
- 
- config CRYPTO_AEAD
--	tristate
-+	tristate "AEAD"
- 	select CRYPTO_AEAD2
- 	select CRYPTO_ALGAPI
- 
-@@ -52,7 +52,7 @@ config CRYPTO_AEAD2
- 	select CRYPTO_RNG2
- 
- config CRYPTO_BLKCIPHER
--	tristate
-+	tristate "BLKCIPHER"
- 	select CRYPTO_BLKCIPHER2
- 	select CRYPTO_ALGAPI
- 
-@@ -63,7 +63,7 @@ config CRYPTO_BLKCIPHER2
- 	select CRYPTO_WORKQUEUE
- 
- config CRYPTO_HASH
--	tristate
-+	tristate "HASH"
- 	select CRYPTO_HASH2
- 	select CRYPTO_ALGAPI
- 
-@@ -72,7 +72,7 @@ config CRYPTO_HASH2
- 	select CRYPTO_ALGAPI2
- 
- config CRYPTO_RNG
--	tristate
-+	tristate "RNG"
- 	select CRYPTO_RNG2
- 	select CRYPTO_ALGAPI
- 
---- a/drivers/bcma/Kconfig
-+++ b/drivers/bcma/Kconfig
-@@ -17,6 +17,7 @@ config BCMA
- config BCMA_BLOCKIO
- 	bool
- 	depends on BCMA
-+	default y
- 
- config BCMA_HOST_PCI_POSSIBLE
- 	bool
---- a/drivers/ssb/Kconfig
-+++ b/drivers/ssb/Kconfig
-@@ -29,6 +29,7 @@ config SSB_SPROM
- config SSB_BLOCKIO
- 	bool
- 	depends on SSB
-+	default y
- 
- config SSB_PCIHOST_POSSIBLE
- 	bool
-@@ -49,7 +50,7 @@ config SSB_PCIHOST
- config SSB_B43_PCI_BRIDGE
- 	bool
- 	depends on SSB_PCIHOST
--	default n
-+	default y
- 
- config SSB_PCMCIAHOST_POSSIBLE
- 	bool
---- a/lib/Kconfig
-+++ b/lib/Kconfig
-@@ -340,16 +340,16 @@ config BCH_CONST_T
- # Textsearch support is select'ed if needed
- #
- config TEXTSEARCH
--	bool
-+	boolean	"Textsearch support"
- 
- config TEXTSEARCH_KMP
--	tristate
-+	tristate "Textsearch KMP"
- 
- config TEXTSEARCH_BM
--	tristate
-+	tristate "Textsearch BM"
- 
- config TEXTSEARCH_FSM
--	tristate
-+	tristate "Textsearch FSM"
- 
- config BTREE
- 	bool
---- a/net/netfilter/Kconfig
-+++ b/net/netfilter/Kconfig
-@@ -10,7 +10,7 @@ config NETFILTER_INGRESS
- 	  infrastructure.
- 
- config NETFILTER_NETLINK
--	tristate
-+	tristate "Netfilter NFNETLINK interface"
- 
- config NETFILTER_NETLINK_ACCT
- tristate "Netfilter NFACCT over NFNETLINK interface"
---- a/net/wireless/Kconfig
-+++ b/net/wireless/Kconfig
-@@ -1,5 +1,5 @@
- config WIRELESS_EXT
--	bool
-+	bool "Wireless extensions"
- 
- config WEXT_CORE
- 	def_bool y
-@@ -11,10 +11,10 @@ config WEXT_PROC
- 	depends on WEXT_CORE
- 
- config WEXT_SPY
--	bool
-+	bool "WEXT_SPY"
- 
- config WEXT_PRIV
--	bool
-+	bool "WEXT_PRIV"
- 
- config CFG80211
- 	tristate "cfg80211 - wireless configuration API"
-@@ -188,7 +188,7 @@ config CFG80211_WEXT_EXPORT
- 	  wext compatibility symbols to be exported.
- 
- config LIB80211
--	tristate
-+	tristate "LIB80211"
- 	default n
- 	help
- 	  This options enables a library of common routines used
-@@ -197,13 +197,16 @@ config LIB80211
- 	  Drivers should select this themselves if needed.
- 
- config LIB80211_CRYPT_WEP
--	tristate
-+	tristate "LIB80211_CRYPT_WEP"
-+	select LIB80211
- 
- config LIB80211_CRYPT_CCMP
--	tristate
-+	tristate "LIB80211_CRYPT_CCMP"
-+	select LIB80211
- 
- config LIB80211_CRYPT_TKIP
--	tristate
-+	tristate "LIB80211_CRYPT_TKIP"
-+	select LIB80211
- 
- config LIB80211_DEBUG
- 	bool "lib80211 debugging messages"
---- a/sound/core/Kconfig
-+++ b/sound/core/Kconfig
-@@ -16,13 +16,13 @@ config SND_DMAENGINE_PCM
- 	tristate
- 
- config SND_HWDEP
--	tristate
-+	tristate "Sound hardware support"
- 
- config SND_RAWMIDI
- 	tristate
- 
- config SND_COMPRESS_OFFLOAD
--	tristate
-+	tristate "Compression offloading support"
- 
- config SND_JACK
- 	bool
--- a/target/linux/generic/hack-4.9/259-regmap_dynamic.patch	2022-03-22 08:54:47.227464703 +0800
+++ b/target/linux/generic/hack-4.9/259-regmap_dynamic.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,100 +0,0 @@
-From 811d9e2268a62b830cfe93cd8bc929afcb8b198b Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 15 Jul 2017 21:12:38 +0200
-Subject: kernel: move regmap bloat out of the kernel image if it is only being used in modules
-
-lede-commit: 96f39119815028073583e4fca3a9c5fe9141e998
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- drivers/base/regmap/Kconfig  | 15 ++++++++++-----
- drivers/base/regmap/Makefile | 12 ++++++++----
- drivers/base/regmap/regmap.c |  3 +++
- include/linux/regmap.h       |  2 +-
- 4 files changed, 22 insertions(+), 10 deletions(-)
-
---- a/drivers/base/regmap/Kconfig
-+++ b/drivers/base/regmap/Kconfig
-@@ -3,9 +3,8 @@
- # subsystems should select the appropriate symbols.
- 
- config REGMAP
--	default y if (REGMAP_I2C || REGMAP_SPI || REGMAP_SPMI || REGMAP_AC97 || REGMAP_MMIO || REGMAP_IRQ)
- 	select IRQ_DOMAIN if REGMAP_IRQ
--	bool
-+	tristate
- 
- config REGCACHE_COMPRESSED
- 	select LZO_COMPRESS
-@@ -17,18 +16,24 @@ config REGMAP_AC97
- 
- config REGMAP_I2C
- 	tristate
-+	select REGMAP
- 	depends on I2C
- 
- config REGMAP_SPI
- 	tristate
-+	select REGMAP
-+	depends on SPI_MASTER
- 	depends on SPI
- 
- config REGMAP_SPMI
-+	select REGMAP
- 	tristate
- 	depends on SPMI
- 
- config REGMAP_MMIO
- 	tristate
-+	select REGMAP
- 
- config REGMAP_IRQ
-+	select REGMAP
- 	bool
---- a/drivers/base/regmap/Makefile
-+++ b/drivers/base/regmap/Makefile
-@@ -1,10 +1,14 @@
- # For include/trace/define_trace.h to include trace.h
- CFLAGS_regmap.o := -I$(src)
- 
--obj-$(CONFIG_REGMAP) += regmap.o regcache.o
--obj-$(CONFIG_REGMAP) += regcache-rbtree.o regcache-flat.o
--obj-$(CONFIG_REGCACHE_COMPRESSED) += regcache-lzo.o
--obj-$(CONFIG_DEBUG_FS) += regmap-debugfs.o
-+regmap-core-objs = regmap.o regcache.o regcache-rbtree.o regcache-flat.o
-+ifdef CONFIG_DEBUG_FS
-+regmap-core-objs += regmap-debugfs.o
-+endif
-+ifdef CONFIG_REGCACHE_COMPRESSED
-+regmap-core-objs += regcache-lzo.o
-+endif
-+obj-$(CONFIG_REGMAP) += regmap-core.o
- obj-$(CONFIG_REGMAP_AC97) += regmap-ac97.o
- obj-$(CONFIG_REGMAP_I2C) += regmap-i2c.o
- obj-$(CONFIG_REGMAP_SPI) += regmap-spi.o
---- a/drivers/base/regmap/regmap.c
-+++ b/drivers/base/regmap/regmap.c
-@@ -13,6 +13,7 @@
- #include <linux/device.h>
- #include <linux/slab.h>
- #include <linux/export.h>
-+#include <linux/module.h>
- #include <linux/mutex.h>
- #include <linux/err.h>
- #include <linux/of.h>
-@@ -2915,3 +2916,5 @@ static int __init regmap_initcall(void)
- 	return 0;
- }
- postcore_initcall(regmap_initcall);
-+
-+MODULE_LICENSE("GPL");
---- a/include/linux/regmap.h
-+++ b/include/linux/regmap.h
-@@ -135,7 +135,7 @@ struct reg_sequence {
- 	pollret ?: ((cond) ? 0 : -ETIMEDOUT); \
- })
- 
--#ifdef CONFIG_REGMAP
-+#if IS_ENABLED(CONFIG_REGMAP)
- 
- enum regmap_endian {
- 	/* Unspecified -> 0 -> Backwards compatible default */
--- a/target/linux/generic/hack-4.9/260-crypto_test_dependencies.patch	2022-03-22 08:54:47.228464704 +0800
+++ b/target/linux/generic/hack-4.9/260-crypto_test_dependencies.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,62 +0,0 @@
-From fd1799b0bf5efa46dd3e6dfbbf3955564807e508 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 17:12:51 +0200
-Subject: kernel: prevent cryptomgr from pulling in useless extra dependencies for tests that are not run
-
-Reduces kernel size after LZMA by about 5k on MIPS
-
-lede-commit: 044c316167e076479a344c59905e5b435b84a77f
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- crypto/Kconfig   | 13 ++++++-------
- crypto/algboss.c |  4 ++++
- 2 files changed, 10 insertions(+), 7 deletions(-)
-
---- a/crypto/Kconfig
-+++ b/crypto/Kconfig
-@@ -132,12 +132,12 @@ config CRYPTO_MANAGER
- 	  cbc(aes).
- 
- config CRYPTO_MANAGER2
--	def_tristate CRYPTO_MANAGER || (CRYPTO_MANAGER!=n && CRYPTO_ALGAPI=y)
--	select CRYPTO_AEAD2
--	select CRYPTO_HASH2
--	select CRYPTO_BLKCIPHER2
--	select CRYPTO_AKCIPHER2
--	select CRYPTO_KPP2
-+	def_tristate CRYPTO_MANAGER || (CRYPTO_MANAGER!=n && CRYPTO_ALGAPI=y && !CRYPTO_MANAGER_DISABLE_TESTS)
-+	select CRYPTO_AEAD2 if !CRYPTO_MANAGER_DISABLE_TESTS
-+	select CRYPTO_HASH2 if !CRYPTO_MANAGER_DISABLE_TESTS
-+	select CRYPTO_BLKCIPHER2 if !CRYPTO_MANAGER_DISABLE_TESTS
-+	select CRYPTO_AKCIPHER2 if !CRYPTO_MANAGER_DISABLE_TESTS
-+	select CRYPTO_KPP2 if !CRYPTO_MANAGER_DISABLE_TESTS
- 
- config CRYPTO_USER
- 	tristate "Userspace cryptographic algorithm configuration"
-@@ -150,7 +150,6 @@ config CRYPTO_USER
- config CRYPTO_MANAGER_DISABLE_TESTS
- 	bool "Disable run-time self tests"
- 	default y
--	depends on CRYPTO_MANAGER2
- 	help
- 	  Disable run-time self tests that normally take place at
- 	  algorithm registration.
---- a/crypto/algboss.c
-+++ b/crypto/algboss.c
-@@ -248,12 +248,16 @@ static int cryptomgr_schedule_test(struc
- 	type = alg->cra_flags;
- 
- 	/* This piece of crap needs to disappear into per-type test hooks. */
-+#ifdef CONFIG_CRYPTO_MANAGER_DISABLE_TESTS
-+	type |= CRYPTO_ALG_TESTED;
-+#else
- 	if (!((type ^ CRYPTO_ALG_TYPE_BLKCIPHER) &
- 	      CRYPTO_ALG_TYPE_BLKCIPHER_MASK) && !(type & CRYPTO_ALG_GENIV) &&
- 	    ((alg->cra_flags & CRYPTO_ALG_TYPE_MASK) ==
- 	     CRYPTO_ALG_TYPE_BLKCIPHER ? alg->cra_blkcipher.ivsize :
- 					 alg->cra_ablkcipher.ivsize))
- 		type |= CRYPTO_ALG_TESTED;
-+#endif
- 
- 	param->type = type;
- 
--- a/target/linux/generic/hack-4.9/280-rfkill-stubs.patch	2022-03-22 08:54:47.228464704 +0800
+++ b/target/linux/generic/hack-4.9/280-rfkill-stubs.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,94 +0,0 @@
-From 236c1acdfef5958010ac9814a9872e0a46fd78ee Mon Sep 17 00:00:00 2001
-From: John Crispin <john@phrozen.org>
-Date: Fri, 7 Jul 2017 17:13:44 +0200
-Subject: rfkill: add fake rfkill support
-
-allow building of modules depending on RFKILL even if RFKILL is not enabled.
-
-Signed-off-by: John Crispin <john@phrozen.org>
----
- include/linux/rfkill.h |  2 +-
- net/Makefile           |  2 +-
- net/rfkill/Kconfig     | 14 +++++++++-----
- net/rfkill/Makefile    |  2 +-
- 4 files changed, 12 insertions(+), 8 deletions(-)
-
---- a/include/linux/rfkill.h
-+++ b/include/linux/rfkill.h
-@@ -64,7 +64,7 @@ struct rfkill_ops {
- 	int	(*set_block)(void *data, bool blocked);
- };
- 
--#if defined(CONFIG_RFKILL) || defined(CONFIG_RFKILL_MODULE)
-+#if defined(CONFIG_RFKILL_FULL) || defined(CONFIG_RFKILL_FULL_MODULE)
- /**
-  * rfkill_alloc - allocate rfkill structure
-  * @name: name of the struct -- the string is not copied internally
---- a/net/Makefile
-+++ b/net/Makefile
-@@ -51,7 +51,7 @@ obj-$(CONFIG_MAC80211)		+= mac80211/
- obj-$(CONFIG_TIPC)		+= tipc/
- obj-$(CONFIG_NETLABEL)		+= netlabel/
- obj-$(CONFIG_IUCV)		+= iucv/
--obj-$(CONFIG_RFKILL)		+= rfkill/
-+obj-$(CONFIG_RFKILL_FULL)	+= rfkill/
- obj-$(CONFIG_NET_9P)		+= 9p/
- obj-$(CONFIG_CAIF)		+= caif/
- ifneq ($(CONFIG_DCB),)
---- a/net/rfkill/Kconfig
-+++ b/net/rfkill/Kconfig
-@@ -1,7 +1,11 @@
- #
- # RF switch subsystem configuration
- #
--menuconfig RFKILL
-+config RFKILL
-+	bool
-+	default y
-+
-+menuconfig RFKILL_FULL
- 	tristate "RF switch subsystem support"
- 	help
- 	  Say Y here if you want to have control over RF switches
-@@ -13,19 +17,19 @@ menuconfig RFKILL
- # LED trigger support
- config RFKILL_LEDS
- 	bool
--	depends on RFKILL
-+	depends on RFKILL_FULL
- 	depends on LEDS_TRIGGERS = y || RFKILL = LEDS_TRIGGERS
- 	default y
- 
- config RFKILL_INPUT
- 	bool "RF switch input support" if EXPERT
--	depends on RFKILL
-+	depends on RFKILL_FULL
- 	depends on INPUT = y || RFKILL = INPUT
- 	default y if !EXPERT
- 
- config RFKILL_REGULATOR
- 	tristate "Generic rfkill regulator driver"
--	depends on RFKILL || !RFKILL
-+	depends on RFKILL_FULL || !RFKILL_FULL
- 	depends on REGULATOR
- 	help
-           This options enable controlling radio transmitters connected to
-@@ -36,7 +40,7 @@ config RFKILL_REGULATOR
- 
- config RFKILL_GPIO
- 	tristate "GPIO RFKILL driver"
--	depends on RFKILL
-+	depends on RFKILL_FULL
- 	depends on GPIOLIB || COMPILE_TEST
- 	default n
- 	help
---- a/net/rfkill/Makefile
-+++ b/net/rfkill/Makefile
-@@ -4,6 +4,6 @@
- 
- rfkill-y			+= core.o
- rfkill-$(CONFIG_RFKILL_INPUT)	+= input.o
--obj-$(CONFIG_RFKILL)		+= rfkill.o
-+obj-$(CONFIG_RFKILL_FULL)	+= rfkill.o
- obj-$(CONFIG_RFKILL_REGULATOR)	+= rfkill-regulator.o
- obj-$(CONFIG_RFKILL_GPIO)	+= rfkill-gpio.o
--- a/target/linux/generic/hack-4.9/300-MIPS-r4k_cache-use-more-efficient-cache-blast.patch	2022-03-22 08:54:47.228464704 +0800
+++ b/target/linux/generic/hack-4.9/300-MIPS-r4k_cache-use-more-efficient-cache-blast.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,66 +0,0 @@
-From: Ben Menchaca <ben.menchaca@qca.qualcomm.com>
-Date: Fri, 7 Jun 2013 18:35:22 -0500
-Subject: MIPS: r4k_cache: use more efficient cache blast
-
-Optimize the compiler output for larger cache blast cases that are
-common for DMA-based networking.
-
-Signed-off-by: Ben Menchaca <ben.menchaca@qca.qualcomm.com>
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
---- a/arch/mips/include/asm/r4kcache.h
-+++ b/arch/mips/include/asm/r4kcache.h
-@@ -665,16 +665,48 @@ static inline void prot##extra##blast_##
- 						    unsigned long end)	\
- {									\
- 	unsigned long lsize = cpu_##desc##_line_size();			\
-+	unsigned long lsize_2 = lsize * 2;				\
-+	unsigned long lsize_3 = lsize * 3;				\
-+	unsigned long lsize_4 = lsize * 4;				\
-+	unsigned long lsize_5 = lsize * 5;				\
-+	unsigned long lsize_6 = lsize * 6;				\
-+	unsigned long lsize_7 = lsize * 7;				\
-+	unsigned long lsize_8 = lsize * 8;				\
- 	unsigned long addr = start & ~(lsize - 1);			\
--	unsigned long aend = (end - 1) & ~(lsize - 1);			\
-+	unsigned long aend = (end + lsize - 1) & ~(lsize - 1);		\
-+	int lines = (aend - addr) / lsize;				\
- 									\
- 	__##pfx##flush_prologue						\
- 									\
--	while (1) {							\
-+	while (lines >= 8) {						\
-+		prot##cache_op(hitop, addr);				\
-+		prot##cache_op(hitop, addr + lsize);			\
-+		prot##cache_op(hitop, addr + lsize_2);			\
-+		prot##cache_op(hitop, addr + lsize_3);			\
-+		prot##cache_op(hitop, addr + lsize_4);			\
-+		prot##cache_op(hitop, addr + lsize_5);			\
-+		prot##cache_op(hitop, addr + lsize_6);			\
-+		prot##cache_op(hitop, addr + lsize_7);			\
-+		addr += lsize_8;					\
-+		lines -= 8;						\
-+	}								\
-+									\
-+	if (lines & 0x4) {						\
-+		prot##cache_op(hitop, addr);				\
-+		prot##cache_op(hitop, addr + lsize);			\
-+		prot##cache_op(hitop, addr + lsize_2);			\
-+		prot##cache_op(hitop, addr + lsize_3);			\
-+		addr += lsize_4;					\
-+	}								\
-+									\
-+	if (lines & 0x2) {						\
-+		prot##cache_op(hitop, addr);				\
-+		prot##cache_op(hitop, addr + lsize);			\
-+		addr += lsize_2;					\
-+	}								\
-+									\
-+	if (lines & 0x1) {						\
- 		prot##cache_op(hitop, addr);				\
--		if (addr == aend)					\
--			break;						\
--		addr += lsize;						\
- 	}								\
- 									\
- 	__##pfx##flush_epilogue						\
--- a/target/linux/generic/hack-4.9/301-mips_image_cmdline_hack.patch	2022-03-22 08:54:47.228464704 +0800
+++ b/target/linux/generic/hack-4.9/301-mips_image_cmdline_hack.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,38 +0,0 @@
-From: John Crispin <john@phrozen.org>
-Subject: hack: kernel: add generic image_cmdline hack to MIPS targets
-
-lede-commit: d59f5b3a987a48508257a0ddbaeadc7909f9f976
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- arch/mips/Kconfig       | 4 ++++
- arch/mips/kernel/head.S | 6 ++++++
- 2 files changed, 10 insertions(+)
-
---- a/arch/mips/Kconfig
-+++ b/arch/mips/Kconfig
-@@ -1157,6 +1157,10 @@ config SYNC_R4K
- config MIPS_MACHINE
- 	def_bool n
- 
-+config IMAGE_CMDLINE_HACK
-+	bool "OpenWrt specific image command line hack"
-+	default n
-+
- config NO_IOPORT_MAP
- 	def_bool n
- 
---- a/arch/mips/kernel/head.S
-+++ b/arch/mips/kernel/head.S
-@@ -79,6 +79,12 @@ FEXPORT(__kernel_entry)
- 	j	kernel_entry
- #endif
- 
-+#ifdef CONFIG_IMAGE_CMDLINE_HACK
-+	.ascii	"CMDLINE:"
-+EXPORT(__image_cmdline)
-+	.fill	0x400
-+#endif /* CONFIG_IMAGE_CMDLINE_HACK */
-+
- 	__REF
- 
- NESTED(kernel_entry, 16, sp)			# kernel entry point
--- a/target/linux/generic/hack-4.9/321-powerpc_crtsavres_prereq.patch	2022-03-22 08:54:47.229464706 +0800
+++ b/target/linux/generic/hack-4.9/321-powerpc_crtsavres_prereq.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,26 +0,0 @@
-From 107c0964cb8db7ca28ac5199426414fdab3c274d Mon Sep 17 00:00:00 2001
-From: "Alexandros C. Couloumbis" <alex@ozo.com>
-Date: Fri, 7 Jul 2017 17:14:51 +0200
-Subject: hack: arch: powerpc: drop register save/restore library from modules
-
-Upstream GCC uses a libgcc function for saving/restoring registers. This
-makes the code bigger, and upstream kernels need to carry that function
-for every single kernel module. Our GCC is patched to avoid those
-references, so we can drop the extra bloat for modules.
-
-lede-commit: e8e1084654f50904e6bf77b70b2de3f137d7b3ec
-Signed-off-by: Alexandros C. Couloumbis <alex@ozo.com>
----
- arch/powerpc/Makefile | 1 -
- 1 file changed, 1 deletion(-)
-
---- a/arch/powerpc/Makefile
-+++ b/arch/powerpc/Makefile
-@@ -188,7 +188,6 @@ else
- CHECKFLAGS	+= -D__LITTLE_ENDIAN__
- endif
- 
--KBUILD_LDFLAGS_MODULE += arch/powerpc/lib/crtsavres.o
- 
- ifeq ($(CONFIG_476FPE_ERR46),y)
- 	KBUILD_LDFLAGS_MODULE += --ppc476-workaround \
--- a/target/linux/generic/hack-4.9/531-debloat_lzma.patch	2022-03-22 08:54:47.230464708 +0800
+++ b/target/linux/generic/hack-4.9/531-debloat_lzma.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,1040 +0,0 @@
-From 3fd297761ac246c54d7723c57fca95c112b99465 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 15 Jul 2017 21:15:44 +0200
-Subject: lzma: de-bloat the lzma library used by jffs2
-
-lede-commit: 3fd1dd08fbcbb78b34efefd32c3032e5c99108d6
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/linux/lzma/LzFind.h  |  17 ---
- include/linux/lzma/LzmaDec.h | 101 ---------------
- include/linux/lzma/LzmaEnc.h |  20 ---
- lib/lzma/LzFind.c            | 287 ++++---------------------------------------
- lib/lzma/LzmaDec.c           |  86 +------------
- lib/lzma/LzmaEnc.c           | 172 ++------------------------
- 6 files changed, 42 insertions(+), 641 deletions(-)
-
---- a/include/linux/lzma/LzFind.h
-+++ b/include/linux/lzma/LzFind.h
-@@ -55,11 +55,6 @@ typedef struct _CMatchFinder
- 
- #define Inline_MatchFinder_GetNumAvailableBytes(p) ((p)->streamPos - (p)->pos)
- 
--int MatchFinder_NeedMove(CMatchFinder *p);
--Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p);
--void MatchFinder_MoveBlock(CMatchFinder *p);
--void MatchFinder_ReadIfRequired(CMatchFinder *p);
--
- void MatchFinder_Construct(CMatchFinder *p);
- 
- /* Conditions:
-@@ -70,12 +65,6 @@ int MatchFinder_Create(CMatchFinder *p,
-     UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
-     ISzAlloc *alloc);
- void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc);
--void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems);
--void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue);
--
--UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *buffer, CLzRef *son,
--    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
--    UInt32 *distances, UInt32 maxLen);
- 
- /*
- Conditions:
-@@ -102,12 +91,6 @@ typedef struct _IMatchFinder
- 
- void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable);
- 
--void MatchFinder_Init(CMatchFinder *p);
--UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
--UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
--void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
--void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
--
- #ifdef __cplusplus
- }
- #endif
---- a/include/linux/lzma/LzmaDec.h
-+++ b/include/linux/lzma/LzmaDec.h
-@@ -31,14 +31,6 @@ typedef struct _CLzmaProps
-   UInt32 dicSize;
- } CLzmaProps;
- 
--/* LzmaProps_Decode - decodes properties
--Returns:
--  SZ_OK
--  SZ_ERROR_UNSUPPORTED - Unsupported properties
--*/
--
--SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size);
--
- 
- /* ---------- LZMA Decoder state ---------- */
- 
-@@ -70,8 +62,6 @@ typedef struct
- 
- #define LzmaDec_Construct(p) { (p)->dic = 0; (p)->probs = 0; }
- 
--void LzmaDec_Init(CLzmaDec *p);
--
- /* There are two types of LZMA streams:
-      0) Stream with end mark. That end mark adds about 6 bytes to compressed size.
-      1) Stream without end mark. You must know exact uncompressed size to decompress such stream. */
-@@ -108,97 +98,6 @@ typedef enum
- 
- /* ELzmaStatus is used only as output value for function call */
- 
--
--/* ---------- Interfaces ---------- */
--
--/* There are 3 levels of interfaces:
--     1) Dictionary Interface
--     2) Buffer Interface
--     3) One Call Interface
--   You can select any of these interfaces, but don't mix functions from different
--   groups for same object. */
--
--
--/* There are two variants to allocate state for Dictionary Interface:
--     1) LzmaDec_Allocate / LzmaDec_Free
--     2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs
--   You can use variant 2, if you set dictionary buffer manually.
--   For Buffer Interface you must always use variant 1.
--
--LzmaDec_Allocate* can return:
--  SZ_OK
--  SZ_ERROR_MEM         - Memory allocation error
--  SZ_ERROR_UNSUPPORTED - Unsupported properties
--*/
--   
--SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc);
--void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc);
--
--SRes LzmaDec_Allocate(CLzmaDec *state, const Byte *prop, unsigned propsSize, ISzAlloc *alloc);
--void LzmaDec_Free(CLzmaDec *state, ISzAlloc *alloc);
--
--/* ---------- Dictionary Interface ---------- */
--
--/* You can use it, if you want to eliminate the overhead for data copying from
--   dictionary to some other external buffer.
--   You must work with CLzmaDec variables directly in this interface.
--
--   STEPS:
--     LzmaDec_Constr()
--     LzmaDec_Allocate()
--     for (each new stream)
--     {
--       LzmaDec_Init()
--       while (it needs more decompression)
--       {
--         LzmaDec_DecodeToDic()
--         use data from CLzmaDec::dic and update CLzmaDec::dicPos
--       }
--     }
--     LzmaDec_Free()
--*/
--
--/* LzmaDec_DecodeToDic
--   
--   The decoding to internal dictionary buffer (CLzmaDec::dic).
--   You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!
--
--finishMode:
--  It has meaning only if the decoding reaches output limit (dicLimit).
--  LZMA_FINISH_ANY - Decode just dicLimit bytes.
--  LZMA_FINISH_END - Stream must be finished after dicLimit.
--
--Returns:
--  SZ_OK
--    status:
--      LZMA_STATUS_FINISHED_WITH_MARK
--      LZMA_STATUS_NOT_FINISHED
--      LZMA_STATUS_NEEDS_MORE_INPUT
--      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
--  SZ_ERROR_DATA - Data error
--*/
--
--SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit,
--    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
--
--
--/* ---------- Buffer Interface ---------- */
--
--/* It's zlib-like interface.
--   See LzmaDec_DecodeToDic description for information about STEPS and return results,
--   but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need
--   to work with CLzmaDec variables manually.
--
--finishMode:
--  It has meaning only if the decoding reaches output limit (*destLen).
--  LZMA_FINISH_ANY - Decode just destLen bytes.
--  LZMA_FINISH_END - Stream must be finished after (*destLen).
--*/
--
--SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen,
--    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
--
--
- /* ---------- One Call Interface ---------- */
- 
- /* LzmaDecode
---- a/include/linux/lzma/LzmaEnc.h
-+++ b/include/linux/lzma/LzmaEnc.h
-@@ -31,9 +31,6 @@ typedef struct _CLzmaEncProps
- } CLzmaEncProps;
- 
- void LzmaEncProps_Init(CLzmaEncProps *p);
--void LzmaEncProps_Normalize(CLzmaEncProps *p);
--UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2);
--
- 
- /* ---------- CLzmaEncHandle Interface ---------- */
- 
-@@ -53,26 +50,9 @@ CLzmaEncHandle LzmaEnc_Create(ISzAlloc *
- void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig);
- SRes LzmaEnc_SetProps(CLzmaEncHandle p, const CLzmaEncProps *props);
- SRes LzmaEnc_WriteProperties(CLzmaEncHandle p, Byte *properties, SizeT *size);
--SRes LzmaEnc_Encode(CLzmaEncHandle p, ISeqOutStream *outStream, ISeqInStream *inStream,
--    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
- SRes LzmaEnc_MemEncode(CLzmaEncHandle p, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-     int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
- 
--/* ---------- One Call Interface ---------- */
--
--/* LzmaEncode
--Return code:
--  SZ_OK               - OK
--  SZ_ERROR_MEM        - Memory allocation error
--  SZ_ERROR_PARAM      - Incorrect paramater
--  SZ_ERROR_OUTPUT_EOF - output buffer overflow
--  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
--*/
--
--SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
--    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
--    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
--
- #ifdef __cplusplus
- }
- #endif
---- a/lib/lzma/LzFind.c
-+++ b/lib/lzma/LzFind.c
-@@ -14,9 +14,15 @@
- 
- #define kStartMaxLen 3
- 
-+#if 0
-+#define DIRECT_INPUT	p->directInput
-+#else
-+#define DIRECT_INPUT	1
-+#endif
-+
- static void LzInWindow_Free(CMatchFinder *p, ISzAlloc *alloc)
- {
--  if (!p->directInput)
-+  if (!DIRECT_INPUT)
-   {
-     alloc->Free(alloc, p->bufferBase);
-     p->bufferBase = 0;
-@@ -28,7 +34,7 @@ static void LzInWindow_Free(CMatchFinder
- static int LzInWindow_Create(CMatchFinder *p, UInt32 keepSizeReserv, ISzAlloc *alloc)
- {
-   UInt32 blockSize = p->keepSizeBefore + p->keepSizeAfter + keepSizeReserv;
--  if (p->directInput)
-+  if (DIRECT_INPUT)
-   {
-     p->blockSize = blockSize;
-     return 1;
-@@ -42,12 +48,12 @@ static int LzInWindow_Create(CMatchFinde
-   return (p->bufferBase != 0);
- }
- 
--Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }
--Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p->buffer[index]; }
-+static Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }
-+static Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p->buffer[index]; }
- 
--UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }
-+static UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }
- 
--void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
-+static void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
- {
-   p->posLimit -= subValue;
-   p->pos -= subValue;
-@@ -58,7 +64,7 @@ static void MatchFinder_ReadBlock(CMatch
- {
-   if (p->streamEndWasReached || p->result != SZ_OK)
-     return;
--  if (p->directInput)
-+  if (DIRECT_INPUT)
-   {
-     UInt32 curSize = 0xFFFFFFFF - p->streamPos;
-     if (curSize > p->directInputRem)
-@@ -89,7 +95,7 @@ static void MatchFinder_ReadBlock(CMatch
-   }
- }
- 
--void MatchFinder_MoveBlock(CMatchFinder *p)
-+static void MatchFinder_MoveBlock(CMatchFinder *p)
- {
-   memmove(p->bufferBase,
-     p->buffer - p->keepSizeBefore,
-@@ -97,22 +103,14 @@ void MatchFinder_MoveBlock(CMatchFinder
-   p->buffer = p->bufferBase + p->keepSizeBefore;
- }
- 
--int MatchFinder_NeedMove(CMatchFinder *p)
-+static int MatchFinder_NeedMove(CMatchFinder *p)
- {
--  if (p->directInput)
-+  if (DIRECT_INPUT)
-     return 0;
-   /* if (p->streamEndWasReached) return 0; */
-   return ((size_t)(p->bufferBase + p->blockSize - p->buffer) <= p->keepSizeAfter);
- }
- 
--void MatchFinder_ReadIfRequired(CMatchFinder *p)
--{
--  if (p->streamEndWasReached)
--    return;
--  if (p->keepSizeAfter >= p->streamPos - p->pos)
--    MatchFinder_ReadBlock(p);
--}
--
- static void MatchFinder_CheckAndMoveAndRead(CMatchFinder *p)
- {
-   if (MatchFinder_NeedMove(p))
-@@ -268,7 +266,7 @@ static void MatchFinder_SetLimits(CMatch
-   p->posLimit = p->pos + limit;
- }
- 
--void MatchFinder_Init(CMatchFinder *p)
-+static void MatchFinder_Init(CMatchFinder *p)
- {
-   UInt32 i;
-   for (i = 0; i < p->hashSizeSum; i++)
-@@ -287,7 +285,7 @@ static UInt32 MatchFinder_GetSubValue(CM
-   return (p->pos - p->historySize - 1) & kNormalizeMask;
- }
- 
--void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems)
-+static void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems)
- {
-   UInt32 i;
-   for (i = 0; i < numItems; i++)
-@@ -319,38 +317,7 @@ static void MatchFinder_CheckLimits(CMat
-   MatchFinder_SetLimits(p);
- }
- 
--static UInt32 * Hc_GetMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
--    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
--    UInt32 *distances, UInt32 maxLen)
--{
--  son[_cyclicBufferPos] = curMatch;
--  for (;;)
--  {
--    UInt32 delta = pos - curMatch;
--    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
--      return distances;
--    {
--      const Byte *pb = cur - delta;
--      curMatch = son[_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)];
--      if (pb[maxLen] == cur[maxLen] && *pb == *cur)
--      {
--        UInt32 len = 0;
--        while (++len != lenLimit)
--          if (pb[len] != cur[len])
--            break;
--        if (maxLen < len)
--        {
--          *distances++ = maxLen = len;
--          *distances++ = delta - 1;
--          if (len == lenLimit)
--            return distances;
--        }
--      }
--    }
--  }
--}
--
--UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
-+static UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
-     UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
-     UInt32 *distances, UInt32 maxLen)
- {
-@@ -460,10 +427,10 @@ static void SkipMatchesSpec(UInt32 lenLi
-   p->buffer++; \
-   if (++p->pos == p->posLimit) MatchFinder_CheckLimits(p);
- 
--#define MOVE_POS_RET MOVE_POS return offset;
--
- static void MatchFinder_MovePos(CMatchFinder *p) { MOVE_POS; }
- 
-+#define MOVE_POS_RET MatchFinder_MovePos(p); return offset;
-+
- #define GET_MATCHES_HEADER2(minLen, ret_op) \
-   UInt32 lenLimit; UInt32 hashValue; const Byte *cur; UInt32 curMatch; \
-   lenLimit = p->lenLimit; { if (lenLimit < minLen) { MatchFinder_MovePos(p); ret_op; }} \
-@@ -479,62 +446,7 @@ static void MatchFinder_MovePos(CMatchFi
-   distances + offset, maxLen) - distances); MOVE_POS_RET;
- 
- #define SKIP_FOOTER \
--  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MOVE_POS;
--
--static UInt32 Bt2_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
--{
--  UInt32 offset;
--  GET_MATCHES_HEADER(2)
--  HASH2_CALC;
--  curMatch = p->hash[hashValue];
--  p->hash[hashValue] = p->pos;
--  offset = 0;
--  GET_MATCHES_FOOTER(offset, 1)
--}
--
--UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
--{
--  UInt32 offset;
--  GET_MATCHES_HEADER(3)
--  HASH_ZIP_CALC;
--  curMatch = p->hash[hashValue];
--  p->hash[hashValue] = p->pos;
--  offset = 0;
--  GET_MATCHES_FOOTER(offset, 2)
--}
--
--static UInt32 Bt3_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
--{
--  UInt32 hash2Value, delta2, maxLen, offset;
--  GET_MATCHES_HEADER(3)
--
--  HASH3_CALC;
--
--  delta2 = p->pos - p->hash[hash2Value];
--  curMatch = p->hash[kFix3HashSize + hashValue];
--  
--  p->hash[hash2Value] =
--  p->hash[kFix3HashSize + hashValue] = p->pos;
--
--
--  maxLen = 2;
--  offset = 0;
--  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
--  {
--    for (; maxLen != lenLimit; maxLen++)
--      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
--        break;
--    distances[0] = maxLen;
--    distances[1] = delta2 - 1;
--    offset = 2;
--    if (maxLen == lenLimit)
--    {
--      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
--      MOVE_POS_RET;
--    }
--  }
--  GET_MATCHES_FOOTER(offset, maxLen)
--}
-+  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MatchFinder_MovePos(p);
- 
- static UInt32 Bt4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
- {
-@@ -583,108 +495,6 @@ static UInt32 Bt4_MatchFinder_GetMatches
-   GET_MATCHES_FOOTER(offset, maxLen)
- }
- 
--static UInt32 Hc4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
--{
--  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
--  GET_MATCHES_HEADER(4)
--
--  HASH4_CALC;
--
--  delta2 = p->pos - p->hash[                hash2Value];
--  delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
--  curMatch = p->hash[kFix4HashSize + hashValue];
--
--  p->hash[                hash2Value] =
--  p->hash[kFix3HashSize + hash3Value] =
--  p->hash[kFix4HashSize + hashValue] = p->pos;
--
--  maxLen = 1;
--  offset = 0;
--  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
--  {
--    distances[0] = maxLen = 2;
--    distances[1] = delta2 - 1;
--    offset = 2;
--  }
--  if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
--  {
--    maxLen = 3;
--    distances[offset + 1] = delta3 - 1;
--    offset += 2;
--    delta2 = delta3;
--  }
--  if (offset != 0)
--  {
--    for (; maxLen != lenLimit; maxLen++)
--      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
--        break;
--    distances[offset - 2] = maxLen;
--    if (maxLen == lenLimit)
--    {
--      p->son[p->cyclicBufferPos] = curMatch;
--      MOVE_POS_RET;
--    }
--  }
--  if (maxLen < 3)
--    maxLen = 3;
--  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
--    distances + offset, maxLen) - (distances));
--  MOVE_POS_RET
--}
--
--UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
--{
--  UInt32 offset;
--  GET_MATCHES_HEADER(3)
--  HASH_ZIP_CALC;
--  curMatch = p->hash[hashValue];
--  p->hash[hashValue] = p->pos;
--  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
--    distances, 2) - (distances));
--  MOVE_POS_RET
--}
--
--static void Bt2_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
--{
--  do
--  {
--    SKIP_HEADER(2)
--    HASH2_CALC;
--    curMatch = p->hash[hashValue];
--    p->hash[hashValue] = p->pos;
--    SKIP_FOOTER
--  }
--  while (--num != 0);
--}
--
--void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
--{
--  do
--  {
--    SKIP_HEADER(3)
--    HASH_ZIP_CALC;
--    curMatch = p->hash[hashValue];
--    p->hash[hashValue] = p->pos;
--    SKIP_FOOTER
--  }
--  while (--num != 0);
--}
--
--static void Bt3_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
--{
--  do
--  {
--    UInt32 hash2Value;
--    SKIP_HEADER(3)
--    HASH3_CALC;
--    curMatch = p->hash[kFix3HashSize + hashValue];
--    p->hash[hash2Value] =
--    p->hash[kFix3HashSize + hashValue] = p->pos;
--    SKIP_FOOTER
--  }
--  while (--num != 0);
--}
--
- static void Bt4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
- {
-   do
-@@ -701,61 +511,12 @@ static void Bt4_MatchFinder_Skip(CMatchF
-   while (--num != 0);
- }
- 
--static void Hc4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
--{
--  do
--  {
--    UInt32 hash2Value, hash3Value;
--    SKIP_HEADER(4)
--    HASH4_CALC;
--    curMatch = p->hash[kFix4HashSize + hashValue];
--    p->hash[                hash2Value] =
--    p->hash[kFix3HashSize + hash3Value] =
--    p->hash[kFix4HashSize + hashValue] = p->pos;
--    p->son[p->cyclicBufferPos] = curMatch;
--    MOVE_POS
--  }
--  while (--num != 0);
--}
--
--void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
--{
--  do
--  {
--    SKIP_HEADER(3)
--    HASH_ZIP_CALC;
--    curMatch = p->hash[hashValue];
--    p->hash[hashValue] = p->pos;
--    p->son[p->cyclicBufferPos] = curMatch;
--    MOVE_POS
--  }
--  while (--num != 0);
--}
--
- void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable)
- {
-   vTable->Init = (Mf_Init_Func)MatchFinder_Init;
-   vTable->GetIndexByte = (Mf_GetIndexByte_Func)MatchFinder_GetIndexByte;
-   vTable->GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinder_GetNumAvailableBytes;
-   vTable->GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinder_GetPointerToCurrentPos;
--  if (!p->btMode)
--  {
--    vTable->GetMatches = (Mf_GetMatches_Func)Hc4_MatchFinder_GetMatches;
--    vTable->Skip = (Mf_Skip_Func)Hc4_MatchFinder_Skip;
--  }
--  else if (p->numHashBytes == 2)
--  {
--    vTable->GetMatches = (Mf_GetMatches_Func)Bt2_MatchFinder_GetMatches;
--    vTable->Skip = (Mf_Skip_Func)Bt2_MatchFinder_Skip;
--  }
--  else if (p->numHashBytes == 3)
--  {
--    vTable->GetMatches = (Mf_GetMatches_Func)Bt3_MatchFinder_GetMatches;
--    vTable->Skip = (Mf_Skip_Func)Bt3_MatchFinder_Skip;
--  }
--  else
--  {
--    vTable->GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
--    vTable->Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
--  }
-+  vTable->GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
-+  vTable->Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
- }
---- a/lib/lzma/LzmaDec.c
-+++ b/lib/lzma/LzmaDec.c
-@@ -682,7 +682,7 @@ static void LzmaDec_InitRc(CLzmaDec *p,
-   p->needFlush = 0;
- }
- 
--void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
-+static void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
- {
-   p->needFlush = 1;
-   p->remainLen = 0;
-@@ -698,7 +698,7 @@ void LzmaDec_InitDicAndState(CLzmaDec *p
-     p->needInitState = 1;
- }
- 
--void LzmaDec_Init(CLzmaDec *p)
-+static void LzmaDec_Init(CLzmaDec *p)
- {
-   p->dicPos = 0;
-   LzmaDec_InitDicAndState(p, True, True);
-@@ -716,7 +716,7 @@ static void LzmaDec_InitStateReal(CLzmaD
-   p->needInitState = 0;
- }
- 
--SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
-+static SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
-     ELzmaFinishMode finishMode, ELzmaStatus *status)
- {
-   SizeT inSize = *srcLen;
-@@ -837,65 +837,13 @@ SRes LzmaDec_DecodeToDic(CLzmaDec *p, Si
-   return (p->code == 0) ? SZ_OK : SZ_ERROR_DATA;
- }
- 
--SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
--{
--  SizeT outSize = *destLen;
--  SizeT inSize = *srcLen;
--  *srcLen = *destLen = 0;
--  for (;;)
--  {
--    SizeT inSizeCur = inSize, outSizeCur, dicPos;
--    ELzmaFinishMode curFinishMode;
--    SRes res;
--    if (p->dicPos == p->dicBufSize)
--      p->dicPos = 0;
--    dicPos = p->dicPos;
--    if (outSize > p->dicBufSize - dicPos)
--    {
--      outSizeCur = p->dicBufSize;
--      curFinishMode = LZMA_FINISH_ANY;
--    }
--    else
--    {
--      outSizeCur = dicPos + outSize;
--      curFinishMode = finishMode;
--    }
--
--    res = LzmaDec_DecodeToDic(p, outSizeCur, src, &inSizeCur, curFinishMode, status);
--    src += inSizeCur;
--    inSize -= inSizeCur;
--    *srcLen += inSizeCur;
--    outSizeCur = p->dicPos - dicPos;
--    memcpy(dest, p->dic + dicPos, outSizeCur);
--    dest += outSizeCur;
--    outSize -= outSizeCur;
--    *destLen += outSizeCur;
--    if (res != 0)
--      return res;
--    if (outSizeCur == 0 || outSize == 0)
--      return SZ_OK;
--  }
--}
--
--void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
-+static void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
- {
-   alloc->Free(alloc, p->probs);
-   p->probs = 0;
- }
- 
--static void LzmaDec_FreeDict(CLzmaDec *p, ISzAlloc *alloc)
--{
--  alloc->Free(alloc, p->dic);
--  p->dic = 0;
--}
--
--void LzmaDec_Free(CLzmaDec *p, ISzAlloc *alloc)
--{
--  LzmaDec_FreeProbs(p, alloc);
--  LzmaDec_FreeDict(p, alloc);
--}
--
--SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
-+static SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
- {
-   UInt32 dicSize;
-   Byte d;
-@@ -935,7 +883,7 @@ static SRes LzmaDec_AllocateProbs2(CLzma
-   return SZ_OK;
- }
- 
--SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
-+static SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
- {
-   CLzmaProps propNew;
-   RINOK(LzmaProps_Decode(&propNew, props, propsSize));
-@@ -943,28 +891,6 @@ SRes LzmaDec_AllocateProbs(CLzmaDec *p,
-   p->prop = propNew;
-   return SZ_OK;
- }
--
--SRes LzmaDec_Allocate(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
--{
--  CLzmaProps propNew;
--  SizeT dicBufSize;
--  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
--  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
--  dicBufSize = propNew.dicSize;
--  if (p->dic == 0 || dicBufSize != p->dicBufSize)
--  {
--    LzmaDec_FreeDict(p, alloc);
--    p->dic = (Byte *)alloc->Alloc(alloc, dicBufSize);
--    if (p->dic == 0)
--    {
--      LzmaDec_FreeProbs(p, alloc);
--      return SZ_ERROR_MEM;
--    }
--  }
--  p->dicBufSize = dicBufSize;
--  p->prop = propNew;
--  return SZ_OK;
--}
- 
- SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
-     const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
---- a/lib/lzma/LzmaEnc.c
-+++ b/lib/lzma/LzmaEnc.c
-@@ -53,7 +53,7 @@ void LzmaEncProps_Init(CLzmaEncProps *p)
-   p->writeEndMark = 0;
- }
- 
--void LzmaEncProps_Normalize(CLzmaEncProps *p)
-+static void LzmaEncProps_Normalize(CLzmaEncProps *p)
- {
-   int level = p->level;
-   if (level < 0) level = 5;
-@@ -76,7 +76,7 @@ void LzmaEncProps_Normalize(CLzmaEncProp
-       #endif
- }
- 
--UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
-+static UInt32 __maybe_unused LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
- {
-   CLzmaEncProps props = *props2;
-   LzmaEncProps_Normalize(&props);
-@@ -93,7 +93,7 @@ UInt32 LzmaEncProps_GetDictSize(const CL
- 
- #define BSR2_RET(pos, res) { unsigned long i; _BitScanReverse(&i, (pos)); res = (i + i) + ((pos >> (i - 1)) & 1); }
- 
--UInt32 GetPosSlot1(UInt32 pos)
-+static UInt32 GetPosSlot1(UInt32 pos)
- {
-   UInt32 res;
-   BSR2_RET(pos, res);
-@@ -107,7 +107,7 @@ UInt32 GetPosSlot1(UInt32 pos)
- #define kNumLogBits (9 + (int)sizeof(size_t) / 2)
- #define kDicLogSizeMaxCompress ((kNumLogBits - 1) * 2 + 7)
- 
--void LzmaEnc_FastPosInit(Byte *g_FastPos)
-+static void LzmaEnc_FastPosInit(Byte *g_FastPos)
- {
-   int c = 2, slotFast;
-   g_FastPos[0] = 0;
-@@ -339,58 +339,6 @@ typedef struct
-   CSaveState saveState;
- } CLzmaEnc;
- 
--void LzmaEnc_SaveState(CLzmaEncHandle pp)
--{
--  CLzmaEnc *p = (CLzmaEnc *)pp;
--  CSaveState *dest = &p->saveState;
--  int i;
--  dest->lenEnc = p->lenEnc;
--  dest->repLenEnc = p->repLenEnc;
--  dest->state = p->state;
--
--  for (i = 0; i < kNumStates; i++)
--  {
--    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
--    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
--  }
--  for (i = 0; i < kNumLenToPosStates; i++)
--    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
--  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
--  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
--  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
--  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
--  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
--  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
--  memcpy(dest->reps, p->reps, sizeof(p->reps));
--  memcpy(dest->litProbs, p->litProbs, (0x300 << p->lclp) * sizeof(CLzmaProb));
--}
--
--void LzmaEnc_RestoreState(CLzmaEncHandle pp)
--{
--  CLzmaEnc *dest = (CLzmaEnc *)pp;
--  const CSaveState *p = &dest->saveState;
--  int i;
--  dest->lenEnc = p->lenEnc;
--  dest->repLenEnc = p->repLenEnc;
--  dest->state = p->state;
--
--  for (i = 0; i < kNumStates; i++)
--  {
--    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
--    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
--  }
--  for (i = 0; i < kNumLenToPosStates; i++)
--    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
--  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
--  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
--  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
--  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
--  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
--  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
--  memcpy(dest->reps, p->reps, sizeof(p->reps));
--  memcpy(dest->litProbs, p->litProbs, (0x300 << dest->lclp) * sizeof(CLzmaProb));
--}
--
- SRes LzmaEnc_SetProps(CLzmaEncHandle pp, const CLzmaEncProps *props2)
- {
-   CLzmaEnc *p = (CLzmaEnc *)pp;
-@@ -600,7 +548,7 @@ static void LitEnc_EncodeMatched(CRangeE
-   while (symbol < 0x10000);
- }
- 
--void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
-+static void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
- {
-   UInt32 i;
-   for (i = (1 << kNumMoveReducingBits) / 2; i < kBitModelTotal; i += (1 << kNumMoveReducingBits))
-@@ -1676,7 +1624,7 @@ static void FillDistancesPrices(CLzmaEnc
-   p->matchPriceCount = 0;
- }
- 
--void LzmaEnc_Construct(CLzmaEnc *p)
-+static void LzmaEnc_Construct(CLzmaEnc *p)
- {
-   RangeEnc_Construct(&p->rc);
-   MatchFinder_Construct(&p->matchFinderBase);
-@@ -1709,7 +1657,7 @@ CLzmaEncHandle LzmaEnc_Create(ISzAlloc *
-   return p;
- }
- 
--void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
-+static void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
- {
-   alloc->Free(alloc, p->litProbs);
-   alloc->Free(alloc, p->saveState.litProbs);
-@@ -1717,7 +1665,7 @@ void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAl
-   p->saveState.litProbs = 0;
- }
- 
--void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
-+static void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
- {
-   #ifndef _7ZIP_ST
-   MatchFinderMt_Destruct(&p->matchFinderMt, allocBig);
-@@ -1947,7 +1895,7 @@ static SRes LzmaEnc_Alloc(CLzmaEnc *p, U
-   return SZ_OK;
- }
- 
--void LzmaEnc_Init(CLzmaEnc *p)
-+static void LzmaEnc_Init(CLzmaEnc *p)
- {
-   UInt32 i;
-   p->state = 0;
-@@ -2005,7 +1953,7 @@ void LzmaEnc_Init(CLzmaEnc *p)
-   p->lpMask = (1 << p->lp) - 1;
- }
- 
--void LzmaEnc_InitPrices(CLzmaEnc *p)
-+static void LzmaEnc_InitPrices(CLzmaEnc *p)
- {
-   if (!p->fastMode)
-   {
-@@ -2037,26 +1985,6 @@ static SRes LzmaEnc_AllocAndInit(CLzmaEn
-   return SZ_OK;
- }
- 
--static SRes LzmaEnc_Prepare(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream,
--    ISzAlloc *alloc, ISzAlloc *allocBig)
--{
--  CLzmaEnc *p = (CLzmaEnc *)pp;
--  p->matchFinderBase.stream = inStream;
--  p->needInit = 1;
--  p->rc.outStream = outStream;
--  return LzmaEnc_AllocAndInit(p, 0, alloc, allocBig);
--}
--
--SRes LzmaEnc_PrepareForLzma2(CLzmaEncHandle pp,
--    ISeqInStream *inStream, UInt32 keepWindowSize,
--    ISzAlloc *alloc, ISzAlloc *allocBig)
--{
--  CLzmaEnc *p = (CLzmaEnc *)pp;
--  p->matchFinderBase.stream = inStream;
--  p->needInit = 1;
--  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
--}
--
- static void LzmaEnc_SetInputBuf(CLzmaEnc *p, const Byte *src, SizeT srcLen)
- {
-   p->matchFinderBase.directInput = 1;
-@@ -2064,7 +1992,7 @@ static void LzmaEnc_SetInputBuf(CLzmaEnc
-   p->matchFinderBase.directInputRem = srcLen;
- }
- 
--SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
-+static SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
-     UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
- {
-   CLzmaEnc *p = (CLzmaEnc *)pp;
-@@ -2074,7 +2002,7 @@ SRes LzmaEnc_MemPrepare(CLzmaEncHandle p
-   return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
- }
- 
--void LzmaEnc_Finish(CLzmaEncHandle pp)
-+static void LzmaEnc_Finish(CLzmaEncHandle pp)
- {
-   #ifndef _7ZIP_ST
-   CLzmaEnc *p = (CLzmaEnc *)pp;
-@@ -2107,53 +2035,6 @@ static size_t MyWrite(void *pp, const vo
-   return size;
- }
- 
--
--UInt32 LzmaEnc_GetNumAvailableBytes(CLzmaEncHandle pp)
--{
--  const CLzmaEnc *p = (CLzmaEnc *)pp;
--  return p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
--}
--
--const Byte *LzmaEnc_GetCurBuf(CLzmaEncHandle pp)
--{
--  const CLzmaEnc *p = (CLzmaEnc *)pp;
--  return p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
--}
--
--SRes LzmaEnc_CodeOneMemBlock(CLzmaEncHandle pp, Bool reInit,
--    Byte *dest, size_t *destLen, UInt32 desiredPackSize, UInt32 *unpackSize)
--{
--  CLzmaEnc *p = (CLzmaEnc *)pp;
--  UInt64 nowPos64;
--  SRes res;
--  CSeqOutStreamBuf outStream;
--
--  outStream.funcTable.Write = MyWrite;
--  outStream.data = dest;
--  outStream.rem = *destLen;
--  outStream.overflow = False;
--
--  p->writeEndMark = False;
--  p->finished = False;
--  p->result = SZ_OK;
--
--  if (reInit)
--    LzmaEnc_Init(p);
--  LzmaEnc_InitPrices(p);
--  nowPos64 = p->nowPos64;
--  RangeEnc_Init(&p->rc);
--  p->rc.outStream = &outStream.funcTable;
--
--  res = LzmaEnc_CodeOneBlock(p, True, desiredPackSize, *unpackSize);
--  
--  *unpackSize = (UInt32)(p->nowPos64 - nowPos64);
--  *destLen -= outStream.rem;
--  if (outStream.overflow)
--    return SZ_ERROR_OUTPUT_EOF;
--
--  return res;
--}
--
- static SRes LzmaEnc_Encode2(CLzmaEnc *p, ICompressProgress *progress)
- {
-   SRes res = SZ_OK;
-@@ -2184,13 +2065,6 @@ static SRes LzmaEnc_Encode2(CLzmaEnc *p,
-   return res;
- }
- 
--SRes LzmaEnc_Encode(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress,
--    ISzAlloc *alloc, ISzAlloc *allocBig)
--{
--  RINOK(LzmaEnc_Prepare(pp, outStream, inStream, alloc, allocBig));
--  return LzmaEnc_Encode2((CLzmaEnc *)pp, progress);
--}
--
- SRes LzmaEnc_WriteProperties(CLzmaEncHandle pp, Byte *props, SizeT *size)
- {
-   CLzmaEnc *p = (CLzmaEnc *)pp;
-@@ -2247,25 +2121,3 @@ SRes LzmaEnc_MemEncode(CLzmaEncHandle pp
-     return SZ_ERROR_OUTPUT_EOF;
-   return res;
- }
--
--SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
--    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
--    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
--{
--  CLzmaEnc *p = (CLzmaEnc *)LzmaEnc_Create(alloc);
--  SRes res;
--  if (p == 0)
--    return SZ_ERROR_MEM;
--
--  res = LzmaEnc_SetProps(p, props);
--  if (res == SZ_OK)
--  {
--    res = LzmaEnc_WriteProperties(p, propsEncoded, propsSize);
--    if (res == SZ_OK)
--      res = LzmaEnc_MemEncode(p, dest, destLen, src, srcLen,
--          writeEndMark, progress, alloc, allocBig);
--  }
--
--  LzmaEnc_Destroy(p, alloc, allocBig);
--  return res;
--}
--- a/target/linux/generic/hack-4.9/640-bridge-only-accept-EAP-locally.patch	2022-03-22 08:54:47.230464708 +0800
+++ b/target/linux/generic/hack-4.9/640-bridge-only-accept-EAP-locally.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,83 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 17:18:54 +0200
-Subject: bridge: only accept EAP locally
-
-When bridging, do not forward EAP frames to other ports, only deliver
-them locally, regardless of the state.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
-[add disable_eap_hack sysfs attribute]
-Signed-off-by: Etienne Champetier <champetier.etienne@gmail.com>
----
-
---- a/net/bridge/br_input.c
-+++ b/net/bridge/br_input.c
-@@ -164,11 +164,14 @@ int br_handle_frame_finish(struct net *n
- 		}
- 	}
- 
-+	BR_INPUT_SKB_CB(skb)->brdev = br->dev;
-+
-+	if (skb->protocol == htons(ETH_P_PAE) && !br->disable_eap_hack)
-+		return br_pass_frame_up(skb);
-+
- 	if (p->state == BR_STATE_LEARNING)
- 		goto drop;
- 
--	BR_INPUT_SKB_CB(skb)->brdev = br->dev;
--
- 	if (IS_ENABLED(CONFIG_INET) && skb->protocol == htons(ETH_P_ARP))
- 		br_do_proxy_arp(skb, br, vid, p);
- 
---- a/net/bridge/br_private.h
-+++ b/net/bridge/br_private.h
-@@ -295,6 +295,8 @@ struct net_bridge
- 	u16				group_fwd_mask;
- 	u16				group_fwd_mask_required;
- 
-+	bool				disable_eap_hack;
-+
- 	/* STP */
- 	bridge_id			designated_root;
- 	bridge_id			bridge_id;
---- a/net/bridge/br_sysfs_br.c
-+++ b/net/bridge/br_sysfs_br.c
-@@ -169,6 +169,30 @@ static ssize_t group_fwd_mask_store(stru
- }
- static DEVICE_ATTR_RW(group_fwd_mask);
- 
-+static ssize_t disable_eap_hack_show(struct device *d,
-+				   struct device_attribute *attr,
-+				   char *buf)
-+{
-+	struct net_bridge *br = to_bridge(d);
-+	return sprintf(buf, "%u\n", br->disable_eap_hack);
-+}
-+
-+static int set_disable_eap_hack(struct net_bridge *br, unsigned long val)
-+{
-+	br->disable_eap_hack = !!val;
-+
-+	return 0;
-+}
-+
-+static ssize_t disable_eap_hack_store(struct device *d,
-+				    struct device_attribute *attr,
-+				    const char *buf,
-+				    size_t len)
-+{
-+	return store_bridge_parm(d, buf, len, set_disable_eap_hack);
-+}
-+static DEVICE_ATTR_RW(disable_eap_hack);
-+
- static ssize_t priority_show(struct device *d, struct device_attribute *attr,
- 			     char *buf)
- {
-@@ -780,6 +804,7 @@ static struct attribute *bridge_attrs[]
- 	&dev_attr_ageing_time.attr,
- 	&dev_attr_stp_state.attr,
- 	&dev_attr_group_fwd_mask.attr,
-+	&dev_attr_disable_eap_hack.attr,
- 	&dev_attr_priority.attr,
- 	&dev_attr_bridge_id.attr,
- 	&dev_attr_root_id.attr,
--- a/target/linux/generic/hack-4.9/641-bridge_port_isolate.patch	2022-03-22 08:54:47.230464708 +0800
+++ b/target/linux/generic/hack-4.9/641-bridge_port_isolate.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,76 +0,0 @@
-From e988390850731aa1697ed09d47b0932fac1af175 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 17:20:03 +0200
-Subject: bridge: port isolate
-
-Isolating individual bridge ports
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/linux/if_bridge.h | 1 +
- net/bridge/br_forward.c   | 5 +++++
- net/bridge/br_input.c     | 3 +++
- net/bridge/br_sysfs_if.c  | 2 ++
- 4 files changed, 11 insertions(+)
-
---- a/include/linux/if_bridge.h
-+++ b/include/linux/if_bridge.h
-@@ -47,6 +47,7 @@ struct br_ip_list {
- #define BR_PROXYARP_WIFI	BIT(10)
- #define BR_MCAST_FLOOD		BIT(11)
- #define BR_MULTICAST_TO_UNICAST	BIT(12)
-+#define BR_ISOLATE_MODE		BIT(13)
- 
- #define BR_DEFAULT_AGEING_TIME	(300 * HZ)
- 
---- a/net/bridge/br_forward.c
-+++ b/net/bridge/br_forward.c
-@@ -140,6 +140,9 @@ static int deliver_clone(const struct ne
- void br_forward(const struct net_bridge_port *to,
- 		struct sk_buff *skb, bool local_rcv, bool local_orig)
- {
-+	if (to->flags & BR_ISOLATE_MODE && !local_orig)
-+		to = NULL;
-+
- 	if (to && should_deliver(to, skb)) {
- 		if (local_rcv)
- 			deliver_clone(to, skb, local_orig);
-@@ -205,6 +208,8 @@ void br_flood(struct net_bridge *br, str
- 	struct net_bridge_port *p;
- 
- 	list_for_each_entry_rcu(p, &br->port_list, list) {
-+		if (!local_orig && (p->flags & BR_ISOLATE_MODE))
-+			continue;
- 		/* Do not flood unicast traffic to ports that turn it off */
- 		if (pkt_type == BR_PKT_UNICAST && !(p->flags & BR_FLOOD))
- 			continue;
---- a/net/bridge/br_input.c
-+++ b/net/bridge/br_input.c
-@@ -175,6 +175,9 @@ int br_handle_frame_finish(struct net *n
- 	if (IS_ENABLED(CONFIG_INET) && skb->protocol == htons(ETH_P_ARP))
- 		br_do_proxy_arp(skb, br, vid, p);
- 
-+	if (p->flags & BR_ISOLATE_MODE)
-+		return br_pass_frame_up(skb);
-+
- 	switch (pkt_type) {
- 	case BR_PKT_MULTICAST:
- 		mdst = br_mdb_get(br, skb, vid);
---- a/net/bridge/br_sysfs_if.c
-+++ b/net/bridge/br_sysfs_if.c
-@@ -172,6 +172,7 @@ BRPORT_ATTR_FLAG(unicast_flood, BR_FLOOD
- BRPORT_ATTR_FLAG(proxyarp, BR_PROXYARP);
- BRPORT_ATTR_FLAG(proxyarp_wifi, BR_PROXYARP_WIFI);
- BRPORT_ATTR_FLAG(multicast_flood, BR_MCAST_FLOOD);
-+BRPORT_ATTR_FLAG(isolated, BR_ISOLATE_MODE);
- 
- #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
- static ssize_t show_multicast_router(struct net_bridge_port *p, char *buf)
-@@ -220,6 +221,7 @@ static const struct brport_attribute *br
- 	&brport_attr_proxyarp,
- 	&brport_attr_proxyarp_wifi,
- 	&brport_attr_multicast_flood,
-+	&brport_attr_isolated,
- 	NULL
- };
- 
--- a/target/linux/generic/hack-4.9/651-wireless_mesh_header.patch	2022-03-22 08:54:47.231464709 +0800
+++ b/target/linux/generic/hack-4.9/651-wireless_mesh_header.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,24 +0,0 @@
-From 6d3bc769657b0ee7c7506dad9911111c4226a7ea Mon Sep 17 00:00:00 2001
-From: Imre Kaloz <kaloz@openwrt.org>
-Date: Fri, 7 Jul 2017 17:21:05 +0200
-Subject: mac80211: increase wireless mesh header size
-
-lede-commit 3d4466cfd8f75f717efdb1f96fdde3c70d865fc1
-Signed-off-by: Imre Kaloz <kaloz@openwrt.org>
----
- include/linux/netdevice.h | 4 ++--
- 1 file changed, 2 insertions(+), 2 deletions(-)
-
---- a/include/linux/netdevice.h
-+++ b/include/linux/netdevice.h
-@@ -137,8 +137,8 @@ static inline bool dev_xmit_complete(int
- 
- #if defined(CONFIG_HYPERV_NET)
- # define LL_MAX_HEADER 128
--#elif defined(CONFIG_WLAN) || IS_ENABLED(CONFIG_AX25)
--# if defined(CONFIG_MAC80211_MESH)
-+#elif defined(CONFIG_WLAN) || IS_ENABLED(CONFIG_AX25) || 1
-+# if defined(CONFIG_MAC80211_MESH) || 1
- #  define LL_MAX_HEADER 128
- # else
- #  define LL_MAX_HEADER 96
--- a/target/linux/generic/hack-4.9/660-fq_codel_defaults.patch	2022-03-22 08:54:47.231464709 +0800
+++ b/target/linux/generic/hack-4.9/660-fq_codel_defaults.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,27 +0,0 @@
-From a6ccb238939b25851474a279b20367fd24a0e816 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 17:21:53 +0200
-Subject:  hack: net: fq_codel: tune defaults for small devices
-
-Assume that x86_64 devices always have a big memory and do not need this 
-optimization compared to devices with only 32 MB or 64 MB RAM.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- net/sched/sch_fq_codel.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/net/sched/sch_fq_codel.c
-+++ b/net/sched/sch_fq_codel.c
-@@ -485,7 +485,11 @@ static int fq_codel_init(struct Qdisc *s
- 
- 	sch->limit = 10*1024;
- 	q->flows_cnt = 1024;
-+#ifdef CONFIG_X86_64
- 	q->memory_limit = 32 << 20; /* 32 MBytes */
-+#else
-+	q->memory_limit = 4 << 20; /* 4 MBytes */
-+#endif
- 	q->drop_batch_size = 64;
- 	q->quantum = psched_mtu(qdisc_dev(sch));
- 	get_random_bytes(&q->perturbation, sizeof(q->perturbation));
--- a/target/linux/generic/hack-4.9/661-use_fq_codel_by_default.patch	2022-03-22 08:54:47.231464709 +0800
+++ b/target/linux/generic/hack-4.9/661-use_fq_codel_by_default.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,94 +0,0 @@
-From 1d418f7e88035ed7a94073f6354246c66e9193e9 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 17:22:58 +0200
-Subject: fq_codel: switch default qdisc from pfifo_fast to fq_codel and remove pfifo_fast
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/net/sch_generic.h | 3 ++-
- net/sched/Kconfig         | 3 ++-
- net/sched/sch_api.c       | 2 +-
- net/sched/sch_fq_codel.c  | 3 ++-
- net/sched/sch_generic.c   | 4 ++--
- 5 files changed, 9 insertions(+), 6 deletions(-)
-
---- a/include/net/sch_generic.h
-+++ b/include/net/sch_generic.h
-@@ -344,12 +344,13 @@ extern struct Qdisc_ops noop_qdisc_ops;
- extern struct Qdisc_ops pfifo_fast_ops;
- extern struct Qdisc_ops mq_qdisc_ops;
- extern struct Qdisc_ops noqueue_qdisc_ops;
-+extern struct Qdisc_ops fq_codel_qdisc_ops;
- extern const struct Qdisc_ops *default_qdisc_ops;
- static inline const struct Qdisc_ops *
- get_default_qdisc_ops(const struct net_device *dev, int ntx)
- {
- 	return ntx < dev->real_num_tx_queues ?
--			default_qdisc_ops : &pfifo_fast_ops;
-+			default_qdisc_ops : &fq_codel_qdisc_ops;
- }
- 
- struct Qdisc_class_common {
---- a/net/sched/Kconfig
-+++ b/net/sched/Kconfig
-@@ -3,8 +3,9 @@
- # 
- 
- menuconfig NET_SCHED
--	bool "QoS and/or fair queueing"
-+	def_bool y
- 	select NET_SCH_FIFO
-+	select NET_SCH_FQ_CODEL
- 	---help---
- 	  When the kernel has several packets to send out over a network
- 	  device, it has to decide which ones to send first, which ones to
---- a/net/sched/sch_api.c
-+++ b/net/sched/sch_api.c
-@@ -1977,7 +1977,7 @@ static int __init pktsched_init(void)
- 		return err;
- 	}
- 
--	register_qdisc(&pfifo_fast_ops);
-+	register_qdisc(&fq_codel_qdisc_ops);
- 	register_qdisc(&pfifo_qdisc_ops);
- 	register_qdisc(&bfifo_qdisc_ops);
- 	register_qdisc(&pfifo_head_drop_qdisc_ops);
---- a/net/sched/sch_fq_codel.c
-+++ b/net/sched/sch_fq_codel.c
-@@ -715,7 +715,7 @@ static const struct Qdisc_class_ops fq_c
- 	.walk		=	fq_codel_walk,
- };
- 
--static struct Qdisc_ops fq_codel_qdisc_ops __read_mostly = {
-+struct Qdisc_ops fq_codel_qdisc_ops __read_mostly = {
- 	.cl_ops		=	&fq_codel_class_ops,
- 	.id		=	"fq_codel",
- 	.priv_size	=	sizeof(struct fq_codel_sched_data),
-@@ -730,6 +730,7 @@ static struct Qdisc_ops fq_codel_qdisc_o
- 	.dump_stats =	fq_codel_dump_stats,
- 	.owner		=	THIS_MODULE,
- };
-+EXPORT_SYMBOL(fq_codel_qdisc_ops);
- 
- static int __init fq_codel_module_init(void)
- {
---- a/net/sched/sch_generic.c
-+++ b/net/sched/sch_generic.c
-@@ -31,7 +31,7 @@
- #include <net/dst.h>
- 
- /* Qdisc to use by default */
--const struct Qdisc_ops *default_qdisc_ops = &pfifo_fast_ops;
-+const struct Qdisc_ops *default_qdisc_ops = &fq_codel_qdisc_ops;
- EXPORT_SYMBOL(default_qdisc_ops);
- 
- /* Main transmission queue. */
-@@ -764,7 +764,7 @@ static void attach_one_default_qdisc(str
- 				     void *_unused)
- {
- 	struct Qdisc *qdisc;
--	const struct Qdisc_ops *ops = default_qdisc_ops;
-+	const struct Qdisc_ops *ops = &fq_codel_qdisc_ops;
- 
- 	if (dev->priv_flags & IFF_NO_QUEUE)
- 		ops = &noqueue_qdisc_ops;
--- a/target/linux/generic/hack-4.9/662-remove_pfifo_fast.patch	2022-03-22 08:54:47.231464709 +0800
+++ b/target/linux/generic/hack-4.9/662-remove_pfifo_fast.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,159 +0,0 @@
-From b531d492d5ef1cf9dba0f4888eb5fd8624a6d762 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 17:23:42 +0200
-Subject: net: sched: switch default qdisc from pfifo_fast to fq_codel and remove pfifo_fast
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- net/sched/sch_generic.c | 140 ------------------------------------------------
- 1 file changed, 140 deletions(-)
-
---- a/net/sched/sch_generic.c
-+++ b/net/sched/sch_generic.c
-@@ -449,146 +449,6 @@ struct Qdisc_ops noqueue_qdisc_ops __rea
- 	.owner		=	THIS_MODULE,
- };
- 
--static const u8 prio2band[TC_PRIO_MAX + 1] = {
--	1, 2, 2, 2, 1, 2, 0, 0 , 1, 1, 1, 1, 1, 1, 1, 1
--};
--
--/* 3-band FIFO queue: old style, but should be a bit faster than
--   generic prio+fifo combination.
-- */
--
--#define PFIFO_FAST_BANDS 3
--
--/*
-- * Private data for a pfifo_fast scheduler containing:
-- * 	- queues for the three band
-- * 	- bitmap indicating which of the bands contain skbs
-- */
--struct pfifo_fast_priv {
--	u32 bitmap;
--	struct qdisc_skb_head q[PFIFO_FAST_BANDS];
--};
--
--/*
-- * Convert a bitmap to the first band number where an skb is queued, where:
-- * 	bitmap=0 means there are no skbs on any band.
-- * 	bitmap=1 means there is an skb on band 0.
-- *	bitmap=7 means there are skbs on all 3 bands, etc.
-- */
--static const int bitmap2band[] = {-1, 0, 1, 0, 2, 0, 1, 0};
--
--static inline struct qdisc_skb_head *band2list(struct pfifo_fast_priv *priv,
--					     int band)
--{
--	return priv->q + band;
--}
--
--static int pfifo_fast_enqueue(struct sk_buff *skb, struct Qdisc *qdisc,
--			      struct sk_buff **to_free)
--{
--	if (qdisc->q.qlen < qdisc_dev(qdisc)->tx_queue_len) {
--		int band = prio2band[skb->priority & TC_PRIO_MAX];
--		struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--		struct qdisc_skb_head *list = band2list(priv, band);
--
--		priv->bitmap |= (1 << band);
--		qdisc->q.qlen++;
--		return __qdisc_enqueue_tail(skb, qdisc, list);
--	}
--
--	return qdisc_drop(skb, qdisc, to_free);
--}
--
--static struct sk_buff *pfifo_fast_dequeue(struct Qdisc *qdisc)
--{
--	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--	int band = bitmap2band[priv->bitmap];
--
--	if (likely(band >= 0)) {
--		struct qdisc_skb_head *qh = band2list(priv, band);
--		struct sk_buff *skb = __qdisc_dequeue_head(qh);
--
--		if (likely(skb != NULL)) {
--			qdisc_qstats_backlog_dec(qdisc, skb);
--			qdisc_bstats_update(qdisc, skb);
--		}
--
--		qdisc->q.qlen--;
--		if (qh->qlen == 0)
--			priv->bitmap &= ~(1 << band);
--
--		return skb;
--	}
--
--	return NULL;
--}
--
--static struct sk_buff *pfifo_fast_peek(struct Qdisc *qdisc)
--{
--	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--	int band = bitmap2band[priv->bitmap];
--
--	if (band >= 0) {
--		struct qdisc_skb_head *qh = band2list(priv, band);
--
--		return qh->head;
--	}
--
--	return NULL;
--}
--
--static void pfifo_fast_reset(struct Qdisc *qdisc)
--{
--	int prio;
--	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--
--	for (prio = 0; prio < PFIFO_FAST_BANDS; prio++)
--		__qdisc_reset_queue(band2list(priv, prio));
--
--	priv->bitmap = 0;
--	qdisc->qstats.backlog = 0;
--	qdisc->q.qlen = 0;
--}
--
--static int pfifo_fast_dump(struct Qdisc *qdisc, struct sk_buff *skb)
--{
--	struct tc_prio_qopt opt = { .bands = PFIFO_FAST_BANDS };
--
--	memcpy(&opt.priomap, prio2band, TC_PRIO_MAX + 1);
--	if (nla_put(skb, TCA_OPTIONS, sizeof(opt), &opt))
--		goto nla_put_failure;
--	return skb->len;
--
--nla_put_failure:
--	return -1;
--}
--
--static int pfifo_fast_init(struct Qdisc *qdisc, struct nlattr *opt)
--{
--	int prio;
--	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--
--	for (prio = 0; prio < PFIFO_FAST_BANDS; prio++)
--		qdisc_skb_head_init(band2list(priv, prio));
--
--	/* Can by-pass the queue discipline */
--	qdisc->flags |= TCQ_F_CAN_BYPASS;
--	return 0;
--}
--
--struct Qdisc_ops pfifo_fast_ops __read_mostly = {
--	.id		=	"pfifo_fast",
--	.priv_size	=	sizeof(struct pfifo_fast_priv),
--	.enqueue	=	pfifo_fast_enqueue,
--	.dequeue	=	pfifo_fast_dequeue,
--	.peek		=	pfifo_fast_peek,
--	.init		=	pfifo_fast_init,
--	.reset		=	pfifo_fast_reset,
--	.dump		=	pfifo_fast_dump,
--	.owner		=	THIS_MODULE,
--};
--EXPORT_SYMBOL(pfifo_fast_ops);
--
- static struct lock_class_key qdisc_tx_busylock;
- static struct lock_class_key qdisc_running_key;
- 
--- a/target/linux/generic/hack-4.9/700-swconfig_switch_drivers.patch	2022-03-22 08:54:47.232464711 +0800
+++ b/target/linux/generic/hack-4.9/700-swconfig_switch_drivers.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,150 +0,0 @@
-From 36e516290611e613aa92996cb4339561452695b4 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 17:24:23 +0200
-Subject: net: swconfig: adds openwrt switch layer
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- drivers/net/phy/Kconfig   | 83 +++++++++++++++++++++++++++++++++++++++++++++++
- drivers/net/phy/Makefile  | 15 +++++++++
- include/uapi/linux/Kbuild |  1 +
- 3 files changed, 99 insertions(+)
-
---- a/drivers/net/phy/Kconfig
-+++ b/drivers/net/phy/Kconfig
-@@ -147,6 +147,89 @@ config MDIO_XGENE
- 	  This module provides a driver for the MDIO busses found in the
- 	  APM X-Gene SoC's.
- 
-+comment "Switch configuration API + drivers"
-+
-+config SWCONFIG
-+	tristate "Switch configuration API"
-+	---help---
-+	  Switch configuration API using netlink. This allows
-+	  you to configure the VLAN features of certain switches.
-+
-+config SWCONFIG_LEDS
-+	bool "Switch LED trigger support"
-+	depends on (SWCONFIG && LEDS_TRIGGERS)
-+
-+config ADM6996_PHY
-+	tristate "Driver for ADM6996 switches"
-+	select SWCONFIG
-+	---help---
-+	  Currently supports the ADM6996FC and ADM6996M switches.
-+	  Support for FC is very limited.
-+
-+config AR8216_PHY
-+	tristate "Driver for Atheros AR8216 switches"
-+	select ETHERNET_PACKET_MANGLE
-+	select SWCONFIG
-+
-+config AR8216_PHY_LEDS
-+	bool "Atheros AR8216 switch LED support"
-+	depends on (AR8216_PHY && LEDS_CLASS)
-+
-+source "drivers/net/phy/b53/Kconfig"
-+
-+config IP17XX_PHY
-+	tristate "Driver for IC+ IP17xx switches"
-+	select SWCONFIG
-+
-+config MVSWITCH_PHY
-+	tristate "Driver for Marvell 88E6060 switches"
-+	select ETHERNET_PACKET_MANGLE
-+
-+config MVSW61XX_PHY
-+	tristate "Driver for Marvell 88E6171/6172 switches"
-+	select SWCONFIG
-+
-+config PSB6970_PHY
-+	tristate "Lantiq XWAY Tantos (PSB6970) Ethernet switch"
-+	select SWCONFIG
-+	select ETHERNET_PACKET_MANGLE
-+
-+config RTL8306_PHY
-+	tristate "Driver for Realtek RTL8306S switches"
-+	select SWCONFIG
-+
-+config RTL8366_SMI
-+	tristate "Driver for the RTL8366 SMI interface"
-+	depends on GPIOLIB
-+	---help---
-+	  This module implements the SMI interface protocol which is used
-+	  by some RTL8366 ethernet switch devices via the generic GPIO API.
-+
-+if RTL8366_SMI
-+
-+config RTL8366_SMI_DEBUG_FS
-+	bool "RTL8366 SMI interface debugfs support"
-+        depends on DEBUG_FS
-+        default n
-+
-+config RTL8366S_PHY
-+	tristate "Driver for the Realtek RTL8366S switch"
-+	select SWCONFIG
-+
-+config RTL8366RB_PHY
-+	tristate "Driver for the Realtek RTL8366RB switch"
-+	select SWCONFIG
-+
-+config RTL8367_PHY
-+	tristate "Driver for the Realtek RTL8367R/M switches"
-+	select SWCONFIG
-+
-+config RTL8367B_PHY
-+	tristate "Driver fot the Realtek RTL8367R-VB switch"
-+	select SWCONFIG
-+
-+endif # RTL8366_SMI
-+
- comment "MII PHY device drivers"
- 
- config AMD_PHY
---- a/drivers/net/phy/Makefile
-+++ b/drivers/net/phy/Makefile
-@@ -5,6 +5,21 @@ libphy-$(CONFIG_SWPHY)		+= swphy.o
- 
- obj-$(CONFIG_PHYLIB)		+= libphy.o
- 
-+obj-$(CONFIG_SWCONFIG)		+= swconfig.o
-+obj-$(CONFIG_ADM6996_PHY)	+= adm6996.o
-+obj-$(CONFIG_AR8216_PHY)	+= ar8216.o ar8327.o
-+obj-$(CONFIG_SWCONFIG_B53)	+= b53/
-+obj-$(CONFIG_IP17XX_PHY)	+= ip17xx.o
-+obj-$(CONFIG_MVSWITCH_PHY)	+= mvswitch.o
-+obj-$(CONFIG_MVSW61XX_PHY)	+= mvsw61xx.o
-+obj-$(CONFIG_PSB6970_PHY)	+= psb6970.o
-+obj-$(CONFIG_RTL8306_PHY)	+= rtl8306.o
-+obj-$(CONFIG_RTL8366_SMI)	+= rtl8366_smi.o
-+obj-$(CONFIG_RTL8366S_PHY)	+= rtl8366s.o
-+obj-$(CONFIG_RTL8366RB_PHY)	+= rtl8366rb.o
-+obj-$(CONFIG_RTL8367_PHY)	+= rtl8367.o
-+obj-$(CONFIG_RTL8367B_PHY)	+= rtl8367b.o
-+
- obj-$(CONFIG_MDIO_BCM_IPROC)	+= mdio-bcm-iproc.o
- obj-$(CONFIG_MDIO_BCM_UNIMAC)	+= mdio-bcm-unimac.o
- obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
---- a/include/uapi/linux/Kbuild
-+++ b/include/uapi/linux/Kbuild
-@@ -399,6 +399,7 @@ header-y += stddef.h
- header-y += string.h
- header-y += suspend_ioctls.h
- header-y += swab.h
-+header-y += switch.h
- header-y += synclink.h
- header-y += sync_file.h
- header-y += sysctl.h
---- a/include/linux/platform_data/b53.h
-+++ b/include/linux/platform_data/b53.h
-@@ -25,6 +25,9 @@ struct b53_platform_data {
- 	u32 chip_id;
- 	u16 enabled_ports;
- 
-+	/* allow to specify an ethX alias */
-+	const char *alias;
-+
- 	/* only used by MMAP'd driver */
- 	unsigned big_endian:1;
- 	void __iomem *regs;
--- a/target/linux/generic/hack-4.9/702-phy_add_aneg_done_function.patch	2022-03-22 08:54:47.232464711 +0800
+++ b/target/linux/generic/hack-4.9/702-phy_add_aneg_done_function.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,27 +0,0 @@
---- a/include/linux/phy.h
-+++ b/include/linux/phy.h
-@@ -495,6 +495,12 @@ struct phy_driver {
- 	/* Determines the negotiated speed and duplex */
- 	int (*read_status)(struct phy_device *phydev);
- 
-+	/* 
-+	 * Update the value in phydev->link to reflect the 
-+	 * current link value
-+	 */
-+	int (*update_link)(struct phy_device *phydev);
-+
- 	/* Clears any pending interrupts */
- 	int (*ack_interrupt)(struct phy_device *phydev);
- 
---- a/drivers/net/phy/phy_device.c
-+++ b/drivers/net/phy/phy_device.c
-@@ -1315,6 +1315,9 @@ int genphy_update_link(struct phy_device
- {
- 	int status;
- 
-+	if (phydev->drv && phydev->drv->update_link)
-+		return phydev->drv->update_link(phydev);
-+
- 	/* Do a fake read */
- 	status = phy_read(phydev, MII_BMSR);
- 	if (status < 0)
--- a/target/linux/generic/hack-4.9/710-phy-add-mdio_register_board_info.patch	2022-03-22 08:54:47.232464711 +0800
+++ b/target/linux/generic/hack-4.9/710-phy-add-mdio_register_board_info.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,197 +0,0 @@
---- a/drivers/net/phy/mdio_bus.c
-+++ b/drivers/net/phy/mdio_bus.c
-@@ -80,6 +80,8 @@ bool mdiobus_is_registered_device(struct
- }
- EXPORT_SYMBOL(mdiobus_is_registered_device);
- 
-+#include "mdio-boardinfo.h"
-+
- /**
-  * mdiobus_alloc_size - allocate a mii_bus structure
-  * @size: extra amount of memory to allocate for private storage.
-@@ -400,6 +402,17 @@ void mdiobus_free(struct mii_bus *bus)
- }
- EXPORT_SYMBOL(mdiobus_free);
- 
-+static void mdiobus_setup_phydev_from_boardinfo(struct mii_bus *bus,
-+						struct phy_device *phydev,
-+						struct mdio_board_info *bi)
-+{
-+	if (strcmp(bus->id, bi->bus_id) ||
-+	    bi->phy_addr != phydev->mdio.addr)
-+	    return;
-+
-+	phydev->mdio.dev.platform_data = (void *) bi->platform_data;
-+}
-+
- /**
-  * mdiobus_scan - scan a bus for MDIO devices.
-  * @bus: mii_bus to scan
-@@ -415,6 +428,7 @@ EXPORT_SYMBOL(mdiobus_free);
- struct phy_device *mdiobus_scan(struct mii_bus *bus, int addr)
- {
- 	struct phy_device *phydev;
-+	struct mdio_board_entry *be;
- 	int err;
- 
- 	phydev = get_phy_device(bus, addr, false);
-@@ -427,6 +441,12 @@ struct phy_device *mdiobus_scan(struct m
- 	 */
- 	of_mdiobus_link_mdiodev(bus, &phydev->mdio);
- 
-+	mutex_lock(&__mdio_board_lock);
-+	list_for_each_entry(be, &__mdio_board_list, list)
-+		mdiobus_setup_phydev_from_boardinfo(bus, phydev,
-+						    &be->board_info);
-+	mutex_unlock(&__mdio_board_lock);
-+
- 	err = phy_device_register(phydev);
- 	if (err) {
- 		phy_device_free(phydev);
---- a/include/linux/phy.h
-+++ b/include/linux/phy.h
-@@ -870,6 +870,23 @@ void mdio_bus_exit(void);
- 
- extern struct bus_type mdio_bus_type;
- 
-+struct mdio_board_info {
-+	const char	*bus_id;
-+	int		phy_addr;
-+
-+	const void	*platform_data;
-+};
-+
-+#ifdef CONFIG_MDIO_BOARDINFO
-+int mdiobus_register_board_info(const struct mdio_board_info *info, unsigned n);
-+#else
-+static inline int
-+mdiobus_register_board_info(const struct mdio_board_info *info, unsigned n)
-+{
-+	return 0;
-+}
-+#endif
-+
- /**
-  * module_phy_driver() - Helper macro for registering PHY drivers
-  * @__phy_drivers: array of PHY drivers to register
---- a/drivers/net/phy/Kconfig
-+++ b/drivers/net/phy/Kconfig
-@@ -149,6 +149,10 @@ config MDIO_XGENE
- 
- comment "Switch configuration API + drivers"
- 
-+config MDIO_BOARDINFO
-+	bool
-+	default y
-+
- config SWCONFIG
- 	tristate "Switch configuration API"
- 	---help---
---- a/drivers/net/phy/Makefile
-+++ b/drivers/net/phy/Makefile
-@@ -3,6 +3,8 @@
- libphy-y			:= phy.o phy_device.o mdio_bus.o mdio_device.o
- libphy-$(CONFIG_SWPHY)		+= swphy.o
- 
-+obj-$(CONFIG_MDIO_BOARDINFO)	+= mdio-boardinfo.o
-+
- obj-$(CONFIG_PHYLIB)		+= libphy.o
- 
- obj-$(CONFIG_SWCONFIG)		+= swconfig.o
---- /dev/null
-+++ b/drivers/net/phy/mdio-boardinfo.c
-@@ -0,0 +1,58 @@
-+/*
-+ * mdio-boardinfo.c - collect pre-declarations of PHY devices
-+ *
-+ * This program is free software; you can redistribute  it and/or modify it
-+ * under  the terms of  the GNU General  Public License as published by the
-+ * Free Software Foundation;  either version 2 of the  License, or (at your
-+ * option) any later version.
-+ *
-+ */
-+
-+#include <linux/kernel.h>
-+#include <linux/phy.h>
-+#include <linux/slab.h>
-+#include <linux/export.h>
-+#include <linux/mutex.h>
-+#include <linux/phy.h>
-+
-+#include "mdio-boardinfo.h"
-+
-+/*
-+ * These symbols are exported ONLY FOR the mdio_bus component.
-+ * No other users will be supported.
-+ */
-+
-+LIST_HEAD(__mdio_board_list);
-+EXPORT_SYMBOL_GPL(__mdio_board_list);
-+
-+DEFINE_MUTEX(__mdio_board_lock);
-+EXPORT_SYMBOL_GPL(__mdio_board_lock);
-+
-+/**
-+ * mdio_register_board_info - register PHY devices for a given board
-+ * @info: array of chip descriptors
-+ * @n: how many descriptors are provided
-+ * Context: can sleep
-+ *
-+ * The board info passed can safely be __initdata ... but be careful of
-+ * any embedded pointers (platform_data, etc), they're copied as-is.
-+ */
-+int __init
-+mdiobus_register_board_info(struct mdio_board_info const *info, unsigned n)
-+{
-+	struct mdio_board_entry *be;
-+	int i;
-+
-+	be = kzalloc(n * sizeof(*be), GFP_KERNEL);
-+	if (!be)
-+		return -ENOMEM;
-+
-+	for (i = 0; i < n; i++, be++, info++) {
-+		memcpy(&be->board_info, info, sizeof(*info));
-+		mutex_lock(&__mdio_board_lock);
-+		list_add_tail(&be->list, &__mdio_board_list);
-+		mutex_unlock(&__mdio_board_lock);
-+	}
-+
-+	return 0;
-+}
---- /dev/null
-+++ b/drivers/net/phy/mdio-boardinfo.h
-@@ -0,0 +1,22 @@
-+/*
-+ * mdio-boardinfo.h - boardinfo interface internal to the mdio_bus component
-+ *
-+ * This program is free software; you can redistribute  it and/or modify it
-+ * under  the terms of  the GNU General  Public License as published by the
-+ * Free Software Foundation;  either version 2 of the  License, or (at your
-+ * option) any later version.
-+ *
-+ */
-+
-+#include <linux/mutex.h>
-+
-+struct mdio_board_entry {
-+	struct list_head	list;
-+	struct mdio_board_info	board_info;
-+};
-+
-+/* __mdio_board_lock protects __mdio_board_list
-+ * only mdio_bus components are allowed to use these symbols.
-+ */
-+extern struct mutex __mdio_board_lock;
-+extern struct list_head __mdio_board_list;
---- a/drivers/net/Makefile
-+++ b/drivers/net/Makefile
-@@ -17,7 +17,7 @@ obj-$(CONFIG_MII) += mii.o
- obj-$(CONFIG_MDIO) += mdio.o
- obj-$(CONFIG_NET) += Space.o loopback.o
- obj-$(CONFIG_NETCONSOLE) += netconsole.o
--obj-$(CONFIG_PHYLIB) += phy/
-+obj-y += phy/
- obj-$(CONFIG_RIONET) += rionet.o
- obj-$(CONFIG_NET_TEAM) += team/
- obj-$(CONFIG_TUN) += tun.o
--- a/target/linux/generic/hack-4.9/721-phy_packets.patch	2022-03-22 08:54:47.233464713 +0800
+++ b/target/linux/generic/hack-4.9/721-phy_packets.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,176 +0,0 @@
-From ffe387740bbe88dd88bbe04d6375902708003d6e Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 17:25:00 +0200
-Subject: net: add packet mangeling patch
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/linux/netdevice.h | 11 +++++++++++
- include/linux/skbuff.h    | 14 ++++----------
- net/Kconfig               |  6 ++++++
- net/core/dev.c            | 18 ++++++++++++++----
- net/core/skbuff.c         | 17 +++++++++++++++++
- net/ethernet/eth.c        |  6 ++++++
- 6 files changed, 58 insertions(+), 14 deletions(-)
-
---- a/include/linux/netdevice.h
-+++ b/include/linux/netdevice.h
-@@ -1400,6 +1400,7 @@ enum netdev_priv_flags {
- 	IFF_PHONY_HEADROOM		= 1<<26,
- 	IFF_MACSEC			= 1<<27,
- 	IFF_L3MDEV_RX_HANDLER		= 1<<28,
-+	IFF_NO_IP_ALIGN			= 1<<29,
- };
- 
- #define IFF_802_1Q_VLAN			IFF_802_1Q_VLAN
-@@ -1430,6 +1431,7 @@ enum netdev_priv_flags {
- #define IFF_RXFH_CONFIGURED		IFF_RXFH_CONFIGURED
- #define IFF_MACSEC			IFF_MACSEC
- #define IFF_L3MDEV_RX_HANDLER		IFF_L3MDEV_RX_HANDLER
-+#define IFF_NO_IP_ALIGN			IFF_NO_IP_ALIGN
- 
- /**
-  *	struct net_device - The DEVICE structure.
-@@ -1716,6 +1718,11 @@ struct net_device {
- 	const struct ndisc_ops *ndisc_ops;
- #endif
- 
-+#ifdef CONFIG_ETHERNET_PACKET_MANGLE
-+	void (*eth_mangle_rx)(struct net_device *dev, struct sk_buff *skb);
-+	struct sk_buff *(*eth_mangle_tx)(struct net_device *dev, struct sk_buff *skb);
-+#endif
-+
- 	const struct header_ops *header_ops;
- 
- 	unsigned int		flags;
-@@ -1783,6 +1790,10 @@ struct net_device {
- 	struct mpls_dev __rcu	*mpls_ptr;
- #endif
- 
-+#ifdef CONFIG_ETHERNET_PACKET_MANGLE
-+	void			*phy_ptr; /* PHY device specific data */
-+#endif
-+
- /*
-  * Cache lines mostly used on receive path (including eth_type_trans())
-  */
---- a/include/linux/skbuff.h
-+++ b/include/linux/skbuff.h
-@@ -2340,6 +2340,10 @@ static inline int pskb_trim(struct sk_bu
- 	return (len < skb->len) ? __pskb_trim(skb, len) : 0;
- }
- 
-+extern struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
-+		unsigned int length, gfp_t gfp);
-+
-+
- /**
-  *	pskb_trim_unique - remove end from a paged unique (not cloned) buffer
-  *	@skb: buffer to alter
-@@ -2460,16 +2464,6 @@ static inline struct sk_buff *dev_alloc_
- }
- 
- 
--static inline struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
--		unsigned int length, gfp_t gfp)
--{
--	struct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);
--
--	if (NET_IP_ALIGN && skb)
--		skb_reserve(skb, NET_IP_ALIGN);
--	return skb;
--}
--
- static inline struct sk_buff *netdev_alloc_skb_ip_align(struct net_device *dev,
- 		unsigned int length)
- {
---- a/net/Kconfig
-+++ b/net/Kconfig
-@@ -25,6 +25,12 @@ menuconfig NET
- 
- if NET
- 
-+config ETHERNET_PACKET_MANGLE
-+	bool
-+	help
-+	  This option can be selected by phy drivers that need to mangle
-+	  packets going in or out of an ethernet device.
-+
- config WANT_COMPAT_NETLINK_MESSAGES
- 	bool
- 	help
---- a/net/core/dev.c
-+++ b/net/core/dev.c
-@@ -2972,10 +2972,20 @@ static int xmit_one(struct sk_buff *skb,
- 	if (!list_empty(&ptype_all) || !list_empty(&dev->ptype_all))
- 		dev_queue_xmit_nit(skb, dev);
- 
--	len = skb->len;
--	trace_net_dev_start_xmit(skb, dev);
--	rc = netdev_start_xmit(skb, dev, txq, more);
--	trace_net_dev_xmit(skb, rc, dev, len);
-+#ifdef CONFIG_ETHERNET_PACKET_MANGLE
-+	if (!dev->eth_mangle_tx ||
-+	    (skb = dev->eth_mangle_tx(dev, skb)) != NULL)
-+#else
-+	if (1)
-+#endif
-+	{
-+		len = skb->len;
-+		trace_net_dev_start_xmit(skb, dev);
-+		rc = netdev_start_xmit(skb, dev, txq, more);
-+		trace_net_dev_xmit(skb, rc, dev, len);
-+	} else {
-+		rc = NETDEV_TX_OK;
-+	}
- 
- 	return rc;
- }
---- a/net/core/skbuff.c
-+++ b/net/core/skbuff.c
-@@ -64,6 +64,7 @@
- #include <linux/errqueue.h>
- #include <linux/prefetch.h>
- #include <linux/if_vlan.h>
-+#include <linux/if.h>
- 
- #include <net/protocol.h>
- #include <net/dst.h>
-@@ -533,6 +534,22 @@ skb_fail:
- }
- EXPORT_SYMBOL(__napi_alloc_skb);
- 
-+struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
-+		unsigned int length, gfp_t gfp)
-+{
-+	struct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);
-+
-+#ifdef CONFIG_ETHERNET_PACKET_MANGLE
-+	if (dev && (dev->priv_flags & IFF_NO_IP_ALIGN))
-+		return skb;
-+#endif
-+
-+	if (NET_IP_ALIGN && skb)
-+		skb_reserve(skb, NET_IP_ALIGN);
-+	return skb;
-+}
-+EXPORT_SYMBOL(__netdev_alloc_skb_ip_align);
-+
- void skb_add_rx_frag(struct sk_buff *skb, int i, struct page *page, int off,
- 		     int size, unsigned int truesize)
- {
---- a/net/ethernet/eth.c
-+++ b/net/ethernet/eth.c
-@@ -171,6 +171,12 @@ __be16 eth_type_trans(struct sk_buff *sk
- 	const struct ethhdr *eth;
- 
- 	skb->dev = dev;
-+
-+#ifdef CONFIG_ETHERNET_PACKET_MANGLE
-+	if (dev->eth_mangle_rx)
-+		dev->eth_mangle_rx(dev, skb);
-+#endif
-+
- 	skb_reset_mac_header(skb);
- 
- 	eth = (struct ethhdr *)skb->data;
--- a/target/linux/generic/hack-4.9/773-bgmac-add-srab-switch.patch	2022-03-22 08:54:47.233464713 +0800
+++ b/target/linux/generic/hack-4.9/773-bgmac-add-srab-switch.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,98 +0,0 @@
-From 3cb240533ab787899dc7f17aa7d6c5b4810e2e58 Mon Sep 17 00:00:00 2001
-From: Hauke Mehrtens <hauke@hauke-m.de>
-Date: Fri, 7 Jul 2017 17:26:01 +0200
-Subject: bcm53xx: bgmac: use srab switch driver
-
-use the srab switch driver on these SoCs.
-
-Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
----
- drivers/net/ethernet/broadcom/bgmac-bcma.c |  1 +
- drivers/net/ethernet/broadcom/bgmac.c      | 24 ++++++++++++++++++++++++
- drivers/net/ethernet/broadcom/bgmac.h      |  4 ++++
- 3 files changed, 29 insertions(+)
-
---- a/drivers/net/ethernet/broadcom/bgmac-bcma.c
-+++ b/drivers/net/ethernet/broadcom/bgmac-bcma.c
-@@ -243,6 +243,7 @@ static int bgmac_probe(struct bcma_devic
- 		bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
- 		bgmac->feature_flags |= BGMAC_FEAT_NO_RESET;
- 		bgmac->feature_flags |= BGMAC_FEAT_FORCE_SPEED_2500;
-+		bgmac->feature_flags |= BGMAC_FEAT_SRAB;
- 		break;
- 	case BCMA_CHIP_ID_BCM53573:
- 		bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
---- a/drivers/net/ethernet/broadcom/bgmac.c
-+++ b/drivers/net/ethernet/broadcom/bgmac.c
-@@ -11,6 +11,7 @@
- 
- #include <linux/bcma/bcma.h>
- #include <linux/etherdevice.h>
-+#include <linux/platform_data/b53.h>
- #include <linux/bcm47xx_nvram.h>
- #include "bgmac.h"
- 
-@@ -1388,6 +1389,17 @@ static const struct ethtool_ops bgmac_et
- 	.set_link_ksettings     = phy_ethtool_set_link_ksettings,
- };
- 
-+static struct b53_platform_data bgmac_b53_pdata = {
-+};
-+
-+static struct platform_device bgmac_b53_dev = {
-+	.name		= "b53-srab-switch",
-+	.id		= -1,
-+	.dev		= {
-+		.platform_data = &bgmac_b53_pdata,
-+	},
-+};
-+
- /**************************************************
-  * MII
-  **************************************************/
-@@ -1534,6 +1546,14 @@ int bgmac_enet_probe(struct bgmac *bgmac
- 	net_dev->hw_features = net_dev->features;
- 	net_dev->vlan_features = net_dev->features;
- 
-+	if ((bgmac->feature_flags & BGMAC_FEAT_SRAB) && !bgmac_b53_pdata.regs) {
-+		bgmac_b53_pdata.regs = ioremap_nocache(0x18007000, 0x1000);
-+
-+		err = platform_device_register(&bgmac_b53_dev);
-+		if (!err)
-+			bgmac->b53_device = &bgmac_b53_dev;
-+	}
-+
- 	err = register_netdev(bgmac->net_dev);
- 	if (err) {
- 		dev_err(bgmac->dev, "Cannot register net device\n");
-@@ -1556,6 +1576,10 @@ EXPORT_SYMBOL_GPL(bgmac_enet_probe);
- 
- void bgmac_enet_remove(struct bgmac *bgmac)
- {
-+	if (bgmac->b53_device)
-+		platform_device_unregister(&bgmac_b53_dev);
-+	bgmac->b53_device = NULL;
-+
- 	unregister_netdev(bgmac->net_dev);
- 	phy_disconnect(bgmac->net_dev->phydev);
- 	netif_napi_del(&bgmac->napi);
---- a/drivers/net/ethernet/broadcom/bgmac.h
-+++ b/drivers/net/ethernet/broadcom/bgmac.h
-@@ -409,6 +409,7 @@
- #define BGMAC_FEAT_CC4_IF_SW_TYPE	BIT(17)
- #define BGMAC_FEAT_CC4_IF_SW_TYPE_RGMII	BIT(18)
- #define BGMAC_FEAT_CC7_IF_TYPE_RGMII	BIT(19)
-+#define BGMAC_FEAT_SRAB			BIT(20)
- 
- struct bgmac_slot_info {
- 	union {
-@@ -513,6 +514,9 @@ struct bgmac {
- 	u32 (*get_bus_clock)(struct bgmac *bgmac);
- 	void (*cmn_maskset32)(struct bgmac *bgmac, u16 offset, u32 mask,
- 			      u32 set);
-+
-+	/* platform device for associated switch */
-+	struct platform_device *b53_device;
- };
- 
- struct bgmac *bgmac_alloc(struct device *dev);
--- a/target/linux/generic/hack-4.9/835-misc-owl_loader.patch	2022-03-22 08:54:47.233464713 +0800
+++ b/target/linux/generic/hack-4.9/835-misc-owl_loader.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,52 +0,0 @@
-From dd36f935973d91644449bd9749f6062a2bed821b Mon Sep 17 00:00:00 2001
-From: Christian Lamparter <chunkeey@googlemail.com>
-Date: Fri, 7 Jul 2017 17:26:46 +0200
-Subject: misc: owl-loader for delayed Atheros ath9k fixup
-
-Some devices (like the Cisco Meraki Z1 Cloud Managed Teleworker Gateway)
-need to be able to initialize the PCIe wifi device. Normally, this is done
-during the early stages of booting linux, because the necessary init code
-is read from the memory mapped SPI and passed to pci_enable_ath9k_fixup.
-However,this isn't possible for devices which have the init code for the
-Atheros chip stored on NAND in an UBI volume. Hence, this module can be
-used to initialze the chip when the user-space is ready to extract the
-init code.
-
-Signed-off-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
-Signed-off-by: Christian Lamparter <chunkeey@googlemail.com>
----
- drivers/misc/Kconfig  | 12 ++++++++++++
- drivers/misc/Makefile |  1 +
- 2 files changed, 13 insertions(+)
-
---- a/drivers/misc/Kconfig
-+++ b/drivers/misc/Kconfig
-@@ -151,6 +151,18 @@ config SGI_IOC4
- 	  If you have an SGI Altix with an IOC4-based card say Y.
- 	  Otherwise say N.
- 
-+config OWL_LOADER
-+	tristate "Owl loader for initializing Atheros PCI(e) Wifi chips"
-+	depends on PCI
-+	---help---
-+	This kernel module helps to initialize certain Qualcomm
-+	Atheros' PCI(e) Wifi chips, which have the init data
-+	(which contains the PCI device ID for example) stored
-+	together with the calibration data in the file system.
-+
-+	This is necessary for devices like the Cisco Meraki Z1, say M.
-+	Otherwise say N.
-+
- config TIFM_CORE
- 	tristate "TI Flash Media interface support"
- 	depends on PCI
---- a/drivers/misc/Makefile
-+++ b/drivers/misc/Makefile
-@@ -12,6 +12,7 @@ obj-$(CONFIG_ATMEL_TCLIB)	+= atmel_tclib
- obj-$(CONFIG_DUMMY_IRQ)		+= dummy-irq.o
- obj-$(CONFIG_ICS932S401)	+= ics932s401.o
- obj-$(CONFIG_LKDTM)		+= lkdtm.o
-+obj-$(CONFIG_OWL_LOADER)	+= owl-loader.o
- obj-$(CONFIG_TIFM_CORE)       	+= tifm_core.o
- obj-$(CONFIG_TIFM_7XX1)       	+= tifm_7xx1.o
- obj-$(CONFIG_PHANTOM)		+= phantom.o
--- a/target/linux/generic/hack-4.9/901-debloat_sock_diag.patch	2022-03-22 08:54:47.234464714 +0800
+++ b/target/linux/generic/hack-4.9/901-debloat_sock_diag.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,95 +0,0 @@
-From 3b6115d6b57a263bdc8c9b1df273bd4a7955eead Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 8 Jul 2017 08:16:31 +0200
-Subject: debloat: add some debloat patches, strip down procfs and make O_DIRECT support optional, saves ~15K after lzma on MIPS
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- net/Kconfig         | 3 +++
- net/core/Makefile   | 3 ++-
- net/core/sock.c     | 2 ++
- net/ipv4/Kconfig    | 1 +
- net/netlink/Kconfig | 1 +
- net/packet/Kconfig  | 1 +
- net/unix/Kconfig    | 1 +
- 7 files changed, 11 insertions(+), 1 deletion(-)
-
---- a/net/Kconfig
-+++ b/net/Kconfig
-@@ -95,6 +95,9 @@ source "net/netlabel/Kconfig"
- 
- endif # if INET
- 
-+config SOCK_DIAG
-+	bool
-+
- config NETWORK_SECMARK
- 	bool "Security Marking"
- 	help
---- a/net/core/Makefile
-+++ b/net/core/Makefile
-@@ -9,8 +9,9 @@ obj-$(CONFIG_SYSCTL) += sysctl_net_core.
- 
- obj-y		     += dev.o ethtool.o dev_addr_lists.o dst.o netevent.o \
- 			neighbour.o rtnetlink.o utils.o link_watch.o filter.o \
--			sock_diag.o dev_ioctl.o tso.o sock_reuseport.o
-+			dev_ioctl.o tso.o sock_reuseport.o
- 
-+obj-$(CONFIG_SOCK_DIAG) += sock_diag.o
- obj-$(CONFIG_XFRM) += flow.o
- obj-y += net-sysfs.o
- obj-$(CONFIG_PROC_FS) += net-procfs.o
---- a/net/core/sock.c
-+++ b/net/core/sock.c
-@@ -1463,9 +1463,11 @@ void sk_destruct(struct sock *sk)
- 
- static void __sk_free(struct sock *sk)
- {
-+#ifdef CONFIG_SOCK_DIAG
- 	if (unlikely(sk->sk_net_refcnt && sock_diag_has_destroy_listeners(sk)))
- 		sock_diag_broadcast_destroy(sk);
- 	else
-+#endif
- 		sk_destruct(sk);
- }
- 
---- a/net/ipv4/Kconfig
-+++ b/net/ipv4/Kconfig
-@@ -408,6 +408,7 @@ config INET_XFRM_MODE_BEET
- 
- config INET_DIAG
- 	tristate "INET: socket monitoring interface"
-+	select SOCK_DIAG
- 	default y
- 	---help---
- 	  Support for INET (TCP, DCCP, etc) socket monitoring interface used by
---- a/net/netlink/Kconfig
-+++ b/net/netlink/Kconfig
-@@ -4,6 +4,7 @@
- 
- config NETLINK_DIAG
- 	tristate "NETLINK: socket monitoring interface"
-+	select SOCK_DIAG
- 	default n
- 	---help---
- 	  Support for NETLINK socket monitoring interface used by the ss tool.
---- a/net/packet/Kconfig
-+++ b/net/packet/Kconfig
-@@ -18,6 +18,7 @@ config PACKET
- config PACKET_DIAG
- 	tristate "Packet: sockets monitoring interface"
- 	depends on PACKET
-+	select SOCK_DIAG
- 	default n
- 	---help---
- 	  Support for PF_PACKET sockets monitoring interface used by the ss tool.
---- a/net/unix/Kconfig
-+++ b/net/unix/Kconfig
-@@ -22,6 +22,7 @@ config UNIX
- config UNIX_DIAG
- 	tristate "UNIX: socket monitoring interface"
- 	depends on UNIX
-+	select SOCK_DIAG
- 	default n
- 	---help---
- 	  Support for UNIX socket monitoring interface used by the ss tool.
--- a/target/linux/generic/hack-4.9/902-debloat_proc.patch	2022-03-22 08:54:47.234464714 +0800
+++ b/target/linux/generic/hack-4.9/902-debloat_proc.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,406 +0,0 @@
-From 9e3f1d0805b2d919904dd9a4ff0d956314cc3cba Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 8 Jul 2017 08:20:09 +0200
-Subject: debloat: procfs
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- fs/locks.c               |  2 ++
- fs/proc/Kconfig          |  5 +++++
- fs/proc/consoles.c       |  3 +++
- fs/proc/proc_tty.c       | 11 ++++++++++-
- include/net/snmp.h       | 18 +++++++++++++++++-
- ipc/msg.c                |  3 +++
- ipc/sem.c                |  2 ++
- ipc/shm.c                |  2 ++
- ipc/util.c               |  3 +++
- kernel/exec_domain.c     |  2 ++
- kernel/irq/proc.c        |  9 +++++++++
- kernel/time/timer_list.c |  2 ++
- mm/vmalloc.c             |  2 ++
- mm/vmstat.c              |  8 +++++---
- net/8021q/vlanproc.c     |  6 ++++++
- net/core/net-procfs.c    | 18 ++++++++++++------
- net/core/sock.c          |  2 ++
- net/ipv4/fib_trie.c      | 18 ++++++++++++------
- net/ipv4/proc.c          |  3 +++
- net/ipv4/route.c         |  3 +++
- 20 files changed, 105 insertions(+), 17 deletions(-)
-
---- a/fs/locks.c
-+++ b/fs/locks.c
-@@ -2802,6 +2802,8 @@ static const struct file_operations proc
- 
- static int __init proc_locks_init(void)
- {
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return 0;
- 	proc_create("locks", 0, NULL, &proc_locks_operations);
- 	return 0;
- }
---- a/fs/proc/Kconfig
-+++ b/fs/proc/Kconfig
-@@ -81,3 +81,8 @@ config PROC_CHILDREN
- 
- 	  Say Y if you are running any user-space software which takes benefit from
- 	  this interface. For example, rkt is such a piece of software.
-+
-+config PROC_STRIPPED
-+	default n
-+	depends on EXPERT
-+	bool "Strip non-essential /proc functionality to reduce code size"
---- a/fs/proc/consoles.c
-+++ b/fs/proc/consoles.c
-@@ -106,6 +106,9 @@ static const struct file_operations proc
- 
- static int __init proc_consoles_init(void)
- {
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return 0;
-+
- 	proc_create("consoles", 0, NULL, &proc_consoles_operations);
- 	return 0;
- }
---- a/fs/proc/proc_tty.c
-+++ b/fs/proc/proc_tty.c
-@@ -144,7 +144,10 @@ static const struct file_operations proc
- void proc_tty_register_driver(struct tty_driver *driver)
- {
- 	struct proc_dir_entry *ent;
--		
-+
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return;
-+
- 	if (!driver->driver_name || driver->proc_entry ||
- 	    !driver->ops->proc_fops)
- 		return;
-@@ -161,6 +164,9 @@ void proc_tty_unregister_driver(struct t
- {
- 	struct proc_dir_entry *ent;
- 
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return;
-+
- 	ent = driver->proc_entry;
- 	if (!ent)
- 		return;
-@@ -175,6 +181,9 @@ void proc_tty_unregister_driver(struct t
-  */
- void __init proc_tty_init(void)
- {
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return;
-+
- 	if (!proc_mkdir("tty", NULL))
- 		return;
- 	proc_mkdir("tty/ldisc", NULL);	/* Preserved: it's userspace visible */
---- a/include/net/snmp.h
-+++ b/include/net/snmp.h
-@@ -123,6 +123,21 @@ struct linux_xfrm_mib {
- #define DECLARE_SNMP_STAT(type, name)	\
- 	extern __typeof__(type) __percpu *name
- 
-+#ifdef CONFIG_PROC_STRIPPED
-+#define __SNMP_STATS_DUMMY(mib)	\
-+	do { (void) mib->mibs[0]; } while(0)
-+
-+#define __SNMP_INC_STATS(mib, field) __SNMP_STATS_DUMMY(mib)
-+#define SNMP_INC_STATS_ATOMIC_LONG(mib, field) __SNMP_STATS_DUMMY(mib)
-+#define SNMP_INC_STATS(mib, field) __SNMP_STATS_DUMMY(mib)
-+#define SNMP_DEC_STATS(mib, field) __SNMP_STATS_DUMMY(mib)
-+#define __SNMP_ADD_STATS(mib, field, addend) __SNMP_STATS_DUMMY(mib)
-+#define SNMP_ADD_STATS(mib, field, addend) __SNMP_STATS_DUMMY(mib)
-+#define SNMP_UPD_PO_STATS(mib, basefield, addend) __SNMP_STATS_DUMMY(mib)
-+#define __SNMP_UPD_PO_STATS(mib, basefield, addend) __SNMP_STATS_DUMMY(mib)
-+
-+#else
-+
- #define __SNMP_INC_STATS(mib, field)	\
- 			__this_cpu_inc(mib->mibs[field])
- 
-@@ -153,8 +168,9 @@ struct linux_xfrm_mib {
- 		__this_cpu_add(ptr[basefield##OCTETS], addend);	\
- 	} while (0)
- 
-+#endif
- 
--#if BITS_PER_LONG==32
-+#if (BITS_PER_LONG==32) && !defined(CONFIG_PROC_STRIPPED)
- 
- #define __SNMP_ADD_STATS64(mib, field, addend) 				\
- 	do {								\
---- a/ipc/msg.c
-+++ b/ipc/msg.c
-@@ -1061,6 +1061,9 @@ void __init msg_init(void)
- {
- 	msg_init_ns(&init_ipc_ns);
- 
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return;
-+
- 	ipc_init_proc_interface("sysvipc/msg",
- 				"       key      msqid perms      cbytes       qnum lspid lrpid   uid   gid  cuid  cgid      stime      rtime      ctime\n",
- 				IPC_MSG_IDS, sysvipc_msg_proc_show);
---- a/ipc/sem.c
-+++ b/ipc/sem.c
-@@ -205,6 +205,8 @@ void sem_exit_ns(struct ipc_namespace *n
- void __init sem_init(void)
- {
- 	sem_init_ns(&init_ipc_ns);
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return;
- 	ipc_init_proc_interface("sysvipc/sem",
- 				"       key      semid perms      nsems   uid   gid  cuid  cgid      otime      ctime\n",
- 				IPC_SEM_IDS, sysvipc_sem_proc_show);
---- a/ipc/shm.c
-+++ b/ipc/shm.c
-@@ -118,6 +118,8 @@ pure_initcall(ipc_ns_init);
- 
- void __init shm_init(void)
- {
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return;
- 	ipc_init_proc_interface("sysvipc/shm",
- #if BITS_PER_LONG <= 32
- 				"       key      shmid perms       size  cpid  lpid nattch   uid   gid  cuid  cgid      atime      dtime      ctime        rss       swap\n",
---- a/ipc/util.c
-+++ b/ipc/util.c
-@@ -121,6 +121,9 @@ void __init ipc_init_proc_interface(cons
- 	struct proc_dir_entry *pde;
- 	struct ipc_proc_iface *iface;
- 
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return;
-+
- 	iface = kmalloc(sizeof(*iface), GFP_KERNEL);
- 	if (!iface)
- 		return;
---- a/kernel/exec_domain.c
-+++ b/kernel/exec_domain.c
-@@ -41,6 +41,8 @@ static const struct file_operations exec
- 
- static int __init proc_execdomains_init(void)
- {
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return 0;
- 	proc_create("execdomains", 0, NULL, &execdomains_proc_fops);
- 	return 0;
- }
---- a/kernel/irq/proc.c
-+++ b/kernel/irq/proc.c
-@@ -326,6 +326,9 @@ void register_irq_proc(unsigned int irq,
- 	static DEFINE_MUTEX(register_lock);
- 	char name [MAX_NAMELEN];
- 
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED) && !IS_ENABLED(CONFIG_SMP))
-+		return;
-+
- 	if (!root_irq_dir || (desc->irq_data.chip == &no_irq_chip))
- 		return;
- 
-@@ -374,6 +377,9 @@ void unregister_irq_proc(unsigned int ir
- {
- 	char name [MAX_NAMELEN];
- 
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED) && !IS_ENABLED(CONFIG_SMP))
-+		return;
-+
- 	if (!root_irq_dir || !desc->dir)
- 		return;
- #ifdef CONFIG_SMP
-@@ -408,6 +414,9 @@ void init_irq_proc(void)
- 	unsigned int irq;
- 	struct irq_desc *desc;
- 
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED) && !IS_ENABLED(CONFIG_SMP))
-+		return;
-+
- 	/* create /proc/irq */
- 	root_irq_dir = proc_mkdir("irq", NULL);
- 	if (!root_irq_dir)
---- a/kernel/time/timer_list.c
-+++ b/kernel/time/timer_list.c
-@@ -400,6 +400,9 @@ static int __init init_timer_list_procfs
- {
- 	struct proc_dir_entry *pe;
- 
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return 0;
-+
- 	pe = proc_create("timer_list", 0400, NULL, &timer_list_fops);
- 	if (!pe)
- 		return -ENOMEM;
---- a/mm/vmalloc.c
-+++ b/mm/vmalloc.c
-@@ -2727,6 +2727,8 @@ static const struct file_operations proc
- 
- static int __init proc_vmalloc_init(void)
- {
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return 0;
- 	proc_create("vmallocinfo", S_IRUSR, NULL, &proc_vmalloc_operations);
- 	return 0;
- }
---- a/mm/vmstat.c
-+++ b/mm/vmstat.c
-@@ -1793,10 +1793,12 @@ static int __init setup_vmstat(void)
- 	cpu_notifier_register_done();
- #endif
- #ifdef CONFIG_PROC_FS
--	proc_create("buddyinfo", S_IRUGO, NULL, &fragmentation_file_operations);
--	proc_create("pagetypeinfo", 0400, NULL, &pagetypeinfo_file_ops);
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED)) {
-+		proc_create("buddyinfo", S_IRUGO, NULL, &fragmentation_file_operations);
-+		proc_create("pagetypeinfo", 0400, NULL, &pagetypeinfo_file_ops);
-+		proc_create("zoneinfo", S_IRUGO, NULL, &proc_zoneinfo_file_operations);
-+	}
- 	proc_create("vmstat", S_IRUGO, NULL, &proc_vmstat_file_operations);
--	proc_create("zoneinfo", S_IRUGO, NULL, &proc_zoneinfo_file_operations);
- #endif
- 	return 0;
- }
---- a/net/8021q/vlanproc.c
-+++ b/net/8021q/vlanproc.c
-@@ -127,6 +127,9 @@ void vlan_proc_cleanup(struct net *net)
- {
- 	struct vlan_net *vn = net_generic(net, vlan_net_id);
- 
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return;
-+
- 	if (vn->proc_vlan_conf)
- 		remove_proc_entry(name_conf, vn->proc_vlan_dir);
- 
-@@ -146,6 +149,9 @@ int __net_init vlan_proc_init(struct net
- {
- 	struct vlan_net *vn = net_generic(net, vlan_net_id);
- 
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return 0;
-+
- 	vn->proc_vlan_dir = proc_net_mkdir(net, name_root, net->proc_net);
- 	if (!vn->proc_vlan_dir)
- 		goto err;
---- a/net/core/net-procfs.c
-+++ b/net/core/net-procfs.c
-@@ -319,10 +319,12 @@ static int __net_init dev_proc_net_init(
- 
- 	if (!proc_create("dev", S_IRUGO, net->proc_net, &dev_seq_fops))
- 		goto out;
--	if (!proc_create("softnet_stat", S_IRUGO, net->proc_net,
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED) &&
-+		!proc_create("softnet_stat", S_IRUGO, net->proc_net,
- 			 &softnet_seq_fops))
- 		goto out_dev;
--	if (!proc_create("ptype", S_IRUGO, net->proc_net, &ptype_seq_fops))
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED) &&
-+		!proc_create("ptype", S_IRUGO, net->proc_net, &ptype_seq_fops))
- 		goto out_softnet;
- 
- 	if (wext_proc_init(net))
-@@ -331,9 +333,11 @@ static int __net_init dev_proc_net_init(
- out:
- 	return rc;
- out_ptype:
--	remove_proc_entry("ptype", net->proc_net);
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		remove_proc_entry("ptype", net->proc_net);
- out_softnet:
--	remove_proc_entry("softnet_stat", net->proc_net);
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		remove_proc_entry("softnet_stat", net->proc_net);
- out_dev:
- 	remove_proc_entry("dev", net->proc_net);
- 	goto out;
-@@ -343,8 +347,10 @@ static void __net_exit dev_proc_net_exit
- {
- 	wext_proc_exit(net);
- 
--	remove_proc_entry("ptype", net->proc_net);
--	remove_proc_entry("softnet_stat", net->proc_net);
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED)) {
-+		remove_proc_entry("ptype", net->proc_net);
-+		remove_proc_entry("softnet_stat", net->proc_net);
-+	}
- 	remove_proc_entry("dev", net->proc_net);
- }
- 
---- a/net/core/sock.c
-+++ b/net/core/sock.c
-@@ -3093,6 +3093,8 @@ static __net_initdata struct pernet_oper
- 
- static int __init proto_init(void)
- {
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return 0;
- 	return register_pernet_subsys(&proto_net_ops);
- }
- 
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -2677,10 +2677,12 @@ static const struct file_operations fib_
- 
- int __net_init fib_proc_init(struct net *net)
- {
--	if (!proc_create("fib_trie", S_IRUGO, net->proc_net, &fib_trie_fops))
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED) &&
-+		!proc_create("fib_trie", S_IRUGO, net->proc_net, &fib_trie_fops))
- 		goto out1;
- 
--	if (!proc_create("fib_triestat", S_IRUGO, net->proc_net,
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED) &&
-+		!proc_create("fib_triestat", S_IRUGO, net->proc_net,
- 			 &fib_triestat_fops))
- 		goto out2;
- 
-@@ -2690,17 +2692,21 @@ int __net_init fib_proc_init(struct net
- 	return 0;
- 
- out3:
--	remove_proc_entry("fib_triestat", net->proc_net);
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		remove_proc_entry("fib_triestat", net->proc_net);
- out2:
--	remove_proc_entry("fib_trie", net->proc_net);
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		remove_proc_entry("fib_trie", net->proc_net);
- out1:
- 	return -ENOMEM;
- }
- 
- void __net_exit fib_proc_exit(struct net *net)
- {
--	remove_proc_entry("fib_trie", net->proc_net);
--	remove_proc_entry("fib_triestat", net->proc_net);
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED)) {
-+		remove_proc_entry("fib_trie", net->proc_net);
-+		remove_proc_entry("fib_triestat", net->proc_net);
-+	}
- 	remove_proc_entry("route", net->proc_net);
- }
- 
---- a/net/ipv4/proc.c
-+++ b/net/ipv4/proc.c
-@@ -566,6 +566,9 @@ static __net_initdata struct pernet_oper
- 
- int __init ip_misc_proc_init(void)
- {
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return 0;
-+
- 	return register_pernet_subsys(&ip_proc_ops);
- }
- 
---- a/net/ipv4/route.c
-+++ b/net/ipv4/route.c
-@@ -423,6 +423,9 @@ static struct pernet_operations ip_rt_pr
- 
- static int __init ip_rt_proc_init(void)
- {
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return 0;
-+
- 	return register_pernet_subsys(&ip_rt_proc_ops);
- }
- 
--- a/target/linux/generic/hack-4.9/904-debloat_dma_buf.patch	2022-03-22 08:54:47.234464714 +0800
+++ b/target/linux/generic/hack-4.9/904-debloat_dma_buf.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,64 +0,0 @@
-From e3692cb2fcd5ba1244512a0f43b8118f65f1c375 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 8 Jul 2017 08:20:43 +0200
-Subject: debloat: dmabuf
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- drivers/base/Kconfig      |  2 +-
- drivers/dma-buf/Makefile  | 10 +++++++---
- drivers/dma-buf/dma-buf.c |  4 +++-
- kernel/sched/core.c       |  1 +
- 4 files changed, 12 insertions(+), 5 deletions(-)
-
---- a/drivers/base/Kconfig
-+++ b/drivers/base/Kconfig
-@@ -244,7 +244,7 @@ config SOC_BUS
- source "drivers/base/regmap/Kconfig"
- 
- config DMA_SHARED_BUFFER
--	bool
-+	tristate
- 	default n
- 	select ANON_INODES
- 	help
---- a/drivers/dma-buf/Makefile
-+++ b/drivers/dma-buf/Makefile
-@@ -1,3 +1,7 @@
--obj-y := dma-buf.o fence.o reservation.o seqno-fence.o fence-array.o
--obj-$(CONFIG_SYNC_FILE)		+= sync_file.o
--obj-$(CONFIG_SW_SYNC)		+= sw_sync.o sync_debug.o
-+obj-$(CONFIG_DMA_SHARED_BUFFER) := dma-shared-buffer.o
-+
-+dma-buf-objs-y := dma-buf.o fence.o reservation.o seqno-fence.o fence-array.o
-+dma-buf-objs-$(CONFIG_SYNC_FILE)		+= sync_file.o
-+dma-buf-objs-$(CONFIG_SW_SYNC)		+= sw_sync.o sync_debug.o
-+
-+dma-shared-buffer-objs :=  $(dma-buf-objs-y)
---- a/drivers/dma-buf/dma-buf.c
-+++ b/drivers/dma-buf/dma-buf.c
-@@ -34,6 +34,7 @@
- #include <linux/poll.h>
- #include <linux/reservation.h>
- #include <linux/mm.h>
-+#include <linux/module.h>
- 
- #include <uapi/linux/dma-buf.h>
- 
-@@ -977,4 +978,5 @@ static void __exit dma_buf_deinit(void)
- {
- 	dma_buf_uninit_debugfs();
- }
--__exitcall(dma_buf_deinit);
-+module_exit(dma_buf_deinit);
-+MODULE_LICENSE("GPL");
---- a/kernel/sched/core.c
-+++ b/kernel/sched/core.c
-@@ -2171,6 +2171,7 @@ int wake_up_state(struct task_struct *p,
- {
- 	return try_to_wake_up(p, state, 0);
- }
-+EXPORT_SYMBOL_GPL(wake_up_state);
- 
- /*
-  * This function clears the sched_dl_entity static params.
--- a/target/linux/generic/hack-4.9/910-kobject_uevent.patch	2022-03-22 08:54:47.235464716 +0800
+++ b/target/linux/generic/hack-4.9/910-kobject_uevent.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,32 +0,0 @@
-From 0d37e6edc09c99e683dd91ca0e83bbc0df8477b3 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sun, 16 Jul 2017 16:56:10 +0200
-Subject: lib: add uevent_next_seqnum()
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/linux/kobject.h |  5 +++++
- lib/kobject_uevent.c    | 37 +++++++++++++++++++++++++++++++++++++
- 2 files changed, 42 insertions(+)
-
---- a/lib/kobject_uevent.c
-+++ b/lib/kobject_uevent.c
-@@ -52,6 +52,18 @@ static const char *kobject_actions[] = {
- 	[KOBJ_OFFLINE] =	"offline",
- };
- 
-+u64 uevent_next_seqnum(void)
-+{
-+	u64 seq;
-+
-+	mutex_lock(&uevent_sock_mutex);
-+	seq = ++uevent_seqnum;
-+	mutex_unlock(&uevent_sock_mutex);
-+
-+	return seq;
-+}
-+EXPORT_SYMBOL_GPL(uevent_next_seqnum);
-+
- /**
-  * kobject_action_type - translate action string to numeric type
-  *
--- a/target/linux/generic/hack-4.9/911-kobject_add_broadcast_uevent.patch	2022-03-22 08:54:47.235464716 +0800
+++ b/target/linux/generic/hack-4.9/911-kobject_add_broadcast_uevent.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,76 +0,0 @@
-From 0d37e6edc09c99e683dd91ca0e83bbc0df8477b3 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sun, 16 Jul 2017 16:56:10 +0200
-Subject: lib: add uevent_next_seqnum()
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/linux/kobject.h |  5 +++++
- lib/kobject_uevent.c    | 37 +++++++++++++++++++++++++++++++++++++
- 2 files changed, 42 insertions(+)
-
---- a/include/linux/kobject.h
-+++ b/include/linux/kobject.h
-@@ -32,6 +32,8 @@
- #define UEVENT_NUM_ENVP			32	/* number of env pointers */
- #define UEVENT_BUFFER_SIZE		2048	/* buffer for the variables */
- 
-+struct sk_buff;
-+
- #ifdef CONFIG_UEVENT_HELPER
- /* path to the userspace helper executed on an event */
- extern char uevent_helper[];
-@@ -239,4 +241,7 @@ int add_uevent_var(struct kobj_uevent_en
- int kobject_action_type(const char *buf, size_t count,
- 			enum kobject_action *type);
- 
-+int broadcast_uevent(struct sk_buff *skb, __u32 pid, __u32 group,
-+		     gfp_t allocation);
-+
- #endif /* _KOBJECT_H_ */
---- a/lib/kobject_uevent.c
-+++ b/lib/kobject_uevent.c
-@@ -423,6 +423,43 @@ int add_uevent_var(struct kobj_uevent_en
- EXPORT_SYMBOL_GPL(add_uevent_var);
- 
- #if defined(CONFIG_NET)
-+int broadcast_uevent(struct sk_buff *skb, __u32 pid, __u32 group,
-+		     gfp_t allocation)
-+{
-+	struct uevent_sock *ue_sk;
-+	int err = 0;
-+
-+	/* send netlink message */
-+	mutex_lock(&uevent_sock_mutex);
-+	list_for_each_entry(ue_sk, &uevent_sock_list, list) {
-+		struct sock *uevent_sock = ue_sk->sk;
-+		struct sk_buff *skb2;
-+
-+		skb2 = skb_clone(skb, allocation);
-+		if (!skb2)
-+			break;
-+
-+		err = netlink_broadcast(uevent_sock, skb2, pid, group,
-+					allocation);
-+		if (err)
-+			break;
-+	}
-+	mutex_unlock(&uevent_sock_mutex);
-+
-+	kfree_skb(skb);
-+	return err;
-+}
-+#else
-+int broadcast_uevent(struct sk_buff *skb, __u32 pid, __u32 group,
-+		     gfp_t allocation)
-+{
-+	kfree_skb(skb);
-+	return 0;
-+}
-+#endif
-+EXPORT_SYMBOL_GPL(broadcast_uevent);
-+
-+#if defined(CONFIG_NET)
- static int uevent_net_init(struct net *net)
- {
- 	struct uevent_sock *ue_sk;
--- a/target/linux/generic/hack-4.9/921-always-create-console-node-in-initramfs.patch	2022-03-22 08:54:47.235464716 +0800
+++ b/target/linux/generic/hack-4.9/921-always-create-console-node-in-initramfs.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,40 +0,0 @@
-From 5d301596fdc72f6cb672f72eb3c66e7cddefb103 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 8 Jul 2017 08:26:02 +0200
-Subject: initramfs: always create console node
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- scripts/gen_initramfs_list.sh | 14 ++++++++++++++
- 1 file changed, 14 insertions(+)
-
---- a/scripts/gen_initramfs_list.sh
-+++ b/scripts/gen_initramfs_list.sh
-@@ -59,6 +59,18 @@ default_initramfs() {
- 	EOF
- }
- 
-+list_openwrt_initramfs() {
-+	:
-+}
-+
-+openwrt_initramfs() {
-+	# make sure that /dev/console exists
-+	cat <<-EOF >> ${output}
-+		dir /dev 0755 0 0
-+		nod /dev/console 0600 0 0 c 5 1
-+	EOF
-+}
-+
- filetype() {
- 	local argv1="$1"
- 
-@@ -180,6 +192,8 @@ dir_filelist() {
- 	if [  "$(echo "${dirlist}" | wc -l)" -gt 1 ]; then
- 		${dep_list}print_mtime "$1"
- 
-+		${dep_list}openwrt_initramfs
-+
- 		echo "${dirlist}" | \
- 		while read x; do
- 			${dep_list}parse ${x}
--- a/target/linux/generic/hack-4.9/930-crashlog.patch	2022-03-22 08:54:47.236464718 +0800
+++ b/target/linux/generic/hack-4.9/930-crashlog.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,338 +0,0 @@
-From 6b1ab74a9917012d0c559edc4ed299d9228ac89f Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 8 Jul 2017 08:26:47 +0200
-Subject: kernel: add the new 'crashlog' feature
-
-this tries to store kernel oops/panic logs in a fixed location in RAM to
-recover them available to user space using debugfs
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/linux/crashlog.h |  17 ++++
- init/Kconfig             |   4 +
- kernel/Makefile          |   1 +
- kernel/crashlog.c        | 213 +++++++++++++++++++++++++++++++++++++++++++++++
- kernel/module.c          |   3 +
- mm/bootmem.c             |   2 +
- mm/memblock.c            |   5 ++
- 7 files changed, 245 insertions(+)
- create mode 100644 include/linux/crashlog.h
- create mode 100644 kernel/crashlog.c
-
---- /dev/null
-+++ b/include/linux/crashlog.h
-@@ -0,0 +1,17 @@
-+#ifndef __CRASHLOG_H
-+#define __CRASHLOG_H
-+
-+#ifdef CONFIG_CRASHLOG
-+void crashlog_init_bootmem(struct bootmem_data *bdata);
-+void crashlog_init_memblock(phys_addr_t addr, phys_addr_t size);
-+#else
-+static inline void crashlog_init_bootmem(struct bootmem_data *bdata)
-+{
-+}
-+
-+static inline void crashlog_init_memblock(phys_addr_t addr, phys_addr_t size)
-+{
-+}
-+#endif
-+
-+#endif
---- a/init/Kconfig
-+++ b/init/Kconfig
-@@ -1298,6 +1298,10 @@ config RELAY
- 
- 	  If unsure, say N.
- 
-+config CRASHLOG
-+	bool "Crash logging"
-+	depends on (!NO_BOOTMEM || HAVE_MEMBLOCK)
-+
- config BLK_DEV_INITRD
- 	bool "Initial RAM filesystem and RAM disk (initramfs/initrd) support"
- 	depends on BROKEN || !FRV
---- a/kernel/Makefile
-+++ b/kernel/Makefile
-@@ -114,6 +114,7 @@ obj-$(CONFIG_TORTURE_TEST) += torture.o
- obj-$(CONFIG_MEMBARRIER) += membarrier.o
- 
- obj-$(CONFIG_HAS_IOMEM) += memremap.o
-+obj-$(CONFIG_CRASHLOG) += crashlog.o
- 
- $(obj)/configs.o: $(obj)/config_data.h
- 
---- /dev/null
-+++ b/kernel/crashlog.c
-@@ -0,0 +1,213 @@
-+/*
-+ * Crash information logger
-+ * Copyright (C) 2010 Felix Fietkau <nbd@nbd.name>
-+ *
-+ * Based on ramoops.c
-+ *   Copyright (C) 2010 Marco Stornelli <marco.stornelli@gmail.com>
-+ *
-+ * This program is free software; you can redistribute it and/or
-+ * modify it under the terms of the GNU General Public License
-+ * version 2 as published by the Free Software Foundation.
-+ *
-+ * This program is distributed in the hope that it will be useful, but
-+ * WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-+ * General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-+ * 02110-1301 USA
-+ *
-+ */
-+
-+#include <linux/module.h>
-+#include <linux/bootmem.h>
-+#include <linux/memblock.h>
-+#include <linux/debugfs.h>
-+#include <linux/crashlog.h>
-+#include <linux/kmsg_dump.h>
-+#include <linux/module.h>
-+#include <linux/pfn.h>
-+#include <linux/vmalloc.h>
-+#include <asm/io.h>
-+
-+#define CRASHLOG_PAGES	4
-+#define CRASHLOG_SIZE	(CRASHLOG_PAGES * PAGE_SIZE)
-+#define CRASHLOG_MAGIC	0xa1eedead
-+
-+/*
-+ * Start the log at 1M before the end of RAM, as some boot loaders like
-+ * to use the end of the RAM for stack usage and other things
-+ * If this fails, fall back to using the last part.
-+ */
-+#define CRASHLOG_OFFSET	(1024 * 1024)
-+
-+struct crashlog_data {
-+	u32 magic;
-+	u32 len;
-+	u8 data[];
-+};
-+
-+static struct debugfs_blob_wrapper crashlog_blob;
-+static unsigned long crashlog_addr = 0;
-+static struct crashlog_data *crashlog_buf;
-+static struct kmsg_dumper dump;
-+static bool first = true;
-+
-+extern struct list_head *crashlog_modules;
-+
-+static bool crashlog_set_addr(phys_addr_t addr, phys_addr_t size)
-+{
-+	/* Limit to lower 64 MB to avoid highmem */
-+	phys_addr_t limit = 64 * 1024 * 1024;
-+
-+	if (crashlog_addr)
-+		return false;
-+
-+	if (addr > limit)
-+		return false;
-+
-+	if (addr + size > limit)
-+		size = limit - addr;
-+
-+	crashlog_addr = addr;
-+
-+	if (addr + size > CRASHLOG_OFFSET)
-+		crashlog_addr += size - CRASHLOG_OFFSET;
-+
-+	return true;
-+}
-+
-+#ifndef CONFIG_NO_BOOTMEM
-+void __init crashlog_init_bootmem(bootmem_data_t *bdata)
-+{
-+	phys_addr_t start, end;
-+
-+	start = PFN_PHYS(bdata->node_low_pfn);
-+	end = PFN_PHYS(bdata->node_min_pfn);
-+	if (!crashlog_set_addr(start, end - start))
-+		return;
-+
-+	if (reserve_bootmem(crashlog_addr, CRASHLOG_SIZE, BOOTMEM_EXCLUSIVE) < 0) {
-+		printk("Crashlog failed to allocate RAM at address 0x%lx\n",
-+		       crashlog_addr);
-+		crashlog_addr = 0;
-+	}
-+}
-+#endif
-+
-+#ifdef CONFIG_HAVE_MEMBLOCK
-+void __init_memblock crashlog_init_memblock(phys_addr_t addr, phys_addr_t size)
-+{
-+	if (!crashlog_set_addr(addr, size))
-+		return;
-+
-+	if (memblock_reserve(crashlog_addr, CRASHLOG_SIZE)) {
-+		printk("Crashlog failed to allocate RAM at address 0x%lx\n",
-+		       crashlog_addr);
-+		crashlog_addr = 0;
-+	}
-+}
-+#endif
-+
-+static void __init crashlog_copy(void)
-+{
-+	if (crashlog_buf->magic != CRASHLOG_MAGIC)
-+		return;
-+
-+	if (!crashlog_buf->len || crashlog_buf->len >
-+	    CRASHLOG_SIZE - sizeof(*crashlog_buf))
-+		return;
-+
-+	crashlog_blob.size = crashlog_buf->len;
-+	crashlog_blob.data = kmemdup(crashlog_buf->data,
-+		crashlog_buf->len, GFP_KERNEL);
-+
-+	debugfs_create_blob("crashlog", 0700, NULL, &crashlog_blob);
-+}
-+
-+static int get_maxlen(void)
-+{
-+	return CRASHLOG_SIZE - sizeof(*crashlog_buf) - crashlog_buf->len;
-+}
-+
-+static void crashlog_printf(const char *fmt, ...)
-+{
-+	va_list args;
-+	int len = get_maxlen();
-+
-+	if (!len)
-+		return;
-+
-+	va_start(args, fmt);
-+	crashlog_buf->len += vscnprintf(
-+		&crashlog_buf->data[crashlog_buf->len],
-+		len, fmt, args);
-+	va_end(args);
-+}
-+
-+static void crashlog_do_dump(struct kmsg_dumper *dumper,
-+		enum kmsg_dump_reason reason)
-+{
-+	struct timeval tv;
-+	struct module *m;
-+	char *buf;
-+	size_t len;
-+
-+	if (!first)
-+		crashlog_printf("\n===================================\n");
-+
-+	do_gettimeofday(&tv);
-+	crashlog_printf("Time: %lu.%lu\n",
-+		(long)tv.tv_sec, (long)tv.tv_usec);
-+
-+	if (first) {
-+		crashlog_printf("Modules:");
-+		list_for_each_entry(m, crashlog_modules, list) {
-+			crashlog_printf("\t%s@%p+%x", m->name,
-+			m->core_layout.base, m->core_layout.size,
-+			m->init_layout.base, m->init_layout.size);
-+		}
-+		crashlog_printf("\n");
-+		first = false;
-+	}
-+
-+	buf = (char *)&crashlog_buf->data[crashlog_buf->len];
-+
-+	kmsg_dump_get_buffer(dumper, true, buf, get_maxlen(), &len);
-+
-+	crashlog_buf->len += len;
-+}
-+
-+
-+int __init crashlog_init_fs(void)
-+{
-+	struct page *pages[CRASHLOG_PAGES];
-+	pgprot_t prot;
-+	int i;
-+
-+	if (!crashlog_addr) {
-+		printk("No memory allocated for crashlog\n");
-+		return -ENOMEM;
-+	}
-+
-+	printk("Crashlog allocated RAM at address 0x%lx\n", (unsigned long) crashlog_addr);
-+	for (i = 0; i < CRASHLOG_PAGES; i++)
-+		pages[i] = pfn_to_page((crashlog_addr >> PAGE_SHIFT) + i);
-+
-+	prot = pgprot_writecombine(PAGE_KERNEL);
-+	crashlog_buf = vmap(pages, CRASHLOG_PAGES, VM_MAP, prot);
-+
-+	crashlog_copy();
-+
-+	crashlog_buf->magic = CRASHLOG_MAGIC;
-+	crashlog_buf->len = 0;
-+
-+	dump.max_reason = KMSG_DUMP_OOPS;
-+	dump.dump = crashlog_do_dump;
-+	kmsg_dump_register(&dump);
-+
-+	return 0;
-+}
-+module_init(crashlog_init_fs);
---- a/kernel/module.c
-+++ b/kernel/module.c
-@@ -253,6 +253,9 @@ static void mod_update_bounds(struct mod
- #ifdef CONFIG_KGDB_KDB
- struct list_head *kdb_modules = &modules; /* kdb needs the list of modules */
- #endif /* CONFIG_KGDB_KDB */
-+#ifdef CONFIG_CRASHLOG
-+struct list_head *crashlog_modules = &modules;
-+#endif
- 
- static void module_assert_mutex(void)
- {
---- a/mm/bootmem.c
-+++ b/mm/bootmem.c
-@@ -14,6 +14,7 @@
- #include <linux/export.h>
- #include <linux/kmemleak.h>
- #include <linux/range.h>
-+#include <linux/crashlog.h>
- #include <linux/bug.h>
- #include <linux/io.h>
- #include <linux/bootmem.h>
-@@ -174,6 +175,7 @@ static unsigned long __init free_all_boo
- 	if (!bdata->node_bootmem_map)
- 		return 0;
- 
-+	crashlog_init_bootmem(bdata);
- 	map = bdata->node_bootmem_map;
- 	start = bdata->node_min_pfn;
- 	end = bdata->node_low_pfn;
---- a/mm/memblock.c
-+++ b/mm/memblock.c
-@@ -19,6 +19,7 @@
- #include <linux/debugfs.h>
- #include <linux/seq_file.h>
- #include <linux/memblock.h>
-+#include <linux/crashlog.h>
- 
- #include <asm/sections.h>
- #include <linux/io.h>
-@@ -495,6 +496,8 @@ static void __init_memblock memblock_ins
- 	memblock_set_region_node(rgn, nid);
- 	type->cnt++;
- 	type->total_size += size;
-+	if (type == &memblock.memory)
-+		crashlog_init_memblock(base, size);
- }
- 
- /**
-@@ -534,6 +537,8 @@ int __init_memblock memblock_add_range(s
- 		type->regions[0].flags = flags;
- 		memblock_set_region_node(&type->regions[0], nid);
- 		type->total_size = size;
-+		if (type == &memblock.memory)
-+			crashlog_init_memblock(base, size);
- 		return 0;
- 	}
- repeat:
--- a/target/linux/generic/hack-4.9/950-net-patch-linux-kernel-to-support-shortcut-fe.patch	2022-03-22 08:54:47.236464718 +0800
+++ b/target/linux/generic/hack-4.9/950-net-patch-linux-kernel-to-support-shortcut-fe.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,140 +0,0 @@
-From 5c43b9811dd88dd2d18d88a253212474bb665896 Mon Sep 17 00:00:00 2001
-From: Xiaoping Fan <xfan@codeaurora.org>
-Date: Fri, 26 Feb 2016 15:01:53 -0800
-Subject: [PATCH 1/3] net: patch linux kernel to support shortcut-fe
-
-1, add a new flag 'fast_forwarded' in skb structure.
-2, put a hook in '__netif_receive_skb_core' to
-   deliver packet to shortcut-fe.
-
-Change-Id: Icaa7c172a06df1c3bc89ff89814d1136772fe217
-Signed-off-by: Xiaoping Fan <xfan@codeaurora.org>
-
-msm: ipq806x: exporting TCP sequence check parameters
-
-This is for use in NSS connection manager.
-
-Change-Id: I01d30c0ab552308c439353c0d51d3d0ab3aa7699
-Signed-off-by: Pamidipati, Vijay <vpamidip@codeaurora.org>
-Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
----
- include/linux/skbuff.h                 |  3 +++
- net/Kconfig                            |  3 +++
- net/core/dev.c                         | 25 +++++++++++++++++++++++++
- net/netfilter/nf_conntrack_proto_tcp.c | 10 ++++++++++
- 4 files changed, 41 insertions(+)
-
-diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
-index 9a0c945..56f4007 100644
---- a/include/linux/skbuff.h
-+++ b/include/linux/skbuff.h
-@@ -738,6 +738,9 @@ struct sk_buff {
- #endif
- 	__u8			ipvs_property:1;
- 	__u8			inner_protocol_type:1;
-+#ifdef CONFIG_SHORTCUT_FE
-+	__u8			fast_forwarded:1;
-+#endif
- 	__u8			remcsum_offload:1;
- #ifdef CONFIG_NET_SWITCHDEV
- 	__u8			offload_fwd_mark:1;
-diff --git a/net/Kconfig b/net/Kconfig
-index b4621e1..6ba72cf 100644
---- a/net/Kconfig
-+++ b/net/Kconfig
-@@ -444,3 +444,6 @@ config HAVE_CBPF_JIT
- # Extended BPF JIT (eBPF)
- config HAVE_EBPF_JIT
- 	bool
-+
-+config SHORTCUT_FE
-+	bool "Enables kernel network stack path for Shortcut Forwarding Engine"
-diff --git a/net/core/dev.c b/net/core/dev.c
-index ca39cd2..74cd937 100644
---- a/net/core/dev.c
-+++ b/net/core/dev.c
-@@ -2929,8 +2929,17 @@ static int xmit_one(struct sk_buff *skb, struct net_device *dev,
- 	unsigned int len;
- 	int rc;
- 
-+#ifdef CONFIG_SHORTCUT_FE
-+	/* If this skb has been fast forwarded then we don't want it to
-+	 * go to any taps (by definition we're trying to bypass them).
-+	 */
-+	if (!skb->fast_forwarded) {
-+#endif
- 	if (!list_empty(&ptype_all) || !list_empty(&dev->ptype_all))
- 		dev_queue_xmit_nit(skb, dev);
-+#ifdef CONFIG_SHORTCUT_FE
-+	}
-+#endif
- 
- #ifdef CONFIG_ETHERNET_PACKET_MANGLE
- 	if (!dev->eth_mangle_tx ||
-@@ -4061,6 +4070,11 @@ void netdev_rx_handler_unregister(struct net_device *dev)
- }
- EXPORT_SYMBOL_GPL(netdev_rx_handler_unregister);
- 
-+#ifdef CONFIG_SHORTCUT_FE
-+int (*fast_nat_recv)(struct sk_buff *skb) __rcu __read_mostly;
-+EXPORT_SYMBOL_GPL(fast_nat_recv);
-+#endif
-+
- /*
-  * Limit the use of PFMEMALLOC reserves to those protocols that implement
-  * the special handling of PFMEMALLOC skbs.
-@@ -4108,6 +4122,9 @@ static int __netif_receive_skb_core(struct sk_buff *skb, bool pfmemalloc)
- 	bool deliver_exact = false;
- 	int ret = NET_RX_DROP;
- 	__be16 type;
-+#ifdef CONFIG_SHORTCUT_FE
-+	int (*fast_recv)(struct sk_buff *skb);
-+#endif
- 
- 	net_timestamp_check(!netdev_tstamp_prequeue, skb);
- 
-@@ -4134,6 +4151,14 @@ static int __netif_receive_skb_core(struct sk_buff *skb, bool pfmemalloc)
- 			goto out;
- 	}
- 
-+#ifdef CONFIG_SHORTCUT_FE
-+	fast_recv = rcu_dereference(fast_nat_recv);
-+	if (fast_recv && fast_recv(skb)) {
-+		ret = NET_RX_SUCCESS;
-+		goto out;
-+	}
-+#endif
-+
- #ifdef CONFIG_NET_CLS_ACT
- 	if (skb->tc_verd & TC_NCLS) {
- 		skb->tc_verd = CLR_TC_NCLS(skb->tc_verd);
-diff --git a/net/netfilter/nf_conntrack_proto_tcp.c b/net/netfilter/nf_conntrack_proto_tcp.c
-index f24b626..4581481 100644
---- a/net/netfilter/nf_conntrack_proto_tcp.c
-+++ b/net/netfilter/nf_conntrack_proto_tcp.c
-@@ -34,12 +34,22 @@
- #include <net/netfilter/ipv6/nf_conntrack_ipv6.h>
- 
- /* Do not check the TCP window for incoming packets  */
-+#ifdef CONFIG_SHORTCUT_FE
-+int nf_ct_tcp_no_window_check __read_mostly = 0;
-+EXPORT_SYMBOL_GPL(nf_ct_tcp_no_window_check);
-+#else
- static int nf_ct_tcp_no_window_check __read_mostly = 1;
-+#endif
- 
- /* "Be conservative in what you do,
-     be liberal in what you accept from others."
-     If it's non-zero, we mark only out of window RST segments as INVALID. */
-+#ifdef CONFIG_SHORTCUT_FE
-+int nf_ct_tcp_be_liberal __read_mostly = 0;
-+EXPORT_SYMBOL_GPL(nf_ct_tcp_be_liberal);
-+#else
- static int nf_ct_tcp_be_liberal __read_mostly = 0;
-+#endif
- 
- /* If it is set to zero, we disable picking up already established
-    connections. */
--- 
-2.7.4
-
--- a/target/linux/generic/hack-4.9/951-bridge-Add-new-bridge-APIs-needed-for-network-HW-acc.patch	2022-03-22 08:54:47.237464719 +0800
+++ b/target/linux/generic/hack-4.9/951-bridge-Add-new-bridge-APIs-needed-for-network-HW-acc.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,74 +0,0 @@
-From cdabe46cd62d22266aed7fdae36f72a36e3558e7 Mon Sep 17 00:00:00 2001
-From: Murat Sezgin <msezgin@codeaurora.org>
-Date: Tue, 25 Nov 2014 17:22:24 -0800
-Subject: [PATCH 2/3] bridge: Add new bridge APIs needed for network HW
- acceleration
-
-Bridge acceleration hardware needs to perform certain operations,
- currently unsupported by the existing bridge code:
-
-  ** cut **
-
- *update bridge interface statistics from outside the bridge code:
-  once acceleration is enabled on a connection, packets will not flow
-  through the host CPU, so we need the hardware accelerator driver to
-  maintain the statistics on the host and update them and add whatever
-  flows through the hardware.
- These change adds the corresponding functions, and make it available
- to other through EXPORT_SYMBOLS().
-
-Change-Id: I67afb325796004053897d9916e2df91827b65139
-Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
----
- include/linux/if_bridge.h |  1 +
- net/bridge/br_if.c        | 25 +++++++++++++++++++++++++
- 2 files changed, 26 insertions(+)
-
-diff --git a/include/linux/if_bridge.h b/include/linux/if_bridge.h
-index 0911c8c..4473f62 100644
---- a/include/linux/if_bridge.h
-+++ b/include/linux/if_bridge.h
-@@ -52,6 +52,7 @@ struct br_ip_list {
- #define BR_DEFAULT_AGEING_TIME	(300 * HZ)
- 
- extern void brioctl_set(int (*ioctl_hook)(struct net *, unsigned int, void __user *));
-+extern void br_dev_update_stats(struct net_device *dev, struct rtnl_link_stats64 *nlstats);
- 
- typedef int br_should_route_hook_t(struct sk_buff *skb);
- extern br_should_route_hook_t __rcu *br_should_route_hook;
-diff --git a/net/bridge/br_if.c b/net/bridge/br_if.c
-index ed0dd33..342b2d9 100644
---- a/net/bridge/br_if.c
-+++ b/net/bridge/br_if.c
-@@ -655,3 +655,28 @@ void br_port_flags_change(struct net_bridge_port *p, unsigned long mask)
- 	if (mask & BR_AUTO_MASK)
- 		nbp_update_port_count(br);
- }
-+
-+/* Update bridge statistics for bridge packets processed by offload engines */
-+void br_dev_update_stats(struct net_device *dev, struct rtnl_link_stats64 *nlstats)
-+{
-+		struct net_bridge *br;
-+		struct pcpu_sw_netstats *stats;
-+
-+		/*
-+		 * Is this a bridge?
-+		 */
-+		if (!(dev->priv_flags & IFF_EBRIDGE)) {
-+			return;
-+		}
-+
-+		br = netdev_priv(dev);
-+		stats = this_cpu_ptr(br->stats);
-+
-+		u64_stats_update_begin(&stats->syncp);
-+		stats->rx_packets += nlstats->rx_packets;
-+		stats->rx_bytes += nlstats->rx_bytes;
-+		stats->tx_packets += nlstats->tx_packets;
-+		stats->tx_bytes += nlstats->tx_bytes;
-+		u64_stats_update_end(&stats->syncp);
-+}
-+EXPORT_SYMBOL_GPL(br_dev_update_stats);
--- 
-2.7.4
-
--- a/target/linux/generic/hack-4.9/952-net-conntrack-events-support-multiple-registrant.patch	2022-03-22 08:54:47.237464719 +0800
+++ b/target/linux/generic/hack-4.9/952-net-conntrack-events-support-multiple-registrant.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,345 +0,0 @@
-From 56294a39f14712f868a495f28be6b2e92f0a48c6 Mon Sep 17 00:00:00 2001
-From: Zhi Chen <zhichen@codeaurora.org>
-Date: Tue, 13 Jan 2015 14:28:18 -0800
-Subject: [PATCH 3/3] net: conntrack events, support multiple registrant
-
-Merging this patch from kernel 3.4:
-This was supported by old (.28) kernel versions but removed
-because of it's overhead.
-But we need this feature for NA connection manager. Both ipv4
-and ipv6 modules needs to register themselves to ct events.
-
-Change-Id: Iebfb254590fb594f5baf232f849d1b7ae45ef757
-Signed-off-by: Zhi Chen <zhichen@codeaurora.org>
----
- include/net/netfilter/nf_conntrack_ecache.h | 13 +++-
- include/net/netns/conntrack.h               |  4 ++
- net/netfilter/Kconfig                       |  8 +++
- net/netfilter/nf_conntrack_core.c           |  4 ++
- net/netfilter/nf_conntrack_ecache.c         | 92 +++++++++++++++++++++++++++++
- net/netfilter/nf_conntrack_netlink.c        | 19 ++++++
- 6 files changed, 139 insertions(+), 1 deletion(-)
-
-diff --git a/include/net/netfilter/nf_conntrack_ecache.h b/include/net/netfilter/nf_conntrack_ecache.h
-index 12d967b..c2b98b6 100644
---- a/include/net/netfilter/nf_conntrack_ecache.h
-+++ b/include/net/netfilter/nf_conntrack_ecache.h
-@@ -70,6 +70,10 @@ struct nf_ct_event {
- 	int report;
- };
- 
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+extern int nf_conntrack_register_notifier(struct net *net, struct notifier_block *nb);
-+extern int nf_conntrack_unregister_notifier(struct net *net, struct notifier_block *nb);
-+#else
- struct nf_ct_event_notifier {
- 	int (*fcn)(unsigned int events, struct nf_ct_event *item);
- };
-@@ -78,6 +82,7 @@ int nf_conntrack_register_notifier(struct net *net,
- 				   struct nf_ct_event_notifier *nb);
- void nf_conntrack_unregister_notifier(struct net *net,
- 				      struct nf_ct_event_notifier *nb);
-+#endif
- 
- void nf_ct_deliver_cached_events(struct nf_conn *ct);
- int nf_conntrack_eventmask_report(unsigned int eventmask, struct nf_conn *ct,
-@@ -86,11 +91,13 @@ int nf_conntrack_eventmask_report(unsigned int eventmask, struct nf_conn *ct,
- static inline void
- nf_conntrack_event_cache(enum ip_conntrack_events event, struct nf_conn *ct)
- {
--	struct net *net = nf_ct_net(ct);
- 	struct nf_conntrack_ecache *e;
-+#ifndef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+	struct net *net = nf_ct_net(ct);
- 
- 	if (!rcu_access_pointer(net->ct.nf_conntrack_event_cb))
- 		return;
-+#endif
- 
- 	e = nf_ct_ecache_find(ct);
- 	if (e == NULL)
-@@ -103,10 +110,12 @@ static inline int
- nf_conntrack_event_report(enum ip_conntrack_events event, struct nf_conn *ct,
- 			  u32 portid, int report)
- {
-+#ifndef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
- 	const struct net *net = nf_ct_net(ct);
- 
- 	if (!rcu_access_pointer(net->ct.nf_conntrack_event_cb))
- 		return 0;
-+#endif
- 
- 	return nf_conntrack_eventmask_report(1 << event, ct, portid, report);
- }
-@@ -114,10 +123,12 @@ nf_conntrack_event_report(enum ip_conntrack_events event, struct nf_conn *ct,
- static inline int
- nf_conntrack_event(enum ip_conntrack_events event, struct nf_conn *ct)
- {
-+#ifndef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
- 	const struct net *net = nf_ct_net(ct);
- 
- 	if (!rcu_access_pointer(net->ct.nf_conntrack_event_cb))
- 		return 0;
-+#endif
- 
- 	return nf_conntrack_eventmask_report(1 << event, ct, 0, 0);
- }
-diff --git a/include/net/netns/conntrack.h b/include/net/netns/conntrack.h
-index e469e85..1d31db8 100644
---- a/include/net/netns/conntrack.h
-+++ b/include/net/netns/conntrack.h
-@@ -86,7 +86,11 @@ struct netns_ct {
- 
- 	struct ct_pcpu __percpu *pcpu_lists;
- 	struct ip_conntrack_stat __percpu *stat;
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+	struct atomic_notifier_head nf_conntrack_chain;
-+#else
- 	struct nf_ct_event_notifier __rcu *nf_conntrack_event_cb;
-+#endif
- 	struct nf_exp_event_notifier __rcu *nf_expect_event_cb;
- 	struct nf_ip_net	nf_ct_proto;
- #if defined(CONFIG_NF_CONNTRACK_LABELS)
-diff --git a/net/netfilter/Kconfig b/net/netfilter/Kconfig
-index 63073be..08d7aab 100644
---- a/net/netfilter/Kconfig
-+++ b/net/netfilter/Kconfig
-@@ -136,6 +136,14 @@ config NF_CONNTRACK_TIMEOUT
- 
- 	  If unsure, say `N'.
- 
-+config NF_CONNTRACK_CHAIN_EVENTS
-+	bool "Register multiple callbacks to ct events"
-+	depends on NF_CONNTRACK_EVENTS
-+	help
-+	  Support multiple registrations.
-+
-+	  If unsure, say `N'.
-+
- config NF_CONNTRACK_TIMESTAMP
- 	bool  'Connection tracking timestamping'
- 	depends on NETFILTER_ADVANCED
-diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c
-index 6bd1508..9b81c7c 100644
---- a/net/netfilter/nf_conntrack_core.c
-+++ b/net/netfilter/nf_conntrack_core.c
-@@ -1998,6 +1998,10 @@ int nf_conntrack_init_net(struct net *net)
- 	ret = nf_conntrack_proto_pernet_init(net);
- 	if (ret < 0)
- 		goto err_proto;
-+
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+	ATOMIC_INIT_NOTIFIER_HEAD(&net->ct.nf_conntrack_chain);
-+#endif
- 	return 0;
- 
- err_proto:
-diff --git a/net/netfilter/nf_conntrack_ecache.c b/net/netfilter/nf_conntrack_ecache.c
-index da9df2d..e0e2a8f 100644
---- a/net/netfilter/nf_conntrack_ecache.c
-+++ b/net/netfilter/nf_conntrack_ecache.c
-@@ -18,6 +18,9 @@
- #include <linux/stddef.h>
- #include <linux/err.h>
- #include <linux/percpu.h>
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+#include <linux/notifier.h>
-+#endif
- #include <linux/kernel.h>
- #include <linux/netdevice.h>
- #include <linux/slab.h>
-@@ -117,6 +120,38 @@ static void ecache_work(struct work_struct *work)
- 		schedule_delayed_work(&ctnet->ecache_dwork, delay);
- }
- 
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+int
-+nf_conntrack_eventmask_report(unsigned int eventmask,
-+			      struct nf_conn *ct,
-+			      u32 portid,
-+			      int report)
-+{
-+	struct nf_conntrack_ecache *e;
-+	struct net *net = nf_ct_net(ct);
-+
-+	e = nf_ct_ecache_find(ct);
-+	if (e == NULL)
-+		return 0;
-+
-+	if (nf_ct_is_confirmed(ct)) {
-+		struct nf_ct_event item = {
-+			.ct = ct,
-+			.portid	= e->portid ? e->portid : portid,
-+			.report = report
-+		};
-+		/* This is a resent of a destroy event? If so, skip missed */
-+		unsigned long missed = e->portid ? 0 : e->missed;
-+
-+		if (!((eventmask | missed) & e->ctmask))
-+			return 0;
-+
-+		atomic_notifier_call_chain(&net->ct.nf_conntrack_chain, eventmask | missed, &item);
-+	}
-+
-+	return 0;
-+}
-+#else
- int nf_conntrack_eventmask_report(unsigned int eventmask, struct nf_conn *ct,
- 				  u32 portid, int report)
- {
-@@ -171,10 +206,52 @@ int nf_conntrack_eventmask_report(unsigned int eventmask, struct nf_conn *ct,
- 	rcu_read_unlock();
- 	return ret;
- }
-+#endif
- EXPORT_SYMBOL_GPL(nf_conntrack_eventmask_report);
- 
- /* deliver cached events and clear cache entry - must be called with locally
-  * disabled softirqs */
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+void nf_ct_deliver_cached_events(struct nf_conn *ct)
-+{
-+	unsigned long events, missed;
-+	struct nf_conntrack_ecache *e;
-+	struct nf_ct_event item;
-+	struct net *net = nf_ct_net(ct);
-+
-+	e = nf_ct_ecache_find(ct);
-+	if (e == NULL)
-+		return;
-+
-+	events = xchg(&e->cache, 0);
-+
-+	if (!nf_ct_is_confirmed(ct) || nf_ct_is_dying(ct) || !events)
-+		return;
-+
-+	/* We make a copy of the missed event cache without taking
-+	 * the lock, thus we may send missed events twice. However,
-+	 * this does not harm and it happens very rarely. */
-+	missed = e->missed;
-+
-+	if (!((events | missed) & e->ctmask))
-+		return;
-+
-+	item.ct = ct;
-+	item.portid = 0;
-+	item.report = 0;
-+
-+	atomic_notifier_call_chain(&net->ct.nf_conntrack_chain,
-+			events | missed,
-+			&item);
-+
-+	if (likely(!missed))
-+		return;
-+
-+	spin_lock_bh(&ct->lock);
-+		e->missed &= ~missed;
-+	spin_unlock_bh(&ct->lock);
-+}
-+#else
- void nf_ct_deliver_cached_events(struct nf_conn *ct)
- {
- 	struct net *net = nf_ct_net(ct);
-@@ -225,6 +302,7 @@ void nf_ct_deliver_cached_events(struct nf_conn *ct)
- out_unlock:
- 	rcu_read_unlock();
- }
-+#endif
- EXPORT_SYMBOL_GPL(nf_ct_deliver_cached_events);
- 
- void nf_ct_expect_event_report(enum ip_conntrack_expect_events event,
-@@ -257,6 +335,12 @@ void nf_ct_expect_event_report(enum ip_conntrack_expect_events event,
- 	rcu_read_unlock();
- }
- 
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+int nf_conntrack_register_notifier(struct net *net, struct notifier_block *nb)
-+{
-+        return atomic_notifier_chain_register(&net->ct.nf_conntrack_chain, nb);
-+}
-+#else
- int nf_conntrack_register_notifier(struct net *net,
- 				   struct nf_ct_event_notifier *new)
- {
-@@ -277,8 +361,15 @@ int nf_conntrack_register_notifier(struct net *net,
- 	mutex_unlock(&nf_ct_ecache_mutex);
- 	return ret;
- }
-+#endif
- EXPORT_SYMBOL_GPL(nf_conntrack_register_notifier);
- 
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+int nf_conntrack_unregister_notifier(struct net *net, struct notifier_block *nb)
-+{
-+	return atomic_notifier_chain_unregister(&net->ct.nf_conntrack_chain, nb);
-+}
-+#else
- void nf_conntrack_unregister_notifier(struct net *net,
- 				      struct nf_ct_event_notifier *new)
- {
-@@ -291,6 +382,7 @@ void nf_conntrack_unregister_notifier(struct net *net,
- 	RCU_INIT_POINTER(net->ct.nf_conntrack_event_cb, NULL);
- 	mutex_unlock(&nf_ct_ecache_mutex);
- }
-+#endif
- EXPORT_SYMBOL_GPL(nf_conntrack_unregister_notifier);
- 
- int nf_ct_expect_register_notifier(struct net *net,
-diff --git a/net/netfilter/nf_conntrack_netlink.c b/net/netfilter/nf_conntrack_netlink.c
-index 04111c1..8c741f7 100644
---- a/net/netfilter/nf_conntrack_netlink.c
-+++ b/net/netfilter/nf_conntrack_netlink.c
-@@ -28,6 +28,11 @@
- #include <linux/netlink.h>
- #include <linux/spinlock.h>
- #include <linux/interrupt.h>
-+
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+#include <linux/notifier.h>
-+#endif
-+
- #include <linux/slab.h>
- 
- #include <linux/netfilter.h>
-@@ -615,14 +620,22 @@ static size_t ctnetlink_nlmsg_size(const struct nf_conn *ct)
- 	       ;
- }
- 
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+static int ctnetlink_conntrack_event(struct notifier_block *this,
-+                           unsigned long events, void *ptr)
-+#else
- static int
- ctnetlink_conntrack_event(unsigned int events, struct nf_ct_event *item)
-+#endif
- {
- 	const struct nf_conntrack_zone *zone;
- 	struct net *net;
- 	struct nlmsghdr *nlh;
- 	struct nfgenmsg *nfmsg;
- 	struct nlattr *nest_parms;
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+	struct nf_ct_event *item = (struct nf_ct_event *)ptr;
-+#endif
- 	struct nf_conn *ct = item->ct;
- 	struct sk_buff *skb;
- 	unsigned int type;
-@@ -3260,9 +3273,15 @@ static int ctnetlink_stat_exp_cpu(struct net *net, struct sock *ctnl,
- }
- 
- #ifdef CONFIG_NF_CONNTRACK_EVENTS
-+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-+static struct notifier_block ctnl_notifier = {
-+	.notifier_call = ctnetlink_conntrack_event,
-+};
-+#else
- static struct nf_ct_event_notifier ctnl_notifier = {
- 	.fcn = ctnetlink_conntrack_event,
- };
-+#endif
- 
- static struct nf_exp_event_notifier ctnl_notifier_exp = {
- 	.fcn = ctnetlink_expect_event,
--- 
-2.7.4
-
--- a/target/linux/generic/pending-3.18/001-mtdsplit_backport.patch	2022-03-22 08:54:47.246464734 +0800
+++ b/target/linux/generic/pending-3.18/001-mtdsplit_backport.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,142 +0,0 @@
---- a/drivers/mtd/mtdsplit/mtdsplit_brnimage.c
-+++ b/drivers/mtd/mtdsplit/mtdsplit_brnimage.c
-@@ -27,7 +27,7 @@
- #define BRNIMAGE_MAX_OVERHEAD	(BRNIMAGE_ALIGN_BYTES + BRNIMAGE_FOOTER_SIZE)
- 
- static int mtdsplit_parse_brnimage(struct mtd_info *master,
--				const struct mtd_partition **pparts,
-+				struct mtd_partition **pparts,
- 				struct mtd_part_parser_data *data)
- {
- 	struct mtd_partition *parts;
---- a/drivers/mtd/mtdsplit/mtdsplit_eva.c
-+++ b/drivers/mtd/mtdsplit/mtdsplit_eva.c
-@@ -29,7 +29,7 @@ struct eva_image_header {
- };
- 
- static int mtdsplit_parse_eva(struct mtd_info *master,
--				const struct mtd_partition **pparts,
-+				struct mtd_partition **pparts,
- 				struct mtd_part_parser_data *data)
- {
- 	struct mtd_partition *parts;
---- a/drivers/mtd/mtdsplit/mtdsplit_fit.c
-+++ b/drivers/mtd/mtdsplit/mtdsplit_fit.c
-@@ -45,8 +45,7 @@ struct fdt_header {
- };
- 
- static int
--mtdsplit_fit_parse(struct mtd_info *mtd,
--		   const struct mtd_partition **pparts,
-+mtdsplit_fit_parse(struct mtd_info *mtd, struct mtd_partition **pparts,
- 	           struct mtd_part_parser_data *data)
- {
- 	struct fdt_header hdr;
---- a/drivers/mtd/mtdsplit/mtdsplit_lzma.c
-+++ b/drivers/mtd/mtdsplit/mtdsplit_lzma.c
-@@ -28,7 +28,7 @@ struct lzma_header {
- };
- 
- static int mtdsplit_parse_lzma(struct mtd_info *master,
--			       const struct mtd_partition **pparts,
-+			       struct mtd_partition **pparts,
- 			       struct mtd_part_parser_data *data)
- {
- 	struct lzma_header hdr;
---- a/drivers/mtd/mtdsplit/mtdsplit_seama.c
-+++ b/drivers/mtd/mtdsplit/mtdsplit_seama.c
-@@ -30,7 +30,7 @@ struct seama_header {
- };
- 
- static int mtdsplit_parse_seama(struct mtd_info *master,
--				const struct mtd_partition **pparts,
-+				struct mtd_partition **pparts,
- 				struct mtd_part_parser_data *data)
- {
- 	struct seama_header hdr;
---- a/drivers/mtd/mtdsplit/mtdsplit_squashfs.c
-+++ b/drivers/mtd/mtdsplit/mtdsplit_squashfs.c
-@@ -23,7 +23,7 @@
- 
- static int
- mtdsplit_parse_squashfs(struct mtd_info *master,
--			const struct mtd_partition **pparts,
-+			struct mtd_partition **pparts,
- 			struct mtd_part_parser_data *data)
- {
- 	struct mtd_partition *part;
---- a/drivers/mtd/mtdsplit/mtdsplit_tplink.c
-+++ b/drivers/mtd/mtdsplit/mtdsplit_tplink.c
-@@ -83,8 +83,8 @@ struct tplink_fw_header {
- };
- 
- static int mtdsplit_parse_tplink(struct mtd_info *master,
--				 const struct mtd_partition **pparts,
--				 struct mtd_part_parser_data *data)
-+				struct mtd_partition **pparts,
-+				struct mtd_part_parser_data *data)
- {
- 	struct tplink_fw_header hdr;
- 	size_t hdr_len, retlen, kernel_size;
---- a/drivers/mtd/mtdsplit/mtdsplit_trx.c
-+++ b/drivers/mtd/mtdsplit/mtdsplit_trx.c
-@@ -56,7 +56,7 @@ read_trx_header(struct mtd_info *mtd, si
- 
- static int
- mtdsplit_parse_trx(struct mtd_info *master,
--		   const struct mtd_partition **pparts,
-+		   struct mtd_partition **pparts,
- 		   struct mtd_part_parser_data *data)
- {
- 	struct mtd_partition *parts;
---- a/drivers/mtd/mtdsplit/mtdsplit_uimage.c
-+++ b/drivers/mtd/mtdsplit/mtdsplit_uimage.c
-@@ -82,7 +82,7 @@ read_uimage_header(struct mtd_info *mtd,
-  *      of a valid uImage header if found
-  */
- static int __mtdsplit_parse_uimage(struct mtd_info *master,
--				   const struct mtd_partition **pparts,
-+				   struct mtd_partition **pparts,
- 				   struct mtd_part_parser_data *data,
- 				   ssize_t (*find_header)(u_char *buf, size_t len))
- {
-@@ -233,7 +233,7 @@ static ssize_t uimage_verify_default(u_c
- 
- static int
- mtdsplit_uimage_parse_generic(struct mtd_info *master,
--			      const struct mtd_partition **pparts,
-+			      struct mtd_partition **pparts,
- 			      struct mtd_part_parser_data *data)
- {
- 	return __mtdsplit_parse_uimage(master, pparts, data,
-@@ -300,7 +300,7 @@ static ssize_t uimage_verify_wndr3700(u_
- 
- static int
- mtdsplit_uimage_parse_netgear(struct mtd_info *master,
--			      const struct mtd_partition **pparts,
-+			      struct mtd_partition **pparts,
- 			      struct mtd_part_parser_data *data)
- {
- 	return __mtdsplit_parse_uimage(master, pparts, data,
-@@ -352,7 +352,7 @@ static ssize_t uimage_find_edimax(u_char
- 
- static int
- mtdsplit_uimage_parse_edimax(struct mtd_info *master,
--			      const struct mtd_partition **pparts,
-+			      struct mtd_partition **pparts,
- 			      struct mtd_part_parser_data *data)
- {
- 	return __mtdsplit_parse_uimage(master, pparts, data,
---- a/drivers/mtd/mtdsplit/mtdsplit_wrgg.c
-+++ b/drivers/mtd/mtdsplit/mtdsplit_wrgg.c
-@@ -51,8 +51,8 @@ struct wrg_header {
- 
- 
- static int mtdsplit_parse_wrgg(struct mtd_info *master,
--			       const struct mtd_partition **pparts,
--			       struct mtd_part_parser_data *data)
-+				struct mtd_partition **pparts,
-+				struct mtd_part_parser_data *data)
- {
- 	struct wrgg03_header hdr;
- 	size_t hdr_len, retlen, kernel_ent_size;
--- a/target/linux/generic/pending-3.18/002-phy_drivers_backport.patch	2022-03-22 08:54:47.246464734 +0800
+++ b/target/linux/generic/pending-3.18/002-phy_drivers_backport.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,552 +0,0 @@
---- a/drivers/net/phy/adm6996.c
-+++ b/drivers/net/phy/adm6996.c
-@@ -289,7 +289,7 @@ static u16
- adm6996_read_mii_reg(struct adm6996_priv *priv, enum admreg reg)
- {
- 	struct phy_device *phydev = priv->priv;
--	struct mii_bus *bus = phydev->mdio.bus;
-+	struct mii_bus *bus = phydev->bus;
- 
- 	return bus->read(bus, PHYADDR(reg));
- }
-@@ -298,7 +298,7 @@ static void
- adm6996_write_mii_reg(struct adm6996_priv *priv, enum admreg reg, u16 val)
- {
- 	struct phy_device *phydev = priv->priv;
--	struct mii_bus *bus = phydev->mdio.bus;
-+	struct mii_bus *bus = phydev->bus;
- 
- 	bus->write(bus, PHYADDR(reg), val);
- }
-@@ -1050,13 +1050,13 @@ static int adm6996_config_init(struct ph
- 	pdev->supported = ADVERTISED_100baseT_Full;
- 	pdev->advertising = ADVERTISED_100baseT_Full;
- 
--	if (pdev->mdio.addr != 0) {
-+	if (pdev->addr != 0) {
- 		pr_info ("%s: PHY overlaps ADM6996, providing fixed PHY 0x%x.\n"
--				, pdev->attached_dev->name, pdev->mdio.addr);
-+				, pdev->attached_dev->name, pdev->addr);
- 		return 0;
- 	}
- 
--	priv = devm_kzalloc(&pdev->mdio.dev, sizeof(struct adm6996_priv), GFP_KERNEL);
-+	priv = devm_kzalloc(&pdev->dev, sizeof(struct adm6996_priv), GFP_KERNEL);
- 	if (!priv)
- 		return -ENOMEM;
- 
-@@ -1076,7 +1076,7 @@ static int adm6996_config_init(struct ph
- }
- 
- /*
-- * Warning: phydev->priv is NULL if phydev->mdio.addr != 0
-+ * Warning: phydev->priv is NULL if phydev->addr != 0
-  */
- static int adm6996_read_status(struct phy_device *phydev)
- {
-@@ -1092,7 +1092,7 @@ static int adm6996_read_status(struct ph
- }
- 
- /*
-- * Warning: phydev->priv is NULL if phydev->mdio.addr != 0
-+ * Warning: phydev->priv is NULL if phydev->addr != 0
-  */
- static int adm6996_config_aneg(struct phy_device *phydev)
- {
-@@ -1101,11 +1101,11 @@ static int adm6996_config_aneg(struct ph
- 
- static int adm6996_fixup(struct phy_device *dev)
- {
--	struct mii_bus *bus = dev->mdio.bus;
-+	struct mii_bus *bus = dev->bus;
- 	u16 reg;
- 
- 	/* Our custom registers are at PHY addresses 0-10. Claim those. */
--	if (dev->mdio.addr > 10)
-+	if (dev->addr > 10)
- 		return 0;
- 
- 	/* look for the switch on the bus */
-@@ -1152,6 +1152,7 @@ static struct phy_driver adm6996_phy_dri
- 	.config_aneg	= &adm6996_config_aneg,
- 	.read_status	= &adm6996_read_status,
- 	.soft_reset	= adm6996_soft_reset,
-+	.driver		= { .owner = THIS_MODULE,},
- };
- 
- static int adm6996_gpio_probe(struct platform_device *pdev)
-@@ -1220,7 +1221,7 @@ static int __init adm6996_init(void)
- 	int err;
- 
- 	phy_register_fixup_for_id(PHY_ANY_ID, adm6996_fixup);
--	err = phy_driver_register(&adm6996_phy_driver, THIS_MODULE);
-+	err = phy_driver_register(&adm6996_phy_driver);
- 	if (err)
- 		return err;
- 
---- a/drivers/net/phy/ar8216.c
-+++ b/drivers/net/phy/ar8216.c
-@@ -177,7 +177,7 @@ ar8xxx_phy_check_aneg(struct phy_device
- 	if (ret & BMCR_ANENABLE)
- 		return 0;
- 
--	dev_info(&phydev->mdio.dev, "ANEG disabled, re-enabling ...\n");
-+	dev_info(&phydev->dev, "ANEG disabled, re-enabling ...\n");
- 	ret |= BMCR_ANENABLE | BMCR_ANRESTART;
- 	return phy_write(phydev, MII_BMCR, ret);
- }
-@@ -2021,7 +2021,7 @@ ar8xxx_phy_config_init(struct phy_device
- 
- 	priv->phy = phydev;
- 
--	if (phydev->mdio.addr != 0) {
-+	if (phydev->addr != 0) {
- 		if (chip_is_ar8316(priv)) {
- 			/* switch device has been initialized, reinit */
- 			priv->dev.ports = (AR8216_NUM_PORTS - 1);
-@@ -2069,7 +2069,7 @@ ar8xxx_check_link_states(struct ar8xxx_p
- 		/* flush ARL entries for this port if it went down*/
- 		if (!link_new)
- 			priv->chip->atu_flush_port(priv, i);
--		dev_info(&priv->phy->mdio.dev, "Port %d is %s\n",
-+		dev_info(&priv->phy->dev, "Port %d is %s\n",
- 			 i, link_new ? "up" : "down");
- 	}
- 
-@@ -2088,10 +2088,10 @@ ar8xxx_phy_read_status(struct phy_device
- 	if (phydev->state == PHY_CHANGELINK)
- 		ar8xxx_check_link_states(priv);
- 
--	if (phydev->mdio.addr != 0)
-+	if (phydev->addr != 0)
- 		return genphy_read_status(phydev);
- 
--	ar8216_read_port_link(priv, phydev->mdio.addr, &link);
-+	ar8216_read_port_link(priv, phydev->addr, &link);
- 	phydev->link = !!link.link;
- 	if (!phydev->link)
- 		return 0;
-@@ -2122,7 +2122,7 @@ ar8xxx_phy_read_status(struct phy_device
- static int
- ar8xxx_phy_config_aneg(struct phy_device *phydev)
- {
--	if (phydev->mdio.addr == 0)
-+	if (phydev->addr == 0)
- 		return 0;
- 
- 	return genphy_config_aneg(phydev);
-@@ -2177,15 +2177,15 @@ ar8xxx_phy_probe(struct phy_device *phyd
- 	int ret;
- 
- 	/* skip PHYs at unused adresses */
--	if (phydev->mdio.addr != 0 && phydev->mdio.addr != 3 && phydev->mdio.addr != 4)
-+	if (phydev->addr != 0 && phydev->addr != 3 && phydev->addr != 4)
- 		return -ENODEV;
- 
--	if (!ar8xxx_is_possible(phydev->mdio.bus))
-+	if (!ar8xxx_is_possible(phydev->bus))
- 		return -ENODEV;
- 
- 	mutex_lock(&ar8xxx_dev_list_lock);
- 	list_for_each_entry(priv, &ar8xxx_dev_list, list)
--		if (priv->mii_bus == phydev->mdio.bus)
-+		if (priv->mii_bus == phydev->bus)
- 			goto found;
- 
- 	priv = ar8xxx_create();
-@@ -2194,7 +2194,7 @@ ar8xxx_phy_probe(struct phy_device *phyd
- 		goto unlock;
- 	}
- 
--	priv->mii_bus = phydev->mdio.bus;
-+	priv->mii_bus = phydev->bus;
- 
- 	ret = ar8xxx_probe_switch(priv);
- 	if (ret)
-@@ -2215,7 +2215,7 @@ ar8xxx_phy_probe(struct phy_device *phyd
- found:
- 	priv->use_count++;
- 
--	if (phydev->mdio.addr == 0) {
-+	if (phydev->addr == 0) {
- 		if (ar8xxx_has_gige(priv)) {
- 			phydev->supported = SUPPORTED_1000baseT_Full;
- 			phydev->advertising = ADVERTISED_1000baseT_Full;
-@@ -2305,21 +2305,33 @@ ar8xxx_phy_soft_reset(struct phy_device
- 	return 0;
- }
- 
--static struct phy_driver ar8xxx_phy_driver[] = {
--	{
--		.phy_id		= 0x004d0000,
--		.name		= "Atheros AR8216/AR8236/AR8316",
--		.phy_id_mask	= 0xffff0000,
--		.features	= PHY_BASIC_FEATURES,
--		.probe		= ar8xxx_phy_probe,
--		.remove		= ar8xxx_phy_remove,
--		.detach		= ar8xxx_phy_detach,
--		.config_init	= ar8xxx_phy_config_init,
--		.config_aneg	= ar8xxx_phy_config_aneg,
--		.read_status	= ar8xxx_phy_read_status,
--		.soft_reset	= ar8xxx_phy_soft_reset,
--	}
-+static struct phy_driver ar8xxx_phy_driver = {
-+	.phy_id		= 0x004d0000,
-+	.name		= "Atheros AR8216/AR8236/AR8316",
-+	.phy_id_mask	= 0xffff0000,
-+	.features	= PHY_BASIC_FEATURES,
-+	.probe		= ar8xxx_phy_probe,
-+	.remove		= ar8xxx_phy_remove,
-+	.detach		= ar8xxx_phy_detach,
-+	.config_init	= ar8xxx_phy_config_init,
-+	.config_aneg	= ar8xxx_phy_config_aneg,
-+	.read_status	= ar8xxx_phy_read_status,
-+	.soft_reset	= ar8xxx_phy_soft_reset,
-+	.driver		= { .owner = THIS_MODULE },
- };
- 
--module_phy_driver(ar8xxx_phy_driver);
-+int __init
-+ar8xxx_init(void)
-+{
-+	return phy_driver_register(&ar8xxx_phy_driver);
-+}
-+
-+void __exit
-+ar8xxx_exit(void)
-+{
-+	phy_driver_unregister(&ar8xxx_phy_driver);
-+}
-+
-+module_init(ar8xxx_init);
-+module_exit(ar8xxx_exit);
- MODULE_LICENSE("GPL");
---- a/drivers/net/phy/ar8327.c
-+++ b/drivers/net/phy/ar8327.c
-@@ -662,11 +662,11 @@ ar8327_hw_init(struct ar8xxx_priv *priv)
- 	if (!priv->chip_data)
- 		return -ENOMEM;
- 
--	if (priv->phy->mdio.dev.of_node)
--		ret = ar8327_hw_config_of(priv, priv->phy->mdio.dev.of_node);
-+	if (priv->phy->dev.of_node)
-+		ret = ar8327_hw_config_of(priv, priv->phy->dev.of_node);
- 	else
- 		ret = ar8327_hw_config_pdata(priv,
--					     priv->phy->mdio.dev.platform_data);
-+					     priv->phy->dev.platform_data);
- 
- 	if (ret)
- 		return ret;
---- a/drivers/net/phy/ip17xx.c
-+++ b/drivers/net/phy/ip17xx.c
-@@ -1273,7 +1273,7 @@ static int ip17xx_probe(struct phy_devic
- 	int err;
- 
- 	/* We only attach to PHY 0, but use all available PHYs */
--	if (pdev->mdio.addr != 0)
-+	if (pdev->addr != 0)
- 		return -ENODEV;
- 
- 	state = kzalloc(sizeof(*state), GFP_KERNEL);
-@@ -1283,7 +1283,7 @@ static int ip17xx_probe(struct phy_devic
- 	dev = &state->dev;
- 
- 	pdev->priv = state;
--	state->mii_bus = pdev->mdio.bus;
-+	state->mii_bus = pdev->bus;
- 
- 	err = get_model(state);
- 	if (err < 0)
-@@ -1295,7 +1295,7 @@ static int ip17xx_probe(struct phy_devic
- 	dev->name = state->regs->NAME;
- 	dev->ops = &ip17xx_ops;
- 
--	pr_info("IP17xx: Found %s at %s\n", dev->name, dev_name(&pdev->mdio.dev));
-+	pr_info("IP17xx: Found %s at %s\n", dev->name, dev_name(&pdev->dev));
- 	return 0;
- 
- error:
-@@ -1353,25 +1353,58 @@ static int ip17xx_read_status(struct phy
- 	return 0;
- }
- 
--static struct phy_driver ip17xx_driver[] = {
--	{
--		.name		= "IC+ IP17xx",
--		.phy_id		= 0x02430c00,
--		.phy_id_mask	= 0x0ffffc00,
--		.features	= PHY_BASIC_FEATURES,
--		.probe		= ip17xx_probe,
--		.remove		= ip17xx_remove,
--		.config_init	= ip17xx_config_init,
--		.config_aneg	= ip17xx_config_aneg,
--		.aneg_done	= ip17xx_aneg_done,
--		.update_link	= ip17xx_update_link,
--		.read_status	= ip17xx_read_status,
--	}
-+static struct phy_driver ip17xx_driver = {
-+	.name		= "IC+ IP17xx",
-+	.phy_id		= 0x02430c00,
-+	.phy_id_mask	= 0x0ffffc00,
-+	.features	= PHY_BASIC_FEATURES,
-+	.probe		= ip17xx_probe,
-+	.remove		= ip17xx_remove,
-+	.config_init	= ip17xx_config_init,
-+	.config_aneg	= ip17xx_config_aneg,
-+	.aneg_done	= ip17xx_aneg_done,
-+	.update_link	= ip17xx_update_link,
-+	.read_status	= ip17xx_read_status,
-+	.driver		= { .owner = THIS_MODULE },
- };
- 
--module_phy_driver(ip17xx_driver);
-+static struct phy_driver ip175a_driver = {
-+	.name		= "IC+ IP175A",
-+	.phy_id		= 0x02430c50,
-+	.phy_id_mask	= 0x0ffffff0,
-+	.features	= PHY_BASIC_FEATURES,
-+	.probe		= ip17xx_probe,
-+	.remove		= ip17xx_remove,
-+	.config_init	= ip17xx_config_init,
-+	.config_aneg	= ip17xx_config_aneg,
-+	.aneg_done	= ip17xx_aneg_done,
-+	.update_link	= ip17xx_update_link,
-+	.read_status	= ip17xx_read_status,
-+	.driver		= { .owner = THIS_MODULE },
-+};
-+
-+
-+int __init ip17xx_init(void)
-+{
-+	int ret;
-+
-+	ret = phy_driver_register(&ip175a_driver);
-+	if (ret < 0)
-+		return ret;
-+
-+	return phy_driver_register(&ip17xx_driver);
-+}
-+
-+void __exit ip17xx_exit(void)
-+{
-+	phy_driver_unregister(&ip17xx_driver);
-+	phy_driver_unregister(&ip175a_driver);
-+}
- 
- MODULE_AUTHOR("Patrick Horn <patrick.horn@gmail.com>");
- MODULE_AUTHOR("Felix Fietkau <nbd@nbd.name>");
- MODULE_AUTHOR("Martin Mares <mj@ucw.cz>");
- MODULE_LICENSE("GPL");
-+
-+module_init(ip17xx_init);
-+module_exit(ip17xx_exit);
---- a/drivers/net/phy/mvswitch.c
-+++ b/drivers/net/phy/mvswitch.c
-@@ -50,17 +50,13 @@ struct mvswitch_priv {
- static inline u16
- r16(struct phy_device *phydev, int addr, int reg)
- {
--	struct mii_bus *bus = phydev->mdio.bus;
--
--	return bus->read(bus, addr, reg);
-+	return phydev->bus->read(phydev->bus, addr, reg);
- }
- 
- static inline void
- w16(struct phy_device *phydev, int addr, int reg, u16 val)
- {
--	struct mii_bus *bus = phydev->mdio.bus;
--
--	bus->write(bus, addr, reg, val);
-+	phydev->bus->write(phydev->bus, addr, reg, val);
- }
- 
- 
-@@ -398,13 +394,12 @@ mvswitch_probe(struct phy_device *pdev)
- static int
- mvswitch_fixup(struct phy_device *dev)
- {
--	struct mii_bus *bus = dev->mdio.bus;
- 	u16 reg;
- 
--	if (dev->mdio.addr != 0x10)
-+	if (dev->addr != 0x10)
- 		return 0;
- 
--	reg = bus->read(bus, MV_PORTREG(IDENT, 0)) & MV_IDENT_MASK;
-+	reg = dev->bus->read(dev->bus, MV_PORTREG(IDENT, 0)) & MV_IDENT_MASK;
- 	if (reg != MV_IDENT_VALUE)
- 		return 0;
- 
-@@ -425,13 +420,14 @@ static struct phy_driver mvswitch_driver
- 	.config_aneg	= &mvswitch_config_aneg,
- 	.aneg_done	= &mvswitch_aneg_done,
- 	.read_status	= &mvswitch_read_status,
-+	.driver		= { .owner = THIS_MODULE,},
- };
- 
- static int __init
- mvswitch_init(void)
- {
- 	phy_register_fixup_for_id(PHY_ANY_ID, mvswitch_fixup);
--	return phy_driver_register(&mvswitch_driver, THIS_MODULE);
-+	return phy_driver_register(&mvswitch_driver);
- }
- 
- static void __exit
---- a/drivers/net/phy/psb6970.c
-+++ b/drivers/net/phy/psb6970.c
-@@ -70,16 +70,12 @@ struct psb6970_priv {
- 
- static u16 psb6970_mii_read(struct phy_device *phydev, int reg)
- {
--	struct mii_bus *bus = phydev->mdio.bus;
--
--	return bus->read(bus, PHYADDR(reg));
-+	return phydev->bus->read(phydev->bus, PHYADDR(reg));
- }
- 
- static void psb6970_mii_write(struct phy_device *phydev, int reg, u16 val)
- {
--	struct mii_bus *bus = phydev->mdio.bus;
--
--	bus->write(bus, PHYADDR(reg), val);
-+	phydev->bus->write(phydev->bus, PHYADDR(reg), val);
- }
- 
- static int
-@@ -316,11 +312,11 @@ static int psb6970_config_init(struct ph
- 
- 	priv->phy = pdev;
- 
--	if (pdev->mdio.addr == 0)
-+	if (pdev->addr == 0)
- 		printk(KERN_INFO "%s: psb6970 switch driver attached.\n",
- 		       pdev->attached_dev->name);
- 
--	if (pdev->mdio.addr != 0) {
-+	if (pdev->addr != 0) {
- 		kfree(priv);
- 		return 0;
- 	}
-@@ -388,14 +384,14 @@ static void psb6970_remove(struct phy_de
- 	if (!priv)
- 		return;
- 
--	if (pdev->mdio.addr == 0)
-+	if (pdev->addr == 0)
- 		unregister_switch(&priv->dev);
- 	kfree(priv);
- }
- 
- static int psb6970_fixup(struct phy_device *dev)
- {
--	struct mii_bus *bus = dev->mdio.bus;
-+	struct mii_bus *bus = dev->bus;
- 	u16 reg;
- 
- 	/* look for the switch on the bus */
-@@ -419,12 +415,13 @@ static struct phy_driver psb6970_driver
- 	.config_init = &psb6970_config_init,
- 	.config_aneg = &psb6970_config_aneg,
- 	.read_status = &psb6970_read_status,
-+	.driver = {.owner = THIS_MODULE},
- };
- 
- int __init psb6970_init(void)
- {
- 	phy_register_fixup_for_id(PHY_ANY_ID, psb6970_fixup);
--	return phy_driver_register(&psb6970_driver, THIS_MODULE);
-+	return phy_driver_register(&psb6970_driver);
- }
- 
- module_init(psb6970_init);
---- a/drivers/net/phy/rtl8306.c
-+++ b/drivers/net/phy/rtl8306.c
-@@ -877,7 +877,7 @@ rtl8306_config_init(struct phy_device *p
- 	int err;
- 
- 	/* Only init the switch for the primary PHY */
--	if (pdev->mdio.addr != 0)
-+	if (pdev->addr != 0)
- 		return 0;
- 
- 	val.value.i = 1;
-@@ -887,7 +887,7 @@ rtl8306_config_init(struct phy_device *p
- 	priv->dev.ops = &rtl8306_ops;
- 	priv->do_cpu = 0;
- 	priv->page = -1;
--	priv->bus = pdev->mdio.bus;
-+	priv->bus = pdev->bus;
- 
- 	chipid = rtl_get(dev, RTL_REG_CHIPID);
- 	chipver = rtl_get(dev, RTL_REG_CHIPVER);
-@@ -933,13 +933,13 @@ rtl8306_fixup(struct phy_device *pdev)
- 	u16 chipid;
- 
- 	/* Attach to primary LAN port and WAN port */
--	if (pdev->mdio.addr != 0 && pdev->mdio.addr != 4)
-+	if (pdev->addr != 0 && pdev->addr != 4)
- 		return 0;
- 
- 	memset(&priv, 0, sizeof(priv));
- 	priv.fixup = true;
- 	priv.page = -1;
--	priv.bus = pdev->mdio.bus;
-+	priv.bus = pdev->bus;
- 	chipid = rtl_get(&priv.dev, RTL_REG_CHIPID);
- 	if (chipid == 0x5988)
- 		pdev->phy_id = RTL8306_MAGIC;
-@@ -957,14 +957,14 @@ rtl8306_probe(struct phy_device *pdev)
- 		 * share one rtl_priv instance between virtual phy
- 		 * devices on the same bus
- 		 */
--		if (priv->bus == pdev->mdio.bus)
-+		if (priv->bus == pdev->bus)
- 			goto found;
- 	}
- 	priv = kzalloc(sizeof(struct rtl_priv), GFP_KERNEL);
- 	if (!priv)
- 		return -ENOMEM;
- 
--	priv->bus = pdev->mdio.bus;
-+	priv->bus = pdev->bus;
- 
- found:
- 	pdev->priv = priv;
-@@ -985,7 +985,7 @@ rtl8306_config_aneg(struct phy_device *p
- 	struct rtl_priv *priv = pdev->priv;
- 
- 	/* Only for WAN */
--	if (pdev->mdio.addr == 0)
-+	if (pdev->addr == 0)
- 		return 0;
- 
- 	/* Restart autonegotiation */
-@@ -1001,7 +1001,7 @@ rtl8306_read_status(struct phy_device *p
- 	struct rtl_priv *priv = pdev->priv;
- 	struct switch_dev *dev = &priv->dev;
- 
--	if (pdev->mdio.addr == 4) {
-+	if (pdev->addr == 4) {
- 		/* WAN */
- 		pdev->speed = rtl_get(dev, RTL_PORT_REG(4, SPEED)) ? SPEED_100 : SPEED_10;
- 		pdev->duplex = rtl_get(dev, RTL_PORT_REG(4, DUPLEX)) ? DUPLEX_FULL : DUPLEX_HALF;
-@@ -1044,6 +1044,7 @@ static struct phy_driver rtl8306_driver
- 	.config_init	= &rtl8306_config_init,
- 	.config_aneg	= &rtl8306_config_aneg,
- 	.read_status	= &rtl8306_read_status,
-+	.driver		= { .owner = THIS_MODULE,},
- };
- 
- 
-@@ -1051,7 +1052,7 @@ static int __init
- rtl_init(void)
- {
- 	phy_register_fixup_for_id(PHY_ANY_ID, rtl8306_fixup);
--	return phy_driver_register(&rtl8306_driver, THIS_MODULE);
-+	return phy_driver_register(&rtl8306_driver);
- }
- 
- static void __exit
--- a/target/linux/generic/pending-3.18/003-myloader_backport.patch	2022-03-22 08:54:47.247464736 +0800
+++ b/target/linux/generic/pending-3.18/003-myloader_backport.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,11 +0,0 @@
---- a/drivers/mtd/myloader.c
-+++ b/drivers/mtd/myloader.c
-@@ -33,7 +33,7 @@ struct part_data {
- };
- 
- static int myloader_parse_partitions(struct mtd_info *master,
--				     const struct mtd_partition **pparts,
-+				     struct mtd_partition **pparts,
- 				     struct mtd_part_parser_data *data)
- {
- 	struct part_data *buf;
--- a/target/linux/generic/pending-3.18/020-ssb_update.patch	2022-03-22 08:54:47.247464736 +0800
+++ b/target/linux/generic/pending-3.18/020-ssb_update.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,134 +0,0 @@
---- a/drivers/ssb/pcihost_wrapper.c
-+++ b/drivers/ssb/pcihost_wrapper.c
-@@ -11,15 +11,17 @@
-  * Licensed under the GNU/GPL. See COPYING for details.
-  */
- 
-+#include <linux/pm.h>
- #include <linux/pci.h>
- #include <linux/export.h>
- #include <linux/slab.h>
- #include <linux/ssb/ssb.h>
- 
- 
--#ifdef CONFIG_PM
--static int ssb_pcihost_suspend(struct pci_dev *dev, pm_message_t state)
-+#ifdef CONFIG_PM_SLEEP
-+static int ssb_pcihost_suspend(struct device *d)
- {
-+	struct pci_dev *dev = to_pci_dev(d);
- 	struct ssb_bus *ssb = pci_get_drvdata(dev);
- 	int err;
- 
-@@ -28,17 +30,23 @@ static int ssb_pcihost_suspend(struct pc
- 		return err;
- 	pci_save_state(dev);
- 	pci_disable_device(dev);
--	pci_set_power_state(dev, pci_choose_state(dev, state));
-+
-+	/* if there is a wakeup enabled child device on ssb bus,
-+	   enable pci wakeup posibility. */
-+	device_set_wakeup_enable(d, d->power.wakeup_path);
-+
-+	pci_prepare_to_sleep(dev);
- 
- 	return 0;
- }
- 
--static int ssb_pcihost_resume(struct pci_dev *dev)
-+static int ssb_pcihost_resume(struct device *d)
- {
-+	struct pci_dev *dev = to_pci_dev(d);
- 	struct ssb_bus *ssb = pci_get_drvdata(dev);
- 	int err;
- 
--	pci_set_power_state(dev, PCI_D0);
-+	pci_back_from_sleep(dev);
- 	err = pci_enable_device(dev);
- 	if (err)
- 		return err;
-@@ -49,10 +57,12 @@ static int ssb_pcihost_resume(struct pci
- 
- 	return 0;
- }
--#else /* CONFIG_PM */
--# define ssb_pcihost_suspend	NULL
--# define ssb_pcihost_resume	NULL
--#endif /* CONFIG_PM */
-+
-+static const struct dev_pm_ops ssb_pcihost_pm_ops = {
-+	SET_SYSTEM_SLEEP_PM_OPS(ssb_pcihost_suspend, ssb_pcihost_resume)
-+};
-+
-+#endif /* CONFIG_PM_SLEEP */
- 
- static int ssb_pcihost_probe(struct pci_dev *dev,
- 			     const struct pci_device_id *id)
-@@ -115,8 +125,9 @@ int ssb_pcihost_register(struct pci_driv
- {
- 	driver->probe = ssb_pcihost_probe;
- 	driver->remove = ssb_pcihost_remove;
--	driver->suspend = ssb_pcihost_suspend;
--	driver->resume = ssb_pcihost_resume;
-+#ifdef CONFIG_PM_SLEEP
-+	driver->driver.pm = &ssb_pcihost_pm_ops;
-+#endif
- 
- 	return pci_register_driver(driver);
- }
---- a/drivers/ssb/driver_pcicore.c
-+++ b/drivers/ssb/driver_pcicore.c
-@@ -357,6 +357,16 @@ static void ssb_pcicore_init_hostmode(st
- 	pcicore_write32(pc, SSB_PCICORE_SBTOPCI2,
- 			SSB_PCICORE_SBTOPCI_MEM | SSB_PCI_DMA);
- 
-+	/*
-+	 * Accessing PCI config without a proper delay after devices reset (not
-+	 * GPIO reset) was causing reboots on WRT300N v1.0 (BCM4704).
-+	 * Tested delay 850 us lowered reboot chance to 50-80%, 1000 us fixed it
-+	 * completely. Flushing all writes was also tested but with no luck.
-+	 * The same problem was reported for WRT350N v1 (BCM4705), so we just
-+	 * sleep here unconditionally.
-+	 */
-+	usleep_range(1000, 2000);
-+
- 	/* Enable PCI bridge BAR0 prefetch and burst */
- 	val = PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;
- 	ssb_extpci_write_config(pc, 0, 0, 0, PCI_COMMAND, &val, 2);
---- a/drivers/ssb/main.c
-+++ b/drivers/ssb/main.c
-@@ -90,25 +90,6 @@ found:
- }
- #endif /* CONFIG_SSB_PCMCIAHOST */
- 
--#ifdef CONFIG_SSB_SDIOHOST
--struct ssb_bus *ssb_sdio_func_to_bus(struct sdio_func *func)
--{
--	struct ssb_bus *bus;
--
--	ssb_buses_lock();
--	list_for_each_entry(bus, &buses, list) {
--		if (bus->bustype == SSB_BUSTYPE_SDIO &&
--		    bus->host_sdio == func)
--			goto found;
--	}
--	bus = NULL;
--found:
--	ssb_buses_unlock();
--
--	return bus;
--}
--#endif /* CONFIG_SSB_SDIOHOST */
--
- int ssb_for_each_bus_call(unsigned long data,
- 			  int (*func)(struct ssb_bus *bus, unsigned long data))
- {
-@@ -1154,6 +1135,8 @@ static u32 ssb_tmslow_reject_bitmask(str
- 	case SSB_IDLOW_SSBREV_25:     /* TODO - find the proper REJECT bit */
- 	case SSB_IDLOW_SSBREV_27:     /* same here */
- 		return SSB_TMSLOW_REJECT;	/* this is a guess */
-+	case SSB_IDLOW_SSBREV:
-+		break;
- 	default:
- 		WARN(1, KERN_INFO "ssb: Backplane Revision 0x%.8X\n", rev);
- 	}
--- a/target/linux/generic/pending-3.18/021-ssb_sprom.patch	2022-03-22 08:54:47.247464736 +0800
+++ b/target/linux/generic/pending-3.18/021-ssb_sprom.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,32 +0,0 @@
---- a/include/linux/ssb/ssb.h
-+++ b/include/linux/ssb/ssb.h
-@@ -29,10 +29,13 @@ struct ssb_sprom {
- 	u8 il0mac[6] __aligned(sizeof(u16));	/* MAC address for 802.11b/g */
- 	u8 et0mac[6] __aligned(sizeof(u16));	/* MAC address for Ethernet */
- 	u8 et1mac[6] __aligned(sizeof(u16));	/* MAC address for 802.11a */
-+	u8 et2mac[6] __aligned(sizeof(u16));	/* MAC address for extra Ethernet */
- 	u8 et0phyaddr;		/* MII address for enet0 */
- 	u8 et1phyaddr;		/* MII address for enet1 */
-+	u8 et2phyaddr;		/* MII address for enet2 */
- 	u8 et0mdcport;		/* MDIO for enet0 */
- 	u8 et1mdcport;		/* MDIO for enet1 */
-+	u8 et2mdcport;		/* MDIO for enet2 */
- 	u16 dev_id;		/* Device ID overriding e.g. PCI ID */
- 	u16 board_rev;		/* Board revision number from SPROM. */
- 	u16 board_num;		/* Board number from SPROM. */
-@@ -88,11 +91,14 @@ struct ssb_sprom {
- 	u32 ofdm5glpo;		/* 5.2GHz OFDM power offset */
- 	u32 ofdm5gpo;		/* 5.3GHz OFDM power offset */
- 	u32 ofdm5ghpo;		/* 5.8GHz OFDM power offset */
-+	u32 boardflags;
-+	u32 boardflags2;
-+	u32 boardflags3;
-+	/* TODO: Switch all drivers to new u32 fields and drop below ones */
- 	u16 boardflags_lo;	/* Board flags (bits 0-15) */
- 	u16 boardflags_hi;	/* Board flags (bits 16-31) */
- 	u16 boardflags2_lo;	/* Board flags (bits 32-47) */
- 	u16 boardflags2_hi;	/* Board flags (bits 48-63) */
--	/* TODO store board flags in a single u64 */
- 
- 	struct ssb_sprom_core_pwr_info core_pwr_info[4];
- 
--- a/target/linux/generic/pending-3.18/025-bcma_backport.patch	2022-03-22 08:54:47.248464738 +0800
+++ b/target/linux/generic/pending-3.18/025-bcma_backport.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,286 +0,0 @@
---- a/drivers/bcma/bcma_private.h
-+++ b/drivers/bcma/bcma_private.h
-@@ -22,6 +22,7 @@ struct bcma_bus;
- /* main.c */
- bool bcma_wait_value(struct bcma_device *core, u16 reg, u32 mask, u32 value,
- 		     int timeout);
-+void bcma_prepare_core(struct bcma_bus *bus, struct bcma_device *core);
- int bcma_bus_register(struct bcma_bus *bus);
- void bcma_bus_unregister(struct bcma_bus *bus);
- int __init bcma_bus_early_register(struct bcma_bus *bus,
---- a/drivers/bcma/driver_chipcommon.c
-+++ b/drivers/bcma/driver_chipcommon.c
-@@ -339,7 +339,7 @@ void bcma_chipco_serial_init(struct bcma
- 		return;
- 	}
- 
--	irq = bcma_core_irq(cc->core);
-+	irq = bcma_core_irq(cc->core, 0);
- 
- 	/* Determine the registers of the UARTs */
- 	cc->nr_serial_ports = (cc->capabilities & BCMA_CC_CAP_NRUART);
---- a/drivers/bcma/driver_gpio.c
-+++ b/drivers/bcma/driver_gpio.c
-@@ -152,7 +152,7 @@ static int bcma_gpio_irq_domain_init(str
- 					 handle_simple_irq);
- 	}
- 
--	hwirq = bcma_core_irq(cc->core);
-+	hwirq = bcma_core_irq(cc->core, 0);
- 	err = request_irq(hwirq, bcma_gpio_irq_handler, IRQF_SHARED, "gpio",
- 			  cc);
- 	if (err)
-@@ -183,7 +183,7 @@ static void bcma_gpio_irq_domain_exit(st
- 		return;
- 
- 	bcma_cc_mask32(cc, BCMA_CC_IRQMASK, ~BCMA_CC_IRQ_GPIO);
--	free_irq(bcma_core_irq(cc->core), cc);
-+	free_irq(bcma_core_irq(cc->core, 0), cc);
- 	for (gpio = 0; gpio < chip->ngpio; gpio++) {
- 		int irq = irq_find_mapping(cc->irq_domain, gpio);
- 
---- a/drivers/bcma/driver_mips.c
-+++ b/drivers/bcma/driver_mips.c
-@@ -115,7 +115,7 @@ static u32 bcma_core_mips_irqflag(struct
-  * If disabled, 5 is returned.
-  * If not supported, 6 is returned.
-  */
--static unsigned int bcma_core_mips_irq(struct bcma_device *dev)
-+unsigned int bcma_core_mips_irq(struct bcma_device *dev)
- {
- 	struct bcma_device *mdev = dev->bus->drv_mips.core;
- 	u32 irqflag;
-@@ -133,13 +133,6 @@ static unsigned int bcma_core_mips_irq(s
- 	return 5;
- }
- 
--unsigned int bcma_core_irq(struct bcma_device *dev)
--{
--	unsigned int mips_irq = bcma_core_mips_irq(dev);
--	return mips_irq <= 4 ? mips_irq + 2 : 0;
--}
--EXPORT_SYMBOL(bcma_core_irq);
--
- static void bcma_core_mips_set_irq(struct bcma_device *dev, unsigned int irq)
- {
- 	unsigned int oldirq = bcma_core_mips_irq(dev);
-@@ -423,7 +416,7 @@ void bcma_core_mips_init(struct bcma_drv
- 		break;
- 	default:
- 		list_for_each_entry(core, &bus->cores, list) {
--			core->irq = bcma_core_irq(core);
-+			core->irq = bcma_core_irq(core, 0);
- 		}
- 		bcma_err(bus,
- 			 "Unknown device (0x%x) found, can not configure IRQs\n",
---- a/drivers/bcma/driver_pci_host.c
-+++ b/drivers/bcma/driver_pci_host.c
-@@ -593,7 +593,7 @@ int bcma_core_pci_plat_dev_init(struct p
- 	pr_info("PCI: Fixing up device %s\n", pci_name(dev));
- 
- 	/* Fix up interrupt lines */
--	dev->irq = bcma_core_irq(pc_host->pdev->core);
-+	dev->irq = bcma_core_irq(pc_host->pdev->core, 0);
- 	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, dev->irq);
- 
- 	readrq = pcie_get_readrq(dev);
-@@ -617,6 +617,6 @@ int bcma_core_pci_pcibios_map_irq(const
- 
- 	pc_host = container_of(dev->bus->ops, struct bcma_drv_pci_host,
- 			       pci_ops);
--	return bcma_core_irq(pc_host->pdev->core);
-+	return bcma_core_irq(pc_host->pdev->core, 0);
- }
- EXPORT_SYMBOL(bcma_core_pci_pcibios_map_irq);
---- a/drivers/bcma/main.c
-+++ b/drivers/bcma/main.c
-@@ -11,6 +11,7 @@
- #include <linux/bcma/bcma.h>
- #include <linux/slab.h>
- #include <linux/of_address.h>
-+#include <linux/of_irq.h>
- 
- MODULE_DESCRIPTION("Broadcom's specific AMBA driver");
- MODULE_LICENSE("GPL");
-@@ -153,6 +154,46 @@ static struct device_node *bcma_of_find_
- 	return NULL;
- }
- 
-+static int bcma_of_irq_parse(struct platform_device *parent,
-+			     struct bcma_device *core,
-+			     struct of_phandle_args *out_irq, int num)
-+{
-+	__be32 laddr[1];
-+	int rc;
-+
-+	if (core->dev.of_node) {
-+		rc = of_irq_parse_one(core->dev.of_node, num, out_irq);
-+		if (!rc)
-+			return rc;
-+	}
-+
-+	out_irq->np = parent->dev.of_node;
-+	out_irq->args_count = 1;
-+	out_irq->args[0] = num;
-+
-+	laddr[0] = cpu_to_be32(core->addr);
-+	return of_irq_parse_raw(laddr, out_irq);
-+}
-+
-+static unsigned int bcma_of_get_irq(struct platform_device *parent,
-+				    struct bcma_device *core, int num)
-+{
-+	struct of_phandle_args out_irq;
-+	int ret;
-+
-+	if (!parent || !parent->dev.of_node)
-+		return 0;
-+
-+	ret = bcma_of_irq_parse(parent, core, &out_irq, num);
-+	if (ret) {
-+		bcma_debug(core->bus, "bcma_of_get_irq() failed with rc=%d\n",
-+			   ret);
-+		return 0;
-+	}
-+
-+	return irq_create_of_mapping(&out_irq);
-+}
-+
- static void bcma_of_fill_device(struct platform_device *parent,
- 				struct bcma_device *core)
- {
-@@ -161,18 +202,47 @@ static void bcma_of_fill_device(struct p
- 	node = bcma_of_find_child_device(parent, core);
- 	if (node)
- 		core->dev.of_node = node;
-+
-+	core->irq = bcma_of_get_irq(parent, core, 0);
- }
- #else
- static void bcma_of_fill_device(struct platform_device *parent,
- 				struct bcma_device *core)
- {
- }
-+static inline unsigned int bcma_of_get_irq(struct platform_device *parent,
-+					   struct bcma_device *core, int num)
-+{
-+	return 0;
-+}
- #endif /* CONFIG_OF */
- 
--static void bcma_register_core(struct bcma_bus *bus, struct bcma_device *core)
-+unsigned int bcma_core_irq(struct bcma_device *core, int num)
- {
--	int err;
-+	struct bcma_bus *bus = core->bus;
-+	unsigned int mips_irq;
-+
-+	switch (bus->hosttype) {
-+	case BCMA_HOSTTYPE_PCI:
-+		return bus->host_pci->irq;
-+	case BCMA_HOSTTYPE_SOC:
-+		if (bus->drv_mips.core && num == 0) {
-+			mips_irq = bcma_core_mips_irq(core);
-+			return mips_irq <= 4 ? mips_irq + 2 : 0;
-+		}
-+		if (bus->host_pdev)
-+			return bcma_of_get_irq(bus->host_pdev, core, num);
-+		return 0;
-+	case BCMA_HOSTTYPE_SDIO:
-+		return 0;
-+	}
- 
-+	return 0;
-+}
-+EXPORT_SYMBOL(bcma_core_irq);
-+
-+void bcma_prepare_core(struct bcma_bus *bus, struct bcma_device *core)
-+{
- 	core->dev.release = bcma_release_core_dev;
- 	core->dev.bus = &bcma_bus_type;
- 	dev_set_name(&core->dev, "bcma%d:%d", bus->num, core->core_index);
-@@ -196,6 +266,11 @@ static void bcma_register_core(struct bc
- 	case BCMA_HOSTTYPE_SDIO:
- 		break;
- 	}
-+}
-+
-+static void bcma_register_core(struct bcma_bus *bus, struct bcma_device *core)
-+{
-+	int err;
- 
- 	err = device_register(&core->dev);
- 	if (err) {
---- a/drivers/bcma/scan.c
-+++ b/drivers/bcma/scan.c
-@@ -505,6 +505,7 @@ int bcma_bus_scan(struct bcma_bus *bus)
- 		bus->nr_cores++;
- 		other_core = bcma_find_core_reverse(bus, core->id.id);
- 		core->core_unit = (other_core == NULL) ? 0 : other_core->core_unit + 1;
-+		bcma_prepare_core(bus, core);
- 
- 		bcma_info(bus, "Core %d found: %s (manuf 0x%03X, id 0x%03X, rev 0x%02X, class 0x%X)\n",
- 			  core->core_index, bcma_device_name(&core->id),
---- a/include/linux/bcma/bcma.h
-+++ b/include/linux/bcma/bcma.h
-@@ -448,4 +448,6 @@ extern u32 bcma_chipco_pll_read(struct b
- #define  BCMA_DMA_TRANSLATION_DMA64_CMT	0x80000000 /* Client Mode Translation for 64-bit DMA */
- extern u32 bcma_core_dma_translation(struct bcma_device *core);
- 
-+extern unsigned int bcma_core_irq(struct bcma_device *core, int num);
-+
- #endif /* LINUX_BCMA_H_ */
---- a/include/linux/bcma/bcma_driver_mips.h
-+++ b/include/linux/bcma/bcma_driver_mips.h
-@@ -43,12 +43,12 @@ struct bcma_drv_mips {
- extern void bcma_core_mips_init(struct bcma_drv_mips *mcore);
- extern void bcma_core_mips_early_init(struct bcma_drv_mips *mcore);
- 
--extern unsigned int bcma_core_irq(struct bcma_device *core);
-+extern unsigned int bcma_core_mips_irq(struct bcma_device *dev);
- #else
- static inline void bcma_core_mips_init(struct bcma_drv_mips *mcore) { }
- static inline void bcma_core_mips_early_init(struct bcma_drv_mips *mcore) { }
- 
--static inline unsigned int bcma_core_irq(struct bcma_device *core)
-+static inline unsigned int bcma_core_mips_irq(struct bcma_device *dev)
- {
- 	return 0;
- }
---- a/Documentation/devicetree/bindings/bus/bcma.txt
-+++ b/Documentation/devicetree/bindings/bus/bcma.txt
-@@ -8,6 +8,11 @@ Required properties:
- 
- The cores on the AXI bus are automatically detected by bcma with the
- memory ranges they are using and they get registered afterwards.
-+Automatic detection of the IRQ number is not working on
-+BCM47xx/BCM53xx ARM SoCs. To assign IRQ numbers to the cores, provide
-+them manually through device tree. Use an interrupt-map to specify the
-+IRQ used by the devices on the bus. The first address is just an index,
-+because we do not have any special register.
- 
- The top-level axi bus may contain children representing attached cores
- (devices). This is needed since some hardware details can't be auto
-@@ -22,6 +27,22 @@ Example:
- 		ranges = <0x00000000 0x18000000 0x00100000>;
- 		#address-cells = <1>;
- 		#size-cells = <1>;
-+		#interrupt-cells = <1>;
-+		interrupt-map-mask = <0x000fffff 0xffff>;
-+		interrupt-map =
-+			/* Ethernet Controller 0 */
-+			<0x00024000 0 &gic GIC_SPI 147 IRQ_TYPE_LEVEL_HIGH>,
-+
-+			/* Ethernet Controller 1 */
-+			<0x00025000 0 &gic GIC_SPI 148 IRQ_TYPE_LEVEL_HIGH>;
-+
-+			/* PCIe Controller 0 */
-+			<0x00012000 0 &gic GIC_SPI 126 IRQ_TYPE_LEVEL_HIGH>,
-+			<0x00012000 1 &gic GIC_SPI 127 IRQ_TYPE_LEVEL_HIGH>,
-+			<0x00012000 2 &gic GIC_SPI 128 IRQ_TYPE_LEVEL_HIGH>,
-+			<0x00012000 3 &gic GIC_SPI 129 IRQ_TYPE_LEVEL_HIGH>,
-+			<0x00012000 4 &gic GIC_SPI 130 IRQ_TYPE_LEVEL_HIGH>,
-+			<0x00012000 5 &gic GIC_SPI 131 IRQ_TYPE_LEVEL_HIGH>;
- 
- 		chipcommon {
- 			reg = <0x00000000 0x1000>;
--- a/target/linux/generic/pending-3.18/026-bcma-from-3.20.patch	2022-03-22 08:54:47.248464738 +0800
+++ b/target/linux/generic/pending-3.18/026-bcma-from-3.20.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,527 +0,0 @@
---- a/drivers/bcma/bcma_private.h
-+++ b/drivers/bcma/bcma_private.h
-@@ -23,22 +23,18 @@ struct bcma_bus;
- bool bcma_wait_value(struct bcma_device *core, u16 reg, u32 mask, u32 value,
- 		     int timeout);
- void bcma_prepare_core(struct bcma_bus *bus, struct bcma_device *core);
-+void bcma_init_bus(struct bcma_bus *bus);
- int bcma_bus_register(struct bcma_bus *bus);
- void bcma_bus_unregister(struct bcma_bus *bus);
--int __init bcma_bus_early_register(struct bcma_bus *bus,
--				   struct bcma_device *core_cc,
--				   struct bcma_device *core_mips);
-+int __init bcma_bus_early_register(struct bcma_bus *bus);
- #ifdef CONFIG_PM
- int bcma_bus_suspend(struct bcma_bus *bus);
- int bcma_bus_resume(struct bcma_bus *bus);
- #endif
- 
- /* scan.c */
-+void bcma_detect_chip(struct bcma_bus *bus);
- int bcma_bus_scan(struct bcma_bus *bus);
--int __init bcma_bus_scan_early(struct bcma_bus *bus,
--			       struct bcma_device_id *match,
--			       struct bcma_device *core);
--void bcma_init_bus(struct bcma_bus *bus);
- 
- /* sprom.c */
- int bcma_sprom_get(struct bcma_bus *bus);
-@@ -109,6 +105,14 @@ extern int bcma_chipco_watchdog_register
- #ifdef CONFIG_BCMA_DRIVER_PCI_HOSTMODE
- bool bcma_core_pci_is_in_hostmode(struct bcma_drv_pci *pc);
- void bcma_core_pci_hostmode_init(struct bcma_drv_pci *pc);
-+#else
-+static inline bool bcma_core_pci_is_in_hostmode(struct bcma_drv_pci *pc)
-+{
-+	return false;
-+}
-+static inline void bcma_core_pci_hostmode_init(struct bcma_drv_pci *pc)
-+{
-+}
- #endif /* CONFIG_BCMA_DRIVER_PCI_HOSTMODE */
- 
- #ifdef CONFIG_BCMA_DRIVER_GPIO
---- a/drivers/bcma/driver_chipcommon.c
-+++ b/drivers/bcma/driver_chipcommon.c
-@@ -79,7 +79,9 @@ static int bcma_chipco_watchdog_ticks_pe
- 
- 	if (cc->capabilities & BCMA_CC_CAP_PMU) {
- 		if (bus->chipinfo.id == BCMA_CHIP_ID_BCM4706)
--			/* 4706 CC and PMU watchdogs are clocked at 1/4 of ALP clock */
-+			/* 4706 CC and PMU watchdogs are clocked at 1/4 of ALP
-+			 * clock
-+			 */
- 			return bcma_chipco_get_alp_clock(cc) / 4000;
- 		else
- 			/* based on 32KHz ILP clock */
-@@ -97,7 +99,8 @@ int bcma_chipco_watchdog_register(struct
- 	wdt.driver_data = cc;
- 	wdt.timer_set = bcma_chipco_watchdog_timer_set_wdt;
- 	wdt.timer_set_ms = bcma_chipco_watchdog_timer_set_ms_wdt;
--	wdt.max_timer_ms = bcma_chipco_watchdog_get_max_timer(cc) / cc->ticks_per_ms;
-+	wdt.max_timer_ms =
-+		bcma_chipco_watchdog_get_max_timer(cc) / cc->ticks_per_ms;
- 
- 	pdev = platform_device_register_data(NULL, "bcm47xx-wdt",
- 					     cc->core->bus->num, &wdt,
-@@ -175,7 +178,6 @@ void bcma_core_chipcommon_init(struct bc
- u32 bcma_chipco_watchdog_timer_set(struct bcma_drv_cc *cc, u32 ticks)
- {
- 	u32 maxt;
--	enum bcma_clkmode clkmode;
- 
- 	maxt = bcma_chipco_watchdog_get_max_timer(cc);
- 	if (cc->capabilities & BCMA_CC_CAP_PMU) {
-@@ -185,8 +187,13 @@ u32 bcma_chipco_watchdog_timer_set(struc
- 			ticks = maxt;
- 		bcma_cc_write32(cc, BCMA_CC_PMU_WATCHDOG, ticks);
- 	} else {
--		clkmode = ticks ? BCMA_CLKMODE_FAST : BCMA_CLKMODE_DYNAMIC;
--		bcma_core_set_clockmode(cc->core, clkmode);
-+		struct bcma_bus *bus = cc->core->bus;
-+
-+		if (bus->chipinfo.id != BCMA_CHIP_ID_BCM4707 &&
-+		    bus->chipinfo.id != BCMA_CHIP_ID_BCM53018)
-+			bcma_core_set_clockmode(cc->core,
-+						ticks ? BCMA_CLKMODE_FAST : BCMA_CLKMODE_DYNAMIC);
-+
- 		if (ticks > maxt)
- 			ticks = maxt;
- 		/* instant NMI */
-@@ -335,7 +342,8 @@ void bcma_chipco_serial_init(struct bcma
- 				       | BCMA_CC_CORECTL_UARTCLKEN);
- 		}
- 	} else {
--		bcma_err(cc->core->bus, "serial not supported on this device ccrev: 0x%x\n", ccrev);
-+		bcma_err(cc->core->bus, "serial not supported on this device ccrev: 0x%x\n",
-+			 ccrev);
- 		return;
- 	}
- 
---- a/drivers/bcma/driver_pci.c
-+++ b/drivers/bcma/driver_pci.c
-@@ -145,6 +145,47 @@ static u16 bcma_pcie_mdio_writeread(stru
- }
- 
- /**************************************************
-+ * Early init.
-+ **************************************************/
-+
-+static void bcma_core_pci_fixcfg(struct bcma_drv_pci *pc)
-+{
-+	struct bcma_device *core = pc->core;
-+	u16 val16, core_index;
-+	uint regoff;
-+
-+	regoff = BCMA_CORE_PCI_SPROM(BCMA_CORE_PCI_SPROM_PI_OFFSET);
-+	core_index = (u16)core->core_index;
-+
-+	val16 = pcicore_read16(pc, regoff);
-+	if (((val16 & BCMA_CORE_PCI_SPROM_PI_MASK) >> BCMA_CORE_PCI_SPROM_PI_SHIFT)
-+	     != core_index) {
-+		val16 = (core_index << BCMA_CORE_PCI_SPROM_PI_SHIFT) |
-+			(val16 & ~BCMA_CORE_PCI_SPROM_PI_MASK);
-+		pcicore_write16(pc, regoff, val16);
-+	}
-+}
-+
-+/*
-+ * Apply some early fixes required before accessing SPROM.
-+ * See also si_pci_fixcfg.
-+ */
-+void bcma_core_pci_early_init(struct bcma_drv_pci *pc)
-+{
-+	if (pc->early_setup_done)
-+		return;
-+
-+	pc->hostmode = bcma_core_pci_is_in_hostmode(pc);
-+	if (pc->hostmode)
-+		goto out;
-+
-+	bcma_core_pci_fixcfg(pc);
-+
-+out:
-+	pc->early_setup_done = true;
-+}
-+
-+/**************************************************
-  * Workarounds.
-  **************************************************/
- 
-@@ -175,24 +216,6 @@ static void bcma_pcicore_serdes_workarou
- 		                     tmp & ~BCMA_CORE_PCI_PLL_CTRL_FREQDET_EN);
- }
- 
--static void bcma_core_pci_fixcfg(struct bcma_drv_pci *pc)
--{
--	struct bcma_device *core = pc->core;
--	u16 val16, core_index;
--	uint regoff;
--
--	regoff = BCMA_CORE_PCI_SPROM(BCMA_CORE_PCI_SPROM_PI_OFFSET);
--	core_index = (u16)core->core_index;
--
--	val16 = pcicore_read16(pc, regoff);
--	if (((val16 & BCMA_CORE_PCI_SPROM_PI_MASK) >> BCMA_CORE_PCI_SPROM_PI_SHIFT)
--	     != core_index) {
--		val16 = (core_index << BCMA_CORE_PCI_SPROM_PI_SHIFT) |
--			(val16 & ~BCMA_CORE_PCI_SPROM_PI_MASK);
--		pcicore_write16(pc, regoff, val16);
--	}
--}
--
- /* Fix MISC config to allow coming out of L2/L3-Ready state w/o PRST */
- /* Needs to happen when coming out of 'standby'/'hibernate' */
- static void bcma_core_pci_config_fixup(struct bcma_drv_pci *pc)
-@@ -216,7 +239,6 @@ static void bcma_core_pci_config_fixup(s
- 
- static void bcma_core_pci_clientmode_init(struct bcma_drv_pci *pc)
- {
--	bcma_core_pci_fixcfg(pc);
- 	bcma_pcicore_serdes_workaround(pc);
- 	bcma_core_pci_config_fixup(pc);
- }
-@@ -226,13 +248,11 @@ void bcma_core_pci_init(struct bcma_drv_
- 	if (pc->setup_done)
- 		return;
- 
--#ifdef CONFIG_BCMA_DRIVER_PCI_HOSTMODE
--	pc->hostmode = bcma_core_pci_is_in_hostmode(pc);
-+	bcma_core_pci_early_init(pc);
-+
- 	if (pc->hostmode)
- 		bcma_core_pci_hostmode_init(pc);
--#endif /* CONFIG_BCMA_DRIVER_PCI_HOSTMODE */
--
--	if (!pc->hostmode)
-+	else
- 		bcma_core_pci_clientmode_init(pc);
- }
- 
---- a/drivers/bcma/host_pci.c
-+++ b/drivers/bcma/host_pci.c
-@@ -13,10 +13,12 @@
- 
- static void bcma_host_pci_switch_core(struct bcma_device *core)
- {
-+	int win2 = core->bus->host_is_pcie2 ?
-+		BCMA_PCIE2_BAR0_WIN2 : BCMA_PCI_BAR0_WIN2;
-+
- 	pci_write_config_dword(core->bus->host_pci, BCMA_PCI_BAR0_WIN,
- 			       core->addr);
--	pci_write_config_dword(core->bus->host_pci, BCMA_PCI_BAR0_WIN2,
--			       core->wrap);
-+	pci_write_config_dword(core->bus->host_pci, win2, core->wrap);
- 	core->bus->mapped_core = core;
- 	bcma_debug(core->bus, "Switched to core: 0x%X\n", core->id.id);
- }
---- a/drivers/bcma/host_soc.c
-+++ b/drivers/bcma/host_soc.c
-@@ -193,7 +193,7 @@ int __init bcma_host_soc_init(struct bcm
- 	int err;
- 
- 	/* Scan bus and initialize it */
--	err = bcma_bus_early_register(bus, &soc->core_cc, &soc->core_mips);
-+	err = bcma_bus_early_register(bus);
- 	if (err)
- 		iounmap(bus->mmio);
- 
---- a/drivers/bcma/main.c
-+++ b/drivers/bcma/main.c
-@@ -268,6 +268,18 @@ void bcma_prepare_core(struct bcma_bus *
- 	}
- }
- 
-+void bcma_init_bus(struct bcma_bus *bus)
-+{
-+	mutex_lock(&bcma_buses_mutex);
-+	bus->num = bcma_bus_next_num++;
-+	mutex_unlock(&bcma_buses_mutex);
-+
-+	INIT_LIST_HEAD(&bus->cores);
-+	bus->nr_cores = 0;
-+
-+	bcma_detect_chip(bus);
-+}
-+
- static void bcma_register_core(struct bcma_bus *bus, struct bcma_device *core)
- {
- 	int err;
-@@ -356,12 +368,19 @@ static void bcma_unregister_cores(struct
- 	struct bcma_device *core, *tmp;
- 
- 	list_for_each_entry_safe(core, tmp, &bus->cores, list) {
-+		if (!core->dev_registered)
-+			continue;
- 		list_del(&core->list);
--		if (core->dev_registered)
--			device_unregister(&core->dev);
-+		device_unregister(&core->dev);
- 	}
- 	if (bus->hosttype == BCMA_HOSTTYPE_SOC)
- 		platform_device_unregister(bus->drv_cc.watchdog);
-+
-+	/* Now noone uses internally-handled cores, we can free them */
-+	list_for_each_entry_safe(core, tmp, &bus->cores, list) {
-+		list_del(&core->list);
-+		kfree(core);
-+	}
- }
- 
- int bcma_bus_register(struct bcma_bus *bus)
-@@ -369,10 +388,6 @@ int bcma_bus_register(struct bcma_bus *b
- 	int err;
- 	struct bcma_device *core;
- 
--	mutex_lock(&bcma_buses_mutex);
--	bus->num = bcma_bus_next_num++;
--	mutex_unlock(&bcma_buses_mutex);
--
- 	/* Scan for devices (cores) */
- 	err = bcma_bus_scan(bus);
- 	if (err) {
-@@ -387,6 +402,13 @@ int bcma_bus_register(struct bcma_bus *b
- 		bcma_core_chipcommon_early_init(&bus->drv_cc);
- 	}
- 
-+	/* Early init PCIE core */
-+	core = bcma_find_core(bus, BCMA_CORE_PCIE);
-+	if (core) {
-+		bus->drv_pci[0].core = core;
-+		bcma_core_pci_early_init(&bus->drv_pci[0]);
-+	}
-+
- 	/* Cores providing flash access go before SPROM init */
- 	list_for_each_entry(core, &bus->cores, list) {
- 		if (bcma_is_core_needed_early(core->id.id))
-@@ -459,7 +481,6 @@ int bcma_bus_register(struct bcma_bus *b
- 
- void bcma_bus_unregister(struct bcma_bus *bus)
- {
--	struct bcma_device *cores[3];
- 	int err;
- 
- 	err = bcma_gpio_unregister(&bus->drv_cc);
-@@ -470,46 +491,23 @@ void bcma_bus_unregister(struct bcma_bus
- 
- 	bcma_core_chipcommon_b_free(&bus->drv_cc_b);
- 
--	cores[0] = bcma_find_core(bus, BCMA_CORE_MIPS_74K);
--	cores[1] = bcma_find_core(bus, BCMA_CORE_PCIE);
--	cores[2] = bcma_find_core(bus, BCMA_CORE_4706_MAC_GBIT_COMMON);
--
- 	bcma_unregister_cores(bus);
--
--	kfree(cores[2]);
--	kfree(cores[1]);
--	kfree(cores[0]);
- }
- 
--int __init bcma_bus_early_register(struct bcma_bus *bus,
--				   struct bcma_device *core_cc,
--				   struct bcma_device *core_mips)
-+/*
-+ * This is a special version of bus registration function designed for SoCs.
-+ * It scans bus and performs basic initialization of main cores only.
-+ * Please note it requires memory allocation, however it won't try to sleep.
-+ */
-+int __init bcma_bus_early_register(struct bcma_bus *bus)
- {
- 	int err;
- 	struct bcma_device *core;
--	struct bcma_device_id match;
--
--	match.manuf = BCMA_MANUF_BCM;
--	match.id = bcma_cc_core_id(bus);
--	match.class = BCMA_CL_SIM;
--	match.rev = BCMA_ANY_REV;
- 
--	/* Scan for chip common core */
--	err = bcma_bus_scan_early(bus, &match, core_cc);
--	if (err) {
--		bcma_err(bus, "Failed to scan for common core: %d\n", err);
--		return -1;
--	}
--
--	match.manuf = BCMA_MANUF_MIPS;
--	match.id = BCMA_CORE_MIPS_74K;
--	match.class = BCMA_CL_SIM;
--	match.rev = BCMA_ANY_REV;
--
--	/* Scan for mips core */
--	err = bcma_bus_scan_early(bus, &match, core_mips);
-+	/* Scan for devices (cores) */
-+	err = bcma_bus_scan(bus);
- 	if (err) {
--		bcma_err(bus, "Failed to scan for mips core: %d\n", err);
-+		bcma_err(bus, "Failed to scan bus: %d\n", err);
- 		return -1;
- 	}
- 
---- a/drivers/bcma/scan.c
-+++ b/drivers/bcma/scan.c
-@@ -435,15 +435,12 @@ static int bcma_get_next_core(struct bcm
- 	return 0;
- }
- 
--void bcma_init_bus(struct bcma_bus *bus)
-+void bcma_detect_chip(struct bcma_bus *bus)
- {
- 	s32 tmp;
- 	struct bcma_chipinfo *chipinfo = &(bus->chipinfo);
- 	char chip_id[8];
- 
--	INIT_LIST_HEAD(&bus->cores);
--	bus->nr_cores = 0;
--
- 	bcma_scan_switch_core(bus, BCMA_ADDR_BASE);
- 
- 	tmp = bcma_scan_read32(bus, 0, BCMA_CC_ID);
-@@ -464,6 +461,10 @@ int bcma_bus_scan(struct bcma_bus *bus)
- 
- 	int err, core_num = 0;
- 
-+	/* Skip if bus was already scanned (e.g. during early register) */
-+	if (bus->nr_cores)
-+		return 0;
-+
- 	erombase = bcma_scan_read32(bus, 0, BCMA_CC_EROM);
- 	if (bus->hosttype == BCMA_HOSTTYPE_SOC) {
- 		eromptr = ioremap_nocache(erombase, BCMA_CORE_SIZE);
-@@ -519,64 +520,6 @@ int bcma_bus_scan(struct bcma_bus *bus)
- out:
- 	if (bus->hosttype == BCMA_HOSTTYPE_SOC)
- 		iounmap(eromptr);
--
--	return err;
--}
--
--int __init bcma_bus_scan_early(struct bcma_bus *bus,
--			       struct bcma_device_id *match,
--			       struct bcma_device *core)
--{
--	u32 erombase;
--	u32 __iomem *eromptr, *eromend;
--
--	int err = -ENODEV;
--	int core_num = 0;
--
--	erombase = bcma_scan_read32(bus, 0, BCMA_CC_EROM);
--	if (bus->hosttype == BCMA_HOSTTYPE_SOC) {
--		eromptr = ioremap_nocache(erombase, BCMA_CORE_SIZE);
--		if (!eromptr)
--			return -ENOMEM;
--	} else {
--		eromptr = bus->mmio;
--	}
--
--	eromend = eromptr + BCMA_CORE_SIZE / sizeof(u32);
--
--	bcma_scan_switch_core(bus, erombase);
--
--	while (eromptr < eromend) {
--		memset(core, 0, sizeof(*core));
--		INIT_LIST_HEAD(&core->list);
--		core->bus = bus;
--
--		err = bcma_get_next_core(bus, &eromptr, match, core_num, core);
--		if (err == -ENODEV) {
--			core_num++;
--			continue;
--		} else if (err == -ENXIO)
--			continue;
--		else if (err == -ESPIPE)
--			break;
--		else if (err < 0)
--			goto out;
--
--		core->core_index = core_num++;
--		bus->nr_cores++;
--		bcma_info(bus, "Core %d found: %s (manuf 0x%03X, id 0x%03X, rev 0x%02X, class 0x%X)\n",
--			  core->core_index, bcma_device_name(&core->id),
--			  core->id.manuf, core->id.id, core->id.rev,
--			  core->id.class);
--
--		list_add_tail(&core->list, &bus->cores);
--		err = 0;
--		break;
--	}
--
--out:
--	if (bus->hosttype == BCMA_HOSTTYPE_SOC)
--		iounmap(eromptr);
- 
- 	return err;
- }
---- a/drivers/bcma/sprom.c
-+++ b/drivers/bcma/sprom.c
-@@ -579,7 +579,8 @@ int bcma_sprom_get(struct bcma_bus *bus)
- 	u16 offset = BCMA_CC_SPROM;
- 	u16 *sprom;
- 	size_t sprom_sizes[] = { SSB_SPROMSIZE_WORDS_R4,
--				 SSB_SPROMSIZE_WORDS_R10, };
-+				 SSB_SPROMSIZE_WORDS_R10,
-+				 SSB_SPROMSIZE_WORDS_R11, };
- 	int i, err = 0;
- 
- 	if (!bus->drv_cc.core)
---- a/include/linux/bcma/bcma.h
-+++ b/include/linux/bcma/bcma.h
-@@ -319,6 +319,7 @@ struct bcma_bus {
- 	const struct bcma_host_ops *ops;
- 
- 	enum bcma_hosttype hosttype;
-+	bool host_is_pcie2; /* Used for BCMA_HOSTTYPE_PCI only */
- 	union {
- 		/* Pointer to the PCI bus (only for BCMA_HOSTTYPE_PCI) */
- 		struct pci_dev *host_pci;
---- a/include/linux/bcma/bcma_driver_pci.h
-+++ b/include/linux/bcma/bcma_driver_pci.h
-@@ -223,6 +223,7 @@ struct bcma_drv_pci_host {
- 
- struct bcma_drv_pci {
- 	struct bcma_device *core;
-+	u8 early_setup_done:1;
- 	u8 setup_done:1;
- 	u8 hostmode:1;
- 
-@@ -237,6 +238,7 @@ struct bcma_drv_pci {
- #define pcicore_write16(pc, offset, val)	bcma_write16((pc)->core, offset, val)
- #define pcicore_write32(pc, offset, val)	bcma_write32((pc)->core, offset, val)
- 
-+extern void bcma_core_pci_early_init(struct bcma_drv_pci *pc);
- extern void bcma_core_pci_init(struct bcma_drv_pci *pc);
- extern int bcma_core_pci_irq_ctl(struct bcma_drv_pci *pc,
- 				 struct bcma_device *core, bool enable);
---- a/include/linux/bcma/bcma_regs.h
-+++ b/include/linux/bcma/bcma_regs.h
-@@ -64,6 +64,8 @@
- #define  BCMA_PCI_GPIO_XTAL		0x40	/* PCI config space GPIO 14 for Xtal powerup */
- #define  BCMA_PCI_GPIO_PLL		0x80	/* PCI config space GPIO 15 for PLL powerdown */
- 
-+#define BCMA_PCIE2_BAR0_WIN2		0x70
-+
- /* SiliconBackplane Address Map.
-  * All regions may not exist on all chips.
-  */
---- a/include/linux/bcma/bcma_soc.h
-+++ b/include/linux/bcma/bcma_soc.h
-@@ -5,8 +5,6 @@
- 
- struct bcma_soc {
- 	struct bcma_bus bus;
--	struct bcma_device core_cc;
--	struct bcma_device core_mips;
- };
- 
- int __init bcma_host_soc_register(struct bcma_soc *soc);
---- a/include/linux/ssb/ssb_regs.h
-+++ b/include/linux/ssb/ssb_regs.h
-@@ -173,6 +173,7 @@
- #define SSB_SPROMSIZE_BYTES_R123	(SSB_SPROMSIZE_WORDS_R123 * sizeof(u16))
- #define SSB_SPROMSIZE_BYTES_R4		(SSB_SPROMSIZE_WORDS_R4 * sizeof(u16))
- #define SSB_SPROMSIZE_WORDS_R10		230
-+#define SSB_SPROMSIZE_WORDS_R11		234
- #define SSB_SPROM_BASE1			0x1000
- #define SSB_SPROM_BASE31		0x0800
- #define SSB_SPROM_REVISION		0x007E
--- a/target/linux/generic/pending-3.18/027-bcma-from-4.1.patch	2022-03-22 08:54:47.249464739 +0800
+++ b/target/linux/generic/pending-3.18/027-bcma-from-4.1.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,680 +0,0 @@
---- a/drivers/bcma/bcma_private.h
-+++ b/drivers/bcma/bcma_private.h
-@@ -24,6 +24,7 @@ bool bcma_wait_value(struct bcma_device
- 		     int timeout);
- void bcma_prepare_core(struct bcma_bus *bus, struct bcma_device *core);
- void bcma_init_bus(struct bcma_bus *bus);
-+void bcma_unregister_cores(struct bcma_bus *bus);
- int bcma_bus_register(struct bcma_bus *bus);
- void bcma_bus_unregister(struct bcma_bus *bus);
- int __init bcma_bus_early_register(struct bcma_bus *bus);
-@@ -40,6 +41,9 @@ int bcma_bus_scan(struct bcma_bus *bus);
- int bcma_sprom_get(struct bcma_bus *bus);
- 
- /* driver_chipcommon.c */
-+void bcma_core_chipcommon_early_init(struct bcma_drv_cc *cc);
-+void bcma_core_chipcommon_init(struct bcma_drv_cc *cc);
-+void bcma_chipco_bcm4331_ext_pa_lines_ctl(struct bcma_drv_cc *cc, bool enable);
- #ifdef CONFIG_BCMA_DRIVER_MIPS
- void bcma_chipco_serial_init(struct bcma_drv_cc *cc);
- extern struct platform_device bcma_pflash_dev;
-@@ -50,6 +54,8 @@ int bcma_core_chipcommon_b_init(struct b
- void bcma_core_chipcommon_b_free(struct bcma_drv_cc_b *ccb);
- 
- /* driver_chipcommon_pmu.c */
-+void bcma_pmu_early_init(struct bcma_drv_cc *cc);
-+void bcma_pmu_init(struct bcma_drv_cc *cc);
- u32 bcma_pmu_get_alp_clock(struct bcma_drv_cc *cc);
- u32 bcma_pmu_get_cpu_clock(struct bcma_drv_cc *cc);
- 
-@@ -98,7 +104,35 @@ static inline void __exit bcma_host_soc_
- #endif /* CONFIG_BCMA_HOST_SOC && CONFIG_OF */
- 
- /* driver_pci.c */
-+#ifdef CONFIG_BCMA_DRIVER_PCI
- u32 bcma_pcie_read(struct bcma_drv_pci *pc, u32 address);
-+void bcma_core_pci_early_init(struct bcma_drv_pci *pc);
-+void bcma_core_pci_init(struct bcma_drv_pci *pc);
-+void bcma_core_pci_up(struct bcma_drv_pci *pc);
-+void bcma_core_pci_down(struct bcma_drv_pci *pc);
-+#else
-+static inline void bcma_core_pci_early_init(struct bcma_drv_pci *pc)
-+{
-+	WARN_ON(pc->core->bus->hosttype == BCMA_HOSTTYPE_PCI);
-+}
-+static inline void bcma_core_pci_init(struct bcma_drv_pci *pc)
-+{
-+	/* Initialization is required for PCI hosted bus */
-+	WARN_ON(pc->core->bus->hosttype == BCMA_HOSTTYPE_PCI);
-+}
-+#endif
-+
-+/* driver_pcie2.c */
-+#ifdef CONFIG_BCMA_DRIVER_PCI
-+void bcma_core_pcie2_init(struct bcma_drv_pcie2 *pcie2);
-+void bcma_core_pcie2_up(struct bcma_drv_pcie2 *pcie2);
-+#else
-+static inline void bcma_core_pcie2_init(struct bcma_drv_pcie2 *pcie2)
-+{
-+	/* Initialization is required for PCI hosted bus */
-+	WARN_ON(pcie2->core->bus->hosttype == BCMA_HOSTTYPE_PCI);
-+}
-+#endif
- 
- extern int bcma_chipco_watchdog_register(struct bcma_drv_cc *cc);
- 
-@@ -115,6 +149,39 @@ static inline void bcma_core_pci_hostmod
- }
- #endif /* CONFIG_BCMA_DRIVER_PCI_HOSTMODE */
- 
-+/**************************************************
-+ * driver_mips.c
-+ **************************************************/
-+
-+#ifdef CONFIG_BCMA_DRIVER_MIPS
-+unsigned int bcma_core_mips_irq(struct bcma_device *dev);
-+void bcma_core_mips_early_init(struct bcma_drv_mips *mcore);
-+void bcma_core_mips_init(struct bcma_drv_mips *mcore);
-+#else
-+static inline unsigned int bcma_core_mips_irq(struct bcma_device *dev)
-+{
-+	return 0;
-+}
-+static inline void bcma_core_mips_early_init(struct bcma_drv_mips *mcore)
-+{
-+}
-+static inline void bcma_core_mips_init(struct bcma_drv_mips *mcore)
-+{
-+}
-+#endif
-+
-+/**************************************************
-+ * driver_gmac_cmn.c
-+ **************************************************/
-+
-+#ifdef CONFIG_BCMA_DRIVER_GMAC_CMN
-+void bcma_core_gmac_cmn_init(struct bcma_drv_gmac_cmn *gc);
-+#else
-+static inline void bcma_core_gmac_cmn_init(struct bcma_drv_gmac_cmn *gc)
-+{
-+}
-+#endif
-+
- #ifdef CONFIG_BCMA_DRIVER_GPIO
- /* driver_gpio.c */
- int bcma_gpio_init(struct bcma_drv_cc *cc);
---- a/drivers/bcma/driver_gpio.c
-+++ b/drivers/bcma/driver_gpio.c
-@@ -17,6 +17,8 @@
- 
- #include "bcma_private.h"
- 
-+#define BCMA_GPIO_MAX_PINS	32
-+
- static inline struct bcma_drv_cc *bcma_gpio_get_cc(struct gpio_chip *chip)
- {
- 	return container_of(chip, struct bcma_drv_cc, gpio);
-@@ -76,7 +78,7 @@ static void bcma_gpio_free(struct gpio_c
- 	bcma_chipco_gpio_pullup(cc, 1 << gpio, 0);
- }
- 
--#if IS_BUILTIN(CONFIG_BCM47XX)
-+#if IS_BUILTIN(CONFIG_BCM47XX) || IS_BUILTIN(CONFIG_ARCH_BCM_5301X)
- static int bcma_gpio_to_irq(struct gpio_chip *chip, unsigned gpio)
- {
- 	struct bcma_drv_cc *cc = bcma_gpio_get_cc(chip);
-@@ -204,6 +206,7 @@ static void bcma_gpio_irq_domain_exit(st
- 
- int bcma_gpio_init(struct bcma_drv_cc *cc)
- {
-+	struct bcma_bus *bus = cc->core->bus;
- 	struct gpio_chip *chip = &cc->gpio;
- 	int err;
- 
-@@ -215,14 +218,14 @@ int bcma_gpio_init(struct bcma_drv_cc *c
- 	chip->set		= bcma_gpio_set_value;
- 	chip->direction_input	= bcma_gpio_direction_input;
- 	chip->direction_output	= bcma_gpio_direction_output;
--#if IS_BUILTIN(CONFIG_BCM47XX)
-+#if IS_BUILTIN(CONFIG_BCM47XX) || IS_BUILTIN(CONFIG_ARCH_BCM_5301X)
- 	chip->to_irq		= bcma_gpio_to_irq;
- #endif
- #if IS_BUILTIN(CONFIG_OF)
- 	if (cc->core->bus->hosttype == BCMA_HOSTTYPE_SOC)
- 		chip->of_node	= cc->core->dev.of_node;
- #endif
--	switch (cc->core->bus->chipinfo.id) {
-+	switch (bus->chipinfo.id) {
- 	case BCMA_CHIP_ID_BCM5357:
- 	case BCMA_CHIP_ID_BCM53572:
- 		chip->ngpio	= 32;
-@@ -231,13 +234,17 @@ int bcma_gpio_init(struct bcma_drv_cc *c
- 		chip->ngpio	= 16;
- 	}
- 
--	/* There is just one SoC in one device and its GPIO addresses should be
--	 * deterministic to address them more easily. The other buses could get
--	 * a random base number. */
--	if (cc->core->bus->hosttype == BCMA_HOSTTYPE_SOC)
--		chip->base		= 0;
--	else
--		chip->base		= -1;
-+	/*
-+	 * On MIPS we register GPIO devices (LEDs, buttons) using absolute GPIO
-+	 * pin numbers. We don't have Device Tree there and we can't really use
-+	 * relative (per chip) numbers.
-+	 * So let's use predictable base for BCM47XX and "random" for all other.
-+	 */
-+#if IS_BUILTIN(CONFIG_BCM47XX)
-+	chip->base		= bus->num * BCMA_GPIO_MAX_PINS;
-+#else
-+	chip->base		= -1;
-+#endif
- 
- 	err = bcma_gpio_irq_domain_init(cc);
- 	if (err)
---- a/drivers/bcma/driver_pci.c
-+++ b/drivers/bcma/driver_pci.c
-@@ -282,39 +282,6 @@ void bcma_core_pci_power_save(struct bcm
- }
- EXPORT_SYMBOL_GPL(bcma_core_pci_power_save);
- 
--int bcma_core_pci_irq_ctl(struct bcma_drv_pci *pc, struct bcma_device *core,
--			  bool enable)
--{
--	struct pci_dev *pdev;
--	u32 coremask, tmp;
--	int err = 0;
--
--	if (!pc || core->bus->hosttype != BCMA_HOSTTYPE_PCI) {
--		/* This bcma device is not on a PCI host-bus. So the IRQs are
--		 * not routed through the PCI core.
--		 * So we must not enable routing through the PCI core. */
--		goto out;
--	}
--
--	pdev = pc->core->bus->host_pci;
--
--	err = pci_read_config_dword(pdev, BCMA_PCI_IRQMASK, &tmp);
--	if (err)
--		goto out;
--
--	coremask = BIT(core->core_index) << 8;
--	if (enable)
--		tmp |= coremask;
--	else
--		tmp &= ~coremask;
--
--	err = pci_write_config_dword(pdev, BCMA_PCI_IRQMASK, tmp);
--
--out:
--	return err;
--}
--EXPORT_SYMBOL_GPL(bcma_core_pci_irq_ctl);
--
- static void bcma_core_pci_extend_L1timer(struct bcma_drv_pci *pc, bool extend)
- {
- 	u32 w;
-@@ -328,28 +295,12 @@ static void bcma_core_pci_extend_L1timer
- 	bcma_pcie_read(pc, BCMA_CORE_PCI_DLLP_PMTHRESHREG);
- }
- 
--void bcma_core_pci_up(struct bcma_bus *bus)
-+void bcma_core_pci_up(struct bcma_drv_pci *pc)
- {
--	struct bcma_drv_pci *pc;
--
--	if (bus->hosttype != BCMA_HOSTTYPE_PCI)
--		return;
--
--	pc = &bus->drv_pci[0];
--
- 	bcma_core_pci_extend_L1timer(pc, true);
- }
--EXPORT_SYMBOL_GPL(bcma_core_pci_up);
- 
--void bcma_core_pci_down(struct bcma_bus *bus)
-+void bcma_core_pci_down(struct bcma_drv_pci *pc)
- {
--	struct bcma_drv_pci *pc;
--
--	if (bus->hosttype != BCMA_HOSTTYPE_PCI)
--		return;
--
--	pc = &bus->drv_pci[0];
--
- 	bcma_core_pci_extend_L1timer(pc, false);
- }
--EXPORT_SYMBOL_GPL(bcma_core_pci_down);
---- a/drivers/bcma/driver_pci_host.c
-+++ b/drivers/bcma/driver_pci_host.c
-@@ -11,6 +11,7 @@
- 
- #include "bcma_private.h"
- #include <linux/pci.h>
-+#include <linux/slab.h>
- #include <linux/export.h>
- #include <linux/bcma/bcma.h>
- #include <asm/paccess.h>
---- a/drivers/bcma/driver_pcie2.c
-+++ b/drivers/bcma/driver_pcie2.c
-@@ -10,6 +10,7 @@
- 
- #include "bcma_private.h"
- #include <linux/bcma/bcma.h>
-+#include <linux/pci.h>
- 
- /**************************************************
-  * R/W ops.
-@@ -156,14 +157,23 @@ static void pciedev_reg_pm_clk_period(st
- 
- void bcma_core_pcie2_init(struct bcma_drv_pcie2 *pcie2)
- {
--	struct bcma_chipinfo *ci = &pcie2->core->bus->chipinfo;
-+	struct bcma_bus *bus = pcie2->core->bus;
-+	struct bcma_chipinfo *ci = &bus->chipinfo;
- 	u32 tmp;
- 
- 	tmp = pcie2_read32(pcie2, BCMA_CORE_PCIE2_SPROM(54));
- 	if ((tmp & 0xe) >> 1 == 2)
- 		bcma_core_pcie2_cfg_write(pcie2, 0x4e0, 0x17);
- 
--	/* TODO: Do we need pcie_reqsize? */
-+	switch (bus->chipinfo.id) {
-+	case BCMA_CHIP_ID_BCM4360:
-+	case BCMA_CHIP_ID_BCM4352:
-+		pcie2->reqsize = 1024;
-+		break;
-+	default:
-+		pcie2->reqsize = 128;
-+		break;
-+	}
- 
- 	if (ci->id == BCMA_CHIP_ID_BCM4360 && ci->rev > 3)
- 		bcma_core_pcie2_war_delay_perst_enab(pcie2, true);
-@@ -173,3 +183,18 @@ void bcma_core_pcie2_init(struct bcma_dr
- 	pciedev_crwlpciegen2_180(pcie2);
- 	pciedev_crwlpciegen2_182(pcie2);
- }
-+
-+/**************************************************
-+ * Runtime ops.
-+ **************************************************/
-+
-+void bcma_core_pcie2_up(struct bcma_drv_pcie2 *pcie2)
-+{
-+	struct bcma_bus *bus = pcie2->core->bus;
-+	struct pci_dev *dev = bus->host_pci;
-+	int err;
-+
-+	err = pcie_set_readrq(dev, pcie2->reqsize);
-+	if (err)
-+		bcma_err(bus, "Error setting PCI_EXP_DEVCTL_READRQ: %d\n", err);
-+}
---- a/drivers/bcma/host_pci.c
-+++ b/drivers/bcma/host_pci.c
-@@ -213,16 +213,26 @@ static int bcma_host_pci_probe(struct pc
- 	/* Initialize struct, detect chip */
- 	bcma_init_bus(bus);
- 
-+	/* Scan bus to find out generation of PCIe core */
-+	err = bcma_bus_scan(bus);
-+	if (err)
-+		goto err_pci_unmap_mmio;
-+
-+	if (bcma_find_core(bus, BCMA_CORE_PCIE2))
-+		bus->host_is_pcie2 = true;
-+
- 	/* Register */
- 	err = bcma_bus_register(bus);
- 	if (err)
--		goto err_pci_unmap_mmio;
-+		goto err_unregister_cores;
- 
- 	pci_set_drvdata(dev, bus);
- 
- out:
- 	return err;
- 
-+err_unregister_cores:
-+	bcma_unregister_cores(bus);
- err_pci_unmap_mmio:
- 	pci_iounmap(dev, bus->mmio);
- err_pci_release_regions:
-@@ -283,9 +293,12 @@ static const struct pci_device_id bcma_p
- 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4357) },
- 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4358) },
- 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4359) },
-+	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4360) },
- 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4365) },
-+	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x43a0) },
- 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x43a9) },
- 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x43aa) },
-+	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x43b1) },
- 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4727) },
- 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 43227) },	/* 0xa8db, BCM43217 (sic!) */
- 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 43228) },	/* 0xa8dc */
-@@ -310,3 +323,65 @@ void __exit bcma_host_pci_exit(void)
- {
- 	pci_unregister_driver(&bcma_pci_bridge_driver);
- }
-+
-+/**************************************************
-+ * Runtime ops for drivers.
-+ **************************************************/
-+
-+/* See also pcicore_up */
-+void bcma_host_pci_up(struct bcma_bus *bus)
-+{
-+	if (bus->hosttype != BCMA_HOSTTYPE_PCI)
-+		return;
-+
-+	if (bus->host_is_pcie2)
-+		bcma_core_pcie2_up(&bus->drv_pcie2);
-+	else
-+		bcma_core_pci_up(&bus->drv_pci[0]);
-+}
-+EXPORT_SYMBOL_GPL(bcma_host_pci_up);
-+
-+/* See also pcicore_down */
-+void bcma_host_pci_down(struct bcma_bus *bus)
-+{
-+	if (bus->hosttype != BCMA_HOSTTYPE_PCI)
-+		return;
-+
-+	if (!bus->host_is_pcie2)
-+		bcma_core_pci_down(&bus->drv_pci[0]);
-+}
-+EXPORT_SYMBOL_GPL(bcma_host_pci_down);
-+
-+/* See also si_pci_setup */
-+int bcma_host_pci_irq_ctl(struct bcma_bus *bus, struct bcma_device *core,
-+			  bool enable)
-+{
-+	struct pci_dev *pdev;
-+	u32 coremask, tmp;
-+	int err = 0;
-+
-+	if (bus->hosttype != BCMA_HOSTTYPE_PCI) {
-+		/* This bcma device is not on a PCI host-bus. So the IRQs are
-+		 * not routed through the PCI core.
-+		 * So we must not enable routing through the PCI core. */
-+		goto out;
-+	}
-+
-+	pdev = bus->host_pci;
-+
-+	err = pci_read_config_dword(pdev, BCMA_PCI_IRQMASK, &tmp);
-+	if (err)
-+		goto out;
-+
-+	coremask = BIT(core->core_index) << 8;
-+	if (enable)
-+		tmp |= coremask;
-+	else
-+		tmp &= ~coremask;
-+
-+	err = pci_write_config_dword(pdev, BCMA_PCI_IRQMASK, tmp);
-+
-+out:
-+	return err;
-+}
-+EXPORT_SYMBOL_GPL(bcma_host_pci_irq_ctl);
---- a/drivers/bcma/main.c
-+++ b/drivers/bcma/main.c
-@@ -363,7 +363,7 @@ static int bcma_register_devices(struct
- 	return 0;
- }
- 
--static void bcma_unregister_cores(struct bcma_bus *bus)
-+void bcma_unregister_cores(struct bcma_bus *bus)
- {
- 	struct bcma_device *core, *tmp;
- 
---- a/drivers/net/wireless/b43/main.c
-+++ b/drivers/net/wireless/b43/main.c
-@@ -4770,7 +4770,7 @@ static void b43_wireless_core_exit(struc
- 	switch (dev->dev->bus_type) {
- #ifdef CONFIG_B43_BCMA
- 	case B43_BUS_BCMA:
--		bcma_core_pci_down(dev->dev->bdev->bus);
-+		bcma_host_pci_down(dev->dev->bdev->bus);
- 		break;
- #endif
- #ifdef CONFIG_B43_SSB
-@@ -4817,9 +4817,9 @@ static int b43_wireless_core_init(struct
- 	switch (dev->dev->bus_type) {
- #ifdef CONFIG_B43_BCMA
- 	case B43_BUS_BCMA:
--		bcma_core_pci_irq_ctl(&dev->dev->bdev->bus->drv_pci[0],
-+		bcma_host_pci_irq_ctl(dev->dev->bdev->bus,
- 				      dev->dev->bdev, true);
--		bcma_core_pci_up(dev->dev->bdev->bus);
-+		bcma_host_pci_up(dev->dev->bdev->bus);
- 		break;
- #endif
- #ifdef CONFIG_B43_SSB
---- a/drivers/net/wireless/brcm80211/brcmsmac/main.c
-+++ b/drivers/net/wireless/brcm80211/brcmsmac/main.c
-@@ -4669,7 +4669,7 @@ static int brcms_b_attach(struct brcms_c
- 	brcms_c_coredisable(wlc_hw);
- 
- 	/* Match driver "down" state */
--	bcma_core_pci_down(wlc_hw->d11core->bus);
-+	bcma_host_pci_down(wlc_hw->d11core->bus);
- 
- 	/* turn off pll and xtal to match driver "down" state */
- 	brcms_b_xtal(wlc_hw, OFF);
-@@ -4960,7 +4960,7 @@ static int brcms_b_up_prep(struct brcms_
- 	 * Configure pci/pcmcia here instead of in brcms_c_attach()
- 	 * to allow mfg hotswap:  down, hotswap (chip power cycle), up.
- 	 */
--	bcma_core_pci_irq_ctl(&wlc_hw->d11core->bus->drv_pci[0], wlc_hw->d11core,
-+	bcma_host_pci_irq_ctl(wlc_hw->d11core->bus, wlc_hw->d11core,
- 			      true);
- 
- 	/*
-@@ -4970,12 +4970,12 @@ static int brcms_b_up_prep(struct brcms_
- 	 */
- 	if (brcms_b_radio_read_hwdisabled(wlc_hw)) {
- 		/* put SB PCI in down state again */
--		bcma_core_pci_down(wlc_hw->d11core->bus);
-+		bcma_host_pci_down(wlc_hw->d11core->bus);
- 		brcms_b_xtal(wlc_hw, OFF);
- 		return -ENOMEDIUM;
- 	}
- 
--	bcma_core_pci_up(wlc_hw->d11core->bus);
-+	bcma_host_pci_up(wlc_hw->d11core->bus);
- 
- 	/* reset the d11 core */
- 	brcms_b_corereset(wlc_hw, BRCMS_USE_COREFLAGS);
-@@ -5172,7 +5172,7 @@ static int brcms_b_down_finish(struct br
- 
- 		/* turn off primary xtal and pll */
- 		if (!wlc_hw->noreset) {
--			bcma_core_pci_down(wlc_hw->d11core->bus);
-+			bcma_host_pci_down(wlc_hw->d11core->bus);
- 			brcms_b_xtal(wlc_hw, OFF);
- 		}
- 	}
---- a/include/linux/bcma/bcma.h
-+++ b/include/linux/bcma/bcma.h
-@@ -435,6 +435,27 @@ static inline struct bcma_device *bcma_f
- 	return bcma_find_core_unit(bus, coreid, 0);
- }
- 
-+#ifdef CONFIG_BCMA_HOST_PCI
-+extern void bcma_host_pci_up(struct bcma_bus *bus);
-+extern void bcma_host_pci_down(struct bcma_bus *bus);
-+extern int bcma_host_pci_irq_ctl(struct bcma_bus *bus,
-+				 struct bcma_device *core, bool enable);
-+#else
-+static inline void bcma_host_pci_up(struct bcma_bus *bus)
-+{
-+}
-+static inline void bcma_host_pci_down(struct bcma_bus *bus)
-+{
-+}
-+static inline int bcma_host_pci_irq_ctl(struct bcma_bus *bus,
-+					struct bcma_device *core, bool enable)
-+{
-+	if (bus->hosttype == BCMA_HOSTTYPE_PCI)
-+		return -ENOTSUPP;
-+	return 0;
-+}
-+#endif
-+
- extern bool bcma_core_is_enabled(struct bcma_device *core);
- extern void bcma_core_disable(struct bcma_device *core, u32 flags);
- extern int bcma_core_enable(struct bcma_device *core, u32 flags);
---- a/include/linux/bcma/bcma_driver_pci.h
-+++ b/include/linux/bcma/bcma_driver_pci.h
-@@ -238,13 +238,13 @@ struct bcma_drv_pci {
- #define pcicore_write16(pc, offset, val)	bcma_write16((pc)->core, offset, val)
- #define pcicore_write32(pc, offset, val)	bcma_write32((pc)->core, offset, val)
- 
--extern void bcma_core_pci_early_init(struct bcma_drv_pci *pc);
--extern void bcma_core_pci_init(struct bcma_drv_pci *pc);
--extern int bcma_core_pci_irq_ctl(struct bcma_drv_pci *pc,
--				 struct bcma_device *core, bool enable);
--extern void bcma_core_pci_up(struct bcma_bus *bus);
--extern void bcma_core_pci_down(struct bcma_bus *bus);
-+#ifdef CONFIG_BCMA_DRIVER_PCI
- extern void bcma_core_pci_power_save(struct bcma_bus *bus, bool up);
-+#else
-+static inline void bcma_core_pci_power_save(struct bcma_bus *bus, bool up)
-+{
-+}
-+#endif
- 
- extern int bcma_core_pci_pcibios_map_irq(const struct pci_dev *dev);
- extern int bcma_core_pci_plat_dev_init(struct pci_dev *dev);
---- a/include/linux/bcma/bcma_driver_pcie2.h
-+++ b/include/linux/bcma/bcma_driver_pcie2.h
-@@ -143,6 +143,8 @@
- 
- struct bcma_drv_pcie2 {
- 	struct bcma_device *core;
-+
-+	u16 reqsize;
- };
- 
- #define pcie2_read16(pcie2, offset)		bcma_read16((pcie2)->core, offset)
-@@ -153,6 +155,4 @@ struct bcma_drv_pcie2 {
- #define pcie2_set32(pcie2, offset, set)		bcma_set32((pcie2)->core, offset, set)
- #define pcie2_mask32(pcie2, offset, mask)	bcma_mask32((pcie2)->core, offset, mask)
- 
--void bcma_core_pcie2_init(struct bcma_drv_pcie2 *pcie2);
--
- #endif /* LINUX_BCMA_DRIVER_PCIE2_H_ */
---- a/drivers/bcma/Kconfig
-+++ b/drivers/bcma/Kconfig
-@@ -26,6 +26,7 @@ config BCMA_HOST_PCI_POSSIBLE
- config BCMA_HOST_PCI
- 	bool "Support for BCMA on PCI-host bus"
- 	depends on BCMA_HOST_PCI_POSSIBLE
-+	select BCMA_DRIVER_PCI
- 	default y
- 
- config BCMA_DRIVER_PCI_HOSTMODE
-@@ -44,6 +45,22 @@ config BCMA_HOST_SOC
- 
- 	  If unsure, say N
- 
-+config BCMA_DRIVER_PCI
-+	bool "BCMA Broadcom PCI core driver"
-+	depends on BCMA && PCI
-+	default y
-+	help
-+	  BCMA bus may have many versions of PCIe core. This driver
-+	  supports:
-+	  1) PCIe core working in clientmode
-+	  2) PCIe Gen 2 clientmode core
-+
-+	  In general PCIe (Gen 2) clientmode core is required on PCIe
-+	  hosted buses. It's responsible for initialization and basic
-+	  hardware management.
-+	  This driver is also prerequisite for a hostmode PCIe core
-+	  support.
-+
- config BCMA_DRIVER_MIPS
- 	bool "BCMA Broadcom MIPS core driver"
- 	depends on BCMA && MIPS
---- a/drivers/bcma/Makefile
-+++ b/drivers/bcma/Makefile
-@@ -3,8 +3,8 @@ bcma-y					+= driver_chipcommon.o driver
- bcma-y					+= driver_chipcommon_b.o
- bcma-$(CONFIG_BCMA_SFLASH)		+= driver_chipcommon_sflash.o
- bcma-$(CONFIG_BCMA_NFLASH)		+= driver_chipcommon_nflash.o
--bcma-y					+= driver_pci.o
--bcma-y					+= driver_pcie2.o
-+bcma-$(CONFIG_BCMA_DRIVER_PCI)		+= driver_pci.o
-+bcma-$(CONFIG_BCMA_DRIVER_PCI)		+= driver_pcie2.o
- bcma-$(CONFIG_BCMA_DRIVER_PCI_HOSTMODE)	+= driver_pci_host.o
- bcma-$(CONFIG_BCMA_DRIVER_MIPS)		+= driver_mips.o
- bcma-$(CONFIG_BCMA_DRIVER_GMAC_CMN)	+= driver_gmac_cmn.o
---- a/include/linux/bcma/bcma_driver_chipcommon.h
-+++ b/include/linux/bcma/bcma_driver_chipcommon.h
-@@ -663,14 +663,6 @@ struct bcma_drv_cc_b {
- #define bcma_cc_maskset32(cc, offset, mask, set) \
- 	bcma_cc_write32(cc, offset, (bcma_cc_read32(cc, offset) & (mask)) | (set))
- 
--extern void bcma_core_chipcommon_init(struct bcma_drv_cc *cc);
--extern void bcma_core_chipcommon_early_init(struct bcma_drv_cc *cc);
--
--extern void bcma_chipco_suspend(struct bcma_drv_cc *cc);
--extern void bcma_chipco_resume(struct bcma_drv_cc *cc);
--
--void bcma_chipco_bcm4331_ext_pa_lines_ctl(struct bcma_drv_cc *cc, bool enable);
--
- extern u32 bcma_chipco_watchdog_timer_set(struct bcma_drv_cc *cc, u32 ticks);
- 
- extern u32 bcma_chipco_get_alp_clock(struct bcma_drv_cc *cc);
-@@ -690,9 +682,6 @@ u32 bcma_chipco_gpio_pullup(struct bcma_
- u32 bcma_chipco_gpio_pulldown(struct bcma_drv_cc *cc, u32 mask, u32 value);
- 
- /* PMU support */
--extern void bcma_pmu_init(struct bcma_drv_cc *cc);
--extern void bcma_pmu_early_init(struct bcma_drv_cc *cc);
--
- extern void bcma_chipco_pll_write(struct bcma_drv_cc *cc, u32 offset,
- 				  u32 value);
- extern void bcma_chipco_pll_maskset(struct bcma_drv_cc *cc, u32 offset,
---- a/include/linux/bcma/bcma_driver_gmac_cmn.h
-+++ b/include/linux/bcma/bcma_driver_gmac_cmn.h
-@@ -91,10 +91,4 @@ struct bcma_drv_gmac_cmn {
- #define gmac_cmn_write16(gc, offset, val)	bcma_write16((gc)->core, offset, val)
- #define gmac_cmn_write32(gc, offset, val)	bcma_write32((gc)->core, offset, val)
- 
--#ifdef CONFIG_BCMA_DRIVER_GMAC_CMN
--extern void bcma_core_gmac_cmn_init(struct bcma_drv_gmac_cmn *gc);
--#else
--static inline void bcma_core_gmac_cmn_init(struct bcma_drv_gmac_cmn *gc) { }
--#endif
--
- #endif /* LINUX_BCMA_DRIVER_GMAC_CMN_H_ */
---- a/include/linux/bcma/bcma_driver_mips.h
-+++ b/include/linux/bcma/bcma_driver_mips.h
-@@ -39,21 +39,6 @@ struct bcma_drv_mips {
- 	u8 early_setup_done:1;
- };
- 
--#ifdef CONFIG_BCMA_DRIVER_MIPS
--extern void bcma_core_mips_init(struct bcma_drv_mips *mcore);
--extern void bcma_core_mips_early_init(struct bcma_drv_mips *mcore);
--
--extern unsigned int bcma_core_mips_irq(struct bcma_device *dev);
--#else
--static inline void bcma_core_mips_init(struct bcma_drv_mips *mcore) { }
--static inline void bcma_core_mips_early_init(struct bcma_drv_mips *mcore) { }
--
--static inline unsigned int bcma_core_mips_irq(struct bcma_device *dev)
--{
--	return 0;
--}
--#endif
--
- extern u32 bcma_cpu_clock(struct bcma_drv_mips *mcore);
- 
- #endif /* LINUX_BCMA_DRIVER_MIPS_H_ */
--- a/target/linux/generic/pending-3.18/028-bcma-from-4.2.patch	2022-03-22 08:54:47.250464741 +0800
+++ b/target/linux/generic/pending-3.18/028-bcma-from-4.2.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,86 +0,0 @@
---- a/drivers/bcma/driver_gpio.c
-+++ b/drivers/bcma/driver_gpio.c
-@@ -226,6 +226,7 @@ int bcma_gpio_init(struct bcma_drv_cc *c
- 		chip->of_node	= cc->core->dev.of_node;
- #endif
- 	switch (bus->chipinfo.id) {
-+	case BCMA_CHIP_ID_BCM4707:
- 	case BCMA_CHIP_ID_BCM5357:
- 	case BCMA_CHIP_ID_BCM53572:
- 		chip->ngpio	= 32;
-@@ -235,16 +236,17 @@ int bcma_gpio_init(struct bcma_drv_cc *c
- 	}
- 
- 	/*
--	 * On MIPS we register GPIO devices (LEDs, buttons) using absolute GPIO
--	 * pin numbers. We don't have Device Tree there and we can't really use
--	 * relative (per chip) numbers.
--	 * So let's use predictable base for BCM47XX and "random" for all other.
-+	 * Register SoC GPIO devices with absolute GPIO pin base.
-+	 * On MIPS, we don't have Device Tree and we can't use relative (per chip)
-+	 * GPIO numbers.
-+	 * On some ARM devices, user space may want to access some system GPIO
-+	 * pins directly, which is easier to do with a predictable GPIO base.
- 	 */
--#if IS_BUILTIN(CONFIG_BCM47XX)
--	chip->base		= bus->num * BCMA_GPIO_MAX_PINS;
--#else
--	chip->base		= -1;
--#endif
-+	if (IS_BUILTIN(CONFIG_BCM47XX) ||
-+	    cc->core->bus->hosttype == BCMA_HOSTTYPE_SOC)
-+		chip->base		= bus->num * BCMA_GPIO_MAX_PINS;
-+	else
-+		chip->base		= -1;
- 
- 	err = bcma_gpio_irq_domain_init(cc);
- 	if (err)
---- a/drivers/bcma/Kconfig
-+++ b/drivers/bcma/Kconfig
-@@ -29,12 +29,6 @@ config BCMA_HOST_PCI
- 	select BCMA_DRIVER_PCI
- 	default y
- 
--config BCMA_DRIVER_PCI_HOSTMODE
--	bool "Driver for PCI core working in hostmode"
--	depends on BCMA && MIPS && BCMA_HOST_PCI
--	help
--	  PCI core hostmode operation (external PCI bus).
--
- config BCMA_HOST_SOC
- 	bool "Support for BCMA in a SoC"
- 	depends on BCMA
-@@ -61,6 +55,12 @@ config BCMA_DRIVER_PCI
- 	  This driver is also prerequisite for a hostmode PCIe core
- 	  support.
- 
-+config BCMA_DRIVER_PCI_HOSTMODE
-+	bool "Driver for PCI core working in hostmode"
-+	depends on BCMA && MIPS && BCMA_DRIVER_PCI
-+	help
-+	  PCI core hostmode operation (external PCI bus).
-+
- config BCMA_DRIVER_MIPS
- 	bool "BCMA Broadcom MIPS core driver"
- 	depends on BCMA && MIPS
---- a/include/linux/bcma/bcma_driver_pci.h
-+++ b/include/linux/bcma/bcma_driver_pci.h
-@@ -246,7 +246,18 @@ static inline void bcma_core_pci_power_s
- }
- #endif
- 
-+#ifdef CONFIG_BCMA_DRIVER_PCI_HOSTMODE
- extern int bcma_core_pci_pcibios_map_irq(const struct pci_dev *dev);
- extern int bcma_core_pci_plat_dev_init(struct pci_dev *dev);
-+#else
-+static inline int bcma_core_pci_pcibios_map_irq(const struct pci_dev *dev)
-+{
-+	return -ENOTSUPP;
-+}
-+static inline int bcma_core_pci_plat_dev_init(struct pci_dev *dev)
-+{
-+	return -ENOTSUPP;
-+}
-+#endif
- 
- #endif /* LINUX_BCMA_DRIVER_PCI_H_ */
--- a/target/linux/generic/pending-3.18/029-bcma-from-4.4.patch	2022-03-22 08:54:47.250464741 +0800
+++ b/target/linux/generic/pending-3.18/029-bcma-from-4.4.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,26 +0,0 @@
-commit 55acca90da52b85299c033354e51ddaa7b73e019
-Author: Hante Meuleman <meuleman@broadcom.com>
-Date:   Fri Sep 18 22:08:17 2015 +0200
-
-    brcmfmac: Add support for the BCM4365 and BCM4366 PCIE devices.
-    
-    This patch adds support for the BCM4365 and BCM4366 11ac Wave2
-    PCIE devices.
-    
-    Reviewed-by: Arend Van Spriel <arend@broadcom.com>
-    Reviewed-by: Pieter-Paul Giesberts <pieterpg@broadcom.com>
-    Signed-off-by: Hante Meuleman <meuleman@broadcom.com>
-    Signed-off-by: Arend van Spriel <arend@broadcom.com>
-    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
-
---- a/include/linux/bcma/bcma.h
-+++ b/include/linux/bcma/bcma.h
-@@ -151,6 +151,8 @@ struct bcma_host_ops {
- #define BCMA_CORE_PCIE2			0x83C	/* PCI Express Gen2 */
- #define BCMA_CORE_USB30_DEV		0x83D
- #define BCMA_CORE_ARM_CR4		0x83E
-+#define BCMA_CORE_ARM_CA7		0x847
-+#define BCMA_CORE_SYS_MEM		0x849
- #define BCMA_CORE_DEFAULT		0xFFF
- 
- #define BCMA_MAX_NR_CORES		16
--- a/target/linux/generic/pending-3.18/030-backport_bcm47xx_nvram.patch	2022-03-22 08:54:47.250464741 +0800
+++ b/target/linux/generic/pending-3.18/030-backport_bcm47xx_nvram.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,52 +0,0 @@
---- /dev/null
-+++ b/include/linux/bcm47xx_nvram.h
-@@ -0,0 +1,49 @@
-+/*
-+ *  This program is free software; you can redistribute  it and/or modify it
-+ *  under  the terms of  the GNU General  Public License as published by the
-+ *  Free Software Foundation;  either version 2 of the  License, or (at your
-+ *  option) any later version.
-+ */
-+
-+#ifndef __BCM47XX_NVRAM_H
-+#define __BCM47XX_NVRAM_H
-+
-+#include <linux/types.h>
-+#include <linux/kernel.h>
-+#include <linux/vmalloc.h>
-+
-+#ifdef CONFIG_BCM47XX_NVRAM
-+int bcm47xx_nvram_init_from_mem(u32 base, u32 lim);
-+int bcm47xx_nvram_getenv(const char *name, char *val, size_t val_len);
-+int bcm47xx_nvram_gpio_pin(const char *name);
-+char *bcm47xx_nvram_get_contents(size_t *val_len);
-+static inline void bcm47xx_nvram_release_contents(char *nvram)
-+{
-+	vfree(nvram);
-+};
-+#else
-+static inline int bcm47xx_nvram_init_from_mem(u32 base, u32 lim)
-+{
-+	return -ENOTSUPP;
-+};
-+static inline int bcm47xx_nvram_getenv(const char *name, char *val,
-+				       size_t val_len)
-+{
-+	return -ENOTSUPP;
-+};
-+static inline int bcm47xx_nvram_gpio_pin(const char *name)
-+{
-+	return -ENOTSUPP;
-+};
-+
-+static inline char *bcm47xx_nvram_get_contents(size_t *val_len)
-+{
-+	return NULL;
-+};
-+
-+static inline void bcm47xx_nvram_release_contents(char *nvram)
-+{
-+};
-+#endif
-+
-+#endif /* __BCM47XX_NVRAM_H */
--- a/target/linux/generic/pending-3.18/030-nl80211-Allow-set-network-namespace-by-fd.patch	2022-03-22 08:54:47.250464741 +0800
+++ b/target/linux/generic/pending-3.18/030-nl80211-Allow-set-network-namespace-by-fd.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,21 +0,0 @@
-From: Vadim Kochan <vadim4j@gmail.com>
-Date: Mon, 12 Jan 2015 16:34:05 +0200
-Subject: [PATCH] nl80211: Allow set network namespace by fd
-
-Added new NL80211_ATTR_NETNS_FD which allows to
-set namespace via nl80211 by fd.
-
-Signed-off-by: Vadim Kochan <vadim4j@gmail.com>
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/net/core/net_namespace.c
-+++ b/net/core/net_namespace.c
-@@ -380,6 +380,7 @@ struct net *get_net_ns_by_fd(int fd)
- 	return ERR_PTR(-EINVAL);
- }
- #endif
-+EXPORT_SYMBOL_GPL(get_net_ns_by_fd);
- 
- struct net *get_net_ns_by_pid(pid_t pid)
- {
--- a/target/linux/generic/pending-3.18/031-bcma-from-4.5.patch	2022-03-22 08:54:47.251464743 +0800
+++ b/target/linux/generic/pending-3.18/031-bcma-from-4.5.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,49 +0,0 @@
---- a/drivers/bcma/main.c
-+++ b/drivers/bcma/main.c
-@@ -637,11 +637,36 @@ static int bcma_device_uevent(struct dev
- 			      core->id.rev, core->id.class);
- }
- 
--static int __init bcma_modinit(void)
-+static unsigned int bcma_bus_registered;
-+
-+/*
-+ * If built-in, bus has to be registered early, before any driver calls
-+ * bcma_driver_register.
-+ * Otherwise registering driver would trigger BUG in driver_register.
-+ */
-+static int __init bcma_init_bus_register(void)
- {
- 	int err;
- 
-+	if (bcma_bus_registered)
-+		return 0;
-+
- 	err = bus_register(&bcma_bus_type);
-+	if (!err)
-+		bcma_bus_registered = 1;
-+
-+	return err;
-+}
-+#ifndef MODULE
-+fs_initcall(bcma_init_bus_register);
-+#endif
-+
-+/* Main initialization has to be done with SPI/mtd/NAND/SPROM available */
-+static int __init bcma_modinit(void)
-+{
-+	int err;
-+
-+	err = bcma_init_bus_register();
- 	if (err)
- 		return err;
- 
-@@ -660,7 +685,7 @@ static int __init bcma_modinit(void)
- 
- 	return err;
- }
--fs_initcall(bcma_modinit);
-+module_init(bcma_modinit);
- 
- static void __exit bcma_modexit(void)
- {
--- a/target/linux/generic/pending-3.18/032-bcma-from-4.6.patch	2022-03-22 08:54:47.252464744 +0800
+++ b/target/linux/generic/pending-3.18/032-bcma-from-4.6.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,716 +0,0 @@
---- a/drivers/bcma/driver_chipcommon.c
-+++ b/drivers/bcma/driver_chipcommon.c
-@@ -15,6 +15,8 @@
- #include <linux/platform_device.h>
- #include <linux/bcma/bcma.h>
- 
-+static void bcma_chipco_serial_init(struct bcma_drv_cc *cc);
-+
- static inline u32 bcma_cc_write32_masked(struct bcma_drv_cc *cc, u16 offset,
- 					 u32 mask, u32 value)
- {
-@@ -113,8 +115,37 @@ int bcma_chipco_watchdog_register(struct
- 	return 0;
- }
- 
-+static void bcma_core_chipcommon_flash_detect(struct bcma_drv_cc *cc)
-+{
-+	struct bcma_bus *bus = cc->core->bus;
-+
-+	switch (cc->capabilities & BCMA_CC_CAP_FLASHT) {
-+	case BCMA_CC_FLASHT_STSER:
-+	case BCMA_CC_FLASHT_ATSER:
-+		bcma_debug(bus, "Found serial flash\n");
-+		bcma_sflash_init(cc);
-+		break;
-+	case BCMA_CC_FLASHT_PARA:
-+		bcma_debug(bus, "Found parallel flash\n");
-+		bcma_pflash_init(cc);
-+		break;
-+	default:
-+		bcma_err(bus, "Flash type not supported\n");
-+	}
-+
-+	if (cc->core->id.rev == 38 ||
-+	    bus->chipinfo.id == BCMA_CHIP_ID_BCM4706) {
-+		if (cc->capabilities & BCMA_CC_CAP_NFLASH) {
-+			bcma_debug(bus, "Found NAND flash\n");
-+			bcma_nflash_init(cc);
-+		}
-+	}
-+}
-+
- void bcma_core_chipcommon_early_init(struct bcma_drv_cc *cc)
- {
-+	struct bcma_bus *bus = cc->core->bus;
-+
- 	if (cc->early_setup_done)
- 		return;
- 
-@@ -129,6 +160,12 @@ void bcma_core_chipcommon_early_init(str
- 	if (cc->capabilities & BCMA_CC_CAP_PMU)
- 		bcma_pmu_early_init(cc);
- 
-+	if (IS_BUILTIN(CONFIG_BCM47XX) && bus->hosttype == BCMA_HOSTTYPE_SOC)
-+		bcma_chipco_serial_init(cc);
-+
-+	if (bus->hosttype == BCMA_HOSTTYPE_SOC)
-+		bcma_core_chipcommon_flash_detect(cc);
-+
- 	cc->early_setup_done = true;
- }
- 
-@@ -185,11 +222,12 @@ u32 bcma_chipco_watchdog_timer_set(struc
- 			ticks = 2;
- 		else if (ticks > maxt)
- 			ticks = maxt;
--		bcma_cc_write32(cc, BCMA_CC_PMU_WATCHDOG, ticks);
-+		bcma_pmu_write32(cc, BCMA_CC_PMU_WATCHDOG, ticks);
- 	} else {
- 		struct bcma_bus *bus = cc->core->bus;
- 
- 		if (bus->chipinfo.id != BCMA_CHIP_ID_BCM4707 &&
-+		    bus->chipinfo.id != BCMA_CHIP_ID_BCM47094 &&
- 		    bus->chipinfo.id != BCMA_CHIP_ID_BCM53018)
- 			bcma_core_set_clockmode(cc->core,
- 						ticks ? BCMA_CLKMODE_FAST : BCMA_CLKMODE_DYNAMIC);
-@@ -314,9 +352,9 @@ u32 bcma_chipco_gpio_pulldown(struct bcm
- 	return res;
- }
- 
--#ifdef CONFIG_BCMA_DRIVER_MIPS
--void bcma_chipco_serial_init(struct bcma_drv_cc *cc)
-+static void bcma_chipco_serial_init(struct bcma_drv_cc *cc)
- {
-+#if IS_BUILTIN(CONFIG_BCM47XX)
- 	unsigned int irq;
- 	u32 baud_base;
- 	u32 i;
-@@ -358,5 +396,5 @@ void bcma_chipco_serial_init(struct bcma
- 		ports[i].baud_base = baud_base;
- 		ports[i].reg_shift = 0;
- 	}
-+#endif /* CONFIG_BCM47XX */
- }
--#endif /* CONFIG_BCMA_DRIVER_MIPS */
---- a/drivers/bcma/driver_chipcommon_pmu.c
-+++ b/drivers/bcma/driver_chipcommon_pmu.c
-@@ -15,44 +15,44 @@
- 
- u32 bcma_chipco_pll_read(struct bcma_drv_cc *cc, u32 offset)
- {
--	bcma_cc_write32(cc, BCMA_CC_PLLCTL_ADDR, offset);
--	bcma_cc_read32(cc, BCMA_CC_PLLCTL_ADDR);
--	return bcma_cc_read32(cc, BCMA_CC_PLLCTL_DATA);
-+	bcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_ADDR, offset);
-+	bcma_pmu_read32(cc, BCMA_CC_PMU_PLLCTL_ADDR);
-+	return bcma_pmu_read32(cc, BCMA_CC_PMU_PLLCTL_DATA);
- }
- EXPORT_SYMBOL_GPL(bcma_chipco_pll_read);
- 
- void bcma_chipco_pll_write(struct bcma_drv_cc *cc, u32 offset, u32 value)
- {
--	bcma_cc_write32(cc, BCMA_CC_PLLCTL_ADDR, offset);
--	bcma_cc_read32(cc, BCMA_CC_PLLCTL_ADDR);
--	bcma_cc_write32(cc, BCMA_CC_PLLCTL_DATA, value);
-+	bcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_ADDR, offset);
-+	bcma_pmu_read32(cc, BCMA_CC_PMU_PLLCTL_ADDR);
-+	bcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_DATA, value);
- }
- EXPORT_SYMBOL_GPL(bcma_chipco_pll_write);
- 
- void bcma_chipco_pll_maskset(struct bcma_drv_cc *cc, u32 offset, u32 mask,
- 			     u32 set)
- {
--	bcma_cc_write32(cc, BCMA_CC_PLLCTL_ADDR, offset);
--	bcma_cc_read32(cc, BCMA_CC_PLLCTL_ADDR);
--	bcma_cc_maskset32(cc, BCMA_CC_PLLCTL_DATA, mask, set);
-+	bcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_ADDR, offset);
-+	bcma_pmu_read32(cc, BCMA_CC_PMU_PLLCTL_ADDR);
-+	bcma_pmu_maskset32(cc, BCMA_CC_PMU_PLLCTL_DATA, mask, set);
- }
- EXPORT_SYMBOL_GPL(bcma_chipco_pll_maskset);
- 
- void bcma_chipco_chipctl_maskset(struct bcma_drv_cc *cc,
- 				 u32 offset, u32 mask, u32 set)
- {
--	bcma_cc_write32(cc, BCMA_CC_CHIPCTL_ADDR, offset);
--	bcma_cc_read32(cc, BCMA_CC_CHIPCTL_ADDR);
--	bcma_cc_maskset32(cc, BCMA_CC_CHIPCTL_DATA, mask, set);
-+	bcma_pmu_write32(cc, BCMA_CC_PMU_CHIPCTL_ADDR, offset);
-+	bcma_pmu_read32(cc, BCMA_CC_PMU_CHIPCTL_ADDR);
-+	bcma_pmu_maskset32(cc, BCMA_CC_PMU_CHIPCTL_DATA, mask, set);
- }
- EXPORT_SYMBOL_GPL(bcma_chipco_chipctl_maskset);
- 
- void bcma_chipco_regctl_maskset(struct bcma_drv_cc *cc, u32 offset, u32 mask,
- 				u32 set)
- {
--	bcma_cc_write32(cc, BCMA_CC_REGCTL_ADDR, offset);
--	bcma_cc_read32(cc, BCMA_CC_REGCTL_ADDR);
--	bcma_cc_maskset32(cc, BCMA_CC_REGCTL_DATA, mask, set);
-+	bcma_pmu_write32(cc, BCMA_CC_PMU_REGCTL_ADDR, offset);
-+	bcma_pmu_read32(cc, BCMA_CC_PMU_REGCTL_ADDR);
-+	bcma_pmu_maskset32(cc, BCMA_CC_PMU_REGCTL_DATA, mask, set);
- }
- EXPORT_SYMBOL_GPL(bcma_chipco_regctl_maskset);
- 
-@@ -60,18 +60,18 @@ static u32 bcma_pmu_xtalfreq(struct bcma
- {
- 	u32 ilp_ctl, alp_hz;
- 
--	if (!(bcma_cc_read32(cc, BCMA_CC_PMU_STAT) &
-+	if (!(bcma_pmu_read32(cc, BCMA_CC_PMU_STAT) &
- 	      BCMA_CC_PMU_STAT_EXT_LPO_AVAIL))
- 		return 0;
- 
--	bcma_cc_write32(cc, BCMA_CC_PMU_XTAL_FREQ,
--			BIT(BCMA_CC_PMU_XTAL_FREQ_MEASURE_SHIFT));
-+	bcma_pmu_write32(cc, BCMA_CC_PMU_XTAL_FREQ,
-+			 BIT(BCMA_CC_PMU_XTAL_FREQ_MEASURE_SHIFT));
- 	usleep_range(1000, 2000);
- 
--	ilp_ctl = bcma_cc_read32(cc, BCMA_CC_PMU_XTAL_FREQ);
-+	ilp_ctl = bcma_pmu_read32(cc, BCMA_CC_PMU_XTAL_FREQ);
- 	ilp_ctl &= BCMA_CC_PMU_XTAL_FREQ_ILPCTL_MASK;
- 
--	bcma_cc_write32(cc, BCMA_CC_PMU_XTAL_FREQ, 0);
-+	bcma_pmu_write32(cc, BCMA_CC_PMU_XTAL_FREQ, 0);
- 
- 	alp_hz = ilp_ctl * 32768 / 4;
- 	return (alp_hz + 50000) / 100000 * 100;
-@@ -127,8 +127,8 @@ static void bcma_pmu2_pll_init0(struct b
- 		mask = (u32)~(BCMA_RES_4314_HT_AVAIL |
- 			      BCMA_RES_4314_MACPHY_CLK_AVAIL);
- 
--		bcma_cc_mask32(cc, BCMA_CC_PMU_MINRES_MSK, mask);
--		bcma_cc_mask32(cc, BCMA_CC_PMU_MAXRES_MSK, mask);
-+		bcma_pmu_mask32(cc, BCMA_CC_PMU_MINRES_MSK, mask);
-+		bcma_pmu_mask32(cc, BCMA_CC_PMU_MAXRES_MSK, mask);
- 		bcma_wait_value(cc->core, BCMA_CLKCTLST,
- 				BCMA_CLKCTLST_HAVEHT, 0, 20000);
- 		break;
-@@ -140,7 +140,7 @@ static void bcma_pmu2_pll_init0(struct b
- 
- 	/* Flush */
- 	if (cc->pmu.rev >= 2)
--		bcma_cc_set32(cc, BCMA_CC_PMU_CTL, BCMA_CC_PMU_CTL_PLL_UPD);
-+		bcma_pmu_set32(cc, BCMA_CC_PMU_CTL, BCMA_CC_PMU_CTL_PLL_UPD);
- 
- 	/* TODO: Do we need to update OTP? */
- }
-@@ -195,9 +195,9 @@ static void bcma_pmu_resources_init(stru
- 
- 	/* Set the resource masks. */
- 	if (min_msk)
--		bcma_cc_write32(cc, BCMA_CC_PMU_MINRES_MSK, min_msk);
-+		bcma_pmu_write32(cc, BCMA_CC_PMU_MINRES_MSK, min_msk);
- 	if (max_msk)
--		bcma_cc_write32(cc, BCMA_CC_PMU_MAXRES_MSK, max_msk);
-+		bcma_pmu_write32(cc, BCMA_CC_PMU_MAXRES_MSK, max_msk);
- 
- 	/*
- 	 * Add some delay; allow resources to come up and settle.
-@@ -269,23 +269,33 @@ static void bcma_pmu_workarounds(struct
- 
- void bcma_pmu_early_init(struct bcma_drv_cc *cc)
- {
-+	struct bcma_bus *bus = cc->core->bus;
- 	u32 pmucap;
- 
--	pmucap = bcma_cc_read32(cc, BCMA_CC_PMU_CAP);
-+	if (cc->core->id.rev >= 35 &&
-+	    cc->capabilities_ext & BCMA_CC_CAP_EXT_AOB_PRESENT) {
-+		cc->pmu.core = bcma_find_core(bus, BCMA_CORE_PMU);
-+		if (!cc->pmu.core)
-+			bcma_warn(bus, "Couldn't find expected PMU core");
-+	}
-+	if (!cc->pmu.core)
-+		cc->pmu.core = cc->core;
-+
-+	pmucap = bcma_pmu_read32(cc, BCMA_CC_PMU_CAP);
- 	cc->pmu.rev = (pmucap & BCMA_CC_PMU_CAP_REVISION);
- 
--	bcma_debug(cc->core->bus, "Found rev %u PMU (capabilities 0x%08X)\n",
--		   cc->pmu.rev, pmucap);
-+	bcma_debug(bus, "Found rev %u PMU (capabilities 0x%08X)\n", cc->pmu.rev,
-+		   pmucap);
- }
- 
- void bcma_pmu_init(struct bcma_drv_cc *cc)
- {
- 	if (cc->pmu.rev == 1)
--		bcma_cc_mask32(cc, BCMA_CC_PMU_CTL,
--			      ~BCMA_CC_PMU_CTL_NOILPONW);
-+		bcma_pmu_mask32(cc, BCMA_CC_PMU_CTL,
-+				~BCMA_CC_PMU_CTL_NOILPONW);
- 	else
--		bcma_cc_set32(cc, BCMA_CC_PMU_CTL,
--			     BCMA_CC_PMU_CTL_NOILPONW);
-+		bcma_pmu_set32(cc, BCMA_CC_PMU_CTL,
-+			       BCMA_CC_PMU_CTL_NOILPONW);
- 
- 	bcma_pmu_pll_init(cc);
- 	bcma_pmu_resources_init(cc);
-@@ -472,8 +482,8 @@ u32 bcma_pmu_get_cpu_clock(struct bcma_d
- static void bcma_pmu_spuravoid_pll_write(struct bcma_drv_cc *cc, u32 offset,
- 					 u32 value)
- {
--	bcma_cc_write32(cc, BCMA_CC_PLLCTL_ADDR, offset);
--	bcma_cc_write32(cc, BCMA_CC_PLLCTL_DATA, value);
-+	bcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_ADDR, offset);
-+	bcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_DATA, value);
- }
- 
- void bcma_pmu_spuravoid_pllupdate(struct bcma_drv_cc *cc, int spuravoid)
-@@ -497,20 +507,20 @@ void bcma_pmu_spuravoid_pllupdate(struct
- 		       bus->chipinfo.id == BCMA_CHIP_ID_BCM53572) ? 6 : 0;
- 
- 		/* RMW only the P1 divider */
--		bcma_cc_write32(cc, BCMA_CC_PLLCTL_ADDR,
-+		bcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_ADDR,
- 				BCMA_CC_PMU_PLL_CTL0 + phypll_offset);
--		tmp = bcma_cc_read32(cc, BCMA_CC_PLLCTL_DATA);
-+		tmp = bcma_pmu_read32(cc, BCMA_CC_PMU_PLLCTL_DATA);
- 		tmp &= (~(BCMA_CC_PMU1_PLL0_PC0_P1DIV_MASK));
- 		tmp |= (bcm5357_bcm43236_p1div[spuravoid] << BCMA_CC_PMU1_PLL0_PC0_P1DIV_SHIFT);
--		bcma_cc_write32(cc, BCMA_CC_PLLCTL_DATA, tmp);
-+		bcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_DATA, tmp);
- 
- 		/* RMW only the int feedback divider */
--		bcma_cc_write32(cc, BCMA_CC_PLLCTL_ADDR,
-+		bcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_ADDR,
- 				BCMA_CC_PMU_PLL_CTL2 + phypll_offset);
--		tmp = bcma_cc_read32(cc, BCMA_CC_PLLCTL_DATA);
-+		tmp = bcma_pmu_read32(cc, BCMA_CC_PMU_PLLCTL_DATA);
- 		tmp &= ~(BCMA_CC_PMU1_PLL0_PC2_NDIV_INT_MASK);
- 		tmp |= (bcm5357_bcm43236_ndiv[spuravoid]) << BCMA_CC_PMU1_PLL0_PC2_NDIV_INT_SHIFT;
--		bcma_cc_write32(cc, BCMA_CC_PLLCTL_DATA, tmp);
-+		bcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_DATA, tmp);
- 
- 		tmp = BCMA_CC_PMU_CTL_PLL_UPD;
- 		break;
-@@ -646,7 +656,7 @@ void bcma_pmu_spuravoid_pllupdate(struct
- 		break;
- 	}
- 
--	tmp |= bcma_cc_read32(cc, BCMA_CC_PMU_CTL);
--	bcma_cc_write32(cc, BCMA_CC_PMU_CTL, tmp);
-+	tmp |= bcma_pmu_read32(cc, BCMA_CC_PMU_CTL);
-+	bcma_pmu_write32(cc, BCMA_CC_PMU_CTL, tmp);
- }
- EXPORT_SYMBOL_GPL(bcma_pmu_spuravoid_pllupdate);
---- a/drivers/bcma/driver_chipcommon_sflash.c
-+++ b/drivers/bcma/driver_chipcommon_sflash.c
-@@ -38,6 +38,7 @@ static const struct bcma_sflash_tbl_e bc
- 	{ "M25P32", 0x15, 0x10000, 64, },
- 	{ "M25P64", 0x16, 0x10000, 128, },
- 	{ "M25FL128", 0x17, 0x10000, 256, },
-+	{ "MX25L25635F", 0x18, 0x10000, 512, },
- 	{ NULL },
- };
- 
---- a/drivers/bcma/scan.c
-+++ b/drivers/bcma/scan.c
-@@ -98,6 +98,9 @@ static const struct bcma_device_id_name
- 	{ BCMA_CORE_SHIM, "SHIM" },
- 	{ BCMA_CORE_PCIE2, "PCIe Gen2" },
- 	{ BCMA_CORE_ARM_CR4, "ARM CR4" },
-+	{ BCMA_CORE_GCI, "GCI" },
-+	{ BCMA_CORE_CMEM, "CNDS DDR2/3 memory controller" },
-+	{ BCMA_CORE_ARM_CA7, "ARM CA7" },
- 	{ BCMA_CORE_DEFAULT, "Default" },
- };
- 
-@@ -315,6 +318,8 @@ static int bcma_get_next_core(struct bcm
- 		switch (core->id.id) {
- 		case BCMA_CORE_4706_MAC_GBIT_COMMON:
- 		case BCMA_CORE_NS_CHIPCOMMON_B:
-+		case BCMA_CORE_PMU:
-+		case BCMA_CORE_GCI:
- 		/* Not used yet: case BCMA_CORE_OOB_ROUTER: */
- 			break;
- 		default:
---- a/drivers/net/wireless/b43/main.c
-+++ b/drivers/net/wireless/b43/main.c
-@@ -1215,10 +1215,10 @@ void b43_wireless_core_phy_pll_reset(str
- 	case B43_BUS_BCMA:
- 		bcma_cc = &dev->dev->bdev->bus->drv_cc;
- 
--		bcma_cc_write32(bcma_cc, BCMA_CC_CHIPCTL_ADDR, 0);
--		bcma_cc_mask32(bcma_cc, BCMA_CC_CHIPCTL_DATA, ~0x4);
--		bcma_cc_set32(bcma_cc, BCMA_CC_CHIPCTL_DATA, 0x4);
--		bcma_cc_mask32(bcma_cc, BCMA_CC_CHIPCTL_DATA, ~0x4);
-+		bcma_cc_write32(bcma_cc, BCMA_CC_PMU_CHIPCTL_ADDR, 0);
-+		bcma_cc_mask32(bcma_cc, BCMA_CC_PMU_CHIPCTL_DATA, ~0x4);
-+		bcma_cc_set32(bcma_cc, BCMA_CC_PMU_CHIPCTL_DATA, 0x4);
-+		bcma_cc_mask32(bcma_cc, BCMA_CC_PMU_CHIPCTL_DATA, ~0x4);
- 		break;
- #endif
- #ifdef CONFIG_B43_SSB
---- a/include/linux/bcma/bcma.h
-+++ b/include/linux/bcma/bcma.h
-@@ -151,6 +151,8 @@ struct bcma_host_ops {
- #define BCMA_CORE_PCIE2			0x83C	/* PCI Express Gen2 */
- #define BCMA_CORE_USB30_DEV		0x83D
- #define BCMA_CORE_ARM_CR4		0x83E
-+#define BCMA_CORE_GCI			0x840
-+#define BCMA_CORE_CMEM			0x846	/* CNDS DDR2/3 memory controller */
- #define BCMA_CORE_ARM_CA7		0x847
- #define BCMA_CORE_SYS_MEM		0x849
- #define BCMA_CORE_DEFAULT		0xFFF
-@@ -200,6 +202,7 @@ struct bcma_host_ops {
- #define  BCMA_PKG_ID_BCM4707	1
- #define  BCMA_PKG_ID_BCM4708	2
- #define  BCMA_PKG_ID_BCM4709	0
-+#define BCMA_CHIP_ID_BCM47094	53030
- #define BCMA_CHIP_ID_BCM53018	53018
- 
- /* Board types (on PCI usually equals to the subsystem dev id) */
---- a/include/linux/bcma/bcma_driver_chipcommon.h
-+++ b/include/linux/bcma/bcma_driver_chipcommon.h
-@@ -217,6 +217,11 @@
- #define	 BCMA_CC_CLKDIV_JTAG_SHIFT	8
- #define	 BCMA_CC_CLKDIV_UART		0x000000FF
- #define BCMA_CC_CAP_EXT			0x00AC		/* Capabilities */
-+#define  BCMA_CC_CAP_EXT_SECI_PRESENT	0x00000001
-+#define  BCMA_CC_CAP_EXT_GSIO_PRESENT	0x00000002
-+#define  BCMA_CC_CAP_EXT_GCI_PRESENT	0x00000004
-+#define  BCMA_CC_CAP_EXT_SECI_PUART_PRESENT		0x00000008    /* UART present */
-+#define  BCMA_CC_CAP_EXT_AOB_PRESENT	0x00000040
- #define BCMA_CC_PLLONDELAY		0x00B0		/* Rev >= 4 only */
- #define BCMA_CC_FREFSELDELAY		0x00B4		/* Rev >= 4 only */
- #define BCMA_CC_SLOWCLKCTL		0x00B8		/* 6 <= Rev <= 9 only */
-@@ -351,12 +356,12 @@
- #define BCMA_CC_PMU_RES_REQTS		0x0640 /* PMU res req timer sel */
- #define BCMA_CC_PMU_RES_REQT		0x0644 /* PMU res req timer */
- #define BCMA_CC_PMU_RES_REQM		0x0648 /* PMU res req mask */
--#define BCMA_CC_CHIPCTL_ADDR		0x0650
--#define BCMA_CC_CHIPCTL_DATA		0x0654
--#define BCMA_CC_REGCTL_ADDR		0x0658
--#define BCMA_CC_REGCTL_DATA		0x065C
--#define BCMA_CC_PLLCTL_ADDR		0x0660
--#define BCMA_CC_PLLCTL_DATA		0x0664
-+#define BCMA_CC_PMU_CHIPCTL_ADDR	0x0650
-+#define BCMA_CC_PMU_CHIPCTL_DATA	0x0654
-+#define BCMA_CC_PMU_REGCTL_ADDR		0x0658
-+#define BCMA_CC_PMU_REGCTL_DATA		0x065C
-+#define BCMA_CC_PMU_PLLCTL_ADDR		0x0660
-+#define BCMA_CC_PMU_PLLCTL_DATA		0x0664
- #define BCMA_CC_PMU_STRAPOPT		0x0668 /* (corerev >= 28) */
- #define BCMA_CC_PMU_XTAL_FREQ		0x066C /* (pmurev >= 10) */
- #define  BCMA_CC_PMU_XTAL_FREQ_ILPCTL_MASK	0x00001FFF
-@@ -566,17 +571,16 @@
-  * Check availability with ((struct bcma_chipcommon)->capabilities & BCMA_CC_CAP_PMU)
-  */
- struct bcma_chipcommon_pmu {
-+	struct bcma_device *core;	/* Can be separated core or just ChipCommon one */
- 	u8 rev;			/* PMU revision */
- 	u32 crystalfreq;	/* The active crystal frequency (in kHz) */
- };
- 
--#ifdef CONFIG_BCMA_DRIVER_MIPS
-+#ifdef CONFIG_BCMA_PFLASH
- struct bcma_pflash {
- 	bool present;
--	u8 buswidth;
--	u32 window;
--	u32 window_size;
- };
-+#endif
- 
- #ifdef CONFIG_BCMA_SFLASH
- struct bcma_sflash {
-@@ -602,6 +606,7 @@ struct bcma_nflash {
- };
- #endif
- 
-+#ifdef CONFIG_BCMA_DRIVER_MIPS
- struct bcma_serial_port {
- 	void *regs;
- 	unsigned long clockspeed;
-@@ -621,8 +626,9 @@ struct bcma_drv_cc {
- 	/* Fast Powerup Delay constant */
- 	u16 fast_pwrup_delay;
- 	struct bcma_chipcommon_pmu pmu;
--#ifdef CONFIG_BCMA_DRIVER_MIPS
-+#ifdef CONFIG_BCMA_PFLASH
- 	struct bcma_pflash pflash;
-+#endif
- #ifdef CONFIG_BCMA_SFLASH
- 	struct bcma_sflash sflash;
- #endif
-@@ -630,6 +636,7 @@ struct bcma_drv_cc {
- 	struct bcma_nflash nflash;
- #endif
- 
-+#ifdef CONFIG_BCMA_DRIVER_MIPS
- 	int nr_serial_ports;
- 	struct bcma_serial_port serial_ports[4];
- #endif /* CONFIG_BCMA_DRIVER_MIPS */
-@@ -663,6 +670,19 @@ struct bcma_drv_cc_b {
- #define bcma_cc_maskset32(cc, offset, mask, set) \
- 	bcma_cc_write32(cc, offset, (bcma_cc_read32(cc, offset) & (mask)) | (set))
- 
-+/* PMU registers access */
-+#define bcma_pmu_read32(cc, offset) \
-+	bcma_read32((cc)->pmu.core, offset)
-+#define bcma_pmu_write32(cc, offset, val) \
-+	bcma_write32((cc)->pmu.core, offset, val)
-+
-+#define bcma_pmu_mask32(cc, offset, mask) \
-+	bcma_pmu_write32(cc, offset, bcma_pmu_read32(cc, offset) & (mask))
-+#define bcma_pmu_set32(cc, offset, set) \
-+	bcma_pmu_write32(cc, offset, bcma_pmu_read32(cc, offset) | (set))
-+#define bcma_pmu_maskset32(cc, offset, mask, set) \
-+	bcma_pmu_write32(cc, offset, (bcma_pmu_read32(cc, offset) & (mask)) | (set))
-+
- extern u32 bcma_chipco_watchdog_timer_set(struct bcma_drv_cc *cc, u32 ticks);
- 
- extern u32 bcma_chipco_get_alp_clock(struct bcma_drv_cc *cc);
---- a/drivers/bcma/bcma_private.h
-+++ b/drivers/bcma/bcma_private.h
-@@ -44,10 +44,6 @@ int bcma_sprom_get(struct bcma_bus *bus)
- void bcma_core_chipcommon_early_init(struct bcma_drv_cc *cc);
- void bcma_core_chipcommon_init(struct bcma_drv_cc *cc);
- void bcma_chipco_bcm4331_ext_pa_lines_ctl(struct bcma_drv_cc *cc, bool enable);
--#ifdef CONFIG_BCMA_DRIVER_MIPS
--void bcma_chipco_serial_init(struct bcma_drv_cc *cc);
--extern struct platform_device bcma_pflash_dev;
--#endif /* CONFIG_BCMA_DRIVER_MIPS */
- 
- /* driver_chipcommon_b.c */
- int bcma_core_chipcommon_b_init(struct bcma_drv_cc_b *ccb);
-@@ -59,6 +55,21 @@ void bcma_pmu_init(struct bcma_drv_cc *c
- u32 bcma_pmu_get_alp_clock(struct bcma_drv_cc *cc);
- u32 bcma_pmu_get_cpu_clock(struct bcma_drv_cc *cc);
- 
-+/**************************************************
-+ * driver_chipcommon_sflash.c
-+ **************************************************/
-+
-+#ifdef CONFIG_BCMA_PFLASH
-+extern struct platform_device bcma_pflash_dev;
-+int bcma_pflash_init(struct bcma_drv_cc *cc);
-+#else
-+static inline int bcma_pflash_init(struct bcma_drv_cc *cc)
-+{
-+	bcma_err(cc->core->bus, "Parallel flash not supported\n");
-+	return 0;
-+}
-+#endif /* CONFIG_BCMA_PFLASH */
-+
- #ifdef CONFIG_BCMA_SFLASH
- /* driver_chipcommon_sflash.c */
- int bcma_sflash_init(struct bcma_drv_cc *cc);
---- a/drivers/bcma/driver_gpio.c
-+++ b/drivers/bcma/driver_gpio.c
-@@ -229,6 +229,7 @@ int bcma_gpio_init(struct bcma_drv_cc *c
- 	case BCMA_CHIP_ID_BCM4707:
- 	case BCMA_CHIP_ID_BCM5357:
- 	case BCMA_CHIP_ID_BCM53572:
-+	case BCMA_CHIP_ID_BCM47094:
- 		chip->ngpio	= 32;
- 		break;
- 	default:
---- a/drivers/bcma/driver_mips.c
-+++ b/drivers/bcma/driver_mips.c
-@@ -14,8 +14,6 @@
- 
- #include <linux/bcma/bcma.h>
- 
--#include <linux/mtd/physmap.h>
--#include <linux/platform_device.h>
- #include <linux/serial.h>
- #include <linux/serial_core.h>
- #include <linux/serial_reg.h>
-@@ -29,26 +27,6 @@ enum bcma_boot_dev {
- 	BCMA_BOOT_DEV_NAND,
- };
- 
--static const char * const part_probes[] = { "bcm47xxpart", NULL };
--
--static struct physmap_flash_data bcma_pflash_data = {
--	.part_probe_types	= part_probes,
--};
--
--static struct resource bcma_pflash_resource = {
--	.name	= "bcma_pflash",
--	.flags  = IORESOURCE_MEM,
--};
--
--struct platform_device bcma_pflash_dev = {
--	.name		= "physmap-flash",
--	.dev		= {
--		.platform_data  = &bcma_pflash_data,
--	},
--	.resource	= &bcma_pflash_resource,
--	.num_resources	= 1,
--};
--
- /* The 47162a0 hangs when reading MIPS DMP registers registers */
- static inline bool bcma_core_mips_bcm47162a0_quirk(struct bcma_device *dev)
- {
-@@ -269,48 +247,11 @@ static enum bcma_boot_dev bcma_boot_dev(
- 	return BCMA_BOOT_DEV_SERIAL;
- }
- 
--static void bcma_core_mips_flash_detect(struct bcma_drv_mips *mcore)
-+static void bcma_core_mips_nvram_init(struct bcma_drv_mips *mcore)
- {
- 	struct bcma_bus *bus = mcore->core->bus;
--	struct bcma_drv_cc *cc = &bus->drv_cc;
--	struct bcma_pflash *pflash = &cc->pflash;
- 	enum bcma_boot_dev boot_dev;
- 
--	switch (cc->capabilities & BCMA_CC_CAP_FLASHT) {
--	case BCMA_CC_FLASHT_STSER:
--	case BCMA_CC_FLASHT_ATSER:
--		bcma_debug(bus, "Found serial flash\n");
--		bcma_sflash_init(cc);
--		break;
--	case BCMA_CC_FLASHT_PARA:
--		bcma_debug(bus, "Found parallel flash\n");
--		pflash->present = true;
--		pflash->window = BCMA_SOC_FLASH2;
--		pflash->window_size = BCMA_SOC_FLASH2_SZ;
--
--		if ((bcma_read32(cc->core, BCMA_CC_FLASH_CFG) &
--		     BCMA_CC_FLASH_CFG_DS) == 0)
--			pflash->buswidth = 1;
--		else
--			pflash->buswidth = 2;
--
--		bcma_pflash_data.width = pflash->buswidth;
--		bcma_pflash_resource.start = pflash->window;
--		bcma_pflash_resource.end = pflash->window + pflash->window_size;
--
--		break;
--	default:
--		bcma_err(bus, "Flash type not supported\n");
--	}
--
--	if (cc->core->id.rev == 38 ||
--	    bus->chipinfo.id == BCMA_CHIP_ID_BCM4706) {
--		if (cc->capabilities & BCMA_CC_CAP_NFLASH) {
--			bcma_debug(bus, "Found NAND flash\n");
--			bcma_nflash_init(cc);
--		}
--	}
--
- 	/* Determine flash type this SoC boots from */
- 	boot_dev = bcma_boot_dev(bus);
- 	switch (boot_dev) {
-@@ -328,13 +269,10 @@ static void bcma_core_mips_flash_detect(
- 
- void bcma_core_mips_early_init(struct bcma_drv_mips *mcore)
- {
--	struct bcma_bus *bus = mcore->core->bus;
--
- 	if (mcore->early_setup_done)
- 		return;
- 
--	bcma_chipco_serial_init(&bus->drv_cc);
--	bcma_core_mips_flash_detect(mcore);
-+	bcma_core_mips_nvram_init(mcore);
- 
- 	mcore->early_setup_done = true;
- }
---- a/drivers/bcma/host_pci.c
-+++ b/drivers/bcma/host_pci.c
-@@ -294,7 +294,7 @@ static const struct pci_device_id bcma_p
- 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4358) },
- 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4359) },
- 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4360) },
--	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4365) },
-+	{ PCI_DEVICE_SUB(PCI_VENDOR_ID_BROADCOM, 0x4365, PCI_VENDOR_ID_DELL, 0x0016) },
- 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x43a0) },
- 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x43a9) },
- 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x43aa) },
---- a/drivers/bcma/Kconfig
-+++ b/drivers/bcma/Kconfig
-@@ -70,6 +70,11 @@ config BCMA_DRIVER_MIPS
- 
- 	  If unsure, say N
- 
-+config BCMA_PFLASH
-+	bool
-+	depends on BCMA_DRIVER_MIPS
-+	default y
-+
- config BCMA_SFLASH
- 	bool
- 	depends on BCMA_DRIVER_MIPS
---- a/drivers/bcma/Makefile
-+++ b/drivers/bcma/Makefile
-@@ -1,6 +1,7 @@
- bcma-y					+= main.o scan.o core.o sprom.o
- bcma-y					+= driver_chipcommon.o driver_chipcommon_pmu.o
- bcma-y					+= driver_chipcommon_b.o
-+bcma-$(CONFIG_BCMA_PFLASH)		+= driver_chipcommon_pflash.o
- bcma-$(CONFIG_BCMA_SFLASH)		+= driver_chipcommon_sflash.o
- bcma-$(CONFIG_BCMA_NFLASH)		+= driver_chipcommon_nflash.o
- bcma-$(CONFIG_BCMA_DRIVER_PCI)		+= driver_pci.o
---- /dev/null
-+++ b/drivers/bcma/driver_chipcommon_pflash.c
-@@ -0,0 +1,49 @@
-+/*
-+ * Broadcom specific AMBA
-+ * ChipCommon parallel flash
-+ *
-+ * Licensed under the GNU/GPL. See COPYING for details.
-+ */
-+
-+#include "bcma_private.h"
-+
-+#include <linux/bcma/bcma.h>
-+#include <linux/mtd/physmap.h>
-+#include <linux/platform_device.h>
-+
-+static const char * const part_probes[] = { "bcm47xxpart", NULL };
-+
-+static struct physmap_flash_data bcma_pflash_data = {
-+	.part_probe_types	= part_probes,
-+};
-+
-+static struct resource bcma_pflash_resource = {
-+	.name	= "bcma_pflash",
-+	.flags  = IORESOURCE_MEM,
-+};
-+
-+struct platform_device bcma_pflash_dev = {
-+	.name		= "physmap-flash",
-+	.dev		= {
-+		.platform_data  = &bcma_pflash_data,
-+	},
-+	.resource	= &bcma_pflash_resource,
-+	.num_resources	= 1,
-+};
-+
-+int bcma_pflash_init(struct bcma_drv_cc *cc)
-+{
-+	struct bcma_pflash *pflash = &cc->pflash;
-+
-+	pflash->present = true;
-+
-+	if (!(bcma_read32(cc->core, BCMA_CC_FLASH_CFG) & BCMA_CC_FLASH_CFG_DS))
-+		bcma_pflash_data.width = 1;
-+	else
-+		bcma_pflash_data.width = 2;
-+
-+	bcma_pflash_resource.start = BCMA_SOC_FLASH2;
-+	bcma_pflash_resource.end = BCMA_SOC_FLASH2 + BCMA_SOC_FLASH2_SZ;
-+
-+	return 0;
-+}
---- a/drivers/bcma/main.c
-+++ b/drivers/bcma/main.c
-@@ -325,7 +325,7 @@ static int bcma_register_devices(struct
- 		bcma_register_core(bus, core);
- 	}
- 
--#ifdef CONFIG_BCMA_DRIVER_MIPS
-+#ifdef CONFIG_BCMA_PFLASH
- 	if (bus->drv_cc.pflash.present) {
- 		err = platform_device_register(&bcma_pflash_dev);
- 		if (err)
--- a/target/linux/generic/pending-3.18/040-mtd-bcm47xxpart-backports-from-3.19.patch	2022-03-22 08:54:47.252464744 +0800
+++ b/target/linux/generic/pending-3.18/040-mtd-bcm47xxpart-backports-from-3.19.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,50 +0,0 @@
---- a/drivers/mtd/bcm47xxpart.c
-+++ b/drivers/mtd/bcm47xxpart.c
-@@ -15,8 +15,12 @@
- #include <linux/mtd/mtd.h>
- #include <linux/mtd/partitions.h>
- 
--/* 10 parts were found on sflash on Netgear WNDR4500 */
--#define BCM47XXPART_MAX_PARTS		12
-+/*
-+ * NAND flash on Netgear R6250 was verified to contain 15 partitions.
-+ * This will result in allocating too big array for some old devices, but the
-+ * memory will be freed soon anyway (see mtd_device_parse_register).
-+ */
-+#define BCM47XXPART_MAX_PARTS		20
- 
- /*
-  * Amount of bytes we read when analyzing each block of flash memory.
-@@ -168,18 +172,26 @@ static int bcm47xxpart_parse(struct mtd_
- 				i++;
- 			}
- 
--			bcm47xxpart_add_part(&parts[curr_part++], "linux",
--					     offset + trx->offset[i], 0);
--			i++;
-+			if (trx->offset[i]) {
-+				bcm47xxpart_add_part(&parts[curr_part++],
-+						     "linux",
-+						     offset + trx->offset[i],
-+						     0);
-+				i++;
-+			}
- 
- 			/*
- 			 * Pure rootfs size is known and can be calculated as:
- 			 * trx->length - trx->offset[i]. We don't fill it as
- 			 * we want to have jffs2 (overlay) in the same mtd.
- 			 */
--			bcm47xxpart_add_part(&parts[curr_part++], "rootfs",
--					     offset + trx->offset[i], 0);
--			i++;
-+			if (trx->offset[i]) {
-+				bcm47xxpart_add_part(&parts[curr_part++],
-+						     "rootfs",
-+						     offset + trx->offset[i],
-+						     0);
-+				i++;
-+			}
- 
- 			last_trx_part = curr_part - 1;
- 
--- a/target/linux/generic/pending-3.18/041-mtd-bcm47xxpart-backports-from-3.20.patch	2022-03-22 08:54:47.252464744 +0800
+++ b/target/linux/generic/pending-3.18/041-mtd-bcm47xxpart-backports-from-3.20.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,95 +0,0 @@
---- a/drivers/mtd/bcm47xxpart.c
-+++ b/drivers/mtd/bcm47xxpart.c
-@@ -15,6 +15,8 @@
- #include <linux/mtd/mtd.h>
- #include <linux/mtd/partitions.h>
- 
-+#include <uapi/linux/magic.h>
-+
- /*
-  * NAND flash on Netgear R6250 was verified to contain 15 partitions.
-  * This will result in allocating too big array for some old devices, but the
-@@ -39,7 +41,8 @@
- #define ML_MAGIC1			0x39685a42
- #define ML_MAGIC2			0x26594131
- #define TRX_MAGIC			0x30524448
--#define SQSH_MAGIC			0x71736873	/* shsq */
-+#define SHSQ_MAGIC			0x71736873	/* shsq (weird ZTE H218N endianness) */
-+#define UBI_EC_MAGIC			0x23494255	/* UBI# */
- 
- struct trx_header {
- 	uint32_t magic;
-@@ -50,7 +53,7 @@ struct trx_header {
- 	uint32_t offset[3];
- } __packed;
- 
--static void bcm47xxpart_add_part(struct mtd_partition *part, char *name,
-+static void bcm47xxpart_add_part(struct mtd_partition *part, const char *name,
- 				 u64 offset, uint32_t mask_flags)
- {
- 	part->name = name;
-@@ -58,6 +61,26 @@ static void bcm47xxpart_add_part(struct
- 	part->mask_flags = mask_flags;
- }
- 
-+static const char *bcm47xxpart_trx_data_part_name(struct mtd_info *master,
-+						  size_t offset)
-+{
-+	uint32_t buf;
-+	size_t bytes_read;
-+
-+	if (mtd_read(master, offset, sizeof(buf), &bytes_read,
-+		     (uint8_t *)&buf) < 0) {
-+		pr_err("mtd_read error while parsing (offset: 0x%X)!\n",
-+			offset);
-+		goto out_default;
-+	}
-+
-+	if (buf == UBI_EC_MAGIC)
-+		return "ubi";
-+
-+out_default:
-+	return "rootfs";
-+}
-+
- static int bcm47xxpart_parse(struct mtd_info *master,
- 			     struct mtd_partition **pparts,
- 			     struct mtd_part_parser_data *data)
-@@ -73,8 +96,12 @@ static int bcm47xxpart_parse(struct mtd_
- 	int last_trx_part = -1;
- 	int possible_nvram_sizes[] = { 0x8000, 0xF000, 0x10000, };
- 
--	if (blocksize <= 0x10000)
--		blocksize = 0x10000;
-+	/*
-+	 * Some really old flashes (like AT45DB*) had smaller erasesize-s, but
-+	 * partitions were aligned to at least 0x1000 anyway.
-+	 */
-+	if (blocksize < 0x1000)
-+		blocksize = 0x1000;
- 
- 	/* Alloc */
- 	parts = kzalloc(sizeof(struct mtd_partition) * BCM47XXPART_MAX_PARTS,
-@@ -186,8 +213,11 @@ static int bcm47xxpart_parse(struct mtd_
- 			 * we want to have jffs2 (overlay) in the same mtd.
- 			 */
- 			if (trx->offset[i]) {
-+				const char *name;
-+
-+				name = bcm47xxpart_trx_data_part_name(master, offset + trx->offset[i]);
- 				bcm47xxpart_add_part(&parts[curr_part++],
--						     "rootfs",
-+						     name,
- 						     offset + trx->offset[i],
- 						     0);
- 				i++;
-@@ -203,7 +233,8 @@ static int bcm47xxpart_parse(struct mtd_
- 		}
- 
- 		/* Squashfs on devices not using TRX */
--		if (buf[0x000 / 4] == SQSH_MAGIC) {
-+		if (le32_to_cpu(buf[0x000 / 4]) == SQUASHFS_MAGIC ||
-+		    buf[0x000 / 4] == SHSQ_MAGIC) {
- 			bcm47xxpart_add_part(&parts[curr_part++], "rootfs",
- 					     offset, 0);
- 			continue;
--- a/target/linux/generic/pending-3.18/043-mtd_GD25Q128B_support_backport_from_3.19.patch	2022-03-22 08:54:47.253464746 +0800
+++ b/target/linux/generic/pending-3.18/043-mtd_GD25Q128B_support_backport_from_3.19.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,15 +0,0 @@
-mtd: spi-nor: support for (GigaDevice) GD25Q128B
-
-Signed-off-by: Rafa Miecki <zajec5@gmail.com>
-Signed-off-by: Brian Norris <computersforpeace@gmail.com>
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -510,6 +510,7 @@ static const struct spi_device_id spi_no
- 	/* GigaDevice */
- 	{ "gd25q32", INFO(0xc84016, 0, 64 * 1024,  64, SECT_4K) },
- 	{ "gd25q64", INFO(0xc84017, 0, 64 * 1024, 128, SECT_4K) },
-+	{ "gd25q128", INFO(0xc84018, 0, 64 * 1024, 256, SECT_4K) },
- 
- 	/* Intel/Numonyx -- xxxs33b */
- 	{ "160s33b",  INFO(0x898911, 0, 64 * 1024,  32, 0) },
--- a/target/linux/generic/pending-3.18/044-backport-m25p80-jedec-probe.patch	2022-03-22 08:54:47.253464746 +0800
+++ b/target/linux/generic/pending-3.18/044-backport-m25p80-jedec-probe.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,39 +0,0 @@
---- a/drivers/mtd/devices/m25p80.c
-+++ b/drivers/mtd/devices/m25p80.c
-@@ -310,11 +310,21 @@ static const struct spi_device_id m25p_i
- };
- MODULE_DEVICE_TABLE(spi, m25p_ids);
- 
-+static const struct of_device_id m25p_of_table[] = {
-+	/*
-+	 * Generic compatibility for SPI NOR that can be identified by the
-+	 * JEDEC READ ID opcode (0x9F). Use this, if possible.
-+	 */
-+	{ .compatible = "jedec,spi-nor" },
-+	{}
-+};
-+MODULE_DEVICE_TABLE(of, m25p_of_table);
- 
- static struct spi_driver m25p80_driver = {
- 	.driver = {
- 		.name	= "m25p80",
- 		.owner	= THIS_MODULE,
-+		.of_match_table = m25p_of_table,
- 	},
- 	.id_table	= m25p_ids,
- 	.probe	= m25p_probe,
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -934,8 +934,11 @@ int spi_nor_scan(struct spi_nor *nor, co
- 	if (ret)
- 		return ret;
- 
--	id = spi_nor_match_id(name);
-+	if (name)
-+		id = spi_nor_match_id(name);
- 	if (!id)
-+		id = nor->read_id(nor);
-+	if (IS_ERR_OR_NULL(id))
- 		return -ENOENT;
- 
- 	info = (void *)id->driver_data;
--- a/target/linux/generic/pending-3.18/050-backport_netfilter_rtcache.patch	2022-03-22 08:54:47.253464746 +0800
+++ b/target/linux/generic/pending-3.18/050-backport_netfilter_rtcache.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,509 +0,0 @@
-Subject: netfilter: conntrack: cache route for forwarded connections
-
-... to avoid per-packet FIB lookup if possible.
-
-The cached dst is re-used provided the input interface
-is the same as that of the previous packet in the same direction.
-
-If not, the cached dst is invalidated.
-
-For ipv6 we also need to store sernum, else dst_check doesn't work,
-pointed out by Eric Dumazet.
-
-This should speed up forwarding when conntrack is already in use
-anyway, especially when using reverse path filtering -- active RPF
-enforces two FIB lookups for each packet.
-
-Before the routing cache removal this didn't matter since RPF was performed
-only when route cache didn't yield a result; but without route cache it
-comes at higher price.
-
-Julian Anastasov suggested to add NETDEV_UNREGISTER handler to
-avoid holding on to dsts of 'frozen' conntracks.
-
-Signed-off-by: Florian Westphal <fw@strlen.de>
-
---- a/include/net/netfilter/nf_conntrack_extend.h
-+++ b/include/net/netfilter/nf_conntrack_extend.h
-@@ -30,6 +30,9 @@ enum nf_ct_ext_id {
- #if IS_ENABLED(CONFIG_NETFILTER_SYNPROXY)
- 	NF_CT_EXT_SYNPROXY,
- #endif
-+#if IS_ENABLED(CONFIG_NF_CONNTRACK_RTCACHE)
-+	NF_CT_EXT_RTCACHE,
-+#endif
- 	NF_CT_EXT_NUM,
- };
- 
-@@ -43,6 +46,7 @@ enum nf_ct_ext_id {
- #define NF_CT_EXT_TIMEOUT_TYPE struct nf_conn_timeout
- #define NF_CT_EXT_LABELS_TYPE struct nf_conn_labels
- #define NF_CT_EXT_SYNPROXY_TYPE struct nf_conn_synproxy
-+#define NF_CT_EXT_RTCACHE_TYPE struct nf_conn_rtcache
- 
- /* Extensions: optional stuff which isn't permanently in struct. */
- struct nf_ct_ext {
---- /dev/null
-+++ b/include/net/netfilter/nf_conntrack_rtcache.h
-@@ -0,0 +1,34 @@
-+#include <linux/gfp.h>
-+#include <net/netfilter/nf_conntrack.h>
-+#include <net/netfilter/nf_conntrack_extend.h>
-+
-+struct dst_entry;
-+
-+struct nf_conn_dst_cache {
-+	struct dst_entry *dst;
-+	int iif;
-+#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
-+	u32 cookie;
-+#endif
-+
-+};
-+
-+struct nf_conn_rtcache {
-+	struct nf_conn_dst_cache cached_dst[IP_CT_DIR_MAX];
-+};
-+
-+static inline
-+struct nf_conn_rtcache *nf_ct_rtcache_find(const struct nf_conn *ct)
-+{
-+#if IS_ENABLED(CONFIG_NF_CONNTRACK_RTCACHE)
-+	return nf_ct_ext_find(ct, NF_CT_EXT_RTCACHE);
-+#else
-+	return NULL;
-+#endif
-+}
-+
-+static inline int nf_conn_rtcache_iif_get(const struct nf_conn_rtcache *rtc,
-+					  enum ip_conntrack_dir dir)
-+{
-+	return rtc->cached_dst[dir].iif;
-+}
---- a/net/netfilter/Kconfig
-+++ b/net/netfilter/Kconfig
-@@ -106,6 +106,18 @@ config NF_CONNTRACK_EVENTS
- 
- 	  If unsure, say `N'.
- 
-+config NF_CONNTRACK_RTCACHE
-+	tristate "Cache route entries in conntrack objects"
-+	depends on NETFILTER_ADVANCED
-+	depends on NF_CONNTRACK
-+	help
-+	  If this option is enabled, the connection tracking code will
-+	  cache routing information for each connection that is being
-+	  forwarded, at a cost of 32 bytes per conntrack object.
-+
-+	  To compile it as a module, choose M here.  If unsure, say N.
-+	  The module will be called nf_conntrack_rtcache.
-+
- config NF_CONNTRACK_TIMEOUT
- 	bool  'Connection tracking timeout'
- 	depends on NETFILTER_ADVANCED
---- a/net/netfilter/Makefile
-+++ b/net/netfilter/Makefile
-@@ -18,6 +18,9 @@ obj-$(CONFIG_NETFILTER_NETLINK_LOG) += n
- # connection tracking
- obj-$(CONFIG_NF_CONNTRACK) += nf_conntrack.o
- 
-+# optional conntrack route cache extension
-+obj-$(CONFIG_NF_CONNTRACK_RTCACHE) += nf_conntrack_rtcache.o
-+
- # SCTP protocol connection tracking
- obj-$(CONFIG_NF_CT_PROTO_DCCP) += nf_conntrack_proto_dccp.o
- obj-$(CONFIG_NF_CT_PROTO_GRE) += nf_conntrack_proto_gre.o
---- /dev/null
-+++ b/net/netfilter/nf_conntrack_rtcache.c
-@@ -0,0 +1,391 @@
-+/* route cache for netfilter.
-+ *
-+ * (C) 2014 Red Hat GmbH
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License version 2 as
-+ * published by the Free Software Foundation.
-+ */
-+
-+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-+
-+#include <linux/types.h>
-+#include <linux/netfilter.h>
-+#include <linux/skbuff.h>
-+#include <linux/stddef.h>
-+#include <linux/kernel.h>
-+#include <linux/netdevice.h>
-+#include <linux/export.h>
-+#include <linux/module.h>
-+
-+#include <net/dst.h>
-+
-+#include <net/netfilter/nf_conntrack.h>
-+#include <net/netfilter/nf_conntrack_core.h>
-+#include <net/netfilter/nf_conntrack_extend.h>
-+#include <net/netfilter/nf_conntrack_rtcache.h>
-+
-+#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
-+#include <net/ip6_fib.h>
-+#endif
-+
-+static void __nf_conn_rtcache_destroy(struct nf_conn_rtcache *rtc,
-+				      enum ip_conntrack_dir dir)
-+{
-+	struct dst_entry *dst = rtc->cached_dst[dir].dst;
-+
-+	dst_release(dst);
-+}
-+
-+static void nf_conn_rtcache_destroy(struct nf_conn *ct)
-+{
-+	struct nf_conn_rtcache *rtc = nf_ct_rtcache_find(ct);
-+
-+	if (!rtc)
-+		return;
-+
-+	__nf_conn_rtcache_destroy(rtc, IP_CT_DIR_ORIGINAL);
-+	__nf_conn_rtcache_destroy(rtc, IP_CT_DIR_REPLY);
-+}
-+
-+static void nf_ct_rtcache_ext_add(struct nf_conn *ct)
-+{
-+	struct nf_conn_rtcache *rtc;
-+
-+	rtc = nf_ct_ext_add(ct, NF_CT_EXT_RTCACHE, GFP_ATOMIC);
-+	if (rtc) {
-+		rtc->cached_dst[IP_CT_DIR_ORIGINAL].iif = -1;
-+		rtc->cached_dst[IP_CT_DIR_ORIGINAL].dst = NULL;
-+		rtc->cached_dst[IP_CT_DIR_REPLY].iif = -1;
-+		rtc->cached_dst[IP_CT_DIR_REPLY].dst = NULL;
-+	}
-+}
-+
-+static struct nf_conn_rtcache *nf_ct_rtcache_find_usable(struct nf_conn *ct)
-+{
-+	if (nf_ct_is_untracked(ct))
-+		return NULL;
-+	return nf_ct_rtcache_find(ct);
-+}
-+
-+static struct dst_entry *
-+nf_conn_rtcache_dst_get(const struct nf_conn_rtcache *rtc,
-+			enum ip_conntrack_dir dir)
-+{
-+	return rtc->cached_dst[dir].dst;
-+}
-+
-+static u32 nf_rtcache_get_cookie(int pf, const struct dst_entry *dst)
-+{
-+#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
-+	if (pf == NFPROTO_IPV6) {
-+		const struct rt6_info *rt = (const struct rt6_info *)dst;
-+
-+		if (rt->rt6i_node)
-+			return (u32)rt->rt6i_node->fn_sernum;
-+	}
-+#endif
-+	return 0;
-+}
-+
-+static void nf_conn_rtcache_dst_set(int pf,
-+				    struct nf_conn_rtcache *rtc,
-+				    struct dst_entry *dst,
-+				    enum ip_conntrack_dir dir, int iif)
-+{
-+	if (rtc->cached_dst[dir].iif != iif)
-+		rtc->cached_dst[dir].iif = iif;
-+
-+	if (rtc->cached_dst[dir].dst != dst) {
-+		struct dst_entry *old;
-+
-+		dst_hold(dst);
-+
-+		old = xchg(&rtc->cached_dst[dir].dst, dst);
-+		dst_release(old);
-+
-+#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
-+		if (pf == NFPROTO_IPV6)
-+			rtc->cached_dst[dir].cookie =
-+				nf_rtcache_get_cookie(pf, dst);
-+#endif
-+	}
-+}
-+
-+static void nf_conn_rtcache_dst_obsolete(struct nf_conn_rtcache *rtc,
-+					 enum ip_conntrack_dir dir)
-+{
-+	struct dst_entry *old;
-+
-+	pr_debug("Invalidate iif %d for dir %d on cache %p\n",
-+		 rtc->cached_dst[dir].iif, dir, rtc);
-+
-+	old = xchg(&rtc->cached_dst[dir].dst, NULL);
-+	dst_release(old);
-+	rtc->cached_dst[dir].iif = -1;
-+}
-+
-+static unsigned int nf_rtcache_in(const struct nf_hook_ops *ops,
-+				  struct sk_buff *skb,
-+				  const struct net_device *in,
-+				  const struct net_device *out,
-+				  int (*okfn)(struct sk_buff *))
-+{
-+	struct nf_conn_rtcache *rtc;
-+	enum ip_conntrack_info ctinfo;
-+	enum ip_conntrack_dir dir;
-+	struct dst_entry *dst;
-+	struct nf_conn *ct;
-+	int iif;
-+	u32 cookie;
-+
-+	if (skb_dst(skb) || skb->sk)
-+		return NF_ACCEPT;
-+
-+	ct = nf_ct_get(skb, &ctinfo);
-+	if (!ct)
-+		return NF_ACCEPT;
-+
-+	rtc = nf_ct_rtcache_find_usable(ct);
-+	if (!rtc)
-+		return NF_ACCEPT;
-+
-+	/* if iif changes, don't use cache and let ip stack
-+	 * do route lookup.
-+	 *
-+	 * If rp_filter is enabled it might toss skb, so
-+	 * we don't want to avoid these checks.
-+	 */
-+	dir = CTINFO2DIR(ctinfo);
-+	iif = nf_conn_rtcache_iif_get(rtc, dir);
-+	if (in->ifindex != iif) {
-+		pr_debug("ct %p, iif %d, cached iif %d, skip cached entry\n",
-+			 ct, iif, in->ifindex);
-+		return NF_ACCEPT;
-+	}
-+	dst = nf_conn_rtcache_dst_get(rtc, dir);
-+	if (dst == NULL)
-+		return NF_ACCEPT;
-+
-+	cookie = nf_rtcache_get_cookie(ops->pf, dst);
-+
-+	dst = dst_check(dst, cookie);
-+	pr_debug("obtained dst %p for skb %p, cookie %d\n", dst, skb, cookie);
-+	if (likely(dst))
-+		skb_dst_set_noref_force(skb, dst);
-+	else
-+		nf_conn_rtcache_dst_obsolete(rtc, dir);
-+
-+	return NF_ACCEPT;
-+}
-+
-+static unsigned int nf_rtcache_forward(const struct nf_hook_ops *ops,
-+				       struct sk_buff *skb,
-+				       const struct net_device *in,
-+				       const struct net_device *out,
-+				       int (*okfn)(struct sk_buff *))
-+{
-+	struct nf_conn_rtcache *rtc;
-+	enum ip_conntrack_info ctinfo;
-+	enum ip_conntrack_dir dir;
-+	struct nf_conn *ct;
-+	struct dst_entry *dst = skb_dst(skb);
-+	int iif;
-+
-+	ct = nf_ct_get(skb, &ctinfo);
-+	if (!ct)
-+		return NF_ACCEPT;
-+
-+	if (dst && dst_xfrm(dst))
-+		return NF_ACCEPT;
-+
-+	if (!nf_ct_is_confirmed(ct)) {
-+		if (WARN_ON(nf_ct_rtcache_find(ct)))
-+			return NF_ACCEPT;
-+		nf_ct_rtcache_ext_add(ct);
-+		return NF_ACCEPT;
-+	}
-+
-+	rtc = nf_ct_rtcache_find_usable(ct);
-+	if (!rtc)
-+		return NF_ACCEPT;
-+
-+	dir = CTINFO2DIR(ctinfo);
-+	iif = nf_conn_rtcache_iif_get(rtc, dir);
-+	pr_debug("ct %p, skb %p, dir %d, iif %d, cached iif %d\n",
-+		 ct, skb, dir, iif, in->ifindex);
-+	if (likely(in->ifindex == iif))
-+		return NF_ACCEPT;
-+
-+	nf_conn_rtcache_dst_set(ops->pf, rtc, skb_dst(skb), dir, in->ifindex);
-+	return NF_ACCEPT;
-+}
-+
-+static int nf_rtcache_dst_remove(struct nf_conn *ct, void *data)
-+{
-+	struct nf_conn_rtcache *rtc = nf_ct_rtcache_find(ct);
-+	struct net_device *dev = data;
-+
-+	if (!rtc)
-+		return 0;
-+
-+	if (dev->ifindex == rtc->cached_dst[IP_CT_DIR_ORIGINAL].iif ||
-+	    dev->ifindex == rtc->cached_dst[IP_CT_DIR_REPLY].iif) {
-+		nf_conn_rtcache_dst_obsolete(rtc, IP_CT_DIR_ORIGINAL);
-+		nf_conn_rtcache_dst_obsolete(rtc, IP_CT_DIR_REPLY);
-+	}
-+
-+	return 0;
-+}
-+
-+static int nf_rtcache_netdev_event(struct notifier_block *this,
-+				   unsigned long event, void *ptr)
-+{
-+	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
-+	struct net *net = dev_net(dev);
-+
-+	if (event == NETDEV_DOWN)
-+		nf_ct_iterate_cleanup(net, nf_rtcache_dst_remove, dev, 0, 0);
-+
-+	return NOTIFY_DONE;
-+}
-+
-+static struct notifier_block nf_rtcache_notifier = {
-+	.notifier_call = nf_rtcache_netdev_event,
-+};
-+
-+static struct nf_hook_ops rtcache_ops[] = {
-+	{
-+		.hook		= nf_rtcache_in,
-+		.owner		= THIS_MODULE,
-+		.pf		= NFPROTO_IPV4,
-+		.hooknum	= NF_INET_PRE_ROUTING,
-+		.priority       = NF_IP_PRI_LAST,
-+	},
-+	{
-+		.hook           = nf_rtcache_forward,
-+		.owner          = THIS_MODULE,
-+		.pf             = NFPROTO_IPV4,
-+		.hooknum        = NF_INET_FORWARD,
-+		.priority       = NF_IP_PRI_LAST,
-+	},
-+#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
-+	{
-+		.hook		= nf_rtcache_in,
-+		.owner		= THIS_MODULE,
-+		.pf		= NFPROTO_IPV6,
-+		.hooknum	= NF_INET_PRE_ROUTING,
-+		.priority       = NF_IP_PRI_LAST,
-+	},
-+	{
-+		.hook           = nf_rtcache_forward,
-+		.owner          = THIS_MODULE,
-+		.pf             = NFPROTO_IPV6,
-+		.hooknum        = NF_INET_FORWARD,
-+		.priority       = NF_IP_PRI_LAST,
-+	},
-+#endif
-+};
-+
-+static struct nf_ct_ext_type rtcache_extend __read_mostly = {
-+	.len	= sizeof(struct nf_conn_rtcache),
-+	.align	= __alignof__(struct nf_conn_rtcache),
-+	.id	= NF_CT_EXT_RTCACHE,
-+	.destroy = nf_conn_rtcache_destroy,
-+};
-+
-+static int __init nf_conntrack_rtcache_init(void)
-+{
-+	int ret = nf_ct_extend_register(&rtcache_extend);
-+
-+	if (ret < 0) {
-+		pr_err("nf_conntrack_rtcache: Unable to register extension\n");
-+		return ret;
-+	}
-+
-+	ret = nf_register_hooks(rtcache_ops, ARRAY_SIZE(rtcache_ops));
-+	if (ret < 0) {
-+		nf_ct_extend_unregister(&rtcache_extend);
-+		return ret;
-+	}
-+
-+	ret = register_netdevice_notifier(&nf_rtcache_notifier);
-+	if (ret) {
-+		nf_unregister_hooks(rtcache_ops, ARRAY_SIZE(rtcache_ops));
-+		nf_ct_extend_unregister(&rtcache_extend);
-+	}
-+
-+	return ret;
-+}
-+
-+static int nf_rtcache_ext_remove(struct nf_conn *ct, void *data)
-+{
-+	struct nf_conn_rtcache *rtc = nf_ct_rtcache_find(ct);
-+
-+	return rtc != NULL;
-+}
-+
-+static bool __exit nf_conntrack_rtcache_wait_for_dying(struct net *net)
-+{
-+	bool wait = false;
-+	int cpu;
-+
-+	for_each_possible_cpu(cpu) {
-+		struct nf_conntrack_tuple_hash *h;
-+		struct hlist_nulls_node *n;
-+		struct nf_conn *ct;
-+		struct ct_pcpu *pcpu = per_cpu_ptr(net->ct.pcpu_lists, cpu);
-+
-+		rcu_read_lock();
-+		spin_lock_bh(&pcpu->lock);
-+
-+		hlist_nulls_for_each_entry(h, n, &pcpu->dying, hnnode) {
-+			ct = nf_ct_tuplehash_to_ctrack(h);
-+			if (nf_ct_rtcache_find(ct) != NULL) {
-+				wait = true;
-+				break;
-+			}
-+		}
-+		spin_unlock_bh(&pcpu->lock);
-+		rcu_read_unlock();
-+	}
-+
-+	return wait;
-+}
-+
-+static void __exit nf_conntrack_rtcache_fini(void)
-+{
-+	struct net *net;
-+	int count = 0;
-+
-+	/* remove hooks so no new connections get rtcache extension */
-+	nf_unregister_hooks(rtcache_ops, ARRAY_SIZE(rtcache_ops));
-+
-+	synchronize_net();
-+
-+	unregister_netdevice_notifier(&nf_rtcache_notifier);
-+
-+	rtnl_lock();
-+
-+	/* zap all conntracks with rtcache extension */
-+	for_each_net(net)
-+		nf_ct_iterate_cleanup(net, nf_rtcache_ext_remove, NULL, 0, 0);
-+
-+	for_each_net(net) {
-+		/* .. and make sure they're gone from dying list, too */
-+		while (nf_conntrack_rtcache_wait_for_dying(net)) {
-+			msleep(200);
-+			WARN_ONCE(++count > 25, "Waiting for all rtcache conntracks to go away\n");
-+		}
-+	}
-+
-+	rtnl_unlock();
-+	synchronize_net();
-+	nf_ct_extend_unregister(&rtcache_extend);
-+}
-+module_init(nf_conntrack_rtcache_init);
-+module_exit(nf_conntrack_rtcache_fini);
-+
-+MODULE_LICENSE("GPL");
-+MODULE_AUTHOR("Florian Westphal <fw@strlen.de>");
-+MODULE_DESCRIPTION("Conntrack route cache extension");
--- a/target/linux/generic/pending-3.18/051-02-bridge-allow-setting-hash_max-multicast_router-if-in.patch	2022-03-22 08:54:47.254464748 +0800
+++ b/target/linux/generic/pending-3.18/051-02-bridge-allow-setting-hash_max-multicast_router-if-in.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,99 +0,0 @@
-From 6ae4ae8e512bd229f806c22f8a2cd751e4f987c2 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Linus=20L=C3=BCssing?= <linus.luessing@c0d3.blue>
-Date: Sat, 23 May 2015 03:12:34 +0200
-Subject: [PATCH] bridge: allow setting hash_max + multicast_router if
- interface is down
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Network managers like netifd (used in OpenWRT for instance) try to
-configure interface options after creation but before setting the
-interface up.
-
-Unfortunately the sysfs / bridge currently only allows to configure the
-hash_max and multicast_router options when the bridge interface is up.
-But since br_multicast_init() doesn't start any timers and only sets
-default values and initializes timers it should be save to reconfigure
-the default values after that, before things actually get active after
-the bridge is set up.
-
-Signed-off-by: Linus Lssing <linus.luessing@c0d3.blue>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- net/bridge/br_multicast.c |   24 +++---------------------
- 1 file changed, 3 insertions(+), 21 deletions(-)
-
---- a/net/bridge/br_multicast.c
-+++ b/net/bridge/br_multicast.c
-@@ -1948,11 +1948,9 @@ out:
- 
- int br_multicast_set_router(struct net_bridge *br, unsigned long val)
- {
--	int err = -ENOENT;
-+	int err = -EINVAL;
- 
- 	spin_lock_bh(&br->multicast_lock);
--	if (!netif_running(br->dev))
--		goto unlock;
- 
- 	switch (val) {
- 	case 0:
-@@ -1963,13 +1961,8 @@ int br_multicast_set_router(struct net_b
- 		br->multicast_router = val;
- 		err = 0;
- 		break;
--
--	default:
--		err = -EINVAL;
--		break;
- 	}
- 
--unlock:
- 	spin_unlock_bh(&br->multicast_lock);
- 
- 	return err;
-@@ -1978,11 +1971,9 @@ unlock:
- int br_multicast_set_port_router(struct net_bridge_port *p, unsigned long val)
- {
- 	struct net_bridge *br = p->br;
--	int err = -ENOENT;
-+	int err = -EINVAL;
- 
- 	spin_lock(&br->multicast_lock);
--	if (!netif_running(br->dev) || p->state == BR_STATE_DISABLED)
--		goto unlock;
- 
- 	switch (val) {
- 	case 0:
-@@ -2004,13 +1995,8 @@ int br_multicast_set_port_router(struct
- 
- 		br_multicast_add_router(br, p);
- 		break;
--
--	default:
--		err = -EINVAL;
--		break;
- 	}
- 
--unlock:
- 	spin_unlock(&br->multicast_lock);
- 
- 	return err;
-@@ -2115,15 +2101,11 @@ unlock:
- 
- int br_multicast_set_hash_max(struct net_bridge *br, unsigned long val)
- {
--	int err = -ENOENT;
-+	int err = -EINVAL;
- 	u32 old;
- 	struct net_bridge_mdb_htable *mdb;
- 
- 	spin_lock_bh(&br->multicast_lock);
--	if (!netif_running(br->dev))
--		goto unlock;
--
--	err = -EINVAL;
- 	if (!is_power_of_2(val))
- 		goto unlock;
- 
--- a/target/linux/generic/pending-3.18/060-mips_decompressor_memmove.patch	2022-03-22 08:54:47.254464748 +0800
+++ b/target/linux/generic/pending-3.18/060-mips_decompressor_memmove.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,22 +0,0 @@
---- a/arch/mips/boot/compressed/string.c
-+++ b/arch/mips/boot/compressed/string.c
-@@ -26,3 +26,19 @@ void *memset(void *s, int c, size_t n)
- 		ss[i] = c;
- 	return s;
- }
-+
-+void *memmove(void *__dest, __const void *__src, size_t count)
-+{
-+	unsigned char *d = __dest;
-+	const unsigned char *s = __src;
-+
-+	if (__dest == __src)
-+		return __dest;
-+
-+	if (__dest < __src)
-+		return memcpy(__dest, __src, count);
-+
-+	while (count--)
-+		d[count] = s[count];
-+	return __dest;
-+}
--- a/target/linux/generic/pending-3.18/070-bgmac-register-napi-before-the-device.patch	2022-03-22 08:54:47.255464749 +0800
+++ b/target/linux/generic/pending-3.18/070-bgmac-register-napi-before-the-device.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,44 +0,0 @@
-From 6216642f200258708e47170ff14ba8ecb486f4f0 Mon Sep 17 00:00:00 2001
-From: Hauke Mehrtens <hauke@hauke-m.de>
-Date: Sun, 18 Jan 2015 19:49:58 +0100
-Subject: [PATCH] bgmac: register napi before the device
-
-napi should get registered before the netdev and not after.
-
-Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- drivers/net/ethernet/broadcom/bgmac.c | 6 +++---
- 1 file changed, 3 insertions(+), 3 deletions(-)
-
---- a/drivers/net/ethernet/broadcom/bgmac.c
-+++ b/drivers/net/ethernet/broadcom/bgmac.c
-@@ -1521,6 +1521,8 @@ static int bgmac_probe(struct bcma_devic
- 	if (core->bus->sprom.boardflags_lo & BGMAC_BFL_ENETADM)
- 		bgmac_warn(bgmac, "Support for ADMtek ethernet switch not implemented\n");
- 
-+	netif_napi_add(net_dev, &bgmac->napi, bgmac_poll, BGMAC_WEIGHT);
-+
- 	err = bgmac_mii_register(bgmac);
- 	if (err) {
- 		bgmac_err(bgmac, "Cannot register MDIO\n");
-@@ -1535,8 +1537,6 @@ static int bgmac_probe(struct bcma_devic
- 
- 	netif_carrier_off(net_dev);
- 
--	netif_napi_add(net_dev, &bgmac->napi, bgmac_poll, BGMAC_WEIGHT);
--
- 	return 0;
- 
- err_mii_unregister:
-@@ -1555,9 +1555,9 @@ static void bgmac_remove(struct bcma_dev
- {
- 	struct bgmac *bgmac = bcma_get_drvdata(core);
- 
--	netif_napi_del(&bgmac->napi);
- 	unregister_netdev(bgmac->net_dev);
- 	bgmac_mii_unregister(bgmac);
-+	netif_napi_del(&bgmac->napi);
- 	bgmac_dma_free(bgmac);
- 	bcma_set_drvdata(core, NULL);
- 	free_netdev(bgmac->net_dev);
--- a/target/linux/generic/pending-3.18/071-bgmac-activate-irqs-only-if-there-is-nothing-to-poll.patch	2022-03-22 08:54:47.255464749 +0800
+++ b/target/linux/generic/pending-3.18/071-bgmac-activate-irqs-only-if-there-is-nothing-to-poll.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,30 +0,0 @@
-From 43f159c60a99318b1ef7d1d7c16c4dfdd06bfd90 Mon Sep 17 00:00:00 2001
-From: Hauke Mehrtens <hauke@hauke-m.de>
-Date: Sun, 18 Jan 2015 19:49:59 +0100
-Subject: [PATCH] bgmac: activate irqs only if there is nothing to poll
-
-IRQs should only get activated when there is nothing to poll in the
-queue any more and to after every poll.
-
-Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- drivers/net/ethernet/broadcom/bgmac.c | 6 +++---
- 1 file changed, 3 insertions(+), 3 deletions(-)
-
---- a/drivers/net/ethernet/broadcom/bgmac.c
-+++ b/drivers/net/ethernet/broadcom/bgmac.c
-@@ -1167,10 +1167,10 @@ static int bgmac_poll(struct napi_struct
- 		bgmac->int_status = 0;
- 	}
- 
--	if (handled < weight)
-+	if (handled < weight) {
- 		napi_complete(napi);
--
--	bgmac_chip_intrs_on(bgmac);
-+		bgmac_chip_intrs_on(bgmac);
-+	}
- 
- 	return handled;
- }
--- a/target/linux/generic/pending-3.18/073-bgmac-Clean-warning-messages.patch	2022-03-22 08:54:47.255464749 +0800
+++ b/target/linux/generic/pending-3.18/073-bgmac-Clean-warning-messages.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,50 +0,0 @@
-From 8edfe3b6fad28da191c8fa15e4e0d8f7335a0091 Mon Sep 17 00:00:00 2001
-From: Peter Senna Tschudin <peter.senna@gmail.com>
-Date: Sat, 7 Mar 2015 12:10:26 +0100
-Subject: [PATCH] bgmac: Clean warning messages
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-On my test environment the throughput of a file transfer drops
-from 4.4MBps to 116KBps due the number of repeated warning
-messages. This patch removes the warning messages as DMA works
-correctly with addresses using 0xC0000000 bits.
-
-Signed-off-by: Peter Senna Tschudin <peter.senna@gmail.com>
-Acked-by: Rafa Miecki <zajec5@gmail.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- drivers/net/ethernet/broadcom/bgmac.c | 7 -------
- 1 file changed, 7 deletions(-)
-
---- a/drivers/net/ethernet/broadcom/bgmac.c
-+++ b/drivers/net/ethernet/broadcom/bgmac.c
-@@ -302,9 +302,6 @@ static int bgmac_dma_rx_skb_for_slot(str
- 	slot->skb = skb;
- 	slot->dma_addr = dma_addr;
- 
--	if (slot->dma_addr & 0xC0000000)
--		bgmac_warn(bgmac, "DMA address using 0xC0000000 bit(s), it may need translation trick\n");
--
- 	return 0;
- }
- 
-@@ -505,8 +502,6 @@ static int bgmac_dma_alloc(struct bgmac
- 				  ring->mmio_base);
- 			goto err_dma_free;
- 		}
--		if (ring->dma_base & 0xC0000000)
--			bgmac_warn(bgmac, "DMA address using 0xC0000000 bit(s), it may need translation trick\n");
- 
- 		ring->unaligned = bgmac_dma_unaligned(bgmac, ring,
- 						      BGMAC_DMA_RING_TX);
-@@ -536,8 +531,6 @@ static int bgmac_dma_alloc(struct bgmac
- 			err = -ENOMEM;
- 			goto err_dma_free;
- 		}
--		if (ring->dma_base & 0xC0000000)
--			bgmac_warn(bgmac, "DMA address using 0xC0000000 bit(s), it may need translation trick\n");
- 
- 		ring->unaligned = bgmac_dma_unaligned(bgmac, ring,
- 						      BGMAC_DMA_RING_RX);
--- a/target/linux/generic/pending-3.18/074-bgmac-register-fixed-PHY-for-ARM-BCM470X-BCM5301X-ch.patch	2022-03-22 08:54:47.256464751 +0800
+++ b/target/linux/generic/pending-3.18/074-bgmac-register-fixed-PHY-for-ARM-BCM470X-BCM5301X-ch.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,76 +0,0 @@
-From c25b23b8a387e7d31f7a74af8e37b61e9e6ebb21 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
-Date: Fri, 20 Mar 2015 23:14:31 +0100
-Subject: [PATCH] bgmac: register fixed PHY for ARM BCM470X / BCM5301X chipsets
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-On ARM SoCs with bgmac Ethernet hardware we don't have any normal PHY.
-There is always a switch attached but it's not even controlled over MDIO
-like in case of MIPS devices.
-We need a fixed PHY to be able to send/receive packets from the switch.
-
-Signed-off-by: Rafa Miecki <zajec5@gmail.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- drivers/net/ethernet/broadcom/bgmac.c | 34 ++++++++++++++++++++++++++++++++++
- 1 file changed, 34 insertions(+)
-
---- a/drivers/net/ethernet/broadcom/bgmac.c
-+++ b/drivers/net/ethernet/broadcom/bgmac.c
-@@ -14,6 +14,7 @@
- #include <linux/etherdevice.h>
- #include <linux/mii.h>
- #include <linux/phy.h>
-+#include <linux/phy_fixed.h>
- #include <linux/interrupt.h>
- #include <linux/dma-mapping.h>
- #include <bcm47xx_nvram.h>
-@@ -1330,13 +1331,46 @@ static void bgmac_adjust_link(struct net
- 	}
- }
- 
-+static int bgmac_fixed_phy_register(struct bgmac *bgmac)
-+{
-+	struct fixed_phy_status fphy_status = {
-+		.link = 1,
-+		.speed = SPEED_1000,
-+		.duplex = DUPLEX_FULL,
-+	};
-+	struct phy_device *phy_dev;
-+	int err;
-+
-+	phy_dev = fixed_phy_register(PHY_POLL, &fphy_status, NULL);
-+	if (!phy_dev || IS_ERR(phy_dev)) {
-+		bgmac_err(bgmac, "Failed to register fixed PHY device\n");
-+		return -ENODEV;
-+	}
-+
-+	err = phy_connect_direct(bgmac->net_dev, phy_dev, bgmac_adjust_link,
-+				 PHY_INTERFACE_MODE_MII);
-+	if (err) {
-+		bgmac_err(bgmac, "Connecting PHY failed\n");
-+		return err;
-+	}
-+
-+	bgmac->phy_dev = phy_dev;
-+
-+	return err;
-+}
-+
- static int bgmac_mii_register(struct bgmac *bgmac)
- {
-+	struct bcma_chipinfo *ci = &bgmac->core->bus->chipinfo;
- 	struct mii_bus *mii_bus;
- 	struct phy_device *phy_dev;
- 	char bus_id[MII_BUS_ID_SIZE + 3];
- 	int i, err = 0;
- 
-+	if (ci->id == BCMA_CHIP_ID_BCM4707 ||
-+	    ci->id == BCMA_CHIP_ID_BCM53018)
-+		return bgmac_fixed_phy_register(bgmac);
-+
- 	mii_bus = mdiobus_alloc();
- 	if (!mii_bus)
- 		return -ENOMEM;
--- a/target/linux/generic/pending-3.18/075-bgmac-allow-enabling-on-ARCH_BCM_5301X.patch	2022-03-22 08:54:47.256464751 +0800
+++ b/target/linux/generic/pending-3.18/075-bgmac-allow-enabling-on-ARCH_BCM_5301X.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,28 +0,0 @@
-From fc300dc3733fdc328e6e10c7b8379b60c26cd648 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
-Date: Fri, 20 Mar 2015 23:14:32 +0100
-Subject: [PATCH] bgmac: allow enabling on ARCH_BCM_5301X
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Home routers based on ARM SoCs like BCM4708 also have bcma bus with core
-supported by bgmac.
-
-Signed-off-by: Rafa Miecki <zajec5@gmail.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- drivers/net/ethernet/broadcom/Kconfig | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/drivers/net/ethernet/broadcom/Kconfig
-+++ b/drivers/net/ethernet/broadcom/Kconfig
-@@ -143,7 +143,7 @@ config BNX2X_SRIOV
- 
- config BGMAC
- 	tristate "BCMA bus GBit core support"
--	depends on BCMA_HOST_SOC && HAS_DMA && BCM47XX
-+	depends on BCMA_HOST_SOC && HAS_DMA && (BCM47XX || ARCH_BCM_5301X)
- 	select PHYLIB
- 	---help---
- 	  This driver supports GBit MAC and BCM4706 GBit MAC cores on BCMA bus.
--- a/target/linux/generic/pending-3.18/076-net-phy-export-fixed_phy_register.patch	2022-03-22 08:54:47.256464751 +0800
+++ b/target/linux/generic/pending-3.18/076-net-phy-export-fixed_phy_register.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,30 +0,0 @@
-From 37e9a6904520b525b542ecd67201164d06fdb95a Mon Sep 17 00:00:00 2001
-From: Mark Salter <msalter@redhat.com>
-Date: Thu, 11 Dec 2014 23:03:26 -0500
-Subject: [PATCH] net: phy: export fixed_phy_register()
-
-When building the bcmgenet driver as module, I get:
-
-ERROR: "fixed_phy_register" [drivers/net/ethernet/broadcom/genet/genet.ko] undefined!
-
-commit b0ba512e225d72 ("net: bcmgenet: enable driver to work without device
-tree") which added a call to fixed_phy_register. But fixed_phy_register
-needs to be exported if used from a module.
-
-Signed-off-by: Mark Salter <msalter@redhat.com>
-Acked-by: Florian Fainelli <f.fainelli@gmail.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- drivers/net/phy/fixed.c | 1 +
- 1 file changed, 1 insertion(+)
-
---- a/drivers/net/phy/fixed.c
-+++ b/drivers/net/phy/fixed.c
-@@ -274,6 +274,7 @@ struct phy_device *fixed_phy_register(un
- 
- 	return phy;
- }
-+EXPORT_SYMBOL_GPL(fixed_phy_register);
- 
- static int __init fixed_mdio_bus_init(void)
- {
--- a/target/linux/generic/pending-3.18/077-01-bgmac-fix-descriptor-frame-start-end-definitions.patch	2022-03-22 08:54:47.257464753 +0800
+++ b/target/linux/generic/pending-3.18/077-01-bgmac-fix-descriptor-frame-start-end-definitions.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,24 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Mon, 23 Mar 2015 02:40:06 +0100
-Subject: [PATCH] bgmac: fix descriptor frame start/end definitions
-
-The start-of-frame and end-of-frame bits were accidentally swapped.
-In the current code it does not make any difference, since they are
-always used together.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/drivers/net/ethernet/broadcom/bgmac.h
-+++ b/drivers/net/ethernet/broadcom/bgmac.h
-@@ -345,8 +345,8 @@
- 
- #define BGMAC_DESC_CTL0_EOT			0x10000000	/* End of ring */
- #define BGMAC_DESC_CTL0_IOC			0x20000000	/* IRQ on complete */
--#define BGMAC_DESC_CTL0_SOF			0x40000000	/* Start of frame */
--#define BGMAC_DESC_CTL0_EOF			0x80000000	/* End of frame */
-+#define BGMAC_DESC_CTL0_EOF			0x40000000	/* End of frame */
-+#define BGMAC_DESC_CTL0_SOF			0x80000000	/* Start of frame */
- #define BGMAC_DESC_CTL1_LEN			0x00001FFF
- 
- #define BGMAC_PHY_NOREGS			0x1E
--- a/target/linux/generic/pending-3.18/077-02-bgmac-implement-GRO-and-use-build_skb.patch	2022-03-22 08:54:47.257464753 +0800
+++ b/target/linux/generic/pending-3.18/077-02-bgmac-implement-GRO-and-use-build_skb.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,189 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Mon, 23 Mar 2015 02:41:25 +0100
-Subject: [PATCH] bgmac: implement GRO and use build_skb
-
-This improves performance for routing and local rx
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/drivers/net/ethernet/broadcom/bgmac.c
-+++ b/drivers/net/ethernet/broadcom/bgmac.c
-@@ -276,31 +276,31 @@ static int bgmac_dma_rx_skb_for_slot(str
- 				     struct bgmac_slot_info *slot)
- {
- 	struct device *dma_dev = bgmac->core->dma_dev;
--	struct sk_buff *skb;
- 	dma_addr_t dma_addr;
- 	struct bgmac_rx_header *rx;
-+	void *buf;
- 
- 	/* Alloc skb */
--	skb = netdev_alloc_skb(bgmac->net_dev, BGMAC_RX_BUF_SIZE);
--	if (!skb)
-+	buf = netdev_alloc_frag(BGMAC_RX_ALLOC_SIZE);
-+	if (!buf)
- 		return -ENOMEM;
- 
- 	/* Poison - if everything goes fine, hardware will overwrite it */
--	rx = (struct bgmac_rx_header *)skb->data;
-+	rx = buf;
- 	rx->len = cpu_to_le16(0xdead);
- 	rx->flags = cpu_to_le16(0xbeef);
- 
- 	/* Map skb for the DMA */
--	dma_addr = dma_map_single(dma_dev, skb->data,
--				  BGMAC_RX_BUF_SIZE, DMA_FROM_DEVICE);
-+	dma_addr = dma_map_single(dma_dev, buf, BGMAC_RX_BUF_SIZE,
-+				  DMA_FROM_DEVICE);
- 	if (dma_mapping_error(dma_dev, dma_addr)) {
- 		bgmac_err(bgmac, "DMA mapping error\n");
--		dev_kfree_skb(skb);
-+		put_page(virt_to_head_page(buf));
- 		return -ENOMEM;
- 	}
- 
- 	/* Update the slot */
--	slot->skb = skb;
-+	slot->buf = buf;
- 	slot->dma_addr = dma_addr;
- 
- 	return 0;
-@@ -343,8 +343,9 @@ static int bgmac_dma_rx_read(struct bgma
- 	while (ring->start != ring->end) {
- 		struct device *dma_dev = bgmac->core->dma_dev;
- 		struct bgmac_slot_info *slot = &ring->slots[ring->start];
--		struct sk_buff *skb = slot->skb;
--		struct bgmac_rx_header *rx;
-+		struct bgmac_rx_header *rx = slot->buf;
-+		struct sk_buff *skb;
-+		void *buf = slot->buf;
- 		u16 len, flags;
- 
- 		/* Unmap buffer to make it accessible to the CPU */
-@@ -352,7 +353,6 @@ static int bgmac_dma_rx_read(struct bgma
- 					BGMAC_RX_BUF_SIZE, DMA_FROM_DEVICE);
- 
- 		/* Get info from the header */
--		rx = (struct bgmac_rx_header *)skb->data;
- 		len = le16_to_cpu(rx->len);
- 		flags = le16_to_cpu(rx->flags);
- 
-@@ -393,12 +393,13 @@ static int bgmac_dma_rx_read(struct bgma
- 			dma_unmap_single(dma_dev, old_dma_addr,
- 					 BGMAC_RX_BUF_SIZE, DMA_FROM_DEVICE);
- 
-+			skb = build_skb(buf, BGMAC_RX_ALLOC_SIZE);
- 			skb_put(skb, BGMAC_RX_FRAME_OFFSET + len);
- 			skb_pull(skb, BGMAC_RX_FRAME_OFFSET);
- 
- 			skb_checksum_none_assert(skb);
- 			skb->protocol = eth_type_trans(skb, bgmac->net_dev);
--			netif_receive_skb(skb);
-+			napi_gro_receive(&bgmac->napi, skb);
- 			handled++;
- 		} while (0);
- 
-@@ -434,12 +435,11 @@ static bool bgmac_dma_unaligned(struct b
- 	return false;
- }
- 
--static void bgmac_dma_ring_free(struct bgmac *bgmac,
--				struct bgmac_dma_ring *ring)
-+static void bgmac_dma_tx_ring_free(struct bgmac *bgmac,
-+				   struct bgmac_dma_ring *ring)
- {
- 	struct device *dma_dev = bgmac->core->dma_dev;
- 	struct bgmac_slot_info *slot;
--	int size;
- 	int i;
- 
- 	for (i = 0; i < ring->num_slots; i++) {
-@@ -451,23 +451,55 @@ static void bgmac_dma_ring_free(struct b
- 			dev_kfree_skb(slot->skb);
- 		}
- 	}
-+}
-+
-+static void bgmac_dma_rx_ring_free(struct bgmac *bgmac,
-+				   struct bgmac_dma_ring *ring)
-+{
-+	struct device *dma_dev = bgmac->core->dma_dev;
-+	struct bgmac_slot_info *slot;
-+	int i;
-+
-+	for (i = 0; i < ring->num_slots; i++) {
-+		slot = &ring->slots[i];
-+		if (!slot->buf)
-+			continue;
- 
--	if (ring->cpu_base) {
--		/* Free ring of descriptors */
--		size = ring->num_slots * sizeof(struct bgmac_dma_desc);
--		dma_free_coherent(dma_dev, size, ring->cpu_base,
--				  ring->dma_base);
-+		if (slot->dma_addr)
-+			dma_unmap_single(dma_dev, slot->dma_addr,
-+					 BGMAC_RX_BUF_SIZE,
-+					 DMA_FROM_DEVICE);
-+		put_page(virt_to_head_page(slot->buf));
- 	}
- }
- 
-+static void bgmac_dma_ring_desc_free(struct bgmac *bgmac,
-+				     struct bgmac_dma_ring *ring)
-+{
-+	struct device *dma_dev = bgmac->core->dma_dev;
-+	int size;
-+
-+	if (!ring->cpu_base)
-+	    return;
-+
-+	/* Free ring of descriptors */
-+	size = ring->num_slots * sizeof(struct bgmac_dma_desc);
-+	dma_free_coherent(dma_dev, size, ring->cpu_base,
-+			  ring->dma_base);
-+}
-+
- static void bgmac_dma_free(struct bgmac *bgmac)
- {
- 	int i;
- 
--	for (i = 0; i < BGMAC_MAX_TX_RINGS; i++)
--		bgmac_dma_ring_free(bgmac, &bgmac->tx_ring[i]);
--	for (i = 0; i < BGMAC_MAX_RX_RINGS; i++)
--		bgmac_dma_ring_free(bgmac, &bgmac->rx_ring[i]);
-+	for (i = 0; i < BGMAC_MAX_TX_RINGS; i++) {
-+		bgmac_dma_tx_ring_free(bgmac, &bgmac->tx_ring[i]);
-+		bgmac_dma_ring_desc_free(bgmac, &bgmac->tx_ring[i]);
-+	}
-+	for (i = 0; i < BGMAC_MAX_RX_RINGS; i++) {
-+		bgmac_dma_rx_ring_free(bgmac, &bgmac->rx_ring[i]);
-+		bgmac_dma_ring_desc_free(bgmac, &bgmac->rx_ring[i]);
-+	}
- }
- 
- static int bgmac_dma_alloc(struct bgmac *bgmac)
---- a/drivers/net/ethernet/broadcom/bgmac.h
-+++ b/drivers/net/ethernet/broadcom/bgmac.h
-@@ -362,6 +362,8 @@
- #define BGMAC_RX_FRAME_OFFSET			30		/* There are 2 unused bytes between header and real data */
- #define BGMAC_RX_MAX_FRAME_SIZE			1536		/* Copied from b44/tg3 */
- #define BGMAC_RX_BUF_SIZE			(BGMAC_RX_FRAME_OFFSET + BGMAC_RX_MAX_FRAME_SIZE)
-+#define BGMAC_RX_ALLOC_SIZE			(SKB_DATA_ALIGN(BGMAC_RX_BUF_SIZE) + \
-+						 SKB_DATA_ALIGN(sizeof(struct skb_shared_info)))
- 
- #define BGMAC_BFL_ENETROBO			0x0010		/* has ephy roboswitch spi */
- #define BGMAC_BFL_ENETADM			0x0080		/* has ADMtek switch */
-@@ -383,7 +385,10 @@
- #define ETHER_MAX_LEN   1518
- 
- struct bgmac_slot_info {
--	struct sk_buff *skb;
-+	union {
-+		struct sk_buff *skb;
-+		void *buf;
-+	};
- 	dma_addr_t dma_addr;
- };
- 
--- a/target/linux/generic/pending-3.18/077-03-bgmac-implement-scatter-gather-support.patch	2022-03-22 08:54:47.258464754 +0800
+++ b/target/linux/generic/pending-3.18/077-03-bgmac-implement-scatter-gather-support.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,267 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Mon, 23 Mar 2015 02:42:26 +0100
-Subject: [PATCH] bgmac: implement scatter/gather support
-
-Always use software checksumming, since the hardware does not have any
-checksum offload support.
-This significantly improves local TCP tx performance.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/drivers/net/ethernet/broadcom/bgmac.c
-+++ b/drivers/net/ethernet/broadcom/bgmac.c
-@@ -115,53 +115,91 @@ static void bgmac_dma_tx_enable(struct b
- 	bgmac_write(bgmac, ring->mmio_base + BGMAC_DMA_TX_CTL, ctl);
- }
- 
-+static void
-+bgmac_dma_tx_add_buf(struct bgmac *bgmac, struct bgmac_dma_ring *ring,
-+		     int i, int len, u32 ctl0)
-+{
-+	struct bgmac_slot_info *slot;
-+	struct bgmac_dma_desc *dma_desc;
-+	u32 ctl1;
-+
-+	if (i == ring->num_slots - 1)
-+		ctl0 |= BGMAC_DESC_CTL0_EOT;
-+
-+	ctl1 = len & BGMAC_DESC_CTL1_LEN;
-+
-+	slot = &ring->slots[i];
-+	dma_desc = &ring->cpu_base[i];
-+	dma_desc->addr_low = cpu_to_le32(lower_32_bits(slot->dma_addr));
-+	dma_desc->addr_high = cpu_to_le32(upper_32_bits(slot->dma_addr));
-+	dma_desc->ctl0 = cpu_to_le32(ctl0);
-+	dma_desc->ctl1 = cpu_to_le32(ctl1);
-+}
-+
- static netdev_tx_t bgmac_dma_tx_add(struct bgmac *bgmac,
- 				    struct bgmac_dma_ring *ring,
- 				    struct sk_buff *skb)
- {
- 	struct device *dma_dev = bgmac->core->dma_dev;
- 	struct net_device *net_dev = bgmac->net_dev;
--	struct bgmac_dma_desc *dma_desc;
--	struct bgmac_slot_info *slot;
--	u32 ctl0, ctl1;
-+	struct bgmac_slot_info *slot = &ring->slots[ring->end];
- 	int free_slots;
-+	int nr_frags;
-+	u32 flags;
-+	int index = ring->end;
-+	int i;
- 
- 	if (skb->len > BGMAC_DESC_CTL1_LEN) {
- 		bgmac_err(bgmac, "Too long skb (%d)\n", skb->len);
--		goto err_stop_drop;
-+		goto err_drop;
- 	}
- 
-+	if (skb->ip_summed == CHECKSUM_PARTIAL)
-+		skb_checksum_help(skb);
-+
-+	nr_frags = skb_shinfo(skb)->nr_frags;
-+
- 	if (ring->start <= ring->end)
- 		free_slots = ring->start - ring->end + BGMAC_TX_RING_SLOTS;
- 	else
- 		free_slots = ring->start - ring->end;
--	if (free_slots == 1) {
-+
-+	if (free_slots <= nr_frags + 1) {
- 		bgmac_err(bgmac, "TX ring is full, queue should be stopped!\n");
- 		netif_stop_queue(net_dev);
- 		return NETDEV_TX_BUSY;
- 	}
- 
--	slot = &ring->slots[ring->end];
--	slot->skb = skb;
--	slot->dma_addr = dma_map_single(dma_dev, skb->data, skb->len,
-+	slot->dma_addr = dma_map_single(dma_dev, skb->data, skb_headlen(skb),
- 					DMA_TO_DEVICE);
--	if (dma_mapping_error(dma_dev, slot->dma_addr)) {
--		bgmac_err(bgmac, "Mapping error of skb on ring 0x%X\n",
--			  ring->mmio_base);
--		goto err_stop_drop;
--	}
-+	if (unlikely(dma_mapping_error(dma_dev, slot->dma_addr)))
-+		goto err_dma_head;
- 
--	ctl0 = BGMAC_DESC_CTL0_IOC | BGMAC_DESC_CTL0_SOF | BGMAC_DESC_CTL0_EOF;
--	if (ring->end == ring->num_slots - 1)
--		ctl0 |= BGMAC_DESC_CTL0_EOT;
--	ctl1 = skb->len & BGMAC_DESC_CTL1_LEN;
-+	flags = BGMAC_DESC_CTL0_SOF;
-+	if (!nr_frags)
-+		flags |= BGMAC_DESC_CTL0_EOF | BGMAC_DESC_CTL0_IOC;
-+
-+	bgmac_dma_tx_add_buf(bgmac, ring, index, skb_headlen(skb), flags);
-+	flags = 0;
-+
-+	for (i = 0; i < nr_frags; i++) {
-+		struct skb_frag_struct *frag = &skb_shinfo(skb)->frags[i];
-+		int len = skb_frag_size(frag);
-+
-+		index = (index + 1) % BGMAC_TX_RING_SLOTS;
-+		slot = &ring->slots[index];
-+		slot->dma_addr = skb_frag_dma_map(dma_dev, frag, 0,
-+						  len, DMA_TO_DEVICE);
-+		if (unlikely(dma_mapping_error(dma_dev, slot->dma_addr)))
-+			goto err_dma;
- 
--	dma_desc = ring->cpu_base;
--	dma_desc += ring->end;
--	dma_desc->addr_low = cpu_to_le32(lower_32_bits(slot->dma_addr));
--	dma_desc->addr_high = cpu_to_le32(upper_32_bits(slot->dma_addr));
--	dma_desc->ctl0 = cpu_to_le32(ctl0);
--	dma_desc->ctl1 = cpu_to_le32(ctl1);
-+		if (i == nr_frags - 1)
-+			flags |= BGMAC_DESC_CTL0_EOF | BGMAC_DESC_CTL0_IOC;
-+
-+		bgmac_dma_tx_add_buf(bgmac, ring, index, len, flags);
-+	}
-+
-+	slot->skb = skb;
- 
- 	netdev_sent_queue(net_dev, skb->len);
- 
-@@ -170,20 +208,35 @@ static netdev_tx_t bgmac_dma_tx_add(stru
- 	/* Increase ring->end to point empty slot. We tell hardware the first
- 	 * slot it should *not* read.
- 	 */
--	if (++ring->end >= BGMAC_TX_RING_SLOTS)
--		ring->end = 0;
-+	ring->end = (index + 1) % BGMAC_TX_RING_SLOTS;
- 	bgmac_write(bgmac, ring->mmio_base + BGMAC_DMA_TX_INDEX,
- 		    ring->index_base +
- 		    ring->end * sizeof(struct bgmac_dma_desc));
- 
--	/* Always keep one slot free to allow detecting bugged calls. */
--	if (--free_slots == 1)
-+	free_slots -= nr_frags + 1;
-+	if (free_slots < 8)
- 		netif_stop_queue(net_dev);
- 
- 	return NETDEV_TX_OK;
- 
--err_stop_drop:
--	netif_stop_queue(net_dev);
-+err_dma:
-+	dma_unmap_single(dma_dev, slot->dma_addr, skb_headlen(skb),
-+			 DMA_TO_DEVICE);
-+
-+	while (i > 0) {
-+		int index = (ring->end + i) % BGMAC_TX_RING_SLOTS;
-+		struct bgmac_slot_info *slot = &ring->slots[index];
-+		u32 ctl1 = le32_to_cpu(ring->cpu_base[index].ctl1);
-+		int len = ctl1 & BGMAC_DESC_CTL1_LEN;
-+
-+		dma_unmap_page(dma_dev, slot->dma_addr, len, DMA_TO_DEVICE);
-+	}
-+
-+err_dma_head:
-+	bgmac_err(bgmac, "Mapping error of skb on ring 0x%X\n",
-+		  ring->mmio_base);
-+
-+err_drop:
- 	dev_kfree_skb(skb);
- 	return NETDEV_TX_OK;
- }
-@@ -205,32 +258,45 @@ static void bgmac_dma_tx_free(struct bgm
- 
- 	while (ring->start != empty_slot) {
- 		struct bgmac_slot_info *slot = &ring->slots[ring->start];
-+		u32 ctl1 = le32_to_cpu(ring->cpu_base[ring->start].ctl1);
-+		int len = ctl1 & BGMAC_DESC_CTL1_LEN;
- 
--		if (slot->skb) {
-+		if (!slot->dma_addr) {
-+			bgmac_err(bgmac, "Hardware reported transmission for empty TX ring slot %d! End of ring: %d\n",
-+				  ring->start, ring->end);
-+			goto next;
-+		}
-+
-+		if (ctl1 & BGMAC_DESC_CTL0_SOF)
- 			/* Unmap no longer used buffer */
--			dma_unmap_single(dma_dev, slot->dma_addr,
--					 slot->skb->len, DMA_TO_DEVICE);
--			slot->dma_addr = 0;
-+			dma_unmap_single(dma_dev, slot->dma_addr, len,
-+					 DMA_TO_DEVICE);
-+		else
-+			dma_unmap_page(dma_dev, slot->dma_addr, len,
-+				       DMA_TO_DEVICE);
- 
-+		if (slot->skb) {
- 			bytes_compl += slot->skb->len;
- 			pkts_compl++;
- 
- 			/* Free memory! :) */
- 			dev_kfree_skb(slot->skb);
- 			slot->skb = NULL;
--		} else {
--			bgmac_err(bgmac, "Hardware reported transmission for empty TX ring slot %d! End of ring: %d\n",
--				  ring->start, ring->end);
- 		}
- 
-+next:
-+		slot->dma_addr = 0;
- 		if (++ring->start >= BGMAC_TX_RING_SLOTS)
- 			ring->start = 0;
- 		freed = true;
- 	}
- 
-+	if (!pkts_compl)
-+		return;
-+
- 	netdev_completed_queue(bgmac->net_dev, pkts_compl, bytes_compl);
- 
--	if (freed && netif_queue_stopped(bgmac->net_dev))
-+	if (netif_queue_stopped(bgmac->net_dev))
- 		netif_wake_queue(bgmac->net_dev);
- }
- 
-@@ -439,17 +505,25 @@ static void bgmac_dma_tx_ring_free(struc
- 				   struct bgmac_dma_ring *ring)
- {
- 	struct device *dma_dev = bgmac->core->dma_dev;
-+	struct bgmac_dma_desc *dma_desc = ring->cpu_base;
- 	struct bgmac_slot_info *slot;
- 	int i;
- 
- 	for (i = 0; i < ring->num_slots; i++) {
-+		int len = dma_desc[i].ctl1 & BGMAC_DESC_CTL1_LEN;
-+
- 		slot = &ring->slots[i];
--		if (slot->skb) {
--			if (slot->dma_addr)
--				dma_unmap_single(dma_dev, slot->dma_addr,
--						 slot->skb->len, DMA_TO_DEVICE);
--			dev_kfree_skb(slot->skb);
--		}
-+		dev_kfree_skb(slot->skb);
-+
-+		if (!slot->dma_addr)
-+			continue;
-+
-+		if (slot->skb)
-+			dma_unmap_single(dma_dev, slot->dma_addr,
-+					 len, DMA_TO_DEVICE);
-+		else
-+			dma_unmap_page(dma_dev, slot->dma_addr,
-+				       len, DMA_TO_DEVICE);
- 	}
- }
- 
-@@ -1588,6 +1662,10 @@ static int bgmac_probe(struct bcma_devic
- 		goto err_dma_free;
- 	}
- 
-+	net_dev->features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;
-+	net_dev->hw_features = net_dev->features;
-+	net_dev->vlan_features = net_dev->features;
-+
- 	err = register_netdev(bgmac->net_dev);
- 	if (err) {
- 		bgmac_err(bgmac, "Cannot register net device\n");
--- a/target/linux/generic/pending-3.18/077-04-bgmac-simplify-tx-ring-index-handling.patch	2022-03-22 08:54:47.258464754 +0800
+++ b/target/linux/generic/pending-3.18/077-04-bgmac-simplify-tx-ring-index-handling.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,125 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sun, 12 Apr 2015 09:58:56 +0200
-Subject: [PATCH] bgmac: simplify tx ring index handling
-
-Keep incrementing ring->start and ring->end instead of pointing it to
-the actual ring slot entry. This simplifies the calculation of the
-number of free slots.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/drivers/net/ethernet/broadcom/bgmac.c
-+++ b/drivers/net/ethernet/broadcom/bgmac.c
-@@ -142,11 +142,10 @@ static netdev_tx_t bgmac_dma_tx_add(stru
- {
- 	struct device *dma_dev = bgmac->core->dma_dev;
- 	struct net_device *net_dev = bgmac->net_dev;
--	struct bgmac_slot_info *slot = &ring->slots[ring->end];
--	int free_slots;
-+	int index = ring->end % BGMAC_TX_RING_SLOTS;
-+	struct bgmac_slot_info *slot = &ring->slots[index];
- 	int nr_frags;
- 	u32 flags;
--	int index = ring->end;
- 	int i;
- 
- 	if (skb->len > BGMAC_DESC_CTL1_LEN) {
-@@ -159,12 +158,10 @@ static netdev_tx_t bgmac_dma_tx_add(stru
- 
- 	nr_frags = skb_shinfo(skb)->nr_frags;
- 
--	if (ring->start <= ring->end)
--		free_slots = ring->start - ring->end + BGMAC_TX_RING_SLOTS;
--	else
--		free_slots = ring->start - ring->end;
--
--	if (free_slots <= nr_frags + 1) {
-+	/* ring->end - ring->start will return the number of valid slots,
-+	 * even when ring->end overflows
-+	 */
-+	if (ring->end - ring->start + nr_frags + 1 >= BGMAC_TX_RING_SLOTS) {
- 		bgmac_err(bgmac, "TX ring is full, queue should be stopped!\n");
- 		netif_stop_queue(net_dev);
- 		return NETDEV_TX_BUSY;
-@@ -200,7 +197,7 @@ static netdev_tx_t bgmac_dma_tx_add(stru
- 	}
- 
- 	slot->skb = skb;
--
-+	ring->end += nr_frags + 1;
- 	netdev_sent_queue(net_dev, skb->len);
- 
- 	wmb();
-@@ -208,13 +205,12 @@ static netdev_tx_t bgmac_dma_tx_add(stru
- 	/* Increase ring->end to point empty slot. We tell hardware the first
- 	 * slot it should *not* read.
- 	 */
--	ring->end = (index + 1) % BGMAC_TX_RING_SLOTS;
- 	bgmac_write(bgmac, ring->mmio_base + BGMAC_DMA_TX_INDEX,
- 		    ring->index_base +
--		    ring->end * sizeof(struct bgmac_dma_desc));
-+		    (ring->end % BGMAC_TX_RING_SLOTS) *
-+		    sizeof(struct bgmac_dma_desc));
- 
--	free_slots -= nr_frags + 1;
--	if (free_slots < 8)
-+	if (ring->end - ring->start >= BGMAC_TX_RING_SLOTS - 8)
- 		netif_stop_queue(net_dev);
- 
- 	return NETDEV_TX_OK;
-@@ -256,17 +252,17 @@ static void bgmac_dma_tx_free(struct bgm
- 	empty_slot &= BGMAC_DMA_TX_STATDPTR;
- 	empty_slot /= sizeof(struct bgmac_dma_desc);
- 
--	while (ring->start != empty_slot) {
--		struct bgmac_slot_info *slot = &ring->slots[ring->start];
--		u32 ctl1 = le32_to_cpu(ring->cpu_base[ring->start].ctl1);
--		int len = ctl1 & BGMAC_DESC_CTL1_LEN;
-+	while (ring->start != ring->end) {
-+		int slot_idx = ring->start % BGMAC_TX_RING_SLOTS;
-+		struct bgmac_slot_info *slot = &ring->slots[slot_idx];
-+		u32 ctl1;
-+		int len;
- 
--		if (!slot->dma_addr) {
--			bgmac_err(bgmac, "Hardware reported transmission for empty TX ring slot %d! End of ring: %d\n",
--				  ring->start, ring->end);
--			goto next;
--		}
-+		if (slot_idx == empty_slot)
-+			break;
- 
-+		ctl1 = le32_to_cpu(ring->cpu_base[slot_idx].ctl1);
-+		len = ctl1 & BGMAC_DESC_CTL1_LEN;
- 		if (ctl1 & BGMAC_DESC_CTL0_SOF)
- 			/* Unmap no longer used buffer */
- 			dma_unmap_single(dma_dev, slot->dma_addr, len,
-@@ -284,10 +280,8 @@ static void bgmac_dma_tx_free(struct bgm
- 			slot->skb = NULL;
- 		}
- 
--next:
- 		slot->dma_addr = 0;
--		if (++ring->start >= BGMAC_TX_RING_SLOTS)
--			ring->start = 0;
-+		ring->start++;
- 		freed = true;
- 	}
- 
---- a/drivers/net/ethernet/broadcom/bgmac.h
-+++ b/drivers/net/ethernet/broadcom/bgmac.h
-@@ -414,10 +414,10 @@ enum bgmac_dma_ring_type {
-  * empty.
-  */
- struct bgmac_dma_ring {
--	u16 num_slots;
--	u16 start;
--	u16 end;
-+	u32 start;
-+	u32 end;
- 
-+	u16 num_slots;
- 	u16 mmio_base;
- 	struct bgmac_dma_desc *cpu_base;
- 	dma_addr_t dma_base;
--- a/target/linux/generic/pending-3.18/077-05-bgmac-leave-interrupts-disabled-as-long-as-there-is-.patch	2022-03-22 08:54:47.258464754 +0800
+++ b/target/linux/generic/pending-3.18/077-05-bgmac-leave-interrupts-disabled-as-long-as-there-is-.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,87 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sun, 12 Apr 2015 10:08:04 +0200
-Subject: [PATCH] bgmac: leave interrupts disabled as long as there is work
- to do
-
-Always poll rx and tx during NAPI poll instead of relying on the status
-of the first interrupt. This prevents bgmac_poll from leaving unfinished
-work around until the next IRQ.
-In my tests this makes bridging/routing throughput under heavy load more
-stable and ensures that no new IRQs arrive as long as bgmac_poll uses up
-the entire budget.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/drivers/net/ethernet/broadcom/bgmac.c
-+++ b/drivers/net/ethernet/broadcom/bgmac.c
-@@ -1109,8 +1109,6 @@ static void bgmac_chip_reset(struct bgma
- 	bgmac_phy_init(bgmac);
- 
- 	netdev_reset_queue(bgmac->net_dev);
--
--	bgmac->int_status = 0;
- }
- 
- static void bgmac_chip_intrs_on(struct bgmac *bgmac)
-@@ -1225,14 +1223,13 @@ static irqreturn_t bgmac_interrupt(int i
- 	if (!int_status)
- 		return IRQ_NONE;
- 
--	/* Ack */
--	bgmac_write(bgmac, BGMAC_INT_STATUS, int_status);
-+	int_status &= ~(BGMAC_IS_TX0 | BGMAC_IS_RX);
-+	if (int_status)
-+		bgmac_err(bgmac, "Unknown IRQs: 0x%08X\n", int_status);
- 
- 	/* Disable new interrupts until handling existing ones */
- 	bgmac_chip_intrs_off(bgmac);
- 
--	bgmac->int_status = int_status;
--
- 	napi_schedule(&bgmac->napi);
- 
- 	return IRQ_HANDLED;
-@@ -1241,25 +1238,17 @@ static irqreturn_t bgmac_interrupt(int i
- static int bgmac_poll(struct napi_struct *napi, int weight)
- {
- 	struct bgmac *bgmac = container_of(napi, struct bgmac, napi);
--	struct bgmac_dma_ring *ring;
- 	int handled = 0;
- 
--	if (bgmac->int_status & BGMAC_IS_TX0) {
--		ring = &bgmac->tx_ring[0];
--		bgmac_dma_tx_free(bgmac, ring);
--		bgmac->int_status &= ~BGMAC_IS_TX0;
--	}
-+	/* Ack */
-+	bgmac_write(bgmac, BGMAC_INT_STATUS, ~0);
- 
--	if (bgmac->int_status & BGMAC_IS_RX) {
--		ring = &bgmac->rx_ring[0];
--		handled += bgmac_dma_rx_read(bgmac, ring, weight);
--		bgmac->int_status &= ~BGMAC_IS_RX;
--	}
-+	bgmac_dma_tx_free(bgmac, &bgmac->tx_ring[0]);
-+	handled += bgmac_dma_rx_read(bgmac, &bgmac->rx_ring[0], weight);
- 
--	if (bgmac->int_status) {
--		bgmac_err(bgmac, "Unknown IRQs: 0x%08X\n", bgmac->int_status);
--		bgmac->int_status = 0;
--	}
-+	/* Poll again if more events arrived in the meantime */
-+	if (bgmac_read(bgmac, BGMAC_INT_STATUS) & (BGMAC_IS_TX0 | BGMAC_IS_RX))
-+		return handled;
- 
- 	if (handled < weight) {
- 		napi_complete(napi);
---- a/drivers/net/ethernet/broadcom/bgmac.h
-+++ b/drivers/net/ethernet/broadcom/bgmac.h
-@@ -452,7 +452,6 @@ struct bgmac {
- 
- 	/* Int */
- 	u32 int_mask;
--	u32 int_status;
- 
- 	/* Current MAC state */
- 	int mac_speed;
--- a/target/linux/generic/pending-3.18/077-06-bgmac-set-received-skb-headroom-to-NET_SKB_PAD.patch	2022-03-22 08:54:47.259464756 +0800
+++ b/target/linux/generic/pending-3.18/077-06-bgmac-set-received-skb-headroom-to-NET_SKB_PAD.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,66 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sun, 12 Apr 2015 10:13:28 +0200
-Subject: [PATCH] bgmac: set received skb headroom to NET_SKB_PAD
-
-A packet buffer offset of 30 bytes is inefficient, because the first 2
-bytes end up in a different cacheline.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/drivers/net/ethernet/broadcom/bgmac.c
-+++ b/drivers/net/ethernet/broadcom/bgmac.c
-@@ -346,13 +346,13 @@ static int bgmac_dma_rx_skb_for_slot(str
- 		return -ENOMEM;
- 
- 	/* Poison - if everything goes fine, hardware will overwrite it */
--	rx = buf;
-+	rx = buf + BGMAC_RX_BUF_OFFSET;
- 	rx->len = cpu_to_le16(0xdead);
- 	rx->flags = cpu_to_le16(0xbeef);
- 
- 	/* Map skb for the DMA */
--	dma_addr = dma_map_single(dma_dev, buf, BGMAC_RX_BUF_SIZE,
--				  DMA_FROM_DEVICE);
-+	dma_addr = dma_map_single(dma_dev, buf + BGMAC_RX_BUF_OFFSET,
-+				  BGMAC_RX_BUF_SIZE, DMA_FROM_DEVICE);
- 	if (dma_mapping_error(dma_dev, dma_addr)) {
- 		bgmac_err(bgmac, "DMA mapping error\n");
- 		put_page(virt_to_head_page(buf));
-@@ -403,7 +403,7 @@ static int bgmac_dma_rx_read(struct bgma
- 	while (ring->start != ring->end) {
- 		struct device *dma_dev = bgmac->core->dma_dev;
- 		struct bgmac_slot_info *slot = &ring->slots[ring->start];
--		struct bgmac_rx_header *rx = slot->buf;
-+		struct bgmac_rx_header *rx = slot->buf + BGMAC_RX_BUF_OFFSET;
- 		struct sk_buff *skb;
- 		void *buf = slot->buf;
- 		u16 len, flags;
-@@ -454,8 +454,10 @@ static int bgmac_dma_rx_read(struct bgma
- 					 BGMAC_RX_BUF_SIZE, DMA_FROM_DEVICE);
- 
- 			skb = build_skb(buf, BGMAC_RX_ALLOC_SIZE);
--			skb_put(skb, BGMAC_RX_FRAME_OFFSET + len);
--			skb_pull(skb, BGMAC_RX_FRAME_OFFSET);
-+			skb_put(skb, BGMAC_RX_FRAME_OFFSET +
-+				BGMAC_RX_BUF_OFFSET + len);
-+			skb_pull(skb, BGMAC_RX_FRAME_OFFSET +
-+				 BGMAC_RX_BUF_OFFSET);
- 
- 			skb_checksum_none_assert(skb);
- 			skb->protocol = eth_type_trans(skb, bgmac->net_dev);
---- a/drivers/net/ethernet/broadcom/bgmac.h
-+++ b/drivers/net/ethernet/broadcom/bgmac.h
-@@ -360,9 +360,11 @@
- 
- #define BGMAC_RX_HEADER_LEN			28		/* Last 24 bytes are unused. Well... */
- #define BGMAC_RX_FRAME_OFFSET			30		/* There are 2 unused bytes between header and real data */
-+#define BGMAC_RX_BUF_OFFSET			(NET_SKB_PAD + NET_IP_ALIGN - \
-+						 BGMAC_RX_FRAME_OFFSET)
- #define BGMAC_RX_MAX_FRAME_SIZE			1536		/* Copied from b44/tg3 */
- #define BGMAC_RX_BUF_SIZE			(BGMAC_RX_FRAME_OFFSET + BGMAC_RX_MAX_FRAME_SIZE)
--#define BGMAC_RX_ALLOC_SIZE			(SKB_DATA_ALIGN(BGMAC_RX_BUF_SIZE) + \
-+#define BGMAC_RX_ALLOC_SIZE			(SKB_DATA_ALIGN(BGMAC_RX_BUF_SIZE + BGMAC_RX_BUF_OFFSET) + \
- 						 SKB_DATA_ALIGN(sizeof(struct skb_shared_info)))
- 
- #define BGMAC_BFL_ENETROBO			0x0010		/* has ephy roboswitch spi */
--- a/target/linux/generic/pending-3.18/077-07-bgmac-simplify-rx-DMA-error-handling.patch	2022-03-22 08:54:47.259464756 +0800
+++ b/target/linux/generic/pending-3.18/077-07-bgmac-simplify-rx-DMA-error-handling.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,130 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sun, 12 Apr 2015 22:23:07 +0200
-Subject: [PATCH] bgmac: simplify/optimize rx DMA error handling
-
-Allocate a new buffer before processing the completed one. If allocation
-fails, reuse the old buffer.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/drivers/net/ethernet/broadcom/bgmac.c
-+++ b/drivers/net/ethernet/broadcom/bgmac.c
-@@ -386,6 +386,19 @@ static void bgmac_dma_rx_setup_desc(stru
- 	dma_desc->ctl1 = cpu_to_le32(ctl1);
- }
- 
-+static void bgmac_dma_rx_poison_buf(struct device *dma_dev,
-+				    struct bgmac_slot_info *slot)
-+{
-+	struct bgmac_rx_header *rx = slot->buf + BGMAC_RX_BUF_OFFSET;
-+
-+	dma_sync_single_for_cpu(dma_dev, slot->dma_addr, BGMAC_RX_BUF_SIZE,
-+				DMA_FROM_DEVICE);
-+	rx->len = cpu_to_le16(0xdead);
-+	rx->flags = cpu_to_le16(0xbeef);
-+	dma_sync_single_for_device(dma_dev, slot->dma_addr, BGMAC_RX_BUF_SIZE,
-+				   DMA_FROM_DEVICE);
-+}
-+
- static int bgmac_dma_rx_read(struct bgmac *bgmac, struct bgmac_dma_ring *ring,
- 			     int weight)
- {
-@@ -406,53 +419,35 @@ static int bgmac_dma_rx_read(struct bgma
- 		struct bgmac_rx_header *rx = slot->buf + BGMAC_RX_BUF_OFFSET;
- 		struct sk_buff *skb;
- 		void *buf = slot->buf;
-+		dma_addr_t dma_addr = slot->dma_addr;
- 		u16 len, flags;
- 
--		/* Unmap buffer to make it accessible to the CPU */
--		dma_sync_single_for_cpu(dma_dev, slot->dma_addr,
--					BGMAC_RX_BUF_SIZE, DMA_FROM_DEVICE);
--
--		/* Get info from the header */
--		len = le16_to_cpu(rx->len);
--		flags = le16_to_cpu(rx->flags);
--
- 		do {
--			dma_addr_t old_dma_addr = slot->dma_addr;
--			int err;
-+			/* Prepare new skb as replacement */
-+			if (bgmac_dma_rx_skb_for_slot(bgmac, slot)) {
-+				bgmac_dma_rx_poison_buf(dma_dev, slot);
-+				break;
-+			}
-+
-+			/* Unmap buffer to make it accessible to the CPU */
-+			dma_unmap_single(dma_dev, dma_addr,
-+					 BGMAC_RX_BUF_SIZE, DMA_FROM_DEVICE);
-+
-+			/* Get info from the header */
-+			len = le16_to_cpu(rx->len);
-+			flags = le16_to_cpu(rx->flags);
- 
- 			/* Check for poison and drop or pass the packet */
- 			if (len == 0xdead && flags == 0xbeef) {
- 				bgmac_err(bgmac, "Found poisoned packet at slot %d, DMA issue!\n",
- 					  ring->start);
--				dma_sync_single_for_device(dma_dev,
--							   slot->dma_addr,
--							   BGMAC_RX_BUF_SIZE,
--							   DMA_FROM_DEVICE);
-+				put_page(virt_to_head_page(buf));
- 				break;
- 			}
- 
- 			/* Omit CRC. */
- 			len -= ETH_FCS_LEN;
- 
--			/* Prepare new skb as replacement */
--			err = bgmac_dma_rx_skb_for_slot(bgmac, slot);
--			if (err) {
--				/* Poison the old skb */
--				rx->len = cpu_to_le16(0xdead);
--				rx->flags = cpu_to_le16(0xbeef);
--
--				dma_sync_single_for_device(dma_dev,
--							   slot->dma_addr,
--							   BGMAC_RX_BUF_SIZE,
--							   DMA_FROM_DEVICE);
--				break;
--			}
--			bgmac_dma_rx_setup_desc(bgmac, ring, ring->start);
--
--			/* Unmap old skb, we'll pass it to the netfif */
--			dma_unmap_single(dma_dev, old_dma_addr,
--					 BGMAC_RX_BUF_SIZE, DMA_FROM_DEVICE);
--
- 			skb = build_skb(buf, BGMAC_RX_ALLOC_SIZE);
- 			skb_put(skb, BGMAC_RX_FRAME_OFFSET +
- 				BGMAC_RX_BUF_OFFSET + len);
-@@ -465,6 +460,8 @@ static int bgmac_dma_rx_read(struct bgma
- 			handled++;
- 		} while (0);
- 
-+		bgmac_dma_rx_setup_desc(bgmac, ring, ring->start);
-+
- 		if (++ring->start >= BGMAC_RX_RING_SLOTS)
- 			ring->start = 0;
- 
-@@ -532,14 +529,14 @@ static void bgmac_dma_rx_ring_free(struc
- 
- 	for (i = 0; i < ring->num_slots; i++) {
- 		slot = &ring->slots[i];
--		if (!slot->buf)
-+		if (!slot->dma_addr)
- 			continue;
- 
--		if (slot->dma_addr)
--			dma_unmap_single(dma_dev, slot->dma_addr,
--					 BGMAC_RX_BUF_SIZE,
--					 DMA_FROM_DEVICE);
-+		dma_unmap_single(dma_dev, slot->dma_addr,
-+				 BGMAC_RX_BUF_SIZE,
-+				 DMA_FROM_DEVICE);
- 		put_page(virt_to_head_page(slot->buf));
-+		slot->dma_addr = 0;
- 	}
- }
- 
--- a/target/linux/generic/pending-3.18/077-08-bgmac-add-check-for-oversized-packets.patch	2022-03-22 08:54:47.259464756 +0800
+++ b/target/linux/generic/pending-3.18/077-08-bgmac-add-check-for-oversized-packets.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,27 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sun, 12 Apr 2015 22:28:20 +0200
-Subject: [PATCH] bgmac: add check for oversized packets
-
-In very rare cases, the MAC can catch an internal buffer that is bigger
-than it's supposed to be. Instead of crashing the kernel, simply pass
-the buffer back to the hardware
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/drivers/net/ethernet/broadcom/bgmac.c
-+++ b/drivers/net/ethernet/broadcom/bgmac.c
-@@ -445,6 +445,13 @@ static int bgmac_dma_rx_read(struct bgma
- 				break;
- 			}
- 
-+			if (len > BGMAC_RX_ALLOC_SIZE) {
-+				bgmac_err(bgmac, "Found oversized packet at slot %d, DMA issue!\n",
-+					  ring->start);
-+				put_page(virt_to_head_page(buf));
-+				break;
-+			}
-+
- 			/* Omit CRC. */
- 			len -= ETH_FCS_LEN;
- 
--- a/target/linux/generic/pending-3.18/077-09-bgmac-increase-rx-ring-size-from-511-to-512.patch	2022-03-22 08:54:47.260464758 +0800
+++ b/target/linux/generic/pending-3.18/077-09-bgmac-increase-rx-ring-size-from-511-to-512.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,23 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sun, 12 Apr 2015 22:36:16 +0200
-Subject: [PATCH] bgmac: increase rx ring size from 511 to 512
-
-Limiting it to 511 looks like a failed attempt at leaving one descriptor
-empty to allow the hardware to stop processing a buffer that has not
-been prepared yet. However, this doesn't work because this affects the
-total ring size as well
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/drivers/net/ethernet/broadcom/bgmac.h
-+++ b/drivers/net/ethernet/broadcom/bgmac.h
-@@ -356,7 +356,7 @@
- #define BGMAC_MAX_RX_RINGS			1
- 
- #define BGMAC_TX_RING_SLOTS			128
--#define BGMAC_RX_RING_SLOTS			512 - 1		/* Why -1? Well, Broadcom does that... */
-+#define BGMAC_RX_RING_SLOTS			512
- 
- #define BGMAC_RX_HEADER_LEN			28		/* Last 24 bytes are unused. Well... */
- #define BGMAC_RX_FRAME_OFFSET			30		/* There are 2 unused bytes between header and real data */
--- a/target/linux/generic/pending-3.18/077-10-bgmac-simplify-dma-init-cleanup.patch	2022-03-22 08:54:47.260464758 +0800
+++ b/target/linux/generic/pending-3.18/077-10-bgmac-simplify-dma-init-cleanup.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,184 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sun, 12 Apr 2015 23:19:32 +0200
-Subject: [PATCH] bgmac: simplify dma init/cleanup
-
-Instead of allocating buffers at device init time and initializing
-descriptors at device open, do both at the same time (during open).
-Free all buffers when closing the device.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/drivers/net/ethernet/broadcom/bgmac.c
-+++ b/drivers/net/ethernet/broadcom/bgmac.c
-@@ -562,18 +562,26 @@ static void bgmac_dma_ring_desc_free(str
- 			  ring->dma_base);
- }
- 
--static void bgmac_dma_free(struct bgmac *bgmac)
-+static void bgmac_dma_cleanup(struct bgmac *bgmac)
- {
- 	int i;
- 
--	for (i = 0; i < BGMAC_MAX_TX_RINGS; i++) {
-+	for (i = 0; i < BGMAC_MAX_TX_RINGS; i++)
- 		bgmac_dma_tx_ring_free(bgmac, &bgmac->tx_ring[i]);
--		bgmac_dma_ring_desc_free(bgmac, &bgmac->tx_ring[i]);
--	}
--	for (i = 0; i < BGMAC_MAX_RX_RINGS; i++) {
-+
-+	for (i = 0; i < BGMAC_MAX_RX_RINGS; i++)
- 		bgmac_dma_rx_ring_free(bgmac, &bgmac->rx_ring[i]);
-+}
-+
-+static void bgmac_dma_free(struct bgmac *bgmac)
-+{
-+	int i;
-+
-+	for (i = 0; i < BGMAC_MAX_TX_RINGS; i++)
-+		bgmac_dma_ring_desc_free(bgmac, &bgmac->tx_ring[i]);
-+
-+	for (i = 0; i < BGMAC_MAX_RX_RINGS; i++)
- 		bgmac_dma_ring_desc_free(bgmac, &bgmac->rx_ring[i]);
--	}
- }
- 
- static int bgmac_dma_alloc(struct bgmac *bgmac)
-@@ -621,8 +629,6 @@ static int bgmac_dma_alloc(struct bgmac
- 	}
- 
- 	for (i = 0; i < BGMAC_MAX_RX_RINGS; i++) {
--		int j;
--
- 		ring = &bgmac->rx_ring[i];
- 		ring->num_slots = BGMAC_RX_RING_SLOTS;
- 		ring->mmio_base = ring_base[i];
-@@ -645,15 +651,6 @@ static int bgmac_dma_alloc(struct bgmac
- 			ring->index_base = lower_32_bits(ring->dma_base);
- 		else
- 			ring->index_base = 0;
--
--		/* Alloc RX slots */
--		for (j = 0; j < ring->num_slots; j++) {
--			err = bgmac_dma_rx_skb_for_slot(bgmac, &ring->slots[j]);
--			if (err) {
--				bgmac_err(bgmac, "Can't allocate skb for slot in RX ring\n");
--				goto err_dma_free;
--			}
--		}
- 	}
- 
- 	return 0;
-@@ -663,10 +660,10 @@ err_dma_free:
- 	return -ENOMEM;
- }
- 
--static void bgmac_dma_init(struct bgmac *bgmac)
-+static int bgmac_dma_init(struct bgmac *bgmac)
- {
- 	struct bgmac_dma_ring *ring;
--	int i;
-+	int i, err;
- 
- 	for (i = 0; i < BGMAC_MAX_TX_RINGS; i++) {
- 		ring = &bgmac->tx_ring[i];
-@@ -698,8 +695,13 @@ static void bgmac_dma_init(struct bgmac
- 		if (ring->unaligned)
- 			bgmac_dma_rx_enable(bgmac, ring);
- 
--		for (j = 0; j < ring->num_slots; j++)
-+		for (j = 0; j < ring->num_slots; j++) {
-+			err = bgmac_dma_rx_skb_for_slot(bgmac, &ring->slots[j]);
-+			if (err)
-+				goto error;
-+
- 			bgmac_dma_rx_setup_desc(bgmac, ring, j);
-+		}
- 
- 		bgmac_write(bgmac, ring->mmio_base + BGMAC_DMA_RX_INDEX,
- 			    ring->index_base +
-@@ -708,6 +710,12 @@ static void bgmac_dma_init(struct bgmac
- 		ring->start = 0;
- 		ring->end = 0;
- 	}
-+
-+	return 0;
-+
-+error:
-+	bgmac_dma_cleanup(bgmac);
-+	return err;
- }
- 
- /**************************************************
-@@ -1183,11 +1191,8 @@ static void bgmac_enable(struct bgmac *b
- }
- 
- /* http://bcm-v4.sipsolutions.net/mac-gbit/gmac/chipinit */
--static void bgmac_chip_init(struct bgmac *bgmac, bool full_init)
-+static void bgmac_chip_init(struct bgmac *bgmac)
- {
--	struct bgmac_dma_ring *ring;
--	int i;
--
- 	/* 1 interrupt per received frame */
- 	bgmac_write(bgmac, BGMAC_INT_RECV_LAZY, 1 << BGMAC_IRL_FC_SHIFT);
- 
-@@ -1205,16 +1210,7 @@ static void bgmac_chip_init(struct bgmac
- 
- 	bgmac_write(bgmac, BGMAC_RXMAX_LENGTH, 32 + ETHER_MAX_LEN);
- 
--	if (full_init) {
--		bgmac_dma_init(bgmac);
--		if (1) /* FIXME: is there any case we don't want IRQs? */
--			bgmac_chip_intrs_on(bgmac);
--	} else {
--		for (i = 0; i < BGMAC_MAX_RX_RINGS; i++) {
--			ring = &bgmac->rx_ring[i];
--			bgmac_dma_rx_enable(bgmac, ring);
--		}
--	}
-+	bgmac_chip_intrs_on(bgmac);
- 
- 	bgmac_enable(bgmac);
- }
-@@ -1274,23 +1270,27 @@ static int bgmac_open(struct net_device
- 	int err = 0;
- 
- 	bgmac_chip_reset(bgmac);
-+
-+	err = bgmac_dma_init(bgmac);
-+	if (err)
-+		return err;
-+
- 	/* Specs say about reclaiming rings here, but we do that in DMA init */
--	bgmac_chip_init(bgmac, true);
-+	bgmac_chip_init(bgmac);
- 
- 	err = request_irq(bgmac->core->irq, bgmac_interrupt, IRQF_SHARED,
- 			  KBUILD_MODNAME, net_dev);
- 	if (err < 0) {
- 		bgmac_err(bgmac, "IRQ request error: %d!\n", err);
--		goto err_out;
-+		bgmac_dma_cleanup(bgmac);
-+		return err;
- 	}
- 	napi_enable(&bgmac->napi);
- 
- 	phy_start(bgmac->phy_dev);
- 
- 	netif_carrier_on(net_dev);
--
--err_out:
--	return err;
-+	return 0;
- }
- 
- static int bgmac_stop(struct net_device *net_dev)
-@@ -1306,6 +1306,7 @@ static int bgmac_stop(struct net_device
- 	free_irq(bgmac->core->irq, net_dev);
- 
- 	bgmac_chip_reset(bgmac);
-+	bgmac_dma_cleanup(bgmac);
- 
- 	return 0;
- }
--- a/target/linux/generic/pending-3.18/077-11-bgmac-fix-DMA-rx-corruption.patch	2022-03-22 08:54:47.261464759 +0800
+++ b/target/linux/generic/pending-3.18/077-11-bgmac-fix-DMA-rx-corruption.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,88 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sun, 12 Apr 2015 11:59:47 +0200
-Subject: [PATCH] bgmac: fix DMA rx corruption
-
-The driver needs to inform the hardware about the first invalid (not yet
-filled) rx slot, by writing its DMA descriptor pointer offset to the
-BGMAC_DMA_RX_INDEX register.
-
-This register was set to a value exceeding the rx ring size, effectively
-allowing the hardware constant access to the full ring, regardless of
-which slots are initialized.
-
-To fix this issue, always mark the last filled rx slot as invalid.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/drivers/net/ethernet/broadcom/bgmac.c
-+++ b/drivers/net/ethernet/broadcom/bgmac.c
-@@ -366,6 +366,16 @@ static int bgmac_dma_rx_skb_for_slot(str
- 	return 0;
- }
- 
-+static void bgmac_dma_rx_update_index(struct bgmac *bgmac,
-+				      struct bgmac_dma_ring *ring)
-+{
-+	wmb();
-+
-+	bgmac_write(bgmac, ring->mmio_base + BGMAC_DMA_RX_INDEX,
-+		    ring->index_base +
-+		    ring->end * sizeof(struct bgmac_dma_desc));
-+}
-+
- static void bgmac_dma_rx_setup_desc(struct bgmac *bgmac,
- 				    struct bgmac_dma_ring *ring, int desc_idx)
- {
-@@ -384,6 +394,8 @@ static void bgmac_dma_rx_setup_desc(stru
- 	dma_desc->addr_high = cpu_to_le32(upper_32_bits(ring->slots[desc_idx].dma_addr));
- 	dma_desc->ctl0 = cpu_to_le32(ctl0);
- 	dma_desc->ctl1 = cpu_to_le32(ctl1);
-+
-+	ring->end = desc_idx;
- }
- 
- static void bgmac_dma_rx_poison_buf(struct device *dma_dev,
-@@ -411,9 +423,7 @@ static int bgmac_dma_rx_read(struct bgma
- 	end_slot &= BGMAC_DMA_RX_STATDPTR;
- 	end_slot /= sizeof(struct bgmac_dma_desc);
- 
--	ring->end = end_slot;
--
--	while (ring->start != ring->end) {
-+	while (ring->start != end_slot) {
- 		struct device *dma_dev = bgmac->core->dma_dev;
- 		struct bgmac_slot_info *slot = &ring->slots[ring->start];
- 		struct bgmac_rx_header *rx = slot->buf + BGMAC_RX_BUF_OFFSET;
-@@ -476,6 +486,8 @@ static int bgmac_dma_rx_read(struct bgma
- 			break;
- 	}
- 
-+	bgmac_dma_rx_update_index(bgmac, ring);
-+
- 	return handled;
- }
- 
-@@ -695,6 +707,8 @@ static int bgmac_dma_init(struct bgmac *
- 		if (ring->unaligned)
- 			bgmac_dma_rx_enable(bgmac, ring);
- 
-+		ring->start = 0;
-+		ring->end = 0;
- 		for (j = 0; j < ring->num_slots; j++) {
- 			err = bgmac_dma_rx_skb_for_slot(bgmac, &ring->slots[j]);
- 			if (err)
-@@ -703,12 +717,7 @@ static int bgmac_dma_init(struct bgmac *
- 			bgmac_dma_rx_setup_desc(bgmac, ring, j);
- 		}
- 
--		bgmac_write(bgmac, ring->mmio_base + BGMAC_DMA_RX_INDEX,
--			    ring->index_base +
--			    ring->num_slots * sizeof(struct bgmac_dma_desc));
--
--		ring->start = 0;
--		ring->end = 0;
-+		bgmac_dma_rx_update_index(bgmac, ring);
- 	}
- 
- 	return 0;
--- a/target/linux/generic/pending-3.18/077-12-bgmac-drop-ring-num_slots.patch	2022-03-22 08:54:47.261464759 +0800
+++ b/target/linux/generic/pending-3.18/077-12-bgmac-drop-ring-num_slots.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,132 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sun, 12 Apr 2015 23:28:38 +0200
-Subject: [PATCH] bgmac: drop ring->num_slots
-
-The ring size is always known at compile time, so make the code a bit
-more efficient
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/drivers/net/ethernet/broadcom/bgmac.c
-+++ b/drivers/net/ethernet/broadcom/bgmac.c
-@@ -123,7 +123,7 @@ bgmac_dma_tx_add_buf(struct bgmac *bgmac
- 	struct bgmac_dma_desc *dma_desc;
- 	u32 ctl1;
- 
--	if (i == ring->num_slots - 1)
-+	if (i == BGMAC_TX_RING_SLOTS - 1)
- 		ctl0 |= BGMAC_DESC_CTL0_EOT;
- 
- 	ctl1 = len & BGMAC_DESC_CTL1_LEN;
-@@ -382,7 +382,7 @@ static void bgmac_dma_rx_setup_desc(stru
- 	struct bgmac_dma_desc *dma_desc = ring->cpu_base + desc_idx;
- 	u32 ctl0 = 0, ctl1 = 0;
- 
--	if (desc_idx == ring->num_slots - 1)
-+	if (desc_idx == BGMAC_RX_RING_SLOTS - 1)
- 		ctl0 |= BGMAC_DESC_CTL0_EOT;
- 	ctl1 |= BGMAC_RX_BUF_SIZE & BGMAC_DESC_CTL1_LEN;
- 	/* Is there any BGMAC device that requires extension? */
-@@ -521,7 +521,7 @@ static void bgmac_dma_tx_ring_free(struc
- 	struct bgmac_slot_info *slot;
- 	int i;
- 
--	for (i = 0; i < ring->num_slots; i++) {
-+	for (i = 0; i < BGMAC_TX_RING_SLOTS; i++) {
- 		int len = dma_desc[i].ctl1 & BGMAC_DESC_CTL1_LEN;
- 
- 		slot = &ring->slots[i];
-@@ -546,7 +546,7 @@ static void bgmac_dma_rx_ring_free(struc
- 	struct bgmac_slot_info *slot;
- 	int i;
- 
--	for (i = 0; i < ring->num_slots; i++) {
-+	for (i = 0; i < BGMAC_RX_RING_SLOTS; i++) {
- 		slot = &ring->slots[i];
- 		if (!slot->dma_addr)
- 			continue;
-@@ -560,7 +560,8 @@ static void bgmac_dma_rx_ring_free(struc
- }
- 
- static void bgmac_dma_ring_desc_free(struct bgmac *bgmac,
--				     struct bgmac_dma_ring *ring)
-+				     struct bgmac_dma_ring *ring,
-+				     int num_slots)
- {
- 	struct device *dma_dev = bgmac->core->dma_dev;
- 	int size;
-@@ -569,7 +570,7 @@ static void bgmac_dma_ring_desc_free(str
- 	    return;
- 
- 	/* Free ring of descriptors */
--	size = ring->num_slots * sizeof(struct bgmac_dma_desc);
-+	size = num_slots * sizeof(struct bgmac_dma_desc);
- 	dma_free_coherent(dma_dev, size, ring->cpu_base,
- 			  ring->dma_base);
- }
-@@ -590,10 +591,12 @@ static void bgmac_dma_free(struct bgmac
- 	int i;
- 
- 	for (i = 0; i < BGMAC_MAX_TX_RINGS; i++)
--		bgmac_dma_ring_desc_free(bgmac, &bgmac->tx_ring[i]);
-+		bgmac_dma_ring_desc_free(bgmac, &bgmac->tx_ring[i],
-+					 BGMAC_TX_RING_SLOTS);
- 
- 	for (i = 0; i < BGMAC_MAX_RX_RINGS; i++)
--		bgmac_dma_ring_desc_free(bgmac, &bgmac->rx_ring[i]);
-+		bgmac_dma_ring_desc_free(bgmac, &bgmac->rx_ring[i],
-+					 BGMAC_RX_RING_SLOTS);
- }
- 
- static int bgmac_dma_alloc(struct bgmac *bgmac)
-@@ -616,11 +619,10 @@ static int bgmac_dma_alloc(struct bgmac
- 
- 	for (i = 0; i < BGMAC_MAX_TX_RINGS; i++) {
- 		ring = &bgmac->tx_ring[i];
--		ring->num_slots = BGMAC_TX_RING_SLOTS;
- 		ring->mmio_base = ring_base[i];
- 
- 		/* Alloc ring of descriptors */
--		size = ring->num_slots * sizeof(struct bgmac_dma_desc);
-+		size = BGMAC_TX_RING_SLOTS * sizeof(struct bgmac_dma_desc);
- 		ring->cpu_base = dma_zalloc_coherent(dma_dev, size,
- 						     &ring->dma_base,
- 						     GFP_KERNEL);
-@@ -642,11 +644,10 @@ static int bgmac_dma_alloc(struct bgmac
- 
- 	for (i = 0; i < BGMAC_MAX_RX_RINGS; i++) {
- 		ring = &bgmac->rx_ring[i];
--		ring->num_slots = BGMAC_RX_RING_SLOTS;
- 		ring->mmio_base = ring_base[i];
- 
- 		/* Alloc ring of descriptors */
--		size = ring->num_slots * sizeof(struct bgmac_dma_desc);
-+		size = BGMAC_RX_RING_SLOTS * sizeof(struct bgmac_dma_desc);
- 		ring->cpu_base = dma_zalloc_coherent(dma_dev, size,
- 						     &ring->dma_base,
- 						     GFP_KERNEL);
-@@ -709,7 +710,7 @@ static int bgmac_dma_init(struct bgmac *
- 
- 		ring->start = 0;
- 		ring->end = 0;
--		for (j = 0; j < ring->num_slots; j++) {
-+		for (j = 0; j < BGMAC_RX_RING_SLOTS; j++) {
- 			err = bgmac_dma_rx_skb_for_slot(bgmac, &ring->slots[j]);
- 			if (err)
- 				goto error;
---- a/drivers/net/ethernet/broadcom/bgmac.h
-+++ b/drivers/net/ethernet/broadcom/bgmac.h
-@@ -419,11 +419,10 @@ struct bgmac_dma_ring {
- 	u32 start;
- 	u32 end;
- 
--	u16 num_slots;
--	u16 mmio_base;
- 	struct bgmac_dma_desc *cpu_base;
- 	dma_addr_t dma_base;
- 	u32 index_base; /* Used for unaligned rings only, otherwise 0 */
-+	u16 mmio_base;
- 	bool unaligned;
- 
- 	struct bgmac_slot_info slots[BGMAC_RX_RING_SLOTS];
--- a/target/linux/generic/pending-3.18/078-bgmac-reset-enable-Ethernet-core-before-using-it.patch	2022-03-22 08:54:47.261464759 +0800
+++ b/target/linux/generic/pending-3.18/078-bgmac-reset-enable-Ethernet-core-before-using-it.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,31 +0,0 @@
-From b4dfd8e92956b396d3438212bc9a0be6267b8b34 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
-Date: Tue, 12 Apr 2016 13:30:45 +0200
-Subject: [PATCH] bgmac: reset & enable Ethernet core before using it
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-This fixes Ethernet on D-Link DIR-885L with BCM47094 SoC. Felix reported
-similar fix was needed for his BCM4709 device (Buffalo WXR-1900DHP?).
-I tested this for regressions on BCM4706, BCM4708A0 and BCM47081A0.
-
-Cc: Felix Fietkau <nbd@nbd.name>
-Signed-off-by: Rafa Miecki <zajec5@gmail.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/drivers/net/ethernet/broadcom/bgmac.c
-+++ b/drivers/net/ethernet/broadcom/bgmac.c
-@@ -1569,6 +1569,11 @@ static int bgmac_probe(struct bcma_devic
- 	 */
- 	bcma_core_enable(core, 0);
- 
-+	/* This (reset &) enable is not preset in specs or reference driver but
-+	 * Broadcom does it in arch PCI code when enabling fake PCI device.
-+	 */
-+	bcma_core_enable(core, 0);
-+
- 	/* Allocation and references */
- 	net_dev = alloc_etherdev(sizeof(*bgmac));
- 	if (!net_dev)
--- a/target/linux/generic/pending-3.18/079-bgmac-fix-MAC-soft-reset-bit-for-corerev-4.patch	2022-03-22 08:54:47.262464761 +0800
+++ b/target/linux/generic/pending-3.18/079-bgmac-fix-MAC-soft-reset-bit-for-corerev-4.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,34 +0,0 @@
-From c02bc350f9dbce7d637c394a6e1c4d29dc5b28b2 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Tue, 12 Apr 2016 18:27:29 +0200
-Subject: [PATCH] bgmac: fix MAC soft-reset bit for corerev > 4
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Only core revisions older than 4 use BGMAC_CMDCFG_SR_REV0. This mainly
-fixes support for BCM4708A0KF SoCs with Ethernet core rev 5 (it means
-only some devices as most of BCM4708A0KF-s got core rev 4).
-This was tested for regressions on BCM47094 which doesn't seem to care
-which bit gets used.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
-Signed-off-by: Rafa Miecki <zajec5@gmail.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/drivers/net/ethernet/broadcom/bgmac.h
-+++ b/drivers/net/ethernet/broadcom/bgmac.h
-@@ -198,9 +198,9 @@
- #define  BGMAC_CMDCFG_TAI			0x00000200
- #define  BGMAC_CMDCFG_HD			0x00000400	/* Set if in half duplex mode */
- #define  BGMAC_CMDCFG_HD_SHIFT			10
--#define  BGMAC_CMDCFG_SR_REV0			0x00000800	/* Set to reset mode, for other revs */
--#define  BGMAC_CMDCFG_SR_REV4			0x00002000	/* Set to reset mode, only for core rev 4 */
--#define  BGMAC_CMDCFG_SR(rev)  ((rev == 4) ? BGMAC_CMDCFG_SR_REV4 : BGMAC_CMDCFG_SR_REV0)
-+#define  BGMAC_CMDCFG_SR_REV0			0x00000800	/* Set to reset mode, for core rev 0-3 */
-+#define  BGMAC_CMDCFG_SR_REV4			0x00002000	/* Set to reset mode, for core rev >= 4 */
-+#define  BGMAC_CMDCFG_SR(rev)  ((rev >= 4) ? BGMAC_CMDCFG_SR_REV4 : BGMAC_CMDCFG_SR_REV0)
- #define  BGMAC_CMDCFG_ML			0x00008000	/* Set to activate mac loopback mode */
- #define  BGMAC_CMDCFG_AE			0x00400000
- #define  BGMAC_CMDCFG_CFE			0x00800000
--- a/target/linux/generic/pending-3.18/080-00-fib_trie-Fix-proc-net-fib_trie-when-CONFIG_IP_MULTIP.patch	2022-03-22 08:54:47.262464761 +0800
+++ b/target/linux/generic/pending-3.18/080-00-fib_trie-Fix-proc-net-fib_trie-when-CONFIG_IP_MULTIP.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,46 +0,0 @@
-From: Alexander Duyck <alexander.h.duyck@redhat.com>
-Date: Tue, 2 Dec 2014 10:58:21 -0800
-Subject: [PATCH] fib_trie: Fix /proc/net/fib_trie when
- CONFIG_IP_MULTIPLE_TABLES is not defined
-
-In recent testing I had disabled CONFIG_IP_MULTIPLE_TABLES and as a result
-when I ran "cat /proc/net/fib_trie" the main trie was displayed multiple
-times.  I found that the problem line of code was in the function
-fib_trie_seq_next.  Specifically the line below caused the indexes to go in
-the opposite direction of our traversal:
-
-	h = tb->tb_id & (FIB_TABLE_HASHSZ - 1);
-
-This issue was that the RT tables are defined such that RT_TABLE_LOCAL is ID
-255, while it is located at TABLE_LOCAL_INDEX of 0, and RT_TABLE_MAIN is 254
-with a TABLE_MAIN_INDEX of 1.  This means that the above line will return 1
-for the local table and 0 for main.  The result is that fib_trie_seq_next
-will return NULL at the end of the local table, fib_trie_seq_start will
-return the start of the main table, and then fib_trie_seq_next will loop on
-main forever as h will always return 0.
-
-The fix for this is to reverse the ordering of the two tables.  It has the
-advantage of making it so that the tables now print in the same order
-regardless of if multiple tables are enabled or not.  In order to make the
-definition consistent with the multiple tables case I simply masked the to
-RT_TABLE_XXX values by (FIB_TABLE_HASHSZ - 1).  This way the two table
-layouts should always stay consistent.
-
-Fixes: 93456b6 ("[IPV4]: Unify access to the routing tables")
-Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/include/net/ip_fib.h
-+++ b/include/net/ip_fib.h
-@@ -201,8 +201,8 @@ void fib_free_table(struct fib_table *tb
- 
- #ifndef CONFIG_IP_MULTIPLE_TABLES
- 
--#define TABLE_LOCAL_INDEX	0
--#define TABLE_MAIN_INDEX	1
-+#define TABLE_LOCAL_INDEX	(RT_TABLE_LOCAL & (FIB_TABLE_HASHSZ - 1))
-+#define TABLE_MAIN_INDEX	(RT_TABLE_MAIN  & (FIB_TABLE_HASHSZ - 1))
- 
- static inline struct fib_table *fib_get_table(struct net *net, u32 id)
- {
--- a/target/linux/generic/pending-3.18/080-01-fib_trie-Fix-trie-balancing-issue-if-new-node-pushes.patch	2022-03-22 08:54:47.262464761 +0800
+++ b/target/linux/generic/pending-3.18/080-01-fib_trie-Fix-trie-balancing-issue-if-new-node-pushes.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,72 +0,0 @@
-From: Alexander Duyck <alexander.h.duyck@redhat.com>
-Date: Wed, 10 Dec 2014 21:49:22 -0800
-Subject: [PATCH] fib_trie: Fix trie balancing issue if new node pushes down
- existing node
-
-This patch addresses an issue with the level compression of the fib_trie.
-Specifically in the case of adding a new leaf that triggers a new node to
-be added that takes the place of the old node.  The result is a trie where
-the 1 child tnode is on one side and one leaf is on the other which gives
-you a very deep trie.  Below is the script I used to generate a trie on
-dummy0 with a 10.X.X.X family of addresses.
-
-  ip link add type dummy
-  ipval=184549374
-  bit=2
-  for i in `seq 1 23`
-  do
-    ifconfig dummy0:$bit $ipval/8
-    ipval=`expr $ipval - $bit`
-    bit=`expr $bit \* 2`
-  done
-  cat /proc/net/fib_triestat
-
-Running the script before the patch:
-
-	Local:
-		Aver depth:     10.82
-		Max depth:      23
-		Leaves:         29
-		Prefixes:       30
-		Internal nodes: 27
-		  1: 26  2: 1
-		Pointers: 56
-	Null ptrs: 1
-	Total size: 5  kB
-
-After applying the patch and repeating:
-
-	Local:
-		Aver depth:     4.72
-		Max depth:      9
-		Leaves:         29
-		Prefixes:       30
-		Internal nodes: 12
-		  1: 3  2: 2  3: 7
-		Pointers: 70
-	Null ptrs: 30
-	Total size: 4  kB
-
-What this fix does is start the rebalance at the newly created tnode
-instead of at the parent tnode.  This way if there is a gap between the
-parent and the new node it doesn't prevent the new tnode from being
-coalesced with any pre-existing nodes that may have been pushed into one
-of the new nodes child branches.
-
-Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -1143,8 +1143,9 @@ static struct list_head *fib_insert_node
- 			put_child(tp, cindex, (struct rt_trie_node *)tn);
- 		} else {
- 			rcu_assign_pointer(t->trie, (struct rt_trie_node *)tn);
--			tp = tn;
- 		}
-+
-+		tp = tn;
- 	}
- 
- 	if (tp && tp->pos + tp->bits > 32)
--- a/target/linux/generic/pending-3.18/080-02-fib_trie-Update-usage-stats-to-be-percpu-instead-of-.patch	2022-03-22 08:54:47.263464763 +0800
+++ b/target/linux/generic/pending-3.18/080-02-fib_trie-Update-usage-stats-to-be-percpu-instead-of-.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,200 +0,0 @@
-From: Alexander Duyck <alexander.h.duyck@redhat.com>
-Date: Wed, 31 Dec 2014 10:55:29 -0800
-Subject: [PATCH] fib_trie: Update usage stats to be percpu instead of
- global variables
-
-The trie usage stats were currently being shared by all threads that were
-calling fib_table_lookup.  As a result when multiple threads were
-performing lookups simultaneously the trie would begin to cache bounce
-between those threads.
-
-In order to prevent this I have updated the usage stats to use a set of
-percpu variables.  By doing this we should be able to avoid the cache
-bouncing and still make use of these stats.
-
-Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/net/ipv4/fib_frontend.c
-+++ b/net/ipv4/fib_frontend.c
-@@ -67,7 +67,7 @@ static int __net_init fib4_rules_init(st
- 	return 0;
- 
- fail:
--	kfree(local_table);
-+	fib_free_table(local_table);
- 	return -ENOMEM;
- }
- #else
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -153,7 +153,7 @@ struct trie_stat {
- struct trie {
- 	struct rt_trie_node __rcu *trie;
- #ifdef CONFIG_IP_FIB_TRIE_STATS
--	struct trie_use_stats stats;
-+	struct trie_use_stats __percpu *stats;
- #endif
- };
- 
-@@ -631,7 +631,7 @@ static struct rt_trie_node *resize(struc
- 		if (IS_ERR(tn)) {
- 			tn = old_tn;
- #ifdef CONFIG_IP_FIB_TRIE_STATS
--			t->stats.resize_node_skipped++;
-+			this_cpu_inc(t->stats->resize_node_skipped);
- #endif
- 			break;
- 		}
-@@ -658,7 +658,7 @@ static struct rt_trie_node *resize(struc
- 		if (IS_ERR(tn)) {
- 			tn = old_tn;
- #ifdef CONFIG_IP_FIB_TRIE_STATS
--			t->stats.resize_node_skipped++;
-+			this_cpu_inc(t->stats->resize_node_skipped);
- #endif
- 			break;
- 		}
-@@ -1357,7 +1357,7 @@ static int check_leaf(struct fib_table *
- 			err = fib_props[fa->fa_type].error;
- 			if (err) {
- #ifdef CONFIG_IP_FIB_TRIE_STATS
--				t->stats.semantic_match_passed++;
-+				this_cpu_inc(t->stats->semantic_match_passed);
- #endif
- 				return err;
- 			}
-@@ -1372,7 +1372,7 @@ static int check_leaf(struct fib_table *
- 					continue;
- 
- #ifdef CONFIG_IP_FIB_TRIE_STATS
--				t->stats.semantic_match_passed++;
-+				this_cpu_inc(t->stats->semantic_match_passed);
- #endif
- 				res->prefixlen = li->plen;
- 				res->nh_sel = nhsel;
-@@ -1388,7 +1388,7 @@ static int check_leaf(struct fib_table *
- 		}
- 
- #ifdef CONFIG_IP_FIB_TRIE_STATS
--		t->stats.semantic_match_miss++;
-+		this_cpu_inc(t->stats->semantic_match_miss);
- #endif
- 	}
- 
-@@ -1399,6 +1399,9 @@ int fib_table_lookup(struct fib_table *t
- 		     struct fib_result *res, int fib_flags)
- {
- 	struct trie *t = (struct trie *) tb->tb_data;
-+#ifdef CONFIG_IP_FIB_TRIE_STATS
-+	struct trie_use_stats __percpu *stats = t->stats;
-+#endif
- 	int ret;
- 	struct rt_trie_node *n;
- 	struct tnode *pn;
-@@ -1417,7 +1420,7 @@ int fib_table_lookup(struct fib_table *t
- 		goto failed;
- 
- #ifdef CONFIG_IP_FIB_TRIE_STATS
--	t->stats.gets++;
-+	this_cpu_inc(stats->gets);
- #endif
- 
- 	/* Just a leaf? */
-@@ -1441,7 +1444,7 @@ int fib_table_lookup(struct fib_table *t
- 
- 		if (n == NULL) {
- #ifdef CONFIG_IP_FIB_TRIE_STATS
--			t->stats.null_node_hit++;
-+			this_cpu_inc(stats->null_node_hit);
- #endif
- 			goto backtrace;
- 		}
-@@ -1576,7 +1579,7 @@ backtrace:
- 			chopped_off = 0;
- 
- #ifdef CONFIG_IP_FIB_TRIE_STATS
--			t->stats.backtrack++;
-+			this_cpu_inc(stats->backtrack);
- #endif
- 			goto backtrace;
- 		}
-@@ -1830,6 +1833,11 @@ int fib_table_flush(struct fib_table *tb
- 
- void fib_free_table(struct fib_table *tb)
- {
-+#ifdef CONFIG_IP_FIB_TRIE_STATS
-+	struct trie *t = (struct trie *)tb->tb_data;
-+
-+	free_percpu(t->stats);
-+#endif /* CONFIG_IP_FIB_TRIE_STATS */
- 	kfree(tb);
- }
- 
-@@ -1973,7 +1981,14 @@ struct fib_table *fib_trie_table(u32 id)
- 	tb->tb_num_default = 0;
- 
- 	t = (struct trie *) tb->tb_data;
--	memset(t, 0, sizeof(*t));
-+	RCU_INIT_POINTER(t->trie, NULL);
-+#ifdef CONFIG_IP_FIB_TRIE_STATS
-+	t->stats = alloc_percpu(struct trie_use_stats);
-+	if (!t->stats) {
-+		kfree(tb);
-+		tb = NULL;
-+	}
-+#endif
- 
- 	return tb;
- }
-@@ -2139,18 +2154,31 @@ static void trie_show_stats(struct seq_f
- 
- #ifdef CONFIG_IP_FIB_TRIE_STATS
- static void trie_show_usage(struct seq_file *seq,
--			    const struct trie_use_stats *stats)
-+			    const struct trie_use_stats __percpu *stats)
- {
-+	struct trie_use_stats s = { 0 };
-+	int cpu;
-+
-+	/* loop through all of the CPUs and gather up the stats */
-+	for_each_possible_cpu(cpu) {
-+		const struct trie_use_stats *pcpu = per_cpu_ptr(stats, cpu);
-+
-+		s.gets += pcpu->gets;
-+		s.backtrack += pcpu->backtrack;
-+		s.semantic_match_passed += pcpu->semantic_match_passed;
-+		s.semantic_match_miss += pcpu->semantic_match_miss;
-+		s.null_node_hit += pcpu->null_node_hit;
-+		s.resize_node_skipped += pcpu->resize_node_skipped;
-+	}
-+
- 	seq_printf(seq, "\nCounters:\n---------\n");
--	seq_printf(seq, "gets = %u\n", stats->gets);
--	seq_printf(seq, "backtracks = %u\n", stats->backtrack);
-+	seq_printf(seq, "gets = %u\n", s.gets);
-+	seq_printf(seq, "backtracks = %u\n", s.backtrack);
- 	seq_printf(seq, "semantic match passed = %u\n",
--		   stats->semantic_match_passed);
--	seq_printf(seq, "semantic match miss = %u\n",
--		   stats->semantic_match_miss);
--	seq_printf(seq, "null node hit= %u\n", stats->null_node_hit);
--	seq_printf(seq, "skipped node resize = %u\n\n",
--		   stats->resize_node_skipped);
-+		   s.semantic_match_passed);
-+	seq_printf(seq, "semantic match miss = %u\n", s.semantic_match_miss);
-+	seq_printf(seq, "null node hit= %u\n", s.null_node_hit);
-+	seq_printf(seq, "skipped node resize = %u\n\n", s.resize_node_skipped);
- }
- #endif /*  CONFIG_IP_FIB_TRIE_STATS */
- 
-@@ -2191,7 +2219,7 @@ static int fib_triestat_seq_show(struct
- 			trie_collect_stats(t, &stat);
- 			trie_show_stats(seq, &stat);
- #ifdef CONFIG_IP_FIB_TRIE_STATS
--			trie_show_usage(seq, &t->stats);
-+			trie_show_usage(seq, t->stats);
- #endif
- 		}
- 	}
--- a/target/linux/generic/pending-3.18/080-03-fib_trie-Make-leaf-and-tnode-more-uniform.patch	2022-03-22 08:54:47.263464763 +0800
+++ b/target/linux/generic/pending-3.18/080-03-fib_trie-Make-leaf-and-tnode-more-uniform.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,421 +0,0 @@
-From: Alexander Duyck <alexander.h.duyck@redhat.com>
-Date: Wed, 31 Dec 2014 10:55:35 -0800
-Subject: [PATCH] fib_trie: Make leaf and tnode more uniform
-
-This change makes some fundamental changes to the way leaves and tnodes are
-constructed.  The big differences are:
-1.  Leaves now populate pos and bits indicating their full key size.
-2.  Trie nodes now mask out their lower bits to be consistent with the leaf
-3.  Both structures have been reordered so that rt_trie_node now consisists
-    of a much larger region including the pos, bits, and rcu portions of
-    the tnode structure.
-
-On 32b systems this will result in the leaf being 4B larger as the pos and
-bits values were added to a hole created by the key as it was only 4B in
-length.
-
-Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -87,24 +87,38 @@
- 
- typedef unsigned int t_key;
- 
--#define T_TNODE 0
--#define T_LEAF  1
--#define NODE_TYPE_MASK	0x1UL
--#define NODE_TYPE(node) ((node)->parent & NODE_TYPE_MASK)
-+#define IS_TNODE(n) ((n)->bits)
-+#define IS_LEAF(n) (!(n)->bits)
- 
--#define IS_TNODE(n) (!(n->parent & T_LEAF))
--#define IS_LEAF(n) (n->parent & T_LEAF)
-+struct tnode {
-+	t_key key;
-+	unsigned char bits;		/* 2log(KEYLENGTH) bits needed */
-+	unsigned char pos;		/* 2log(KEYLENGTH) bits needed */
-+	struct tnode __rcu *parent;
-+	union {
-+		struct rcu_head rcu;
-+		struct tnode *tnode_free;
-+	};
-+	unsigned int full_children;	/* KEYLENGTH bits needed */
-+	unsigned int empty_children;	/* KEYLENGTH bits needed */
-+	struct rt_trie_node __rcu *child[0];
-+};
- 
- struct rt_trie_node {
--	unsigned long parent;
- 	t_key key;
-+	unsigned char bits;
-+	unsigned char pos;
-+	struct tnode __rcu *parent;
-+	struct rcu_head rcu;
- };
- 
- struct leaf {
--	unsigned long parent;
- 	t_key key;
--	struct hlist_head list;
-+	unsigned char bits;
-+	unsigned char pos;
-+	struct tnode __rcu *parent;
- 	struct rcu_head rcu;
-+	struct hlist_head list;
- };
- 
- struct leaf_info {
-@@ -115,20 +129,6 @@ struct leaf_info {
- 	struct rcu_head rcu;
- };
- 
--struct tnode {
--	unsigned long parent;
--	t_key key;
--	unsigned char pos;		/* 2log(KEYLENGTH) bits needed */
--	unsigned char bits;		/* 2log(KEYLENGTH) bits needed */
--	unsigned int full_children;	/* KEYLENGTH bits needed */
--	unsigned int empty_children;	/* KEYLENGTH bits needed */
--	union {
--		struct rcu_head rcu;
--		struct tnode *tnode_free;
--	};
--	struct rt_trie_node __rcu *child[0];
--};
--
- #ifdef CONFIG_IP_FIB_TRIE_STATS
- struct trie_use_stats {
- 	unsigned int gets;
-@@ -176,38 +176,27 @@ static const int sync_pages = 128;
- static struct kmem_cache *fn_alias_kmem __read_mostly;
- static struct kmem_cache *trie_leaf_kmem __read_mostly;
- 
--/*
-- * caller must hold RTNL
-- */
--static inline struct tnode *node_parent(const struct rt_trie_node *node)
--{
--	unsigned long parent;
-+/* caller must hold RTNL */
-+#define node_parent(n) rtnl_dereference((n)->parent)
- 
--	parent = rcu_dereference_index_check(node->parent, lockdep_rtnl_is_held());
-+/* caller must hold RCU read lock or RTNL */
-+#define node_parent_rcu(n) rcu_dereference_rtnl((n)->parent)
- 
--	return (struct tnode *)(parent & ~NODE_TYPE_MASK);
--}
--
--/*
-- * caller must hold RCU read lock or RTNL
-- */
--static inline struct tnode *node_parent_rcu(const struct rt_trie_node *node)
-+/* wrapper for rcu_assign_pointer */
-+static inline void node_set_parent(struct rt_trie_node *node, struct tnode *ptr)
- {
--	unsigned long parent;
--
--	parent = rcu_dereference_index_check(node->parent, rcu_read_lock_held() ||
--							   lockdep_rtnl_is_held());
--
--	return (struct tnode *)(parent & ~NODE_TYPE_MASK);
-+	if (node)
-+		rcu_assign_pointer(node->parent, ptr);
- }
- 
--/* Same as rcu_assign_pointer
-- * but that macro() assumes that value is a pointer.
-+#define NODE_INIT_PARENT(n, p) RCU_INIT_POINTER((n)->parent, p)
-+
-+/* This provides us with the number of children in this node, in the case of a
-+ * leaf this will return 0 meaning none of the children are accessible.
-  */
--static inline void node_set_parent(struct rt_trie_node *node, struct tnode *ptr)
-+static inline int tnode_child_length(const struct tnode *tn)
- {
--	smp_wmb();
--	node->parent = (unsigned long)ptr | NODE_TYPE(node);
-+	return (1ul << tn->bits) & ~(1ul);
- }
- 
- /*
-@@ -215,7 +204,7 @@ static inline void node_set_parent(struc
-  */
- static inline struct rt_trie_node *tnode_get_child(const struct tnode *tn, unsigned int i)
- {
--	BUG_ON(i >= 1U << tn->bits);
-+	BUG_ON(i >= tnode_child_length(tn));
- 
- 	return rtnl_dereference(tn->child[i]);
- }
-@@ -225,16 +214,11 @@ static inline struct rt_trie_node *tnode
-  */
- static inline struct rt_trie_node *tnode_get_child_rcu(const struct tnode *tn, unsigned int i)
- {
--	BUG_ON(i >= 1U << tn->bits);
-+	BUG_ON(i >= tnode_child_length(tn));
- 
- 	return rcu_dereference_rtnl(tn->child[i]);
- }
- 
--static inline int tnode_child_length(const struct tnode *tn)
--{
--	return 1 << tn->bits;
--}
--
- static inline t_key mask_pfx(t_key k, unsigned int l)
- {
- 	return (l == 0) ? 0 : k >> (KEYLENGTH-l) << (KEYLENGTH-l);
-@@ -336,11 +320,6 @@ static inline int tkey_mismatch(t_key a,
- 
- */
- 
--static inline void check_tnode(const struct tnode *tn)
--{
--	WARN_ON(tn && tn->pos+tn->bits > 32);
--}
--
- static const int halve_threshold = 25;
- static const int inflate_threshold = 50;
- static const int halve_threshold_root = 15;
-@@ -426,11 +405,20 @@ static void tnode_free_flush(void)
- 	}
- }
- 
--static struct leaf *leaf_new(void)
-+static struct leaf *leaf_new(t_key key)
- {
- 	struct leaf *l = kmem_cache_alloc(trie_leaf_kmem, GFP_KERNEL);
- 	if (l) {
--		l->parent = T_LEAF;
-+		l->parent = NULL;
-+		/* set key and pos to reflect full key value
-+		 * any trailing zeros in the key should be ignored
-+		 * as the nodes are searched
-+		 */
-+		l->key = key;
-+		l->pos = KEYLENGTH;
-+		/* set bits to 0 indicating we are not a tnode */
-+		l->bits = 0;
-+
- 		INIT_HLIST_HEAD(&l->list);
- 	}
- 	return l;
-@@ -451,12 +439,16 @@ static struct tnode *tnode_new(t_key key
- {
- 	size_t sz = sizeof(struct tnode) + (sizeof(struct rt_trie_node *) << bits);
- 	struct tnode *tn = tnode_alloc(sz);
-+	unsigned int shift = pos + bits;
-+
-+	/* verify bits and pos their msb bits clear and values are valid */
-+	BUG_ON(!bits || (shift > KEYLENGTH));
- 
- 	if (tn) {
--		tn->parent = T_TNODE;
-+		tn->parent = NULL;
- 		tn->pos = pos;
- 		tn->bits = bits;
--		tn->key = key;
-+		tn->key = mask_pfx(key, pos);
- 		tn->full_children = 0;
- 		tn->empty_children = 1<<bits;
- 	}
-@@ -473,10 +465,7 @@ static struct tnode *tnode_new(t_key key
- 
- static inline int tnode_full(const struct tnode *tn, const struct rt_trie_node *n)
- {
--	if (n == NULL || IS_LEAF(n))
--		return 0;
--
--	return ((struct tnode *) n)->pos == tn->pos + tn->bits;
-+	return n && IS_TNODE(n) && (n->pos == (tn->pos + tn->bits));
- }
- 
- static inline void put_child(struct tnode *tn, int i,
-@@ -514,8 +503,7 @@ static void tnode_put_child_reorg(struct
- 	else if (!wasfull && isfull)
- 		tn->full_children++;
- 
--	if (n)
--		node_set_parent(n, tn);
-+	node_set_parent(n, tn);
- 
- 	rcu_assign_pointer(tn->child[i], n);
- }
-@@ -523,7 +511,7 @@ static void tnode_put_child_reorg(struct
- #define MAX_WORK 10
- static struct rt_trie_node *resize(struct trie *t, struct tnode *tn)
- {
--	int i;
-+	struct rt_trie_node *n = NULL;
- 	struct tnode *old_tn;
- 	int inflate_threshold_use;
- 	int halve_threshold_use;
-@@ -536,12 +524,11 @@ static struct rt_trie_node *resize(struc
- 		 tn, inflate_threshold, halve_threshold);
- 
- 	/* No children */
--	if (tn->empty_children == tnode_child_length(tn)) {
--		tnode_free_safe(tn);
--		return NULL;
--	}
-+	if (tn->empty_children > (tnode_child_length(tn) - 1))
-+		goto no_children;
-+
- 	/* One child */
--	if (tn->empty_children == tnode_child_length(tn) - 1)
-+	if (tn->empty_children == (tnode_child_length(tn) - 1))
- 		goto one_child;
- 	/*
- 	 * Double as long as the resulting node has a number of
-@@ -607,11 +594,9 @@ static struct rt_trie_node *resize(struc
- 	 *
- 	 */
- 
--	check_tnode(tn);
--
- 	/* Keep root node larger  */
- 
--	if (!node_parent((struct rt_trie_node *)tn)) {
-+	if (!node_parent(tn)) {
- 		inflate_threshold_use = inflate_threshold_root;
- 		halve_threshold_use = halve_threshold_root;
- 	} else {
-@@ -637,8 +622,6 @@ static struct rt_trie_node *resize(struc
- 		}
- 	}
- 
--	check_tnode(tn);
--
- 	/* Return if at least one inflate is run */
- 	if (max_work != MAX_WORK)
- 		return (struct rt_trie_node *) tn;
-@@ -666,21 +649,16 @@ static struct rt_trie_node *resize(struc
- 
- 
- 	/* Only one child remains */
--	if (tn->empty_children == tnode_child_length(tn) - 1) {
-+	if (tn->empty_children == (tnode_child_length(tn) - 1)) {
-+		unsigned long i;
- one_child:
--		for (i = 0; i < tnode_child_length(tn); i++) {
--			struct rt_trie_node *n;
--
--			n = rtnl_dereference(tn->child[i]);
--			if (!n)
--				continue;
--
--			/* compress one level */
--
--			node_set_parent(n, NULL);
--			tnode_free_safe(tn);
--			return n;
--		}
-+		for (i = tnode_child_length(tn); !n && i;)
-+			n = tnode_get_child(tn, --i);
-+no_children:
-+		/* compress one level */
-+		node_set_parent(n, NULL);
-+		tnode_free_safe(tn);
-+		return n;
- 	}
- 	return (struct rt_trie_node *) tn;
- }
-@@ -760,8 +738,7 @@ static struct tnode *inflate(struct trie
- 
- 		/* A leaf or an internal node with skipped bits */
- 
--		if (IS_LEAF(node) || ((struct tnode *) node)->pos >
--		   tn->pos + tn->bits - 1) {
-+		if (IS_LEAF(node) || (node->pos > (tn->pos + tn->bits - 1))) {
- 			put_child(tn,
- 				tkey_extract_bits(node->key, oldtnode->pos, oldtnode->bits + 1),
- 				node);
-@@ -958,11 +935,9 @@ fib_find_node(struct trie *t, u32 key)
- 	pos = 0;
- 	n = rcu_dereference_rtnl(t->trie);
- 
--	while (n != NULL &&  NODE_TYPE(n) == T_TNODE) {
-+	while (n && IS_TNODE(n)) {
- 		tn = (struct tnode *) n;
- 
--		check_tnode(tn);
--
- 		if (tkey_sub_equals(tn->key, pos, tn->pos-pos, key)) {
- 			pos = tn->pos + tn->bits;
- 			n = tnode_get_child_rcu(tn,
-@@ -988,7 +963,7 @@ static void trie_rebalance(struct trie *
- 
- 	key = tn->key;
- 
--	while (tn != NULL && (tp = node_parent((struct rt_trie_node *)tn)) != NULL) {
-+	while (tn != NULL && (tp = node_parent(tn)) != NULL) {
- 		cindex = tkey_extract_bits(key, tp->pos, tp->bits);
- 		wasfull = tnode_full(tp, tnode_get_child(tp, cindex));
- 		tn = (struct tnode *)resize(t, tn);
-@@ -996,7 +971,7 @@ static void trie_rebalance(struct trie *
- 		tnode_put_child_reorg(tp, cindex,
- 				      (struct rt_trie_node *)tn, wasfull);
- 
--		tp = node_parent((struct rt_trie_node *) tn);
-+		tp = node_parent(tn);
- 		if (!tp)
- 			rcu_assign_pointer(t->trie, (struct rt_trie_node *)tn);
- 
-@@ -1048,11 +1023,9 @@ static struct list_head *fib_insert_node
- 	 * If it doesn't, we need to replace it with a T_TNODE.
- 	 */
- 
--	while (n != NULL &&  NODE_TYPE(n) == T_TNODE) {
-+	while (n && IS_TNODE(n)) {
- 		tn = (struct tnode *) n;
- 
--		check_tnode(tn);
--
- 		if (tkey_sub_equals(tn->key, pos, tn->pos-pos, key)) {
- 			tp = tn;
- 			pos = tn->pos + tn->bits;
-@@ -1087,12 +1060,11 @@ static struct list_head *fib_insert_node
- 		insert_leaf_info(&l->list, li);
- 		goto done;
- 	}
--	l = leaf_new();
-+	l = leaf_new(key);
- 
- 	if (!l)
- 		return NULL;
- 
--	l->key = key;
- 	li = leaf_info_new(plen);
- 
- 	if (!li) {
-@@ -1569,7 +1541,7 @@ backtrace:
- 		if (chopped_off <= pn->bits) {
- 			cindex &= ~(1 << (chopped_off-1));
- 		} else {
--			struct tnode *parent = node_parent_rcu((struct rt_trie_node *) pn);
-+			struct tnode *parent = node_parent_rcu(pn);
- 			if (!parent)
- 				goto failed;
- 
-@@ -1597,7 +1569,7 @@ EXPORT_SYMBOL_GPL(fib_table_lookup);
-  */
- static void trie_leaf_remove(struct trie *t, struct leaf *l)
- {
--	struct tnode *tp = node_parent((struct rt_trie_node *) l);
-+	struct tnode *tp = node_parent(l);
- 
- 	pr_debug("entering trie_leaf_remove(%p)\n", l);
- 
-@@ -2374,7 +2346,7 @@ static int fib_trie_seq_show(struct seq_
- 
- 	if (IS_TNODE(n)) {
- 		struct tnode *tn = (struct tnode *) n;
--		__be32 prf = htonl(mask_pfx(tn->key, tn->pos));
-+		__be32 prf = htonl(tn->key);
- 
- 		seq_indent(seq, iter->depth-1);
- 		seq_printf(seq, "  +-- %pI4/%d %d %d %d\n",
--- a/target/linux/generic/pending-3.18/080-04-fib_trie-Merge-tnode_free-and-leaf_free-into-node_fr.patch	2022-03-22 08:54:47.264464764 +0800
+++ b/target/linux/generic/pending-3.18/080-04-fib_trie-Merge-tnode_free-and-leaf_free-into-node_fr.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,209 +0,0 @@
-From: Alexander Duyck <alexander.h.duyck@redhat.com>
-Date: Wed, 31 Dec 2014 10:55:41 -0800
-Subject: [PATCH] fib_trie: Merge tnode_free and leaf_free into node_free
-
-Both the leaf and the tnode had an rcu_head in them, but they had them in
-slightly different places.  Since we now have them in the same spot and
-know that any node with bits == 0 is a leaf and the rest are either vmalloc
-or kmalloc tnodes depending on the value of bits it makes it easy to combine
-the functions and reduce overhead.
-
-In addition I have taken advantage of the rcu_head pointer to go ahead and
-put together a simple linked list instead of using the tnode pointer as
-this way we can merge either type of structure for freeing.
-
-Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -95,15 +95,17 @@ struct tnode {
- 	unsigned char bits;		/* 2log(KEYLENGTH) bits needed */
- 	unsigned char pos;		/* 2log(KEYLENGTH) bits needed */
- 	struct tnode __rcu *parent;
--	union {
--		struct rcu_head rcu;
--		struct tnode *tnode_free;
--	};
-+	struct rcu_head rcu;
-+	/* everything above this comment must be the same as rt_trie_node */
- 	unsigned int full_children;	/* KEYLENGTH bits needed */
- 	unsigned int empty_children;	/* KEYLENGTH bits needed */
- 	struct rt_trie_node __rcu *child[0];
- };
- 
-+/* This struct represents the shared bits between tnode and leaf.  If any
-+ * ordering is changed here is must also be updated in tnode and leaf as
-+ * well.
-+ */
- struct rt_trie_node {
- 	t_key key;
- 	unsigned char bits;
-@@ -118,6 +120,7 @@ struct leaf {
- 	unsigned char pos;
- 	struct tnode __rcu *parent;
- 	struct rcu_head rcu;
-+	/* everything above this comment must be the same as rt_trie_node */
- 	struct hlist_head list;
- };
- 
-@@ -163,7 +166,7 @@ static struct rt_trie_node *resize(struc
- static struct tnode *inflate(struct trie *t, struct tnode *tn);
- static struct tnode *halve(struct trie *t, struct tnode *tn);
- /* tnodes to free after resize(); protected by RTNL */
--static struct tnode *tnode_free_head;
-+static struct callback_head *tnode_free_head;
- static size_t tnode_free_size;
- 
- /*
-@@ -336,17 +339,23 @@ static inline void alias_free_mem_rcu(st
- 	call_rcu(&fa->rcu, __alias_free_mem);
- }
- 
--static void __leaf_free_rcu(struct rcu_head *head)
--{
--	struct leaf *l = container_of(head, struct leaf, rcu);
--	kmem_cache_free(trie_leaf_kmem, l);
--}
-+#define TNODE_KMALLOC_MAX \
-+	ilog2((PAGE_SIZE - sizeof(struct tnode)) / sizeof(struct rt_trie_node *))
- 
--static inline void free_leaf(struct leaf *l)
-+static void __node_free_rcu(struct rcu_head *head)
- {
--	call_rcu(&l->rcu, __leaf_free_rcu);
-+	struct rt_trie_node *n = container_of(head, struct rt_trie_node, rcu);
-+
-+	if (IS_LEAF(n))
-+		kmem_cache_free(trie_leaf_kmem, n);
-+	else if (n->bits <= TNODE_KMALLOC_MAX)
-+		kfree(n);
-+	else
-+		vfree(n);
- }
- 
-+#define node_free(n) call_rcu(&n->rcu, __node_free_rcu)
-+
- static inline void free_leaf_info(struct leaf_info *leaf)
- {
- 	kfree_rcu(leaf, rcu);
-@@ -360,43 +369,24 @@ static struct tnode *tnode_alloc(size_t
- 		return vzalloc(size);
- }
- 
--static void __tnode_free_rcu(struct rcu_head *head)
--{
--	struct tnode *tn = container_of(head, struct tnode, rcu);
--	size_t size = sizeof(struct tnode) +
--		      (sizeof(struct rt_trie_node *) << tn->bits);
--
--	if (size <= PAGE_SIZE)
--		kfree(tn);
--	else
--		vfree(tn);
--}
--
--static inline void tnode_free(struct tnode *tn)
--{
--	if (IS_LEAF(tn))
--		free_leaf((struct leaf *) tn);
--	else
--		call_rcu(&tn->rcu, __tnode_free_rcu);
--}
--
- static void tnode_free_safe(struct tnode *tn)
- {
- 	BUG_ON(IS_LEAF(tn));
--	tn->tnode_free = tnode_free_head;
--	tnode_free_head = tn;
--	tnode_free_size += sizeof(struct tnode) +
--			   (sizeof(struct rt_trie_node *) << tn->bits);
-+	tn->rcu.next = tnode_free_head;
-+	tnode_free_head = &tn->rcu;
- }
- 
- static void tnode_free_flush(void)
- {
--	struct tnode *tn;
-+	struct callback_head *head;
-+
-+	while ((head = tnode_free_head)) {
-+		struct tnode *tn = container_of(head, struct tnode, rcu);
-+
-+		tnode_free_head = head->next;
-+		tnode_free_size += offsetof(struct tnode, child[1 << tn->bits]);
- 
--	while ((tn = tnode_free_head)) {
--		tnode_free_head = tn->tnode_free;
--		tn->tnode_free = NULL;
--		tnode_free(tn);
-+		node_free(tn);
- 	}
- 
- 	if (tnode_free_size >= PAGE_SIZE * sync_pages) {
-@@ -437,7 +427,7 @@ static struct leaf_info *leaf_info_new(i
- 
- static struct tnode *tnode_new(t_key key, int pos, int bits)
- {
--	size_t sz = sizeof(struct tnode) + (sizeof(struct rt_trie_node *) << bits);
-+	size_t sz = offsetof(struct tnode, child[1 << bits]);
- 	struct tnode *tn = tnode_alloc(sz);
- 	unsigned int shift = pos + bits;
- 
-@@ -666,15 +656,15 @@ no_children:
- 
- static void tnode_clean_free(struct tnode *tn)
- {
-+	struct rt_trie_node *tofree;
- 	int i;
--	struct tnode *tofree;
- 
- 	for (i = 0; i < tnode_child_length(tn); i++) {
--		tofree = (struct tnode *)rtnl_dereference(tn->child[i]);
-+		tofree = rtnl_dereference(tn->child[i]);
- 		if (tofree)
--			tnode_free(tofree);
-+			node_free(tofree);
- 	}
--	tnode_free(tn);
-+	node_free(tn);
- }
- 
- static struct tnode *inflate(struct trie *t, struct tnode *tn)
-@@ -717,7 +707,7 @@ static struct tnode *inflate(struct trie
- 					  inode->bits - 1);
- 
- 			if (!right) {
--				tnode_free(left);
-+				node_free(left);
- 				goto nomem;
- 			}
- 
-@@ -1068,7 +1058,7 @@ static struct list_head *fib_insert_node
- 	li = leaf_info_new(plen);
- 
- 	if (!li) {
--		free_leaf(l);
-+		node_free(l);
- 		return NULL;
- 	}
- 
-@@ -1100,7 +1090,7 @@ static struct list_head *fib_insert_node
- 
- 		if (!tn) {
- 			free_leaf_info(li);
--			free_leaf(l);
-+			node_free(l);
- 			return NULL;
- 		}
- 
-@@ -1580,7 +1570,7 @@ static void trie_leaf_remove(struct trie
- 	} else
- 		RCU_INIT_POINTER(t->trie, NULL);
- 
--	free_leaf(l);
-+	node_free(l);
- }
- 
- /*
--- a/target/linux/generic/pending-3.18/080-05-fib_trie-Merge-leaf-into-tnode.patch	2022-03-22 08:54:47.265464766 +0800
+++ b/target/linux/generic/pending-3.18/080-05-fib_trie-Merge-leaf-into-tnode.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,928 +0,0 @@
-From: Alexander Duyck <alexander.h.duyck@redhat.com>
-Date: Wed, 31 Dec 2014 10:55:47 -0800
-Subject: [PATCH] fib_trie: Merge leaf into tnode
-
-This change makes it so that leaf and tnode are the same struct.  As a
-result there is no need for rt_trie_node anymore since everyting can be
-merged into tnode.
-
-On 32b systems this results in the leaf being 4 bytes larger, however I
-don't know if that is really an issue as this and an eariler patch that
-added bits & pos have increased the size from 20 to 28.  If I am not
-mistaken slub/slab allocate on power of 2 sizes so 20 was likely being
-rounded up to 32 anyway.
-
-Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -96,32 +96,16 @@ struct tnode {
- 	unsigned char pos;		/* 2log(KEYLENGTH) bits needed */
- 	struct tnode __rcu *parent;
- 	struct rcu_head rcu;
--	/* everything above this comment must be the same as rt_trie_node */
--	unsigned int full_children;	/* KEYLENGTH bits needed */
--	unsigned int empty_children;	/* KEYLENGTH bits needed */
--	struct rt_trie_node __rcu *child[0];
--};
--
--/* This struct represents the shared bits between tnode and leaf.  If any
-- * ordering is changed here is must also be updated in tnode and leaf as
-- * well.
-- */
--struct rt_trie_node {
--	t_key key;
--	unsigned char bits;
--	unsigned char pos;
--	struct tnode __rcu *parent;
--	struct rcu_head rcu;
--};
--
--struct leaf {
--	t_key key;
--	unsigned char bits;
--	unsigned char pos;
--	struct tnode __rcu *parent;
--	struct rcu_head rcu;
--	/* everything above this comment must be the same as rt_trie_node */
--	struct hlist_head list;
-+	union {
-+		/* The fields in this struct are valid if bits > 0 (TNODE) */
-+		struct {
-+			unsigned int full_children;  /* KEYLENGTH bits needed */
-+			unsigned int empty_children; /* KEYLENGTH bits needed */
-+			struct tnode __rcu *child[0];
-+		};
-+		/* This list pointer if valid if bits == 0 (LEAF) */
-+		struct hlist_head list;
-+	};
- };
- 
- struct leaf_info {
-@@ -154,15 +138,15 @@ struct trie_stat {
- };
- 
- struct trie {
--	struct rt_trie_node __rcu *trie;
-+	struct tnode __rcu *trie;
- #ifdef CONFIG_IP_FIB_TRIE_STATS
- 	struct trie_use_stats __percpu *stats;
- #endif
- };
- 
--static void tnode_put_child_reorg(struct tnode *tn, int i, struct rt_trie_node *n,
-+static void tnode_put_child_reorg(struct tnode *tn, int i, struct tnode *n,
- 				  int wasfull);
--static struct rt_trie_node *resize(struct trie *t, struct tnode *tn);
-+static struct tnode *resize(struct trie *t, struct tnode *tn);
- static struct tnode *inflate(struct trie *t, struct tnode *tn);
- static struct tnode *halve(struct trie *t, struct tnode *tn);
- /* tnodes to free after resize(); protected by RTNL */
-@@ -186,10 +170,10 @@ static struct kmem_cache *trie_leaf_kmem
- #define node_parent_rcu(n) rcu_dereference_rtnl((n)->parent)
- 
- /* wrapper for rcu_assign_pointer */
--static inline void node_set_parent(struct rt_trie_node *node, struct tnode *ptr)
-+static inline void node_set_parent(struct tnode *n, struct tnode *tp)
- {
--	if (node)
--		rcu_assign_pointer(node->parent, ptr);
-+	if (n)
-+		rcu_assign_pointer(n->parent, tp);
- }
- 
- #define NODE_INIT_PARENT(n, p) RCU_INIT_POINTER((n)->parent, p)
-@@ -205,7 +189,7 @@ static inline int tnode_child_length(con
- /*
-  * caller must hold RTNL
-  */
--static inline struct rt_trie_node *tnode_get_child(const struct tnode *tn, unsigned int i)
-+static inline struct tnode *tnode_get_child(const struct tnode *tn, unsigned int i)
- {
- 	BUG_ON(i >= tnode_child_length(tn));
- 
-@@ -215,7 +199,7 @@ static inline struct rt_trie_node *tnode
- /*
-  * caller must hold RCU read lock or RTNL
-  */
--static inline struct rt_trie_node *tnode_get_child_rcu(const struct tnode *tn, unsigned int i)
-+static inline struct tnode *tnode_get_child_rcu(const struct tnode *tn, unsigned int i)
- {
- 	BUG_ON(i >= tnode_child_length(tn));
- 
-@@ -340,11 +324,11 @@ static inline void alias_free_mem_rcu(st
- }
- 
- #define TNODE_KMALLOC_MAX \
--	ilog2((PAGE_SIZE - sizeof(struct tnode)) / sizeof(struct rt_trie_node *))
-+	ilog2((PAGE_SIZE - sizeof(struct tnode)) / sizeof(struct tnode *))
- 
- static void __node_free_rcu(struct rcu_head *head)
- {
--	struct rt_trie_node *n = container_of(head, struct rt_trie_node, rcu);
-+	struct tnode *n = container_of(head, struct tnode, rcu);
- 
- 	if (IS_LEAF(n))
- 		kmem_cache_free(trie_leaf_kmem, n);
-@@ -395,9 +379,9 @@ static void tnode_free_flush(void)
- 	}
- }
- 
--static struct leaf *leaf_new(t_key key)
-+static struct tnode *leaf_new(t_key key)
- {
--	struct leaf *l = kmem_cache_alloc(trie_leaf_kmem, GFP_KERNEL);
-+	struct tnode *l = kmem_cache_alloc(trie_leaf_kmem, GFP_KERNEL);
- 	if (l) {
- 		l->parent = NULL;
- 		/* set key and pos to reflect full key value
-@@ -444,7 +428,7 @@ static struct tnode *tnode_new(t_key key
- 	}
- 
- 	pr_debug("AT %p s=%zu %zu\n", tn, sizeof(struct tnode),
--		 sizeof(struct rt_trie_node *) << bits);
-+		 sizeof(struct tnode *) << bits);
- 	return tn;
- }
- 
-@@ -453,13 +437,13 @@ static struct tnode *tnode_new(t_key key
-  * and no bits are skipped. See discussion in dyntree paper p. 6
-  */
- 
--static inline int tnode_full(const struct tnode *tn, const struct rt_trie_node *n)
-+static inline int tnode_full(const struct tnode *tn, const struct tnode *n)
- {
- 	return n && IS_TNODE(n) && (n->pos == (tn->pos + tn->bits));
- }
- 
- static inline void put_child(struct tnode *tn, int i,
--			     struct rt_trie_node *n)
-+			     struct tnode *n)
- {
- 	tnode_put_child_reorg(tn, i, n, -1);
- }
-@@ -469,10 +453,10 @@ static inline void put_child(struct tnod
-   * Update the value of full_children and empty_children.
-   */
- 
--static void tnode_put_child_reorg(struct tnode *tn, int i, struct rt_trie_node *n,
-+static void tnode_put_child_reorg(struct tnode *tn, int i, struct tnode *n,
- 				  int wasfull)
- {
--	struct rt_trie_node *chi = rtnl_dereference(tn->child[i]);
-+	struct tnode *chi = rtnl_dereference(tn->child[i]);
- 	int isfull;
- 
- 	BUG_ON(i >= 1<<tn->bits);
-@@ -499,10 +483,9 @@ static void tnode_put_child_reorg(struct
- }
- 
- #define MAX_WORK 10
--static struct rt_trie_node *resize(struct trie *t, struct tnode *tn)
-+static struct tnode *resize(struct trie *t, struct tnode *tn)
- {
--	struct rt_trie_node *n = NULL;
--	struct tnode *old_tn;
-+	struct tnode *old_tn, *n = NULL;
- 	int inflate_threshold_use;
- 	int halve_threshold_use;
- 	int max_work;
-@@ -614,7 +597,7 @@ static struct rt_trie_node *resize(struc
- 
- 	/* Return if at least one inflate is run */
- 	if (max_work != MAX_WORK)
--		return (struct rt_trie_node *) tn;
-+		return tn;
- 
- 	/*
- 	 * Halve as long as the number of empty children in this
-@@ -650,13 +633,13 @@ no_children:
- 		tnode_free_safe(tn);
- 		return n;
- 	}
--	return (struct rt_trie_node *) tn;
-+	return tn;
- }
- 
- 
- static void tnode_clean_free(struct tnode *tn)
- {
--	struct rt_trie_node *tofree;
-+	struct tnode *tofree;
- 	int i;
- 
- 	for (i = 0; i < tnode_child_length(tn); i++) {
-@@ -667,10 +650,10 @@ static void tnode_clean_free(struct tnod
- 	node_free(tn);
- }
- 
--static struct tnode *inflate(struct trie *t, struct tnode *tn)
-+static struct tnode *inflate(struct trie *t, struct tnode *oldtnode)
- {
--	struct tnode *oldtnode = tn;
--	int olen = tnode_child_length(tn);
-+	int olen = tnode_child_length(oldtnode);
-+	struct tnode *tn;
- 	int i;
- 
- 	pr_debug("In inflate\n");
-@@ -690,11 +673,8 @@ static struct tnode *inflate(struct trie
- 	for (i = 0; i < olen; i++) {
- 		struct tnode *inode;
- 
--		inode = (struct tnode *) tnode_get_child(oldtnode, i);
--		if (inode &&
--		    IS_TNODE(inode) &&
--		    inode->pos == oldtnode->pos + oldtnode->bits &&
--		    inode->bits > 1) {
-+		inode = tnode_get_child(oldtnode, i);
-+		if (tnode_full(oldtnode, inode) && inode->bits > 1) {
- 			struct tnode *left, *right;
- 			t_key m = ~0U << (KEYLENGTH - 1) >> inode->pos;
- 
-@@ -711,33 +691,29 @@ static struct tnode *inflate(struct trie
- 				goto nomem;
- 			}
- 
--			put_child(tn, 2*i, (struct rt_trie_node *) left);
--			put_child(tn, 2*i+1, (struct rt_trie_node *) right);
-+			put_child(tn, 2*i, left);
-+			put_child(tn, 2*i+1, right);
- 		}
- 	}
- 
- 	for (i = 0; i < olen; i++) {
--		struct tnode *inode;
--		struct rt_trie_node *node = tnode_get_child(oldtnode, i);
-+		struct tnode *inode = tnode_get_child(oldtnode, i);
- 		struct tnode *left, *right;
- 		int size, j;
- 
- 		/* An empty child */
--		if (node == NULL)
-+		if (inode == NULL)
- 			continue;
- 
- 		/* A leaf or an internal node with skipped bits */
--
--		if (IS_LEAF(node) || (node->pos > (tn->pos + tn->bits - 1))) {
-+		if (!tnode_full(oldtnode, inode)) {
- 			put_child(tn,
--				tkey_extract_bits(node->key, oldtnode->pos, oldtnode->bits + 1),
--				node);
-+				tkey_extract_bits(inode->key, tn->pos, tn->bits),
-+				inode);
- 			continue;
- 		}
- 
- 		/* An internal node with two children */
--		inode = (struct tnode *) node;
--
- 		if (inode->bits == 1) {
- 			put_child(tn, 2*i, rtnl_dereference(inode->child[0]));
- 			put_child(tn, 2*i+1, rtnl_dereference(inode->child[1]));
-@@ -769,12 +745,12 @@ static struct tnode *inflate(struct trie
- 		 *   bit to zero.
- 		 */
- 
--		left = (struct tnode *) tnode_get_child(tn, 2*i);
-+		left = tnode_get_child(tn, 2*i);
- 		put_child(tn, 2*i, NULL);
- 
- 		BUG_ON(!left);
- 
--		right = (struct tnode *) tnode_get_child(tn, 2*i+1);
-+		right = tnode_get_child(tn, 2*i+1);
- 		put_child(tn, 2*i+1, NULL);
- 
- 		BUG_ON(!right);
-@@ -796,12 +772,11 @@ nomem:
- 	return ERR_PTR(-ENOMEM);
- }
- 
--static struct tnode *halve(struct trie *t, struct tnode *tn)
-+static struct tnode *halve(struct trie *t, struct tnode *oldtnode)
- {
--	struct tnode *oldtnode = tn;
--	struct rt_trie_node *left, *right;
-+	int olen = tnode_child_length(oldtnode);
-+	struct tnode *tn, *left, *right;
- 	int i;
--	int olen = tnode_child_length(tn);
- 
- 	pr_debug("In halve\n");
- 
-@@ -830,7 +805,7 @@ static struct tnode *halve(struct trie *
- 			if (!newn)
- 				goto nomem;
- 
--			put_child(tn, i/2, (struct rt_trie_node *)newn);
-+			put_child(tn, i/2, newn);
- 		}
- 
- 	}
-@@ -855,7 +830,7 @@ static struct tnode *halve(struct trie *
- 		}
- 
- 		/* Two nonempty children */
--		newBinNode = (struct tnode *) tnode_get_child(tn, i/2);
-+		newBinNode = tnode_get_child(tn, i/2);
- 		put_child(tn, i/2, NULL);
- 		put_child(newBinNode, 0, left);
- 		put_child(newBinNode, 1, right);
-@@ -871,7 +846,7 @@ nomem:
- /* readside must use rcu_read_lock currently dump routines
-  via get_fa_head and dump */
- 
--static struct leaf_info *find_leaf_info(struct leaf *l, int plen)
-+static struct leaf_info *find_leaf_info(struct tnode *l, int plen)
- {
- 	struct hlist_head *head = &l->list;
- 	struct leaf_info *li;
-@@ -883,7 +858,7 @@ static struct leaf_info *find_leaf_info(
- 	return NULL;
- }
- 
--static inline struct list_head *get_fa_head(struct leaf *l, int plen)
-+static inline struct list_head *get_fa_head(struct tnode *l, int plen)
- {
- 	struct leaf_info *li = find_leaf_info(l, plen);
- 
-@@ -915,32 +890,25 @@ static void insert_leaf_info(struct hlis
- 
- /* rcu_read_lock needs to be hold by caller from readside */
- 
--static struct leaf *
--fib_find_node(struct trie *t, u32 key)
-+static struct tnode *fib_find_node(struct trie *t, u32 key)
- {
--	int pos;
--	struct tnode *tn;
--	struct rt_trie_node *n;
--
--	pos = 0;
--	n = rcu_dereference_rtnl(t->trie);
-+	struct tnode *n = rcu_dereference_rtnl(t->trie);
-+	int pos = 0;
- 
- 	while (n && IS_TNODE(n)) {
--		tn = (struct tnode *) n;
--
--		if (tkey_sub_equals(tn->key, pos, tn->pos-pos, key)) {
--			pos = tn->pos + tn->bits;
--			n = tnode_get_child_rcu(tn,
-+		if (tkey_sub_equals(n->key, pos, n->pos-pos, key)) {
-+			pos = n->pos + n->bits;
-+			n = tnode_get_child_rcu(n,
- 						tkey_extract_bits(key,
--								  tn->pos,
--								  tn->bits));
-+								  n->pos,
-+								  n->bits));
- 		} else
- 			break;
- 	}
- 	/* Case we have found a leaf. Compare prefixes */
- 
- 	if (n != NULL && IS_LEAF(n) && tkey_equals(key, n->key))
--		return (struct leaf *)n;
-+		return n;
- 
- 	return NULL;
- }
-@@ -956,14 +924,13 @@ static void trie_rebalance(struct trie *
- 	while (tn != NULL && (tp = node_parent(tn)) != NULL) {
- 		cindex = tkey_extract_bits(key, tp->pos, tp->bits);
- 		wasfull = tnode_full(tp, tnode_get_child(tp, cindex));
--		tn = (struct tnode *)resize(t, tn);
-+		tn = resize(t, tn);
- 
--		tnode_put_child_reorg(tp, cindex,
--				      (struct rt_trie_node *)tn, wasfull);
-+		tnode_put_child_reorg(tp, cindex, tn, wasfull);
- 
- 		tp = node_parent(tn);
- 		if (!tp)
--			rcu_assign_pointer(t->trie, (struct rt_trie_node *)tn);
-+			rcu_assign_pointer(t->trie, tn);
- 
- 		tnode_free_flush();
- 		if (!tp)
-@@ -973,9 +940,9 @@ static void trie_rebalance(struct trie *
- 
- 	/* Handle last (top) tnode */
- 	if (IS_TNODE(tn))
--		tn = (struct tnode *)resize(t, tn);
-+		tn = resize(t, tn);
- 
--	rcu_assign_pointer(t->trie, (struct rt_trie_node *)tn);
-+	rcu_assign_pointer(t->trie, tn);
- 	tnode_free_flush();
- }
- 
-@@ -985,8 +952,8 @@ static struct list_head *fib_insert_node
- {
- 	int pos, newpos;
- 	struct tnode *tp = NULL, *tn = NULL;
--	struct rt_trie_node *n;
--	struct leaf *l;
-+	struct tnode *n;
-+	struct tnode *l;
- 	int missbit;
- 	struct list_head *fa_head = NULL;
- 	struct leaf_info *li;
-@@ -1014,17 +981,15 @@ static struct list_head *fib_insert_node
- 	 */
- 
- 	while (n && IS_TNODE(n)) {
--		tn = (struct tnode *) n;
--
--		if (tkey_sub_equals(tn->key, pos, tn->pos-pos, key)) {
--			tp = tn;
--			pos = tn->pos + tn->bits;
--			n = tnode_get_child(tn,
-+		if (tkey_sub_equals(n->key, pos, n->pos-pos, key)) {
-+			tp = n;
-+			pos = n->pos + n->bits;
-+			n = tnode_get_child(n,
- 					    tkey_extract_bits(key,
--							      tn->pos,
--							      tn->bits));
-+							      n->pos,
-+							      n->bits));
- 
--			BUG_ON(n && node_parent(n) != tn);
-+			BUG_ON(n && node_parent(n) != tp);
- 		} else
- 			break;
- 	}
-@@ -1040,14 +1005,13 @@ static struct list_head *fib_insert_node
- 	/* Case 1: n is a leaf. Compare prefixes */
- 
- 	if (n != NULL && IS_LEAF(n) && tkey_equals(key, n->key)) {
--		l = (struct leaf *) n;
- 		li = leaf_info_new(plen);
- 
- 		if (!li)
- 			return NULL;
- 
- 		fa_head = &li->falh;
--		insert_leaf_info(&l->list, li);
-+		insert_leaf_info(&n->list, li);
- 		goto done;
- 	}
- 	l = leaf_new(key);
-@@ -1068,10 +1032,10 @@ static struct list_head *fib_insert_node
- 	if (t->trie && n == NULL) {
- 		/* Case 2: n is NULL, and will just insert a new leaf */
- 
--		node_set_parent((struct rt_trie_node *)l, tp);
-+		node_set_parent(l, tp);
- 
- 		cindex = tkey_extract_bits(key, tp->pos, tp->bits);
--		put_child(tp, cindex, (struct rt_trie_node *)l);
-+		put_child(tp, cindex, l);
- 	} else {
- 		/* Case 3: n is a LEAF or a TNODE and the key doesn't match. */
- 		/*
-@@ -1094,17 +1058,17 @@ static struct list_head *fib_insert_node
- 			return NULL;
- 		}
- 
--		node_set_parent((struct rt_trie_node *)tn, tp);
-+		node_set_parent(tn, tp);
- 
- 		missbit = tkey_extract_bits(key, newpos, 1);
--		put_child(tn, missbit, (struct rt_trie_node *)l);
-+		put_child(tn, missbit, l);
- 		put_child(tn, 1-missbit, n);
- 
- 		if (tp) {
- 			cindex = tkey_extract_bits(key, tp->pos, tp->bits);
--			put_child(tp, cindex, (struct rt_trie_node *)tn);
-+			put_child(tp, cindex, tn);
- 		} else {
--			rcu_assign_pointer(t->trie, (struct rt_trie_node *)tn);
-+			rcu_assign_pointer(t->trie, tn);
- 		}
- 
- 		tp = tn;
-@@ -1134,7 +1098,7 @@ int fib_table_insert(struct fib_table *t
- 	u8 tos = cfg->fc_tos;
- 	u32 key, mask;
- 	int err;
--	struct leaf *l;
-+	struct tnode *l;
- 
- 	if (plen > 32)
- 		return -EINVAL;
-@@ -1292,7 +1256,7 @@ err:
- }
- 
- /* should be called with rcu_read_lock */
--static int check_leaf(struct fib_table *tb, struct trie *t, struct leaf *l,
-+static int check_leaf(struct fib_table *tb, struct trie *t, struct tnode *l,
- 		      t_key key,  const struct flowi4 *flp,
- 		      struct fib_result *res, int fib_flags)
- {
-@@ -1365,7 +1329,7 @@ int fib_table_lookup(struct fib_table *t
- 	struct trie_use_stats __percpu *stats = t->stats;
- #endif
- 	int ret;
--	struct rt_trie_node *n;
-+	struct tnode *n;
- 	struct tnode *pn;
- 	unsigned int pos, bits;
- 	t_key key = ntohl(flp->daddr);
-@@ -1387,11 +1351,11 @@ int fib_table_lookup(struct fib_table *t
- 
- 	/* Just a leaf? */
- 	if (IS_LEAF(n)) {
--		ret = check_leaf(tb, t, (struct leaf *)n, key, flp, res, fib_flags);
-+		ret = check_leaf(tb, t, n, key, flp, res, fib_flags);
- 		goto found;
- 	}
- 
--	pn = (struct tnode *) n;
-+	pn = n;
- 	chopped_off = 0;
- 
- 	while (pn) {
-@@ -1412,13 +1376,13 @@ int fib_table_lookup(struct fib_table *t
- 		}
- 
- 		if (IS_LEAF(n)) {
--			ret = check_leaf(tb, t, (struct leaf *)n, key, flp, res, fib_flags);
-+			ret = check_leaf(tb, t, n, key, flp, res, fib_flags);
- 			if (ret > 0)
- 				goto backtrace;
- 			goto found;
- 		}
- 
--		cn = (struct tnode *)n;
-+		cn = n;
- 
- 		/*
- 		 * It's a tnode, and we can do some extra checks here if we
-@@ -1506,7 +1470,7 @@ int fib_table_lookup(struct fib_table *t
- 				current_prefix_length = mp;
- 		}
- 
--		pn = (struct tnode *)n; /* Descend */
-+		pn = n; /* Descend */
- 		chopped_off = 0;
- 		continue;
- 
-@@ -1557,7 +1521,7 @@ EXPORT_SYMBOL_GPL(fib_table_lookup);
- /*
-  * Remove the leaf and return parent.
-  */
--static void trie_leaf_remove(struct trie *t, struct leaf *l)
-+static void trie_leaf_remove(struct trie *t, struct tnode *l)
- {
- 	struct tnode *tp = node_parent(l);
- 
-@@ -1584,7 +1548,7 @@ int fib_table_delete(struct fib_table *t
- 	u8 tos = cfg->fc_tos;
- 	struct fib_alias *fa, *fa_to_delete;
- 	struct list_head *fa_head;
--	struct leaf *l;
-+	struct tnode *l;
- 	struct leaf_info *li;
- 
- 	if (plen > 32)
-@@ -1682,7 +1646,7 @@ static int trie_flush_list(struct list_h
- 	return found;
- }
- 
--static int trie_flush_leaf(struct leaf *l)
-+static int trie_flush_leaf(struct tnode *l)
- {
- 	int found = 0;
- 	struct hlist_head *lih = &l->list;
-@@ -1704,7 +1668,7 @@ static int trie_flush_leaf(struct leaf *
-  * Scan for the next right leaf starting at node p->child[idx]
-  * Since we have back pointer, no recursion necessary.
-  */
--static struct leaf *leaf_walk_rcu(struct tnode *p, struct rt_trie_node *c)
-+static struct tnode *leaf_walk_rcu(struct tnode *p, struct tnode *c)
- {
- 	do {
- 		t_key idx;
-@@ -1720,47 +1684,46 @@ static struct leaf *leaf_walk_rcu(struct
- 				continue;
- 
- 			if (IS_LEAF(c))
--				return (struct leaf *) c;
-+				return c;
- 
- 			/* Rescan start scanning in new node */
--			p = (struct tnode *) c;
-+			p = c;
- 			idx = 0;
- 		}
- 
- 		/* Node empty, walk back up to parent */
--		c = (struct rt_trie_node *) p;
-+		c = p;
- 	} while ((p = node_parent_rcu(c)) != NULL);
- 
- 	return NULL; /* Root of trie */
- }
- 
--static struct leaf *trie_firstleaf(struct trie *t)
-+static struct tnode *trie_firstleaf(struct trie *t)
- {
--	struct tnode *n = (struct tnode *)rcu_dereference_rtnl(t->trie);
-+	struct tnode *n = rcu_dereference_rtnl(t->trie);
- 
- 	if (!n)
- 		return NULL;
- 
- 	if (IS_LEAF(n))          /* trie is just a leaf */
--		return (struct leaf *) n;
-+		return n;
- 
- 	return leaf_walk_rcu(n, NULL);
- }
- 
--static struct leaf *trie_nextleaf(struct leaf *l)
-+static struct tnode *trie_nextleaf(struct tnode *l)
- {
--	struct rt_trie_node *c = (struct rt_trie_node *) l;
--	struct tnode *p = node_parent_rcu(c);
-+	struct tnode *p = node_parent_rcu(l);
- 
- 	if (!p)
- 		return NULL;	/* trie with just one leaf */
- 
--	return leaf_walk_rcu(p, c);
-+	return leaf_walk_rcu(p, l);
- }
- 
--static struct leaf *trie_leafindex(struct trie *t, int index)
-+static struct tnode *trie_leafindex(struct trie *t, int index)
- {
--	struct leaf *l = trie_firstleaf(t);
-+	struct tnode *l = trie_firstleaf(t);
- 
- 	while (l && index-- > 0)
- 		l = trie_nextleaf(l);
-@@ -1775,7 +1738,7 @@ static struct leaf *trie_leafindex(struc
- int fib_table_flush(struct fib_table *tb)
- {
- 	struct trie *t = (struct trie *) tb->tb_data;
--	struct leaf *l, *ll = NULL;
-+	struct tnode *l, *ll = NULL;
- 	int found = 0;
- 
- 	for (l = trie_firstleaf(t); l; l = trie_nextleaf(l)) {
-@@ -1840,7 +1803,7 @@ static int fn_trie_dump_fa(t_key key, in
- 	return skb->len;
- }
- 
--static int fn_trie_dump_leaf(struct leaf *l, struct fib_table *tb,
-+static int fn_trie_dump_leaf(struct tnode *l, struct fib_table *tb,
- 			struct sk_buff *skb, struct netlink_callback *cb)
- {
- 	struct leaf_info *li;
-@@ -1876,7 +1839,7 @@ static int fn_trie_dump_leaf(struct leaf
- int fib_table_dump(struct fib_table *tb, struct sk_buff *skb,
- 		   struct netlink_callback *cb)
- {
--	struct leaf *l;
-+	struct tnode *l;
- 	struct trie *t = (struct trie *) tb->tb_data;
- 	t_key key = cb->args[2];
- 	int count = cb->args[3];
-@@ -1922,7 +1885,7 @@ void __init fib_trie_init(void)
- 					  0, SLAB_PANIC, NULL);
- 
- 	trie_leaf_kmem = kmem_cache_create("ip_fib_trie",
--					   max(sizeof(struct leaf),
-+					   max(sizeof(struct tnode),
- 					       sizeof(struct leaf_info)),
- 					   0, SLAB_PANIC, NULL);
- }
-@@ -1965,7 +1928,7 @@ struct fib_trie_iter {
- 	unsigned int depth;
- };
- 
--static struct rt_trie_node *fib_trie_get_next(struct fib_trie_iter *iter)
-+static struct tnode *fib_trie_get_next(struct fib_trie_iter *iter)
- {
- 	struct tnode *tn = iter->tnode;
- 	unsigned int cindex = iter->index;
-@@ -1979,7 +1942,7 @@ static struct rt_trie_node *fib_trie_get
- 		 iter->tnode, iter->index, iter->depth);
- rescan:
- 	while (cindex < (1<<tn->bits)) {
--		struct rt_trie_node *n = tnode_get_child_rcu(tn, cindex);
-+		struct tnode *n = tnode_get_child_rcu(tn, cindex);
- 
- 		if (n) {
- 			if (IS_LEAF(n)) {
-@@ -1987,7 +1950,7 @@ rescan:
- 				iter->index = cindex + 1;
- 			} else {
- 				/* push down one level */
--				iter->tnode = (struct tnode *) n;
-+				iter->tnode = n;
- 				iter->index = 0;
- 				++iter->depth;
- 			}
-@@ -1998,7 +1961,7 @@ rescan:
- 	}
- 
- 	/* Current node exhausted, pop back up */
--	p = node_parent_rcu((struct rt_trie_node *)tn);
-+	p = node_parent_rcu(tn);
- 	if (p) {
- 		cindex = tkey_extract_bits(tn->key, p->pos, p->bits)+1;
- 		tn = p;
-@@ -2010,10 +1973,10 @@ rescan:
- 	return NULL;
- }
- 
--static struct rt_trie_node *fib_trie_get_first(struct fib_trie_iter *iter,
-+static struct tnode *fib_trie_get_first(struct fib_trie_iter *iter,
- 				       struct trie *t)
- {
--	struct rt_trie_node *n;
-+	struct tnode *n;
- 
- 	if (!t)
- 		return NULL;
-@@ -2023,7 +1986,7 @@ static struct rt_trie_node *fib_trie_get
- 		return NULL;
- 
- 	if (IS_TNODE(n)) {
--		iter->tnode = (struct tnode *) n;
-+		iter->tnode = n;
- 		iter->index = 0;
- 		iter->depth = 1;
- 	} else {
-@@ -2037,7 +2000,7 @@ static struct rt_trie_node *fib_trie_get
- 
- static void trie_collect_stats(struct trie *t, struct trie_stat *s)
- {
--	struct rt_trie_node *n;
-+	struct tnode *n;
- 	struct fib_trie_iter iter;
- 
- 	memset(s, 0, sizeof(*s));
-@@ -2045,7 +2008,6 @@ static void trie_collect_stats(struct tr
- 	rcu_read_lock();
- 	for (n = fib_trie_get_first(&iter, t); n; n = fib_trie_get_next(&iter)) {
- 		if (IS_LEAF(n)) {
--			struct leaf *l = (struct leaf *)n;
- 			struct leaf_info *li;
- 
- 			s->leaves++;
-@@ -2053,18 +2015,17 @@ static void trie_collect_stats(struct tr
- 			if (iter.depth > s->maxdepth)
- 				s->maxdepth = iter.depth;
- 
--			hlist_for_each_entry_rcu(li, &l->list, hlist)
-+			hlist_for_each_entry_rcu(li, &n->list, hlist)
- 				++s->prefixes;
- 		} else {
--			const struct tnode *tn = (const struct tnode *) n;
- 			int i;
- 
- 			s->tnodes++;
--			if (tn->bits < MAX_STAT_DEPTH)
--				s->nodesizes[tn->bits]++;
-+			if (n->bits < MAX_STAT_DEPTH)
-+				s->nodesizes[n->bits]++;
- 
--			for (i = 0; i < (1<<tn->bits); i++)
--				if (!tn->child[i])
-+			for (i = 0; i < tnode_child_length(n); i++)
-+				if (!rcu_access_pointer(n->child[i]))
- 					s->nullpointers++;
- 		}
- 	}
-@@ -2088,7 +2049,7 @@ static void trie_show_stats(struct seq_f
- 	seq_printf(seq, "\tMax depth:      %u\n", stat->maxdepth);
- 
- 	seq_printf(seq, "\tLeaves:         %u\n", stat->leaves);
--	bytes = sizeof(struct leaf) * stat->leaves;
-+	bytes = sizeof(struct tnode) * stat->leaves;
- 
- 	seq_printf(seq, "\tPrefixes:       %u\n", stat->prefixes);
- 	bytes += sizeof(struct leaf_info) * stat->prefixes;
-@@ -2109,7 +2070,7 @@ static void trie_show_stats(struct seq_f
- 	seq_putc(seq, '\n');
- 	seq_printf(seq, "\tPointers: %u\n", pointers);
- 
--	bytes += sizeof(struct rt_trie_node *) * pointers;
-+	bytes += sizeof(struct tnode *) * pointers;
- 	seq_printf(seq, "Null ptrs: %u\n", stat->nullpointers);
- 	seq_printf(seq, "Total size: %u  kB\n", (bytes + 1023) / 1024);
- }
-@@ -2163,7 +2124,7 @@ static int fib_triestat_seq_show(struct
- 	seq_printf(seq,
- 		   "Basic info: size of leaf:"
- 		   " %Zd bytes, size of tnode: %Zd bytes.\n",
--		   sizeof(struct leaf), sizeof(struct tnode));
-+		   sizeof(struct tnode), sizeof(struct tnode));
- 
- 	for (h = 0; h < FIB_TABLE_HASHSZ; h++) {
- 		struct hlist_head *head = &net->ipv4.fib_table_hash[h];
-@@ -2202,7 +2163,7 @@ static const struct file_operations fib_
- 	.release = single_release_net,
- };
- 
--static struct rt_trie_node *fib_trie_get_idx(struct seq_file *seq, loff_t pos)
-+static struct tnode *fib_trie_get_idx(struct seq_file *seq, loff_t pos)
- {
- 	struct fib_trie_iter *iter = seq->private;
- 	struct net *net = seq_file_net(seq);
-@@ -2214,7 +2175,7 @@ static struct rt_trie_node *fib_trie_get
- 		struct fib_table *tb;
- 
- 		hlist_for_each_entry_rcu(tb, head, tb_hlist) {
--			struct rt_trie_node *n;
-+			struct tnode *n;
- 
- 			for (n = fib_trie_get_first(iter,
- 						    (struct trie *) tb->tb_data);
-@@ -2243,7 +2204,7 @@ static void *fib_trie_seq_next(struct se
- 	struct fib_table *tb = iter->tb;
- 	struct hlist_node *tb_node;
- 	unsigned int h;
--	struct rt_trie_node *n;
-+	struct tnode *n;
- 
- 	++*pos;
- 	/* next node in same table */
-@@ -2329,29 +2290,26 @@ static inline const char *rtn_type(char
- static int fib_trie_seq_show(struct seq_file *seq, void *v)
- {
- 	const struct fib_trie_iter *iter = seq->private;
--	struct rt_trie_node *n = v;
-+	struct tnode *n = v;
- 
- 	if (!node_parent_rcu(n))
- 		fib_table_print(seq, iter->tb);
- 
- 	if (IS_TNODE(n)) {
--		struct tnode *tn = (struct tnode *) n;
--		__be32 prf = htonl(tn->key);
-+		__be32 prf = htonl(n->key);
- 
--		seq_indent(seq, iter->depth-1);
-+		seq_indent(seq, iter->depth - 1);
- 		seq_printf(seq, "  +-- %pI4/%d %d %d %d\n",
--			   &prf, tn->pos, tn->bits, tn->full_children,
--			   tn->empty_children);
--
-+			   &prf, n->pos, n->bits, n->full_children,
-+			   n->empty_children);
- 	} else {
--		struct leaf *l = (struct leaf *) n;
- 		struct leaf_info *li;
--		__be32 val = htonl(l->key);
-+		__be32 val = htonl(n->key);
- 
- 		seq_indent(seq, iter->depth);
- 		seq_printf(seq, "  |-- %pI4\n", &val);
- 
--		hlist_for_each_entry_rcu(li, &l->list, hlist) {
-+		hlist_for_each_entry_rcu(li, &n->list, hlist) {
- 			struct fib_alias *fa;
- 
- 			list_for_each_entry_rcu(fa, &li->falh, fa_list) {
-@@ -2401,9 +2359,9 @@ struct fib_route_iter {
- 	t_key	key;
- };
- 
--static struct leaf *fib_route_get_idx(struct fib_route_iter *iter, loff_t pos)
-+static struct tnode *fib_route_get_idx(struct fib_route_iter *iter, loff_t pos)
- {
--	struct leaf *l = NULL;
-+	struct tnode *l = NULL;
- 	struct trie *t = iter->main_trie;
- 
- 	/* use cache location of last found key */
-@@ -2448,7 +2406,7 @@ static void *fib_route_seq_start(struct
- static void *fib_route_seq_next(struct seq_file *seq, void *v, loff_t *pos)
- {
- 	struct fib_route_iter *iter = seq->private;
--	struct leaf *l = v;
-+	struct tnode *l = v;
- 
- 	++*pos;
- 	if (v == SEQ_START_TOKEN) {
-@@ -2494,7 +2452,7 @@ static unsigned int fib_flag_trans(int t
-  */
- static int fib_route_seq_show(struct seq_file *seq, void *v)
- {
--	struct leaf *l = v;
-+	struct tnode *l = v;
- 	struct leaf_info *li;
- 
- 	if (v == SEQ_START_TOKEN) {
--- a/target/linux/generic/pending-3.18/080-06-fib_trie-Optimize-fib_table_lookup-to-avoid-wasting-.patch	2022-03-22 08:54:47.266464768 +0800
+++ b/target/linux/generic/pending-3.18/080-06-fib_trie-Optimize-fib_table_lookup-to-avoid-wasting-.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,343 +0,0 @@
-From: Alexander Duyck <alexander.h.duyck@redhat.com>
-Date: Wed, 31 Dec 2014 10:55:54 -0800
-Subject: [PATCH] fib_trie: Optimize fib_table_lookup to avoid wasting
- time on loops/variables
-
-This patch is meant to reduce the complexity of fib_table_lookup by reducing
-the number of variables to the bare minimum while still keeping the same if
-not improved functionality versus the original.
-
-Most of this change was started off by the desire to rid the function of
-chopped_off and current_prefix_length as they actually added very little to
-the function since they only applied when computing the cindex.  I was able
-to replace them mostly with just a check for the prefix match.  As long as
-the prefix between the key and the node being tested was the same we know
-we can search the tnode fully versus just testing cindex 0.
-
-The second portion of the change ended up being a massive reordering.
-Originally the calls to check_leaf were up near the start of the loop, and
-the backtracing and descending into lower levels of tnodes was later.  This
-didn't make much sense as the structure of the tree means the leaves are
-always the last thing to be tested.  As such I reordered things so that we
-instead have a loop that will delve into the tree and only exit when we
-have either found a leaf or we have exhausted the tree.  The advantage of
-rearranging things like this is that we can fully inline check_leaf since
-there is now only one reference to it in the function.
-
-Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -90,6 +90,9 @@ typedef unsigned int t_key;
- #define IS_TNODE(n) ((n)->bits)
- #define IS_LEAF(n) (!(n)->bits)
- 
-+#define get_shift(_kv) (KEYLENGTH - (_kv)->pos - (_kv)->bits)
-+#define get_index(_key, _kv) (((_key) ^ (_kv)->key) >> get_shift(_kv))
-+
- struct tnode {
- 	t_key key;
- 	unsigned char bits;		/* 2log(KEYLENGTH) bits needed */
-@@ -1281,7 +1284,7 @@ static int check_leaf(struct fib_table *
- 				continue;
- 			fib_alias_accessed(fa);
- 			err = fib_props[fa->fa_type].error;
--			if (err) {
-+			if (unlikely(err < 0)) {
- #ifdef CONFIG_IP_FIB_TRIE_STATS
- 				this_cpu_inc(t->stats->semantic_match_passed);
- #endif
-@@ -1303,7 +1306,7 @@ static int check_leaf(struct fib_table *
- 				res->prefixlen = li->plen;
- 				res->nh_sel = nhsel;
- 				res->type = fa->fa_type;
--				res->scope = fa->fa_info->fib_scope;
-+				res->scope = fi->fib_scope;
- 				res->fi = fi;
- 				res->table = tb;
- 				res->fa_head = &li->falh;
-@@ -1321,23 +1324,24 @@ static int check_leaf(struct fib_table *
- 	return 1;
- }
- 
-+static inline t_key prefix_mismatch(t_key key, struct tnode *n)
-+{
-+	t_key prefix = n->key;
-+
-+	return (key ^ prefix) & (prefix | -prefix);
-+}
-+
- int fib_table_lookup(struct fib_table *tb, const struct flowi4 *flp,
- 		     struct fib_result *res, int fib_flags)
- {
--	struct trie *t = (struct trie *) tb->tb_data;
-+	struct trie *t = (struct trie *)tb->tb_data;
- #ifdef CONFIG_IP_FIB_TRIE_STATS
- 	struct trie_use_stats __percpu *stats = t->stats;
- #endif
--	int ret;
--	struct tnode *n;
--	struct tnode *pn;
--	unsigned int pos, bits;
--	t_key key = ntohl(flp->daddr);
--	unsigned int chopped_off;
--	t_key cindex = 0;
--	unsigned int current_prefix_length = KEYLENGTH;
--	struct tnode *cn;
--	t_key pref_mismatch;
-+	const t_key key = ntohl(flp->daddr);
-+	struct tnode *n, *pn;
-+	t_key cindex;
-+	int ret = 1;
- 
- 	rcu_read_lock();
- 
-@@ -1349,170 +1353,102 @@ int fib_table_lookup(struct fib_table *t
- 	this_cpu_inc(stats->gets);
- #endif
- 
--	/* Just a leaf? */
--	if (IS_LEAF(n)) {
--		ret = check_leaf(tb, t, n, key, flp, res, fib_flags);
--		goto found;
--	}
--
- 	pn = n;
--	chopped_off = 0;
--
--	while (pn) {
--		pos = pn->pos;
--		bits = pn->bits;
-+	cindex = 0;
- 
--		if (!chopped_off)
--			cindex = tkey_extract_bits(mask_pfx(key, current_prefix_length),
--						   pos, bits);
--
--		n = tnode_get_child_rcu(pn, cindex);
--
--		if (n == NULL) {
--#ifdef CONFIG_IP_FIB_TRIE_STATS
--			this_cpu_inc(stats->null_node_hit);
--#endif
--			goto backtrace;
--		}
-+	/* Step 1: Travel to the longest prefix match in the trie */
-+	for (;;) {
-+		unsigned long index = get_index(key, n);
-+
-+		/* This bit of code is a bit tricky but it combines multiple
-+		 * checks into a single check.  The prefix consists of the
-+		 * prefix plus zeros for the "bits" in the prefix. The index
-+		 * is the difference between the key and this value.  From
-+		 * this we can actually derive several pieces of data.
-+		 *   if !(index >> bits)
-+		 *     we know the value is child index
-+		 *   else
-+		 *     we have a mismatch in skip bits and failed
-+		 */
-+		if (index >> n->bits)
-+			break;
- 
--		if (IS_LEAF(n)) {
--			ret = check_leaf(tb, t, n, key, flp, res, fib_flags);
--			if (ret > 0)
--				goto backtrace;
-+		/* we have found a leaf. Prefixes have already been compared */
-+		if (IS_LEAF(n))
- 			goto found;
--		}
--
--		cn = n;
- 
--		/*
--		 * It's a tnode, and we can do some extra checks here if we
--		 * like, to avoid descending into a dead-end branch.
--		 * This tnode is in the parent's child array at index
--		 * key[p_pos..p_pos+p_bits] but potentially with some bits
--		 * chopped off, so in reality the index may be just a
--		 * subprefix, padded with zero at the end.
--		 * We can also take a look at any skipped bits in this
--		 * tnode - everything up to p_pos is supposed to be ok,
--		 * and the non-chopped bits of the index (se previous
--		 * paragraph) are also guaranteed ok, but the rest is
--		 * considered unknown.
--		 *
--		 * The skipped bits are key[pos+bits..cn->pos].
--		 */
--
--		/* If current_prefix_length < pos+bits, we are already doing
--		 * actual prefix  matching, which means everything from
--		 * pos+(bits-chopped_off) onward must be zero along some
--		 * branch of this subtree - otherwise there is *no* valid
--		 * prefix present. Here we can only check the skipped
--		 * bits. Remember, since we have already indexed into the
--		 * parent's child array, we know that the bits we chopped of
--		 * *are* zero.
-+		/* only record pn and cindex if we are going to be chopping
-+		 * bits later.  Otherwise we are just wasting cycles.
- 		 */
--
--		/* NOTA BENE: Checking only skipped bits
--		   for the new node here */
--
--		if (current_prefix_length < pos+bits) {
--			if (tkey_extract_bits(cn->key, current_prefix_length,
--						cn->pos - current_prefix_length)
--			    || !(cn->child[0]))
--				goto backtrace;
-+		if (index) {
-+			pn = n;
-+			cindex = index;
- 		}
- 
--		/*
--		 * If chopped_off=0, the index is fully validated and we
--		 * only need to look at the skipped bits for this, the new,
--		 * tnode. What we actually want to do is to find out if
--		 * these skipped bits match our key perfectly, or if we will
--		 * have to count on finding a matching prefix further down,
--		 * because if we do, we would like to have some way of
--		 * verifying the existence of such a prefix at this point.
--		 */
--
--		/* The only thing we can do at this point is to verify that
--		 * any such matching prefix can indeed be a prefix to our
--		 * key, and if the bits in the node we are inspecting that
--		 * do not match our key are not ZERO, this cannot be true.
--		 * Thus, find out where there is a mismatch (before cn->pos)
--		 * and verify that all the mismatching bits are zero in the
--		 * new tnode's key.
--		 */
-+		n = rcu_dereference(n->child[index]);
-+		if (unlikely(!n))
-+			goto backtrace;
-+	}
- 
--		/*
--		 * Note: We aren't very concerned about the piece of
--		 * the key that precede pn->pos+pn->bits, since these
--		 * have already been checked. The bits after cn->pos
--		 * aren't checked since these are by definition
--		 * "unknown" at this point. Thus, what we want to see
--		 * is if we are about to enter the "prefix matching"
--		 * state, and in that case verify that the skipped
--		 * bits that will prevail throughout this subtree are
--		 * zero, as they have to be if we are to find a
--		 * matching prefix.
-+	/* Step 2: Sort out leaves and begin backtracing for longest prefix */
-+	for (;;) {
-+		/* record the pointer where our next node pointer is stored */
-+		struct tnode __rcu **cptr = n->child;
-+
-+		/* This test verifies that none of the bits that differ
-+		 * between the key and the prefix exist in the region of
-+		 * the lsb and higher in the prefix.
- 		 */
-+		if (unlikely(prefix_mismatch(key, n)))
-+			goto backtrace;
- 
--		pref_mismatch = mask_pfx(cn->key ^ key, cn->pos);
-+		/* exit out and process leaf */
-+		if (unlikely(IS_LEAF(n)))
-+			break;
- 
--		/*
--		 * In short: If skipped bits in this node do not match
--		 * the search key, enter the "prefix matching"
--		 * state.directly.
-+		/* Don't bother recording parent info.  Since we are in
-+		 * prefix match mode we will have to come back to wherever
-+		 * we started this traversal anyway
- 		 */
--		if (pref_mismatch) {
--			/* fls(x) = __fls(x) + 1 */
--			int mp = KEYLENGTH - __fls(pref_mismatch) - 1;
--
--			if (tkey_extract_bits(cn->key, mp, cn->pos - mp) != 0)
--				goto backtrace;
--
--			if (current_prefix_length >= cn->pos)
--				current_prefix_length = mp;
--		}
--
--		pn = n; /* Descend */
--		chopped_off = 0;
--		continue;
- 
-+		while ((n = rcu_dereference(*cptr)) == NULL) {
- backtrace:
--		chopped_off++;
--
--		/* As zero don't change the child key (cindex) */
--		while ((chopped_off <= pn->bits)
--		       && !(cindex & (1<<(chopped_off-1))))
--			chopped_off++;
--
--		/* Decrease current_... with bits chopped off */
--		if (current_prefix_length > pn->pos + pn->bits - chopped_off)
--			current_prefix_length = pn->pos + pn->bits
--				- chopped_off;
--
--		/*
--		 * Either we do the actual chop off according or if we have
--		 * chopped off all bits in this tnode walk up to our parent.
--		 */
--
--		if (chopped_off <= pn->bits) {
--			cindex &= ~(1 << (chopped_off-1));
--		} else {
--			struct tnode *parent = node_parent_rcu(pn);
--			if (!parent)
--				goto failed;
--
--			/* Get Child's index */
--			cindex = tkey_extract_bits(pn->key, parent->pos, parent->bits);
--			pn = parent;
--			chopped_off = 0;
--
- #ifdef CONFIG_IP_FIB_TRIE_STATS
--			this_cpu_inc(stats->backtrack);
-+			if (!n)
-+				this_cpu_inc(stats->null_node_hit);
- #endif
--			goto backtrace;
-+			/* If we are at cindex 0 there are no more bits for
-+			 * us to strip at this level so we must ascend back
-+			 * up one level to see if there are any more bits to
-+			 * be stripped there.
-+			 */
-+			while (!cindex) {
-+				t_key pkey = pn->key;
-+
-+				pn = node_parent_rcu(pn);
-+				if (unlikely(!pn))
-+					goto failed;
-+#ifdef CONFIG_IP_FIB_TRIE_STATS
-+				this_cpu_inc(stats->backtrack);
-+#endif
-+				/* Get Child's index */
-+				cindex = get_index(pkey, pn);
-+			}
-+
-+			/* strip the least significant bit from the cindex */
-+			cindex &= cindex - 1;
-+
-+			/* grab pointer for next child node */
-+			cptr = &pn->child[cindex];
- 		}
- 	}
--failed:
--	ret = 1;
-+
- found:
-+	/* Step 3: Process the leaf, if that fails fall back to backtracing */
-+	ret = check_leaf(tb, t, n, key, flp, res, fib_flags);
-+	if (unlikely(ret > 0))
-+		goto backtrace;
-+failed:
- 	rcu_read_unlock();
- 	return ret;
- }
--- a/target/linux/generic/pending-3.18/080-07-fib_trie-Optimize-fib_find_node.patch	2022-03-22 08:54:47.266464768 +0800
+++ b/target/linux/generic/pending-3.18/080-07-fib_trie-Optimize-fib_find_node.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,64 +0,0 @@
-From: Alexander Duyck <alexander.h.duyck@redhat.com>
-Date: Wed, 31 Dec 2014 10:56:00 -0800
-Subject: [PATCH] fib_trie: Optimize fib_find_node
-
-This patch makes use of the same features I made use of for
-fib_table_lookup to streamline fib_find_node.  The resultant code should be
-smaller and run faster than the original.
-
-Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -892,28 +892,34 @@ static void insert_leaf_info(struct hlis
- }
- 
- /* rcu_read_lock needs to be hold by caller from readside */
--
- static struct tnode *fib_find_node(struct trie *t, u32 key)
- {
- 	struct tnode *n = rcu_dereference_rtnl(t->trie);
--	int pos = 0;
- 
--	while (n && IS_TNODE(n)) {
--		if (tkey_sub_equals(n->key, pos, n->pos-pos, key)) {
--			pos = n->pos + n->bits;
--			n = tnode_get_child_rcu(n,
--						tkey_extract_bits(key,
--								  n->pos,
--								  n->bits));
--		} else
-+	while (n) {
-+		unsigned long index = get_index(key, n);
-+
-+		/* This bit of code is a bit tricky but it combines multiple
-+		 * checks into a single check.  The prefix consists of the
-+		 * prefix plus zeros for the bits in the cindex. The index
-+		 * is the difference between the key and this value.  From
-+		 * this we can actually derive several pieces of data.
-+		 *   if !(index >> bits)
-+		 *     we know the value is cindex
-+		 *   else
-+		 *     we have a mismatch in skip bits and failed
-+		 */
-+		if (index >> n->bits)
-+			return NULL;
-+
-+		/* we have found a leaf. Prefixes have already been compared */
-+		if (IS_LEAF(n))
- 			break;
--	}
--	/* Case we have found a leaf. Compare prefixes */
- 
--	if (n != NULL && IS_LEAF(n) && tkey_equals(key, n->key))
--		return n;
-+		n = rcu_dereference_rtnl(n->child[index]);
-+	}
- 
--	return NULL;
-+	return n;
- }
- 
- static void trie_rebalance(struct trie *t, struct tnode *tn)
--- a/target/linux/generic/pending-3.18/080-08-fib_trie-Optimize-fib_table_insert.patch	2022-03-22 08:54:47.267464769 +0800
+++ b/target/linux/generic/pending-3.18/080-08-fib_trie-Optimize-fib_table_insert.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,276 +0,0 @@
-From: Alexander Duyck <alexander.h.duyck@redhat.com>
-Date: Wed, 31 Dec 2014 10:56:06 -0800
-Subject: [PATCH] fib_trie: Optimize fib_table_insert
-
-This patch updates the fib_table_insert function to take advantage of the
-changes made to improve the performance of fib_table_lookup.  As a result
-the code should be smaller and run faster then the original.
-
-Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -222,31 +222,6 @@ static inline t_key tkey_extract_bits(t_
- 		return 0;
- }
- 
--static inline int tkey_equals(t_key a, t_key b)
--{
--	return a == b;
--}
--
--static inline int tkey_sub_equals(t_key a, int offset, int bits, t_key b)
--{
--	if (bits == 0 || offset >= KEYLENGTH)
--		return 1;
--	bits = bits > KEYLENGTH ? KEYLENGTH : bits;
--	return ((a ^ b) << offset) >> (KEYLENGTH - bits) == 0;
--}
--
--static inline int tkey_mismatch(t_key a, int offset, t_key b)
--{
--	t_key diff = a ^ b;
--	int i = offset;
--
--	if (!diff)
--		return 0;
--	while ((diff << i) >> (KEYLENGTH-1) == 0)
--		i++;
--	return i;
--}
--
- /*
-   To understand this stuff, an understanding of keys and all their bits is
-   necessary. Every node in the trie has a key associated with it, but not
-@@ -485,6 +460,15 @@ static void tnode_put_child_reorg(struct
- 	rcu_assign_pointer(tn->child[i], n);
- }
- 
-+static void put_child_root(struct tnode *tp, struct trie *t,
-+			   t_key key, struct tnode *n)
-+{
-+	if (tp)
-+		put_child(tp, get_index(key, tp), n);
-+	else
-+		rcu_assign_pointer(t->trie, n);
-+}
-+
- #define MAX_WORK 10
- static struct tnode *resize(struct trie *t, struct tnode *tn)
- {
-@@ -959,138 +943,100 @@ static void trie_rebalance(struct trie *
- 
- static struct list_head *fib_insert_node(struct trie *t, u32 key, int plen)
- {
--	int pos, newpos;
--	struct tnode *tp = NULL, *tn = NULL;
--	struct tnode *n;
--	struct tnode *l;
--	int missbit;
- 	struct list_head *fa_head = NULL;
-+	struct tnode *l, *n, *tp = NULL;
- 	struct leaf_info *li;
--	t_key cindex;
- 
--	pos = 0;
-+	li = leaf_info_new(plen);
-+	if (!li)
-+		return NULL;
-+	fa_head = &li->falh;
-+
- 	n = rtnl_dereference(t->trie);
- 
- 	/* If we point to NULL, stop. Either the tree is empty and we should
- 	 * just put a new leaf in if, or we have reached an empty child slot,
- 	 * and we should just put our new leaf in that.
--	 * If we point to a T_TNODE, check if it matches our key. Note that
--	 * a T_TNODE might be skipping any number of bits - its 'pos' need
--	 * not be the parent's 'pos'+'bits'!
--	 *
--	 * If it does match the current key, get pos/bits from it, extract
--	 * the index from our key, push the T_TNODE and walk the tree.
--	 *
--	 * If it doesn't, we have to replace it with a new T_TNODE.
- 	 *
--	 * If we point to a T_LEAF, it might or might not have the same key
--	 * as we do. If it does, just change the value, update the T_LEAF's
--	 * value, and return it.
--	 * If it doesn't, we need to replace it with a T_TNODE.
-+	 * If we hit a node with a key that does't match then we should stop
-+	 * and create a new tnode to replace that node and insert ourselves
-+	 * and the other node into the new tnode.
- 	 */
-+	while (n) {
-+		unsigned long index = get_index(key, n);
- 
--	while (n && IS_TNODE(n)) {
--		if (tkey_sub_equals(n->key, pos, n->pos-pos, key)) {
--			tp = n;
--			pos = n->pos + n->bits;
--			n = tnode_get_child(n,
--					    tkey_extract_bits(key,
--							      n->pos,
--							      n->bits));
--
--			BUG_ON(n && node_parent(n) != tp);
--		} else
-+		/* This bit of code is a bit tricky but it combines multiple
-+		 * checks into a single check.  The prefix consists of the
-+		 * prefix plus zeros for the "bits" in the prefix. The index
-+		 * is the difference between the key and this value.  From
-+		 * this we can actually derive several pieces of data.
-+		 *   if !(index >> bits)
-+		 *     we know the value is child index
-+		 *   else
-+		 *     we have a mismatch in skip bits and failed
-+		 */
-+		if (index >> n->bits)
- 			break;
--	}
--
--	/*
--	 * n  ----> NULL, LEAF or TNODE
--	 *
--	 * tp is n's (parent) ----> NULL or TNODE
--	 */
- 
--	BUG_ON(tp && IS_LEAF(tp));
--
--	/* Case 1: n is a leaf. Compare prefixes */
--
--	if (n != NULL && IS_LEAF(n) && tkey_equals(key, n->key)) {
--		li = leaf_info_new(plen);
--
--		if (!li)
--			return NULL;
-+		/* we have found a leaf. Prefixes have already been compared */
-+		if (IS_LEAF(n)) {
-+			/* Case 1: n is a leaf, and prefixes match*/
-+			insert_leaf_info(&n->list, li);
-+			return fa_head;
-+		}
- 
--		fa_head = &li->falh;
--		insert_leaf_info(&n->list, li);
--		goto done;
-+		tp = n;
-+		n = rcu_dereference_rtnl(n->child[index]);
- 	}
--	l = leaf_new(key);
--
--	if (!l)
--		return NULL;
- 
--	li = leaf_info_new(plen);
--
--	if (!li) {
--		node_free(l);
-+	l = leaf_new(key);
-+	if (!l) {
-+		free_leaf_info(li);
- 		return NULL;
- 	}
- 
--	fa_head = &li->falh;
- 	insert_leaf_info(&l->list, li);
- 
--	if (t->trie && n == NULL) {
--		/* Case 2: n is NULL, and will just insert a new leaf */
--
--		node_set_parent(l, tp);
--
--		cindex = tkey_extract_bits(key, tp->pos, tp->bits);
--		put_child(tp, cindex, l);
--	} else {
--		/* Case 3: n is a LEAF or a TNODE and the key doesn't match. */
--		/*
--		 *  Add a new tnode here
--		 *  first tnode need some special handling
--		 */
-+	/* Case 2: n is a LEAF or a TNODE and the key doesn't match.
-+	 *
-+	 *  Add a new tnode here
-+	 *  first tnode need some special handling
-+	 *  leaves us in position for handling as case 3
-+	 */
-+	if (n) {
-+		struct tnode *tn;
-+		int newpos;
- 
--		if (n) {
--			pos = tp ? tp->pos+tp->bits : 0;
--			newpos = tkey_mismatch(key, pos, n->key);
--			tn = tnode_new(n->key, newpos, 1);
--		} else {
--			newpos = 0;
--			tn = tnode_new(key, newpos, 1); /* First tnode */
--		}
-+		newpos = KEYLENGTH - __fls(n->key ^ key) - 1;
- 
-+		tn = tnode_new(key, newpos, 1);
- 		if (!tn) {
- 			free_leaf_info(li);
- 			node_free(l);
- 			return NULL;
- 		}
- 
--		node_set_parent(tn, tp);
--
--		missbit = tkey_extract_bits(key, newpos, 1);
--		put_child(tn, missbit, l);
--		put_child(tn, 1-missbit, n);
--
--		if (tp) {
--			cindex = tkey_extract_bits(key, tp->pos, tp->bits);
--			put_child(tp, cindex, tn);
--		} else {
--			rcu_assign_pointer(t->trie, tn);
--		}
-+		/* initialize routes out of node */
-+		NODE_INIT_PARENT(tn, tp);
-+		put_child(tn, get_index(key, tn) ^ 1, n);
-+
-+		/* start adding routes into the node */
-+		put_child_root(tp, t, key, tn);
-+		node_set_parent(n, tn);
- 
-+		/* parent now has a NULL spot where the leaf can go */
- 		tp = tn;
- 	}
- 
--	if (tp && tp->pos + tp->bits > 32)
--		pr_warn("fib_trie tp=%p pos=%d, bits=%d, key=%0x plen=%d\n",
--			tp, tp->pos, tp->bits, key, plen);
--
--	/* Rebalance the trie */
-+	/* Case 3: n is NULL, and will just insert a new leaf */
-+	if (tp) {
-+		NODE_INIT_PARENT(l, tp);
-+		put_child(tp, get_index(key, tp), l);
-+		trie_rebalance(t, tp);
-+	} else {
-+		rcu_assign_pointer(t->trie, l);
-+	}
- 
--	trie_rebalance(t, tp);
--done:
- 	return fa_head;
- }
- 
-@@ -1470,11 +1416,11 @@ static void trie_leaf_remove(struct trie
- 	pr_debug("entering trie_leaf_remove(%p)\n", l);
- 
- 	if (tp) {
--		t_key cindex = tkey_extract_bits(l->key, tp->pos, tp->bits);
--		put_child(tp, cindex, NULL);
-+		put_child(tp, get_index(l->key, tp), NULL);
- 		trie_rebalance(t, tp);
--	} else
-+	} else {
- 		RCU_INIT_POINTER(t->trie, NULL);
-+	}
- 
- 	node_free(l);
- }
--- a/target/linux/generic/pending-3.18/080-09-fib_trie-Update-meaning-of-pos-to-represent-unchecke.patch	2022-03-22 08:54:47.267464769 +0800
+++ b/target/linux/generic/pending-3.18/080-09-fib_trie-Update-meaning-of-pos-to-represent-unchecke.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,346 +0,0 @@
-From: Alexander Duyck <alexander.h.duyck@redhat.com>
-Date: Wed, 31 Dec 2014 10:56:12 -0800
-Subject: [PATCH] fib_trie: Update meaning of pos to represent unchecked
- bits
-
-This change moves the pos value to the other side of the "bits" field.  By
-doing this it actually simplifies a significant amount of code in the trie.
-
-For example when halving a tree we know that the bit lost exists at
-oldnode->pos, and if we inflate the tree the new bit being add is at
-tn->pos.  Previously to find those bits you would have to subtract pos and
-bits from the keylength or start with a value of (1 << 31) and then shift
-that.
-
-There are a number of spots throughout the code that benefit from this.  In
-the case of the hot-path searches the main advantage is that we can drop 2
-or more operations from the search path as we no longer need to compute the
-value for the index to be shifted by and can instead just use the raw pos
-value.
-
-In addition the tkey_extract_bits is now defunct and can be replaced by
-get_index since the two operations were doing the same thing, but now
-get_index does it much more quickly as it is only an xor and shift versus a
-pair of shifts and a subtraction.
-
-Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -90,8 +90,7 @@ typedef unsigned int t_key;
- #define IS_TNODE(n) ((n)->bits)
- #define IS_LEAF(n) (!(n)->bits)
- 
--#define get_shift(_kv) (KEYLENGTH - (_kv)->pos - (_kv)->bits)
--#define get_index(_key, _kv) (((_key) ^ (_kv)->key) >> get_shift(_kv))
-+#define get_index(_key, _kv) (((_key) ^ (_kv)->key) >> (_kv)->pos)
- 
- struct tnode {
- 	t_key key;
-@@ -209,81 +208,64 @@ static inline struct tnode *tnode_get_ch
- 	return rcu_dereference_rtnl(tn->child[i]);
- }
- 
--static inline t_key mask_pfx(t_key k, unsigned int l)
--{
--	return (l == 0) ? 0 : k >> (KEYLENGTH-l) << (KEYLENGTH-l);
--}
--
--static inline t_key tkey_extract_bits(t_key a, unsigned int offset, unsigned int bits)
--{
--	if (offset < KEYLENGTH)
--		return ((t_key)(a << offset)) >> (KEYLENGTH - bits);
--	else
--		return 0;
--}
--
--/*
--  To understand this stuff, an understanding of keys and all their bits is
--  necessary. Every node in the trie has a key associated with it, but not
--  all of the bits in that key are significant.
--
--  Consider a node 'n' and its parent 'tp'.
--
--  If n is a leaf, every bit in its key is significant. Its presence is
--  necessitated by path compression, since during a tree traversal (when
--  searching for a leaf - unless we are doing an insertion) we will completely
--  ignore all skipped bits we encounter. Thus we need to verify, at the end of
--  a potentially successful search, that we have indeed been walking the
--  correct key path.
--
--  Note that we can never "miss" the correct key in the tree if present by
--  following the wrong path. Path compression ensures that segments of the key
--  that are the same for all keys with a given prefix are skipped, but the
--  skipped part *is* identical for each node in the subtrie below the skipped
--  bit! trie_insert() in this implementation takes care of that - note the
--  call to tkey_sub_equals() in trie_insert().
--
--  if n is an internal node - a 'tnode' here, the various parts of its key
--  have many different meanings.
--
--  Example:
--  _________________________________________________________________
--  | i | i | i | i | i | i | i | N | N | N | S | S | S | S | S | C |
--  -----------------------------------------------------------------
--    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
--
--  _________________________________________________________________
--  | C | C | C | u | u | u | u | u | u | u | u | u | u | u | u | u |
--  -----------------------------------------------------------------
--   16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31
--
--  tp->pos = 7
--  tp->bits = 3
--  n->pos = 15
--  n->bits = 4
--
--  First, let's just ignore the bits that come before the parent tp, that is
--  the bits from 0 to (tp->pos-1). They are *known* but at this point we do
--  not use them for anything.
--
--  The bits from (tp->pos) to (tp->pos + tp->bits - 1) - "N", above - are the
--  index into the parent's child array. That is, they will be used to find
--  'n' among tp's children.
--
--  The bits from (tp->pos + tp->bits) to (n->pos - 1) - "S" - are skipped bits
--  for the node n.
--
--  All the bits we have seen so far are significant to the node n. The rest
--  of the bits are really not needed or indeed known in n->key.
--
--  The bits from (n->pos) to (n->pos + n->bits - 1) - "C" - are the index into
--  n's child array, and will of course be different for each child.
--
--
--  The rest of the bits, from (n->pos + n->bits) onward, are completely unknown
--  at this point.
--
--*/
-+/* To understand this stuff, an understanding of keys and all their bits is
-+ * necessary. Every node in the trie has a key associated with it, but not
-+ * all of the bits in that key are significant.
-+ *
-+ * Consider a node 'n' and its parent 'tp'.
-+ *
-+ * If n is a leaf, every bit in its key is significant. Its presence is
-+ * necessitated by path compression, since during a tree traversal (when
-+ * searching for a leaf - unless we are doing an insertion) we will completely
-+ * ignore all skipped bits we encounter. Thus we need to verify, at the end of
-+ * a potentially successful search, that we have indeed been walking the
-+ * correct key path.
-+ *
-+ * Note that we can never "miss" the correct key in the tree if present by
-+ * following the wrong path. Path compression ensures that segments of the key
-+ * that are the same for all keys with a given prefix are skipped, but the
-+ * skipped part *is* identical for each node in the subtrie below the skipped
-+ * bit! trie_insert() in this implementation takes care of that.
-+ *
-+ * if n is an internal node - a 'tnode' here, the various parts of its key
-+ * have many different meanings.
-+ *
-+ * Example:
-+ * _________________________________________________________________
-+ * | i | i | i | i | i | i | i | N | N | N | S | S | S | S | S | C |
-+ * -----------------------------------------------------------------
-+ *  31  30  29  28  27  26  25  24  23  22  21  20  19  18  17  16
-+ *
-+ * _________________________________________________________________
-+ * | C | C | C | u | u | u | u | u | u | u | u | u | u | u | u | u |
-+ * -----------------------------------------------------------------
-+ *  15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
-+ *
-+ * tp->pos = 22
-+ * tp->bits = 3
-+ * n->pos = 13
-+ * n->bits = 4
-+ *
-+ * First, let's just ignore the bits that come before the parent tp, that is
-+ * the bits from (tp->pos + tp->bits) to 31. They are *known* but at this
-+ * point we do not use them for anything.
-+ *
-+ * The bits from (tp->pos) to (tp->pos + tp->bits - 1) - "N", above - are the
-+ * index into the parent's child array. That is, they will be used to find
-+ * 'n' among tp's children.
-+ *
-+ * The bits from (n->pos + n->bits) to (tn->pos - 1) - "S" - are skipped bits
-+ * for the node n.
-+ *
-+ * All the bits we have seen so far are significant to the node n. The rest
-+ * of the bits are really not needed or indeed known in n->key.
-+ *
-+ * The bits from (n->pos) to (n->pos + n->bits - 1) - "C" - are the index into
-+ * n's child array, and will of course be different for each child.
-+ *
-+ * The rest of the bits, from 0 to (n->pos + n->bits), are completely unknown
-+ * at this point.
-+ */
- 
- static const int halve_threshold = 25;
- static const int inflate_threshold = 50;
-@@ -367,7 +349,7 @@ static struct tnode *leaf_new(t_key key)
- 		 * as the nodes are searched
- 		 */
- 		l->key = key;
--		l->pos = KEYLENGTH;
-+		l->pos = 0;
- 		/* set bits to 0 indicating we are not a tnode */
- 		l->bits = 0;
- 
-@@ -400,7 +382,7 @@ static struct tnode *tnode_new(t_key key
- 		tn->parent = NULL;
- 		tn->pos = pos;
- 		tn->bits = bits;
--		tn->key = mask_pfx(key, pos);
-+		tn->key = (shift < KEYLENGTH) ? (key >> shift) << shift : 0;
- 		tn->full_children = 0;
- 		tn->empty_children = 1<<bits;
- 	}
-@@ -410,14 +392,12 @@ static struct tnode *tnode_new(t_key key
- 	return tn;
- }
- 
--/*
-- * Check whether a tnode 'n' is "full", i.e. it is an internal node
-+/* Check whether a tnode 'n' is "full", i.e. it is an internal node
-  * and no bits are skipped. See discussion in dyntree paper p. 6
-  */
--
- static inline int tnode_full(const struct tnode *tn, const struct tnode *n)
- {
--	return n && IS_TNODE(n) && (n->pos == (tn->pos + tn->bits));
-+	return n && ((n->pos + n->bits) == tn->pos) && IS_TNODE(n);
- }
- 
- static inline void put_child(struct tnode *tn, int i,
-@@ -641,11 +621,12 @@ static struct tnode *inflate(struct trie
- {
- 	int olen = tnode_child_length(oldtnode);
- 	struct tnode *tn;
-+	t_key m;
- 	int i;
- 
- 	pr_debug("In inflate\n");
- 
--	tn = tnode_new(oldtnode->key, oldtnode->pos, oldtnode->bits + 1);
-+	tn = tnode_new(oldtnode->key, oldtnode->pos - 1, oldtnode->bits + 1);
- 
- 	if (!tn)
- 		return ERR_PTR(-ENOMEM);
-@@ -656,21 +637,18 @@ static struct tnode *inflate(struct trie
- 	 * fails. In case of failure we return the oldnode and  inflate
- 	 * of tnode is ignored.
- 	 */
-+	for (i = 0, m = 1u << tn->pos; i < olen; i++) {
-+		struct tnode *inode = tnode_get_child(oldtnode, i);
- 
--	for (i = 0; i < olen; i++) {
--		struct tnode *inode;
--
--		inode = tnode_get_child(oldtnode, i);
--		if (tnode_full(oldtnode, inode) && inode->bits > 1) {
-+		if (tnode_full(oldtnode, inode) && (inode->bits > 1)) {
- 			struct tnode *left, *right;
--			t_key m = ~0U << (KEYLENGTH - 1) >> inode->pos;
- 
--			left = tnode_new(inode->key&(~m), inode->pos + 1,
-+			left = tnode_new(inode->key & ~m, inode->pos,
- 					 inode->bits - 1);
- 			if (!left)
- 				goto nomem;
- 
--			right = tnode_new(inode->key|m, inode->pos + 1,
-+			right = tnode_new(inode->key | m, inode->pos,
- 					  inode->bits - 1);
- 
- 			if (!right) {
-@@ -694,9 +672,7 @@ static struct tnode *inflate(struct trie
- 
- 		/* A leaf or an internal node with skipped bits */
- 		if (!tnode_full(oldtnode, inode)) {
--			put_child(tn,
--				tkey_extract_bits(inode->key, tn->pos, tn->bits),
--				inode);
-+			put_child(tn, get_index(inode->key, tn), inode);
- 			continue;
- 		}
- 
-@@ -767,7 +743,7 @@ static struct tnode *halve(struct trie *
- 
- 	pr_debug("In halve\n");
- 
--	tn = tnode_new(oldtnode->key, oldtnode->pos, oldtnode->bits - 1);
-+	tn = tnode_new(oldtnode->key, oldtnode->pos + 1, oldtnode->bits - 1);
- 
- 	if (!tn)
- 		return ERR_PTR(-ENOMEM);
-@@ -787,7 +763,7 @@ static struct tnode *halve(struct trie *
- 		if (left && right) {
- 			struct tnode *newn;
- 
--			newn = tnode_new(left->key, tn->pos + tn->bits, 1);
-+			newn = tnode_new(left->key, oldtnode->pos, 1);
- 
- 			if (!newn)
- 				goto nomem;
-@@ -915,7 +891,7 @@ static void trie_rebalance(struct trie *
- 	key = tn->key;
- 
- 	while (tn != NULL && (tp = node_parent(tn)) != NULL) {
--		cindex = tkey_extract_bits(key, tp->pos, tp->bits);
-+		cindex = get_index(key, tp);
- 		wasfull = tnode_full(tp, tnode_get_child(tp, cindex));
- 		tn = resize(t, tn);
- 
-@@ -1005,11 +981,8 @@ static struct list_head *fib_insert_node
- 	 */
- 	if (n) {
- 		struct tnode *tn;
--		int newpos;
--
--		newpos = KEYLENGTH - __fls(n->key ^ key) - 1;
- 
--		tn = tnode_new(key, newpos, 1);
-+		tn = tnode_new(key, __fls(key ^ n->key), 1);
- 		if (!tn) {
- 			free_leaf_info(li);
- 			node_free(l);
-@@ -1559,12 +1532,7 @@ static int trie_flush_leaf(struct tnode
- static struct tnode *leaf_walk_rcu(struct tnode *p, struct tnode *c)
- {
- 	do {
--		t_key idx;
--
--		if (c)
--			idx = tkey_extract_bits(c->key, p->pos, p->bits) + 1;
--		else
--			idx = 0;
-+		t_key idx = c ? idx = get_index(c->key, p) + 1 : 0;
- 
- 		while (idx < 1u << p->bits) {
- 			c = tnode_get_child_rcu(p, idx++);
-@@ -1851,7 +1819,7 @@ rescan:
- 	/* Current node exhausted, pop back up */
- 	p = node_parent_rcu(tn);
- 	if (p) {
--		cindex = tkey_extract_bits(tn->key, p->pos, p->bits)+1;
-+		cindex = get_index(tn->key, p) + 1;
- 		tn = p;
- 		--iter->depth;
- 		goto rescan;
-@@ -2186,10 +2154,10 @@ static int fib_trie_seq_show(struct seq_
- 	if (IS_TNODE(n)) {
- 		__be32 prf = htonl(n->key);
- 
--		seq_indent(seq, iter->depth - 1);
--		seq_printf(seq, "  +-- %pI4/%d %d %d %d\n",
--			   &prf, n->pos, n->bits, n->full_children,
--			   n->empty_children);
-+		seq_indent(seq, iter->depth-1);
-+		seq_printf(seq, "  +-- %pI4/%zu %u %u %u\n",
-+			   &prf, KEYLENGTH - n->pos - n->bits, n->bits,
-+			   n->full_children, n->empty_children);
- 	} else {
- 		struct leaf_info *li;
- 		__be32 val = htonl(n->key);
--- a/target/linux/generic/pending-3.18/080-10-fib_trie-Use-unsigned-long-for-anything-dealing-with.patch	2022-03-22 08:54:47.268464771 +0800
+++ b/target/linux/generic/pending-3.18/080-10-fib_trie-Use-unsigned-long-for-anything-dealing-with.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,186 +0,0 @@
-From: Alexander Duyck <alexander.h.duyck@redhat.com>
-Date: Wed, 31 Dec 2014 10:56:18 -0800
-Subject: [PATCH] fib_trie: Use unsigned long for anything dealing with a
- shift by bits
-
-This change makes it so that anything that can be shifted by, or compared
-to a value shifted by bits is updated to be an unsigned long.  This is
-mostly a precaution against an insanely huge address space that somehow
-starts coming close to the 2^32 root node size which would require
-something like 1.5 billion addresses.
-
-I chose unsigned long instead of unsigned long long since I do not believe
-it is possible to allocate a 32 bit tnode on a 32 bit system as the memory
-consumed would be 16GB + 28B which exceeds the addressible space for any
-one process.
-
-Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -146,8 +146,8 @@ struct trie {
- #endif
- };
- 
--static void tnode_put_child_reorg(struct tnode *tn, int i, struct tnode *n,
--				  int wasfull);
-+static void tnode_put_child_reorg(struct tnode *tn, unsigned long i,
-+				  struct tnode *n, int wasfull);
- static struct tnode *resize(struct trie *t, struct tnode *tn);
- static struct tnode *inflate(struct trie *t, struct tnode *tn);
- static struct tnode *halve(struct trie *t, struct tnode *tn);
-@@ -183,25 +183,23 @@ static inline void node_set_parent(struc
- /* This provides us with the number of children in this node, in the case of a
-  * leaf this will return 0 meaning none of the children are accessible.
-  */
--static inline int tnode_child_length(const struct tnode *tn)
-+static inline unsigned long tnode_child_length(const struct tnode *tn)
- {
- 	return (1ul << tn->bits) & ~(1ul);
- }
- 
--/*
-- * caller must hold RTNL
-- */
--static inline struct tnode *tnode_get_child(const struct tnode *tn, unsigned int i)
-+/* caller must hold RTNL */
-+static inline struct tnode *tnode_get_child(const struct tnode *tn,
-+					    unsigned long i)
- {
- 	BUG_ON(i >= tnode_child_length(tn));
- 
- 	return rtnl_dereference(tn->child[i]);
- }
- 
--/*
-- * caller must hold RCU read lock or RTNL
-- */
--static inline struct tnode *tnode_get_child_rcu(const struct tnode *tn, unsigned int i)
-+/* caller must hold RCU read lock or RTNL */
-+static inline struct tnode *tnode_get_child_rcu(const struct tnode *tn,
-+						unsigned long i)
- {
- 	BUG_ON(i >= tnode_child_length(tn));
- 
-@@ -400,7 +398,7 @@ static inline int tnode_full(const struc
- 	return n && ((n->pos + n->bits) == tn->pos) && IS_TNODE(n);
- }
- 
--static inline void put_child(struct tnode *tn, int i,
-+static inline void put_child(struct tnode *tn, unsigned long i,
- 			     struct tnode *n)
- {
- 	tnode_put_child_reorg(tn, i, n, -1);
-@@ -411,13 +409,13 @@ static inline void put_child(struct tnod
-   * Update the value of full_children and empty_children.
-   */
- 
--static void tnode_put_child_reorg(struct tnode *tn, int i, struct tnode *n,
--				  int wasfull)
-+static void tnode_put_child_reorg(struct tnode *tn, unsigned long i,
-+				  struct tnode *n, int wasfull)
- {
- 	struct tnode *chi = rtnl_dereference(tn->child[i]);
- 	int isfull;
- 
--	BUG_ON(i >= 1<<tn->bits);
-+	BUG_ON(i >= tnode_child_length(tn));
- 
- 	/* update emptyChildren */
- 	if (n == NULL && chi != NULL)
-@@ -607,10 +605,10 @@ no_children:
- static void tnode_clean_free(struct tnode *tn)
- {
- 	struct tnode *tofree;
--	int i;
-+	unsigned long i;
- 
- 	for (i = 0; i < tnode_child_length(tn); i++) {
--		tofree = rtnl_dereference(tn->child[i]);
-+		tofree = tnode_get_child(tn, i);
- 		if (tofree)
- 			node_free(tofree);
- 	}
-@@ -619,10 +617,10 @@ static void tnode_clean_free(struct tnod
- 
- static struct tnode *inflate(struct trie *t, struct tnode *oldtnode)
- {
--	int olen = tnode_child_length(oldtnode);
-+	unsigned long olen = tnode_child_length(oldtnode);
- 	struct tnode *tn;
-+	unsigned long i;
- 	t_key m;
--	int i;
- 
- 	pr_debug("In inflate\n");
- 
-@@ -664,7 +662,7 @@ static struct tnode *inflate(struct trie
- 	for (i = 0; i < olen; i++) {
- 		struct tnode *inode = tnode_get_child(oldtnode, i);
- 		struct tnode *left, *right;
--		int size, j;
-+		unsigned long size, j;
- 
- 		/* An empty child */
- 		if (inode == NULL)
-@@ -737,7 +735,7 @@ nomem:
- 
- static struct tnode *halve(struct trie *t, struct tnode *oldtnode)
- {
--	int olen = tnode_child_length(oldtnode);
-+	unsigned long olen = tnode_child_length(oldtnode);
- 	struct tnode *tn, *left, *right;
- 	int i;
- 
-@@ -1532,9 +1530,9 @@ static int trie_flush_leaf(struct tnode
- static struct tnode *leaf_walk_rcu(struct tnode *p, struct tnode *c)
- {
- 	do {
--		t_key idx = c ? idx = get_index(c->key, p) + 1 : 0;
-+		unsigned long idx = c ? idx = get_index(c->key, p) + 1 : 0;
- 
--		while (idx < 1u << p->bits) {
-+		while (idx < tnode_child_length(p)) {
- 			c = tnode_get_child_rcu(p, idx++);
- 			if (!c)
- 				continue;
-@@ -1786,8 +1784,8 @@ struct fib_trie_iter {
- 
- static struct tnode *fib_trie_get_next(struct fib_trie_iter *iter)
- {
-+	unsigned long cindex = iter->index;
- 	struct tnode *tn = iter->tnode;
--	unsigned int cindex = iter->index;
- 	struct tnode *p;
- 
- 	/* A single entry routing table */
-@@ -1797,7 +1795,7 @@ static struct tnode *fib_trie_get_next(s
- 	pr_debug("get_next iter={node=%p index=%d depth=%d}\n",
- 		 iter->tnode, iter->index, iter->depth);
- rescan:
--	while (cindex < (1<<tn->bits)) {
-+	while (cindex < tnode_child_length(tn)) {
- 		struct tnode *n = tnode_get_child_rcu(tn, cindex);
- 
- 		if (n) {
-@@ -1874,15 +1872,16 @@ static void trie_collect_stats(struct tr
- 			hlist_for_each_entry_rcu(li, &n->list, hlist)
- 				++s->prefixes;
- 		} else {
--			int i;
-+			unsigned long i;
- 
- 			s->tnodes++;
- 			if (n->bits < MAX_STAT_DEPTH)
- 				s->nodesizes[n->bits]++;
- 
--			for (i = 0; i < tnode_child_length(n); i++)
-+			for (i = 0; i < tnode_child_length(n); i++) {
- 				if (!rcu_access_pointer(n->child[i]))
- 					s->nullpointers++;
-+			}
- 		}
- 	}
- 	rcu_read_unlock();
--- a/target/linux/generic/pending-3.18/080-11-fib_trie-Push-rcu_read_lock-unlock-to-callers.patch	2022-03-22 08:54:47.268464771 +0800
+++ b/target/linux/generic/pending-3.18/080-11-fib_trie-Push-rcu_read_lock-unlock-to-callers.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,403 +0,0 @@
-From: Alexander Duyck <alexander.h.duyck@redhat.com>
-Date: Wed, 31 Dec 2014 10:56:24 -0800
-Subject: [PATCH] fib_trie: Push rcu_read_lock/unlock to callers
-
-This change is to start cleaning up some of the rcu_read_lock/unlock
-handling.  I realized while reviewing the code there are several spots that
-I don't believe are being handled correctly or are masking warnings by
-locally calling rcu_read_lock/unlock instead of calling them at the correct
-level.
-
-A common example is a call to fib_get_table followed by fib_table_lookup.
-The rcu_read_lock/unlock ought to wrap both but there are several spots where
-they were not wrapped.
-
-Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/include/net/ip_fib.h
-+++ b/include/net/ip_fib.h
-@@ -222,16 +222,19 @@ static inline struct fib_table *fib_new_
- static inline int fib_lookup(struct net *net, const struct flowi4 *flp,
- 			     struct fib_result *res)
- {
--	struct fib_table *table;
-+	int err = -ENETUNREACH;
- 
--	table = fib_get_table(net, RT_TABLE_LOCAL);
--	if (!fib_table_lookup(table, flp, res, FIB_LOOKUP_NOREF))
--		return 0;
--
--	table = fib_get_table(net, RT_TABLE_MAIN);
--	if (!fib_table_lookup(table, flp, res, FIB_LOOKUP_NOREF))
--		return 0;
--	return -ENETUNREACH;
-+	rcu_read_lock();
-+
-+	if (!fib_table_lookup(fib_get_table(net, RT_TABLE_LOCAL), flp, res,
-+			      FIB_LOOKUP_NOREF) ||
-+	    !fib_table_lookup(fib_get_table(net, RT_TABLE_MAIN), flp, res,
-+			      FIB_LOOKUP_NOREF))
-+		err = 0;
-+
-+	rcu_read_unlock();
-+
-+	return err;
- }
- 
- #else /* CONFIG_IP_MULTIPLE_TABLES */
-@@ -247,20 +250,25 @@ static inline int fib_lookup(struct net
- 			     struct fib_result *res)
- {
- 	if (!net->ipv4.fib_has_custom_rules) {
-+		int err = -ENETUNREACH;
-+
-+		rcu_read_lock();
-+
- 		res->tclassid = 0;
--		if (net->ipv4.fib_local &&
--		    !fib_table_lookup(net->ipv4.fib_local, flp, res,
--				      FIB_LOOKUP_NOREF))
--			return 0;
--		if (net->ipv4.fib_main &&
--		    !fib_table_lookup(net->ipv4.fib_main, flp, res,
--				      FIB_LOOKUP_NOREF))
--			return 0;
--		if (net->ipv4.fib_default &&
--		    !fib_table_lookup(net->ipv4.fib_default, flp, res,
--				      FIB_LOOKUP_NOREF))
--			return 0;
--		return -ENETUNREACH;
-+		if ((net->ipv4.fib_local &&
-+		     !fib_table_lookup(net->ipv4.fib_local, flp, res,
-+				       FIB_LOOKUP_NOREF)) ||
-+		    (net->ipv4.fib_main &&
-+		     !fib_table_lookup(net->ipv4.fib_main, flp, res,
-+				       FIB_LOOKUP_NOREF)) ||
-+		    (net->ipv4.fib_default &&
-+		     !fib_table_lookup(net->ipv4.fib_default, flp, res,
-+				       FIB_LOOKUP_NOREF)))
-+			err = 0;
-+
-+		rcu_read_unlock();
-+
-+		return err;
- 	}
- 	return __fib_lookup(net, flp, res);
- }
---- a/net/ipv4/fib_frontend.c
-+++ b/net/ipv4/fib_frontend.c
-@@ -109,6 +109,7 @@ struct fib_table *fib_new_table(struct n
- 	return tb;
- }
- 
-+/* caller must hold either rtnl or rcu read lock */
- struct fib_table *fib_get_table(struct net *net, u32 id)
- {
- 	struct fib_table *tb;
-@@ -119,15 +120,11 @@ struct fib_table *fib_get_table(struct n
- 		id = RT_TABLE_MAIN;
- 	h = id & (FIB_TABLE_HASHSZ - 1);
- 
--	rcu_read_lock();
- 	head = &net->ipv4.fib_table_hash[h];
- 	hlist_for_each_entry_rcu(tb, head, tb_hlist) {
--		if (tb->tb_id == id) {
--			rcu_read_unlock();
-+		if (tb->tb_id == id)
- 			return tb;
--		}
- 	}
--	rcu_read_unlock();
- 	return NULL;
- }
- #endif /* CONFIG_IP_MULTIPLE_TABLES */
-@@ -167,16 +164,18 @@ static inline unsigned int __inet_dev_ad
- 	if (ipv4_is_multicast(addr))
- 		return RTN_MULTICAST;
- 
-+	rcu_read_lock();
-+
- 	local_table = fib_get_table(net, RT_TABLE_LOCAL);
- 	if (local_table) {
- 		ret = RTN_UNICAST;
--		rcu_read_lock();
- 		if (!fib_table_lookup(local_table, &fl4, &res, FIB_LOOKUP_NOREF)) {
- 			if (!dev || dev == res.fi->fib_dev)
- 				ret = res.type;
- 		}
--		rcu_read_unlock();
- 	}
-+
-+	rcu_read_unlock();
- 	return ret;
- }
- 
-@@ -923,7 +922,7 @@ no_promotions:
- #undef BRD1_OK
- }
- 
--static void nl_fib_lookup(struct fib_result_nl *frn, struct fib_table *tb)
-+static void nl_fib_lookup(struct net *net, struct fib_result_nl *frn)
- {
- 
- 	struct fib_result       res;
-@@ -933,6 +932,11 @@ static void nl_fib_lookup(struct fib_res
- 		.flowi4_tos = frn->fl_tos,
- 		.flowi4_scope = frn->fl_scope,
- 	};
-+	struct fib_table *tb;
-+
-+	rcu_read_lock();
-+
-+	tb = fib_get_table(net, frn->tb_id_in);
- 
- 	frn->err = -ENOENT;
- 	if (tb) {
-@@ -949,6 +953,8 @@ static void nl_fib_lookup(struct fib_res
- 		}
- 		local_bh_enable();
- 	}
-+
-+	rcu_read_unlock();
- }
- 
- static void nl_fib_input(struct sk_buff *skb)
-@@ -956,7 +962,6 @@ static void nl_fib_input(struct sk_buff
- 	struct net *net;
- 	struct fib_result_nl *frn;
- 	struct nlmsghdr *nlh;
--	struct fib_table *tb;
- 	u32 portid;
- 
- 	net = sock_net(skb->sk);
-@@ -972,9 +977,7 @@ static void nl_fib_input(struct sk_buff
- 	nlh = nlmsg_hdr(skb);
- 
- 	frn = (struct fib_result_nl *) nlmsg_data(nlh);
--	tb = fib_get_table(net, frn->tb_id_in);
--
--	nl_fib_lookup(frn, tb);
-+	nl_fib_lookup(net, frn);
- 
- 	portid = NETLINK_CB(skb).portid;      /* netlink portid */
- 	NETLINK_CB(skb).portid = 0;        /* from kernel */
---- a/net/ipv4/fib_rules.c
-+++ b/net/ipv4/fib_rules.c
-@@ -81,27 +81,25 @@ static int fib4_rule_action(struct fib_r
- 		break;
- 
- 	case FR_ACT_UNREACHABLE:
--		err = -ENETUNREACH;
--		goto errout;
-+		return -ENETUNREACH;
- 
- 	case FR_ACT_PROHIBIT:
--		err = -EACCES;
--		goto errout;
-+		return -EACCES;
- 
- 	case FR_ACT_BLACKHOLE:
- 	default:
--		err = -EINVAL;
--		goto errout;
-+		return -EINVAL;
- 	}
- 
-+	rcu_read_lock();
-+
- 	tbl = fib_get_table(rule->fr_net, rule->table);
--	if (!tbl)
--		goto errout;
-+	if (tbl)
-+		err = fib_table_lookup(tbl, &flp->u.ip4,
-+				       (struct fib_result *)arg->result,
-+				       arg->flags);
- 
--	err = fib_table_lookup(tbl, &flp->u.ip4, (struct fib_result *) arg->result, arg->flags);
--	if (err > 0)
--		err = -EAGAIN;
--errout:
-+	rcu_read_unlock();
- 	return err;
- }
- 
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -1181,72 +1181,6 @@ err:
- 	return err;
- }
- 
--/* should be called with rcu_read_lock */
--static int check_leaf(struct fib_table *tb, struct trie *t, struct tnode *l,
--		      t_key key,  const struct flowi4 *flp,
--		      struct fib_result *res, int fib_flags)
--{
--	struct leaf_info *li;
--	struct hlist_head *hhead = &l->list;
--
--	hlist_for_each_entry_rcu(li, hhead, hlist) {
--		struct fib_alias *fa;
--
--		if (l->key != (key & li->mask_plen))
--			continue;
--
--		list_for_each_entry_rcu(fa, &li->falh, fa_list) {
--			struct fib_info *fi = fa->fa_info;
--			int nhsel, err;
--
--			if (fa->fa_tos && fa->fa_tos != flp->flowi4_tos)
--				continue;
--			if (fi->fib_dead)
--				continue;
--			if (fa->fa_info->fib_scope < flp->flowi4_scope)
--				continue;
--			fib_alias_accessed(fa);
--			err = fib_props[fa->fa_type].error;
--			if (unlikely(err < 0)) {
--#ifdef CONFIG_IP_FIB_TRIE_STATS
--				this_cpu_inc(t->stats->semantic_match_passed);
--#endif
--				return err;
--			}
--			if (fi->fib_flags & RTNH_F_DEAD)
--				continue;
--			for (nhsel = 0; nhsel < fi->fib_nhs; nhsel++) {
--				const struct fib_nh *nh = &fi->fib_nh[nhsel];
--
--				if (nh->nh_flags & RTNH_F_DEAD)
--					continue;
--				if (flp->flowi4_oif && flp->flowi4_oif != nh->nh_oif)
--					continue;
--
--#ifdef CONFIG_IP_FIB_TRIE_STATS
--				this_cpu_inc(t->stats->semantic_match_passed);
--#endif
--				res->prefixlen = li->plen;
--				res->nh_sel = nhsel;
--				res->type = fa->fa_type;
--				res->scope = fi->fib_scope;
--				res->fi = fi;
--				res->table = tb;
--				res->fa_head = &li->falh;
--				if (!(fib_flags & FIB_LOOKUP_NOREF))
--					atomic_inc(&fi->fib_clntref);
--				return 0;
--			}
--		}
--
--#ifdef CONFIG_IP_FIB_TRIE_STATS
--		this_cpu_inc(t->stats->semantic_match_miss);
--#endif
--	}
--
--	return 1;
--}
--
- static inline t_key prefix_mismatch(t_key key, struct tnode *n)
- {
- 	t_key prefix = n->key;
-@@ -1254,6 +1188,7 @@ static inline t_key prefix_mismatch(t_ke
- 	return (key ^ prefix) & (prefix | -prefix);
- }
- 
-+/* should be called with rcu_read_lock */
- int fib_table_lookup(struct fib_table *tb, const struct flowi4 *flp,
- 		     struct fib_result *res, int fib_flags)
- {
-@@ -1263,14 +1198,12 @@ int fib_table_lookup(struct fib_table *t
- #endif
- 	const t_key key = ntohl(flp->daddr);
- 	struct tnode *n, *pn;
-+	struct leaf_info *li;
- 	t_key cindex;
--	int ret = 1;
--
--	rcu_read_lock();
- 
- 	n = rcu_dereference(t->trie);
- 	if (!n)
--		goto failed;
-+		return -EAGAIN;
- 
- #ifdef CONFIG_IP_FIB_TRIE_STATS
- 	this_cpu_inc(stats->gets);
-@@ -1350,7 +1283,7 @@ backtrace:
- 
- 				pn = node_parent_rcu(pn);
- 				if (unlikely(!pn))
--					goto failed;
-+					return -EAGAIN;
- #ifdef CONFIG_IP_FIB_TRIE_STATS
- 				this_cpu_inc(stats->backtrack);
- #endif
-@@ -1368,12 +1301,62 @@ backtrace:
- 
- found:
- 	/* Step 3: Process the leaf, if that fails fall back to backtracing */
--	ret = check_leaf(tb, t, n, key, flp, res, fib_flags);
--	if (unlikely(ret > 0))
--		goto backtrace;
--failed:
--	rcu_read_unlock();
--	return ret;
-+	hlist_for_each_entry_rcu(li, &n->list, hlist) {
-+		struct fib_alias *fa;
-+
-+		if ((key ^ n->key) & li->mask_plen)
-+			continue;
-+
-+		list_for_each_entry_rcu(fa, &li->falh, fa_list) {
-+			struct fib_info *fi = fa->fa_info;
-+			int nhsel, err;
-+
-+			if (fa->fa_tos && fa->fa_tos != flp->flowi4_tos)
-+				continue;
-+			if (fi->fib_dead)
-+				continue;
-+			if (fa->fa_info->fib_scope < flp->flowi4_scope)
-+				continue;
-+			fib_alias_accessed(fa);
-+			err = fib_props[fa->fa_type].error;
-+			if (unlikely(err < 0)) {
-+#ifdef CONFIG_IP_FIB_TRIE_STATS
-+				this_cpu_inc(stats->semantic_match_passed);
-+#endif
-+				return err;
-+			}
-+			if (fi->fib_flags & RTNH_F_DEAD)
-+				continue;
-+			for (nhsel = 0; nhsel < fi->fib_nhs; nhsel++) {
-+				const struct fib_nh *nh = &fi->fib_nh[nhsel];
-+
-+				if (nh->nh_flags & RTNH_F_DEAD)
-+					continue;
-+				if (flp->flowi4_oif && flp->flowi4_oif != nh->nh_oif)
-+					continue;
-+
-+				if (!(fib_flags & FIB_LOOKUP_NOREF))
-+					atomic_inc(&fi->fib_clntref);
-+
-+				res->prefixlen = li->plen;
-+				res->nh_sel = nhsel;
-+				res->type = fa->fa_type;
-+				res->scope = fi->fib_scope;
-+				res->fi = fi;
-+				res->table = tb;
-+				res->fa_head = &li->falh;
-+#ifdef CONFIG_IP_FIB_TRIE_STATS
-+				this_cpu_inc(stats->semantic_match_passed);
-+#endif
-+				return err;
-+			}
-+		}
-+
-+#ifdef CONFIG_IP_FIB_TRIE_STATS
-+		this_cpu_inc(stats->semantic_match_miss);
-+#endif
-+	}
-+	goto backtrace;
- }
- EXPORT_SYMBOL_GPL(fib_table_lookup);
- 
--- a/target/linux/generic/pending-3.18/080-12-fib_trie-Move-resize-to-after-inflate-halve.patch	2022-03-22 08:54:47.269464773 +0800
+++ b/target/linux/generic/pending-3.18/080-12-fib_trie-Move-resize-to-after-inflate-halve.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,345 +0,0 @@
-From: Alexander Duyck <alexander.h.duyck@redhat.com>
-Date: Wed, 31 Dec 2014 10:56:31 -0800
-Subject: [PATCH] fib_trie: Move resize to after inflate/halve
-
-This change consists of a cut/paste of resize to behind inflate and halve
-so that I could remove the two function prototypes.
-
-Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -149,8 +149,6 @@ struct trie {
- static void tnode_put_child_reorg(struct tnode *tn, unsigned long i,
- 				  struct tnode *n, int wasfull);
- static struct tnode *resize(struct trie *t, struct tnode *tn);
--static struct tnode *inflate(struct trie *t, struct tnode *tn);
--static struct tnode *halve(struct trie *t, struct tnode *tn);
- /* tnodes to free after resize(); protected by RTNL */
- static struct callback_head *tnode_free_head;
- static size_t tnode_free_size;
-@@ -447,161 +445,6 @@ static void put_child_root(struct tnode
- 		rcu_assign_pointer(t->trie, n);
- }
- 
--#define MAX_WORK 10
--static struct tnode *resize(struct trie *t, struct tnode *tn)
--{
--	struct tnode *old_tn, *n = NULL;
--	int inflate_threshold_use;
--	int halve_threshold_use;
--	int max_work;
--
--	if (!tn)
--		return NULL;
--
--	pr_debug("In tnode_resize %p inflate_threshold=%d threshold=%d\n",
--		 tn, inflate_threshold, halve_threshold);
--
--	/* No children */
--	if (tn->empty_children > (tnode_child_length(tn) - 1))
--		goto no_children;
--
--	/* One child */
--	if (tn->empty_children == (tnode_child_length(tn) - 1))
--		goto one_child;
--	/*
--	 * Double as long as the resulting node has a number of
--	 * nonempty nodes that are above the threshold.
--	 */
--
--	/*
--	 * From "Implementing a dynamic compressed trie" by Stefan Nilsson of
--	 * the Helsinki University of Technology and Matti Tikkanen of Nokia
--	 * Telecommunications, page 6:
--	 * "A node is doubled if the ratio of non-empty children to all
--	 * children in the *doubled* node is at least 'high'."
--	 *
--	 * 'high' in this instance is the variable 'inflate_threshold'. It
--	 * is expressed as a percentage, so we multiply it with
--	 * tnode_child_length() and instead of multiplying by 2 (since the
--	 * child array will be doubled by inflate()) and multiplying
--	 * the left-hand side by 100 (to handle the percentage thing) we
--	 * multiply the left-hand side by 50.
--	 *
--	 * The left-hand side may look a bit weird: tnode_child_length(tn)
--	 * - tn->empty_children is of course the number of non-null children
--	 * in the current node. tn->full_children is the number of "full"
--	 * children, that is non-null tnodes with a skip value of 0.
--	 * All of those will be doubled in the resulting inflated tnode, so
--	 * we just count them one extra time here.
--	 *
--	 * A clearer way to write this would be:
--	 *
--	 * to_be_doubled = tn->full_children;
--	 * not_to_be_doubled = tnode_child_length(tn) - tn->empty_children -
--	 *     tn->full_children;
--	 *
--	 * new_child_length = tnode_child_length(tn) * 2;
--	 *
--	 * new_fill_factor = 100 * (not_to_be_doubled + 2*to_be_doubled) /
--	 *      new_child_length;
--	 * if (new_fill_factor >= inflate_threshold)
--	 *
--	 * ...and so on, tho it would mess up the while () loop.
--	 *
--	 * anyway,
--	 * 100 * (not_to_be_doubled + 2*to_be_doubled) / new_child_length >=
--	 *      inflate_threshold
--	 *
--	 * avoid a division:
--	 * 100 * (not_to_be_doubled + 2*to_be_doubled) >=
--	 *      inflate_threshold * new_child_length
--	 *
--	 * expand not_to_be_doubled and to_be_doubled, and shorten:
--	 * 100 * (tnode_child_length(tn) - tn->empty_children +
--	 *    tn->full_children) >= inflate_threshold * new_child_length
--	 *
--	 * expand new_child_length:
--	 * 100 * (tnode_child_length(tn) - tn->empty_children +
--	 *    tn->full_children) >=
--	 *      inflate_threshold * tnode_child_length(tn) * 2
--	 *
--	 * shorten again:
--	 * 50 * (tn->full_children + tnode_child_length(tn) -
--	 *    tn->empty_children) >= inflate_threshold *
--	 *    tnode_child_length(tn)
--	 *
--	 */
--
--	/* Keep root node larger  */
--
--	if (!node_parent(tn)) {
--		inflate_threshold_use = inflate_threshold_root;
--		halve_threshold_use = halve_threshold_root;
--	} else {
--		inflate_threshold_use = inflate_threshold;
--		halve_threshold_use = halve_threshold;
--	}
--
--	max_work = MAX_WORK;
--	while ((tn->full_children > 0 &&  max_work-- &&
--		50 * (tn->full_children + tnode_child_length(tn)
--		      - tn->empty_children)
--		>= inflate_threshold_use * tnode_child_length(tn))) {
--
--		old_tn = tn;
--		tn = inflate(t, tn);
--
--		if (IS_ERR(tn)) {
--			tn = old_tn;
--#ifdef CONFIG_IP_FIB_TRIE_STATS
--			this_cpu_inc(t->stats->resize_node_skipped);
--#endif
--			break;
--		}
--	}
--
--	/* Return if at least one inflate is run */
--	if (max_work != MAX_WORK)
--		return tn;
--
--	/*
--	 * Halve as long as the number of empty children in this
--	 * node is above threshold.
--	 */
--
--	max_work = MAX_WORK;
--	while (tn->bits > 1 &&  max_work-- &&
--	       100 * (tnode_child_length(tn) - tn->empty_children) <
--	       halve_threshold_use * tnode_child_length(tn)) {
--
--		old_tn = tn;
--		tn = halve(t, tn);
--		if (IS_ERR(tn)) {
--			tn = old_tn;
--#ifdef CONFIG_IP_FIB_TRIE_STATS
--			this_cpu_inc(t->stats->resize_node_skipped);
--#endif
--			break;
--		}
--	}
--
--
--	/* Only one child remains */
--	if (tn->empty_children == (tnode_child_length(tn) - 1)) {
--		unsigned long i;
--one_child:
--		for (i = tnode_child_length(tn); !n && i;)
--			n = tnode_get_child(tn, --i);
--no_children:
--		/* compress one level */
--		node_set_parent(n, NULL);
--		tnode_free_safe(tn);
--		return n;
--	}
--	return tn;
--}
--
--
- static void tnode_clean_free(struct tnode *tn)
- {
- 	struct tnode *tofree;
-@@ -804,6 +647,160 @@ nomem:
- 	return ERR_PTR(-ENOMEM);
- }
- 
-+#define MAX_WORK 10
-+static struct tnode *resize(struct trie *t, struct tnode *tn)
-+{
-+	struct tnode *old_tn, *n = NULL;
-+	int inflate_threshold_use;
-+	int halve_threshold_use;
-+	int max_work;
-+
-+	if (!tn)
-+		return NULL;
-+
-+	pr_debug("In tnode_resize %p inflate_threshold=%d threshold=%d\n",
-+		 tn, inflate_threshold, halve_threshold);
-+
-+	/* No children */
-+	if (tn->empty_children > (tnode_child_length(tn) - 1))
-+		goto no_children;
-+
-+	/* One child */
-+	if (tn->empty_children == (tnode_child_length(tn) - 1))
-+		goto one_child;
-+	/*
-+	 * Double as long as the resulting node has a number of
-+	 * nonempty nodes that are above the threshold.
-+	 */
-+
-+	/*
-+	 * From "Implementing a dynamic compressed trie" by Stefan Nilsson of
-+	 * the Helsinki University of Technology and Matti Tikkanen of Nokia
-+	 * Telecommunications, page 6:
-+	 * "A node is doubled if the ratio of non-empty children to all
-+	 * children in the *doubled* node is at least 'high'."
-+	 *
-+	 * 'high' in this instance is the variable 'inflate_threshold'. It
-+	 * is expressed as a percentage, so we multiply it with
-+	 * tnode_child_length() and instead of multiplying by 2 (since the
-+	 * child array will be doubled by inflate()) and multiplying
-+	 * the left-hand side by 100 (to handle the percentage thing) we
-+	 * multiply the left-hand side by 50.
-+	 *
-+	 * The left-hand side may look a bit weird: tnode_child_length(tn)
-+	 * - tn->empty_children is of course the number of non-null children
-+	 * in the current node. tn->full_children is the number of "full"
-+	 * children, that is non-null tnodes with a skip value of 0.
-+	 * All of those will be doubled in the resulting inflated tnode, so
-+	 * we just count them one extra time here.
-+	 *
-+	 * A clearer way to write this would be:
-+	 *
-+	 * to_be_doubled = tn->full_children;
-+	 * not_to_be_doubled = tnode_child_length(tn) - tn->empty_children -
-+	 *     tn->full_children;
-+	 *
-+	 * new_child_length = tnode_child_length(tn) * 2;
-+	 *
-+	 * new_fill_factor = 100 * (not_to_be_doubled + 2*to_be_doubled) /
-+	 *      new_child_length;
-+	 * if (new_fill_factor >= inflate_threshold)
-+	 *
-+	 * ...and so on, tho it would mess up the while () loop.
-+	 *
-+	 * anyway,
-+	 * 100 * (not_to_be_doubled + 2*to_be_doubled) / new_child_length >=
-+	 *      inflate_threshold
-+	 *
-+	 * avoid a division:
-+	 * 100 * (not_to_be_doubled + 2*to_be_doubled) >=
-+	 *      inflate_threshold * new_child_length
-+	 *
-+	 * expand not_to_be_doubled and to_be_doubled, and shorten:
-+	 * 100 * (tnode_child_length(tn) - tn->empty_children +
-+	 *    tn->full_children) >= inflate_threshold * new_child_length
-+	 *
-+	 * expand new_child_length:
-+	 * 100 * (tnode_child_length(tn) - tn->empty_children +
-+	 *    tn->full_children) >=
-+	 *      inflate_threshold * tnode_child_length(tn) * 2
-+	 *
-+	 * shorten again:
-+	 * 50 * (tn->full_children + tnode_child_length(tn) -
-+	 *    tn->empty_children) >= inflate_threshold *
-+	 *    tnode_child_length(tn)
-+	 *
-+	 */
-+
-+	/* Keep root node larger  */
-+
-+	if (!node_parent(tn)) {
-+		inflate_threshold_use = inflate_threshold_root;
-+		halve_threshold_use = halve_threshold_root;
-+	} else {
-+		inflate_threshold_use = inflate_threshold;
-+		halve_threshold_use = halve_threshold;
-+	}
-+
-+	max_work = MAX_WORK;
-+	while ((tn->full_children > 0 &&  max_work-- &&
-+		50 * (tn->full_children + tnode_child_length(tn)
-+		      - tn->empty_children)
-+		>= inflate_threshold_use * tnode_child_length(tn))) {
-+
-+		old_tn = tn;
-+		tn = inflate(t, tn);
-+
-+		if (IS_ERR(tn)) {
-+			tn = old_tn;
-+#ifdef CONFIG_IP_FIB_TRIE_STATS
-+			this_cpu_inc(t->stats->resize_node_skipped);
-+#endif
-+			break;
-+		}
-+	}
-+
-+	/* Return if at least one inflate is run */
-+	if (max_work != MAX_WORK)
-+		return tn;
-+
-+	/*
-+	 * Halve as long as the number of empty children in this
-+	 * node is above threshold.
-+	 */
-+
-+	max_work = MAX_WORK;
-+	while (tn->bits > 1 &&  max_work-- &&
-+	       100 * (tnode_child_length(tn) - tn->empty_children) <
-+	       halve_threshold_use * tnode_child_length(tn)) {
-+
-+		old_tn = tn;
-+		tn = halve(t, tn);
-+		if (IS_ERR(tn)) {
-+			tn = old_tn;
-+#ifdef CONFIG_IP_FIB_TRIE_STATS
-+			this_cpu_inc(t->stats->resize_node_skipped);
-+#endif
-+			break;
-+		}
-+	}
-+
-+
-+	/* Only one child remains */
-+	if (tn->empty_children == (tnode_child_length(tn) - 1)) {
-+		unsigned long i;
-+one_child:
-+		for (i = tnode_child_length(tn); !n && i;)
-+			n = tnode_get_child(tn, --i);
-+no_children:
-+		/* compress one level */
-+		node_set_parent(n, NULL);
-+		tnode_free_safe(tn);
-+		return n;
-+	}
-+	return tn;
-+}
-+
- /* readside must use rcu_read_lock currently dump routines
-  via get_fa_head and dump */
- 
--- a/target/linux/generic/pending-3.18/080-13-fib_trie-Add-functions-should_inflate-and-should_hal.patch	2022-03-22 08:54:47.270464774 +0800
+++ b/target/linux/generic/pending-3.18/080-13-fib_trie-Add-functions-should_inflate-and-should_hal.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,250 +0,0 @@
-From: Alexander Duyck <alexander.h.duyck@redhat.com>
-Date: Wed, 31 Dec 2014 10:56:37 -0800
-Subject: [PATCH] fib_trie: Add functions should_inflate and should_halve
-
-This change pulls the logic for if we should inflate/halve the nodes out
-into separate functions.  It also addresses what I believe is a bug where 1
-full node is all that is needed to keep a node from ever being halved.
-
-Simple script to reproduce the issue:
-	modprobe dummy;	ifconfig dummy0 up
-	for i in `seq 0 255`; do ifconfig dummy0:$i 10.0.${i}.1/24 up; done
-	ifconfig dummy0:256 10.0.255.33/16 up
-	for i in `seq 0 254`; do ifconfig dummy0:$i down; done
-
-Results from /proc/net/fib_triestat
-Before:
-	Local:
-		Aver depth:     3.00
-		Max depth:      4
-		Leaves:         17
-		Prefixes:       18
-		Internal nodes: 11
-		  1: 8  2: 2  10: 1
-		Pointers: 1048
-	Null ptrs: 1021
-	Total size: 11  kB
-After:
-	Local:
-		Aver depth:     3.41
-		Max depth:      5
-		Leaves:         17
-		Prefixes:       18
-		Internal nodes: 12
-		  1: 8  2: 3  3: 1
-		Pointers: 36
-	Null ptrs: 8
-	Total size: 3  kB
-
-Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -647,12 +647,94 @@ nomem:
- 	return ERR_PTR(-ENOMEM);
- }
- 
-+/* From "Implementing a dynamic compressed trie" by Stefan Nilsson of
-+ * the Helsinki University of Technology and Matti Tikkanen of Nokia
-+ * Telecommunications, page 6:
-+ * "A node is doubled if the ratio of non-empty children to all
-+ * children in the *doubled* node is at least 'high'."
-+ *
-+ * 'high' in this instance is the variable 'inflate_threshold'. It
-+ * is expressed as a percentage, so we multiply it with
-+ * tnode_child_length() and instead of multiplying by 2 (since the
-+ * child array will be doubled by inflate()) and multiplying
-+ * the left-hand side by 100 (to handle the percentage thing) we
-+ * multiply the left-hand side by 50.
-+ *
-+ * The left-hand side may look a bit weird: tnode_child_length(tn)
-+ * - tn->empty_children is of course the number of non-null children
-+ * in the current node. tn->full_children is the number of "full"
-+ * children, that is non-null tnodes with a skip value of 0.
-+ * All of those will be doubled in the resulting inflated tnode, so
-+ * we just count them one extra time here.
-+ *
-+ * A clearer way to write this would be:
-+ *
-+ * to_be_doubled = tn->full_children;
-+ * not_to_be_doubled = tnode_child_length(tn) - tn->empty_children -
-+ *     tn->full_children;
-+ *
-+ * new_child_length = tnode_child_length(tn) * 2;
-+ *
-+ * new_fill_factor = 100 * (not_to_be_doubled + 2*to_be_doubled) /
-+ *      new_child_length;
-+ * if (new_fill_factor >= inflate_threshold)
-+ *
-+ * ...and so on, tho it would mess up the while () loop.
-+ *
-+ * anyway,
-+ * 100 * (not_to_be_doubled + 2*to_be_doubled) / new_child_length >=
-+ *      inflate_threshold
-+ *
-+ * avoid a division:
-+ * 100 * (not_to_be_doubled + 2*to_be_doubled) >=
-+ *      inflate_threshold * new_child_length
-+ *
-+ * expand not_to_be_doubled and to_be_doubled, and shorten:
-+ * 100 * (tnode_child_length(tn) - tn->empty_children +
-+ *    tn->full_children) >= inflate_threshold * new_child_length
-+ *
-+ * expand new_child_length:
-+ * 100 * (tnode_child_length(tn) - tn->empty_children +
-+ *    tn->full_children) >=
-+ *      inflate_threshold * tnode_child_length(tn) * 2
-+ *
-+ * shorten again:
-+ * 50 * (tn->full_children + tnode_child_length(tn) -
-+ *    tn->empty_children) >= inflate_threshold *
-+ *    tnode_child_length(tn)
-+ *
-+ */
-+static bool should_inflate(const struct tnode *tn)
-+{
-+	unsigned long used = tnode_child_length(tn);
-+	unsigned long threshold = used;
-+
-+	/* Keep root node larger */
-+	threshold *= node_parent(tn) ? inflate_threshold :
-+				       inflate_threshold_root;
-+	used += tn->full_children;
-+	used -= tn->empty_children;
-+
-+	return tn->pos && ((50 * used) >= threshold);
-+}
-+
-+static bool should_halve(const struct tnode *tn)
-+{
-+	unsigned long used = tnode_child_length(tn);
-+	unsigned long threshold = used;
-+
-+	/* Keep root node larger */
-+	threshold *= node_parent(tn) ? halve_threshold :
-+				       halve_threshold_root;
-+	used -= tn->empty_children;
-+
-+	return (tn->bits > 1) && ((100 * used) < threshold);
-+}
-+
- #define MAX_WORK 10
- static struct tnode *resize(struct trie *t, struct tnode *tn)
- {
- 	struct tnode *old_tn, *n = NULL;
--	int inflate_threshold_use;
--	int halve_threshold_use;
- 	int max_work;
- 
- 	if (!tn)
-@@ -668,86 +750,12 @@ static struct tnode *resize(struct trie
- 	/* One child */
- 	if (tn->empty_children == (tnode_child_length(tn) - 1))
- 		goto one_child;
--	/*
--	 * Double as long as the resulting node has a number of
--	 * nonempty nodes that are above the threshold.
--	 */
- 
--	/*
--	 * From "Implementing a dynamic compressed trie" by Stefan Nilsson of
--	 * the Helsinki University of Technology and Matti Tikkanen of Nokia
--	 * Telecommunications, page 6:
--	 * "A node is doubled if the ratio of non-empty children to all
--	 * children in the *doubled* node is at least 'high'."
--	 *
--	 * 'high' in this instance is the variable 'inflate_threshold'. It
--	 * is expressed as a percentage, so we multiply it with
--	 * tnode_child_length() and instead of multiplying by 2 (since the
--	 * child array will be doubled by inflate()) and multiplying
--	 * the left-hand side by 100 (to handle the percentage thing) we
--	 * multiply the left-hand side by 50.
--	 *
--	 * The left-hand side may look a bit weird: tnode_child_length(tn)
--	 * - tn->empty_children is of course the number of non-null children
--	 * in the current node. tn->full_children is the number of "full"
--	 * children, that is non-null tnodes with a skip value of 0.
--	 * All of those will be doubled in the resulting inflated tnode, so
--	 * we just count them one extra time here.
--	 *
--	 * A clearer way to write this would be:
--	 *
--	 * to_be_doubled = tn->full_children;
--	 * not_to_be_doubled = tnode_child_length(tn) - tn->empty_children -
--	 *     tn->full_children;
--	 *
--	 * new_child_length = tnode_child_length(tn) * 2;
--	 *
--	 * new_fill_factor = 100 * (not_to_be_doubled + 2*to_be_doubled) /
--	 *      new_child_length;
--	 * if (new_fill_factor >= inflate_threshold)
--	 *
--	 * ...and so on, tho it would mess up the while () loop.
--	 *
--	 * anyway,
--	 * 100 * (not_to_be_doubled + 2*to_be_doubled) / new_child_length >=
--	 *      inflate_threshold
--	 *
--	 * avoid a division:
--	 * 100 * (not_to_be_doubled + 2*to_be_doubled) >=
--	 *      inflate_threshold * new_child_length
--	 *
--	 * expand not_to_be_doubled and to_be_doubled, and shorten:
--	 * 100 * (tnode_child_length(tn) - tn->empty_children +
--	 *    tn->full_children) >= inflate_threshold * new_child_length
--	 *
--	 * expand new_child_length:
--	 * 100 * (tnode_child_length(tn) - tn->empty_children +
--	 *    tn->full_children) >=
--	 *      inflate_threshold * tnode_child_length(tn) * 2
--	 *
--	 * shorten again:
--	 * 50 * (tn->full_children + tnode_child_length(tn) -
--	 *    tn->empty_children) >= inflate_threshold *
--	 *    tnode_child_length(tn)
--	 *
-+	/* Double as long as the resulting node has a number of
-+	 * nonempty nodes that are above the threshold.
- 	 */
--
--	/* Keep root node larger  */
--
--	if (!node_parent(tn)) {
--		inflate_threshold_use = inflate_threshold_root;
--		halve_threshold_use = halve_threshold_root;
--	} else {
--		inflate_threshold_use = inflate_threshold;
--		halve_threshold_use = halve_threshold;
--	}
--
- 	max_work = MAX_WORK;
--	while ((tn->full_children > 0 &&  max_work-- &&
--		50 * (tn->full_children + tnode_child_length(tn)
--		      - tn->empty_children)
--		>= inflate_threshold_use * tnode_child_length(tn))) {
--
-+	while (should_inflate(tn) && max_work--) {
- 		old_tn = tn;
- 		tn = inflate(t, tn);
- 
-@@ -764,16 +772,11 @@ static struct tnode *resize(struct trie
- 	if (max_work != MAX_WORK)
- 		return tn;
- 
--	/*
--	 * Halve as long as the number of empty children in this
-+	/* Halve as long as the number of empty children in this
- 	 * node is above threshold.
- 	 */
--
- 	max_work = MAX_WORK;
--	while (tn->bits > 1 &&  max_work-- &&
--	       100 * (tnode_child_length(tn) - tn->empty_children) <
--	       halve_threshold_use * tnode_child_length(tn)) {
--
-+	while (should_halve(tn) && max_work--) {
- 		old_tn = tn;
- 		tn = halve(t, tn);
- 		if (IS_ERR(tn)) {
--- a/target/linux/generic/pending-3.18/080-14-fib_trie-Push-assignment-of-child-to-parent-down-int.patch	2022-03-22 08:54:47.270464774 +0800
+++ b/target/linux/generic/pending-3.18/080-14-fib_trie-Push-assignment-of-child-to-parent-down-int.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,336 +0,0 @@
-From: Alexander Duyck <alexander.h.duyck@redhat.com>
-Date: Wed, 31 Dec 2014 10:56:43 -0800
-Subject: [PATCH] fib_trie: Push assignment of child to parent down into
- inflate/halve
-
-This change makes it so that the assignment of the tnode to the parent is
-handled directly within whatever function is currently handling the node be
-it inflate, halve, or resize.  By doing this we can avoid some of the need
-to set NULL pointers in the tree while we are resizing the subnodes.
-
-Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -146,9 +146,7 @@ struct trie {
- #endif
- };
- 
--static void tnode_put_child_reorg(struct tnode *tn, unsigned long i,
--				  struct tnode *n, int wasfull);
--static struct tnode *resize(struct trie *t, struct tnode *tn);
-+static void resize(struct trie *t, struct tnode *tn);
- /* tnodes to free after resize(); protected by RTNL */
- static struct callback_head *tnode_free_head;
- static size_t tnode_free_size;
-@@ -396,22 +394,13 @@ static inline int tnode_full(const struc
- 	return n && ((n->pos + n->bits) == tn->pos) && IS_TNODE(n);
- }
- 
--static inline void put_child(struct tnode *tn, unsigned long i,
--			     struct tnode *n)
--{
--	tnode_put_child_reorg(tn, i, n, -1);
--}
--
-- /*
--  * Add a child at position i overwriting the old value.
--  * Update the value of full_children and empty_children.
--  */
--
--static void tnode_put_child_reorg(struct tnode *tn, unsigned long i,
--				  struct tnode *n, int wasfull)
-+/* Add a child at position i overwriting the old value.
-+ * Update the value of full_children and empty_children.
-+ */
-+static void put_child(struct tnode *tn, unsigned long i, struct tnode *n)
- {
- 	struct tnode *chi = rtnl_dereference(tn->child[i]);
--	int isfull;
-+	int isfull, wasfull;
- 
- 	BUG_ON(i >= tnode_child_length(tn));
- 
-@@ -422,10 +411,9 @@ static void tnode_put_child_reorg(struct
- 		tn->empty_children--;
- 
- 	/* update fullChildren */
--	if (wasfull == -1)
--		wasfull = tnode_full(tn, chi);
--
-+	wasfull = tnode_full(tn, chi);
- 	isfull = tnode_full(tn, n);
-+
- 	if (wasfull && !isfull)
- 		tn->full_children--;
- 	else if (!wasfull && isfull)
-@@ -458,9 +446,10 @@ static void tnode_clean_free(struct tnod
- 	node_free(tn);
- }
- 
--static struct tnode *inflate(struct trie *t, struct tnode *oldtnode)
-+static int inflate(struct trie *t, struct tnode *oldtnode)
- {
- 	unsigned long olen = tnode_child_length(oldtnode);
-+	struct tnode *tp = node_parent(oldtnode);
- 	struct tnode *tn;
- 	unsigned long i;
- 	t_key m;
-@@ -468,9 +457,8 @@ static struct tnode *inflate(struct trie
- 	pr_debug("In inflate\n");
- 
- 	tn = tnode_new(oldtnode->key, oldtnode->pos - 1, oldtnode->bits + 1);
--
- 	if (!tn)
--		return ERR_PTR(-ENOMEM);
-+		return -ENOMEM;
- 
- 	/*
- 	 * Preallocate and store tnodes before the actual work so we
-@@ -564,30 +552,36 @@ static struct tnode *inflate(struct trie
- 			put_child(left, j, rtnl_dereference(inode->child[j]));
- 			put_child(right, j, rtnl_dereference(inode->child[j + size]));
- 		}
--		put_child(tn, 2*i, resize(t, left));
--		put_child(tn, 2*i+1, resize(t, right));
-+
-+		put_child(tn, 2 * i, left);
-+		put_child(tn, 2 * i + 1, right);
- 
- 		tnode_free_safe(inode);
-+
-+		resize(t, left);
-+		resize(t, right);
- 	}
-+
-+	put_child_root(tp, t, tn->key, tn);
- 	tnode_free_safe(oldtnode);
--	return tn;
-+	return 0;
- nomem:
- 	tnode_clean_free(tn);
--	return ERR_PTR(-ENOMEM);
-+	return -ENOMEM;
- }
- 
--static struct tnode *halve(struct trie *t, struct tnode *oldtnode)
-+static int halve(struct trie *t, struct tnode *oldtnode)
- {
- 	unsigned long olen = tnode_child_length(oldtnode);
-+	struct tnode *tp = node_parent(oldtnode);
- 	struct tnode *tn, *left, *right;
- 	int i;
- 
- 	pr_debug("In halve\n");
- 
- 	tn = tnode_new(oldtnode->key, oldtnode->pos + 1, oldtnode->bits - 1);
--
- 	if (!tn)
--		return ERR_PTR(-ENOMEM);
-+		return -ENOMEM;
- 
- 	/*
- 	 * Preallocate and store tnodes before the actual work so we
-@@ -606,8 +600,10 @@ static struct tnode *halve(struct trie *
- 
- 			newn = tnode_new(left->key, oldtnode->pos, 1);
- 
--			if (!newn)
--				goto nomem;
-+			if (!newn) {
-+				tnode_clean_free(tn);
-+				return -ENOMEM;
-+			}
- 
- 			put_child(tn, i/2, newn);
- 		}
-@@ -635,16 +631,18 @@ static struct tnode *halve(struct trie *
- 
- 		/* Two nonempty children */
- 		newBinNode = tnode_get_child(tn, i/2);
--		put_child(tn, i/2, NULL);
- 		put_child(newBinNode, 0, left);
- 		put_child(newBinNode, 1, right);
--		put_child(tn, i/2, resize(t, newBinNode));
-+
-+		put_child(tn, i / 2, newBinNode);
-+
-+		resize(t, newBinNode);
- 	}
-+
-+	put_child_root(tp, t, tn->key, tn);
- 	tnode_free_safe(oldtnode);
--	return tn;
--nomem:
--	tnode_clean_free(tn);
--	return ERR_PTR(-ENOMEM);
-+
-+	return 0;
- }
- 
- /* From "Implementing a dynamic compressed trie" by Stefan Nilsson of
-@@ -704,45 +702,48 @@ nomem:
-  *    tnode_child_length(tn)
-  *
-  */
--static bool should_inflate(const struct tnode *tn)
-+static bool should_inflate(const struct tnode *tp, const struct tnode *tn)
- {
- 	unsigned long used = tnode_child_length(tn);
- 	unsigned long threshold = used;
- 
- 	/* Keep root node larger */
--	threshold *= node_parent(tn) ? inflate_threshold :
--				       inflate_threshold_root;
-+	threshold *= tp ? inflate_threshold : inflate_threshold_root;
- 	used += tn->full_children;
- 	used -= tn->empty_children;
- 
- 	return tn->pos && ((50 * used) >= threshold);
- }
- 
--static bool should_halve(const struct tnode *tn)
-+static bool should_halve(const struct tnode *tp, const struct tnode *tn)
- {
- 	unsigned long used = tnode_child_length(tn);
- 	unsigned long threshold = used;
- 
- 	/* Keep root node larger */
--	threshold *= node_parent(tn) ? halve_threshold :
--				       halve_threshold_root;
-+	threshold *= tp ? halve_threshold : halve_threshold_root;
- 	used -= tn->empty_children;
- 
- 	return (tn->bits > 1) && ((100 * used) < threshold);
- }
- 
- #define MAX_WORK 10
--static struct tnode *resize(struct trie *t, struct tnode *tn)
-+static void resize(struct trie *t, struct tnode *tn)
- {
--	struct tnode *old_tn, *n = NULL;
-+	struct tnode *tp = node_parent(tn), *n = NULL;
-+	struct tnode __rcu **cptr;
- 	int max_work;
- 
--	if (!tn)
--		return NULL;
--
- 	pr_debug("In tnode_resize %p inflate_threshold=%d threshold=%d\n",
- 		 tn, inflate_threshold, halve_threshold);
- 
-+	/* track the tnode via the pointer from the parent instead of
-+	 * doing it ourselves.  This way we can let RCU fully do its
-+	 * thing without us interfering
-+	 */
-+	cptr = tp ? &tp->child[get_index(tn->key, tp)] : &t->trie;
-+	BUG_ON(tn != rtnl_dereference(*cptr));
-+
- 	/* No children */
- 	if (tn->empty_children > (tnode_child_length(tn) - 1))
- 		goto no_children;
-@@ -755,39 +756,35 @@ static struct tnode *resize(struct trie
- 	 * nonempty nodes that are above the threshold.
- 	 */
- 	max_work = MAX_WORK;
--	while (should_inflate(tn) && max_work--) {
--		old_tn = tn;
--		tn = inflate(t, tn);
--
--		if (IS_ERR(tn)) {
--			tn = old_tn;
-+	while (should_inflate(tp, tn) && max_work--) {
-+		if (inflate(t, tn)) {
- #ifdef CONFIG_IP_FIB_TRIE_STATS
- 			this_cpu_inc(t->stats->resize_node_skipped);
- #endif
- 			break;
- 		}
-+
-+		tn = rtnl_dereference(*cptr);
- 	}
- 
- 	/* Return if at least one inflate is run */
- 	if (max_work != MAX_WORK)
--		return tn;
-+		return;
- 
- 	/* Halve as long as the number of empty children in this
- 	 * node is above threshold.
- 	 */
- 	max_work = MAX_WORK;
--	while (should_halve(tn) && max_work--) {
--		old_tn = tn;
--		tn = halve(t, tn);
--		if (IS_ERR(tn)) {
--			tn = old_tn;
-+	while (should_halve(tp, tn) && max_work--) {
-+		if (halve(t, tn)) {
- #ifdef CONFIG_IP_FIB_TRIE_STATS
- 			this_cpu_inc(t->stats->resize_node_skipped);
- #endif
- 			break;
- 		}
--	}
- 
-+		tn = rtnl_dereference(*cptr);
-+	}
- 
- 	/* Only one child remains */
- 	if (tn->empty_children == (tnode_child_length(tn) - 1)) {
-@@ -797,11 +794,12 @@ one_child:
- 			n = tnode_get_child(tn, --i);
- no_children:
- 		/* compress one level */
--		node_set_parent(n, NULL);
-+		put_child_root(tp, t, tn->key, n);
-+		node_set_parent(n, tp);
-+
-+		/* drop dead node */
- 		tnode_free_safe(tn);
--		return n;
- 	}
--	return tn;
- }
- 
- /* readside must use rcu_read_lock currently dump routines
-@@ -882,34 +880,19 @@ static struct tnode *fib_find_node(struc
- 
- static void trie_rebalance(struct trie *t, struct tnode *tn)
- {
--	int wasfull;
--	t_key cindex, key;
- 	struct tnode *tp;
- 
--	key = tn->key;
--
--	while (tn != NULL && (tp = node_parent(tn)) != NULL) {
--		cindex = get_index(key, tp);
--		wasfull = tnode_full(tp, tnode_get_child(tp, cindex));
--		tn = resize(t, tn);
--
--		tnode_put_child_reorg(tp, cindex, tn, wasfull);
--
--		tp = node_parent(tn);
--		if (!tp)
--			rcu_assign_pointer(t->trie, tn);
-+	while ((tp = node_parent(tn)) != NULL) {
-+		resize(t, tn);
- 
- 		tnode_free_flush();
--		if (!tp)
--			break;
- 		tn = tp;
- 	}
- 
- 	/* Handle last (top) tnode */
- 	if (IS_TNODE(tn))
--		tn = resize(t, tn);
-+		resize(t, tn);
- 
--	rcu_assign_pointer(t->trie, tn);
- 	tnode_free_flush();
- }
- 
--- a/target/linux/generic/pending-3.18/080-15-fib_trie-Push-tnode-flushing-down-to-inflate-halve.patch	2022-03-22 08:54:47.271464776 +0800
+++ b/target/linux/generic/pending-3.18/080-15-fib_trie-Push-tnode-flushing-down-to-inflate-halve.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,237 +0,0 @@
-From: Alexander Duyck <alexander.h.duyck@redhat.com>
-Date: Wed, 31 Dec 2014 10:56:49 -0800
-Subject: [PATCH] fib_trie: Push tnode flushing down to inflate/halve
-
-This change pushes the tnode freeing down into the inflate and halve
-functions.  It makes more sense here as we have a better grasp of what is
-going on and when a given cluster of nodes is ready to be freed.
-
-I believe this may address a bug in the freeing logic as well.  For some
-reason if the freelist got to a certain size we would call
-synchronize_rcu().  I'm assuming that what they meant to do is call
-synchronize_rcu() after they had handed off that much memory via
-call_rcu().  As such that is what I have updated the behavior to be.
-
-Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -147,8 +147,6 @@ struct trie {
- };
- 
- static void resize(struct trie *t, struct tnode *tn);
--/* tnodes to free after resize(); protected by RTNL */
--static struct callback_head *tnode_free_head;
- static size_t tnode_free_size;
- 
- /*
-@@ -307,32 +305,6 @@ static struct tnode *tnode_alloc(size_t
- 		return vzalloc(size);
- }
- 
--static void tnode_free_safe(struct tnode *tn)
--{
--	BUG_ON(IS_LEAF(tn));
--	tn->rcu.next = tnode_free_head;
--	tnode_free_head = &tn->rcu;
--}
--
--static void tnode_free_flush(void)
--{
--	struct callback_head *head;
--
--	while ((head = tnode_free_head)) {
--		struct tnode *tn = container_of(head, struct tnode, rcu);
--
--		tnode_free_head = head->next;
--		tnode_free_size += offsetof(struct tnode, child[1 << tn->bits]);
--
--		node_free(tn);
--	}
--
--	if (tnode_free_size >= PAGE_SIZE * sync_pages) {
--		tnode_free_size = 0;
--		synchronize_rcu();
--	}
--}
--
- static struct tnode *leaf_new(t_key key)
- {
- 	struct tnode *l = kmem_cache_alloc(trie_leaf_kmem, GFP_KERNEL);
-@@ -433,17 +405,33 @@ static void put_child_root(struct tnode
- 		rcu_assign_pointer(t->trie, n);
- }
- 
--static void tnode_clean_free(struct tnode *tn)
-+static inline void tnode_free_init(struct tnode *tn)
- {
--	struct tnode *tofree;
--	unsigned long i;
-+	tn->rcu.next = NULL;
-+}
-+
-+static inline void tnode_free_append(struct tnode *tn, struct tnode *n)
-+{
-+	n->rcu.next = tn->rcu.next;
-+	tn->rcu.next = &n->rcu;
-+}
- 
--	for (i = 0; i < tnode_child_length(tn); i++) {
--		tofree = tnode_get_child(tn, i);
--		if (tofree)
--			node_free(tofree);
-+static void tnode_free(struct tnode *tn)
-+{
-+	struct callback_head *head = &tn->rcu;
-+
-+	while (head) {
-+		head = head->next;
-+		tnode_free_size += offsetof(struct tnode, child[1 << tn->bits]);
-+		node_free(tn);
-+
-+		tn = container_of(head, struct tnode, rcu);
-+	}
-+
-+	if (tnode_free_size >= PAGE_SIZE * sync_pages) {
-+		tnode_free_size = 0;
-+		synchronize_rcu();
- 	}
--	node_free(tn);
- }
- 
- static int inflate(struct trie *t, struct tnode *oldtnode)
-@@ -476,20 +464,23 @@ static int inflate(struct trie *t, struc
- 					 inode->bits - 1);
- 			if (!left)
- 				goto nomem;
-+			tnode_free_append(tn, left);
- 
- 			right = tnode_new(inode->key | m, inode->pos,
- 					  inode->bits - 1);
- 
--			if (!right) {
--				node_free(left);
-+			if (!right)
- 				goto nomem;
--			}
-+			tnode_free_append(tn, right);
- 
- 			put_child(tn, 2*i, left);
- 			put_child(tn, 2*i+1, right);
- 		}
- 	}
- 
-+	/* prepare oldtnode to be freed */
-+	tnode_free_init(oldtnode);
-+
- 	for (i = 0; i < olen; i++) {
- 		struct tnode *inode = tnode_get_child(oldtnode, i);
- 		struct tnode *left, *right;
-@@ -505,12 +496,13 @@ static int inflate(struct trie *t, struc
- 			continue;
- 		}
- 
-+		/* drop the node in the old tnode free list */
-+		tnode_free_append(oldtnode, inode);
-+
- 		/* An internal node with two children */
- 		if (inode->bits == 1) {
- 			put_child(tn, 2*i, rtnl_dereference(inode->child[0]));
- 			put_child(tn, 2*i+1, rtnl_dereference(inode->child[1]));
--
--			tnode_free_safe(inode);
- 			continue;
- 		}
- 
-@@ -556,17 +548,19 @@ static int inflate(struct trie *t, struc
- 		put_child(tn, 2 * i, left);
- 		put_child(tn, 2 * i + 1, right);
- 
--		tnode_free_safe(inode);
--
-+		/* resize child nodes */
- 		resize(t, left);
- 		resize(t, right);
- 	}
- 
- 	put_child_root(tp, t, tn->key, tn);
--	tnode_free_safe(oldtnode);
-+
-+	/* we completed without error, prepare to free old node */
-+	tnode_free(oldtnode);
- 	return 0;
- nomem:
--	tnode_clean_free(tn);
-+	/* all pointers should be clean so we are done */
-+	tnode_free(tn);
- 	return -ENOMEM;
- }
- 
-@@ -599,17 +593,20 @@ static int halve(struct trie *t, struct
- 			struct tnode *newn;
- 
- 			newn = tnode_new(left->key, oldtnode->pos, 1);
--
- 			if (!newn) {
--				tnode_clean_free(tn);
-+				tnode_free(tn);
- 				return -ENOMEM;
- 			}
-+			tnode_free_append(tn, newn);
- 
- 			put_child(tn, i/2, newn);
- 		}
- 
- 	}
- 
-+	/* prepare oldtnode to be freed */
-+	tnode_free_init(oldtnode);
-+
- 	for (i = 0; i < olen; i += 2) {
- 		struct tnode *newBinNode;
- 
-@@ -636,11 +633,14 @@ static int halve(struct trie *t, struct
- 
- 		put_child(tn, i / 2, newBinNode);
- 
-+		/* resize child node */
- 		resize(t, newBinNode);
- 	}
- 
- 	put_child_root(tp, t, tn->key, tn);
--	tnode_free_safe(oldtnode);
-+
-+	/* all pointers should be clean so we are done */
-+	tnode_free(oldtnode);
- 
- 	return 0;
- }
-@@ -798,7 +798,8 @@ no_children:
- 		node_set_parent(n, tp);
- 
- 		/* drop dead node */
--		tnode_free_safe(tn);
-+		tnode_free_init(tn);
-+		tnode_free(tn);
- 	}
- }
- 
-@@ -884,16 +885,12 @@ static void trie_rebalance(struct trie *
- 
- 	while ((tp = node_parent(tn)) != NULL) {
- 		resize(t, tn);
--
--		tnode_free_flush();
- 		tn = tp;
- 	}
- 
- 	/* Handle last (top) tnode */
- 	if (IS_TNODE(tn))
- 		resize(t, tn);
--
--	tnode_free_flush();
- }
- 
- /* only used from updater-side */
--- a/target/linux/generic/pending-3.18/080-16-fib_trie-inflate-halve-nodes-in-a-more-RCU-friendly-.patch	2022-03-22 08:54:47.271464776 +0800
+++ b/target/linux/generic/pending-3.18/080-16-fib_trie-inflate-halve-nodes-in-a-more-RCU-friendly-.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,345 +0,0 @@
-From: Alexander Duyck <alexander.h.duyck@redhat.com>
-Date: Wed, 31 Dec 2014 10:56:55 -0800
-Subject: [PATCH] fib_trie: inflate/halve nodes in a more RCU friendly
- way
-
-This change pulls the node_set_parent functionality out of put_child_reorg
-and instead leaves that to the function to take care of as well.  By doing
-this we can fully construct the new cluster of tnodes and all of the
-pointers out of it before we start routing pointers into it.
-
-I am suspecting this will likely fix some concurency issues though I don't
-have a good test to show as such.
-
-Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -391,8 +391,6 @@ static void put_child(struct tnode *tn,
- 	else if (!wasfull && isfull)
- 		tn->full_children++;
- 
--	node_set_parent(n, tn);
--
- 	rcu_assign_pointer(tn->child[i], n);
- }
- 
-@@ -436,10 +434,8 @@ static void tnode_free(struct tnode *tn)
- 
- static int inflate(struct trie *t, struct tnode *oldtnode)
- {
--	unsigned long olen = tnode_child_length(oldtnode);
--	struct tnode *tp = node_parent(oldtnode);
--	struct tnode *tn;
--	unsigned long i;
-+	struct tnode *inode, *node0, *node1, *tn, *tp;
-+	unsigned long i, j, k;
- 	t_key m;
- 
- 	pr_debug("In inflate\n");
-@@ -448,43 +444,13 @@ static int inflate(struct trie *t, struc
- 	if (!tn)
- 		return -ENOMEM;
- 
--	/*
--	 * Preallocate and store tnodes before the actual work so we
--	 * don't get into an inconsistent state if memory allocation
--	 * fails. In case of failure we return the oldnode and  inflate
--	 * of tnode is ignored.
-+	/* Assemble all of the pointers in our cluster, in this case that
-+	 * represents all of the pointers out of our allocated nodes that
-+	 * point to existing tnodes and the links between our allocated
-+	 * nodes.
- 	 */
--	for (i = 0, m = 1u << tn->pos; i < olen; i++) {
--		struct tnode *inode = tnode_get_child(oldtnode, i);
--
--		if (tnode_full(oldtnode, inode) && (inode->bits > 1)) {
--			struct tnode *left, *right;
--
--			left = tnode_new(inode->key & ~m, inode->pos,
--					 inode->bits - 1);
--			if (!left)
--				goto nomem;
--			tnode_free_append(tn, left);
--
--			right = tnode_new(inode->key | m, inode->pos,
--					  inode->bits - 1);
--
--			if (!right)
--				goto nomem;
--			tnode_free_append(tn, right);
--
--			put_child(tn, 2*i, left);
--			put_child(tn, 2*i+1, right);
--		}
--	}
--
--	/* prepare oldtnode to be freed */
--	tnode_free_init(oldtnode);
--
--	for (i = 0; i < olen; i++) {
--		struct tnode *inode = tnode_get_child(oldtnode, i);
--		struct tnode *left, *right;
--		unsigned long size, j;
-+	for (i = tnode_child_length(oldtnode), m = 1u << tn->pos; i;) {
-+		inode = tnode_get_child(oldtnode, --i);
- 
- 		/* An empty child */
- 		if (inode == NULL)
-@@ -496,65 +462,99 @@ static int inflate(struct trie *t, struc
- 			continue;
- 		}
- 
--		/* drop the node in the old tnode free list */
--		tnode_free_append(oldtnode, inode);
--
- 		/* An internal node with two children */
- 		if (inode->bits == 1) {
--			put_child(tn, 2*i, rtnl_dereference(inode->child[0]));
--			put_child(tn, 2*i+1, rtnl_dereference(inode->child[1]));
-+			put_child(tn, 2 * i + 1, tnode_get_child(inode, 1));
-+			put_child(tn, 2 * i, tnode_get_child(inode, 0));
- 			continue;
- 		}
- 
--		/* An internal node with more than two children */
--
- 		/* We will replace this node 'inode' with two new
--		 * ones, 'left' and 'right', each with half of the
-+		 * ones, 'node0' and 'node1', each with half of the
- 		 * original children. The two new nodes will have
- 		 * a position one bit further down the key and this
- 		 * means that the "significant" part of their keys
- 		 * (see the discussion near the top of this file)
- 		 * will differ by one bit, which will be "0" in
--		 * left's key and "1" in right's key. Since we are
-+		 * node0's key and "1" in node1's key. Since we are
- 		 * moving the key position by one step, the bit that
- 		 * we are moving away from - the bit at position
--		 * (inode->pos) - is the one that will differ between
--		 * left and right. So... we synthesize that bit in the
--		 * two  new keys.
--		 * The mask 'm' below will be a single "one" bit at
--		 * the position (inode->pos)
-+		 * (tn->pos) - is the one that will differ between
-+		 * node0 and node1. So... we synthesize that bit in the
-+		 * two new keys.
- 		 */
-+		node1 = tnode_new(inode->key | m, inode->pos, inode->bits - 1);
-+		if (!node1)
-+			goto nomem;
-+		tnode_free_append(tn, node1);
-+
-+		node0 = tnode_new(inode->key & ~m, inode->pos, inode->bits - 1);
-+		if (!node0)
-+			goto nomem;
-+		tnode_free_append(tn, node0);
-+
-+		/* populate child pointers in new nodes */
-+		for (k = tnode_child_length(inode), j = k / 2; j;) {
-+			put_child(node1, --j, tnode_get_child(inode, --k));
-+			put_child(node0, j, tnode_get_child(inode, j));
-+			put_child(node1, --j, tnode_get_child(inode, --k));
-+			put_child(node0, j, tnode_get_child(inode, j));
-+		}
-+
-+		/* link new nodes to parent */
-+		NODE_INIT_PARENT(node1, tn);
-+		NODE_INIT_PARENT(node0, tn);
-+
-+		/* link parent to nodes */
-+		put_child(tn, 2 * i + 1, node1);
-+		put_child(tn, 2 * i, node0);
-+	}
-+
-+	/* setup the parent pointer into and out of this node */
-+	tp = node_parent(oldtnode);
-+	NODE_INIT_PARENT(tn, tp);
-+	put_child_root(tp, t, tn->key, tn);
- 
--		/* Use the old key, but set the new significant
--		 *   bit to zero.
--		 */
-+	/* prepare oldtnode to be freed */
-+	tnode_free_init(oldtnode);
- 
--		left = tnode_get_child(tn, 2*i);
--		put_child(tn, 2*i, NULL);
-+	/* update all child nodes parent pointers to route to us */
-+	for (i = tnode_child_length(oldtnode); i;) {
-+		inode = tnode_get_child(oldtnode, --i);
- 
--		BUG_ON(!left);
-+		/* A leaf or an internal node with skipped bits */
-+		if (!tnode_full(oldtnode, inode)) {
-+			node_set_parent(inode, tn);
-+			continue;
-+		}
- 
--		right = tnode_get_child(tn, 2*i+1);
--		put_child(tn, 2*i+1, NULL);
-+		/* drop the node in the old tnode free list */
-+		tnode_free_append(oldtnode, inode);
- 
--		BUG_ON(!right);
-+		/* fetch new nodes */
-+		node1 = tnode_get_child(tn, 2 * i + 1);
-+		node0 = tnode_get_child(tn, 2 * i);
- 
--		size = tnode_child_length(left);
--		for (j = 0; j < size; j++) {
--			put_child(left, j, rtnl_dereference(inode->child[j]));
--			put_child(right, j, rtnl_dereference(inode->child[j + size]));
-+		/* bits == 1 then node0 and node1 represent inode's children */
-+		if (inode->bits == 1) {
-+			node_set_parent(node1, tn);
-+			node_set_parent(node0, tn);
-+			continue;
- 		}
- 
--		put_child(tn, 2 * i, left);
--		put_child(tn, 2 * i + 1, right);
-+		/* update parent pointers in child node's children */
-+		for (k = tnode_child_length(inode), j = k / 2; j;) {
-+			node_set_parent(tnode_get_child(inode, --k), node1);
-+			node_set_parent(tnode_get_child(inode, --j), node0);
-+			node_set_parent(tnode_get_child(inode, --k), node1);
-+			node_set_parent(tnode_get_child(inode, --j), node0);
-+		}
- 
- 		/* resize child nodes */
--		resize(t, left);
--		resize(t, right);
-+		resize(t, node1);
-+		resize(t, node0);
- 	}
- 
--	put_child_root(tp, t, tn->key, tn);
--
- 	/* we completed without error, prepare to free old node */
- 	tnode_free(oldtnode);
- 	return 0;
-@@ -566,10 +566,8 @@ nomem:
- 
- static int halve(struct trie *t, struct tnode *oldtnode)
- {
--	unsigned long olen = tnode_child_length(oldtnode);
--	struct tnode *tp = node_parent(oldtnode);
--	struct tnode *tn, *left, *right;
--	int i;
-+	struct tnode *tn, *tp, *inode, *node0, *node1;
-+	unsigned long i;
- 
- 	pr_debug("In halve\n");
- 
-@@ -577,68 +575,64 @@ static int halve(struct trie *t, struct
- 	if (!tn)
- 		return -ENOMEM;
- 
--	/*
--	 * Preallocate and store tnodes before the actual work so we
--	 * don't get into an inconsistent state if memory allocation
--	 * fails. In case of failure we return the oldnode and halve
--	 * of tnode is ignored.
-+	/* Assemble all of the pointers in our cluster, in this case that
-+	 * represents all of the pointers out of our allocated nodes that
-+	 * point to existing tnodes and the links between our allocated
-+	 * nodes.
- 	 */
-+	for (i = tnode_child_length(oldtnode); i;) {
-+		node1 = tnode_get_child(oldtnode, --i);
-+		node0 = tnode_get_child(oldtnode, --i);
- 
--	for (i = 0; i < olen; i += 2) {
--		left = tnode_get_child(oldtnode, i);
--		right = tnode_get_child(oldtnode, i+1);
-+		/* At least one of the children is empty */
-+		if (!node1 || !node0) {
-+			put_child(tn, i / 2, node1 ? : node0);
-+			continue;
-+		}
- 
- 		/* Two nonempty children */
--		if (left && right) {
--			struct tnode *newn;
--
--			newn = tnode_new(left->key, oldtnode->pos, 1);
--			if (!newn) {
--				tnode_free(tn);
--				return -ENOMEM;
--			}
--			tnode_free_append(tn, newn);
--
--			put_child(tn, i/2, newn);
-+		inode = tnode_new(node0->key, oldtnode->pos, 1);
-+		if (!inode) {
-+			tnode_free(tn);
-+			return -ENOMEM;
- 		}
-+		tnode_free_append(tn, inode);
- 
-+		/* initialize pointers out of node */
-+		put_child(inode, 1, node1);
-+		put_child(inode, 0, node0);
-+		NODE_INIT_PARENT(inode, tn);
-+
-+		/* link parent to node */
-+		put_child(tn, i / 2, inode);
- 	}
- 
-+	/* setup the parent pointer out of and back into this node */
-+	tp = node_parent(oldtnode);
-+	NODE_INIT_PARENT(tn, tp);
-+	put_child_root(tp, t, tn->key, tn);
-+
- 	/* prepare oldtnode to be freed */
- 	tnode_free_init(oldtnode);
- 
--	for (i = 0; i < olen; i += 2) {
--		struct tnode *newBinNode;
--
--		left = tnode_get_child(oldtnode, i);
--		right = tnode_get_child(oldtnode, i+1);
--
--		/* At least one of the children is empty */
--		if (left == NULL) {
--			if (right == NULL)    /* Both are empty */
--				continue;
--			put_child(tn, i/2, right);
--			continue;
--		}
--
--		if (right == NULL) {
--			put_child(tn, i/2, left);
-+	/* update all of the child parent pointers */
-+	for (i = tnode_child_length(tn); i;) {
-+		inode = tnode_get_child(tn, --i);
-+
-+		/* only new tnodes will be considered "full" nodes */
-+		if (!tnode_full(tn, inode)) {
-+			node_set_parent(inode, tn);
- 			continue;
- 		}
- 
- 		/* Two nonempty children */
--		newBinNode = tnode_get_child(tn, i/2);
--		put_child(newBinNode, 0, left);
--		put_child(newBinNode, 1, right);
--
--		put_child(tn, i / 2, newBinNode);
-+		node_set_parent(tnode_get_child(inode, 1), inode);
-+		node_set_parent(tnode_get_child(inode, 0), inode);
- 
- 		/* resize child node */
--		resize(t, newBinNode);
-+		resize(t, inode);
- 	}
- 
--	put_child_root(tp, t, tn->key, tn);
--
- 	/* all pointers should be clean so we are done */
- 	tnode_free(oldtnode);
- 
--- a/target/linux/generic/pending-3.18/080-17-fib_trie-Remove-checks-for-index-tnode_child_length-.patch	2022-03-22 08:54:47.272464778 +0800
+++ b/target/linux/generic/pending-3.18/080-17-fib_trie-Remove-checks-for-index-tnode_child_length-.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,95 +0,0 @@
-From: Alexander Duyck <alexander.h.duyck@redhat.com>
-Date: Wed, 31 Dec 2014 10:57:02 -0800
-Subject: [PATCH] fib_trie: Remove checks for index >= tnode_child_length
- from tnode_get_child
-
-For some reason the compiler doesn't seem to understand that when we are in
-a loop that runs from tnode_child_length - 1 to 0 we don't expect the value
-of tn->bits to change.  As such every call to tnode_get_child was rerunning
-tnode_chile_length which ended up consuming quite a bit of space in the
-resultant assembly code.
-
-I have gone though and verified that in all cases where tnode_get_child
-is used we are either winding though a fixed loop from tnode_child_length -
-1 to 0, or are in a fastpath case where we are verifying the value by
-either checking for any remaining bits after shifting index by bits and
-testing for leaf, or by using tnode_child_length.
-
-size net/ipv4/fib_trie.o
-Before:
-   text	   data	    bss	    dec	    hex	filename
-  15506	    376	      8	  15890	   3e12	net/ipv4/fib_trie.o
-
-After:
-   text	   data	    bss	    dec	    hex	filename
-  14827	    376	      8	  15211	   3b6b	net/ipv4/fib_trie.o
-
-Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -186,8 +186,6 @@ static inline unsigned long tnode_child_
- static inline struct tnode *tnode_get_child(const struct tnode *tn,
- 					    unsigned long i)
- {
--	BUG_ON(i >= tnode_child_length(tn));
--
- 	return rtnl_dereference(tn->child[i]);
- }
- 
-@@ -195,8 +193,6 @@ static inline struct tnode *tnode_get_ch
- static inline struct tnode *tnode_get_child_rcu(const struct tnode *tn,
- 						unsigned long i)
- {
--	BUG_ON(i >= tnode_child_length(tn));
--
- 	return rcu_dereference_rtnl(tn->child[i]);
- }
- 
-@@ -371,7 +367,7 @@ static inline int tnode_full(const struc
-  */
- static void put_child(struct tnode *tn, unsigned long i, struct tnode *n)
- {
--	struct tnode *chi = rtnl_dereference(tn->child[i]);
-+	struct tnode *chi = tnode_get_child(tn, i);
- 	int isfull, wasfull;
- 
- 	BUG_ON(i >= tnode_child_length(tn));
-@@ -867,7 +863,7 @@ static struct tnode *fib_find_node(struc
- 		if (IS_LEAF(n))
- 			break;
- 
--		n = rcu_dereference_rtnl(n->child[index]);
-+		n = tnode_get_child_rcu(n, index);
- 	}
- 
- 	return n;
-@@ -934,7 +930,7 @@ static struct list_head *fib_insert_node
- 		}
- 
- 		tp = n;
--		n = rcu_dereference_rtnl(n->child[index]);
-+		n = tnode_get_child_rcu(n, index);
- 	}
- 
- 	l = leaf_new(key);
-@@ -1215,7 +1211,7 @@ int fib_table_lookup(struct fib_table *t
- 			cindex = index;
- 		}
- 
--		n = rcu_dereference(n->child[index]);
-+		n = tnode_get_child_rcu(n, index);
- 		if (unlikely(!n))
- 			goto backtrace;
- 	}
-@@ -1835,7 +1831,7 @@ static void trie_collect_stats(struct tr
- 			if (n->bits < MAX_STAT_DEPTH)
- 				s->nodesizes[n->bits]++;
- 
--			for (i = 0; i < tnode_child_length(n); i++) {
-+			for (i = tnode_child_length(n); i--;) {
- 				if (!rcu_access_pointer(n->child[i]))
- 					s->nullpointers++;
- 			}
--- a/target/linux/generic/pending-3.18/080-18-fib_trie-Add-tracking-value-for-suffix-length.patch	2022-03-22 08:54:47.272464778 +0800
+++ b/target/linux/generic/pending-3.18/080-18-fib_trie-Add-tracking-value-for-suffix-length.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,234 +0,0 @@
-From: Alexander Duyck <alexander.h.duyck@redhat.com>
-Date: Wed, 31 Dec 2014 10:57:08 -0800
-Subject: [PATCH] fib_trie: Add tracking value for suffix length
-
-This change adds a tracking value for the maximum suffix length of all
-prefixes stored in any given tnode.  With this value we can determine if we
-need to backtrace or not based on if the suffix is greater than the pos
-value.
-
-By doing this we can reduce the CPU overhead for lookups in the local table
-as many of the prefixes there are 32b long and have a suffix length of 0
-meaning we can immediately backtrace to the root node without needing to
-test any of the nodes between it and where we ended up.
-
-Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -96,6 +96,7 @@ struct tnode {
- 	t_key key;
- 	unsigned char bits;		/* 2log(KEYLENGTH) bits needed */
- 	unsigned char pos;		/* 2log(KEYLENGTH) bits needed */
-+	unsigned char slen;
- 	struct tnode __rcu *parent;
- 	struct rcu_head rcu;
- 	union {
-@@ -311,6 +312,7 @@ static struct tnode *leaf_new(t_key key)
- 		 * as the nodes are searched
- 		 */
- 		l->key = key;
-+		l->slen = 0;
- 		l->pos = 0;
- 		/* set bits to 0 indicating we are not a tnode */
- 		l->bits = 0;
-@@ -342,6 +344,7 @@ static struct tnode *tnode_new(t_key key
- 
- 	if (tn) {
- 		tn->parent = NULL;
-+		tn->slen = pos;
- 		tn->pos = pos;
- 		tn->bits = bits;
- 		tn->key = (shift < KEYLENGTH) ? (key >> shift) << shift : 0;
-@@ -387,6 +390,9 @@ static void put_child(struct tnode *tn,
- 	else if (!wasfull && isfull)
- 		tn->full_children++;
- 
-+	if (n && (tn->slen < n->slen))
-+		tn->slen = n->slen;
-+
- 	rcu_assign_pointer(tn->child[i], n);
- }
- 
-@@ -635,6 +641,41 @@ static int halve(struct trie *t, struct
- 	return 0;
- }
- 
-+static unsigned char update_suffix(struct tnode *tn)
-+{
-+	unsigned char slen = tn->pos;
-+	unsigned long stride, i;
-+
-+	/* search though the list of children looking for nodes that might
-+	 * have a suffix greater than the one we currently have.  This is
-+	 * why we start with a stride of 2 since a stride of 1 would
-+	 * represent the nodes with suffix length equal to tn->pos
-+	 */
-+	for (i = 0, stride = 0x2ul ; i < tnode_child_length(tn); i += stride) {
-+		struct tnode *n = tnode_get_child(tn, i);
-+
-+		if (!n || (n->slen <= slen))
-+			continue;
-+
-+		/* update stride and slen based on new value */
-+		stride <<= (n->slen - slen);
-+		slen = n->slen;
-+		i &= ~(stride - 1);
-+
-+		/* if slen covers all but the last bit we can stop here
-+		 * there will be nothing longer than that since only node
-+		 * 0 and 1 << (bits - 1) could have that as their suffix
-+		 * length.
-+		 */
-+		if ((slen + 1) >= (tn->pos + tn->bits))
-+			break;
-+	}
-+
-+	tn->slen = slen;
-+
-+	return slen;
-+}
-+
- /* From "Implementing a dynamic compressed trie" by Stefan Nilsson of
-  * the Helsinki University of Technology and Matti Tikkanen of Nokia
-  * Telecommunications, page 6:
-@@ -790,6 +831,19 @@ no_children:
- 		/* drop dead node */
- 		tnode_free_init(tn);
- 		tnode_free(tn);
-+		return;
-+	}
-+
-+	/* Return if at least one deflate was run */
-+	if (max_work != MAX_WORK)
-+		return;
-+
-+	/* push the suffix length to the parent node */
-+	if (tn->slen > tn->pos) {
-+		unsigned char slen = update_suffix(tn);
-+
-+		if (tp && (slen > tp->slen))
-+			tp->slen = slen;
- 	}
- }
- 
-@@ -818,8 +872,58 @@ static inline struct list_head *get_fa_h
- 	return &li->falh;
- }
- 
--static void insert_leaf_info(struct hlist_head *head, struct leaf_info *new)
-+static void leaf_pull_suffix(struct tnode *l)
-+{
-+	struct tnode *tp = node_parent(l);
-+
-+	while (tp && (tp->slen > tp->pos) && (tp->slen > l->slen)) {
-+		if (update_suffix(tp) > l->slen)
-+			break;
-+		tp = node_parent(tp);
-+	}
-+}
-+
-+static void leaf_push_suffix(struct tnode *l)
-+{
-+	struct tnode *tn = node_parent(l);
-+
-+	/* if this is a new leaf then tn will be NULL and we can sort
-+	 * out parent suffix lengths as a part of trie_rebalance
-+	 */
-+	while (tn && (tn->slen < l->slen)) {
-+		tn->slen = l->slen;
-+		tn = node_parent(tn);
-+	}
-+}
-+
-+static void remove_leaf_info(struct tnode *l, struct leaf_info *old)
-+{
-+	struct hlist_node *prev;
-+
-+	/* record the location of the pointer to this object */
-+	prev = rtnl_dereference(hlist_pprev_rcu(&old->hlist));
-+
-+	/* remove the leaf info from the list */
-+	hlist_del_rcu(&old->hlist);
-+
-+	/* if we emptied the list this leaf will be freed and we can sort
-+	 * out parent suffix lengths as a part of trie_rebalance
-+	 */
-+	if (hlist_empty(&l->list))
-+		return;
-+
-+	/* if we removed the tail then we need to update slen */
-+	if (!rcu_access_pointer(hlist_next_rcu(prev))) {
-+		struct leaf_info *li = hlist_entry(prev, typeof(*li), hlist);
-+
-+		l->slen = KEYLENGTH - li->plen;
-+		leaf_pull_suffix(l);
-+	}
-+}
-+
-+static void insert_leaf_info(struct tnode *l, struct leaf_info *new)
- {
-+	struct hlist_head *head = &l->list;
- 	struct leaf_info *li = NULL, *last = NULL;
- 
- 	if (hlist_empty(head)) {
-@@ -836,6 +940,12 @@ static void insert_leaf_info(struct hlis
- 		else
- 			hlist_add_before_rcu(&new->hlist, &li->hlist);
- 	}
-+
-+	/* if we added to the tail node then we need to update slen */
-+	if (!rcu_access_pointer(hlist_next_rcu(&new->hlist))) {
-+		l->slen = KEYLENGTH - new->plen;
-+		leaf_push_suffix(l);
-+	}
- }
- 
- /* rcu_read_lock needs to be hold by caller from readside */
-@@ -925,7 +1035,7 @@ static struct list_head *fib_insert_node
- 		/* we have found a leaf. Prefixes have already been compared */
- 		if (IS_LEAF(n)) {
- 			/* Case 1: n is a leaf, and prefixes match*/
--			insert_leaf_info(&n->list, li);
-+			insert_leaf_info(n, li);
- 			return fa_head;
- 		}
- 
-@@ -939,7 +1049,7 @@ static struct list_head *fib_insert_node
- 		return NULL;
- 	}
- 
--	insert_leaf_info(&l->list, li);
-+	insert_leaf_info(l, li);
- 
- 	/* Case 2: n is a LEAF or a TNODE and the key doesn't match.
- 	 *
-@@ -1206,7 +1316,7 @@ int fib_table_lookup(struct fib_table *t
- 		/* only record pn and cindex if we are going to be chopping
- 		 * bits later.  Otherwise we are just wasting cycles.
- 		 */
--		if (index) {
-+		if (n->slen > n->pos) {
- 			pn = n;
- 			cindex = index;
- 		}
-@@ -1225,7 +1335,7 @@ int fib_table_lookup(struct fib_table *t
- 		 * between the key and the prefix exist in the region of
- 		 * the lsb and higher in the prefix.
- 		 */
--		if (unlikely(prefix_mismatch(key, n)))
-+		if (unlikely(prefix_mismatch(key, n)) || (n->slen == n->pos))
- 			goto backtrace;
- 
- 		/* exit out and process leaf */
-@@ -1425,7 +1535,7 @@ int fib_table_delete(struct fib_table *t
- 		tb->tb_num_default--;
- 
- 	if (list_empty(fa_head)) {
--		hlist_del_rcu(&li->hlist);
-+		remove_leaf_info(l, li);
- 		free_leaf_info(li);
- 	}
- 
--- a/target/linux/generic/pending-3.18/080-19-fib_trie-Use-index-0ul-n-bits-instead-of-index-n-bit.patch	2022-03-22 08:54:47.273464779 +0800
+++ b/target/linux/generic/pending-3.18/080-19-fib_trie-Use-index-0ul-n-bits-instead-of-index-n-bit.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,52 +0,0 @@
-From: Alexander Duyck <alexander.h.duyck@redhat.com>
-Date: Thu, 22 Jan 2015 15:51:08 -0800
-Subject: [PATCH] fib_trie: Use index & (~0ul << n->bits) instead of index >>
- n->bits
-
-In doing performance testing and analysis of the changes I recently found
-that by shifting the index I had created an unnecessary dependency.
-
-I have updated the code so that we instead shift a mask by bits and then
-just test against that as that should save us about 2 CPU cycles since we
-can generate the mask while the key and pos are being processed.
-
-Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -961,12 +961,12 @@ static struct tnode *fib_find_node(struc
- 		 * prefix plus zeros for the bits in the cindex. The index
- 		 * is the difference between the key and this value.  From
- 		 * this we can actually derive several pieces of data.
--		 *   if !(index >> bits)
--		 *     we know the value is cindex
--		 *   else
-+		 *   if (index & (~0ul << bits))
- 		 *     we have a mismatch in skip bits and failed
-+		 *   else
-+		 *     we know the value is cindex
- 		 */
--		if (index >> n->bits)
-+		if (index & (~0ul << n->bits))
- 			return NULL;
- 
- 		/* we have found a leaf. Prefixes have already been compared */
-@@ -1301,12 +1301,12 @@ int fib_table_lookup(struct fib_table *t
- 		 * prefix plus zeros for the "bits" in the prefix. The index
- 		 * is the difference between the key and this value.  From
- 		 * this we can actually derive several pieces of data.
--		 *   if !(index >> bits)
--		 *     we know the value is child index
--		 *   else
-+		 *   if (index & (~0ul << bits))
- 		 *     we have a mismatch in skip bits and failed
-+		 *   else
-+		 *     we know the value is cindex
- 		 */
--		if (index >> n->bits)
-+		if (index & (~0ul << n->bits))
- 			break;
- 
- 		/* we have found a leaf. Prefixes have already been compared */
--- a/target/linux/generic/pending-3.18/080-20-fib_trie-Fix-RCU-bug-and-merge-similar-bits-of-infla.patch	2022-03-22 08:54:47.273464779 +0800
+++ b/target/linux/generic/pending-3.18/080-20-fib_trie-Fix-RCU-bug-and-merge-similar-bits-of-infla.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,267 +0,0 @@
-From: Alexander Duyck <alexander.h.duyck@redhat.com>
-Date: Thu, 22 Jan 2015 15:51:14 -0800
-Subject: [PATCH] fib_trie: Fix RCU bug and merge similar bits of inflate/halve
-
-This patch addresses two issues.
-
-The first issue is the fact that I believe I had the RCU freeing sequence
-slightly out of order.  As a result we could get into an issue if a caller
-went into a child of a child of the new node, then backtraced into the to be
-freed parent, and then attempted to access a child of a child that may have
-been consumed in a resize of one of the new nodes children.  To resolve this I
-have moved the resize after we have freed the oldtnode.  The only side effect
-of this is that we will now be calling resize on more nodes in the case of
-inflate due to the fact that we don't have a good way to test to see if a
-full_tnode on the new node was there before or after the allocation.  This
-should have minimal impact however since the node should already be
-correctly size so it is just the cost of calling should_inflate that we
-will be taking on the node which is only a couple of cycles.
-
-The second issue is the fact that inflate and halve were essentially doing
-the same thing after the new node was added to the trie replacing the old
-one.  As such it wasn't really necessary to keep the code in both functions
-so I have split it out into two other functions, called replace and
-update_children.
-
-Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -396,8 +396,30 @@ static void put_child(struct tnode *tn,
- 	rcu_assign_pointer(tn->child[i], n);
- }
- 
--static void put_child_root(struct tnode *tp, struct trie *t,
--			   t_key key, struct tnode *n)
-+static void update_children(struct tnode *tn)
-+{
-+	unsigned long i;
-+
-+	/* update all of the child parent pointers */
-+	for (i = tnode_child_length(tn); i;) {
-+		struct tnode *inode = tnode_get_child(tn, --i);
-+
-+		if (!inode)
-+			continue;
-+
-+		/* Either update the children of a tnode that
-+		 * already belongs to us or update the child
-+		 * to point to ourselves.
-+		 */
-+		if (node_parent(inode) == tn)
-+			update_children(inode);
-+		else
-+			node_set_parent(inode, tn);
-+	}
-+}
-+
-+static inline void put_child_root(struct tnode *tp, struct trie *t,
-+				  t_key key, struct tnode *n)
- {
- 	if (tp)
- 		put_child(tp, get_index(key, tp), n);
-@@ -434,10 +456,35 @@ static void tnode_free(struct tnode *tn)
- 	}
- }
- 
-+static void replace(struct trie *t, struct tnode *oldtnode, struct tnode *tn)
-+{
-+	struct tnode *tp = node_parent(oldtnode);
-+	unsigned long i;
-+
-+	/* setup the parent pointer out of and back into this node */
-+	NODE_INIT_PARENT(tn, tp);
-+	put_child_root(tp, t, tn->key, tn);
-+
-+	/* update all of the child parent pointers */
-+	update_children(tn);
-+
-+	/* all pointers should be clean so we are done */
-+	tnode_free(oldtnode);
-+
-+	/* resize children now that oldtnode is freed */
-+	for (i = tnode_child_length(tn); i;) {
-+		struct tnode *inode = tnode_get_child(tn, --i);
-+
-+		/* resize child node */
-+		if (tnode_full(tn, inode))
-+			resize(t, inode);
-+	}
-+}
-+
- static int inflate(struct trie *t, struct tnode *oldtnode)
- {
--	struct tnode *inode, *node0, *node1, *tn, *tp;
--	unsigned long i, j, k;
-+	struct tnode *tn;
-+	unsigned long i;
- 	t_key m;
- 
- 	pr_debug("In inflate\n");
-@@ -446,13 +493,18 @@ static int inflate(struct trie *t, struc
- 	if (!tn)
- 		return -ENOMEM;
- 
-+	/* prepare oldtnode to be freed */
-+	tnode_free_init(oldtnode);
-+
- 	/* Assemble all of the pointers in our cluster, in this case that
- 	 * represents all of the pointers out of our allocated nodes that
- 	 * point to existing tnodes and the links between our allocated
- 	 * nodes.
- 	 */
- 	for (i = tnode_child_length(oldtnode), m = 1u << tn->pos; i;) {
--		inode = tnode_get_child(oldtnode, --i);
-+		struct tnode *inode = tnode_get_child(oldtnode, --i);
-+		struct tnode *node0, *node1;
-+		unsigned long j, k;
- 
- 		/* An empty child */
- 		if (inode == NULL)
-@@ -464,6 +516,9 @@ static int inflate(struct trie *t, struc
- 			continue;
- 		}
- 
-+		/* drop the node in the old tnode free list */
-+		tnode_free_append(oldtnode, inode);
-+
- 		/* An internal node with two children */
- 		if (inode->bits == 1) {
- 			put_child(tn, 2 * i + 1, tnode_get_child(inode, 1));
-@@ -488,9 +543,9 @@ static int inflate(struct trie *t, struc
- 		node1 = tnode_new(inode->key | m, inode->pos, inode->bits - 1);
- 		if (!node1)
- 			goto nomem;
--		tnode_free_append(tn, node1);
-+		node0 = tnode_new(inode->key, inode->pos, inode->bits - 1);
- 
--		node0 = tnode_new(inode->key & ~m, inode->pos, inode->bits - 1);
-+		tnode_free_append(tn, node1);
- 		if (!node0)
- 			goto nomem;
- 		tnode_free_append(tn, node0);
-@@ -512,53 +567,9 @@ static int inflate(struct trie *t, struc
- 		put_child(tn, 2 * i, node0);
- 	}
- 
--	/* setup the parent pointer into and out of this node */
--	tp = node_parent(oldtnode);
--	NODE_INIT_PARENT(tn, tp);
--	put_child_root(tp, t, tn->key, tn);
-+	/* setup the parent pointers into and out of this node */
-+	replace(t, oldtnode, tn);
- 
--	/* prepare oldtnode to be freed */
--	tnode_free_init(oldtnode);
--
--	/* update all child nodes parent pointers to route to us */
--	for (i = tnode_child_length(oldtnode); i;) {
--		inode = tnode_get_child(oldtnode, --i);
--
--		/* A leaf or an internal node with skipped bits */
--		if (!tnode_full(oldtnode, inode)) {
--			node_set_parent(inode, tn);
--			continue;
--		}
--
--		/* drop the node in the old tnode free list */
--		tnode_free_append(oldtnode, inode);
--
--		/* fetch new nodes */
--		node1 = tnode_get_child(tn, 2 * i + 1);
--		node0 = tnode_get_child(tn, 2 * i);
--
--		/* bits == 1 then node0 and node1 represent inode's children */
--		if (inode->bits == 1) {
--			node_set_parent(node1, tn);
--			node_set_parent(node0, tn);
--			continue;
--		}
--
--		/* update parent pointers in child node's children */
--		for (k = tnode_child_length(inode), j = k / 2; j;) {
--			node_set_parent(tnode_get_child(inode, --k), node1);
--			node_set_parent(tnode_get_child(inode, --j), node0);
--			node_set_parent(tnode_get_child(inode, --k), node1);
--			node_set_parent(tnode_get_child(inode, --j), node0);
--		}
--
--		/* resize child nodes */
--		resize(t, node1);
--		resize(t, node0);
--	}
--
--	/* we completed without error, prepare to free old node */
--	tnode_free(oldtnode);
- 	return 0;
- nomem:
- 	/* all pointers should be clean so we are done */
-@@ -568,7 +579,7 @@ nomem:
- 
- static int halve(struct trie *t, struct tnode *oldtnode)
- {
--	struct tnode *tn, *tp, *inode, *node0, *node1;
-+	struct tnode *tn;
- 	unsigned long i;
- 
- 	pr_debug("In halve\n");
-@@ -577,14 +588,18 @@ static int halve(struct trie *t, struct
- 	if (!tn)
- 		return -ENOMEM;
- 
-+	/* prepare oldtnode to be freed */
-+	tnode_free_init(oldtnode);
-+
- 	/* Assemble all of the pointers in our cluster, in this case that
- 	 * represents all of the pointers out of our allocated nodes that
- 	 * point to existing tnodes and the links between our allocated
- 	 * nodes.
- 	 */
- 	for (i = tnode_child_length(oldtnode); i;) {
--		node1 = tnode_get_child(oldtnode, --i);
--		node0 = tnode_get_child(oldtnode, --i);
-+		struct tnode *node1 = tnode_get_child(oldtnode, --i);
-+		struct tnode *node0 = tnode_get_child(oldtnode, --i);
-+		struct tnode *inode;
- 
- 		/* At least one of the children is empty */
- 		if (!node1 || !node0) {
-@@ -609,34 +624,8 @@ static int halve(struct trie *t, struct
- 		put_child(tn, i / 2, inode);
- 	}
- 
--	/* setup the parent pointer out of and back into this node */
--	tp = node_parent(oldtnode);
--	NODE_INIT_PARENT(tn, tp);
--	put_child_root(tp, t, tn->key, tn);
--
--	/* prepare oldtnode to be freed */
--	tnode_free_init(oldtnode);
--
--	/* update all of the child parent pointers */
--	for (i = tnode_child_length(tn); i;) {
--		inode = tnode_get_child(tn, --i);
--
--		/* only new tnodes will be considered "full" nodes */
--		if (!tnode_full(tn, inode)) {
--			node_set_parent(inode, tn);
--			continue;
--		}
--
--		/* Two nonempty children */
--		node_set_parent(tnode_get_child(inode, 1), inode);
--		node_set_parent(tnode_get_child(inode, 0), inode);
--
--		/* resize child node */
--		resize(t, inode);
--	}
--
--	/* all pointers should be clean so we are done */
--	tnode_free(oldtnode);
-+	/* setup the parent pointers into and out of this node */
-+	replace(t, oldtnode, tn);
- 
- 	return 0;
- }
--- a/target/linux/generic/pending-3.18/080-21-fib_trie-Fall-back-to-slen-update-on-inflate-halve-f.patch	2022-03-22 08:54:47.274464781 +0800
+++ b/target/linux/generic/pending-3.18/080-21-fib_trie-Fall-back-to-slen-update-on-inflate-halve-f.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,61 +0,0 @@
-From: Alexander Duyck <alexander.h.duyck@redhat.com>
-Date: Thu, 22 Jan 2015 15:51:20 -0800
-Subject: [PATCH] fib_trie: Fall back to slen update on inflate/halve failure
-
-This change corrects an issue where if inflate or halve fails we were
-exiting the resize function without at least updating the slen for the
-node.  To correct this I have moved the update of max_size into the while
-loop so that it is only decremented on a successful call to either inflate
-or halve.
-
-Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -752,7 +752,7 @@ static void resize(struct trie *t, struc
- {
- 	struct tnode *tp = node_parent(tn), *n = NULL;
- 	struct tnode __rcu **cptr;
--	int max_work;
-+	int max_work = MAX_WORK;
- 
- 	pr_debug("In tnode_resize %p inflate_threshold=%d threshold=%d\n",
- 		 tn, inflate_threshold, halve_threshold);
-@@ -775,8 +775,7 @@ static void resize(struct trie *t, struc
- 	/* Double as long as the resulting node has a number of
- 	 * nonempty nodes that are above the threshold.
- 	 */
--	max_work = MAX_WORK;
--	while (should_inflate(tp, tn) && max_work--) {
-+	while (should_inflate(tp, tn) && max_work) {
- 		if (inflate(t, tn)) {
- #ifdef CONFIG_IP_FIB_TRIE_STATS
- 			this_cpu_inc(t->stats->resize_node_skipped);
-@@ -784,6 +783,7 @@ static void resize(struct trie *t, struc
- 			break;
- 		}
- 
-+		max_work--;
- 		tn = rtnl_dereference(*cptr);
- 	}
- 
-@@ -794,8 +794,7 @@ static void resize(struct trie *t, struc
- 	/* Halve as long as the number of empty children in this
- 	 * node is above threshold.
- 	 */
--	max_work = MAX_WORK;
--	while (should_halve(tp, tn) && max_work--) {
-+	while (should_halve(tp, tn) && max_work) {
- 		if (halve(t, tn)) {
- #ifdef CONFIG_IP_FIB_TRIE_STATS
- 			this_cpu_inc(t->stats->resize_node_skipped);
-@@ -803,6 +802,7 @@ static void resize(struct trie *t, struc
- 			break;
- 		}
- 
-+		max_work--;
- 		tn = rtnl_dereference(*cptr);
- 	}
- 
--- a/target/linux/generic/pending-3.18/080-22-fib_trie-Add-collapse-and-should_collapse-to-resize.patch	2022-03-22 08:54:47.274464781 +0800
+++ b/target/linux/generic/pending-3.18/080-22-fib_trie-Add-collapse-and-should_collapse-to-resize.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,206 +0,0 @@
-From: Alexander Duyck <alexander.h.duyck@redhat.com>
-Date: Thu, 22 Jan 2015 15:51:26 -0800
-Subject: [PATCH] fib_trie: Add collapse() and should_collapse() to resize
-
-This patch really does two things.
-
-First it pulls the logic for determining if we should collapse one node out
-of the tree and the actual code doing the collapse into a separate pair of
-functions.  This helps to make the changes to these areas more readable.
-
-Second it encodes the upper 32b of the empty_children value onto the
-full_children value in the case of bits == KEYLENGTH.  By doing this we are
-able to handle the case of a 32b node where empty_children would appear to
-be 0 when it was actually 1ul << 32.
-
-Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -83,7 +83,8 @@
- 
- #define MAX_STAT_DEPTH 32
- 
--#define KEYLENGTH (8*sizeof(t_key))
-+#define KEYLENGTH	(8*sizeof(t_key))
-+#define KEY_MAX		((t_key)~0)
- 
- typedef unsigned int t_key;
- 
-@@ -102,8 +103,8 @@ struct tnode {
- 	union {
- 		/* The fields in this struct are valid if bits > 0 (TNODE) */
- 		struct {
--			unsigned int full_children;  /* KEYLENGTH bits needed */
--			unsigned int empty_children; /* KEYLENGTH bits needed */
-+			t_key empty_children; /* KEYLENGTH bits needed */
-+			t_key full_children;  /* KEYLENGTH bits needed */
- 			struct tnode __rcu *child[0];
- 		};
- 		/* This list pointer if valid if bits == 0 (LEAF) */
-@@ -302,6 +303,16 @@ static struct tnode *tnode_alloc(size_t
- 		return vzalloc(size);
- }
- 
-+static inline void empty_child_inc(struct tnode *n)
-+{
-+	++n->empty_children ? : ++n->full_children;
-+}
-+
-+static inline void empty_child_dec(struct tnode *n)
-+{
-+	n->empty_children-- ? : n->full_children--;
-+}
-+
- static struct tnode *leaf_new(t_key key)
- {
- 	struct tnode *l = kmem_cache_alloc(trie_leaf_kmem, GFP_KERNEL);
-@@ -335,7 +346,7 @@ static struct leaf_info *leaf_info_new(i
- 
- static struct tnode *tnode_new(t_key key, int pos, int bits)
- {
--	size_t sz = offsetof(struct tnode, child[1 << bits]);
-+	size_t sz = offsetof(struct tnode, child[1ul << bits]);
- 	struct tnode *tn = tnode_alloc(sz);
- 	unsigned int shift = pos + bits;
- 
-@@ -348,8 +359,10 @@ static struct tnode *tnode_new(t_key key
- 		tn->pos = pos;
- 		tn->bits = bits;
- 		tn->key = (shift < KEYLENGTH) ? (key >> shift) << shift : 0;
--		tn->full_children = 0;
--		tn->empty_children = 1<<bits;
-+		if (bits == KEYLENGTH)
-+			tn->full_children = 1;
-+		else
-+			tn->empty_children = 1ul << bits;
- 	}
- 
- 	pr_debug("AT %p s=%zu %zu\n", tn, sizeof(struct tnode),
-@@ -375,11 +388,11 @@ static void put_child(struct tnode *tn,
- 
- 	BUG_ON(i >= tnode_child_length(tn));
- 
--	/* update emptyChildren */
-+	/* update emptyChildren, overflow into fullChildren */
- 	if (n == NULL && chi != NULL)
--		tn->empty_children++;
--	else if (n != NULL && chi == NULL)
--		tn->empty_children--;
-+		empty_child_inc(tn);
-+	if (n != NULL && chi == NULL)
-+		empty_child_dec(tn);
- 
- 	/* update fullChildren */
- 	wasfull = tnode_full(tn, chi);
-@@ -630,6 +643,24 @@ static int halve(struct trie *t, struct
- 	return 0;
- }
- 
-+static void collapse(struct trie *t, struct tnode *oldtnode)
-+{
-+	struct tnode *n, *tp;
-+	unsigned long i;
-+
-+	/* scan the tnode looking for that one child that might still exist */
-+	for (n = NULL, i = tnode_child_length(oldtnode); !n && i;)
-+		n = tnode_get_child(oldtnode, --i);
-+
-+	/* compress one level */
-+	tp = node_parent(oldtnode);
-+	put_child_root(tp, t, oldtnode->key, n);
-+	node_set_parent(n, tp);
-+
-+	/* drop dead node */
-+	node_free(oldtnode);
-+}
-+
- static unsigned char update_suffix(struct tnode *tn)
- {
- 	unsigned char slen = tn->pos;
-@@ -729,10 +760,12 @@ static bool should_inflate(const struct
- 
- 	/* Keep root node larger */
- 	threshold *= tp ? inflate_threshold : inflate_threshold_root;
--	used += tn->full_children;
- 	used -= tn->empty_children;
-+	used += tn->full_children;
- 
--	return tn->pos && ((50 * used) >= threshold);
-+	/* if bits == KEYLENGTH then pos = 0, and will fail below */
-+
-+	return (used > 1) && tn->pos && ((50 * used) >= threshold);
- }
- 
- static bool should_halve(const struct tnode *tp, const struct tnode *tn)
-@@ -744,13 +777,29 @@ static bool should_halve(const struct tn
- 	threshold *= tp ? halve_threshold : halve_threshold_root;
- 	used -= tn->empty_children;
- 
--	return (tn->bits > 1) && ((100 * used) < threshold);
-+	/* if bits == KEYLENGTH then used = 100% on wrap, and will fail below */
-+
-+	return (used > 1) && (tn->bits > 1) && ((100 * used) < threshold);
-+}
-+
-+static bool should_collapse(const struct tnode *tn)
-+{
-+	unsigned long used = tnode_child_length(tn);
-+
-+	used -= tn->empty_children;
-+
-+	/* account for bits == KEYLENGTH case */
-+	if ((tn->bits == KEYLENGTH) && tn->full_children)
-+		used -= KEY_MAX;
-+
-+	/* One child or none, time to drop us from the trie */
-+	return used < 2;
- }
- 
- #define MAX_WORK 10
- static void resize(struct trie *t, struct tnode *tn)
- {
--	struct tnode *tp = node_parent(tn), *n = NULL;
-+	struct tnode *tp = node_parent(tn);
- 	struct tnode __rcu **cptr;
- 	int max_work = MAX_WORK;
- 
-@@ -764,14 +813,6 @@ static void resize(struct trie *t, struc
- 	cptr = tp ? &tp->child[get_index(tn->key, tp)] : &t->trie;
- 	BUG_ON(tn != rtnl_dereference(*cptr));
- 
--	/* No children */
--	if (tn->empty_children > (tnode_child_length(tn) - 1))
--		goto no_children;
--
--	/* One child */
--	if (tn->empty_children == (tnode_child_length(tn) - 1))
--		goto one_child;
--
- 	/* Double as long as the resulting node has a number of
- 	 * nonempty nodes that are above the threshold.
- 	 */
-@@ -807,19 +848,8 @@ static void resize(struct trie *t, struc
- 	}
- 
- 	/* Only one child remains */
--	if (tn->empty_children == (tnode_child_length(tn) - 1)) {
--		unsigned long i;
--one_child:
--		for (i = tnode_child_length(tn); !n && i;)
--			n = tnode_get_child(tn, --i);
--no_children:
--		/* compress one level */
--		put_child_root(tp, t, tn->key, n);
--		node_set_parent(n, tp);
--
--		/* drop dead node */
--		tnode_free_init(tn);
--		tnode_free(tn);
-+	if (should_collapse(tn)) {
-+		collapse(t, tn);
- 		return;
- 	}
- 
--- a/target/linux/generic/pending-3.18/080-23-fib_trie-Use-empty_children-instead-of-counting-empt.patch	2022-03-22 08:54:47.274464781 +0800
+++ b/target/linux/generic/pending-3.18/080-23-fib_trie-Use-empty_children-instead-of-counting-empt.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,34 +0,0 @@
-From: Alexander Duyck <alexander.h.duyck@redhat.com>
-Date: Thu, 22 Jan 2015 15:51:33 -0800
-Subject: [PATCH] fib_trie: Use empty_children instead of counting empty nodes
- in stats collection
-
-It doesn't make much sense to count the pointers ourselves when
-empty_children already has a count for the number of NULL pointers stored
-in the tnode.  As such save ourselves the cycles and just use
-empty_children.
-
-Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -1954,16 +1954,10 @@ static void trie_collect_stats(struct tr
- 			hlist_for_each_entry_rcu(li, &n->list, hlist)
- 				++s->prefixes;
- 		} else {
--			unsigned long i;
--
- 			s->tnodes++;
- 			if (n->bits < MAX_STAT_DEPTH)
- 				s->nodesizes[n->bits]++;
--
--			for (i = tnode_child_length(n); i--;) {
--				if (!rcu_access_pointer(n->child[i]))
--					s->nullpointers++;
--			}
-+			s->nullpointers += n->empty_children;
- 		}
- 	}
- 	rcu_read_unlock();
--- a/target/linux/generic/pending-3.18/080-24-fib_trie-Move-fib_find_alias-to-file-where-it-is-use.patch	2022-03-22 08:54:47.275464783 +0800
+++ b/target/linux/generic/pending-3.18/080-24-fib_trie-Move-fib_find_alias-to-file-where-it-is-use.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,79 +0,0 @@
-From: Alexander Duyck <alexander.h.duyck@redhat.com>
-Date: Thu, 22 Jan 2015 15:51:39 -0800
-Subject: [PATCH] fib_trie: Move fib_find_alias to file where it is used
-
-The function fib_find_alias is only accessed by functions in fib_trie.c as
-such it makes sense to relocate it and cast it as static so that the
-compiler can take advantage of optimizations it can do to it as a local
-function.
-
-Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/net/ipv4/fib_lookup.h
-+++ b/net/ipv4/fib_lookup.h
-@@ -32,7 +32,6 @@ int fib_dump_info(struct sk_buff *skb, u
- 		  unsigned int);
- void rtmsg_fib(int event, __be32 key, struct fib_alias *fa, int dst_len,
- 	       u32 tb_id, const struct nl_info *info, unsigned int nlm_flags);
--struct fib_alias *fib_find_alias(struct list_head *fah, u8 tos, u32 prio);
- 
- static inline void fib_result_assign(struct fib_result *res,
- 				     struct fib_info *fi)
---- a/net/ipv4/fib_semantics.c
-+++ b/net/ipv4/fib_semantics.c
-@@ -410,24 +410,6 @@ errout:
- 		rtnl_set_sk_err(info->nl_net, RTNLGRP_IPV4_ROUTE, err);
- }
- 
--/* Return the first fib alias matching TOS with
-- * priority less than or equal to PRIO.
-- */
--struct fib_alias *fib_find_alias(struct list_head *fah, u8 tos, u32 prio)
--{
--	if (fah) {
--		struct fib_alias *fa;
--		list_for_each_entry(fa, fah, fa_list) {
--			if (fa->fa_tos > tos)
--				continue;
--			if (fa->fa_info->fib_priority >= prio ||
--			    fa->fa_tos < tos)
--				return fa;
--		}
--	}
--	return NULL;
--}
--
- static int fib_detect_death(struct fib_info *fi, int order,
- 			    struct fib_info **last_resort, int *last_idx,
- 			    int dflt)
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -998,6 +998,26 @@ static struct tnode *fib_find_node(struc
- 	return n;
- }
- 
-+/* Return the first fib alias matching TOS with
-+ * priority less than or equal to PRIO.
-+ */
-+static struct fib_alias *fib_find_alias(struct list_head *fah, u8 tos, u32 prio)
-+{
-+	struct fib_alias *fa;
-+
-+	if (!fah)
-+		return NULL;
-+
-+	list_for_each_entry(fa, fah, fa_list) {
-+		if (fa->fa_tos > tos)
-+			continue;
-+		if (fa->fa_info->fib_priority >= prio || fa->fa_tos < tos)
-+			return fa;
-+	}
-+
-+	return NULL;
-+}
-+
- static void trie_rebalance(struct trie *t, struct tnode *tn)
- {
- 	struct tnode *tp;
--- a/target/linux/generic/pending-3.18/080-25-fib_trie-Various-clean-ups-for-handling-slen.patch	2022-03-22 08:54:47.275464783 +0800
+++ b/target/linux/generic/pending-3.18/080-25-fib_trie-Various-clean-ups-for-handling-slen.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,116 +0,0 @@
-From: Alexander Duyck <alexander.h.duyck@redhat.com>
-Date: Thu, 22 Jan 2015 15:51:45 -0800
-Subject: [PATCH] fib_trie: Various clean-ups for handling slen
-
-While doing further work on the fib_trie I noted a few items.
-
-First I was using calls that were far more complicated than they needed to
-be for determining when to push/pull the suffix length.  I have updated the
-code to reflect the simplier logic.
-
-The second issue is that I realised we weren't necessarily handling the
-case of a leaf_info struct surviving a flush.  I have updated the logic so
-that now we will call pull_suffix in the event of having a leaf info value
-left in the leaf after flushing it.
-
-Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -917,27 +917,20 @@ static void leaf_push_suffix(struct tnod
- 
- static void remove_leaf_info(struct tnode *l, struct leaf_info *old)
- {
--	struct hlist_node *prev;
--
--	/* record the location of the pointer to this object */
--	prev = rtnl_dereference(hlist_pprev_rcu(&old->hlist));
-+	/* record the location of the previous list_info entry */
-+	struct hlist_node **pprev = old->hlist.pprev;
-+	struct leaf_info *li = hlist_entry(pprev, typeof(*li), hlist.next);
- 
- 	/* remove the leaf info from the list */
- 	hlist_del_rcu(&old->hlist);
- 
--	/* if we emptied the list this leaf will be freed and we can sort
--	 * out parent suffix lengths as a part of trie_rebalance
--	 */
--	if (hlist_empty(&l->list))
-+	/* only access li if it is pointing at the last valid hlist_node */
-+	if (hlist_empty(&l->list) || (*pprev))
- 		return;
- 
--	/* if we removed the tail then we need to update slen */
--	if (!rcu_access_pointer(hlist_next_rcu(prev))) {
--		struct leaf_info *li = hlist_entry(prev, typeof(*li), hlist);
--
--		l->slen = KEYLENGTH - li->plen;
--		leaf_pull_suffix(l);
--	}
-+	/* update the trie with the latest suffix length */
-+	l->slen = KEYLENGTH - li->plen;
-+	leaf_pull_suffix(l);
- }
- 
- static void insert_leaf_info(struct tnode *l, struct leaf_info *new)
-@@ -961,7 +954,7 @@ static void insert_leaf_info(struct tnod
- 	}
- 
- 	/* if we added to the tail node then we need to update slen */
--	if (!rcu_access_pointer(hlist_next_rcu(&new->hlist))) {
-+	if (l->slen < (KEYLENGTH - new->plen)) {
- 		l->slen = KEYLENGTH - new->plen;
- 		leaf_push_suffix(l);
- 	}
-@@ -1613,6 +1606,7 @@ static int trie_flush_leaf(struct tnode
- 	struct hlist_head *lih = &l->list;
- 	struct hlist_node *tmp;
- 	struct leaf_info *li = NULL;
-+	unsigned char plen = KEYLENGTH;
- 
- 	hlist_for_each_entry_safe(li, tmp, lih, hlist) {
- 		found += trie_flush_list(&li->falh);
-@@ -1620,8 +1614,14 @@ static int trie_flush_leaf(struct tnode
- 		if (list_empty(&li->falh)) {
- 			hlist_del_rcu(&li->hlist);
- 			free_leaf_info(li);
-+			continue;
- 		}
-+
-+		plen = li->plen;
- 	}
-+
-+	l->slen = KEYLENGTH - plen;
-+
- 	return found;
- }
- 
-@@ -1700,13 +1700,22 @@ int fib_table_flush(struct fib_table *tb
- 	for (l = trie_firstleaf(t); l; l = trie_nextleaf(l)) {
- 		found += trie_flush_leaf(l);
- 
--		if (ll && hlist_empty(&ll->list))
--			trie_leaf_remove(t, ll);
-+		if (ll) {
-+			if (hlist_empty(&ll->list))
-+				trie_leaf_remove(t, ll);
-+			else
-+				leaf_pull_suffix(ll);
-+		}
-+
- 		ll = l;
- 	}
- 
--	if (ll && hlist_empty(&ll->list))
--		trie_leaf_remove(t, ll);
-+	if (ll) {
-+		if (hlist_empty(&ll->list))
-+			trie_leaf_remove(t, ll);
-+		else
-+			leaf_pull_suffix(ll);
-+	}
- 
- 	pr_debug("trie_flush found=%d\n", found);
- 	return found;
--- a/target/linux/generic/pending-3.18/081-01-pppoe-Use-workqueue-to-die-properly-when-a-PADT-is-r.patch	2022-03-22 08:54:47.276464784 +0800
+++ b/target/linux/generic/pending-3.18/081-01-pppoe-Use-workqueue-to-die-properly-when-a-PADT-is-r.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,89 +0,0 @@
-From: Simon Farnsworth <simon@farnz.org.uk>
-Date: Sun, 1 Mar 2015 10:54:39 +0000
-Subject: [PATCH] pppoe: Use workqueue to die properly when a PADT is received
-
-When a PADT frame is received, the socket may not be in a good state to
-close down the PPP interface. The current implementation handles this by
-simply blocking all further PPP traffic, and hoping that the lack of traffic
-will trigger the user to investigate.
-
-Use schedule_work to get to a process context from which we clear down the
-PPP interface, in a fashion analogous to hangup on a TTY-based PPP
-interface. This causes pppd to disconnect immediately, and allows tools to
-take immediate corrective action.
-
-Note that pppd's rp_pppoe.so plugin has code in it to disable the session
-when it disconnects; however, as a consequence of this patch, the session is
-already disabled before rp_pppoe.so is asked to disable the session. The
-result is a harmless error message:
-
-Failed to disconnect PPPoE socket: 114 Operation already in progress
-
-This message is safe to ignore, as long as the error is 114 Operation
-already in progress; in that specific case, it means that the PPPoE session
-has already been disabled before pppd tried to disable it.
-
-Signed-off-by: Simon Farnsworth <simon@farnz.org.uk>
-Tested-by: Dan Williams <dcbw@redhat.com>
-Tested-by: Christoph Schulz <develop@kristov.de>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/drivers/net/ppp/pppoe.c
-+++ b/drivers/net/ppp/pppoe.c
-@@ -454,6 +454,18 @@ out:
- 	return NET_RX_DROP;
- }
- 
-+static void pppoe_unbind_sock_work(struct work_struct *work)
-+{
-+	struct pppox_sock *po = container_of(work, struct pppox_sock,
-+					     proto.pppoe.padt_work);
-+	struct sock *sk = sk_pppox(po);
-+
-+	lock_sock(sk);
-+	pppox_unbind_sock(sk);
-+	release_sock(sk);
-+	sock_put(sk);
-+}
-+
- /************************************************************************
-  *
-  * Receive a PPPoE Discovery frame.
-@@ -499,7 +511,8 @@ static int pppoe_disc_rcv(struct sk_buff
- 		}
- 
- 		bh_unlock_sock(sk);
--		sock_put(sk);
-+		if (!schedule_work(&po->proto.pppoe.padt_work))
-+			sock_put(sk);
- 	}
- 
- abort:
-@@ -612,6 +625,8 @@ static int pppoe_connect(struct socket *
- 
- 	lock_sock(sk);
- 
-+	INIT_WORK(&po->proto.pppoe.padt_work, pppoe_unbind_sock_work);
-+
- 	error = -EINVAL;
- 
- 	if (sockaddr_len != sizeof(struct sockaddr_pppox))
---- a/include/linux/if_pppox.h
-+++ b/include/linux/if_pppox.h
-@@ -19,6 +19,7 @@
- #include <linux/netdevice.h>
- #include <linux/ppp_channel.h>
- #include <linux/skbuff.h>
-+#include <linux/workqueue.h>
- #include <uapi/linux/if_pppox.h>
- 
- static inline struct pppoe_hdr *pppoe_hdr(const struct sk_buff *skb)
-@@ -32,6 +33,7 @@ struct pppoe_opt {
- 	struct pppoe_addr	pa;	  /* what this socket is bound to*/
- 	struct sockaddr_pppox	relay;	  /* what socket data will be
- 					     relayed to (PPPoE relaying) */
-+	struct work_struct      padt_work;/* Work item for handling PADT */
- };
- 
- struct pptp_opt {
--- a/target/linux/generic/pending-3.18/081-02-pppoe-Lacks-DST-MAC-address-check.patch	2022-03-22 08:54:47.276464784 +0800
+++ b/target/linux/generic/pending-3.18/081-02-pppoe-Lacks-DST-MAC-address-check.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,25 +0,0 @@
-From: Joakim Tjernlund <Joakim.Tjernlund@transmode.se>
-Date: Mon, 20 Apr 2015 21:07:48 +0200
-Subject: [PATCH] pppoe: Lacks DST MAC address check
-
-A pppoe session is identified by its session ID and MAC address.
-Currently pppoe does not check if the received pkg has the correct
-MAC address. This is a problem when the eth I/F is in promisc mode
-as then any DST MAC address is accepted.
-
-Signed-off-by: Joakim Tjernlund <joakim.tjernlund@transmode.se>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/drivers/net/ppp/pppoe.c
-+++ b/drivers/net/ppp/pppoe.c
-@@ -379,6 +379,9 @@ static int pppoe_rcv_core(struct sock *s
- 	 * can't change.
- 	 */
- 
-+	if (skb->pkt_type == PACKET_OTHERHOST)
-+		goto abort_kfree;
-+
- 	if (sk->sk_state & PPPOX_BOUND) {
- 		ppp_input(&po->chan, skb);
- 	} else if (sk->sk_state & PPPOX_RELAY) {
--- a/target/linux/generic/pending-3.18/081-03-pppoe-drop-pppoe-device-in-pppoe_unbind_sock_work.patch	2022-03-22 08:54:47.277464786 +0800
+++ b/target/linux/generic/pending-3.18/081-03-pppoe-drop-pppoe-device-in-pppoe_unbind_sock_work.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,28 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 9 May 2015 23:08:38 +0200
-Subject: [PATCH] pppoe: drop pppoe device in pppoe_unbind_sock_work
-
-After receiving a PADT and the socket is closed, user space will no
-longer drop the reference to the pppoe device.
-This leads to errors like this:
-
-[  488.570000] unregister_netdevice: waiting for eth0.2 to become free. Usage count = 2
-
-Fixes: 287f3a943fe ("pppoe: Use workqueue to die properly when a PADT is received")
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/drivers/net/ppp/pppoe.c
-+++ b/drivers/net/ppp/pppoe.c
-@@ -464,6 +464,10 @@ static void pppoe_unbind_sock_work(struc
- 	struct sock *sk = sk_pppox(po);
- 
- 	lock_sock(sk);
-+	if (po->pppoe_dev) {
-+		dev_put(po->pppoe_dev);
-+		po->pppoe_dev = NULL;
-+	}
- 	pppox_unbind_sock(sk);
- 	release_sock(sk);
- 	sock_put(sk);
--- a/target/linux/generic/pending-3.18/081-06-ppp-don-t-set-sk_state-to-PPPOX_ZOMBIE-in-pppoe_disc.patch	2022-03-22 08:54:47.277464786 +0800
+++ b/target/linux/generic/pending-3.18/081-06-ppp-don-t-set-sk_state-to-PPPOX_ZOMBIE-in-pppoe_disc.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,45 +0,0 @@
-From: Guillaume Nault <g.nault@alphalink.fr>
-Date: Thu, 19 Nov 2015 12:52:56 +0100
-Subject: [PATCH] ppp: don't set sk_state to PPPOX_ZOMBIE in pppoe_disc_rcv()
-
-Since 287f3a943fef ("pppoe: Use workqueue to die properly when a PADT
-is received"), pppoe_disc_rcv() disconnects the socket by scheduling
-pppoe_unbind_sock_work(). This is enough to stop socket transmission
-and makes the PPPOX_ZOMBIE state uncessary.
-
-Signed-off-by: Guillaume Nault <g.nault@alphalink.fr>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/drivers/net/ppp/pppoe.c
-+++ b/drivers/net/ppp/pppoe.c
-@@ -500,27 +500,9 @@ static int pppoe_disc_rcv(struct sk_buff
- 
- 	pn = pppoe_pernet(dev_net(dev));
- 	po = get_item(pn, ph->sid, eth_hdr(skb)->h_source, dev->ifindex);
--	if (po) {
--		struct sock *sk = sk_pppox(po);
--
--		bh_lock_sock(sk);
--
--		/* If the user has locked the socket, just ignore
--		 * the packet.  With the way two rcv protocols hook into
--		 * one socket family type, we cannot (easily) distinguish
--		 * what kind of SKB it is during backlog rcv.
--		 */
--		if (sock_owned_by_user(sk) == 0) {
--			/* We're no longer connect at the PPPOE layer,
--			 * and must wait for ppp channel to disconnect us.
--			 */
--			sk->sk_state = PPPOX_ZOMBIE;
--		}
--
--		bh_unlock_sock(sk);
-+	if (po)
- 		if (!schedule_work(&po->proto.pppoe.padt_work))
--			sock_put(sk);
--	}
-+			sock_put(sk_pppox(po));
- 
- abort:
- 	kfree_skb(skb);
--- a/target/linux/generic/pending-3.18/081-07-ppp-remove-PPPOX_ZOMBIE-socket-state.patch	2022-03-22 08:54:47.277464786 +0800
+++ b/target/linux/generic/pending-3.18/081-07-ppp-remove-PPPOX_ZOMBIE-socket-state.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,51 +0,0 @@
-From: Guillaume Nault <g.nault@alphalink.fr>
-Date: Thu, 19 Nov 2015 12:53:21 +0100
-Subject: [PATCH] ppp: remove PPPOX_ZOMBIE socket state
-
-PPPOX_ZOMBIE is never set anymore.
-
-Signed-off-by: Guillaume Nault <g.nault@alphalink.fr>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/drivers/net/ppp/pppoe.c
-+++ b/drivers/net/ppp/pppoe.c
-@@ -311,7 +311,7 @@ static void pppoe_flush_dev(struct net_d
- 			lock_sock(sk);
- 
- 			if (po->pppoe_dev == dev &&
--			    sk->sk_state & (PPPOX_CONNECTED | PPPOX_BOUND | PPPOX_ZOMBIE)) {
-+			    sk->sk_state & (PPPOX_CONNECTED | PPPOX_BOUND)) {
- 				pppox_unbind_sock(sk);
- 				sk->sk_state_change(sk);
- 				po->pppoe_dev = NULL;
-@@ -779,7 +779,7 @@ static int pppoe_ioctl(struct socket *so
- 		struct pppox_sock *relay_po;
- 
- 		err = -EBUSY;
--		if (sk->sk_state & (PPPOX_BOUND | PPPOX_ZOMBIE | PPPOX_DEAD))
-+		if (sk->sk_state & (PPPOX_BOUND | PPPOX_DEAD))
- 			break;
- 
- 		err = -ENOTCONN;
---- a/drivers/net/ppp/pppox.c
-+++ b/drivers/net/ppp/pppox.c
-@@ -58,7 +58,7 @@ void pppox_unbind_sock(struct sock *sk)
- {
- 	/* Clear connection to ppp device, if attached. */
- 
--	if (sk->sk_state & (PPPOX_BOUND | PPPOX_CONNECTED | PPPOX_ZOMBIE)) {
-+	if (sk->sk_state & (PPPOX_BOUND | PPPOX_CONNECTED)) {
- 		ppp_unregister_channel(&pppox_sk(sk)->chan);
- 		sk->sk_state = PPPOX_DEAD;
- 	}
---- a/include/linux/if_pppox.h
-+++ b/include/linux/if_pppox.h
-@@ -91,7 +91,6 @@ enum {
-     PPPOX_CONNECTED	= 1,  /* connection established ==TCP_ESTABLISHED */
-     PPPOX_BOUND		= 2,  /* bound to ppp device */
-     PPPOX_RELAY		= 4,  /* forwarding is enabled */
--    PPPOX_ZOMBIE	= 8,  /* dead, but still bound to ppp device */
-     PPPOX_DEAD		= 16  /* dead, useless, please clean me up!*/
- };
- 
--- a/target/linux/generic/pending-3.18/081-08-pppoe-fix-memory-corruption-in-padt-work-structure.patch	2022-03-22 08:54:47.278464788 +0800
+++ b/target/linux/generic/pending-3.18/081-08-pppoe-fix-memory-corruption-in-padt-work-structure.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,82 +0,0 @@
-From: Guillaume Nault <g.nault@alphalink.fr>
-Date: Thu, 3 Dec 2015 16:49:32 +0100
-Subject: [PATCH] pppoe: fix memory corruption in padt work structure
-
-pppoe_connect() mustn't touch the padt_work field of pppoe sockets
-because that work could be already pending.
-
-[   21.473147] BUG: unable to handle kernel NULL pointer dereference at 00000004
-[   21.474523] IP: [<c1043177>] process_one_work+0x29/0x31c
-[   21.475164] *pde = 00000000
-[   21.475513] Oops: 0000 [#1] SMP
-[   21.475910] Modules linked in: pppoe pppox ppp_generic slhc crc32c_intel aesni_intel virtio_net xts aes_i586 lrw gf128mul ablk_helper cryptd evdev acpi_cpufreq processor serio_raw button ext4 crc16 mbcache jbd2 virtio_blk virtio_pci virtio_ring virtio
-[   21.476168] CPU: 2 PID: 164 Comm: kworker/2:2 Not tainted 4.4.0-rc1 #1
-[   21.476168] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Debian-1.8.2-1 04/01/2014
-[   21.476168] task: f5f83c00 ti: f5e28000 task.ti: f5e28000
-[   21.476168] EIP: 0060:[<c1043177>] EFLAGS: 00010046 CPU: 2
-[   21.476168] EIP is at process_one_work+0x29/0x31c
-[   21.484082] EAX: 00000000 EBX: f678b2a0 ECX: 00000004 EDX: 00000000
-[   21.484082] ESI: f6c69940 EDI: f5e29ef0 EBP: f5e29f0c ESP: f5e29edc
-[   21.484082]  DS: 007b ES: 007b FS: 00d8 GS: 0000 SS: 0068
-[   21.484082] CR0: 80050033 CR2: 000000a4 CR3: 317ad000 CR4: 00040690
-[   21.484082] Stack:
-[   21.484082]  00000000 f6c69950 00000000 f6c69940 c0042338 f5e29f0c c1327945 00000000
-[   21.484082]  00000008 f678b2a0 f6c69940 f678b2b8 f5e29f30 c1043984 f5f83c00 f6c69970
-[   21.484082]  f678b2a0 c10437d3 f6775e80 f678b2a0 c10437d3 f5e29fac c1047059 f5e29f74
-[   21.484082] Call Trace:
-[   21.484082]  [<c1327945>] ? _raw_spin_lock_irq+0x28/0x30
-[   21.484082]  [<c1043984>] worker_thread+0x1b1/0x244
-[   21.484082]  [<c10437d3>] ? rescuer_thread+0x229/0x229
-[   21.484082]  [<c10437d3>] ? rescuer_thread+0x229/0x229
-[   21.484082]  [<c1047059>] kthread+0x8f/0x94
-[   21.484082]  [<c1327a32>] ? _raw_spin_unlock_irq+0x22/0x26
-[   21.484082]  [<c1327ee9>] ret_from_kernel_thread+0x21/0x38
-[   21.484082]  [<c1046fca>] ? kthread_parkme+0x19/0x19
-[   21.496082] Code: 5d c3 55 89 e5 57 56 53 89 c3 83 ec 24 89 d0 89 55 e0 8d 7d e4 e8 6c d8 ff ff b9 04 00 00 00 89 45 d8 8b 43 24 89 45 dc 8b 45 d8 <8b> 40 04 8b 80 e0 00 00 00 c1 e8 05 24 01 88 45 d7 8b 45 e0 8d
-[   21.496082] EIP: [<c1043177>] process_one_work+0x29/0x31c SS:ESP 0068:f5e29edc
-[   21.496082] CR2: 0000000000000004
-[   21.496082] ---[ end trace e362cc9cf10dae89 ]---
-
-Reported-by: Andrew <nitr0@seti.kr.ua>
-Fixes: 287f3a943fef ("pppoe: Use workqueue to die properly when a PADT is received")
-Signed-off-by: Guillaume Nault <g.nault@alphalink.fr>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/drivers/net/ppp/pppoe.c
-+++ b/drivers/net/ppp/pppoe.c
-@@ -550,6 +550,9 @@ static int pppoe_create(struct net *net,
- 	sk->sk_family		= PF_PPPOX;
- 	sk->sk_protocol		= PX_PROTO_OE;
- 
-+	INIT_WORK(&pppox_sk(sk)->proto.pppoe.padt_work,
-+		  pppoe_unbind_sock_work);
-+
- 	return 0;
- }
- 
-@@ -614,8 +617,6 @@ static int pppoe_connect(struct socket *
- 
- 	lock_sock(sk);
- 
--	INIT_WORK(&po->proto.pppoe.padt_work, pppoe_unbind_sock_work);
--
- 	error = -EINVAL;
- 
- 	if (sockaddr_len != sizeof(struct sockaddr_pppox))
-@@ -649,8 +650,13 @@ static int pppoe_connect(struct socket *
- 			po->pppoe_dev = NULL;
- 		}
- 
--		memset(sk_pppox(po) + 1, 0,
--		       sizeof(struct pppox_sock) - sizeof(struct sock));
-+		po->pppoe_ifindex = 0;
-+		memset(&po->pppoe_pa, 0, sizeof(po->pppoe_pa));
-+		memset(&po->pppoe_relay, 0, sizeof(po->pppoe_relay));
-+		memset(&po->chan, 0, sizeof(po->chan));
-+		po->next = NULL;
-+		po->num = 0;
-+
- 		sk->sk_state = PPPOX_NONE;
- 	}
- 
--- a/target/linux/generic/pending-3.18/082-ipv6-ip6_fragment-fix-headroom-tests-and-skb-leak.patch	2022-03-22 08:54:47.278464788 +0800
+++ b/target/linux/generic/pending-3.18/082-ipv6-ip6_fragment-fix-headroom-tests-and-skb-leak.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,101 +0,0 @@
-From: Florian Westphal <fw@strlen.de>
-Date: Thu, 17 Sep 2015 11:24:48 +0100
-Subject: [PATCH] ipv6: ip6_fragment: fix headroom tests and skb leak
-
-David Woodhouse reports skb_under_panic when we try to push ethernet
-header to fragmented ipv6 skbs:
-
- skbuff: skb_under_panic: text:c1277f1e len:1294 put:14 head:dec98000
- data:dec97ffc tail:0xdec9850a end:0xdec98f40 dev:br-lan
-[..]
-ip6_finish_output2+0x196/0x4da
-
-David further debugged this:
-  [..] offending fragments were arriving here with skb_headroom(skb)==10.
-  Which is reasonable, being the Solos ADSL card's header of 8 bytes
-  followed by 2 bytes of PPP frame type.
-
-The problem is that if netfilter ipv6 defragmentation is used, skb_cow()
-in ip6_forward will only see reassembled skb.
-
-Therefore, headroom is overestimated by 8 bytes (we pulled fragment
-header) and we don't check the skbs in the frag_list either.
-
-We can't do these checks in netfilter defrag since outdev isn't known yet.
-
-Furthermore, existing tests in ip6_fragment did not consider the fragment
-or ipv6 header size when checking headroom of the fraglist skbs.
-
-While at it, also fix a skb leak on memory allocation -- ip6_fragment
-must consume the skb.
-
-I tested this e1000 driver hacked to not allocate additional headroom
-(we end up in slowpath, since LL_RESERVED_SPACE is 16).
-
-If 2 bytes of headroom are allocated, fastpath is taken (14 byte
-ethernet header was pulled, so 16 byte headroom available in all
-fragments).
-
-Reported-by: David Woodhouse <dwmw2@infradead.org>
-Diagnosed-by: David Woodhouse <dwmw2@infradead.org>
-Signed-off-by: Florian Westphal <fw@strlen.de>
-Closes 20532
----
-
---- a/net/ipv6/ip6_output.c
-+++ b/net/ipv6/ip6_output.c
-@@ -603,20 +603,22 @@ int ip6_fragment(struct sk_buff *skb, in
- 	}
- 	mtu -= hlen + sizeof(struct frag_hdr);
- 
-+	hroom = LL_RESERVED_SPACE(rt->dst.dev);
- 	if (skb_has_frag_list(skb)) {
- 		int first_len = skb_pagelen(skb);
- 		struct sk_buff *frag2;
- 
- 		if (first_len - hlen > mtu ||
- 		    ((first_len - hlen) & 7) ||
--		    skb_cloned(skb))
-+		    skb_cloned(skb) ||
-+		    skb_headroom(skb) < (hroom + sizeof(struct frag_hdr)))
- 			goto slow_path;
- 
- 		skb_walk_frags(skb, frag) {
- 			/* Correct geometry. */
- 			if (frag->len > mtu ||
- 			    ((frag->len & 7) && frag->next) ||
--			    skb_headroom(frag) < hlen)
-+			    skb_headroom(frag) < (hlen + hroom + sizeof(struct frag_hdr)))
- 				goto slow_path_clean;
- 
- 			/* Partially cloned skb? */
-@@ -633,8 +635,6 @@ int ip6_fragment(struct sk_buff *skb, in
- 
- 		err = 0;
- 		offset = 0;
--		frag = skb_shinfo(skb)->frag_list;
--		skb_frag_list_init(skb);
- 		/* BUILD HEADER */
- 
- 		*prevhdr = NEXTHDR_FRAGMENT;
-@@ -642,8 +642,11 @@ int ip6_fragment(struct sk_buff *skb, in
- 		if (!tmp_hdr) {
- 			IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),
- 				      IPSTATS_MIB_FRAGFAILS);
--			return -ENOMEM;
-+			err = -ENOMEM;
-+			goto fail;
- 		}
-+		frag = skb_shinfo(skb)->frag_list;
-+		skb_frag_list_init(skb);
- 
- 		__skb_pull(skb, hlen);
- 		fh = (struct frag_hdr *)__skb_push(skb, sizeof(struct frag_hdr));
-@@ -741,7 +744,6 @@ slow_path:
- 	 */
- 
- 	*prevhdr = NEXTHDR_FRAGMENT;
--	hroom = LL_RESERVED_SPACE(rt->dst.dev);
- 	troom = rt->dst.dev->needed_tailroom;
- 
- 	/*
--- a/target/linux/generic/pending-3.18/083-solos-pci-Increase-headroom-on-received-packets.patch	2022-03-22 08:54:47.278464788 +0800
+++ b/target/linux/generic/pending-3.18/083-solos-pci-Increase-headroom-on-received-packets.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,54 +0,0 @@
-From: David Woodhouse <dwmw2@infradead.org>
-Date: Thu, 17 Sep 2015 11:19:53 +0100
-Subject: [PATCH] solos-pci: Increase headroom on received packets
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-A comment in include/linux/skbuff.h says that:
-
- * Various parts of the networking layer expect at least 32 bytes of
- * headroom, you should not reduce this.
-
-This was demonstrated by a panic when handling fragmented IPv6 packets:
-http://marc.info/?l=linux-netdev&m=144236093519172&w=2
-
-It's not entirely clear if that comment is still valid  and if it is,
-perhaps netif_rx() ought to be enforcing it with a warning.
-
-But either way, it is rather stupid from a performance point of view
-for us to be receiving packets into a buffer which doesn't have enough
-room to prepend an Ethernet header  it means that *every* incoming
-packet is going to be need to be reallocated. So let's fix that.
-
-Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
----
-
---- a/drivers/atm/solos-pci.c
-+++ b/drivers/atm/solos-pci.c
-@@ -805,7 +805,12 @@ static void solos_bh(unsigned long card_
- 					continue;
- 				}
- 
--				skb = alloc_skb(size + 1, GFP_ATOMIC);
-+				/* Use netdev_alloc_skb() because it adds NET_SKB_PAD of
-+				 * headroom, and ensures we can route packets back out an
-+				 * Ethernet interface (for example) without having to
-+				 * reallocate. Adding NET_IP_ALIGN also ensures that both
-+				 * PPPoATM and PPPoEoBR2684 packets end up aligned. */
-+				skb = netdev_alloc_skb_ip_align(NULL, size + 1);
- 				if (!skb) {
- 					if (net_ratelimit())
- 						dev_warn(&card->dev->dev, "Failed to allocate sk_buff for RX\n");
-@@ -869,7 +874,10 @@ static void solos_bh(unsigned long card_
- 		/* Allocate RX skbs for any ports which need them */
- 		if (card->using_dma && card->atmdev[port] &&
- 		    !card->rx_skb[port]) {
--			struct sk_buff *skb = alloc_skb(RX_DMA_SIZE, GFP_ATOMIC);
-+			/* Unlike the MMIO case (qv) we can't add NET_IP_ALIGN
-+			 * here; the FPGA can only DMA to addresses which are
-+			 * aligned to 4 bytes. */
-+			struct sk_buff *skb = dev_alloc_skb(RX_DMA_SIZE);
- 			if (skb) {
- 				SKB_CB(skb)->dma_addr =
- 					pci_map_single(card->dev, skb->data,
--- a/target/linux/generic/pending-3.18/087-regmap-make-LZO-cache-optional.patch	2022-03-22 08:54:47.279464789 +0800
+++ b/target/linux/generic/pending-3.18/087-regmap-make-LZO-cache-optional.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,67 +0,0 @@
-From de88e9b0354c2e3ff8eae3f97afe43a34f5ed239 Mon Sep 17 00:00:00 2001
-From: Jonas Gorski <jonas.gorski@gmail.com>
-Date: Sat, 13 May 2017 13:03:21 +0200
-Subject: [PATCH] regmap: make LZO cache optional
-
-Commit 2cbbb579bcbe3 ("regmap: Add the LZO cache support") added support
-for LZO compression in regcache, but there were never any users added
-afterwards. Since LZO support itself has its own size, it currently is
-rather a deoptimization.
-
-So make it optional by introducing a symbol that can be selected by
-drivers wanting to make use of it.
-
-Saves e.g. ~46 kB on MIPS (size of LZO support + regcache LZO code).
-
-Signed-off-by: Jonas Gorski <jonas.gorski@gmail.com>
----
-I tried using google to find any users (even out-of-tree ones), but at
-best I found a single driver submission that was switched to RBTREE in
-subsequent resubmissions (MFD_SMSC).
-
-One could maybe also just drop the code because of no users for 5 years,
-but that would be up to the maintainer(s) to decide.
-
- drivers/base/regmap/Kconfig    | 5 ++++-
- drivers/base/regmap/Makefile   | 3 ++-
- drivers/base/regmap/regcache.c | 2 ++
- 3 files changed, 8 insertions(+), 2 deletions(-)
-
---- a/drivers/base/regmap/Kconfig
-+++ b/drivers/base/regmap/Kconfig
-@@ -4,9 +4,12 @@
- 
- config REGMAP
- 	default y if (REGMAP_I2C || REGMAP_SPI || REGMAP_SPMI || REGMAP_MMIO || REGMAP_IRQ)
-+	select IRQ_DOMAIN if REGMAP_IRQ
-+	bool
-+
-+config REGCACHE_COMPRESSED
- 	select LZO_COMPRESS
- 	select LZO_DECOMPRESS
--	select IRQ_DOMAIN if REGMAP_IRQ
- 	bool
- 
- config REGMAP_I2C
---- a/drivers/base/regmap/Makefile
-+++ b/drivers/base/regmap/Makefile
-@@ -1,5 +1,6 @@
- obj-$(CONFIG_REGMAP) += regmap.o regcache.o
--obj-$(CONFIG_REGMAP) += regcache-rbtree.o regcache-lzo.o regcache-flat.o
-+obj-$(CONFIG_REGMAP) += regcache-rbtree.o regcache-flat.o
-+obj-$(CONFIG_REGCACHE_COMPRESSED) += regcache-lzo.o
- obj-$(CONFIG_DEBUG_FS) += regmap-debugfs.o
- obj-$(CONFIG_REGMAP_I2C) += regmap-i2c.o
- obj-$(CONFIG_REGMAP_SPI) += regmap-spi.o
---- a/drivers/base/regmap/regcache.c
-+++ b/drivers/base/regmap/regcache.c
-@@ -21,7 +21,9 @@
- 
- static const struct regcache_ops *cache_types[] = {
- 	&regcache_rbtree_ops,
-+#if IS_ENABLED(CONFIG_REGCACHE_COMPRESSED)
- 	&regcache_lzo_ops,
-+#endif
- 	&regcache_flat_ops,
- };
- 
--- a/target/linux/generic/pending-3.18/090-overlayfs-fallback-to-readonly-when-full.patch	2022-03-22 08:54:47.279464789 +0800
+++ b/target/linux/generic/pending-3.18/090-overlayfs-fallback-to-readonly-when-full.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,109 +0,0 @@
-[linux-unionfs added to Cc]
-
-On Tue, May 19, 2015 at 09:51:20AM +0200, Bastian Bittorf wrote:
-> Hi Miklos,
->
-> sorry for writing directly to you, feel free to forward
-> this to the appropriate mailinglist.
->
-> we have a problem with mainline overlay filesystem on kernel 3.18:
-> https://dev.openwrt.org/ticket/19564
->
-> 2 things are odd:
-> when the working filesystem is full, overlays fails with:
->
-> overlayfs: failed to create directory /overlay/work/work
->
-> what is strange, that we call it with:
->
-> mount(overlay, "/mnt", "overlay", MS_NOATIME, lowerdir)
->
-> see here:
-> http://nbd.name/gitweb.cgi?p=fstools.git;a=blob;f=libfstools/mount.c;h=81176ce399b4cd8e2d347c0008c13dec92407f55;hb=e6004000ff15d7bd32cf5663e8690fc94d7ec747#l125
->
-> do you have an idea whats wrong?
-> 1) is it really needed, that we need space for creating dir "/overlay/work"?
-> 2) why does overlay need "/overlay/work/work"?
-
-The work directory is needed for atomic copy-up and similar.  It is not actually
-necessary to mount a read-only overlay.  Post 4.0 it is possible to mount the
-overlay without workdir (but even then it won't happen automatically in case the
-upper fs is full, so this should be fixed in the latest kernel too).
-
-Could you please try the following patch?  If the workdir can't be created it
-will fall back to mounting the overlay read-only.
-
-Thanks,
-Miklos
-
----
- fs/overlayfs/copy_up.c |    3 +++
- fs/overlayfs/dir.c     |    9 +++++++++
- fs/overlayfs/super.c   |   12 +++++++++---
- 3 files changed, 21 insertions(+), 3 deletions(-)
-
---- a/fs/overlayfs/copy_up.c
-+++ b/fs/overlayfs/copy_up.c
-@@ -315,6 +315,9 @@ int ovl_copy_up_one(struct dentry *paren
- 	struct cred *override_cred;
- 	char *link = NULL;
- 
-+	if (WARN_ON(!workdir))
-+		return -EROFS;
-+
- 	ovl_path_upper(parent, &parentpath);
- 	upperdir = parentpath.dentry;
- 
---- a/fs/overlayfs/dir.c
-+++ b/fs/overlayfs/dir.c
-@@ -222,6 +222,9 @@ static struct dentry *ovl_clear_empty(st
- 	struct kstat stat;
- 	int err;
- 
-+	if (WARN_ON(!workdir))
-+		return ERR_PTR(-EROFS);
-+
- 	err = ovl_lock_rename_workdir(workdir, upperdir);
- 	if (err)
- 		goto out;
-@@ -322,6 +325,9 @@ static int ovl_create_over_whiteout(stru
- 	struct dentry *newdentry;
- 	int err;
- 
-+	if (WARN_ON(!workdir))
-+		return -EROFS;
-+
- 	err = ovl_lock_rename_workdir(workdir, upperdir);
- 	if (err)
- 		goto out;
-@@ -507,6 +513,9 @@ static int ovl_remove_and_whiteout(struc
- 	int err;
- 	int flags = 0;
- 
-+	if (WARN_ON(!workdir))
-+		return -EROFS;
-+
- 	if (is_dir) {
- 		opaquedir = ovl_check_empty_and_clear(dentry);
- 		err = PTR_ERR(opaquedir);
---- a/fs/overlayfs/super.c
-+++ b/fs/overlayfs/super.c
-@@ -760,9 +760,15 @@ static int ovl_fill_super(struct super_b
- 	ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
- 	err = PTR_ERR(ufs->workdir);
- 	if (IS_ERR(ufs->workdir)) {
--		pr_err("overlayfs: failed to create directory %s/%s\n",
--		       ufs->config.workdir, OVL_WORKDIR_NAME);
--		goto out_put_lower_mnt;
-+		if (err == -ENOSPC || err == -EROFS) {
-+			pr_warning("overlayfs: failed to create work directory (%s), mounting read-only\n", err == ENOSPC ? "ENOSPC" : "EROFS");
-+			sb->s_flags |= MS_RDONLY;
-+			ufs->workdir = NULL;
-+		} else {
-+			pr_err("overlayfs: failed to create directory %s/%s\n",
-+			       ufs->config.workdir, OVL_WORKDIR_NAME);
-+			goto out_put_lower_mnt;
-+		}
- 	}
- 
- 	/*
--- a/target/linux/generic/pending-3.18/091-mtd-spi-nor-add-support-Spansion_S25FL164K.patch	2022-03-22 08:54:47.279464789 +0800
+++ b/target/linux/generic/pending-3.18/091-mtd-spi-nor-add-support-Spansion_S25FL164K.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,10 +0,0 @@
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -567,6 +567,7 @@ static const struct spi_device_id spi_no
- 	{ "s25fl008k",  INFO(0xef4014,      0,  64 * 1024,  16, SECT_4K) },
- 	{ "s25fl016k",  INFO(0xef4015,      0,  64 * 1024,  32, SECT_4K) },
- 	{ "s25fl064k",  INFO(0xef4017,      0,  64 * 1024, 128, SECT_4K) },
-+	{ "s25fl164k",  INFO(0x014017,      0,  64 * 1024, 128, SECT_4K) },
- 
- 	/* SST -- large erase sizes are "overlays", "sectors" are 4K */
- 	{ "sst25vf040b", INFO(0xbf258d, 0, 64 * 1024,  8, SECT_4K | SST_WRITE) },
--- a/target/linux/generic/pending-3.18/092-01-spi-Check-to-see-if-the-device-is-processing-a-messa.patch	2022-03-22 08:54:47.280464791 +0800
+++ b/target/linux/generic/pending-3.18/092-01-spi-Check-to-see-if-the-device-is-processing-a-messa.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,47 +0,0 @@
-From: Mark Brown <broonie@kernel.org>
-Date: Tue, 9 Dec 2014 19:46:56 +0000
-Subject: [PATCH] spi: Check to see if the device is processing a message
- before we idle
-
-cur_msg is updated under the queue lock and holds the message we are
-currently processing. Since currently we only ever do removals in the
-pump kthread it doesn't matter in what order we do things but we want
-to be able to push things out from the submitting thread so pull the
-check to see if we're currently handling a message before we check to
-see if the queue is idle.
-
-Signed-off-by: Mark Brown <broonie@kernel.org>
----
-
---- a/drivers/spi/spi.c
-+++ b/drivers/spi/spi.c
-@@ -891,8 +891,16 @@ static void spi_pump_messages(struct kth
- 	bool was_busy = false;
- 	int ret;
- 
--	/* Lock queue and check for queue work */
-+	/* Lock queue */
- 	spin_lock_irqsave(&master->queue_lock, flags);
-+
-+	/* Make sure we are not already running a message */
-+	if (master->cur_msg) {
-+		spin_unlock_irqrestore(&master->queue_lock, flags);
-+		return;
-+	}
-+
-+	/* Check if the queue is idle */
- 	if (list_empty(&master->queue) || !master->running) {
- 		if (!master->busy) {
- 			spin_unlock_irqrestore(&master->queue_lock, flags);
-@@ -916,11 +924,6 @@ static void spi_pump_messages(struct kth
- 		return;
- 	}
- 
--	/* Make sure we are not already running a message */
--	if (master->cur_msg) {
--		spin_unlock_irqrestore(&master->queue_lock, flags);
--		return;
--	}
- 	/* Extract head of queue */
- 	master->cur_msg =
- 		list_first_entry(&master->queue, struct spi_message, queue);
--- a/target/linux/generic/pending-3.18/092-02-spi-Pump-transfers-inside-calling-context-for-spi_sy.patch	2022-03-22 08:54:47.280464791 +0800
+++ b/target/linux/generic/pending-3.18/092-02-spi-Pump-transfers-inside-calling-context-for-spi_sy.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,184 +0,0 @@
-From: Mark Brown <broonie@kernel.org>
-Date: Tue, 9 Dec 2014 21:38:05 +0000
-Subject: [PATCH] spi: Pump transfers inside calling context for spi_sync()
-
-If we are using the standard SPI message pump (which all drivers should be
-transitioning over to) then special case the message enqueue and instead of
-starting the worker thread to push messages to the hardware do so in the
-context of the caller if the controller is idle. This avoids a context
-switch in the common case where the controller has a single user in a
-single thread, for short PIO transfers there may be no need to context
-switch away from the calling context to complete the transfer.
-
-The code is a bit more complex than is desirable in part due to the need
-to handle drivers not using the standard queue and in part due to handling
-the various combinations of bus locking and asynchronous submission in
-interrupt context.
-
-It is still suboptimal since it will still wake the message pump for each
-transfer in order to schedule idling of the hardware and if multiple
-contexts are using the controller simultaneously a caller may end up
-pumping a message for some random other thread rather than for itself,
-and if the thread ends up deferring due to another context idling the
-hardware then it will just busy wait.  It can, however, have the benefit
-of aggregating power up and down of the hardware when a caller performs
-a series of transfers back to back without any need for the use of
-spi_async().
-
-Signed-off-by: Mark Brown <broonie@kernel.org>
----
-
---- a/drivers/spi/spi.c
-+++ b/drivers/spi/spi.c
-@@ -882,6 +882,9 @@ EXPORT_SYMBOL_GPL(spi_finalize_current_t
-  * needs processing and if so call out to the driver to initialize hardware
-  * and transfer each message.
-  *
-+ * Note that it is called both from the kthread itself and also from
-+ * inside spi_sync(); the queue extraction handling at the top of the
-+ * function should deal with this safely.
-  */
- static void spi_pump_messages(struct kthread_work *work)
- {
-@@ -900,6 +903,13 @@ static void spi_pump_messages(struct kth
- 		return;
- 	}
- 
-+	/* If another context is idling the device then defer */
-+	if (master->idling) {
-+		queue_kthread_work(&master->kworker, &master->pump_messages);
-+		spin_unlock_irqrestore(&master->queue_lock, flags);
-+		return;
-+	}
-+
- 	/* Check if the queue is idle */
- 	if (list_empty(&master->queue) || !master->running) {
- 		if (!master->busy) {
-@@ -907,7 +917,9 @@ static void spi_pump_messages(struct kth
- 			return;
- 		}
- 		master->busy = false;
-+		master->idling = true;
- 		spin_unlock_irqrestore(&master->queue_lock, flags);
-+
- 		kfree(master->dummy_rx);
- 		master->dummy_rx = NULL;
- 		kfree(master->dummy_tx);
-@@ -921,6 +933,10 @@ static void spi_pump_messages(struct kth
- 			pm_runtime_put_autosuspend(master->dev.parent);
- 		}
- 		trace_spi_master_idle(master);
-+
-+		spin_lock_irqsave(&master->queue_lock, flags);
-+		master->idling = false;
-+		spin_unlock_irqrestore(&master->queue_lock, flags);
- 		return;
- 	}
- 
-@@ -1166,12 +1182,9 @@ static int spi_destroy_queue(struct spi_
- 	return 0;
- }
- 
--/**
-- * spi_queued_transfer - transfer function for queued transfers
-- * @spi: spi device which is requesting transfer
-- * @msg: spi message which is to handled is queued to driver queue
-- */
--static int spi_queued_transfer(struct spi_device *spi, struct spi_message *msg)
-+static int __spi_queued_transfer(struct spi_device *spi,
-+				 struct spi_message *msg,
-+				 bool need_pump)
- {
- 	struct spi_master *master = spi->master;
- 	unsigned long flags;
-@@ -1186,13 +1199,23 @@ static int spi_queued_transfer(struct sp
- 	msg->status = -EINPROGRESS;
- 
- 	list_add_tail(&msg->queue, &master->queue);
--	if (!master->busy)
-+	if (!master->busy && need_pump)
- 		queue_kthread_work(&master->kworker, &master->pump_messages);
- 
- 	spin_unlock_irqrestore(&master->queue_lock, flags);
- 	return 0;
- }
- 
-+/**
-+ * spi_queued_transfer - transfer function for queued transfers
-+ * @spi: spi device which is requesting transfer
-+ * @msg: spi message which is to handled is queued to driver queue
-+ */
-+static int spi_queued_transfer(struct spi_device *spi, struct spi_message *msg)
-+{
-+	return __spi_queued_transfer(spi, msg, true);
-+}
-+
- static int spi_master_initialize_queue(struct spi_master *master)
- {
- 	int ret;
-@@ -2104,19 +2127,46 @@ static int __spi_sync(struct spi_device
- 	DECLARE_COMPLETION_ONSTACK(done);
- 	int status;
- 	struct spi_master *master = spi->master;
-+	unsigned long flags;
-+
-+	status = __spi_validate(spi, message);
-+	if (status != 0)
-+		return status;
- 
- 	message->complete = spi_complete;
- 	message->context = &done;
-+	message->spi = spi;
- 
- 	if (!bus_locked)
- 		mutex_lock(&master->bus_lock_mutex);
- 
--	status = spi_async_locked(spi, message);
-+	/* If we're not using the legacy transfer method then we will
-+	 * try to transfer in the calling context so special case.
-+	 * This code would be less tricky if we could remove the
-+	 * support for driver implemented message queues.
-+	 */
-+	if (master->transfer == spi_queued_transfer) {
-+		spin_lock_irqsave(&master->bus_lock_spinlock, flags);
-+
-+		trace_spi_message_submit(message);
-+
-+		status = __spi_queued_transfer(spi, message, false);
-+
-+		spin_unlock_irqrestore(&master->bus_lock_spinlock, flags);
-+	} else {
-+		status = spi_async_locked(spi, message);
-+	}
- 
- 	if (!bus_locked)
- 		mutex_unlock(&master->bus_lock_mutex);
- 
- 	if (status == 0) {
-+		/* Push out the messages in the calling context if we
-+		 * can.
-+		 */
-+		if (master->transfer == spi_queued_transfer)
-+			spi_pump_messages(&master->pump_messages);
-+
- 		wait_for_completion(&done);
- 		status = message->status;
- 	}
---- a/include/linux/spi/spi.h
-+++ b/include/linux/spi/spi.h
-@@ -260,6 +260,7 @@ static inline void spi_unregister_driver
-  * @pump_messages: work struct for scheduling work to the message pump
-  * @queue_lock: spinlock to syncronise access to message queue
-  * @queue: message queue
-+ * @idling: the device is entering idle state
-  * @cur_msg: the currently in-flight message
-  * @cur_msg_prepared: spi_prepare_message was called for the currently
-  *                    in-flight message
-@@ -425,6 +426,7 @@ struct spi_master {
- 	spinlock_t			queue_lock;
- 	struct list_head		queue;
- 	struct spi_message		*cur_msg;
-+	bool				idling;
- 	bool				busy;
- 	bool				running;
- 	bool				rt;
--- a/target/linux/generic/pending-3.18/092-03-spi-Only-idle-the-message-pump-in-the-worker-kthread.patch	2022-03-22 08:54:47.281464793 +0800
+++ b/target/linux/generic/pending-3.18/092-03-spi-Only-idle-the-message-pump-in-the-worker-kthread.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,83 +0,0 @@
-From: Mark Brown <broonie@kernel.org>
-Date: Wed, 10 Dec 2014 13:46:33 +0000
-Subject: [PATCH] spi: Only idle the message pump in the worker kthread
-
-In order to avoid the situation where the kthread is waiting for another
-context to make the hardware idle let the message pump know if it's being
-called from the worker thread context and if it isn't then defer to the
-worker thread instead of idling the hardware immediately. This will ensure
-that if this situation happens we block rather than busy waiting.
-
-Signed-off-by: Mark Brown <broonie@kernel.org>
----
-
---- a/drivers/spi/spi.c
-+++ b/drivers/spi/spi.c
-@@ -875,8 +875,9 @@ void spi_finalize_current_transfer(struc
- EXPORT_SYMBOL_GPL(spi_finalize_current_transfer);
- 
- /**
-- * spi_pump_messages - kthread work function which processes spi message queue
-- * @work: pointer to kthread work struct contained in the master struct
-+ * __spi_pump_messages - function which processes spi message queue
-+ * @master: master to process queue for
-+ * @in_kthread: true if we are in the context of the message pump thread
-  *
-  * This function checks if there is any spi message in the queue that
-  * needs processing and if so call out to the driver to initialize hardware
-@@ -886,10 +887,8 @@ EXPORT_SYMBOL_GPL(spi_finalize_current_t
-  * inside spi_sync(); the queue extraction handling at the top of the
-  * function should deal with this safely.
-  */
--static void spi_pump_messages(struct kthread_work *work)
-+static void __spi_pump_messages(struct spi_master *master, bool in_kthread)
- {
--	struct spi_master *master =
--		container_of(work, struct spi_master, pump_messages);
- 	unsigned long flags;
- 	bool was_busy = false;
- 	int ret;
-@@ -916,6 +915,15 @@ static void spi_pump_messages(struct kth
- 			spin_unlock_irqrestore(&master->queue_lock, flags);
- 			return;
- 		}
-+
-+		/* Only do teardown in the thread */
-+		if (!in_kthread) {
-+			queue_kthread_work(&master->kworker,
-+					   &master->pump_messages);
-+			spin_unlock_irqrestore(&master->queue_lock, flags);
-+			return;
-+		}
-+
- 		master->busy = false;
- 		master->idling = true;
- 		spin_unlock_irqrestore(&master->queue_lock, flags);
-@@ -1004,6 +1012,18 @@ static void spi_pump_messages(struct kth
- 	}
- }
- 
-+/**
-+ * spi_pump_messages - kthread work function which processes spi message queue
-+ * @work: pointer to kthread work struct contained in the master struct
-+ */
-+static void spi_pump_messages(struct kthread_work *work)
-+{
-+	struct spi_master *master =
-+		container_of(work, struct spi_master, pump_messages);
-+
-+	__spi_pump_messages(master, true);
-+}
-+
- static int spi_init_queue(struct spi_master *master)
- {
- 	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };
-@@ -2165,7 +2185,7 @@ static int __spi_sync(struct spi_device
- 		 * can.
- 		 */
- 		if (master->transfer == spi_queued_transfer)
--			spi_pump_messages(&master->pump_messages);
-+			__spi_pump_messages(master, false);
- 
- 		wait_for_completion(&done);
- 		status = message->status;
--- a/target/linux/generic/pending-3.18/095-api-fix-compatibility-of-linux-in.h-with-netinet-in..patch	2022-03-22 08:54:47.281464793 +0800
+++ b/target/linux/generic/pending-3.18/095-api-fix-compatibility-of-linux-in.h-with-netinet-in..patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,146 +0,0 @@
-From 279c6c7fa64f5763e6b9f05e7ab3840092e702e7 Mon Sep 17 00:00:00 2001
-From: Stephen Hemminger <stephen@networkplumber.org>
-Date: Mon, 29 Jun 2015 14:57:48 -1000
-Subject: [PATCH] api: fix compatibility of linux/in.h with netinet/in.h
-
-u
-This fixes breakage to iproute2 build with recent kernel headers
-caused by:
-   commit a263653ed798216c0069922d7b5237ca49436007
-   Author: Pablo Neira Ayuso <pablo@netfilter.org>
-   Date:   Wed Jun 17 10:28:27 2015 -0500
-
-   netfilter: don't pull include/linux/netfilter.h from netns headers
-
-The issue is that definitions in linux/in.h overlap with those
-in netinet/in.h. This patch solves this by introducing the same
-mechanism as was used to solve the same problem with linux/in6.h
-
-Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- include/uapi/linux/in.h          | 16 +++++++++++++---
- include/uapi/linux/libc-compat.h | 22 ++++++++++++++++++++++
- 2 files changed, 35 insertions(+), 3 deletions(-)
-
---- a/include/uapi/linux/in.h
-+++ b/include/uapi/linux/in.h
-@@ -19,8 +19,10 @@
- #define _UAPI_LINUX_IN_H
- 
- #include <linux/types.h>
-+#include <linux/libc-compat.h>
- #include <linux/socket.h>
- 
-+#if __UAPI_DEF_IN_IPPROTO
- /* Standard well-defined IP protocols.  */
- enum {
-   IPPROTO_IP = 0,		/* Dummy protocol for TCP		*/
-@@ -73,12 +75,14 @@ enum {
- #define IPPROTO_RAW		IPPROTO_RAW
-   IPPROTO_MAX
- };
-+#endif
- 
--
-+#if __UAPI_DEF_IN_ADDR
- /* Internet address. */
- struct in_addr {
- 	__be32	s_addr;
- };
-+#endif
- 
- #define IP_TOS		1
- #define IP_TTL		2
-@@ -154,6 +158,7 @@ struct in_addr {
- 
- /* Request struct for multicast socket ops */
- 
-+#if __UAPI_DEF_IP_MREQ
- struct ip_mreq  {
- 	struct in_addr imr_multiaddr;	/* IP multicast address of group */
- 	struct in_addr imr_interface;	/* local IP address of interface */
-@@ -205,14 +210,18 @@ struct group_filter {
- #define GROUP_FILTER_SIZE(numsrc) \
- 	(sizeof(struct group_filter) - sizeof(struct __kernel_sockaddr_storage) \
- 	+ (numsrc) * sizeof(struct __kernel_sockaddr_storage))
-+#endif
- 
-+#if __UAPI_DEF_IN_PKTINFO
- struct in_pktinfo {
- 	int		ipi_ifindex;
- 	struct in_addr	ipi_spec_dst;
- 	struct in_addr	ipi_addr;
- };
-+#endif
- 
- /* Structure describing an Internet (IP) socket address. */
-+#if  __UAPI_DEF_SOCKADDR_IN
- #define __SOCK_SIZE__	16		/* sizeof(struct sockaddr)	*/
- struct sockaddr_in {
-   __kernel_sa_family_t	sin_family;	/* Address family		*/
-@@ -224,8 +233,9 @@ struct sockaddr_in {
- 			sizeof(unsigned short int) - sizeof(struct in_addr)];
- };
- #define sin_zero	__pad		/* for BSD UNIX comp. -FvK	*/
-+#endif
- 
--
-+#if __UAPI_DEF_IN_CLASS
- /*
-  * Definitions of the bits in an Internet address integer.
-  * On subnets, host and network parts are found according
-@@ -276,7 +286,7 @@ struct sockaddr_in {
- #define INADDR_ALLHOSTS_GROUP 	0xe0000001U	/* 224.0.0.1   */
- #define INADDR_ALLRTRS_GROUP    0xe0000002U	/* 224.0.0.2 */
- #define INADDR_MAX_LOCAL_GROUP  0xe00000ffU	/* 224.0.0.255 */
--
-+#endif
- 
- /* <asm/byteorder.h> contains the htonl type stuff.. */
- #include <asm/byteorder.h> 
---- a/include/uapi/linux/libc-compat.h
-+++ b/include/uapi/linux/libc-compat.h
-@@ -56,6 +56,13 @@
- 
- /* GLIBC headers included first so don't define anything
-  * that would already be defined. */
-+#define __UAPI_DEF_IN_ADDR		0
-+#define __UAPI_DEF_IN_IPPROTO		0
-+#define __UAPI_DEF_IN_PKTINFO		0
-+#define __UAPI_DEF_IP_MREQ		0
-+#define __UAPI_DEF_SOCKADDR_IN		0
-+#define __UAPI_DEF_IN_CLASS		0
-+
- #define __UAPI_DEF_IN6_ADDR		0
- /* The exception is the in6_addr macros which must be defined
-  * if the glibc code didn't define them. This guard matches
-@@ -76,6 +83,13 @@
- /* Linux headers included first, and we must define everything
-  * we need. The expectation is that glibc will check the
-  * __UAPI_DEF_* defines and adjust appropriately. */
-+#define __UAPI_DEF_IN_ADDR		1
-+#define __UAPI_DEF_IN_IPPROTO		1
-+#define __UAPI_DEF_IN_PKTINFO		1
-+#define __UAPI_DEF_IP_MREQ		1
-+#define __UAPI_DEF_SOCKADDR_IN		1
-+#define __UAPI_DEF_IN_CLASS		1
-+
- #define __UAPI_DEF_IN6_ADDR		1
- /* We unconditionally define the in6_addr macros and glibc must
-  * coordinate. */
-@@ -99,6 +113,14 @@
-  * that we need. */
- #else /* !defined(__GLIBC__) */
- 
-+/* Definitions for in.h */
-+#define __UAPI_DEF_IN_ADDR		1
-+#define __UAPI_DEF_IN_IPPROTO		1
-+#define __UAPI_DEF_IN_PKTINFO		1
-+#define __UAPI_DEF_IP_MREQ		1
-+#define __UAPI_DEF_SOCKADDR_IN		1
-+#define __UAPI_DEF_IN_CLASS		1
-+
- /* Definitions for in6.h */
- #define __UAPI_DEF_IN6_ADDR		1
- #define __UAPI_DEF_IN6_ADDR_ALT		1
--- a/target/linux/generic/pending-3.18/099-module_arch_freeing_init-new-hook-for-archs-before-m.patch	2022-03-22 08:54:47.281464793 +0800
+++ b/target/linux/generic/pending-3.18/099-module_arch_freeing_init-new-hook-for-archs-before-m.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,182 +0,0 @@
-From: Rusty Russell <rusty@rustcorp.com.au>
-Date: Tue, 20 Jan 2015 09:07:04 +1030
-Subject: [PATCH] module_arch_freeing_init(): new hook for archs before module->module_init freed.
-
-Archs have been abusing module_free() to clean up their arch-specific
-allocations.  Since module_free() is also (ab)used by BPF and trace code,
-let's keep it to simple allocations, and provide a hook called before
-that.
-
-This means that avr32, ia64, parisc and s390 no longer need to implement
-their own module_free() at all.  avr32 doesn't need module_finalize()
-either.
-
-Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
-Cc: Chris Metcalf <cmetcalf@ezchip.com>
-Cc: Haavard Skinnemoen <hskinnemoen@gmail.com>
-Cc: Hans-Christian Egtvedt <egtvedt@samfundet.no>
-Cc: Tony Luck <tony.luck@intel.com>
-Cc: Fenghua Yu <fenghua.yu@intel.com>
-Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
-Cc: Helge Deller <deller@gmx.de>
-Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
-Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
-Cc: linux-kernel@vger.kernel.org
-Cc: linux-ia64@vger.kernel.org
-Cc: linux-parisc@vger.kernel.org
-Cc: linux-s390@vger.kernel.org
-
-Origin: backport, https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=d453cded05ee219b77815ea194dc36efa5398bca
----
- arch/avr32/kernel/module.c   | 13 +------------
- arch/ia64/kernel/module.c    |  6 ++----
- arch/parisc/kernel/module.c  |  6 +-----
- arch/s390/kernel/module.c    | 10 +++-------
- arch/tile/kernel/module.c    |  2 +-
- include/linux/moduleloader.h |  2 ++
- kernel/module.c              |  7 +++++++
- 7 files changed, 17 insertions(+), 29 deletions(-)
-
---- a/arch/avr32/kernel/module.c
-+++ b/arch/avr32/kernel/module.c
-@@ -19,12 +19,10 @@
- #include <linux/moduleloader.h>
- #include <linux/vmalloc.h>
- 
--void module_free(struct module *mod, void *module_region)
-+void module_arch_freeing_init(struct module *mod)
- {
- 	vfree(mod->arch.syminfo);
- 	mod->arch.syminfo = NULL;
--
--	vfree(module_region);
- }
- 
- static inline int check_rela(Elf32_Rela *rela, struct module *module,
-@@ -291,12 +289,3 @@ int apply_relocate_add(Elf32_Shdr *sechd
- 
- 	return ret;
- }
--
--int module_finalize(const Elf_Ehdr *hdr, const Elf_Shdr *sechdrs,
--		    struct module *module)
--{
--	vfree(module->arch.syminfo);
--	module->arch.syminfo = NULL;
--
--	return 0;
--}
---- a/arch/ia64/kernel/module.c
-+++ b/arch/ia64/kernel/module.c
-@@ -305,14 +305,12 @@ plt_target (struct plt_entry *plt)
- #endif /* !USE_BRL */
- 
- void
--module_free (struct module *mod, void *module_region)
-+module_arch_freeing_init (struct module *mod)
- {
--	if (mod && mod->arch.init_unw_table &&
--	    module_region == mod->module_init) {
-+	if (mod->arch.init_unw_table) {
- 		unw_remove_unwind_table(mod->arch.init_unw_table);
- 		mod->arch.init_unw_table = NULL;
- 	}
--	vfree(module_region);
- }
- 
- /* Have we already seen one of these relocations? */
---- a/arch/parisc/kernel/module.c
-+++ b/arch/parisc/kernel/module.c
-@@ -298,14 +298,10 @@ static inline unsigned long count_stubs(
- }
- #endif
- 
--
--/* Free memory returned from module_alloc */
--void module_free(struct module *mod, void *module_region)
-+void module_arch_freeing_init(struct module *mod)
- {
- 	kfree(mod->arch.section);
- 	mod->arch.section = NULL;
--
--	vfree(module_region);
- }
- 
- /* Additional bytes needed in front of individual sections */
---- a/arch/s390/kernel/module.c
-+++ b/arch/s390/kernel/module.c
-@@ -55,14 +55,10 @@ void *module_alloc(unsigned long size)
- }
- #endif
- 
--/* Free memory returned from module_alloc */
--void module_free(struct module *mod, void *module_region)
-+void module_arch_freeing_init(struct module *mod)
- {
--	if (mod) {
--		vfree(mod->arch.syminfo);
--		mod->arch.syminfo = NULL;
--	}
--	vfree(module_region);
-+	vfree(mod->arch.syminfo);
-+	mod->arch.syminfo = NULL;
- }
- 
- static void check_rela(Elf_Rela *rela, struct module *me)
---- a/arch/tile/kernel/module.c
-+++ b/arch/tile/kernel/module.c
-@@ -83,7 +83,7 @@ void module_free(struct module *mod, voi
- 		     0, 0, 0, NULL, NULL, 0);
- 
- 	/*
--	 * FIXME: If module_region == mod->module_init, trim exception
-+	 * FIXME: Add module_arch_freeing_init to trim exception
- 	 * table entries.
- 	 */
- }
---- a/include/linux/moduleloader.h
-+++ b/include/linux/moduleloader.h
-@@ -82,4 +82,6 @@ int module_finalize(const Elf_Ehdr *hdr,
- /* Any cleanup needed when module leaves. */
- void module_arch_cleanup(struct module *mod);
- 
-+/* Any cleanup before freeing mod->module_init */
-+void module_arch_freeing_init(struct module *mod);
- #endif
---- a/kernel/module.c
-+++ b/kernel/module.c
-@@ -1840,6 +1840,10 @@ void __weak module_arch_cleanup(struct m
- {
- }
- 
-+void __weak module_arch_freeing_init(struct module *mod)
-+{
-+}
-+
- /* Free a module, remove from lists, etc. */
- static void free_module(struct module *mod)
- {
-@@ -1872,6 +1876,7 @@ static void free_module(struct module *m
- 
- 	/* This may be NULL, but that's OK */
- 	unset_module_init_ro_nx(mod);
-+	module_arch_freeing_init(mod);
- 	module_free(mod, mod->module_init);
- 	kfree(mod->args);
- 	percpu_modfree(mod);
-@@ -2983,6 +2988,7 @@ static struct module *layout_and_allocat
- static void module_deallocate(struct module *mod, struct load_info *info)
- {
- 	percpu_modfree(mod);
-+	module_arch_freeing_init(mod);
- 	module_free(mod, mod->module_init);
- 	module_free(mod, mod->module_core);
- }
-@@ -3105,6 +3111,7 @@ static int do_init_module(struct module
- 	rcu_assign_pointer(mod->kallsyms, &mod->core_kallsyms);
- #endif
- 	unset_module_init_ro_nx(mod);
-+	module_arch_freeing_init(mod);
- 	module_free(mod, mod->module_init);
- 	mod->module_init = NULL;
- 	mod->init_size = 0;
--- a/target/linux/generic/pending-3.18/102-ehci_hcd_ignore_oc.patch	2022-03-22 08:54:47.282464794 +0800
+++ b/target/linux/generic/pending-3.18/102-ehci_hcd_ignore_oc.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,82 +0,0 @@
-From 1e311820ec3055e3f08e687de6564692a7cec675 Mon Sep 17 00:00:00 2001
-From: Florian Fainelli <florian@openwrt.org>
-Date: Mon, 28 Jan 2013 20:06:29 +0100
-Subject: [PATCH 11/12] USB: EHCI: add ignore_oc flag to disable overcurrent
- checking
-
-This patch adds an ignore_oc flag which can be set by EHCI controller
-not supporting or wanting to disable overcurrent checking. The EHCI
-platform data in include/linux/usb/ehci_pdriver.h is also augmented to
-take advantage of this new flag.
-
-Signed-off-by: Florian Fainelli <florian@openwrt.org>
----
- drivers/usb/host/ehci-hcd.c      |    2 +-
- drivers/usb/host/ehci-hub.c      |    4 ++--
- drivers/usb/host/ehci-platform.c |    1 +
- drivers/usb/host/ehci.h          |    1 +
- include/linux/usb/ehci_pdriver.h |    1 +
- 5 files changed, 6 insertions(+), 3 deletions(-)
-
---- a/drivers/usb/host/ehci-hcd.c
-+++ b/drivers/usb/host/ehci-hcd.c
-@@ -633,7 +633,7 @@ static int ehci_run (struct usb_hcd *hcd
- 		"USB %x.%x started, EHCI %x.%02x%s\n",
- 		((ehci->sbrn & 0xf0)>>4), (ehci->sbrn & 0x0f),
- 		temp >> 8, temp & 0xff,
--		ignore_oc ? ", overcurrent ignored" : "");
-+		(ignore_oc || ehci->ignore_oc) ? ", overcurrent ignored" : "");
- 
- 	ehci_writel(ehci, INTR_MASK,
- 		    &ehci->regs->intr_enable); /* Turn On Interrupts */
---- a/drivers/usb/host/ehci-hub.c
-+++ b/drivers/usb/host/ehci-hub.c
-@@ -635,7 +635,7 @@ ehci_hub_status_data (struct usb_hcd *hc
- 	 * always set, seem to clear PORT_OCC and PORT_CSC when writing to
- 	 * PORT_POWER; that's surprising, but maybe within-spec.
- 	 */
--	if (!ignore_oc)
-+	if (!ignore_oc && !ehci->ignore_oc)
- 		mask = PORT_CSC | PORT_PEC | PORT_OCC;
- 	else
- 		mask = PORT_CSC | PORT_PEC;
-@@ -995,7 +995,7 @@ int ehci_hub_control(
- 		if (temp & PORT_PEC)
- 			status |= USB_PORT_STAT_C_ENABLE << 16;
- 
--		if ((temp & PORT_OCC) && !ignore_oc){
-+		if ((temp & PORT_OCC) && (!ignore_oc && !ehci->ignore_oc)){
- 			status |= USB_PORT_STAT_C_OVERCURRENT << 16;
- 
- 			/*
---- a/drivers/usb/host/ehci-platform.c
-+++ b/drivers/usb/host/ehci-platform.c
-@@ -226,6 +226,8 @@ static int ehci_platform_probe(struct pl
- 		ehci->big_endian_desc = 1;
- 	if (pdata->big_endian_mmio)
- 		ehci->big_endian_mmio = 1;
-+	if (pdata->ignore_oc)
-+		ehci->ignore_oc = 1;
- 
- #ifndef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO
- 	if (ehci->big_endian_mmio) {
---- a/drivers/usb/host/ehci.h
-+++ b/drivers/usb/host/ehci.h
-@@ -226,6 +226,7 @@ struct ehci_hcd {			/* one per controlle
- 	unsigned		frame_index_bug:1; /* MosChip (AKA NetMos) */
- 	unsigned		need_oc_pp_cycle:1; /* MPC834X port power */
- 	unsigned		imx28_write_fix:1; /* For Freescale i.MX28 */
-+	unsigned		ignore_oc:1;
- 
- 	/* required for usb32 quirk */
- 	#define OHCI_CTRL_HCFS          (3 << 6)
---- a/include/linux/usb/ehci_pdriver.h
-+++ b/include/linux/usb/ehci_pdriver.h
-@@ -45,6 +45,7 @@ struct usb_ehci_pdata {
- 	unsigned	big_endian_desc:1;
- 	unsigned	big_endian_mmio:1;
- 	unsigned	no_io_watchdog:1;
-+	unsigned	ignore_oc:1;
- 
- 	/* Turn on all power and clocks */
- 	int (*power_on)(struct platform_device *pdev);
--- a/target/linux/generic/pending-3.18/110-jffs2-use-.rename2-and-add-RENAME_WHITEOUT-support.patch	2022-03-22 08:54:47.282464794 +0800
+++ b/target/linux/generic/pending-3.18/110-jffs2-use-.rename2-and-add-RENAME_WHITEOUT-support.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,86 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 10 Apr 2015 13:35:29 +0200
-Subject: [PATCH] jffs2: use .rename2 and add RENAME_WHITEOUT support
-
-It is required for renames on overlayfs
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/fs/jffs2/dir.c
-+++ b/fs/jffs2/dir.c
-@@ -35,7 +35,7 @@ static int jffs2_mkdir (struct inode *,s
- static int jffs2_rmdir (struct inode *,struct dentry *);
- static int jffs2_mknod (struct inode *,struct dentry *,umode_t,dev_t);
- static int jffs2_rename (struct inode *, struct dentry *,
--			 struct inode *, struct dentry *);
-+			 struct inode *, struct dentry *, unsigned int);
- 
- const struct file_operations jffs2_dir_operations =
- {
-@@ -57,7 +57,7 @@ const struct inode_operations jffs2_dir_
- 	.mkdir =	jffs2_mkdir,
- 	.rmdir =	jffs2_rmdir,
- 	.mknod =	jffs2_mknod,
--	.rename =	jffs2_rename,
-+	.rename2 =	jffs2_rename,
- 	.get_acl =	jffs2_get_acl,
- 	.set_acl =	jffs2_set_acl,
- 	.setattr =	jffs2_setattr,
-@@ -752,8 +752,27 @@ static int jffs2_mknod (struct inode *di
- 	return ret;
- }
- 
-+static int jffs2_whiteout(struct inode *old_dir, struct dentry *old_dentry)
-+{
-+	struct dentry *wh;
-+	int err;
-+
-+	wh = d_alloc(old_dentry->d_parent, &old_dentry->d_name);
-+	if (!wh)
-+		return -ENOMEM;
-+
-+	err = jffs2_mknod(old_dir, wh, S_IFCHR | WHITEOUT_MODE,
-+			  WHITEOUT_DEV);
-+	if (err)
-+		return err;
-+
-+	d_rehash(wh);
-+	return 0;
-+}
-+
- static int jffs2_rename (struct inode *old_dir_i, struct dentry *old_dentry,
--			 struct inode *new_dir_i, struct dentry *new_dentry)
-+			 struct inode *new_dir_i, struct dentry *new_dentry,
-+			 unsigned int flags)
- {
- 	int ret;
- 	struct jffs2_sb_info *c = JFFS2_SB_INFO(old_dir_i->i_sb);
-@@ -761,6 +780,9 @@ static int jffs2_rename (struct inode *o
- 	uint8_t type;
- 	uint32_t now;
- 
-+	if (flags & ~RENAME_WHITEOUT)
-+		return -EINVAL;
-+
- 	/* The VFS will check for us and prevent trying to rename a
- 	 * file over a directory and vice versa, but if it's a directory,
- 	 * the VFS can't check whether the victim is empty. The filesystem
-@@ -824,9 +846,14 @@ static int jffs2_rename (struct inode *o
- 	if (S_ISDIR(old_dentry->d_inode->i_mode) && !victim_f)
- 		inc_nlink(new_dir_i);
- 
--	/* Unlink the original */
--	ret = jffs2_do_unlink(c, JFFS2_INODE_INFO(old_dir_i),
--			      old_dentry->d_name.name, old_dentry->d_name.len, NULL, now);
-+	if (flags & RENAME_WHITEOUT)
-+		/* Replace with whiteout */
-+		ret = jffs2_whiteout(old_dir_i, old_dentry);
-+	else
-+		/* Unlink the original */
-+		ret = jffs2_do_unlink(c, JFFS2_INODE_INFO(old_dir_i),
-+				      old_dentry->d_name.name,
-+				      old_dentry->d_name.len, NULL, now);
- 
- 	/* We don't touch inode->i_nlink */
- 
--- a/target/linux/generic/pending-3.18/111-jffs2-add-RENAME_EXCHANGE-support.patch	2022-03-22 08:54:47.282464794 +0800
+++ b/target/linux/generic/pending-3.18/111-jffs2-add-RENAME_EXCHANGE-support.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,58 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 25 Apr 2015 12:41:32 +0200
-Subject: [PATCH] jffs2: add RENAME_EXCHANGE support
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/fs/jffs2/dir.c
-+++ b/fs/jffs2/dir.c
-@@ -780,7 +780,7 @@ static int jffs2_rename (struct inode *o
- 	uint8_t type;
- 	uint32_t now;
- 
--	if (flags & ~RENAME_WHITEOUT)
-+	if (flags & ~(RENAME_WHITEOUT | RENAME_EXCHANGE))
- 		return -EINVAL;
- 
- 	/* The VFS will check for us and prevent trying to rename a
-@@ -788,7 +788,7 @@ static int jffs2_rename (struct inode *o
- 	 * the VFS can't check whether the victim is empty. The filesystem
- 	 * needs to do that for itself.
- 	 */
--	if (new_dentry->d_inode) {
-+	if (new_dentry->d_inode && !(flags & RENAME_EXCHANGE)) {
- 		victim_f = JFFS2_INODE_INFO(new_dentry->d_inode);
- 		if (S_ISDIR(new_dentry->d_inode->i_mode)) {
- 			struct jffs2_full_dirent *fd;
-@@ -823,7 +823,7 @@ static int jffs2_rename (struct inode *o
- 	if (ret)
- 		return ret;
- 
--	if (victim_f) {
-+	if (victim_f && !(flags & RENAME_EXCHANGE)) {
- 		/* There was a victim. Kill it off nicely */
- 		if (S_ISDIR(new_dentry->d_inode->i_mode))
- 			clear_nlink(new_dentry->d_inode);
-@@ -849,6 +849,12 @@ static int jffs2_rename (struct inode *o
- 	if (flags & RENAME_WHITEOUT)
- 		/* Replace with whiteout */
- 		ret = jffs2_whiteout(old_dir_i, old_dentry);
-+	else if (flags & RENAME_EXCHANGE)
-+		/* Replace the original */
-+		ret = jffs2_do_link(c, JFFS2_INODE_INFO(old_dir_i),
-+				    new_dentry->d_inode->i_ino, type,
-+				    old_dentry->d_name.name, old_dentry->d_name.len,
-+				    now);
- 	else
- 		/* Unlink the original */
- 		ret = jffs2_do_unlink(c, JFFS2_INODE_INFO(old_dir_i),
-@@ -875,7 +881,7 @@ static int jffs2_rename (struct inode *o
- 		return ret;
- 	}
- 
--	if (S_ISDIR(old_dentry->d_inode->i_mode))
-+	if (S_ISDIR(old_dentry->d_inode->i_mode) && !(flags & RENAME_EXCHANGE))
- 		drop_nlink(old_dir_i);
- 
- 	new_dir_i->i_mtime = new_dir_i->i_ctime = old_dir_i->i_mtime = old_dir_i->i_ctime = ITIME(now);
--- a/target/linux/generic/pending-3.18/120-bridge_allow_receiption_on_disabled_port.patch	2022-03-22 08:54:47.283464796 +0800
+++ b/target/linux/generic/pending-3.18/120-bridge_allow_receiption_on_disabled_port.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,54 +0,0 @@
-From: Stephen Hemminger <stephen@networkplumber.org>
-Subject: bridge: allow receiption on disabled port
-
-When an ethernet device is enslaved to a bridge, and the bridge STP
-detects loss of carrier (or operational state down), then normally
-packet receiption is blocked.
-
-This breaks control applications like WPA which maybe expecting to
-receive packets to negotiate to bring link up. The bridge needs to
-block forwarding packets from these disabled ports, but there is no
-hard requirement to not allow local packet delivery.
-
-Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
-
---- a/net/bridge/br_input.c
-+++ b/net/bridge/br_input.c
-@@ -146,11 +146,13 @@ EXPORT_SYMBOL_GPL(br_handle_frame_finish
- static int br_handle_local_finish(struct sk_buff *skb)
- {
- 	struct net_bridge_port *p = br_port_get_rcu(skb->dev);
--	u16 vid = 0;
-+	if (p->state != BR_STATE_DISABLED) {
-+		u16 vid = 0;
- 
--	/* check if vlan is allowed, to avoid spoofing */
--	if (p->flags & BR_LEARNING && br_should_learn(p, skb, &vid))
--		br_fdb_update(p->br, p, eth_hdr(skb)->h_source, vid, false);
-+		/* check if vlan is allowed, to avoid spoofing */
-+		if (p->flags & BR_LEARNING && br_should_learn(p, skb, &vid))
-+			br_fdb_update(p->br, p, eth_hdr(skb)->h_source, vid, false);
-+	}
- 	return 0;	 /* process further */
- }
- 
-@@ -224,6 +226,18 @@ rx_handler_result_t br_handle_frame(stru
- 
- forward:
- 	switch (p->state) {
-+	case BR_STATE_DISABLED:
-+		if (ether_addr_equal(p->br->dev->dev_addr, dest))
-+			skb->pkt_type = PACKET_HOST;
-+
-+		if (NF_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING, skb, skb->dev, NULL,
-+			br_handle_local_finish))
-+			break;
-+
-+		BR_INPUT_SKB_CB(skb)->brdev = p->br->dev;
-+		br_pass_frame_up(skb);
-+		break;
-+
- 	case BR_STATE_FORWARDING:
- 		rhook = rcu_dereference(br_should_route_hook);
- 		if (rhook) {
--- a/target/linux/generic/pending-3.18/132-mips_inline_dma_ops.patch	2022-03-22 08:54:47.284464798 +0800
+++ b/target/linux/generic/pending-3.18/132-mips_inline_dma_ops.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,688 +0,0 @@
-From 2c58080407554e1bac8fd50d23cb02420524caed Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Mon, 12 Aug 2013 12:50:22 +0200
-Subject: [PATCH] MIPS: partially inline dma ops
-
-Several DMA ops are no-op on many platforms, and the indirection through
-the mips_dma_map_ops function table is causing the compiler to emit
-unnecessary code.
-
-Inlining visibly improves network performance in my tests (on a 24Kc
-based system), and also slightly reduces code size of a few drivers.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- arch/mips/Kconfig                   |   4 +
- arch/mips/include/asm/dma-mapping.h | 360 +++++++++++++++++++++++++++++++++++-
- arch/mips/mm/dma-default.c          | 163 ++--------------
- 3 files changed, 373 insertions(+), 154 deletions(-)
-
---- a/arch/mips/Kconfig
-+++ b/arch/mips/Kconfig
-@@ -1453,6 +1453,7 @@ config CPU_CAVIUM_OCTEON
- 	select CPU_SUPPORTS_HUGEPAGES
- 	select USB_EHCI_BIG_ENDIAN_MMIO
- 	select MIPS_L1_CACHE_SHIFT_7
-+	select SYS_HAS_DMA_OPS
- 	help
- 	  The Cavium Octeon processor is a highly integrated chip containing
- 	  many ethernet hardware widgets for networking tasks. The processor
-@@ -1708,6 +1709,9 @@ config MIPS_MALTA_PM
- 	bool
- 	default y
- 
-+config SYS_HAS_DMA_OPS
-+	bool
-+
- #
- # CPU may reorder R->R, R->W, W->R, W->W
- # Reordering beyond LL and SC is handled in WEAK_REORDERING_BEYOND_LLSC
---- a/arch/mips/include/asm/dma-mapping.h
-+++ b/arch/mips/include/asm/dma-mapping.h
-@@ -1,9 +1,16 @@
- #ifndef _ASM_DMA_MAPPING_H
- #define _ASM_DMA_MAPPING_H
- 
-+#include <linux/kmemcheck.h>
-+#include <linux/bug.h>
-+#include <linux/scatterlist.h>
-+#include <linux/dma-debug.h>
-+#include <linux/dma-attrs.h>
-+
- #include <asm/scatterlist.h>
- #include <asm/dma-coherence.h>
- #include <asm/cache.h>
-+#include <asm/cpu-type.h>
- #include <asm-generic/dma-coherent.h>
- 
- #ifndef CONFIG_SGI_IP27 /* Kludge to fix 2.6.39 build for IP27 */
-@@ -12,12 +19,48 @@
- 
- extern struct dma_map_ops *mips_dma_map_ops;
- 
-+void __dma_sync(struct page *page, unsigned long offset, size_t size,
-+		enum dma_data_direction direction);
-+void *mips_dma_alloc_coherent(struct device *dev, size_t size,
-+			      dma_addr_t *dma_handle, gfp_t gfp,
-+			      struct dma_attrs *attrs);
-+void mips_dma_free_coherent(struct device *dev, size_t size, void *vaddr,
-+			    dma_addr_t dma_handle, struct dma_attrs *attrs);
-+
- static inline struct dma_map_ops *get_dma_ops(struct device *dev)
- {
-+#ifdef CONFIG_SYS_HAS_DMA_OPS
- 	if (dev && dev->archdata.dma_ops)
- 		return dev->archdata.dma_ops;
- 	else
- 		return mips_dma_map_ops;
-+#else
-+	return NULL;
-+#endif
-+}
-+
-+/*
-+ * Warning on the terminology - Linux calls an uncached area coherent;
-+ * MIPS terminology calls memory areas with hardware maintained coherency
-+ * coherent.
-+ */
-+
-+static inline int cpu_needs_post_dma_flush(struct device *dev)
-+{
-+#ifndef CONFIG_SYS_HAS_CPU_R10000
-+	return 0;
-+#endif
-+	return !plat_device_is_coherent(dev) &&
-+	       (boot_cpu_type() == CPU_R10000 ||
-+		boot_cpu_type() == CPU_R12000 ||
-+		boot_cpu_type() == CPU_BMIPS5000);
-+}
-+
-+static inline struct page *dma_addr_to_page(struct device *dev,
-+	dma_addr_t dma_addr)
-+{
-+	return pfn_to_page(
-+		plat_dma_addr_to_phys(dev, dma_addr) >> PAGE_SHIFT);
- }
- 
- static inline bool dma_capable(struct device *dev, dma_addr_t addr, size_t size)
-@@ -30,12 +73,304 @@ static inline bool dma_capable(struct de
- 
- static inline void dma_mark_clean(void *addr, size_t size) {}
- 
--#include <asm-generic/dma-mapping-common.h>
-+static inline dma_addr_t dma_map_single_attrs(struct device *dev, void *ptr,
-+					      size_t size,
-+					      enum dma_data_direction dir,
-+					      struct dma_attrs *attrs)
-+{
-+	struct dma_map_ops *ops = get_dma_ops(dev);
-+	unsigned long offset = (unsigned long)ptr & ~PAGE_MASK;
-+	struct page *page = virt_to_page(ptr);
-+	dma_addr_t addr;
-+
-+	kmemcheck_mark_initialized(ptr, size);
-+	BUG_ON(!valid_dma_direction(dir));
-+	if (ops) {
-+		addr = ops->map_page(dev, page, offset, size, dir, attrs);
-+	} else {
-+		if (!plat_device_is_coherent(dev))
-+			__dma_sync(page, offset, size, dir);
-+
-+		addr = plat_map_dma_mem_page(dev, page) + offset;
-+	}
-+	debug_dma_map_page(dev, page, offset, size, dir, addr, true);
-+	return addr;
-+}
-+
-+static inline void dma_unmap_single_attrs(struct device *dev, dma_addr_t addr,
-+					  size_t size,
-+					  enum dma_data_direction dir,
-+					  struct dma_attrs *attrs)
-+{
-+	struct dma_map_ops *ops = get_dma_ops(dev);
-+
-+	BUG_ON(!valid_dma_direction(dir));
-+	if (ops) {
-+		ops->unmap_page(dev, addr, size, dir, attrs);
-+	} else {
-+		if (cpu_needs_post_dma_flush(dev))
-+			__dma_sync(dma_addr_to_page(dev, addr),
-+				   addr & ~PAGE_MASK, size, dir);
-+
-+		plat_unmap_dma_mem(dev, addr, size, dir);
-+	}
-+	debug_dma_unmap_page(dev, addr, size, dir, true);
-+}
-+
-+static inline int dma_map_sg_attrs(struct device *dev, struct scatterlist *sg,
-+				   int nents, enum dma_data_direction dir,
-+				   struct dma_attrs *attrs)
-+{
-+	struct dma_map_ops *ops = get_dma_ops(dev);
-+	int i, ents;
-+	struct scatterlist *s;
-+
-+	for_each_sg(sg, s, nents, i)
-+		kmemcheck_mark_initialized(sg_virt(s), s->length);
-+	BUG_ON(!valid_dma_direction(dir));
-+	if (ops) {
-+		ents = ops->map_sg(dev, sg, nents, dir, attrs);
-+	} else {
-+		for_each_sg(sg, s, nents, i) {
-+			struct page *page = sg_page(s);
-+
-+			if (!plat_device_is_coherent(dev))
-+				__dma_sync(page, s->offset, s->length, dir);
-+#ifdef CONFIG_NEED_SG_DMA_LENGTH
-+			s->dma_length = s->length;
-+#endif
-+			s->dma_address =
-+				plat_map_dma_mem_page(dev, page) + s->offset;
-+		}
-+		ents = nents;
-+	}
-+	debug_dma_map_sg(dev, sg, nents, ents, dir);
-+
-+	return ents;
-+}
-+
-+static inline void dma_unmap_sg_attrs(struct device *dev, struct scatterlist *sg,
-+				      int nents, enum dma_data_direction dir,
-+				      struct dma_attrs *attrs)
-+{
-+	struct dma_map_ops *ops = get_dma_ops(dev);
-+	struct scatterlist *s;
-+	int i;
-+
-+	BUG_ON(!valid_dma_direction(dir));
-+	debug_dma_unmap_sg(dev, sg, nents, dir);
-+	if (ops) {
-+		ops->unmap_sg(dev, sg, nents, dir, attrs);
-+		return;
-+	}
-+
-+	for_each_sg(sg, s, nents, i) {
-+		if (!plat_device_is_coherent(dev) && dir != DMA_TO_DEVICE)
-+			__dma_sync(sg_page(s), s->offset, s->length, dir);
-+		plat_unmap_dma_mem(dev, s->dma_address, s->length, dir);
-+	}
-+}
-+
-+static inline dma_addr_t dma_map_page(struct device *dev, struct page *page,
-+				      size_t offset, size_t size,
-+				      enum dma_data_direction dir)
-+{
-+	struct dma_map_ops *ops = get_dma_ops(dev);
-+	dma_addr_t addr;
-+
-+	kmemcheck_mark_initialized(page_address(page) + offset, size);
-+	BUG_ON(!valid_dma_direction(dir));
-+	if (ops) {
-+		addr = ops->map_page(dev, page, offset, size, dir, NULL);
-+	} else {
-+		if (!plat_device_is_coherent(dev))
-+			__dma_sync(page, offset, size, dir);
-+
-+		addr = plat_map_dma_mem_page(dev, page) + offset;
-+	}
-+	debug_dma_map_page(dev, page, offset, size, dir, addr, false);
-+
-+	return addr;
-+}
-+
-+static inline void dma_unmap_page(struct device *dev, dma_addr_t addr,
-+				  size_t size, enum dma_data_direction dir)
-+{
-+	struct dma_map_ops *ops = get_dma_ops(dev);
-+
-+	BUG_ON(!valid_dma_direction(dir));
-+	if (ops) {
-+		ops->unmap_page(dev, addr, size, dir, NULL);
-+	} else {
-+		if (cpu_needs_post_dma_flush(dev))
-+			__dma_sync(dma_addr_to_page(dev, addr),
-+				   addr & ~PAGE_MASK, size, dir);
-+
-+		plat_unmap_dma_mem(dev, addr, size, dir);
-+	}
-+	debug_dma_unmap_page(dev, addr, size, dir, false);
-+}
-+
-+static inline void dma_sync_single_for_cpu(struct device *dev, dma_addr_t addr,
-+					   size_t size,
-+					   enum dma_data_direction dir)
-+{
-+	struct dma_map_ops *ops = get_dma_ops(dev);
-+
-+	BUG_ON(!valid_dma_direction(dir));
-+	if (ops)
-+		ops->sync_single_for_cpu(dev, addr, size, dir);
-+	else if (cpu_needs_post_dma_flush(dev))
-+		__dma_sync(dma_addr_to_page(dev, addr),
-+			   addr & ~PAGE_MASK, size, dir);
-+	debug_dma_sync_single_for_cpu(dev, addr, size, dir);
-+}
-+
-+static inline void dma_sync_single_for_device(struct device *dev,
-+					      dma_addr_t addr, size_t size,
-+					      enum dma_data_direction dir)
-+{
-+	struct dma_map_ops *ops = get_dma_ops(dev);
-+
-+	BUG_ON(!valid_dma_direction(dir));
-+	if (ops)
-+		ops->sync_single_for_device(dev, addr, size, dir);
-+	else if (!plat_device_is_coherent(dev))
-+		__dma_sync(dma_addr_to_page(dev, addr),
-+			   addr & ~PAGE_MASK, size, dir);
-+	debug_dma_sync_single_for_device(dev, addr, size, dir);
-+}
-+
-+static inline void dma_sync_single_range_for_cpu(struct device *dev,
-+						 dma_addr_t addr,
-+						 unsigned long offset,
-+						 size_t size,
-+						 enum dma_data_direction dir)
-+{
-+	const struct dma_map_ops *ops = get_dma_ops(dev);
-+
-+	BUG_ON(!valid_dma_direction(dir));
-+	if (ops)
-+		ops->sync_single_for_cpu(dev, addr + offset, size, dir);
-+	else if (cpu_needs_post_dma_flush(dev))
-+		__dma_sync(dma_addr_to_page(dev, addr + offset),
-+			   (addr + offset) & ~PAGE_MASK, size, dir);
-+	debug_dma_sync_single_range_for_cpu(dev, addr, offset, size, dir);
-+}
-+
-+static inline void dma_sync_single_range_for_device(struct device *dev,
-+						    dma_addr_t addr,
-+						    unsigned long offset,
-+						    size_t size,
-+						    enum dma_data_direction dir)
-+{
-+	const struct dma_map_ops *ops = get_dma_ops(dev);
-+
-+	BUG_ON(!valid_dma_direction(dir));
-+	if (ops)
-+		ops->sync_single_for_device(dev, addr + offset, size, dir);
-+	else if (!plat_device_is_coherent(dev))
-+		__dma_sync(dma_addr_to_page(dev, addr + offset),
-+			   (addr + offset) & ~PAGE_MASK, size, dir);
-+	debug_dma_sync_single_range_for_device(dev, addr, offset, size, dir);
-+}
-+
-+static inline void
-+dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg,
-+		    int nelems, enum dma_data_direction dir)
-+{
-+	struct dma_map_ops *ops = get_dma_ops(dev);
-+	struct scatterlist *s;
-+	int i;
-+
-+	BUG_ON(!valid_dma_direction(dir));
-+	if (ops)
-+		ops->sync_sg_for_cpu(dev, sg, nelems, dir);
-+	else if (cpu_needs_post_dma_flush(dev)) {
-+		for_each_sg(sg, s, nelems, i)
-+			__dma_sync(sg_page(s), s->offset, s->length, dir);
-+	}
-+	debug_dma_sync_sg_for_cpu(dev, sg, nelems, dir);
-+}
-+
-+static inline void
-+dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg,
-+		       int nelems, enum dma_data_direction dir)
-+{
-+	struct dma_map_ops *ops = get_dma_ops(dev);
-+	struct scatterlist *s;
-+	int i;
-+
-+	BUG_ON(!valid_dma_direction(dir));
-+	if (ops)
-+		ops->sync_sg_for_device(dev, sg, nelems, dir);
-+	else if (!plat_device_is_coherent(dev)) {
-+		for_each_sg(sg, s, nelems, i)
-+			__dma_sync(sg_page(s), s->offset, s->length, dir);
-+	}
-+	debug_dma_sync_sg_for_device(dev, sg, nelems, dir);
-+
-+}
-+
-+#define dma_map_single(d, a, s, r) dma_map_single_attrs(d, a, s, r, NULL)
-+#define dma_unmap_single(d, a, s, r) dma_unmap_single_attrs(d, a, s, r, NULL)
-+#define dma_map_sg(d, s, n, r) dma_map_sg_attrs(d, s, n, r, NULL)
-+#define dma_unmap_sg(d, s, n, r) dma_unmap_sg_attrs(d, s, n, r, NULL)
-+
-+extern int dma_common_mmap(struct device *dev, struct vm_area_struct *vma,
-+			   void *cpu_addr, dma_addr_t dma_addr, size_t size);
-+
-+/**
-+ * dma_mmap_attrs - map a coherent DMA allocation into user space
-+ * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices
-+ * @vma: vm_area_struct describing requested user mapping
-+ * @cpu_addr: kernel CPU-view address returned from dma_alloc_attrs
-+ * @handle: device-view address returned from dma_alloc_attrs
-+ * @size: size of memory originally requested in dma_alloc_attrs
-+ * @attrs: attributes of mapping properties requested in dma_alloc_attrs
-+ *
-+ * Map a coherent DMA buffer previously allocated by dma_alloc_attrs
-+ * into user space.  The coherent DMA buffer must not be freed by the
-+ * driver until the user space mapping has been released.
-+ */
-+static inline int
-+dma_mmap_attrs(struct device *dev, struct vm_area_struct *vma, void *cpu_addr,
-+	       dma_addr_t dma_addr, size_t size, struct dma_attrs *attrs)
-+{
-+	struct dma_map_ops *ops = get_dma_ops(dev);
-+	BUG_ON(!ops);
-+	if (ops && ops->mmap)
-+		return ops->mmap(dev, vma, cpu_addr, dma_addr, size, attrs);
-+	return dma_common_mmap(dev, vma, cpu_addr, dma_addr, size);
-+}
-+
-+#define dma_mmap_coherent(d, v, c, h, s) dma_mmap_attrs(d, v, c, h, s, NULL)
-+
-+int
-+dma_common_get_sgtable(struct device *dev, struct sg_table *sgt,
-+		       void *cpu_addr, dma_addr_t dma_addr, size_t size);
-+
-+static inline int
-+dma_get_sgtable_attrs(struct device *dev, struct sg_table *sgt, void *cpu_addr,
-+		      dma_addr_t dma_addr, size_t size, struct dma_attrs *attrs)
-+{
-+	struct dma_map_ops *ops = get_dma_ops(dev);
-+	BUG_ON(!ops);
-+	if (ops && ops->get_sgtable)
-+		return ops->get_sgtable(dev, sgt, cpu_addr, dma_addr, size,
-+					attrs);
-+	return dma_common_get_sgtable(dev, sgt, cpu_addr, dma_addr, size);
-+}
-+
-+#define dma_get_sgtable(d, t, v, h, s) dma_get_sgtable_attrs(d, t, v, h, s, NULL)
-+
- 
- static inline int dma_supported(struct device *dev, u64 mask)
- {
- 	struct dma_map_ops *ops = get_dma_ops(dev);
--	return ops->dma_supported(dev, mask);
-+	if (ops)
-+		return ops->dma_supported(dev, mask);
-+	return plat_dma_supported(dev, mask);
- }
- 
- static inline int dma_mapping_error(struct device *dev, u64 mask)
-@@ -43,7 +378,9 @@ static inline int dma_mapping_error(stru
- 	struct dma_map_ops *ops = get_dma_ops(dev);
- 
- 	debug_dma_mapping_error(dev, mask);
--	return ops->mapping_error(dev, mask);
-+	if (ops)
-+		return ops->mapping_error(dev, mask);
-+	return 0;
- }
- 
- static inline int
-@@ -54,7 +391,7 @@ dma_set_mask(struct device *dev, u64 mas
- 	if(!dev->dma_mask || !dma_supported(dev, mask))
- 		return -EIO;
- 
--	if (ops->set_dma_mask)
-+	if (ops && ops->set_dma_mask)
- 		return ops->set_dma_mask(dev, mask);
- 
- 	*dev->dma_mask = mask;
-@@ -74,7 +411,11 @@ static inline void *dma_alloc_attrs(stru
- 	void *ret;
- 	struct dma_map_ops *ops = get_dma_ops(dev);
- 
--	ret = ops->alloc(dev, size, dma_handle, gfp, attrs);
-+	if (ops)
-+		ret = ops->alloc(dev, size, dma_handle, gfp, attrs);
-+	else
-+		ret = mips_dma_alloc_coherent(dev, size, dma_handle, gfp,
-+					      attrs);
- 
- 	debug_dma_alloc_coherent(dev, size, *dma_handle, ret);
- 
-@@ -89,7 +430,10 @@ static inline void dma_free_attrs(struct
- {
- 	struct dma_map_ops *ops = get_dma_ops(dev);
- 
--	ops->free(dev, size, vaddr, dma_handle, attrs);
-+	if (ops)
-+		ops->free(dev, size, vaddr, dma_handle, attrs);
-+	else
-+		mips_dma_free_coherent(dev, size, vaddr, dma_handle, attrs);
- 
- 	debug_dma_free_coherent(dev, size, vaddr, dma_handle);
- }
---- a/arch/mips/mm/dma-default.c
-+++ b/arch/mips/mm/dma-default.c
-@@ -26,7 +26,7 @@
- 
- #ifdef CONFIG_DMA_MAYBE_COHERENT
- int coherentio = 0;	/* User defined DMA coherency from command line. */
--EXPORT_SYMBOL_GPL(coherentio);
-+EXPORT_SYMBOL(coherentio);
- int hw_coherentio = 0;	/* Actual hardware supported DMA coherency setting. */
- 
- static int __init setcoherentio(char *str)
-@@ -46,30 +46,6 @@ static int __init setnocoherentio(char *
- early_param("nocoherentio", setnocoherentio);
- #endif
- 
--static inline struct page *dma_addr_to_page(struct device *dev,
--	dma_addr_t dma_addr)
--{
--	return pfn_to_page(
--		plat_dma_addr_to_phys(dev, dma_addr) >> PAGE_SHIFT);
--}
--
--/*
-- * The affected CPUs below in 'cpu_needs_post_dma_flush()' can
-- * speculatively fill random cachelines with stale data at any time,
-- * requiring an extra flush post-DMA.
-- *
-- * Warning on the terminology - Linux calls an uncached area coherent;
-- * MIPS terminology calls memory areas with hardware maintained coherency
-- * coherent.
-- */
--static inline int cpu_needs_post_dma_flush(struct device *dev)
--{
--	return !plat_device_is_coherent(dev) &&
--	       (boot_cpu_type() == CPU_R10000 ||
--		boot_cpu_type() == CPU_R12000 ||
--		boot_cpu_type() == CPU_BMIPS5000);
--}
--
- static gfp_t massage_gfp_flags(const struct device *dev, gfp_t gfp)
- {
- 	gfp_t dma_flag;
-@@ -125,8 +101,9 @@ void *dma_alloc_noncoherent(struct devic
- }
- EXPORT_SYMBOL(dma_alloc_noncoherent);
- 
--static void *mips_dma_alloc_coherent(struct device *dev, size_t size,
--	dma_addr_t * dma_handle, gfp_t gfp, struct dma_attrs *attrs)
-+void *mips_dma_alloc_coherent(struct device *dev, size_t size,
-+			      dma_addr_t *dma_handle, gfp_t gfp,
-+			      struct dma_attrs *attrs)
- {
- 	void *ret;
- 	struct page *page = NULL;
-@@ -157,6 +134,7 @@ static void *mips_dma_alloc_coherent(str
- 
- 	return ret;
- }
-+EXPORT_SYMBOL(mips_dma_alloc_coherent);
- 
- 
- void dma_free_noncoherent(struct device *dev, size_t size, void *vaddr,
-@@ -167,8 +145,8 @@ void dma_free_noncoherent(struct device
- }
- EXPORT_SYMBOL(dma_free_noncoherent);
- 
--static void mips_dma_free_coherent(struct device *dev, size_t size, void *vaddr,
--	dma_addr_t dma_handle, struct dma_attrs *attrs)
-+void mips_dma_free_coherent(struct device *dev, size_t size, void *vaddr,
-+			    dma_addr_t dma_handle, struct dma_attrs *attrs)
- {
- 	unsigned long addr = (unsigned long) vaddr;
- 	int order = get_order(size);
-@@ -188,6 +166,7 @@ static void mips_dma_free_coherent(struc
- 	if (!dma_release_from_contiguous(dev, page, count))
- 		__free_pages(page, get_order(size));
- }
-+EXPORT_SYMBOL(mips_dma_free_coherent);
- 
- static inline void __dma_sync_virtual(void *addr, size_t size,
- 	enum dma_data_direction direction)
-@@ -216,8 +195,8 @@ static inline void __dma_sync_virtual(vo
-  * If highmem is not configured then the bulk of this loop gets
-  * optimized out.
-  */
--static inline void __dma_sync(struct page *page,
--	unsigned long offset, size_t size, enum dma_data_direction direction)
-+void __dma_sync(struct page *page, unsigned long offset, size_t size,
-+		enum dma_data_direction direction)
- {
- 	size_t left = size;
- 
-@@ -246,108 +225,7 @@ static inline void __dma_sync(struct pag
- 		left -= len;
- 	} while (left);
- }
--
--static void mips_dma_unmap_page(struct device *dev, dma_addr_t dma_addr,
--	size_t size, enum dma_data_direction direction, struct dma_attrs *attrs)
--{
--	if (cpu_needs_post_dma_flush(dev))
--		__dma_sync(dma_addr_to_page(dev, dma_addr),
--			   dma_addr & ~PAGE_MASK, size, direction);
--
--	plat_unmap_dma_mem(dev, dma_addr, size, direction);
--}
--
--static int mips_dma_map_sg(struct device *dev, struct scatterlist *sg,
--	int nents, enum dma_data_direction direction, struct dma_attrs *attrs)
--{
--	int i;
--
--	for (i = 0; i < nents; i++, sg++) {
--		if (!plat_device_is_coherent(dev))
--			__dma_sync(sg_page(sg), sg->offset, sg->length,
--				   direction);
--#ifdef CONFIG_NEED_SG_DMA_LENGTH
--		sg->dma_length = sg->length;
--#endif
--		sg->dma_address = plat_map_dma_mem_page(dev, sg_page(sg)) +
--				  sg->offset;
--	}
--
--	return nents;
--}
--
--static dma_addr_t mips_dma_map_page(struct device *dev, struct page *page,
--	unsigned long offset, size_t size, enum dma_data_direction direction,
--	struct dma_attrs *attrs)
--{
--	if (!plat_device_is_coherent(dev))
--		__dma_sync(page, offset, size, direction);
--
--	return plat_map_dma_mem_page(dev, page) + offset;
--}
--
--static void mips_dma_unmap_sg(struct device *dev, struct scatterlist *sg,
--	int nhwentries, enum dma_data_direction direction,
--	struct dma_attrs *attrs)
--{
--	int i;
--
--	for (i = 0; i < nhwentries; i++, sg++) {
--		if (!plat_device_is_coherent(dev) &&
--		    direction != DMA_TO_DEVICE)
--			__dma_sync(sg_page(sg), sg->offset, sg->length,
--				   direction);
--		plat_unmap_dma_mem(dev, sg->dma_address, sg->length, direction);
--	}
--}
--
--static void mips_dma_sync_single_for_cpu(struct device *dev,
--	dma_addr_t dma_handle, size_t size, enum dma_data_direction direction)
--{
--	if (cpu_needs_post_dma_flush(dev))
--		__dma_sync(dma_addr_to_page(dev, dma_handle),
--			   dma_handle & ~PAGE_MASK, size, direction);
--}
--
--static void mips_dma_sync_single_for_device(struct device *dev,
--	dma_addr_t dma_handle, size_t size, enum dma_data_direction direction)
--{
--	if (!plat_device_is_coherent(dev))
--		__dma_sync(dma_addr_to_page(dev, dma_handle),
--			   dma_handle & ~PAGE_MASK, size, direction);
--}
--
--static void mips_dma_sync_sg_for_cpu(struct device *dev,
--	struct scatterlist *sg, int nelems, enum dma_data_direction direction)
--{
--	int i;
--
--	if (cpu_needs_post_dma_flush(dev))
--		for (i = 0; i < nelems; i++, sg++)
--			__dma_sync(sg_page(sg), sg->offset, sg->length,
--				   direction);
--}
--
--static void mips_dma_sync_sg_for_device(struct device *dev,
--	struct scatterlist *sg, int nelems, enum dma_data_direction direction)
--{
--	int i;
--
--	if (!plat_device_is_coherent(dev))
--		for (i = 0; i < nelems; i++, sg++)
--			__dma_sync(sg_page(sg), sg->offset, sg->length,
--				   direction);
--}
--
--int mips_dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
--{
--	return 0;
--}
--
--int mips_dma_supported(struct device *dev, u64 mask)
--{
--	return plat_dma_supported(dev, mask);
--}
-+EXPORT_SYMBOL(__dma_sync);
- 
- void dma_cache_sync(struct device *dev, void *vaddr, size_t size,
- 			 enum dma_data_direction direction)
-@@ -360,23 +238,10 @@ void dma_cache_sync(struct device *dev,
- 
- EXPORT_SYMBOL(dma_cache_sync);
- 
--static struct dma_map_ops mips_default_dma_map_ops = {
--	.alloc = mips_dma_alloc_coherent,
--	.free = mips_dma_free_coherent,
--	.map_page = mips_dma_map_page,
--	.unmap_page = mips_dma_unmap_page,
--	.map_sg = mips_dma_map_sg,
--	.unmap_sg = mips_dma_unmap_sg,
--	.sync_single_for_cpu = mips_dma_sync_single_for_cpu,
--	.sync_single_for_device = mips_dma_sync_single_for_device,
--	.sync_sg_for_cpu = mips_dma_sync_sg_for_cpu,
--	.sync_sg_for_device = mips_dma_sync_sg_for_device,
--	.mapping_error = mips_dma_mapping_error,
--	.dma_supported = mips_dma_supported
--};
--
--struct dma_map_ops *mips_dma_map_ops = &mips_default_dma_map_ops;
-+#ifdef CONFIG_SYS_HAS_DMA_OPS
-+struct dma_map_ops *mips_dma_map_ops = NULL;
- EXPORT_SYMBOL(mips_dma_map_ops);
-+#endif
- 
- #define PREALLOC_DMA_DEBUG_ENTRIES (1 << 16)
- 
--- a/target/linux/generic/pending-3.18/140-mtd-part-add-generic-parsing-of-linux-part-probe.patch	2022-03-22 08:54:47.284464798 +0800
+++ b/target/linux/generic/pending-3.18/140-mtd-part-add-generic-parsing-of-linux-part-probe.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,175 +0,0 @@
-From 173b0add0cff6558f950c0cb1eacfb729d482711 Mon Sep 17 00:00:00 2001
-From: Hauke Mehrtens <hauke@hauke-m.de>
-Date: Sun, 17 May 2015 18:48:38 +0200
-Subject: [PATCH 4/8] mtd: part: add generic parsing of linux,part-probe
-
-This moves the linux,part-probe device tree parsing code from
-physmap_of.c to mtdpart.c. Now all drivers can use this feature by just
-providing a reference to their device tree node in struct
-mtd_part_parser_data.
-
-Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
----
- Documentation/devicetree/bindings/mtd/nand.txt | 16 ++++++++++
- drivers/mtd/maps/physmap_of.c                  | 40 +-----------------------
- drivers/mtd/mtdpart.c                          | 43 ++++++++++++++++++++++++++
- 3 files changed, 60 insertions(+), 39 deletions(-)
-
---- a/Documentation/devicetree/bindings/mtd/nand.txt
-+++ b/Documentation/devicetree/bindings/mtd/nand.txt
-@@ -12,6 +12,22 @@
- - nand-ecc-step-size: integer representing the number of data bytes
- 		      that are covered by a single ECC step.
- 
-+- linux,part-probe: list of name as strings of the partition parser
-+		    which should be used to parse the partition table.
-+		    They will be tried in the specified ordering and
-+		    the next one will be used if the previous one
-+		    failed.
-+
-+		    Example: linux,part-probe = "cmdlinepart", "ofpart";
-+
-+		    This is also the default value, which will be used
-+		    if this attribute is not specified. It could be
-+		    that the flash driver in use overwrote the default
-+		    value and uses some other default.
-+
-+		    Possible values are: bcm47xxpart, afs, ar7part,
-+		    ofoldpart, ofpart, bcm63xxpart, RedBoot, cmdlinepart
-+
- The ECC strength and ECC step size properties define the correction capability
- of a controller. Together, they say a controller can correct "{strength} bit
- errors per {size} bytes".
---- a/drivers/mtd/maps/physmap_of.c
-+++ b/drivers/mtd/maps/physmap_of.c
-@@ -114,45 +114,9 @@ static struct mtd_info *obsolete_probe(s
- static const char * const part_probe_types_def[] = {
- 	"cmdlinepart", "RedBoot", "ofpart", "ofoldpart", NULL };
- 
--static const char * const *of_get_probes(struct device_node *dp)
--{
--	const char *cp;
--	int cplen;
--	unsigned int l;
--	unsigned int count;
--	const char **res;
--
--	cp = of_get_property(dp, "linux,part-probe", &cplen);
--	if (cp == NULL)
--		return part_probe_types_def;
--
--	count = 0;
--	for (l = 0; l != cplen; l++)
--		if (cp[l] == 0)
--			count++;
--
--	res = kzalloc((count + 1)*sizeof(*res), GFP_KERNEL);
--	count = 0;
--	while (cplen > 0) {
--		res[count] = cp;
--		l = strlen(cp) + 1;
--		cp += l;
--		cplen -= l;
--		count++;
--	}
--	return res;
--}
--
--static void of_free_probes(const char * const *probes)
--{
--	if (probes != part_probe_types_def)
--		kfree(probes);
--}
--
- static struct of_device_id of_flash_match[];
- static int of_flash_probe(struct platform_device *dev)
- {
--	const char * const *part_probe_types;
- 	const struct of_device_id *match;
- 	struct device_node *dp = dev->dev.of_node;
- 	struct resource res;
-@@ -302,10 +266,8 @@ static int of_flash_probe(struct platfor
- 		goto err_out;
- 
- 	ppdata.of_node = dp;
--	part_probe_types = of_get_probes(dp);
--	mtd_device_parse_register(info->cmtd, part_probe_types, &ppdata,
-+	mtd_device_parse_register(info->cmtd, part_probe_types_def, &ppdata,
- 			NULL, 0);
--	of_free_probes(part_probe_types);
- 
- 	kfree(mtd_list);
- 
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -29,6 +29,7 @@
- #include <linux/kmod.h>
- #include <linux/mtd/mtd.h>
- #include <linux/mtd/partitions.h>
-+#include <linux/of.h>
- #include <linux/err.h>
- 
- #include "mtdcore.h"
-@@ -702,6 +703,40 @@ void deregister_mtd_parser(struct mtd_pa
- EXPORT_SYMBOL_GPL(deregister_mtd_parser);
- 
- /*
-+ * Parses the linux,part-probe device tree property.
-+ * When a non null value is returned it has to be freed with kfree() by
-+ * the caller.
-+ */
-+static const char * const *of_get_probes(struct device_node *dp)
-+{
-+	const char *cp;
-+	int cplen;
-+	unsigned int l;
-+	unsigned int count;
-+	const char **res;
-+
-+	cp = of_get_property(dp, "linux,part-probe", &cplen);
-+	if (cp == NULL)
-+		return NULL;
-+
-+	count = 0;
-+	for (l = 0; l != cplen; l++)
-+		if (cp[l] == 0)
-+			count++;
-+
-+	res = kzalloc((count + 1) * sizeof(*res), GFP_KERNEL);
-+	count = 0;
-+	while (cplen > 0) {
-+		res[count] = cp;
-+		l = strlen(cp) + 1;
-+		cp += l;
-+		cplen -= l;
-+		count++;
-+	}
-+	return res;
-+}
-+
-+/*
-  * Do not forget to update 'parse_mtd_partitions()' kerneldoc comment if you
-  * are changing this array!
-  */
-@@ -737,6 +772,13 @@ int parse_mtd_partitions(struct mtd_info
- {
- 	struct mtd_part_parser *parser;
- 	int ret = 0;
-+	const char *const *types_of = NULL;
-+
-+	if (data && data->of_node) {
-+		types_of = of_get_probes(data->of_node);
-+		if (types_of != NULL)
-+			types = types_of;
-+	}
- 
- 	if (!types)
- 		types = default_mtd_part_types;
-@@ -755,6 +797,7 @@ int parse_mtd_partitions(struct mtd_info
- 			break;
- 		}
- 	}
-+	kfree(types_of);
- 	return ret;
- }
- 
--- a/target/linux/generic/pending-3.18/142-mtd-bcm47xxpart-don-t-fail-because-of-bit-flips.patch	2022-03-22 08:54:47.285464799 +0800
+++ b/target/linux/generic/pending-3.18/142-mtd-bcm47xxpart-don-t-fail-because-of-bit-flips.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,92 +0,0 @@
-From dfe4b4c732365fc1d83c2d2fd9cc18054ae850b7 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
-Date: Sun, 6 Dec 2015 11:24:05 +0100
-Subject: [PATCH] mtd: bcm47xxpart: don't fail because of bit-flips
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Bit-flip errors may occur on NAND flashes and are harmless. Handle them
-gracefully as read content is still reliable and can be parsed.
-
-Signed-off-by: Rafa Miecki <zajec5@gmail.com>
----
- drivers/mtd/bcm47xxpart.c | 38 ++++++++++++++++++++++----------------
- 1 file changed, 22 insertions(+), 16 deletions(-)
-
---- a/drivers/mtd/bcm47xxpart.c
-+++ b/drivers/mtd/bcm47xxpart.c
-@@ -66,11 +66,13 @@ static const char *bcm47xxpart_trx_data_
- {
- 	uint32_t buf;
- 	size_t bytes_read;
-+	int err;
- 
--	if (mtd_read(master, offset, sizeof(buf), &bytes_read,
--		     (uint8_t *)&buf) < 0) {
--		pr_err("mtd_read error while parsing (offset: 0x%X)!\n",
--			offset);
-+	err  = mtd_read(master, offset, sizeof(buf), &bytes_read,
-+			(uint8_t *)&buf);
-+	if (err && !mtd_is_bitflip(err)) {
-+		pr_err("mtd_read error while parsing (offset: 0x%X): %d\n",
-+			offset, err);
- 		goto out_default;
- 	}
- 
-@@ -95,6 +97,7 @@ static int bcm47xxpart_parse(struct mtd_
- 	int trx_part = -1;
- 	int last_trx_part = -1;
- 	int possible_nvram_sizes[] = { 0x8000, 0xF000, 0x10000, };
-+	int err;
- 
- 	/*
- 	 * Some really old flashes (like AT45DB*) had smaller erasesize-s, but
-@@ -128,10 +131,11 @@ static int bcm47xxpart_parse(struct mtd_
- 		}
- 
- 		/* Read beginning of the block */
--		if (mtd_read(master, offset, BCM47XXPART_BYTES_TO_READ,
--			     &bytes_read, (uint8_t *)buf) < 0) {
--			pr_err("mtd_read error while parsing (offset: 0x%X)!\n",
--			       offset);
-+		err = mtd_read(master, offset, BCM47XXPART_BYTES_TO_READ,
-+			       &bytes_read, (uint8_t *)buf);
-+		if (err && !mtd_is_bitflip(err)) {
-+			pr_err("mtd_read error while parsing (offset: 0x%X): %d\n",
-+			       offset, err);
- 			continue;
- 		}
- 
-@@ -252,10 +256,11 @@ static int bcm47xxpart_parse(struct mtd_
- 		}
- 
- 		/* Read middle of the block */
--		if (mtd_read(master, offset + 0x8000, 0x4,
--			     &bytes_read, (uint8_t *)buf) < 0) {
--			pr_err("mtd_read error while parsing (offset: 0x%X)!\n",
--			       offset);
-+		err = mtd_read(master, offset + 0x8000, 0x4, &bytes_read,
-+			       (uint8_t *)buf);
-+		if (err && !mtd_is_bitflip(err)) {
-+			pr_err("mtd_read error while parsing (offset: 0x%X): %d\n",
-+			       offset, err);
- 			continue;
- 		}
- 
-@@ -275,10 +280,11 @@ static int bcm47xxpart_parse(struct mtd_
- 		}
- 
- 		offset = master->size - possible_nvram_sizes[i];
--		if (mtd_read(master, offset, 0x4, &bytes_read,
--			     (uint8_t *)buf) < 0) {
--			pr_err("mtd_read error while reading at offset 0x%X!\n",
--			       offset);
-+		err = mtd_read(master, offset, 0x4, &bytes_read,
-+			       (uint8_t *)buf);
-+		if (err && !mtd_is_bitflip(err)) {
-+			pr_err("mtd_read error while reading (offset 0x%X): %d\n",
-+			       offset, err);
- 			continue;
- 		}
- 
--- a/target/linux/generic/pending-3.18/180-usb-xhci-make-USB_XHCI_PLATFORM-selectable.patch	2022-03-22 08:54:47.285464799 +0800
+++ b/target/linux/generic/pending-3.18/180-usb-xhci-make-USB_XHCI_PLATFORM-selectable.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,41 +0,0 @@
-From 9612e686b235dc9e33c8dfb5e6d2ff2b2140fb9d Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
-Date: Tue, 16 Jun 2015 21:01:30 +0200
-Subject: [PATCH V2] usb: xhci: make USB_XHCI_PLATFORM selectable
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Right now xhci-plat-hcd can be built when using one of platform specific
-drivers only (mvebu/rcar). There shouldn't be such limitation as some
-platforms may not require any quirks and may want to just use a generic
-driver ("generic-xhci" / "xhci-hcd").
-
-Signed-off-by: Rafa Miecki <zajec5@gmail.com>
----
-Greg/Mathias: I'm not sure if it's more like USB subsystem stuff or xHCI
-Could you decide which one of you could pick that, please?
-
-V2: Drop useless "default n", thanks Sergei :)
----
- drivers/usb/host/Kconfig | 9 ++++++++-
- 1 file changed, 8 insertions(+), 1 deletion(-)
-
---- a/drivers/usb/host/Kconfig
-+++ b/drivers/usb/host/Kconfig
-@@ -32,7 +32,14 @@ config USB_XHCI_PCI
-        default y
- 
- config USB_XHCI_PLATFORM
--	tristate
-+	tristate "Generic xHCI driver for a platform device"
-+	---help---
-+	  Adds an xHCI host driver for a generic platform device, which
-+	  provides a memory space and an irq.
-+	  It is also a prerequisite for platform specific drivers that
-+	  implement some extra quirks.
-+
-+	  If unsure, say N.
- 
- config USB_XHCI_MVEBU
- 	tristate "xHCI support for Marvell Armada 375/38x"
--- a/target/linux/generic/pending-3.18/190-cdc_ncm_add_support_for_moving_ndp_to_end_of_ncm_frame.patch	2022-03-22 08:54:47.286464801 +0800
+++ b/target/linux/generic/pending-3.18/190-cdc_ncm_add_support_for_moving_ndp_to_end_of_ncm_frame.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,228 +0,0 @@
-From 4a0e3e989d66bb7204b163d9cfaa7fa96d0f2023 Mon Sep 17 00:00:00 2001
-From: Enrico Mioso <mrkiko.rs@gmail.com>
-Date: Wed, 8 Jul 2015 13:05:57 +0200
-Subject: [PATCH] cdc_ncm: Add support for moving NDP to end of NCM frame
-
-NCM specs are not actually mandating a specific position in the frame for
-the NDP (Network Datagram Pointer). However, some Huawei devices will
-ignore our aggregates if it is not placed after the datagrams it points
-to. Add support for doing just this, in a per-device configurable way.
-While at it, update NCM subdrivers, disabling this functionality in all of
-them, except in huawei_cdc_ncm where it is enabled instead.
-We aren't making any distinction between different Huawei NCM devices,
-based on what the vendor driver does. Standard NCM devices are left
-unaffected: if they are compliant, they should be always usable, still
-stay on the safe side.
-
-This change has been tested and working with a Huawei E3131 device (which
-works regardless of NDP position), a Huawei E3531 (also working both
-ways) and an E3372 (which mandates NDP to be after indexed datagrams).
-
-V1->V2:
-- corrected wrong NDP acronym definition
-- fixed possible NULL pointer dereference
-- patch cleanup
-V2->V3:
-- Properly account for the NDP size when writing new packets to SKB
-
-Signed-off-by: Enrico Mioso <mrkiko.rs@gmail.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- drivers/net/usb/cdc_mbim.c       |  2 +-
- drivers/net/usb/cdc_ncm.c        | 61 ++++++++++++++++++++++++++++++++++++----
- drivers/net/usb/huawei_cdc_ncm.c |  7 +++--
- include/linux/usb/cdc_ncm.h      |  7 ++++-
- 4 files changed, 67 insertions(+), 10 deletions(-)
-
---- a/drivers/net/usb/cdc_mbim.c
-+++ b/drivers/net/usb/cdc_mbim.c
-@@ -158,7 +158,7 @@ static int cdc_mbim_bind(struct usbnet *
- 	if (!cdc_ncm_comm_intf_is_mbim(intf->cur_altsetting))
- 		goto err;
- 
--	ret = cdc_ncm_bind_common(dev, intf, data_altsetting);
-+	ret = cdc_ncm_bind_common(dev, intf, data_altsetting, 0);
- 	if (ret)
- 		goto err;
- 
---- a/drivers/net/usb/cdc_ncm.c
-+++ b/drivers/net/usb/cdc_ncm.c
-@@ -684,10 +684,12 @@ static void cdc_ncm_free(struct cdc_ncm_
- 		ctx->tx_curr_skb = NULL;
- 	}
- 
-+	kfree(ctx->delayed_ndp16);
-+
- 	kfree(ctx);
- }
- 
--int cdc_ncm_bind_common(struct usbnet *dev, struct usb_interface *intf, u8 data_altsetting)
-+int cdc_ncm_bind_common(struct usbnet *dev, struct usb_interface *intf, u8 data_altsetting, int drvflags)
- {
- 	const struct usb_cdc_union_desc *union_desc = NULL;
- 	struct cdc_ncm_ctx *ctx;
-@@ -859,6 +861,17 @@ advance:
- 	/* finish setting up the device specific data */
- 	cdc_ncm_setup(dev);
- 
-+	/* Device-specific flags */
-+	ctx->drvflags = drvflags;
-+
-+	/* Allocate the delayed NDP if needed. */
-+	if (ctx->drvflags & CDC_NCM_FLAG_NDP_TO_END) {
-+		ctx->delayed_ndp16 = kzalloc(ctx->max_ndp_size, GFP_KERNEL);
-+		if (!ctx->delayed_ndp16)
-+			goto error2;
-+		dev_info(&intf->dev, "NDP will be placed at end of frame for this device.");
-+	}
-+
- 	/* override ethtool_ops */
- 	dev->net->ethtool_ops = &cdc_ncm_ethtool_ops;
- 
-@@ -956,8 +969,11 @@ static int cdc_ncm_bind(struct usbnet *d
- 	if (cdc_ncm_select_altsetting(intf) != CDC_NCM_COMM_ALTSETTING_NCM)
- 		return -ENODEV;
- 
--	/* The NCM data altsetting is fixed */
--	return cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM);
-+	/* The NCM data altsetting is fixed, so we hard-coded it.
-+	 * Additionally, generic NCM devices are assumed to accept arbitrarily
-+	 * placed NDP.
-+	 */
-+	return cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);
- }
- 
- static void cdc_ncm_align_tail(struct sk_buff *skb, size_t modulus, size_t remainder, size_t max)
-@@ -979,6 +995,14 @@ static struct usb_cdc_ncm_ndp16 *cdc_ncm
- 	struct usb_cdc_ncm_nth16 *nth16 = (void *)skb->data;
- 	size_t ndpoffset = le16_to_cpu(nth16->wNdpIndex);
- 
-+	/* If NDP should be moved to the end of the NCM package, we can't follow the
-+	* NTH16 header as we would normally do. NDP isn't written to the SKB yet, and
-+	* the wNdpIndex field in the header is actually not consistent with reality. It will be later.
-+	*/
-+	if (ctx->drvflags & CDC_NCM_FLAG_NDP_TO_END)
-+		if (ctx->delayed_ndp16->dwSignature == sign)
-+			return ctx->delayed_ndp16;
-+
- 	/* follow the chain of NDPs, looking for a match */
- 	while (ndpoffset) {
- 		ndp16 = (struct usb_cdc_ncm_ndp16 *)(skb->data + ndpoffset);
-@@ -988,7 +1012,8 @@ static struct usb_cdc_ncm_ndp16 *cdc_ncm
- 	}
- 
- 	/* align new NDP */
--	cdc_ncm_align_tail(skb, ctx->tx_ndp_modulus, 0, ctx->tx_max);
-+	if (!(ctx->drvflags & CDC_NCM_FLAG_NDP_TO_END))
-+		cdc_ncm_align_tail(skb, ctx->tx_ndp_modulus, 0, ctx->tx_max);
- 
- 	/* verify that there is room for the NDP and the datagram (reserve) */
- 	if ((ctx->tx_max - skb->len - reserve) < ctx->max_ndp_size)
-@@ -1001,7 +1026,11 @@ static struct usb_cdc_ncm_ndp16 *cdc_ncm
- 		nth16->wNdpIndex = cpu_to_le16(skb->len);
- 
- 	/* push a new empty NDP */
--	ndp16 = (struct usb_cdc_ncm_ndp16 *)memset(skb_put(skb, ctx->max_ndp_size), 0, ctx->max_ndp_size);
-+	if (!(ctx->drvflags & CDC_NCM_FLAG_NDP_TO_END))
-+		ndp16 = (struct usb_cdc_ncm_ndp16 *)memset(skb_put(skb, ctx->max_ndp_size), 0, ctx->max_ndp_size);
-+	else
-+		ndp16 = ctx->delayed_ndp16;
-+
- 	ndp16->dwSignature = sign;
- 	ndp16->wLength = cpu_to_le16(sizeof(struct usb_cdc_ncm_ndp16) + sizeof(struct usb_cdc_ncm_dpe16));
- 	return ndp16;
-@@ -1016,6 +1045,15 @@ cdc_ncm_fill_tx_frame(struct usbnet *dev
- 	struct sk_buff *skb_out;
- 	u16 n = 0, index, ndplen;
- 	u8 ready2send = 0;
-+	u32 delayed_ndp_size;
-+
-+	/* When our NDP gets written in cdc_ncm_ndp(), then skb_out->len gets updated
-+	 * accordingly. Otherwise, we should check here.
-+	 */
-+	if (ctx->drvflags & CDC_NCM_FLAG_NDP_TO_END)
-+		delayed_ndp_size = ctx->max_ndp_size;
-+	else
-+		delayed_ndp_size = 0;
- 
- 	/* if there is a remaining skb, it gets priority */
- 	if (skb != NULL) {
-@@ -1070,7 +1108,7 @@ cdc_ncm_fill_tx_frame(struct usbnet *dev
- 		cdc_ncm_align_tail(skb_out,  ctx->tx_modulus, ctx->tx_remainder, ctx->tx_max);
- 
- 		/* check if we had enough room left for both NDP and frame */
--		if (!ndp16 || skb_out->len + skb->len > ctx->tx_max) {
-+		if (!ndp16 || skb_out->len + skb->len + delayed_ndp_size > ctx->tx_max) {
- 			if (n == 0) {
- 				/* won't fit, MTU problem? */
- 				dev_kfree_skb_any(skb);
-@@ -1143,6 +1181,17 @@ cdc_ncm_fill_tx_frame(struct usbnet *dev
- 		/* variables will be reset at next call */
- 	}
- 
-+	/* If requested, put NDP at end of frame. */
-+	if (ctx->drvflags & CDC_NCM_FLAG_NDP_TO_END) {
-+		nth16 = (struct usb_cdc_ncm_nth16 *)skb_out->data;
-+		cdc_ncm_align_tail(skb_out, ctx->tx_ndp_modulus, 0, ctx->tx_max);
-+		nth16->wNdpIndex = cpu_to_le16(skb_out->len);
-+		memcpy(skb_put(skb_out, ctx->max_ndp_size), ctx->delayed_ndp16, ctx->max_ndp_size);
-+
-+		/* Zero out delayed NDP - signature checking will naturally fail. */
-+		ndp16 = memset(ctx->delayed_ndp16, 0, ctx->max_ndp_size);
-+	}
-+
- 	/* If collected data size is less or equal ctx->min_tx_pkt
- 	 * bytes, we send buffers as it is. If we get more data, it
- 	 * would be more efficient for USB HS mobile device with DMA
---- a/drivers/net/usb/huawei_cdc_ncm.c
-+++ b/drivers/net/usb/huawei_cdc_ncm.c
-@@ -73,11 +73,14 @@ static int huawei_cdc_ncm_bind(struct us
- 	struct usb_driver *subdriver = ERR_PTR(-ENODEV);
- 	int ret = -ENODEV;
- 	struct huawei_cdc_ncm_state *drvstate = (void *)&usbnet_dev->data;
-+	int drvflags = 0;
- 
- 	/* altsetting should always be 1 for NCM devices - so we hard-coded
--	 * it here
-+	 * it here. Some huawei devices will need the NDP part of the NCM package to
-+	 * be at the end of the frame.
- 	 */
--	ret = cdc_ncm_bind_common(usbnet_dev, intf, 1);
-+	drvflags |= CDC_NCM_FLAG_NDP_TO_END;
-+	ret = cdc_ncm_bind_common(usbnet_dev, intf, 1, drvflags);
- 	if (ret)
- 		goto err;
- 
---- a/include/linux/usb/cdc_ncm.h
-+++ b/include/linux/usb/cdc_ncm.h
-@@ -80,6 +80,9 @@
- #define CDC_NCM_TIMER_INTERVAL_MIN		5UL
- #define CDC_NCM_TIMER_INTERVAL_MAX		(U32_MAX / NSEC_PER_USEC)
- 
-+/* Driver flags */
-+#define CDC_NCM_FLAG_NDP_TO_END	0x02		/* NDP is placed at end of frame */
-+
- #define cdc_ncm_comm_intf_is_mbim(x)  ((x)->desc.bInterfaceSubClass == USB_CDC_SUBCLASS_MBIM && \
- 				       (x)->desc.bInterfaceProtocol == USB_CDC_PROTO_NONE)
- #define cdc_ncm_data_intf_is_mbim(x)  ((x)->desc.bInterfaceProtocol == USB_CDC_MBIM_PROTO_NTB)
-@@ -103,9 +106,11 @@ struct cdc_ncm_ctx {
- 
- 	spinlock_t mtx;
- 	atomic_t stop;
-+	int drvflags;
- 
- 	u32 timer_interval;
- 	u32 max_ndp_size;
-+	struct usb_cdc_ncm_ndp16 *delayed_ndp16;
- 
- 	u32 tx_timer_pending;
- 	u32 tx_curr_frame_num;
-@@ -133,7 +138,7 @@ struct cdc_ncm_ctx {
- };
- 
- u8 cdc_ncm_select_altsetting(struct usb_interface *intf);
--int cdc_ncm_bind_common(struct usbnet *dev, struct usb_interface *intf, u8 data_altsetting);
-+int cdc_ncm_bind_common(struct usbnet *dev, struct usb_interface *intf, u8 data_altsetting, int drvflags);
- void cdc_ncm_unbind(struct usbnet *dev, struct usb_interface *intf);
- struct sk_buff *cdc_ncm_fill_tx_frame(struct usbnet *dev, struct sk_buff *skb, __le32 sign);
- int cdc_ncm_rx_verify_nth16(struct cdc_ncm_ctx *ctx, struct sk_buff *skb_in);
--- a/target/linux/generic/pending-3.18/192-USB-qcserial-Add-support-for-Quectel-EC20-Mini-PCIe-.patch	2022-03-22 08:54:47.286464801 +0800
+++ b/target/linux/generic/pending-3.18/192-USB-qcserial-Add-support-for-Quectel-EC20-Mini-PCIe-.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,114 +0,0 @@
-From 128524b9db3e4f4245226852bee771bd03db75be Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Petr=20=C5=A0tetiar?= <ynezz@true.cz>
-Date: Tue, 3 Nov 2015 11:01:42 +0100
-Subject: [PATCH 1/2] USB: qcserial: Add support for Quectel EC20 Mini PCIe
- module
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-It seems like this device has same vendor and product IDs as G2K
-devices, but it has different number of interfaces(4 vs 5) and also
-different interface layout which makes it currently unusable:
-
-	usbcore: registered new interface driver qcserial
-	usbserial: USB Serial support registered for Qualcomm USB modem
-	usb 2-1.2: unknown number of interfaces: 5
-
-lsusb output:
-
-	Bus 002 Device 003: ID 05c6:9215 Qualcomm, Inc. Acer Gobi 2000 Wireless
-	Device Descriptor:
-	  bLength                18
-	  bDescriptorType         1
-	  bcdUSB               2.00
-	  bDeviceClass            0 (Defined at Interface level)
-	  bDeviceSubClass         0
-	  bDeviceProtocol         0
-	  bMaxPacketSize0        64
-	  idVendor           0x05c6 Qualcomm, Inc.
-	  idProduct          0x9215 Acer Gobi 2000 Wireless Modem
-	  bcdDevice            2.32
-	  iManufacturer           1 Quectel
-	  iProduct                2 Quectel LTE Module
-	  iSerial                 0
-	  bNumConfigurations      1
-	  Configuration Descriptor:
-	    bLength                 9
-	    bDescriptorType         2
-	    wTotalLength          209
-	    bNumInterfaces          5
-	    bConfigurationValue     1
-	    iConfiguration          0
-	    bmAttributes         0xa0
-	      (Bus Powered)
-	      Remote Wakeup
-	    MaxPower              500mA
-
-Signed-off-by: Petr tetiar <ynezz@true.cz>
----
- drivers/usb/serial/qcserial.c |   39 +++++++++++++++++++++++++++++++++++++++
- 1 file changed, 39 insertions(+)
-
---- a/drivers/usb/serial/qcserial.c
-+++ b/drivers/usb/serial/qcserial.c
-@@ -22,6 +22,8 @@
- #define DRIVER_AUTHOR "Qualcomm Inc"
- #define DRIVER_DESC "Qualcomm USB Serial driver"
- 
-+#define QUECTEL_EC20_IDPRODUCT 0x9215
-+
- /* standard device layouts supported by this driver */
- enum qcserial_layouts {
- 	QCSERIAL_G2K = 0,	/* Gobi 2000 */
-@@ -181,6 +183,38 @@ static const struct usb_device_id id_tab
- };
- MODULE_DEVICE_TABLE(usb, id_table);
- 
-+static int handle_quectel_ec20(struct device *dev, int ifnum)
-+{
-+	int altsetting = 0;
-+
-+	/*
-+	 * Quectel EC20 Mini PCIe LTE module layout:
-+	 * 0: DM/DIAG (use libqcdm from ModemManager for communication)
-+	 * 1: NMEA
-+	 * 2: AT-capable modem port
-+	 * 3: Modem interface
-+	 * 4: NDIS
-+	 */
-+	switch (ifnum) {
-+	case 0:
-+		dev_dbg(dev, "Quectel EC20 DM/DIAG interface found\n");
-+		break;
-+	case 1:
-+		dev_dbg(dev, "Quectel EC20 NMEA GPS interface found\n");
-+		break;
-+	case 2:
-+	case 3:
-+		dev_dbg(dev, "Quectel EC20 Modem port found\n");
-+		break;
-+	case 4:
-+		/* Don't claim the QMI/net interface */
-+		altsetting = -1;
-+		break;
-+	}
-+
-+	return altsetting;
-+}
-+
- static int qcprobe(struct usb_serial *serial, const struct usb_device_id *id)
- {
- 	struct usb_host_interface *intf = serial->interface->cur_altsetting;
-@@ -253,6 +287,11 @@ static int qcprobe(struct usb_serial *se
- 			altsetting = -1;
- 		break;
- 	case QCSERIAL_G2K:
-+		if (nintf == 5 && id->idProduct == QUECTEL_EC20_IDPRODUCT) {
-+			altsetting = handle_quectel_ec20(dev, ifnum);
-+			goto done;
-+		}
-+
- 		/*
- 		 * Gobi 2K+ USB layout:
- 		 * 0: QMI/net
--- a/target/linux/generic/pending-3.18/193-USB-qmi_wwan-Add-quirk-for-Quectel-EC20-Mini-PCIe-mo.patch	2022-03-22 08:54:47.286464801 +0800
+++ b/target/linux/generic/pending-3.18/193-USB-qmi_wwan-Add-quirk-for-Quectel-EC20-Mini-PCIe-mo.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,91 +0,0 @@
-From fe29727caa7fe434fcb3166df2a62672bc516b54 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Petr=20=C5=A0tetiar?= <ynezz@true.cz>
-Date: Wed, 4 Nov 2015 16:23:37 +0100
-Subject: [PATCH 2/2] USB: qmi_wwan: Add quirk for Quectel EC20 Mini PCIe
- module
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-This device has same vendor and product IDs as G2K devices, but it has
-different number of interfaces(4 vs 5) and also different interface
-layout where EC20 has QMI on interface 4 instead of 0.
-
-lsusb output:
-
-	Bus 002 Device 003: ID 05c6:9215 Qualcomm, Inc. Acer Gobi 2000
-	Device Descriptor:
-	  bLength                18
-	  bDescriptorType         1
-	  bcdUSB               2.00
-	  bDeviceClass            0 (Defined at Interface level)
-	  bDeviceSubClass         0
-	  bDeviceProtocol         0
-	  bMaxPacketSize0        64
-	  idVendor           0x05c6 Qualcomm, Inc.
-	  idProduct          0x9215 Acer Gobi 2000 Wireless Modem
-	  bcdDevice            2.32
-	  iManufacturer           1 Quectel
-	  iProduct                2 Quectel LTE Module
-	  iSerial                 0
-	  bNumConfigurations      1
-	  Configuration Descriptor:
-	    bLength                 9
-	    bDescriptorType         2
-	    wTotalLength          209
-	    bNumInterfaces          5
-	    bConfigurationValue     1
-	    iConfiguration          0
-	    bmAttributes         0xa0
-	      (Bus Powered)
-	      Remote Wakeup
-	    MaxPower              500mA
-
-Signed-off-by: Petr tetiar <ynezz@true.cz>
----
- drivers/net/usb/qmi_wwan.c |   21 +++++++++++++++++++++
- 1 file changed, 21 insertions(+)
-
---- a/drivers/net/usb/qmi_wwan.c
-+++ b/drivers/net/usb/qmi_wwan.c
-@@ -836,6 +836,7 @@ static const struct usb_device_id produc
- 	{QMI_GOBI_DEVICE(0x05c6, 0x9245)},	/* Samsung Gobi 2000 Modem device (VL176) */
- 	{QMI_GOBI_DEVICE(0x03f0, 0x251d)},	/* HP Gobi 2000 Modem device (VP412) */
- 	{QMI_GOBI_DEVICE(0x05c6, 0x9215)},	/* Acer Gobi 2000 Modem device (VP413) */
-+	{QMI_FIXED_INTF(0x05c6, 0x9215, 4)},	/* Quectel EC20 Mini PCIe */
- 	{QMI_GOBI_DEVICE(0x05c6, 0x9265)},	/* Asus Gobi 2000 Modem device (VR305) */
- 	{QMI_GOBI_DEVICE(0x05c6, 0x9235)},	/* Top Global Gobi 2000 Modem device (VR306) */
- 	{QMI_GOBI_DEVICE(0x05c6, 0x9275)},	/* iRex Technologies Gobi 2000 Modem device (VR307) */
-@@ -867,6 +868,19 @@ static const struct usb_device_id produc
- };
- MODULE_DEVICE_TABLE(usb, products);
- 
-+static bool quectel_ec20_detected(struct usb_interface *intf)
-+{
-+	struct usb_device *dev = interface_to_usbdev(intf);
-+
-+	if (dev->actconfig &&
-+	   le16_to_cpu(dev->descriptor.idVendor) == 0x05c6 &&
-+	   le16_to_cpu(dev->descriptor.idProduct) == 0x9215 &&
-+	   dev->actconfig->desc.bNumInterfaces == 5)
-+		return true;
-+
-+	return false;
-+}
-+
- static int qmi_wwan_probe(struct usb_interface *intf,
- 			  const struct usb_device_id *prod)
- {
-@@ -895,6 +909,12 @@ static int qmi_wwan_probe(struct usb_int
- 		return -ENODEV;
- 	}
- 
-+	/* Quectel EC20 quirk where we've QMI on interface 4 instead of 0 */
-+	if (quectel_ec20_detected(intf) && desc->bInterfaceNumber == 0) {
-+		dev_dbg(&intf->dev, "Quectel EC20 quirk, skipping interface 0\n");
-+		return -ENODEV;
-+	}
-+
- 	return usbnet_probe(intf, id);
- }
- 
--- a/target/linux/generic/pending-3.18/200-fix_localversion.patch	2022-03-22 08:54:47.287464803 +0800
+++ b/target/linux/generic/pending-3.18/200-fix_localversion.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,11 +0,0 @@
---- a/scripts/setlocalversion
-+++ b/scripts/setlocalversion
-@@ -165,7 +165,7 @@ else
- 	# annotated or signed tagged state (as git describe only
- 	# looks at signed or annotated tags - git tag -a/-s) and
- 	# LOCALVERSION= is not specified
--	if test "${LOCALVERSION+set}" != "set"; then
-+	if test "${CONFIG_LOCALVERSION+set}" != "set"; then
- 		scm=$(scm_version --short)
- 		res="$res${scm:++}"
- 	fi
--- a/target/linux/generic/pending-3.18/201-extra_optimization.patch	2022-03-22 08:54:47.287464803 +0800
+++ b/target/linux/generic/pending-3.18/201-extra_optimization.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,14 +0,0 @@
---- a/Makefile
-+++ b/Makefile
-@@ -618,9 +618,9 @@ KBUILD_CFLAGS	+= $(call cc-option,-fno-P
- KBUILD_AFLAGS	+= $(call cc-option,-fno-PIE)
- 
- ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
--KBUILD_CFLAGS	+= -Os $(call cc-disable-warning,maybe-uninitialized,)
-+KBUILD_CFLAGS	+= -Os $(EXTRA_OPTIMIZATION) $(call cc-disable-warning,maybe-uninitialized,)
- else
--KBUILD_CFLAGS	+= -O2
-+KBUILD_CFLAGS	+= -O2 -fno-reorder-blocks -fno-tree-ch $(EXTRA_OPTIMIZATION)
- endif
- 
- # Tell gcc to never replace conditional load with a non-conditional one
--- a/target/linux/generic/pending-3.18/202-reduce_module_size.patch	2022-03-22 08:54:47.287464803 +0800
+++ b/target/linux/generic/pending-3.18/202-reduce_module_size.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,11 +0,0 @@
---- a/Makefile
-+++ b/Makefile
-@@ -408,7 +408,7 @@ KBUILD_CFLAGS_KERNEL :=
- KBUILD_AFLAGS   := -D__ASSEMBLY__
- KBUILD_AFLAGS_MODULE  := -DMODULE
- KBUILD_CFLAGS_MODULE  := -DMODULE
--KBUILD_LDFLAGS_MODULE := -T $(srctree)/scripts/module-common.lds
-+KBUILD_LDFLAGS_MODULE = -T $(srctree)/scripts/module-common.lds $(if $(CONFIG_PROFILING),,-s)
- 
- # Read KERNELRELEASE from include/config/kernel.release (if it exists)
- KERNELRELEASE = $(shell cat include/config/kernel.release 2> /dev/null)
--- a/target/linux/generic/pending-3.18/203-kallsyms_uncompressed.patch	2022-03-22 08:54:47.288464804 +0800
+++ b/target/linux/generic/pending-3.18/203-kallsyms_uncompressed.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,108 +0,0 @@
---- a/scripts/kallsyms.c
-+++ b/scripts/kallsyms.c
-@@ -58,6 +58,7 @@ static struct addr_range percpu_range =
- static struct sym_entry *table;
- static unsigned int table_size, table_cnt;
- static int all_symbols = 0;
-+static int uncompressed = 0;
- static int absolute_percpu = 0;
- static char symbol_prefix_char = '\0';
- static unsigned long long kernel_start_addr = 0;
-@@ -392,6 +393,9 @@ static void write_src(void)
- 
- 	free(markers);
- 
-+	if (uncompressed)
-+		return;
-+
- 	output_label("kallsyms_token_table");
- 	off = 0;
- 	for (i = 0; i < 256; i++) {
-@@ -450,6 +454,9 @@ static void *find_token(unsigned char *s
- {
- 	int i;
- 
-+	if (uncompressed)
-+		return NULL;
-+
- 	for (i = 0; i < len - 1; i++) {
- 		if (str[i] == token[0] && str[i+1] == token[1])
- 			return &str[i];
-@@ -522,6 +529,9 @@ static void optimize_result(void)
- {
- 	int i, best;
- 
-+	if (uncompressed)
-+		return;
-+
- 	/* using the '\0' symbol last allows compress_symbols to use standard
- 	 * fast string functions */
- 	for (i = 255; i >= 0; i--) {
-@@ -692,7 +702,9 @@ int main(int argc, char **argv)
- 			} else if (strncmp(argv[i], "--page-offset=", 14) == 0) {
- 				const char *p = &argv[i][14];
- 				kernel_start_addr = strtoull(p, NULL, 16);
--			} else
-+			} else if (strcmp(argv[i], "--uncompressed") == 0)
-+				uncompressed = 1;
-+			else
- 				usage();
- 		}
- 	} else if (argc != 1)
---- a/init/Kconfig
-+++ b/init/Kconfig
-@@ -1338,6 +1338,17 @@ config SYSCTL_ARCH_UNALIGN_ALLOW
- 	  the unaligned access emulation.
- 	  see arch/parisc/kernel/unaligned.c for reference
- 
-+config KALLSYMS_UNCOMPRESSED
-+	bool "Keep kallsyms uncompressed"
-+	depends on KALLSYMS
-+	help
-+		Normally kallsyms contains compressed symbols (using a token table),
-+		reducing the uncompressed kernel image size. Keeping the symbol table
-+		uncompressed significantly improves the size of this part in compressed
-+		kernel images.
-+
-+		Say N unless you need compressed kernel images to be small.
-+
- config HAVE_PCSPKR_PLATFORM
- 	bool
- 
---- a/scripts/link-vmlinux.sh
-+++ b/scripts/link-vmlinux.sh
-@@ -90,6 +90,10 @@ kallsyms()
- 		kallsymopt="${kallsymopt} --absolute-percpu"
- 	fi
- 
-+	if [ -n "${CONFIG_KALLSYMS_UNCOMPRESSED}" ]; then
-+		kallsymopt="${kallsymopt} --uncompressed"
-+	fi
-+
- 	local aflags="${KBUILD_AFLAGS} ${KBUILD_AFLAGS_KERNEL}               \
- 		      ${NOSTDINC_FLAGS} ${LINUXINCLUDE} ${KBUILD_CPPFLAGS}"
- 
---- a/kernel/kallsyms.c
-+++ b/kernel/kallsyms.c
-@@ -109,6 +109,11 @@ static unsigned int kallsyms_expand_symb
- 	 * For every byte on the compressed symbol data, copy the table
- 	 * entry for that byte.
- 	 */
-+#ifdef CONFIG_KALLSYMS_UNCOMPRESSED
-+	memcpy(result, data + 1, len - 1);
-+	result += len - 1;
-+	len = 0;
-+#endif
- 	while (len) {
- 		tptr = &kallsyms_token_table[kallsyms_token_index[*data]];
- 		data++;
-@@ -141,6 +146,9 @@ tail:
-  */
- static char kallsyms_get_symbol_type(unsigned int off)
- {
-+#ifdef CONFIG_KALLSYMS_UNCOMPRESSED
-+	return kallsyms_names[off + 1];
-+#endif
- 	/*
- 	 * Get just the first code, look it up in the token table,
- 	 * and return the first char from this token.
--- a/target/linux/generic/pending-3.18/204-module_strip.patch	2022-03-22 08:54:47.288464804 +0800
+++ b/target/linux/generic/pending-3.18/204-module_strip.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,190 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: [PATCH] build: add a hack for removing non-essential module info
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
---- a/include/linux/module.h
-+++ b/include/linux/module.h
-@@ -84,6 +84,7 @@ void trim_init_extable(struct module *m)
- 
- /* Generic info of form tag = "info" */
- #define MODULE_INFO(tag, info) __MODULE_INFO(tag, tag, info)
-+#define MODULE_INFO_STRIP(tag, info) __MODULE_INFO_STRIP(tag, tag, info)
- 
- /* For userspace: you can also call me... */
- #define MODULE_ALIAS(_alias) MODULE_INFO(alias, _alias)
-@@ -127,12 +128,12 @@ void trim_init_extable(struct module *m)
-  * Author(s), use "Name <email>" or just "Name", for multiple
-  * authors use multiple MODULE_AUTHOR() statements/lines.
-  */
--#define MODULE_AUTHOR(_author) MODULE_INFO(author, _author)
-+#define MODULE_AUTHOR(_author) MODULE_INFO_STRIP(author, _author)
- 
- /* What your module does. */
--#define MODULE_DESCRIPTION(_description) MODULE_INFO(description, _description)
-+#define MODULE_DESCRIPTION(_description) MODULE_INFO_STRIP(description, _description)
- 
--#ifdef MODULE
-+#if defined(MODULE) && !defined(CONFIG_MODULE_STRIPPED)
- /* Creates an alias so file2alias.c can find device table. */
- #define MODULE_DEVICE_TABLE(type, name)					\
- extern const typeof(name) __mod_##type##__##name##_device_table		\
-@@ -159,7 +160,9 @@ extern const typeof(name) __mod_##type##
-  */
- 
- #if defined(MODULE) || !defined(CONFIG_SYSFS)
--#define MODULE_VERSION(_version) MODULE_INFO(version, _version)
-+#define MODULE_VERSION(_version) MODULE_INFO_STRIP(version, _version)
-+#elif defined(CONFIG_MODULE_STRIPPED)
-+#define MODULE_VERSION(_version) __MODULE_INFO_DISABLED(version)
- #else
- #define MODULE_VERSION(_version)					\
- 	static struct module_version_attribute ___modver_attr = {	\
-@@ -181,7 +184,7 @@ extern const typeof(name) __mod_##type##
- /* Optional firmware file (or files) needed by the module
-  * format is simply firmware file name.  Multiple firmware
-  * files require multiple MODULE_FIRMWARE() specifiers */
--#define MODULE_FIRMWARE(_firmware) MODULE_INFO(firmware, _firmware)
-+#define MODULE_FIRMWARE(_firmware) MODULE_INFO_STRIP(firmware, _firmware)
- 
- /* Given an address, look for it in the exception tables */
- const struct exception_table_entry *search_exception_tables(unsigned long add);
---- a/include/linux/moduleparam.h
-+++ b/include/linux/moduleparam.h
-@@ -16,6 +16,16 @@
- /* Chosen so that structs with an unsigned long line up. */
- #define MAX_PARAM_PREFIX_LEN (64 - sizeof(unsigned long))
- 
-+/* This struct is here for syntactic coherency, it is not used */
-+#define __MODULE_INFO_DISABLED(name)					  \
-+  struct __UNIQUE_ID(name) {}
-+
-+#ifdef CONFIG_MODULE_STRIPPED
-+#define __MODULE_INFO_STRIP(tag, name, info) __MODULE_INFO_DISABLED(name)
-+#else
-+#define __MODULE_INFO_STRIP(tag, name, info) __MODULE_INFO(tag, name, info)
-+#endif
-+
- #ifdef MODULE
- #define __MODULE_INFO(tag, name, info)					  \
- static const char __UNIQUE_ID(name)[]					  \
-@@ -23,8 +33,7 @@ static const char __UNIQUE_ID(name)[]
-   = __stringify(tag) "=" info
- #else  /* !MODULE */
- /* This struct is here for syntactic coherency, it is not used */
--#define __MODULE_INFO(tag, name, info)					  \
--  struct __UNIQUE_ID(name) {}
-+#define __MODULE_INFO(tag, name, info) __MODULE_INFO_DISABLED(name)
- #endif
- #define __MODULE_PARM_TYPE(name, _type)					  \
-   __MODULE_INFO(parmtype, name##type, #name ":" _type)
-@@ -32,7 +41,7 @@ static const char __UNIQUE_ID(name)[]
- /* One for each parameter, describing how to use it.  Some files do
-    multiple of these per line, so can't just use MODULE_INFO. */
- #define MODULE_PARM_DESC(_parm, desc) \
--	__MODULE_INFO(parm, _parm, #_parm ":" desc)
-+	__MODULE_INFO_STRIP(parm, _parm, #_parm ":" desc)
- 
- struct kernel_param;
- 
---- a/init/Kconfig
-+++ b/init/Kconfig
-@@ -1987,6 +1987,13 @@ config MODULE_COMPRESS_XZ
- 
- endchoice
- 
-+config MODULE_STRIPPED
-+	bool "Reduce module size"
-+	depends on MODULES
-+	help
-+	  Remove module parameter descriptions, author info, version, aliases,
-+	  device tables, etc.
-+
- endif # MODULES
- 
- config INIT_ALL_POSSIBLE
---- a/kernel/module.c
-+++ b/kernel/module.c
-@@ -2699,6 +2699,7 @@ static struct module *setup_load_info(st
- 
- static int check_modinfo(struct module *mod, struct load_info *info, int flags)
- {
-+#ifndef CONFIG_MODULE_STRIPPED
- 	const char *modmagic = get_modinfo(info, "vermagic");
- 	int err;
- 
-@@ -2724,6 +2725,7 @@ static int check_modinfo(struct module *
- 		pr_warn("%s: module is from the staging directory, the quality "
- 			"is unknown, you have been warned.\n", mod->name);
- 	}
-+#endif
- 
- 	/* Set up license info based on the info section */
- 	set_license(mod, get_modinfo(info, "license"));
---- a/scripts/mod/modpost.c
-+++ b/scripts/mod/modpost.c
-@@ -1760,7 +1760,9 @@ static void read_symbols(char *modname)
- 		symname = remove_dot(info.strtab + sym->st_name);
- 
- 		handle_modversions(mod, &info, sym, symname);
-+#ifndef CONFIG_MODULE_STRIPPED
- 		handle_moddevtable(mod, &info, sym, symname);
-+#endif
- 	}
- 	if (!is_vmlinux(modname) ||
- 	     (is_vmlinux(modname) && vmlinux_section_warnings))
-@@ -1904,7 +1906,9 @@ static void add_header(struct buffer *b,
- 	buf_printf(b, "#include <linux/vermagic.h>\n");
- 	buf_printf(b, "#include <linux/compiler.h>\n");
- 	buf_printf(b, "\n");
-+#ifndef CONFIG_MODULE_STRIPPED
- 	buf_printf(b, "MODULE_INFO(vermagic, VERMAGIC_STRING);\n");
-+#endif
- 	buf_printf(b, "\n");
- 	buf_printf(b, "__visible struct module __this_module\n");
- 	buf_printf(b, "__attribute__((section(\".gnu.linkonce.this_module\"))) = {\n");
-@@ -1921,16 +1925,20 @@ static void add_header(struct buffer *b,
- 
- static void add_intree_flag(struct buffer *b, int is_intree)
- {
-+#ifndef CONFIG_MODULE_STRIPPED
- 	if (is_intree)
- 		buf_printf(b, "\nMODULE_INFO(intree, \"Y\");\n");
-+#endif
- }
- 
- static void add_staging_flag(struct buffer *b, const char *name)
- {
-+#ifndef CONFIG_MODULE_STRIPPED
- 	static const char *staging_dir = "drivers/staging";
- 
- 	if (strncmp(staging_dir, name, strlen(staging_dir)) == 0)
- 		buf_printf(b, "\nMODULE_INFO(staging, \"Y\");\n");
-+#endif
- }
- 
- /**
-@@ -2023,11 +2031,13 @@ static void add_depends(struct buffer *b
- 
- static void add_srcversion(struct buffer *b, struct module *mod)
- {
-+#ifndef CONFIG_MODULE_STRIPPED
- 	if (mod->srcversion[0]) {
- 		buf_printf(b, "\n");
- 		buf_printf(b, "MODULE_INFO(srcversion, \"%s\");\n",
- 			   mod->srcversion);
- 	}
-+#endif
- }
- 
- static void write_if_changed(struct buffer *b, const char *fname)
-@@ -2258,7 +2268,9 @@ int main(int argc, char **argv)
- 		add_staging_flag(&buf, mod->name);
- 		err |= add_versions(&buf, mod);
- 		add_depends(&buf, mod, modules);
-+#ifndef CONFIG_MODULE_STRIPPED
- 		add_moddevtable(&buf, mod);
-+#endif
- 		add_srcversion(&buf, mod);
- 
- 		sprintf(fname, "%s.mod.c", mod->name);
--- a/target/linux/generic/pending-3.18/205-backtrace_module_info.patch	2022-03-22 08:54:47.289464806 +0800
+++ b/target/linux/generic/pending-3.18/205-backtrace_module_info.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,36 +0,0 @@
---- a/lib/vsprintf.c
-+++ b/lib/vsprintf.c
-@@ -614,8 +614,10 @@ char *symbol_string(char *buf, char *end
- 		    struct printf_spec spec, const char *fmt)
- {
- 	unsigned long value;
--#ifdef CONFIG_KALLSYMS
- 	char sym[KSYM_SYMBOL_LEN];
-+#ifndef CONFIG_KALLSYMS
-+	struct module *mod;
-+	int len;
- #endif
- 
- 	if (fmt[1] == 'R')
-@@ -629,15 +631,15 @@ char *symbol_string(char *buf, char *end
- 		sprint_symbol(sym, value);
- 	else
- 		sprint_symbol_no_offset(sym, value);
--
--	return string(buf, end, sym, spec);
- #else
--	spec.field_width = 2 * sizeof(void *);
--	spec.flags |= SPECIAL | SMALL | ZEROPAD;
--	spec.base = 16;
-+	len = snprintf(sym, sizeof(sym), "0x%lx", value);
- 
--	return number(buf, end, value, spec);
-+	mod = __module_address(value);
-+	if (mod)
-+		snprintf(sym + len, sizeof(sym) - len, " [%s@%p+0x%x]",
-+			 mod->name, mod->module_core, mod->core_size);
- #endif
-+	return string(buf, end, sym, spec);
- }
- 
- static noinline_for_stack
--- a/target/linux/generic/pending-3.18/210-darwin_scripts_include.patch	2022-03-22 08:54:47.290464808 +0800
+++ b/target/linux/generic/pending-3.18/210-darwin_scripts_include.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,3088 +0,0 @@
---- a/scripts/kallsyms.c
-+++ b/scripts/kallsyms.c
-@@ -22,6 +22,35 @@
- #include <stdlib.h>
- #include <string.h>
- #include <ctype.h>
-+#ifdef __APPLE__
-+/* Darwin has no memmem implementation, this one is ripped of the uClibc-0.9.28 source */
-+void *memmem (const void *haystack, size_t haystack_len,
-+                          const void *needle,  size_t needle_len)
-+{
-+  const char *begin;
-+  const char *const last_possible
-+    = (const char *) haystack + haystack_len - needle_len;
-+
-+  if (needle_len == 0)
-+    /* The first occurrence of the empty string is deemed to occur at
-+       the beginning of the string.  */
-+    return (void *) haystack;
-+
-+  /* Sanity check, otherwise the loop might search through the whole
-+     memory.  */
-+  if (__builtin_expect (haystack_len < needle_len, 0))
-+    return NULL;
-+
-+  for (begin = (const char *) haystack; begin <= last_possible; ++begin)
-+    if (begin[0] == ((const char *) needle)[0] &&
-+        !memcmp ((const void *) &begin[1],
-+                 (const void *) ((const char *) needle + 1),
-+                 needle_len - 1))
-+      return (void *) begin;
-+
-+  return NULL;
-+}
-+#endif
- 
- #ifndef ARRAY_SIZE
- #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))
---- a/scripts/kconfig/Makefile
-+++ b/scripts/kconfig/Makefile
-@@ -151,6 +151,9 @@ check-lxdialog  := $(srctree)/$(src)/lxd
- # we really need to do so. (Do not call gcc as part of make mrproper)
- HOST_EXTRACFLAGS += $(shell $(CONFIG_SHELL) $(check-lxdialog) -ccflags) \
-                     -DLOCALE
-+ifeq ($(shell uname -s),Darwin)
-+HOST_LOADLIBES  += -lncurses
-+endif
- 
- # ===========================================================================
- # Shared Makefile for the various kconfig executables:
---- a/scripts/mod/mk_elfconfig.c
-+++ b/scripts/mod/mk_elfconfig.c
-@@ -1,7 +1,11 @@
- #include <stdio.h>
- #include <stdlib.h>
- #include <string.h>
-+#ifndef __APPLE__
- #include <elf.h>
-+#else
-+#include "elf.h"
-+#endif
- 
- int
- main(int argc, char **argv)
---- a/scripts/mod/modpost.h
-+++ b/scripts/mod/modpost.h
-@@ -7,7 +7,11 @@
- #include <sys/mman.h>
- #include <fcntl.h>
- #include <unistd.h>
-+#if !(defined(__APPLE__) || defined(__CYGWIN__))
- #include <elf.h>
-+#else
-+#include "elf.h"
-+#endif
- 
- #include "elfconfig.h"
- 
---- /dev/null
-+++ b/scripts/mod/elf.h
-@@ -0,0 +1,3007 @@
-+/* This file defines standard ELF types, structures, and macros.
-+   Copyright (C) 1995-2012 Free Software Foundation, Inc.
-+   This file is part of the GNU C Library.
-+
-+   The GNU C Library is free software; you can redistribute it and/or
-+   modify it under the terms of the GNU Lesser General Public
-+   License as published by the Free Software Foundation; either
-+   version 2.1 of the License, or (at your option) any later version.
-+
-+   The GNU C Library is distributed in the hope that it will be useful,
-+   but WITHOUT ANY WARRANTY; without even the implied warranty of
-+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-+   Lesser General Public License for more details.
-+
-+   You should have received a copy of the GNU Lesser General Public
-+   License along with the GNU C Library; if not, see
-+   <http://www.gnu.org/licenses/>.  */
-+
-+#ifndef _ELF_H
-+#define	_ELF_H 1
-+
-+/* Standard ELF types.  */
-+
-+#include <stdint.h>
-+
-+/* Type for a 16-bit quantity.  */
-+typedef uint16_t Elf32_Half;
-+typedef uint16_t Elf64_Half;
-+
-+/* Types for signed and unsigned 32-bit quantities.  */
-+typedef uint32_t Elf32_Word;
-+typedef	int32_t  Elf32_Sword;
-+typedef uint32_t Elf64_Word;
-+typedef	int32_t  Elf64_Sword;
-+
-+/* Types for signed and unsigned 64-bit quantities.  */
-+typedef uint64_t Elf32_Xword;
-+typedef	int64_t  Elf32_Sxword;
-+typedef uint64_t Elf64_Xword;
-+typedef	int64_t  Elf64_Sxword;
-+
-+/* Type of addresses.  */
-+typedef uint32_t Elf32_Addr;
-+typedef uint64_t Elf64_Addr;
-+
-+/* Type of file offsets.  */
-+typedef uint32_t Elf32_Off;
-+typedef uint64_t Elf64_Off;
-+
-+/* Type for section indices, which are 16-bit quantities.  */
-+typedef uint16_t Elf32_Section;
-+typedef uint16_t Elf64_Section;
-+
-+/* Type for version symbol information.  */
-+typedef Elf32_Half Elf32_Versym;
-+typedef Elf64_Half Elf64_Versym;
-+
-+
-+/* The ELF file header.  This appears at the start of every ELF file.  */
-+
-+#define EI_NIDENT (16)
-+
-+typedef struct
-+{
-+  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
-+  Elf32_Half	e_type;			/* Object file type */
-+  Elf32_Half	e_machine;		/* Architecture */
-+  Elf32_Word	e_version;		/* Object file version */
-+  Elf32_Addr	e_entry;		/* Entry point virtual address */
-+  Elf32_Off	e_phoff;		/* Program header table file offset */
-+  Elf32_Off	e_shoff;		/* Section header table file offset */
-+  Elf32_Word	e_flags;		/* Processor-specific flags */
-+  Elf32_Half	e_ehsize;		/* ELF header size in bytes */
-+  Elf32_Half	e_phentsize;		/* Program header table entry size */
-+  Elf32_Half	e_phnum;		/* Program header table entry count */
-+  Elf32_Half	e_shentsize;		/* Section header table entry size */
-+  Elf32_Half	e_shnum;		/* Section header table entry count */
-+  Elf32_Half	e_shstrndx;		/* Section header string table index */
-+} Elf32_Ehdr;
-+
-+typedef struct
-+{
-+  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
-+  Elf64_Half	e_type;			/* Object file type */
-+  Elf64_Half	e_machine;		/* Architecture */
-+  Elf64_Word	e_version;		/* Object file version */
-+  Elf64_Addr	e_entry;		/* Entry point virtual address */
-+  Elf64_Off	e_phoff;		/* Program header table file offset */
-+  Elf64_Off	e_shoff;		/* Section header table file offset */
-+  Elf64_Word	e_flags;		/* Processor-specific flags */
-+  Elf64_Half	e_ehsize;		/* ELF header size in bytes */
-+  Elf64_Half	e_phentsize;		/* Program header table entry size */
-+  Elf64_Half	e_phnum;		/* Program header table entry count */
-+  Elf64_Half	e_shentsize;		/* Section header table entry size */
-+  Elf64_Half	e_shnum;		/* Section header table entry count */
-+  Elf64_Half	e_shstrndx;		/* Section header string table index */
-+} Elf64_Ehdr;
-+
-+/* Fields in the e_ident array.  The EI_* macros are indices into the
-+   array.  The macros under each EI_* macro are the values the byte
-+   may have.  */
-+
-+#define EI_MAG0		0		/* File identification byte 0 index */
-+#define ELFMAG0		0x7f		/* Magic number byte 0 */
-+
-+#define EI_MAG1		1		/* File identification byte 1 index */
-+#define ELFMAG1		'E'		/* Magic number byte 1 */
-+
-+#define EI_MAG2		2		/* File identification byte 2 index */
-+#define ELFMAG2		'L'		/* Magic number byte 2 */
-+
-+#define EI_MAG3		3		/* File identification byte 3 index */
-+#define ELFMAG3		'F'		/* Magic number byte 3 */
-+
-+/* Conglomeration of the identification bytes, for easy testing as a word.  */
-+#define	ELFMAG		"\177ELF"
-+#define	SELFMAG		4
-+
-+#define EI_CLASS	4		/* File class byte index */
-+#define ELFCLASSNONE	0		/* Invalid class */
-+#define ELFCLASS32	1		/* 32-bit objects */
-+#define ELFCLASS64	2		/* 64-bit objects */
-+#define ELFCLASSNUM	3
-+
-+#define EI_DATA		5		/* Data encoding byte index */
-+#define ELFDATANONE	0		/* Invalid data encoding */
-+#define ELFDATA2LSB	1		/* 2's complement, little endian */
-+#define ELFDATA2MSB	2		/* 2's complement, big endian */
-+#define ELFDATANUM	3
-+
-+#define EI_VERSION	6		/* File version byte index */
-+					/* Value must be EV_CURRENT */
-+
-+#define EI_OSABI	7		/* OS ABI identification */
-+#define ELFOSABI_NONE		0	/* UNIX System V ABI */
-+#define ELFOSABI_SYSV		0	/* Alias.  */
-+#define ELFOSABI_HPUX		1	/* HP-UX */
-+#define ELFOSABI_NETBSD		2	/* NetBSD.  */
-+#define ELFOSABI_GNU		3	/* Object uses GNU ELF extensions.  */
-+#define ELFOSABI_LINUX		ELFOSABI_GNU /* Compatibility alias.  */
-+#define ELFOSABI_SOLARIS	6	/* Sun Solaris.  */
-+#define ELFOSABI_AIX		7	/* IBM AIX.  */
-+#define ELFOSABI_IRIX		8	/* SGI Irix.  */
-+#define ELFOSABI_FREEBSD	9	/* FreeBSD.  */
-+#define ELFOSABI_TRU64		10	/* Compaq TRU64 UNIX.  */
-+#define ELFOSABI_MODESTO	11	/* Novell Modesto.  */
-+#define ELFOSABI_OPENBSD	12	/* OpenBSD.  */
-+#define ELFOSABI_ARM_AEABI	64	/* ARM EABI */
-+#define ELFOSABI_ARM		97	/* ARM */
-+#define ELFOSABI_STANDALONE	255	/* Standalone (embedded) application */
-+
-+#define EI_ABIVERSION	8		/* ABI version */
-+
-+#define EI_PAD		9		/* Byte index of padding bytes */
-+
-+/* Legal values for e_type (object file type).  */
-+
-+#define ET_NONE		0		/* No file type */
-+#define ET_REL		1		/* Relocatable file */
-+#define ET_EXEC		2		/* Executable file */
-+#define ET_DYN		3		/* Shared object file */
-+#define ET_CORE		4		/* Core file */
-+#define	ET_NUM		5		/* Number of defined types */
-+#define ET_LOOS		0xfe00		/* OS-specific range start */
-+#define ET_HIOS		0xfeff		/* OS-specific range end */
-+#define ET_LOPROC	0xff00		/* Processor-specific range start */
-+#define ET_HIPROC	0xffff		/* Processor-specific range end */
-+
-+/* Legal values for e_machine (architecture).  */
-+
-+#define EM_NONE		 0		/* No machine */
-+#define EM_M32		 1		/* AT&T WE 32100 */
-+#define EM_SPARC	 2		/* SUN SPARC */
-+#define EM_386		 3		/* Intel 80386 */
-+#define EM_68K		 4		/* Motorola m68k family */
-+#define EM_88K		 5		/* Motorola m88k family */
-+#define EM_860		 7		/* Intel 80860 */
-+#define EM_MIPS		 8		/* MIPS R3000 big-endian */
-+#define EM_S370		 9		/* IBM System/370 */
-+#define EM_MIPS_RS3_LE	10		/* MIPS R3000 little-endian */
-+
-+#define EM_PARISC	15		/* HPPA */
-+#define EM_VPP500	17		/* Fujitsu VPP500 */
-+#define EM_SPARC32PLUS	18		/* Sun's "v8plus" */
-+#define EM_960		19		/* Intel 80960 */
-+#define EM_PPC		20		/* PowerPC */
-+#define EM_PPC64	21		/* PowerPC 64-bit */
-+#define EM_S390		22		/* IBM S390 */
-+
-+#define EM_V800		36		/* NEC V800 series */
-+#define EM_FR20		37		/* Fujitsu FR20 */
-+#define EM_RH32		38		/* TRW RH-32 */
-+#define EM_RCE		39		/* Motorola RCE */
-+#define EM_ARM		40		/* ARM */
-+#define EM_FAKE_ALPHA	41		/* Digital Alpha */
-+#define EM_SH		42		/* Hitachi SH */
-+#define EM_SPARCV9	43		/* SPARC v9 64-bit */
-+#define EM_TRICORE	44		/* Siemens Tricore */
-+#define EM_ARC		45		/* Argonaut RISC Core */
-+#define EM_H8_300	46		/* Hitachi H8/300 */
-+#define EM_H8_300H	47		/* Hitachi H8/300H */
-+#define EM_H8S		48		/* Hitachi H8S */
-+#define EM_H8_500	49		/* Hitachi H8/500 */
-+#define EM_IA_64	50		/* Intel Merced */
-+#define EM_MIPS_X	51		/* Stanford MIPS-X */
-+#define EM_COLDFIRE	52		/* Motorola Coldfire */
-+#define EM_68HC12	53		/* Motorola M68HC12 */
-+#define EM_MMA		54		/* Fujitsu MMA Multimedia Accelerator*/
-+#define EM_PCP		55		/* Siemens PCP */
-+#define EM_NCPU		56		/* Sony nCPU embeeded RISC */
-+#define EM_NDR1		57		/* Denso NDR1 microprocessor */
-+#define EM_STARCORE	58		/* Motorola Start*Core processor */
-+#define EM_ME16		59		/* Toyota ME16 processor */
-+#define EM_ST100	60		/* STMicroelectronic ST100 processor */
-+#define EM_TINYJ	61		/* Advanced Logic Corp. Tinyj emb.fam*/
-+#define EM_X86_64	62		/* AMD x86-64 architecture */
-+#define EM_PDSP		63		/* Sony DSP Processor */
-+
-+#define EM_FX66		66		/* Siemens FX66 microcontroller */
-+#define EM_ST9PLUS	67		/* STMicroelectronics ST9+ 8/16 mc */
-+#define EM_ST7		68		/* STmicroelectronics ST7 8 bit mc */
-+#define EM_68HC16	69		/* Motorola MC68HC16 microcontroller */
-+#define EM_68HC11	70		/* Motorola MC68HC11 microcontroller */
-+#define EM_68HC08	71		/* Motorola MC68HC08 microcontroller */
-+#define EM_68HC05	72		/* Motorola MC68HC05 microcontroller */
-+#define EM_SVX		73		/* Silicon Graphics SVx */
-+#define EM_ST19		74		/* STMicroelectronics ST19 8 bit mc */
-+#define EM_VAX		75		/* Digital VAX */
-+#define EM_CRIS		76		/* Axis Communications 32-bit embedded processor */
-+#define EM_JAVELIN	77		/* Infineon Technologies 32-bit embedded processor */
-+#define EM_FIREPATH	78		/* Element 14 64-bit DSP Processor */
-+#define EM_ZSP		79		/* LSI Logic 16-bit DSP Processor */
-+#define EM_MMIX		80		/* Donald Knuth's educational 64-bit processor */
-+#define EM_HUANY	81		/* Harvard University machine-independent object files */
-+#define EM_PRISM	82		/* SiTera Prism */
-+#define EM_AVR		83		/* Atmel AVR 8-bit microcontroller */
-+#define EM_FR30		84		/* Fujitsu FR30 */
-+#define EM_D10V		85		/* Mitsubishi D10V */
-+#define EM_D30V		86		/* Mitsubishi D30V */
-+#define EM_V850		87		/* NEC v850 */
-+#define EM_M32R		88		/* Mitsubishi M32R */
-+#define EM_MN10300	89		/* Matsushita MN10300 */
-+#define EM_MN10200	90		/* Matsushita MN10200 */
-+#define EM_PJ		91		/* picoJava */
-+#define EM_OPENRISC	92		/* OpenRISC 32-bit embedded processor */
-+#define EM_ARC_A5	93		/* ARC Cores Tangent-A5 */
-+#define EM_XTENSA	94		/* Tensilica Xtensa Architecture */
-+#define EM_TILEPRO	188		/* Tilera TILEPro */
-+#define EM_TILEGX	191		/* Tilera TILE-Gx */
-+#define EM_NUM		192
-+
-+/* If it is necessary to assign new unofficial EM_* values, please
-+   pick large random numbers (0x8523, 0xa7f2, etc.) to minimize the
-+   chances of collision with official or non-GNU unofficial values.  */
-+
-+#define EM_ALPHA	0x9026
-+
-+/* Legal values for e_version (version).  */
-+
-+#define EV_NONE		0		/* Invalid ELF version */
-+#define EV_CURRENT	1		/* Current version */
-+#define EV_NUM		2
-+
-+/* Section header.  */
-+
-+typedef struct
-+{
-+  Elf32_Word	sh_name;		/* Section name (string tbl index) */
-+  Elf32_Word	sh_type;		/* Section type */
-+  Elf32_Word	sh_flags;		/* Section flags */
-+  Elf32_Addr	sh_addr;		/* Section virtual addr at execution */
-+  Elf32_Off	sh_offset;		/* Section file offset */
-+  Elf32_Word	sh_size;		/* Section size in bytes */
-+  Elf32_Word	sh_link;		/* Link to another section */
-+  Elf32_Word	sh_info;		/* Additional section information */
-+  Elf32_Word	sh_addralign;		/* Section alignment */
-+  Elf32_Word	sh_entsize;		/* Entry size if section holds table */
-+} Elf32_Shdr;
-+
-+typedef struct
-+{
-+  Elf64_Word	sh_name;		/* Section name (string tbl index) */
-+  Elf64_Word	sh_type;		/* Section type */
-+  Elf64_Xword	sh_flags;		/* Section flags */
-+  Elf64_Addr	sh_addr;		/* Section virtual addr at execution */
-+  Elf64_Off	sh_offset;		/* Section file offset */
-+  Elf64_Xword	sh_size;		/* Section size in bytes */
-+  Elf64_Word	sh_link;		/* Link to another section */
-+  Elf64_Word	sh_info;		/* Additional section information */
-+  Elf64_Xword	sh_addralign;		/* Section alignment */
-+  Elf64_Xword	sh_entsize;		/* Entry size if section holds table */
-+} Elf64_Shdr;
-+
-+/* Special section indices.  */
-+
-+#define SHN_UNDEF	0		/* Undefined section */
-+#define SHN_LORESERVE	0xff00		/* Start of reserved indices */
-+#define SHN_LOPROC	0xff00		/* Start of processor-specific */
-+#define SHN_BEFORE	0xff00		/* Order section before all others
-+					   (Solaris).  */
-+#define SHN_AFTER	0xff01		/* Order section after all others
-+					   (Solaris).  */
-+#define SHN_HIPROC	0xff1f		/* End of processor-specific */
-+#define SHN_LOOS	0xff20		/* Start of OS-specific */
-+#define SHN_HIOS	0xff3f		/* End of OS-specific */
-+#define SHN_ABS		0xfff1		/* Associated symbol is absolute */
-+#define SHN_COMMON	0xfff2		/* Associated symbol is common */
-+#define SHN_XINDEX	0xffff		/* Index is in extra table.  */
-+#define SHN_HIRESERVE	0xffff		/* End of reserved indices */
-+
-+/* Legal values for sh_type (section type).  */
-+
-+#define SHT_NULL	  0		/* Section header table entry unused */
-+#define SHT_PROGBITS	  1		/* Program data */
-+#define SHT_SYMTAB	  2		/* Symbol table */
-+#define SHT_STRTAB	  3		/* String table */
-+#define SHT_RELA	  4		/* Relocation entries with addends */
-+#define SHT_HASH	  5		/* Symbol hash table */
-+#define SHT_DYNAMIC	  6		/* Dynamic linking information */
-+#define SHT_NOTE	  7		/* Notes */
-+#define SHT_NOBITS	  8		/* Program space with no data (bss) */
-+#define SHT_REL		  9		/* Relocation entries, no addends */
-+#define SHT_SHLIB	  10		/* Reserved */
-+#define SHT_DYNSYM	  11		/* Dynamic linker symbol table */
-+#define SHT_INIT_ARRAY	  14		/* Array of constructors */
-+#define SHT_FINI_ARRAY	  15		/* Array of destructors */
-+#define SHT_PREINIT_ARRAY 16		/* Array of pre-constructors */
-+#define SHT_GROUP	  17		/* Section group */
-+#define SHT_SYMTAB_SHNDX  18		/* Extended section indeces */
-+#define	SHT_NUM		  19		/* Number of defined types.  */
-+#define SHT_LOOS	  0x60000000	/* Start OS-specific.  */
-+#define SHT_GNU_ATTRIBUTES 0x6ffffff5	/* Object attributes.  */
-+#define SHT_GNU_HASH	  0x6ffffff6	/* GNU-style hash table.  */
-+#define SHT_GNU_LIBLIST	  0x6ffffff7	/* Prelink library list */
-+#define SHT_CHECKSUM	  0x6ffffff8	/* Checksum for DSO content.  */
-+#define SHT_LOSUNW	  0x6ffffffa	/* Sun-specific low bound.  */
-+#define SHT_SUNW_move	  0x6ffffffa
-+#define SHT_SUNW_COMDAT   0x6ffffffb
-+#define SHT_SUNW_syminfo  0x6ffffffc
-+#define SHT_GNU_verdef	  0x6ffffffd	/* Version definition section.  */
-+#define SHT_GNU_verneed	  0x6ffffffe	/* Version needs section.  */
-+#define SHT_GNU_versym	  0x6fffffff	/* Version symbol table.  */
-+#define SHT_HISUNW	  0x6fffffff	/* Sun-specific high bound.  */
-+#define SHT_HIOS	  0x6fffffff	/* End OS-specific type */
-+#define SHT_LOPROC	  0x70000000	/* Start of processor-specific */
-+#define SHT_HIPROC	  0x7fffffff	/* End of processor-specific */
-+#define SHT_LOUSER	  0x80000000	/* Start of application-specific */
-+#define SHT_HIUSER	  0x8fffffff	/* End of application-specific */
-+
-+/* Legal values for sh_flags (section flags).  */
-+
-+#define SHF_WRITE	     (1 << 0)	/* Writable */
-+#define SHF_ALLOC	     (1 << 1)	/* Occupies memory during execution */
-+#define SHF_EXECINSTR	     (1 << 2)	/* Executable */
-+#define SHF_MERGE	     (1 << 4)	/* Might be merged */
-+#define SHF_STRINGS	     (1 << 5)	/* Contains nul-terminated strings */
-+#define SHF_INFO_LINK	     (1 << 6)	/* `sh_info' contains SHT index */
-+#define SHF_LINK_ORDER	     (1 << 7)	/* Preserve order after combining */
-+#define SHF_OS_NONCONFORMING (1 << 8)	/* Non-standard OS specific handling
-+					   required */
-+#define SHF_GROUP	     (1 << 9)	/* Section is member of a group.  */
-+#define SHF_TLS		     (1 << 10)	/* Section hold thread-local data.  */
-+#define SHF_MASKOS	     0x0ff00000	/* OS-specific.  */
-+#define SHF_MASKPROC	     0xf0000000	/* Processor-specific */
-+#define SHF_ORDERED	     (1 << 30)	/* Special ordering requirement
-+					   (Solaris).  */
-+#define SHF_EXCLUDE	     (1 << 31)	/* Section is excluded unless
-+					   referenced or allocated (Solaris).*/
-+
-+/* Section group handling.  */
-+#define GRP_COMDAT	0x1		/* Mark group as COMDAT.  */
-+
-+/* Symbol table entry.  */
-+
-+typedef struct
-+{
-+  Elf32_Word	st_name;		/* Symbol name (string tbl index) */
-+  Elf32_Addr	st_value;		/* Symbol value */
-+  Elf32_Word	st_size;		/* Symbol size */
-+  unsigned char	st_info;		/* Symbol type and binding */
-+  unsigned char	st_other;		/* Symbol visibility */
-+  Elf32_Section	st_shndx;		/* Section index */
-+} Elf32_Sym;
-+
-+typedef struct
-+{
-+  Elf64_Word	st_name;		/* Symbol name (string tbl index) */
-+  unsigned char	st_info;		/* Symbol type and binding */
-+  unsigned char st_other;		/* Symbol visibility */
-+  Elf64_Section	st_shndx;		/* Section index */
-+  Elf64_Addr	st_value;		/* Symbol value */
-+  Elf64_Xword	st_size;		/* Symbol size */
-+} Elf64_Sym;
-+
-+/* The syminfo section if available contains additional information about
-+   every dynamic symbol.  */
-+
-+typedef struct
-+{
-+  Elf32_Half si_boundto;		/* Direct bindings, symbol bound to */
-+  Elf32_Half si_flags;			/* Per symbol flags */
-+} Elf32_Syminfo;
-+
-+typedef struct
-+{
-+  Elf64_Half si_boundto;		/* Direct bindings, symbol bound to */
-+  Elf64_Half si_flags;			/* Per symbol flags */
-+} Elf64_Syminfo;
-+
-+/* Possible values for si_boundto.  */
-+#define SYMINFO_BT_SELF		0xffff	/* Symbol bound to self */
-+#define SYMINFO_BT_PARENT	0xfffe	/* Symbol bound to parent */
-+#define SYMINFO_BT_LOWRESERVE	0xff00	/* Beginning of reserved entries */
-+
-+/* Possible bitmasks for si_flags.  */
-+#define SYMINFO_FLG_DIRECT	0x0001	/* Direct bound symbol */
-+#define SYMINFO_FLG_PASSTHRU	0x0002	/* Pass-thru symbol for translator */
-+#define SYMINFO_FLG_COPY	0x0004	/* Symbol is a copy-reloc */
-+#define SYMINFO_FLG_LAZYLOAD	0x0008	/* Symbol bound to object to be lazy
-+					   loaded */
-+/* Syminfo version values.  */
-+#define SYMINFO_NONE		0
-+#define SYMINFO_CURRENT		1
-+#define SYMINFO_NUM		2
-+
-+
-+/* How to extract and insert information held in the st_info field.  */
-+
-+#define ELF32_ST_BIND(val)		(((unsigned char) (val)) >> 4)
-+#define ELF32_ST_TYPE(val)		((val) & 0xf)
-+#define ELF32_ST_INFO(bind, type)	(((bind) << 4) + ((type) & 0xf))
-+
-+/* Both Elf32_Sym and Elf64_Sym use the same one-byte st_info field.  */
-+#define ELF64_ST_BIND(val)		ELF32_ST_BIND (val)
-+#define ELF64_ST_TYPE(val)		ELF32_ST_TYPE (val)
-+#define ELF64_ST_INFO(bind, type)	ELF32_ST_INFO ((bind), (type))
-+
-+/* Legal values for ST_BIND subfield of st_info (symbol binding).  */
-+
-+#define STB_LOCAL	0		/* Local symbol */
-+#define STB_GLOBAL	1		/* Global symbol */
-+#define STB_WEAK	2		/* Weak symbol */
-+#define	STB_NUM		3		/* Number of defined types.  */
-+#define STB_LOOS	10		/* Start of OS-specific */
-+#define STB_GNU_UNIQUE	10		/* Unique symbol.  */
-+#define STB_HIOS	12		/* End of OS-specific */
-+#define STB_LOPROC	13		/* Start of processor-specific */
-+#define STB_HIPROC	15		/* End of processor-specific */
-+
-+/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
-+
-+#define STT_NOTYPE	0		/* Symbol type is unspecified */
-+#define STT_OBJECT	1		/* Symbol is a data object */
-+#define STT_FUNC	2		/* Symbol is a code object */
-+#define STT_SECTION	3		/* Symbol associated with a section */
-+#define STT_FILE	4		/* Symbol's name is file name */
-+#define STT_COMMON	5		/* Symbol is a common data object */
-+#define STT_TLS		6		/* Symbol is thread-local data object*/
-+#define	STT_NUM		7		/* Number of defined types.  */
-+#define STT_LOOS	10		/* Start of OS-specific */
-+#define STT_GNU_IFUNC	10		/* Symbol is indirect code object */
-+#define STT_HIOS	12		/* End of OS-specific */
-+#define STT_LOPROC	13		/* Start of processor-specific */
-+#define STT_HIPROC	15		/* End of processor-specific */
-+
-+
-+/* Symbol table indices are found in the hash buckets and chain table
-+   of a symbol hash table section.  This special index value indicates
-+   the end of a chain, meaning no further symbols are found in that bucket.  */
-+
-+#define STN_UNDEF	0		/* End of a chain.  */
-+
-+
-+/* How to extract and insert information held in the st_other field.  */
-+
-+#define ELF32_ST_VISIBILITY(o)	((o) & 0x03)
-+
-+/* For ELF64 the definitions are the same.  */
-+#define ELF64_ST_VISIBILITY(o)	ELF32_ST_VISIBILITY (o)
-+
-+/* Symbol visibility specification encoded in the st_other field.  */
-+#define STV_DEFAULT	0		/* Default symbol visibility rules */
-+#define STV_INTERNAL	1		/* Processor specific hidden class */
-+#define STV_HIDDEN	2		/* Sym unavailable in other modules */
-+#define STV_PROTECTED	3		/* Not preemptible, not exported */
-+
-+
-+/* Relocation table entry without addend (in section of type SHT_REL).  */
-+
-+typedef struct
-+{
-+  Elf32_Addr	r_offset;		/* Address */
-+  Elf32_Word	r_info;			/* Relocation type and symbol index */
-+} Elf32_Rel;
-+
-+/* I have seen two different definitions of the Elf64_Rel and
-+   Elf64_Rela structures, so we'll leave them out until Novell (or
-+   whoever) gets their act together.  */
-+/* The following, at least, is used on Sparc v9, MIPS, and Alpha.  */
-+
-+typedef struct
-+{
-+  Elf64_Addr	r_offset;		/* Address */
-+  Elf64_Xword	r_info;			/* Relocation type and symbol index */
-+} Elf64_Rel;
-+
-+/* Relocation table entry with addend (in section of type SHT_RELA).  */
-+
-+typedef struct
-+{
-+  Elf32_Addr	r_offset;		/* Address */
-+  Elf32_Word	r_info;			/* Relocation type and symbol index */
-+  Elf32_Sword	r_addend;		/* Addend */
-+} Elf32_Rela;
-+
-+typedef struct
-+{
-+  Elf64_Addr	r_offset;		/* Address */
-+  Elf64_Xword	r_info;			/* Relocation type and symbol index */
-+  Elf64_Sxword	r_addend;		/* Addend */
-+} Elf64_Rela;
-+
-+/* How to extract and insert information held in the r_info field.  */
-+
-+#define ELF32_R_SYM(val)		((val) >> 8)
-+#define ELF32_R_TYPE(val)		((val) & 0xff)
-+#define ELF32_R_INFO(sym, type)		(((sym) << 8) + ((type) & 0xff))
-+
-+#define ELF64_R_SYM(i)			((i) >> 32)
-+#define ELF64_R_TYPE(i)			((i) & 0xffffffff)
-+#define ELF64_R_INFO(sym,type)		((((Elf64_Xword) (sym)) << 32) + (type))
-+
-+/* Program segment header.  */
-+
-+typedef struct
-+{
-+  Elf32_Word	p_type;			/* Segment type */
-+  Elf32_Off	p_offset;		/* Segment file offset */
-+  Elf32_Addr	p_vaddr;		/* Segment virtual address */
-+  Elf32_Addr	p_paddr;		/* Segment physical address */
-+  Elf32_Word	p_filesz;		/* Segment size in file */
-+  Elf32_Word	p_memsz;		/* Segment size in memory */
-+  Elf32_Word	p_flags;		/* Segment flags */
-+  Elf32_Word	p_align;		/* Segment alignment */
-+} Elf32_Phdr;
-+
-+typedef struct
-+{
-+  Elf64_Word	p_type;			/* Segment type */
-+  Elf64_Word	p_flags;		/* Segment flags */
-+  Elf64_Off	p_offset;		/* Segment file offset */
-+  Elf64_Addr	p_vaddr;		/* Segment virtual address */
-+  Elf64_Addr	p_paddr;		/* Segment physical address */
-+  Elf64_Xword	p_filesz;		/* Segment size in file */
-+  Elf64_Xword	p_memsz;		/* Segment size in memory */
-+  Elf64_Xword	p_align;		/* Segment alignment */
-+} Elf64_Phdr;
-+
-+/* Special value for e_phnum.  This indicates that the real number of
-+   program headers is too large to fit into e_phnum.  Instead the real
-+   value is in the field sh_info of section 0.  */
-+
-+#define PN_XNUM		0xffff
-+
-+/* Legal values for p_type (segment type).  */
-+
-+#define	PT_NULL		0		/* Program header table entry unused */
-+#define PT_LOAD		1		/* Loadable program segment */
-+#define PT_DYNAMIC	2		/* Dynamic linking information */
-+#define PT_INTERP	3		/* Program interpreter */
-+#define PT_NOTE		4		/* Auxiliary information */
-+#define PT_SHLIB	5		/* Reserved */
-+#define PT_PHDR		6		/* Entry for header table itself */
-+#define PT_TLS		7		/* Thread-local storage segment */
-+#define	PT_NUM		8		/* Number of defined types */
-+#define PT_LOOS		0x60000000	/* Start of OS-specific */
-+#define PT_GNU_EH_FRAME	0x6474e550	/* GCC .eh_frame_hdr segment */
-+#define PT_GNU_STACK	0x6474e551	/* Indicates stack executability */
-+#define PT_GNU_RELRO	0x6474e552	/* Read-only after relocation */
-+#define PT_LOSUNW	0x6ffffffa
-+#define PT_SUNWBSS	0x6ffffffa	/* Sun Specific segment */
-+#define PT_SUNWSTACK	0x6ffffffb	/* Stack segment */
-+#define PT_HISUNW	0x6fffffff
-+#define PT_HIOS		0x6fffffff	/* End of OS-specific */
-+#define PT_LOPROC	0x70000000	/* Start of processor-specific */
-+#define PT_HIPROC	0x7fffffff	/* End of processor-specific */
-+
-+/* Legal values for p_flags (segment flags).  */
-+
-+#define PF_X		(1 << 0)	/* Segment is executable */
-+#define PF_W		(1 << 1)	/* Segment is writable */
-+#define PF_R		(1 << 2)	/* Segment is readable */
-+#define PF_MASKOS	0x0ff00000	/* OS-specific */
-+#define PF_MASKPROC	0xf0000000	/* Processor-specific */
-+
-+/* Legal values for note segment descriptor types for core files. */
-+
-+#define NT_PRSTATUS	1		/* Contains copy of prstatus struct */
-+#define NT_FPREGSET	2		/* Contains copy of fpregset struct */
-+#define NT_PRPSINFO	3		/* Contains copy of prpsinfo struct */
-+#define NT_PRXREG	4		/* Contains copy of prxregset struct */
-+#define NT_TASKSTRUCT	4		/* Contains copy of task structure */
-+#define NT_PLATFORM	5		/* String from sysinfo(SI_PLATFORM) */
-+#define NT_AUXV		6		/* Contains copy of auxv array */
-+#define NT_GWINDOWS	7		/* Contains copy of gwindows struct */
-+#define NT_ASRS		8		/* Contains copy of asrset struct */
-+#define NT_PSTATUS	10		/* Contains copy of pstatus struct */
-+#define NT_PSINFO	13		/* Contains copy of psinfo struct */
-+#define NT_PRCRED	14		/* Contains copy of prcred struct */
-+#define NT_UTSNAME	15		/* Contains copy of utsname struct */
-+#define NT_LWPSTATUS	16		/* Contains copy of lwpstatus struct */
-+#define NT_LWPSINFO	17		/* Contains copy of lwpinfo struct */
-+#define NT_PRFPXREG	20		/* Contains copy of fprxregset struct */
-+#define NT_PRXFPREG	0x46e62b7f	/* Contains copy of user_fxsr_struct */
-+#define NT_PPC_VMX	0x100		/* PowerPC Altivec/VMX registers */
-+#define NT_PPC_SPE	0x101		/* PowerPC SPE/EVR registers */
-+#define NT_PPC_VSX	0x102		/* PowerPC VSX registers */
-+#define NT_386_TLS	0x200		/* i386 TLS slots (struct user_desc) */
-+#define NT_386_IOPERM	0x201		/* x86 io permission bitmap (1=deny) */
-+#define NT_X86_XSTATE	0x202		/* x86 extended state using xsave */
-+
-+/* Legal values for the note segment descriptor types for object files.  */
-+
-+#define NT_VERSION	1		/* Contains a version string.  */
-+
-+
-+/* Dynamic section entry.  */
-+
-+typedef struct
-+{
-+  Elf32_Sword	d_tag;			/* Dynamic entry type */
-+  union
-+    {
-+      Elf32_Word d_val;			/* Integer value */
-+      Elf32_Addr d_ptr;			/* Address value */
-+    } d_un;
-+} Elf32_Dyn;
-+
-+typedef struct
-+{
-+  Elf64_Sxword	d_tag;			/* Dynamic entry type */
-+  union
-+    {
-+      Elf64_Xword d_val;		/* Integer value */
-+      Elf64_Addr d_ptr;			/* Address value */
-+    } d_un;
-+} Elf64_Dyn;
-+
-+/* Legal values for d_tag (dynamic entry type).  */
-+
-+#define DT_NULL		0		/* Marks end of dynamic section */
-+#define DT_NEEDED	1		/* Name of needed library */
-+#define DT_PLTRELSZ	2		/* Size in bytes of PLT relocs */
-+#define DT_PLTGOT	3		/* Processor defined value */
-+#define DT_HASH		4		/* Address of symbol hash table */
-+#define DT_STRTAB	5		/* Address of string table */
-+#define DT_SYMTAB	6		/* Address of symbol table */
-+#define DT_RELA		7		/* Address of Rela relocs */
-+#define DT_RELASZ	8		/* Total size of Rela relocs */
-+#define DT_RELAENT	9		/* Size of one Rela reloc */
-+#define DT_STRSZ	10		/* Size of string table */
-+#define DT_SYMENT	11		/* Size of one symbol table entry */
-+#define DT_INIT		12		/* Address of init function */
-+#define DT_FINI		13		/* Address of termination function */
-+#define DT_SONAME	14		/* Name of shared object */
-+#define DT_RPATH	15		/* Library search path (deprecated) */
-+#define DT_SYMBOLIC	16		/* Start symbol search here */
-+#define DT_REL		17		/* Address of Rel relocs */
-+#define DT_RELSZ	18		/* Total size of Rel relocs */
-+#define DT_RELENT	19		/* Size of one Rel reloc */
-+#define DT_PLTREL	20		/* Type of reloc in PLT */
-+#define DT_DEBUG	21		/* For debugging; unspecified */
-+#define DT_TEXTREL	22		/* Reloc might modify .text */
-+#define DT_JMPREL	23		/* Address of PLT relocs */
-+#define	DT_BIND_NOW	24		/* Process relocations of object */
-+#define	DT_INIT_ARRAY	25		/* Array with addresses of init fct */
-+#define	DT_FINI_ARRAY	26		/* Array with addresses of fini fct */
-+#define	DT_INIT_ARRAYSZ	27		/* Size in bytes of DT_INIT_ARRAY */
-+#define	DT_FINI_ARRAYSZ	28		/* Size in bytes of DT_FINI_ARRAY */
-+#define DT_RUNPATH	29		/* Library search path */
-+#define DT_FLAGS	30		/* Flags for the object being loaded */
-+#define DT_ENCODING	32		/* Start of encoded range */
-+#define DT_PREINIT_ARRAY 32		/* Array with addresses of preinit fct*/
-+#define DT_PREINIT_ARRAYSZ 33		/* size in bytes of DT_PREINIT_ARRAY */
-+#define	DT_NUM		34		/* Number used */
-+#define DT_LOOS		0x6000000d	/* Start of OS-specific */
-+#define DT_HIOS		0x6ffff000	/* End of OS-specific */
-+#define DT_LOPROC	0x70000000	/* Start of processor-specific */
-+#define DT_HIPROC	0x7fffffff	/* End of processor-specific */
-+#define	DT_PROCNUM	DT_MIPS_NUM	/* Most used by any processor */
-+
-+/* DT_* entries which fall between DT_VALRNGHI & DT_VALRNGLO use the
-+   Dyn.d_un.d_val field of the Elf*_Dyn structure.  This follows Sun's
-+   approach.  */
-+#define DT_VALRNGLO	0x6ffffd00
-+#define DT_GNU_PRELINKED 0x6ffffdf5	/* Prelinking timestamp */
-+#define DT_GNU_CONFLICTSZ 0x6ffffdf6	/* Size of conflict section */
-+#define DT_GNU_LIBLISTSZ 0x6ffffdf7	/* Size of library list */
-+#define DT_CHECKSUM	0x6ffffdf8
-+#define DT_PLTPADSZ	0x6ffffdf9
-+#define DT_MOVEENT	0x6ffffdfa
-+#define DT_MOVESZ	0x6ffffdfb
-+#define DT_FEATURE_1	0x6ffffdfc	/* Feature selection (DTF_*).  */
-+#define DT_POSFLAG_1	0x6ffffdfd	/* Flags for DT_* entries, effecting
-+					   the following DT_* entry.  */
-+#define DT_SYMINSZ	0x6ffffdfe	/* Size of syminfo table (in bytes) */
-+#define DT_SYMINENT	0x6ffffdff	/* Entry size of syminfo */
-+#define DT_VALRNGHI	0x6ffffdff
-+#define DT_VALTAGIDX(tag)	(DT_VALRNGHI - (tag))	/* Reverse order! */
-+#define DT_VALNUM 12
-+
-+/* DT_* entries which fall between DT_ADDRRNGHI & DT_ADDRRNGLO use the
-+   Dyn.d_un.d_ptr field of the Elf*_Dyn structure.
-+
-+   If any adjustment is made to the ELF object after it has been
-+   built these entries will need to be adjusted.  */
-+#define DT_ADDRRNGLO	0x6ffffe00
-+#define DT_GNU_HASH	0x6ffffef5	/* GNU-style hash table.  */
-+#define DT_TLSDESC_PLT	0x6ffffef6
-+#define DT_TLSDESC_GOT	0x6ffffef7
-+#define DT_GNU_CONFLICT	0x6ffffef8	/* Start of conflict section */
-+#define DT_GNU_LIBLIST	0x6ffffef9	/* Library list */
-+#define DT_CONFIG	0x6ffffefa	/* Configuration information.  */
-+#define DT_DEPAUDIT	0x6ffffefb	/* Dependency auditing.  */
-+#define DT_AUDIT	0x6ffffefc	/* Object auditing.  */
-+#define	DT_PLTPAD	0x6ffffefd	/* PLT padding.  */
-+#define	DT_MOVETAB	0x6ffffefe	/* Move table.  */
-+#define DT_SYMINFO	0x6ffffeff	/* Syminfo table.  */
-+#define DT_ADDRRNGHI	0x6ffffeff
-+#define DT_ADDRTAGIDX(tag)	(DT_ADDRRNGHI - (tag))	/* Reverse order! */
-+#define DT_ADDRNUM 11
-+
-+/* The versioning entry types.  The next are defined as part of the
-+   GNU extension.  */
-+#define DT_VERSYM	0x6ffffff0
-+
-+#define DT_RELACOUNT	0x6ffffff9
-+#define DT_RELCOUNT	0x6ffffffa
-+
-+/* These were chosen by Sun.  */
-+#define DT_FLAGS_1	0x6ffffffb	/* State flags, see DF_1_* below.  */
-+#define	DT_VERDEF	0x6ffffffc	/* Address of version definition
-+					   table */
-+#define	DT_VERDEFNUM	0x6ffffffd	/* Number of version definitions */
-+#define	DT_VERNEED	0x6ffffffe	/* Address of table with needed
-+					   versions */
-+#define	DT_VERNEEDNUM	0x6fffffff	/* Number of needed versions */
-+#define DT_VERSIONTAGIDX(tag)	(DT_VERNEEDNUM - (tag))	/* Reverse order! */
-+#define DT_VERSIONTAGNUM 16
-+
-+/* Sun added these machine-independent extensions in the "processor-specific"
-+   range.  Be compatible.  */
-+#define DT_AUXILIARY    0x7ffffffd      /* Shared object to load before self */
-+#define DT_FILTER       0x7fffffff      /* Shared object to get values from */
-+#define DT_EXTRATAGIDX(tag)	((Elf32_Word)-((Elf32_Sword) (tag) <<1>>1)-1)
-+#define DT_EXTRANUM	3
-+
-+/* Values of `d_un.d_val' in the DT_FLAGS entry.  */
-+#define DF_ORIGIN	0x00000001	/* Object may use DF_ORIGIN */
-+#define DF_SYMBOLIC	0x00000002	/* Symbol resolutions starts here */
-+#define DF_TEXTREL	0x00000004	/* Object contains text relocations */
-+#define DF_BIND_NOW	0x00000008	/* No lazy binding for this object */
-+#define DF_STATIC_TLS	0x00000010	/* Module uses the static TLS model */
-+
-+/* State flags selectable in the `d_un.d_val' element of the DT_FLAGS_1
-+   entry in the dynamic section.  */
-+#define DF_1_NOW	0x00000001	/* Set RTLD_NOW for this object.  */
-+#define DF_1_GLOBAL	0x00000002	/* Set RTLD_GLOBAL for this object.  */
-+#define DF_1_GROUP	0x00000004	/* Set RTLD_GROUP for this object.  */
-+#define DF_1_NODELETE	0x00000008	/* Set RTLD_NODELETE for this object.*/
-+#define DF_1_LOADFLTR	0x00000010	/* Trigger filtee loading at runtime.*/
-+#define DF_1_INITFIRST	0x00000020	/* Set RTLD_INITFIRST for this object*/
-+#define DF_1_NOOPEN	0x00000040	/* Set RTLD_NOOPEN for this object.  */
-+#define DF_1_ORIGIN	0x00000080	/* $ORIGIN must be handled.  */
-+#define DF_1_DIRECT	0x00000100	/* Direct binding enabled.  */
-+#define DF_1_TRANS	0x00000200
-+#define DF_1_INTERPOSE	0x00000400	/* Object is used to interpose.  */
-+#define DF_1_NODEFLIB	0x00000800	/* Ignore default lib search path.  */
-+#define DF_1_NODUMP	0x00001000	/* Object can't be dldump'ed.  */
-+#define DF_1_CONFALT	0x00002000	/* Configuration alternative created.*/
-+#define DF_1_ENDFILTEE	0x00004000	/* Filtee terminates filters search. */
-+#define	DF_1_DISPRELDNE	0x00008000	/* Disp reloc applied at build time. */
-+#define	DF_1_DISPRELPND	0x00010000	/* Disp reloc applied at run-time.  */
-+
-+/* Flags for the feature selection in DT_FEATURE_1.  */
-+#define DTF_1_PARINIT	0x00000001
-+#define DTF_1_CONFEXP	0x00000002
-+
-+/* Flags in the DT_POSFLAG_1 entry effecting only the next DT_* entry.  */
-+#define DF_P1_LAZYLOAD	0x00000001	/* Lazyload following object.  */
-+#define DF_P1_GROUPPERM	0x00000002	/* Symbols from next object are not
-+					   generally available.  */
-+
-+/* Version definition sections.  */
-+
-+typedef struct
-+{
-+  Elf32_Half	vd_version;		/* Version revision */
-+  Elf32_Half	vd_flags;		/* Version information */
-+  Elf32_Half	vd_ndx;			/* Version Index */
-+  Elf32_Half	vd_cnt;			/* Number of associated aux entries */
-+  Elf32_Word	vd_hash;		/* Version name hash value */
-+  Elf32_Word	vd_aux;			/* Offset in bytes to verdaux array */
-+  Elf32_Word	vd_next;		/* Offset in bytes to next verdef
-+					   entry */
-+} Elf32_Verdef;
-+
-+typedef struct
-+{
-+  Elf64_Half	vd_version;		/* Version revision */
-+  Elf64_Half	vd_flags;		/* Version information */
-+  Elf64_Half	vd_ndx;			/* Version Index */
-+  Elf64_Half	vd_cnt;			/* Number of associated aux entries */
-+  Elf64_Word	vd_hash;		/* Version name hash value */
-+  Elf64_Word	vd_aux;			/* Offset in bytes to verdaux array */
-+  Elf64_Word	vd_next;		/* Offset in bytes to next verdef
-+					   entry */
-+} Elf64_Verdef;
-+
-+
-+/* Legal values for vd_version (version revision).  */
-+#define VER_DEF_NONE	0		/* No version */
-+#define VER_DEF_CURRENT	1		/* Current version */
-+#define VER_DEF_NUM	2		/* Given version number */
-+
-+/* Legal values for vd_flags (version information flags).  */
-+#define VER_FLG_BASE	0x1		/* Version definition of file itself */
-+#define VER_FLG_WEAK	0x2		/* Weak version identifier */
-+
-+/* Versym symbol index values.  */
-+#define	VER_NDX_LOCAL		0	/* Symbol is local.  */
-+#define	VER_NDX_GLOBAL		1	/* Symbol is global.  */
-+#define	VER_NDX_LORESERVE	0xff00	/* Beginning of reserved entries.  */
-+#define	VER_NDX_ELIMINATE	0xff01	/* Symbol is to be eliminated.  */
-+
-+/* Auxialiary version information.  */
-+
-+typedef struct
-+{
-+  Elf32_Word	vda_name;		/* Version or dependency names */
-+  Elf32_Word	vda_next;		/* Offset in bytes to next verdaux
-+					   entry */
-+} Elf32_Verdaux;
-+
-+typedef struct
-+{
-+  Elf64_Word	vda_name;		/* Version or dependency names */
-+  Elf64_Word	vda_next;		/* Offset in bytes to next verdaux
-+					   entry */
-+} Elf64_Verdaux;
-+
-+
-+/* Version dependency section.  */
-+
-+typedef struct
-+{
-+  Elf32_Half	vn_version;		/* Version of structure */
-+  Elf32_Half	vn_cnt;			/* Number of associated aux entries */
-+  Elf32_Word	vn_file;		/* Offset of filename for this
-+					   dependency */
-+  Elf32_Word	vn_aux;			/* Offset in bytes to vernaux array */
-+  Elf32_Word	vn_next;		/* Offset in bytes to next verneed
-+					   entry */
-+} Elf32_Verneed;
-+
-+typedef struct
-+{
-+  Elf64_Half	vn_version;		/* Version of structure */
-+  Elf64_Half	vn_cnt;			/* Number of associated aux entries */
-+  Elf64_Word	vn_file;		/* Offset of filename for this
-+					   dependency */
-+  Elf64_Word	vn_aux;			/* Offset in bytes to vernaux array */
-+  Elf64_Word	vn_next;		/* Offset in bytes to next verneed
-+					   entry */
-+} Elf64_Verneed;
-+
-+
-+/* Legal values for vn_version (version revision).  */
-+#define VER_NEED_NONE	 0		/* No version */
-+#define VER_NEED_CURRENT 1		/* Current version */
-+#define VER_NEED_NUM	 2		/* Given version number */
-+
-+/* Auxiliary needed version information.  */
-+
-+typedef struct
-+{
-+  Elf32_Word	vna_hash;		/* Hash value of dependency name */
-+  Elf32_Half	vna_flags;		/* Dependency specific information */
-+  Elf32_Half	vna_other;		/* Unused */
-+  Elf32_Word	vna_name;		/* Dependency name string offset */
-+  Elf32_Word	vna_next;		/* Offset in bytes to next vernaux
-+					   entry */
-+} Elf32_Vernaux;
-+
-+typedef struct
-+{
-+  Elf64_Word	vna_hash;		/* Hash value of dependency name */
-+  Elf64_Half	vna_flags;		/* Dependency specific information */
-+  Elf64_Half	vna_other;		/* Unused */
-+  Elf64_Word	vna_name;		/* Dependency name string offset */
-+  Elf64_Word	vna_next;		/* Offset in bytes to next vernaux
-+					   entry */
-+} Elf64_Vernaux;
-+
-+
-+/* Legal values for vna_flags.  */
-+#define VER_FLG_WEAK	0x2		/* Weak version identifier */
-+
-+
-+/* Auxiliary vector.  */
-+
-+/* This vector is normally only used by the program interpreter.  The
-+   usual definition in an ABI supplement uses the name auxv_t.  The
-+   vector is not usually defined in a standard <elf.h> file, but it
-+   can't hurt.  We rename it to avoid conflicts.  The sizes of these
-+   types are an arrangement between the exec server and the program
-+   interpreter, so we don't fully specify them here.  */
-+
-+typedef struct
-+{
-+  uint32_t a_type;		/* Entry type */
-+  union
-+    {
-+      uint32_t a_val;		/* Integer value */
-+      /* We use to have pointer elements added here.  We cannot do that,
-+	 though, since it does not work when using 32-bit definitions
-+	 on 64-bit platforms and vice versa.  */
-+    } a_un;
-+} Elf32_auxv_t;
-+
-+typedef struct
-+{
-+  uint64_t a_type;		/* Entry type */
-+  union
-+    {
-+      uint64_t a_val;		/* Integer value */
-+      /* We use to have pointer elements added here.  We cannot do that,
-+	 though, since it does not work when using 32-bit definitions
-+	 on 64-bit platforms and vice versa.  */
-+    } a_un;
-+} Elf64_auxv_t;
-+
-+/* Legal values for a_type (entry type).  */
-+
-+#define AT_NULL		0		/* End of vector */
-+#define AT_IGNORE	1		/* Entry should be ignored */
-+#define AT_EXECFD	2		/* File descriptor of program */
-+#define AT_PHDR		3		/* Program headers for program */
-+#define AT_PHENT	4		/* Size of program header entry */
-+#define AT_PHNUM	5		/* Number of program headers */
-+#define AT_PAGESZ	6		/* System page size */
-+#define AT_BASE		7		/* Base address of interpreter */
-+#define AT_FLAGS	8		/* Flags */
-+#define AT_ENTRY	9		/* Entry point of program */
-+#define AT_NOTELF	10		/* Program is not ELF */
-+#define AT_UID		11		/* Real uid */
-+#define AT_EUID		12		/* Effective uid */
-+#define AT_GID		13		/* Real gid */
-+#define AT_EGID		14		/* Effective gid */
-+#define AT_CLKTCK	17		/* Frequency of times() */
-+
-+/* Some more special a_type values describing the hardware.  */
-+#define AT_PLATFORM	15		/* String identifying platform.  */
-+#define AT_HWCAP	16		/* Machine dependent hints about
-+					   processor capabilities.  */
-+
-+/* This entry gives some information about the FPU initialization
-+   performed by the kernel.  */
-+#define AT_FPUCW	18		/* Used FPU control word.  */
-+
-+/* Cache block sizes.  */
-+#define AT_DCACHEBSIZE	19		/* Data cache block size.  */
-+#define AT_ICACHEBSIZE	20		/* Instruction cache block size.  */
-+#define AT_UCACHEBSIZE	21		/* Unified cache block size.  */
-+
-+/* A special ignored value for PPC, used by the kernel to control the
-+   interpretation of the AUXV. Must be > 16.  */
-+#define AT_IGNOREPPC	22		/* Entry should be ignored.  */
-+
-+#define	AT_SECURE	23		/* Boolean, was exec setuid-like?  */
-+
-+#define AT_BASE_PLATFORM 24		/* String identifying real platforms.*/
-+
-+#define AT_RANDOM	25		/* Address of 16 random bytes.  */
-+
-+#define AT_EXECFN	31		/* Filename of executable.  */
-+
-+/* Pointer to the global system page used for system calls and other
-+   nice things.  */
-+#define AT_SYSINFO	32
-+#define AT_SYSINFO_EHDR	33
-+
-+/* Shapes of the caches.  Bits 0-3 contains associativity; bits 4-7 contains
-+   log2 of line size; mask those to get cache size.  */
-+#define AT_L1I_CACHESHAPE	34
-+#define AT_L1D_CACHESHAPE	35
-+#define AT_L2_CACHESHAPE	36
-+#define AT_L3_CACHESHAPE	37
-+
-+/* Note section contents.  Each entry in the note section begins with
-+   a header of a fixed form.  */
-+
-+typedef struct
-+{
-+  Elf32_Word n_namesz;			/* Length of the note's name.  */
-+  Elf32_Word n_descsz;			/* Length of the note's descriptor.  */
-+  Elf32_Word n_type;			/* Type of the note.  */
-+} Elf32_Nhdr;
-+
-+typedef struct
-+{
-+  Elf64_Word n_namesz;			/* Length of the note's name.  */
-+  Elf64_Word n_descsz;			/* Length of the note's descriptor.  */
-+  Elf64_Word n_type;			/* Type of the note.  */
-+} Elf64_Nhdr;
-+
-+/* Known names of notes.  */
-+
-+/* Solaris entries in the note section have this name.  */
-+#define ELF_NOTE_SOLARIS	"SUNW Solaris"
-+
-+/* Note entries for GNU systems have this name.  */
-+#define ELF_NOTE_GNU		"GNU"
-+
-+
-+/* Defined types of notes for Solaris.  */
-+
-+/* Value of descriptor (one word) is desired pagesize for the binary.  */
-+#define ELF_NOTE_PAGESIZE_HINT	1
-+
-+
-+/* Defined note types for GNU systems.  */
-+
-+/* ABI information.  The descriptor consists of words:
-+   word 0: OS descriptor
-+   word 1: major version of the ABI
-+   word 2: minor version of the ABI
-+   word 3: subminor version of the ABI
-+*/
-+#define NT_GNU_ABI_TAG	1
-+#define ELF_NOTE_ABI	NT_GNU_ABI_TAG /* Old name.  */
-+
-+/* Known OSes.  These values can appear in word 0 of an
-+   NT_GNU_ABI_TAG note section entry.  */
-+#define ELF_NOTE_OS_LINUX	0
-+#define ELF_NOTE_OS_GNU		1
-+#define ELF_NOTE_OS_SOLARIS2	2
-+#define ELF_NOTE_OS_FREEBSD	3
-+
-+/* Synthetic hwcap information.  The descriptor begins with two words:
-+   word 0: number of entries
-+   word 1: bitmask of enabled entries
-+   Then follow variable-length entries, one byte followed by a
-+   '\0'-terminated hwcap name string.  The byte gives the bit
-+   number to test if enabled, (1U << bit) & bitmask.  */
-+#define NT_GNU_HWCAP	2
-+
-+/* Build ID bits as generated by ld --build-id.
-+   The descriptor consists of any nonzero number of bytes.  */
-+#define NT_GNU_BUILD_ID	3
-+
-+/* Version note generated by GNU gold containing a version string.  */
-+#define NT_GNU_GOLD_VERSION	4
-+
-+
-+/* Move records.  */
-+typedef struct
-+{
-+  Elf32_Xword m_value;		/* Symbol value.  */
-+  Elf32_Word m_info;		/* Size and index.  */
-+  Elf32_Word m_poffset;		/* Symbol offset.  */
-+  Elf32_Half m_repeat;		/* Repeat count.  */
-+  Elf32_Half m_stride;		/* Stride info.  */
-+} Elf32_Move;
-+
-+typedef struct
-+{
-+  Elf64_Xword m_value;		/* Symbol value.  */
-+  Elf64_Xword m_info;		/* Size and index.  */
-+  Elf64_Xword m_poffset;	/* Symbol offset.  */
-+  Elf64_Half m_repeat;		/* Repeat count.  */
-+  Elf64_Half m_stride;		/* Stride info.  */
-+} Elf64_Move;
-+
-+/* Macro to construct move records.  */
-+#define ELF32_M_SYM(info)	((info) >> 8)
-+#define ELF32_M_SIZE(info)	((unsigned char) (info))
-+#define ELF32_M_INFO(sym, size)	(((sym) << 8) + (unsigned char) (size))
-+
-+#define ELF64_M_SYM(info)	ELF32_M_SYM (info)
-+#define ELF64_M_SIZE(info)	ELF32_M_SIZE (info)
-+#define ELF64_M_INFO(sym, size)	ELF32_M_INFO (sym, size)
-+
-+
-+/* Motorola 68k specific definitions.  */
-+
-+/* Values for Elf32_Ehdr.e_flags.  */
-+#define EF_CPU32	0x00810000
-+
-+/* m68k relocs.  */
-+
-+#define R_68K_NONE	0		/* No reloc */
-+#define R_68K_32	1		/* Direct 32 bit  */
-+#define R_68K_16	2		/* Direct 16 bit  */
-+#define R_68K_8		3		/* Direct 8 bit  */
-+#define R_68K_PC32	4		/* PC relative 32 bit */
-+#define R_68K_PC16	5		/* PC relative 16 bit */
-+#define R_68K_PC8	6		/* PC relative 8 bit */
-+#define R_68K_GOT32	7		/* 32 bit PC relative GOT entry */
-+#define R_68K_GOT16	8		/* 16 bit PC relative GOT entry */
-+#define R_68K_GOT8	9		/* 8 bit PC relative GOT entry */
-+#define R_68K_GOT32O	10		/* 32 bit GOT offset */
-+#define R_68K_GOT16O	11		/* 16 bit GOT offset */
-+#define R_68K_GOT8O	12		/* 8 bit GOT offset */
-+#define R_68K_PLT32	13		/* 32 bit PC relative PLT address */
-+#define R_68K_PLT16	14		/* 16 bit PC relative PLT address */
-+#define R_68K_PLT8	15		/* 8 bit PC relative PLT address */
-+#define R_68K_PLT32O	16		/* 32 bit PLT offset */
-+#define R_68K_PLT16O	17		/* 16 bit PLT offset */
-+#define R_68K_PLT8O	18		/* 8 bit PLT offset */
-+#define R_68K_COPY	19		/* Copy symbol at runtime */
-+#define R_68K_GLOB_DAT	20		/* Create GOT entry */
-+#define R_68K_JMP_SLOT	21		/* Create PLT entry */
-+#define R_68K_RELATIVE	22		/* Adjust by program base */
-+#define R_68K_TLS_GD32      25          /* 32 bit GOT offset for GD */
-+#define R_68K_TLS_GD16      26          /* 16 bit GOT offset for GD */
-+#define R_68K_TLS_GD8       27          /* 8 bit GOT offset for GD */
-+#define R_68K_TLS_LDM32     28          /* 32 bit GOT offset for LDM */
-+#define R_68K_TLS_LDM16     29          /* 16 bit GOT offset for LDM */
-+#define R_68K_TLS_LDM8      30          /* 8 bit GOT offset for LDM */
-+#define R_68K_TLS_LDO32     31          /* 32 bit module-relative offset */
-+#define R_68K_TLS_LDO16     32          /* 16 bit module-relative offset */
-+#define R_68K_TLS_LDO8      33          /* 8 bit module-relative offset */
-+#define R_68K_TLS_IE32      34          /* 32 bit GOT offset for IE */
-+#define R_68K_TLS_IE16      35          /* 16 bit GOT offset for IE */
-+#define R_68K_TLS_IE8       36          /* 8 bit GOT offset for IE */
-+#define R_68K_TLS_LE32      37          /* 32 bit offset relative to
-+					   static TLS block */
-+#define R_68K_TLS_LE16      38          /* 16 bit offset relative to
-+					   static TLS block */
-+#define R_68K_TLS_LE8       39          /* 8 bit offset relative to
-+					   static TLS block */
-+#define R_68K_TLS_DTPMOD32  40          /* 32 bit module number */
-+#define R_68K_TLS_DTPREL32  41          /* 32 bit module-relative offset */
-+#define R_68K_TLS_TPREL32   42          /* 32 bit TP-relative offset */
-+/* Keep this the last entry.  */
-+#define R_68K_NUM	43
-+
-+/* Intel 80386 specific definitions.  */
-+
-+/* i386 relocs.  */
-+
-+#define R_386_NONE	   0		/* No reloc */
-+#define R_386_32	   1		/* Direct 32 bit  */
-+#define R_386_PC32	   2		/* PC relative 32 bit */
-+#define R_386_GOT32	   3		/* 32 bit GOT entry */
-+#define R_386_PLT32	   4		/* 32 bit PLT address */
-+#define R_386_COPY	   5		/* Copy symbol at runtime */
-+#define R_386_GLOB_DAT	   6		/* Create GOT entry */
-+#define R_386_JMP_SLOT	   7		/* Create PLT entry */
-+#define R_386_RELATIVE	   8		/* Adjust by program base */
-+#define R_386_GOTOFF	   9		/* 32 bit offset to GOT */
-+#define R_386_GOTPC	   10		/* 32 bit PC relative offset to GOT */
-+#define R_386_32PLT	   11
-+#define R_386_TLS_TPOFF	   14		/* Offset in static TLS block */
-+#define R_386_TLS_IE	   15		/* Address of GOT entry for static TLS
-+					   block offset */
-+#define R_386_TLS_GOTIE	   16		/* GOT entry for static TLS block
-+					   offset */
-+#define R_386_TLS_LE	   17		/* Offset relative to static TLS
-+					   block */
-+#define R_386_TLS_GD	   18		/* Direct 32 bit for GNU version of
-+					   general dynamic thread local data */
-+#define R_386_TLS_LDM	   19		/* Direct 32 bit for GNU version of
-+					   local dynamic thread local data
-+					   in LE code */
-+#define R_386_16	   20
-+#define R_386_PC16	   21
-+#define R_386_8		   22
-+#define R_386_PC8	   23
-+#define R_386_TLS_GD_32	   24		/* Direct 32 bit for general dynamic
-+					   thread local data */
-+#define R_386_TLS_GD_PUSH  25		/* Tag for pushl in GD TLS code */
-+#define R_386_TLS_GD_CALL  26		/* Relocation for call to
-+					   __tls_get_addr() */
-+#define R_386_TLS_GD_POP   27		/* Tag for popl in GD TLS code */
-+#define R_386_TLS_LDM_32   28		/* Direct 32 bit for local dynamic
-+					   thread local data in LE code */
-+#define R_386_TLS_LDM_PUSH 29		/* Tag for pushl in LDM TLS code */
-+#define R_386_TLS_LDM_CALL 30		/* Relocation for call to
-+					   __tls_get_addr() in LDM code */
-+#define R_386_TLS_LDM_POP  31		/* Tag for popl in LDM TLS code */
-+#define R_386_TLS_LDO_32   32		/* Offset relative to TLS block */
-+#define R_386_TLS_IE_32	   33		/* GOT entry for negated static TLS
-+					   block offset */
-+#define R_386_TLS_LE_32	   34		/* Negated offset relative to static
-+					   TLS block */
-+#define R_386_TLS_DTPMOD32 35		/* ID of module containing symbol */
-+#define R_386_TLS_DTPOFF32 36		/* Offset in TLS block */
-+#define R_386_TLS_TPOFF32  37		/* Negated offset in static TLS block */
-+/* 38? */
-+#define R_386_TLS_GOTDESC  39		/* GOT offset for TLS descriptor.  */
-+#define R_386_TLS_DESC_CALL 40		/* Marker of call through TLS
-+					   descriptor for
-+					   relaxation.  */
-+#define R_386_TLS_DESC     41		/* TLS descriptor containing
-+					   pointer to code and to
-+					   argument, returning the TLS
-+					   offset for the symbol.  */
-+#define R_386_IRELATIVE	   42		/* Adjust indirectly by program base */
-+/* Keep this the last entry.  */
-+#define R_386_NUM	   43
-+
-+/* SUN SPARC specific definitions.  */
-+
-+/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
-+
-+#define STT_SPARC_REGISTER	13	/* Global register reserved to app. */
-+
-+/* Values for Elf64_Ehdr.e_flags.  */
-+
-+#define EF_SPARCV9_MM		3
-+#define EF_SPARCV9_TSO		0
-+#define EF_SPARCV9_PSO		1
-+#define EF_SPARCV9_RMO		2
-+#define EF_SPARC_LEDATA		0x800000 /* little endian data */
-+#define EF_SPARC_EXT_MASK	0xFFFF00
-+#define EF_SPARC_32PLUS		0x000100 /* generic V8+ features */
-+#define EF_SPARC_SUN_US1	0x000200 /* Sun UltraSPARC1 extensions */
-+#define EF_SPARC_HAL_R1		0x000400 /* HAL R1 extensions */
-+#define EF_SPARC_SUN_US3	0x000800 /* Sun UltraSPARCIII extensions */
-+
-+/* SPARC relocs.  */
-+
-+#define R_SPARC_NONE		0	/* No reloc */
-+#define R_SPARC_8		1	/* Direct 8 bit */
-+#define R_SPARC_16		2	/* Direct 16 bit */
-+#define R_SPARC_32		3	/* Direct 32 bit */
-+#define R_SPARC_DISP8		4	/* PC relative 8 bit */
-+#define R_SPARC_DISP16		5	/* PC relative 16 bit */
-+#define R_SPARC_DISP32		6	/* PC relative 32 bit */
-+#define R_SPARC_WDISP30		7	/* PC relative 30 bit shifted */
-+#define R_SPARC_WDISP22		8	/* PC relative 22 bit shifted */
-+#define R_SPARC_HI22		9	/* High 22 bit */
-+#define R_SPARC_22		10	/* Direct 22 bit */
-+#define R_SPARC_13		11	/* Direct 13 bit */
-+#define R_SPARC_LO10		12	/* Truncated 10 bit */
-+#define R_SPARC_GOT10		13	/* Truncated 10 bit GOT entry */
-+#define R_SPARC_GOT13		14	/* 13 bit GOT entry */
-+#define R_SPARC_GOT22		15	/* 22 bit GOT entry shifted */
-+#define R_SPARC_PC10		16	/* PC relative 10 bit truncated */
-+#define R_SPARC_PC22		17	/* PC relative 22 bit shifted */
-+#define R_SPARC_WPLT30		18	/* 30 bit PC relative PLT address */
-+#define R_SPARC_COPY		19	/* Copy symbol at runtime */
-+#define R_SPARC_GLOB_DAT	20	/* Create GOT entry */
-+#define R_SPARC_JMP_SLOT	21	/* Create PLT entry */
-+#define R_SPARC_RELATIVE	22	/* Adjust by program base */
-+#define R_SPARC_UA32		23	/* Direct 32 bit unaligned */
-+
-+/* Additional Sparc64 relocs.  */
-+
-+#define R_SPARC_PLT32		24	/* Direct 32 bit ref to PLT entry */
-+#define R_SPARC_HIPLT22		25	/* High 22 bit PLT entry */
-+#define R_SPARC_LOPLT10		26	/* Truncated 10 bit PLT entry */
-+#define R_SPARC_PCPLT32		27	/* PC rel 32 bit ref to PLT entry */
-+#define R_SPARC_PCPLT22		28	/* PC rel high 22 bit PLT entry */
-+#define R_SPARC_PCPLT10		29	/* PC rel trunc 10 bit PLT entry */
-+#define R_SPARC_10		30	/* Direct 10 bit */
-+#define R_SPARC_11		31	/* Direct 11 bit */
-+#define R_SPARC_64		32	/* Direct 64 bit */
-+#define R_SPARC_OLO10		33	/* 10bit with secondary 13bit addend */
-+#define R_SPARC_HH22		34	/* Top 22 bits of direct 64 bit */
-+#define R_SPARC_HM10		35	/* High middle 10 bits of ... */
-+#define R_SPARC_LM22		36	/* Low middle 22 bits of ... */
-+#define R_SPARC_PC_HH22		37	/* Top 22 bits of pc rel 64 bit */
-+#define R_SPARC_PC_HM10		38	/* High middle 10 bit of ... */
-+#define R_SPARC_PC_LM22		39	/* Low miggle 22 bits of ... */
-+#define R_SPARC_WDISP16		40	/* PC relative 16 bit shifted */
-+#define R_SPARC_WDISP19		41	/* PC relative 19 bit shifted */
-+#define R_SPARC_GLOB_JMP	42	/* was part of v9 ABI but was removed */
-+#define R_SPARC_7		43	/* Direct 7 bit */
-+#define R_SPARC_5		44	/* Direct 5 bit */
-+#define R_SPARC_6		45	/* Direct 6 bit */
-+#define R_SPARC_DISP64		46	/* PC relative 64 bit */
-+#define R_SPARC_PLT64		47	/* Direct 64 bit ref to PLT entry */
-+#define R_SPARC_HIX22		48	/* High 22 bit complemented */
-+#define R_SPARC_LOX10		49	/* Truncated 11 bit complemented */
-+#define R_SPARC_H44		50	/* Direct high 12 of 44 bit */
-+#define R_SPARC_M44		51	/* Direct mid 22 of 44 bit */
-+#define R_SPARC_L44		52	/* Direct low 10 of 44 bit */
-+#define R_SPARC_REGISTER	53	/* Global register usage */
-+#define R_SPARC_UA64		54	/* Direct 64 bit unaligned */
-+#define R_SPARC_UA16		55	/* Direct 16 bit unaligned */
-+#define R_SPARC_TLS_GD_HI22	56
-+#define R_SPARC_TLS_GD_LO10	57
-+#define R_SPARC_TLS_GD_ADD	58
-+#define R_SPARC_TLS_GD_CALL	59
-+#define R_SPARC_TLS_LDM_HI22	60
-+#define R_SPARC_TLS_LDM_LO10	61
-+#define R_SPARC_TLS_LDM_ADD	62
-+#define R_SPARC_TLS_LDM_CALL	63
-+#define R_SPARC_TLS_LDO_HIX22	64
-+#define R_SPARC_TLS_LDO_LOX10	65
-+#define R_SPARC_TLS_LDO_ADD	66
-+#define R_SPARC_TLS_IE_HI22	67
-+#define R_SPARC_TLS_IE_LO10	68
-+#define R_SPARC_TLS_IE_LD	69
-+#define R_SPARC_TLS_IE_LDX	70
-+#define R_SPARC_TLS_IE_ADD	71
-+#define R_SPARC_TLS_LE_HIX22	72
-+#define R_SPARC_TLS_LE_LOX10	73
-+#define R_SPARC_TLS_DTPMOD32	74
-+#define R_SPARC_TLS_DTPMOD64	75
-+#define R_SPARC_TLS_DTPOFF32	76
-+#define R_SPARC_TLS_DTPOFF64	77
-+#define R_SPARC_TLS_TPOFF32	78
-+#define R_SPARC_TLS_TPOFF64	79
-+#define R_SPARC_GOTDATA_HIX22	80
-+#define R_SPARC_GOTDATA_LOX10	81
-+#define R_SPARC_GOTDATA_OP_HIX22	82
-+#define R_SPARC_GOTDATA_OP_LOX10	83
-+#define R_SPARC_GOTDATA_OP	84
-+#define R_SPARC_H34		85
-+#define R_SPARC_SIZE32		86
-+#define R_SPARC_SIZE64		87
-+#define R_SPARC_WDISP10		88
-+#define R_SPARC_JMP_IREL	248
-+#define R_SPARC_IRELATIVE	249
-+#define R_SPARC_GNU_VTINHERIT	250
-+#define R_SPARC_GNU_VTENTRY	251
-+#define R_SPARC_REV32		252
-+/* Keep this the last entry.  */
-+#define R_SPARC_NUM		253
-+
-+/* For Sparc64, legal values for d_tag of Elf64_Dyn.  */
-+
-+#define DT_SPARC_REGISTER 0x70000001
-+#define DT_SPARC_NUM	2
-+
-+/* MIPS R3000 specific definitions.  */
-+
-+/* Legal values for e_flags field of Elf32_Ehdr.  */
-+
-+#define EF_MIPS_NOREORDER   1		/* A .noreorder directive was used */
-+#define EF_MIPS_PIC	    2		/* Contains PIC code */
-+#define EF_MIPS_CPIC	    4		/* Uses PIC calling sequence */
-+#define EF_MIPS_XGOT	    8
-+#define EF_MIPS_64BIT_WHIRL 16
-+#define EF_MIPS_ABI2	    32
-+#define EF_MIPS_ABI_ON32    64
-+#define EF_MIPS_ARCH	    0xf0000000	/* MIPS architecture level */
-+
-+/* Legal values for MIPS architecture level.  */
-+
-+#define EF_MIPS_ARCH_1	    0x00000000	/* -mips1 code.  */
-+#define EF_MIPS_ARCH_2	    0x10000000	/* -mips2 code.  */
-+#define EF_MIPS_ARCH_3	    0x20000000	/* -mips3 code.  */
-+#define EF_MIPS_ARCH_4	    0x30000000	/* -mips4 code.  */
-+#define EF_MIPS_ARCH_5	    0x40000000	/* -mips5 code.  */
-+#define EF_MIPS_ARCH_32	    0x60000000	/* MIPS32 code.  */
-+#define EF_MIPS_ARCH_64	    0x70000000	/* MIPS64 code.  */
-+
-+/* The following are non-official names and should not be used.  */
-+
-+#define E_MIPS_ARCH_1	  0x00000000	/* -mips1 code.  */
-+#define E_MIPS_ARCH_2	  0x10000000	/* -mips2 code.  */
-+#define E_MIPS_ARCH_3	  0x20000000	/* -mips3 code.  */
-+#define E_MIPS_ARCH_4	  0x30000000	/* -mips4 code.  */
-+#define E_MIPS_ARCH_5	  0x40000000	/* -mips5 code.  */
-+#define E_MIPS_ARCH_32	  0x60000000	/* MIPS32 code.  */
-+#define E_MIPS_ARCH_64	  0x70000000	/* MIPS64 code.  */
-+
-+/* Special section indices.  */
-+
-+#define SHN_MIPS_ACOMMON    0xff00	/* Allocated common symbols */
-+#define SHN_MIPS_TEXT	    0xff01	/* Allocated test symbols.  */
-+#define SHN_MIPS_DATA	    0xff02	/* Allocated data symbols.  */
-+#define SHN_MIPS_SCOMMON    0xff03	/* Small common symbols */
-+#define SHN_MIPS_SUNDEFINED 0xff04	/* Small undefined symbols */
-+
-+/* Legal values for sh_type field of Elf32_Shdr.  */
-+
-+#define SHT_MIPS_LIBLIST       0x70000000 /* Shared objects used in link */
-+#define SHT_MIPS_MSYM	       0x70000001
-+#define SHT_MIPS_CONFLICT      0x70000002 /* Conflicting symbols */
-+#define SHT_MIPS_GPTAB	       0x70000003 /* Global data area sizes */
-+#define SHT_MIPS_UCODE	       0x70000004 /* Reserved for SGI/MIPS compilers */
-+#define SHT_MIPS_DEBUG	       0x70000005 /* MIPS ECOFF debugging information*/
-+#define SHT_MIPS_REGINFO       0x70000006 /* Register usage information */
-+#define SHT_MIPS_PACKAGE       0x70000007
-+#define SHT_MIPS_PACKSYM       0x70000008
-+#define SHT_MIPS_RELD	       0x70000009
-+#define SHT_MIPS_IFACE         0x7000000b
-+#define SHT_MIPS_CONTENT       0x7000000c
-+#define SHT_MIPS_OPTIONS       0x7000000d /* Miscellaneous options.  */
-+#define SHT_MIPS_SHDR	       0x70000010
-+#define SHT_MIPS_FDESC	       0x70000011
-+#define SHT_MIPS_EXTSYM	       0x70000012
-+#define SHT_MIPS_DENSE	       0x70000013
-+#define SHT_MIPS_PDESC	       0x70000014
-+#define SHT_MIPS_LOCSYM	       0x70000015
-+#define SHT_MIPS_AUXSYM	       0x70000016
-+#define SHT_MIPS_OPTSYM	       0x70000017
-+#define SHT_MIPS_LOCSTR	       0x70000018
-+#define SHT_MIPS_LINE	       0x70000019
-+#define SHT_MIPS_RFDESC	       0x7000001a
-+#define SHT_MIPS_DELTASYM      0x7000001b
-+#define SHT_MIPS_DELTAINST     0x7000001c
-+#define SHT_MIPS_DELTACLASS    0x7000001d
-+#define SHT_MIPS_DWARF         0x7000001e /* DWARF debugging information.  */
-+#define SHT_MIPS_DELTADECL     0x7000001f
-+#define SHT_MIPS_SYMBOL_LIB    0x70000020
-+#define SHT_MIPS_EVENTS	       0x70000021 /* Event section.  */
-+#define SHT_MIPS_TRANSLATE     0x70000022
-+#define SHT_MIPS_PIXIE	       0x70000023
-+#define SHT_MIPS_XLATE	       0x70000024
-+#define SHT_MIPS_XLATE_DEBUG   0x70000025
-+#define SHT_MIPS_WHIRL	       0x70000026
-+#define SHT_MIPS_EH_REGION     0x70000027
-+#define SHT_MIPS_XLATE_OLD     0x70000028
-+#define SHT_MIPS_PDR_EXCEPTION 0x70000029
-+
-+/* Legal values for sh_flags field of Elf32_Shdr.  */
-+
-+#define SHF_MIPS_GPREL	 0x10000000	/* Must be part of global data area */
-+#define SHF_MIPS_MERGE	 0x20000000
-+#define SHF_MIPS_ADDR	 0x40000000
-+#define SHF_MIPS_STRINGS 0x80000000
-+#define SHF_MIPS_NOSTRIP 0x08000000
-+#define SHF_MIPS_LOCAL	 0x04000000
-+#define SHF_MIPS_NAMES	 0x02000000
-+#define SHF_MIPS_NODUPE	 0x01000000
-+
-+
-+/* Symbol tables.  */
-+
-+/* MIPS specific values for `st_other'.  */
-+#define STO_MIPS_DEFAULT		0x0
-+#define STO_MIPS_INTERNAL		0x1
-+#define STO_MIPS_HIDDEN			0x2
-+#define STO_MIPS_PROTECTED		0x3
-+#define STO_MIPS_PLT			0x8
-+#define STO_MIPS_SC_ALIGN_UNUSED	0xff
-+
-+/* MIPS specific values for `st_info'.  */
-+#define STB_MIPS_SPLIT_COMMON		13
-+
-+/* Entries found in sections of type SHT_MIPS_GPTAB.  */
-+
-+typedef union
-+{
-+  struct
-+    {
-+      Elf32_Word gt_current_g_value;	/* -G value used for compilation */
-+      Elf32_Word gt_unused;		/* Not used */
-+    } gt_header;			/* First entry in section */
-+  struct
-+    {
-+      Elf32_Word gt_g_value;		/* If this value were used for -G */
-+      Elf32_Word gt_bytes;		/* This many bytes would be used */
-+    } gt_entry;				/* Subsequent entries in section */
-+} Elf32_gptab;
-+
-+/* Entry found in sections of type SHT_MIPS_REGINFO.  */
-+
-+typedef struct
-+{
-+  Elf32_Word	ri_gprmask;		/* General registers used */
-+  Elf32_Word	ri_cprmask[4];		/* Coprocessor registers used */
-+  Elf32_Sword	ri_gp_value;		/* $gp register value */
-+} Elf32_RegInfo;
-+
-+/* Entries found in sections of type SHT_MIPS_OPTIONS.  */
-+
-+typedef struct
-+{
-+  unsigned char kind;		/* Determines interpretation of the
-+				   variable part of descriptor.  */
-+  unsigned char size;		/* Size of descriptor, including header.  */
-+  Elf32_Section section;	/* Section header index of section affected,
-+				   0 for global options.  */
-+  Elf32_Word info;		/* Kind-specific information.  */
-+} Elf_Options;
-+
-+/* Values for `kind' field in Elf_Options.  */
-+
-+#define ODK_NULL	0	/* Undefined.  */
-+#define ODK_REGINFO	1	/* Register usage information.  */
-+#define ODK_EXCEPTIONS	2	/* Exception processing options.  */
-+#define ODK_PAD		3	/* Section padding options.  */
-+#define ODK_HWPATCH	4	/* Hardware workarounds performed */
-+#define ODK_FILL	5	/* record the fill value used by the linker. */
-+#define ODK_TAGS	6	/* reserve space for desktop tools to write. */
-+#define ODK_HWAND	7	/* HW workarounds.  'AND' bits when merging. */
-+#define ODK_HWOR	8	/* HW workarounds.  'OR' bits when merging.  */
-+
-+/* Values for `info' in Elf_Options for ODK_EXCEPTIONS entries.  */
-+
-+#define OEX_FPU_MIN	0x1f	/* FPE's which MUST be enabled.  */
-+#define OEX_FPU_MAX	0x1f00	/* FPE's which MAY be enabled.  */
-+#define OEX_PAGE0	0x10000	/* page zero must be mapped.  */
-+#define OEX_SMM		0x20000	/* Force sequential memory mode?  */
-+#define OEX_FPDBUG	0x40000	/* Force floating point debug mode?  */
-+#define OEX_PRECISEFP	OEX_FPDBUG
-+#define OEX_DISMISS	0x80000	/* Dismiss invalid address faults?  */
-+
-+#define OEX_FPU_INVAL	0x10
-+#define OEX_FPU_DIV0	0x08
-+#define OEX_FPU_OFLO	0x04
-+#define OEX_FPU_UFLO	0x02
-+#define OEX_FPU_INEX	0x01
-+
-+/* Masks for `info' in Elf_Options for an ODK_HWPATCH entry.  */
-+
-+#define OHW_R4KEOP	0x1	/* R4000 end-of-page patch.  */
-+#define OHW_R8KPFETCH	0x2	/* may need R8000 prefetch patch.  */
-+#define OHW_R5KEOP	0x4	/* R5000 end-of-page patch.  */
-+#define OHW_R5KCVTL	0x8	/* R5000 cvt.[ds].l bug.  clean=1.  */
-+
-+#define OPAD_PREFIX	0x1
-+#define OPAD_POSTFIX	0x2
-+#define OPAD_SYMBOL	0x4
-+
-+/* Entry found in `.options' section.  */
-+
-+typedef struct
-+{
-+  Elf32_Word hwp_flags1;	/* Extra flags.  */
-+  Elf32_Word hwp_flags2;	/* Extra flags.  */
-+} Elf_Options_Hw;
-+
-+/* Masks for `info' in ElfOptions for ODK_HWAND and ODK_HWOR entries.  */
-+
-+#define OHWA0_R4KEOP_CHECKED	0x00000001
-+#define OHWA1_R4KEOP_CLEAN	0x00000002
-+
-+/* MIPS relocs.  */
-+
-+#define R_MIPS_NONE		0	/* No reloc */
-+#define R_MIPS_16		1	/* Direct 16 bit */
-+#define R_MIPS_32		2	/* Direct 32 bit */
-+#define R_MIPS_REL32		3	/* PC relative 32 bit */
-+#define R_MIPS_26		4	/* Direct 26 bit shifted */
-+#define R_MIPS_HI16		5	/* High 16 bit */
-+#define R_MIPS_LO16		6	/* Low 16 bit */
-+#define R_MIPS_GPREL16		7	/* GP relative 16 bit */
-+#define R_MIPS_LITERAL		8	/* 16 bit literal entry */
-+#define R_MIPS_GOT16		9	/* 16 bit GOT entry */
-+#define R_MIPS_PC16		10	/* PC relative 16 bit */
-+#define R_MIPS_CALL16		11	/* 16 bit GOT entry for function */
-+#define R_MIPS_GPREL32		12	/* GP relative 32 bit */
-+
-+#define R_MIPS_SHIFT5		16
-+#define R_MIPS_SHIFT6		17
-+#define R_MIPS_64		18
-+#define R_MIPS_GOT_DISP		19
-+#define R_MIPS_GOT_PAGE		20
-+#define R_MIPS_GOT_OFST		21
-+#define R_MIPS_GOT_HI16		22
-+#define R_MIPS_GOT_LO16		23
-+#define R_MIPS_SUB		24
-+#define R_MIPS_INSERT_A		25
-+#define R_MIPS_INSERT_B		26
-+#define R_MIPS_DELETE		27
-+#define R_MIPS_HIGHER		28
-+#define R_MIPS_HIGHEST		29
-+#define R_MIPS_CALL_HI16	30
-+#define R_MIPS_CALL_LO16	31
-+#define R_MIPS_SCN_DISP		32
-+#define R_MIPS_REL16		33
-+#define R_MIPS_ADD_IMMEDIATE	34
-+#define R_MIPS_PJUMP		35
-+#define R_MIPS_RELGOT		36
-+#define R_MIPS_JALR		37
-+#define R_MIPS_TLS_DTPMOD32	38	/* Module number 32 bit */
-+#define R_MIPS_TLS_DTPREL32	39	/* Module-relative offset 32 bit */
-+#define R_MIPS_TLS_DTPMOD64	40	/* Module number 64 bit */
-+#define R_MIPS_TLS_DTPREL64	41	/* Module-relative offset 64 bit */
-+#define R_MIPS_TLS_GD		42	/* 16 bit GOT offset for GD */
-+#define R_MIPS_TLS_LDM		43	/* 16 bit GOT offset for LDM */
-+#define R_MIPS_TLS_DTPREL_HI16	44	/* Module-relative offset, high 16 bits */
-+#define R_MIPS_TLS_DTPREL_LO16	45	/* Module-relative offset, low 16 bits */
-+#define R_MIPS_TLS_GOTTPREL	46	/* 16 bit GOT offset for IE */
-+#define R_MIPS_TLS_TPREL32	47	/* TP-relative offset, 32 bit */
-+#define R_MIPS_TLS_TPREL64	48	/* TP-relative offset, 64 bit */
-+#define R_MIPS_TLS_TPREL_HI16	49	/* TP-relative offset, high 16 bits */
-+#define R_MIPS_TLS_TPREL_LO16	50	/* TP-relative offset, low 16 bits */
-+#define R_MIPS_GLOB_DAT		51
-+#define R_MIPS_COPY		126
-+#define R_MIPS_JUMP_SLOT        127
-+/* Keep this the last entry.  */
-+#define R_MIPS_NUM		128
-+
-+/* Legal values for p_type field of Elf32_Phdr.  */
-+
-+#define PT_MIPS_REGINFO	0x70000000	/* Register usage information */
-+#define PT_MIPS_RTPROC  0x70000001	/* Runtime procedure table. */
-+#define PT_MIPS_OPTIONS 0x70000002
-+
-+/* Special program header types.  */
-+
-+#define PF_MIPS_LOCAL	0x10000000
-+
-+/* Legal values for d_tag field of Elf32_Dyn.  */
-+
-+#define DT_MIPS_RLD_VERSION  0x70000001	/* Runtime linker interface version */
-+#define DT_MIPS_TIME_STAMP   0x70000002	/* Timestamp */
-+#define DT_MIPS_ICHECKSUM    0x70000003	/* Checksum */
-+#define DT_MIPS_IVERSION     0x70000004	/* Version string (string tbl index) */
-+#define DT_MIPS_FLAGS	     0x70000005	/* Flags */
-+#define DT_MIPS_BASE_ADDRESS 0x70000006	/* Base address */
-+#define DT_MIPS_MSYM	     0x70000007
-+#define DT_MIPS_CONFLICT     0x70000008	/* Address of CONFLICT section */
-+#define DT_MIPS_LIBLIST	     0x70000009	/* Address of LIBLIST section */
-+#define DT_MIPS_LOCAL_GOTNO  0x7000000a	/* Number of local GOT entries */
-+#define DT_MIPS_CONFLICTNO   0x7000000b	/* Number of CONFLICT entries */
-+#define DT_MIPS_LIBLISTNO    0x70000010	/* Number of LIBLIST entries */
-+#define DT_MIPS_SYMTABNO     0x70000011	/* Number of DYNSYM entries */
-+#define DT_MIPS_UNREFEXTNO   0x70000012	/* First external DYNSYM */
-+#define DT_MIPS_GOTSYM	     0x70000013	/* First GOT entry in DYNSYM */
-+#define DT_MIPS_HIPAGENO     0x70000014	/* Number of GOT page table entries */
-+#define DT_MIPS_RLD_MAP	     0x70000016	/* Address of run time loader map.  */
-+#define DT_MIPS_DELTA_CLASS  0x70000017	/* Delta C++ class definition.  */
-+#define DT_MIPS_DELTA_CLASS_NO    0x70000018 /* Number of entries in
-+						DT_MIPS_DELTA_CLASS.  */
-+#define DT_MIPS_DELTA_INSTANCE    0x70000019 /* Delta C++ class instances.  */
-+#define DT_MIPS_DELTA_INSTANCE_NO 0x7000001a /* Number of entries in
-+						DT_MIPS_DELTA_INSTANCE.  */
-+#define DT_MIPS_DELTA_RELOC  0x7000001b /* Delta relocations.  */
-+#define DT_MIPS_DELTA_RELOC_NO 0x7000001c /* Number of entries in
-+					     DT_MIPS_DELTA_RELOC.  */
-+#define DT_MIPS_DELTA_SYM    0x7000001d /* Delta symbols that Delta
-+					   relocations refer to.  */
-+#define DT_MIPS_DELTA_SYM_NO 0x7000001e /* Number of entries in
-+					   DT_MIPS_DELTA_SYM.  */
-+#define DT_MIPS_DELTA_CLASSSYM 0x70000020 /* Delta symbols that hold the
-+					     class declaration.  */
-+#define DT_MIPS_DELTA_CLASSSYM_NO 0x70000021 /* Number of entries in
-+						DT_MIPS_DELTA_CLASSSYM.  */
-+#define DT_MIPS_CXX_FLAGS    0x70000022 /* Flags indicating for C++ flavor.  */
-+#define DT_MIPS_PIXIE_INIT   0x70000023
-+#define DT_MIPS_SYMBOL_LIB   0x70000024
-+#define DT_MIPS_LOCALPAGE_GOTIDX 0x70000025
-+#define DT_MIPS_LOCAL_GOTIDX 0x70000026
-+#define DT_MIPS_HIDDEN_GOTIDX 0x70000027
-+#define DT_MIPS_PROTECTED_GOTIDX 0x70000028
-+#define DT_MIPS_OPTIONS	     0x70000029 /* Address of .options.  */
-+#define DT_MIPS_INTERFACE    0x7000002a /* Address of .interface.  */
-+#define DT_MIPS_DYNSTR_ALIGN 0x7000002b
-+#define DT_MIPS_INTERFACE_SIZE 0x7000002c /* Size of the .interface section. */
-+#define DT_MIPS_RLD_TEXT_RESOLVE_ADDR 0x7000002d /* Address of rld_text_rsolve
-+						    function stored in GOT.  */
-+#define DT_MIPS_PERF_SUFFIX  0x7000002e /* Default suffix of dso to be added
-+					   by rld on dlopen() calls.  */
-+#define DT_MIPS_COMPACT_SIZE 0x7000002f /* (O32)Size of compact rel section. */
-+#define DT_MIPS_GP_VALUE     0x70000030 /* GP value for aux GOTs.  */
-+#define DT_MIPS_AUX_DYNAMIC  0x70000031 /* Address of aux .dynamic.  */
-+/* The address of .got.plt in an executable using the new non-PIC ABI.  */
-+#define DT_MIPS_PLTGOT	     0x70000032
-+/* The base of the PLT in an executable using the new non-PIC ABI if that
-+   PLT is writable.  For a non-writable PLT, this is omitted or has a zero
-+   value.  */
-+#define DT_MIPS_RWPLT        0x70000034
-+#define DT_MIPS_NUM	     0x35
-+
-+/* Legal values for DT_MIPS_FLAGS Elf32_Dyn entry.  */
-+
-+#define RHF_NONE		   0		/* No flags */
-+#define RHF_QUICKSTART		   (1 << 0)	/* Use quickstart */
-+#define RHF_NOTPOT		   (1 << 1)	/* Hash size not power of 2 */
-+#define RHF_NO_LIBRARY_REPLACEMENT (1 << 2)	/* Ignore LD_LIBRARY_PATH */
-+#define RHF_NO_MOVE		   (1 << 3)
-+#define RHF_SGI_ONLY		   (1 << 4)
-+#define RHF_GUARANTEE_INIT	   (1 << 5)
-+#define RHF_DELTA_C_PLUS_PLUS	   (1 << 6)
-+#define RHF_GUARANTEE_START_INIT   (1 << 7)
-+#define RHF_PIXIE		   (1 << 8)
-+#define RHF_DEFAULT_DELAY_LOAD	   (1 << 9)
-+#define RHF_REQUICKSTART	   (1 << 10)
-+#define RHF_REQUICKSTARTED	   (1 << 11)
-+#define RHF_CORD		   (1 << 12)
-+#define RHF_NO_UNRES_UNDEF	   (1 << 13)
-+#define RHF_RLD_ORDER_SAFE	   (1 << 14)
-+
-+/* Entries found in sections of type SHT_MIPS_LIBLIST.  */
-+
-+typedef struct
-+{
-+  Elf32_Word l_name;		/* Name (string table index) */
-+  Elf32_Word l_time_stamp;	/* Timestamp */
-+  Elf32_Word l_checksum;	/* Checksum */
-+  Elf32_Word l_version;		/* Interface version */
-+  Elf32_Word l_flags;		/* Flags */
-+} Elf32_Lib;
-+
-+typedef struct
-+{
-+  Elf64_Word l_name;		/* Name (string table index) */
-+  Elf64_Word l_time_stamp;	/* Timestamp */
-+  Elf64_Word l_checksum;	/* Checksum */
-+  Elf64_Word l_version;		/* Interface version */
-+  Elf64_Word l_flags;		/* Flags */
-+} Elf64_Lib;
-+
-+
-+/* Legal values for l_flags.  */
-+
-+#define LL_NONE		  0
-+#define LL_EXACT_MATCH	  (1 << 0)	/* Require exact match */
-+#define LL_IGNORE_INT_VER (1 << 1)	/* Ignore interface version */
-+#define LL_REQUIRE_MINOR  (1 << 2)
-+#define LL_EXPORTS	  (1 << 3)
-+#define LL_DELAY_LOAD	  (1 << 4)
-+#define LL_DELTA	  (1 << 5)
-+
-+/* Entries found in sections of type SHT_MIPS_CONFLICT.  */
-+
-+typedef Elf32_Addr Elf32_Conflict;
-+
-+
-+/* HPPA specific definitions.  */
-+
-+/* Legal values for e_flags field of Elf32_Ehdr.  */
-+
-+#define EF_PARISC_TRAPNIL	0x00010000 /* Trap nil pointer dereference.  */
-+#define EF_PARISC_EXT		0x00020000 /* Program uses arch. extensions. */
-+#define EF_PARISC_LSB		0x00040000 /* Program expects little endian. */
-+#define EF_PARISC_WIDE		0x00080000 /* Program expects wide mode.  */
-+#define EF_PARISC_NO_KABP	0x00100000 /* No kernel assisted branch
-+					      prediction.  */
-+#define EF_PARISC_LAZYSWAP	0x00400000 /* Allow lazy swapping.  */
-+#define EF_PARISC_ARCH		0x0000ffff /* Architecture version.  */
-+
-+/* Defined values for `e_flags & EF_PARISC_ARCH' are:  */
-+
-+#define EFA_PARISC_1_0		    0x020b /* PA-RISC 1.0 big-endian.  */
-+#define EFA_PARISC_1_1		    0x0210 /* PA-RISC 1.1 big-endian.  */
-+#define EFA_PARISC_2_0		    0x0214 /* PA-RISC 2.0 big-endian.  */
-+
-+/* Additional section indeces.  */
-+
-+#define SHN_PARISC_ANSI_COMMON	0xff00	   /* Section for tenatively declared
-+					      symbols in ANSI C.  */
-+#define SHN_PARISC_HUGE_COMMON	0xff01	   /* Common blocks in huge model.  */
-+
-+/* Legal values for sh_type field of Elf32_Shdr.  */
-+
-+#define SHT_PARISC_EXT		0x70000000 /* Contains product specific ext. */
-+#define SHT_PARISC_UNWIND	0x70000001 /* Unwind information.  */
-+#define SHT_PARISC_DOC		0x70000002 /* Debug info for optimized code. */
-+
-+/* Legal values for sh_flags field of Elf32_Shdr.  */
-+
-+#define SHF_PARISC_SHORT	0x20000000 /* Section with short addressing. */
-+#define SHF_PARISC_HUGE		0x40000000 /* Section far from gp.  */
-+#define SHF_PARISC_SBP		0x80000000 /* Static branch prediction code. */
-+
-+/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
-+
-+#define STT_PARISC_MILLICODE	13	/* Millicode function entry point.  */
-+
-+#define STT_HP_OPAQUE		(STT_LOOS + 0x1)
-+#define STT_HP_STUB		(STT_LOOS + 0x2)
-+
-+/* HPPA relocs.  */
-+
-+#define R_PARISC_NONE		0	/* No reloc.  */
-+#define R_PARISC_DIR32		1	/* Direct 32-bit reference.  */
-+#define R_PARISC_DIR21L		2	/* Left 21 bits of eff. address.  */
-+#define R_PARISC_DIR17R		3	/* Right 17 bits of eff. address.  */
-+#define R_PARISC_DIR17F		4	/* 17 bits of eff. address.  */
-+#define R_PARISC_DIR14R		6	/* Right 14 bits of eff. address.  */
-+#define R_PARISC_PCREL32	9	/* 32-bit rel. address.  */
-+#define R_PARISC_PCREL21L	10	/* Left 21 bits of rel. address.  */
-+#define R_PARISC_PCREL17R	11	/* Right 17 bits of rel. address.  */
-+#define R_PARISC_PCREL17F	12	/* 17 bits of rel. address.  */
-+#define R_PARISC_PCREL14R	14	/* Right 14 bits of rel. address.  */
-+#define R_PARISC_DPREL21L	18	/* Left 21 bits of rel. address.  */
-+#define R_PARISC_DPREL14R	22	/* Right 14 bits of rel. address.  */
-+#define R_PARISC_GPREL21L	26	/* GP-relative, left 21 bits.  */
-+#define R_PARISC_GPREL14R	30	/* GP-relative, right 14 bits.  */
-+#define R_PARISC_LTOFF21L	34	/* LT-relative, left 21 bits.  */
-+#define R_PARISC_LTOFF14R	38	/* LT-relative, right 14 bits.  */
-+#define R_PARISC_SECREL32	41	/* 32 bits section rel. address.  */
-+#define R_PARISC_SEGBASE	48	/* No relocation, set segment base.  */
-+#define R_PARISC_SEGREL32	49	/* 32 bits segment rel. address.  */
-+#define R_PARISC_PLTOFF21L	50	/* PLT rel. address, left 21 bits.  */
-+#define R_PARISC_PLTOFF14R	54	/* PLT rel. address, right 14 bits.  */
-+#define R_PARISC_LTOFF_FPTR32	57	/* 32 bits LT-rel. function pointer. */
-+#define R_PARISC_LTOFF_FPTR21L	58	/* LT-rel. fct ptr, left 21 bits. */
-+#define R_PARISC_LTOFF_FPTR14R	62	/* LT-rel. fct ptr, right 14 bits. */
-+#define R_PARISC_FPTR64		64	/* 64 bits function address.  */
-+#define R_PARISC_PLABEL32	65	/* 32 bits function address.  */
-+#define R_PARISC_PLABEL21L	66	/* Left 21 bits of fdesc address.  */
-+#define R_PARISC_PLABEL14R	70	/* Right 14 bits of fdesc address.  */
-+#define R_PARISC_PCREL64	72	/* 64 bits PC-rel. address.  */
-+#define R_PARISC_PCREL22F	74	/* 22 bits PC-rel. address.  */
-+#define R_PARISC_PCREL14WR	75	/* PC-rel. address, right 14 bits.  */
-+#define R_PARISC_PCREL14DR	76	/* PC rel. address, right 14 bits.  */
-+#define R_PARISC_PCREL16F	77	/* 16 bits PC-rel. address.  */
-+#define R_PARISC_PCREL16WF	78	/* 16 bits PC-rel. address.  */
-+#define R_PARISC_PCREL16DF	79	/* 16 bits PC-rel. address.  */
-+#define R_PARISC_DIR64		80	/* 64 bits of eff. address.  */
-+#define R_PARISC_DIR14WR	83	/* 14 bits of eff. address.  */
-+#define R_PARISC_DIR14DR	84	/* 14 bits of eff. address.  */
-+#define R_PARISC_DIR16F		85	/* 16 bits of eff. address.  */
-+#define R_PARISC_DIR16WF	86	/* 16 bits of eff. address.  */
-+#define R_PARISC_DIR16DF	87	/* 16 bits of eff. address.  */
-+#define R_PARISC_GPREL64	88	/* 64 bits of GP-rel. address.  */
-+#define R_PARISC_GPREL14WR	91	/* GP-rel. address, right 14 bits.  */
-+#define R_PARISC_GPREL14DR	92	/* GP-rel. address, right 14 bits.  */
-+#define R_PARISC_GPREL16F	93	/* 16 bits GP-rel. address.  */
-+#define R_PARISC_GPREL16WF	94	/* 16 bits GP-rel. address.  */
-+#define R_PARISC_GPREL16DF	95	/* 16 bits GP-rel. address.  */
-+#define R_PARISC_LTOFF64	96	/* 64 bits LT-rel. address.  */
-+#define R_PARISC_LTOFF14WR	99	/* LT-rel. address, right 14 bits.  */
-+#define R_PARISC_LTOFF14DR	100	/* LT-rel. address, right 14 bits.  */
-+#define R_PARISC_LTOFF16F	101	/* 16 bits LT-rel. address.  */
-+#define R_PARISC_LTOFF16WF	102	/* 16 bits LT-rel. address.  */
-+#define R_PARISC_LTOFF16DF	103	/* 16 bits LT-rel. address.  */
-+#define R_PARISC_SECREL64	104	/* 64 bits section rel. address.  */
-+#define R_PARISC_SEGREL64	112	/* 64 bits segment rel. address.  */
-+#define R_PARISC_PLTOFF14WR	115	/* PLT-rel. address, right 14 bits.  */
-+#define R_PARISC_PLTOFF14DR	116	/* PLT-rel. address, right 14 bits.  */
-+#define R_PARISC_PLTOFF16F	117	/* 16 bits LT-rel. address.  */
-+#define R_PARISC_PLTOFF16WF	118	/* 16 bits PLT-rel. address.  */
-+#define R_PARISC_PLTOFF16DF	119	/* 16 bits PLT-rel. address.  */
-+#define R_PARISC_LTOFF_FPTR64	120	/* 64 bits LT-rel. function ptr.  */
-+#define R_PARISC_LTOFF_FPTR14WR	123	/* LT-rel. fct. ptr., right 14 bits. */
-+#define R_PARISC_LTOFF_FPTR14DR	124	/* LT-rel. fct. ptr., right 14 bits. */
-+#define R_PARISC_LTOFF_FPTR16F	125	/* 16 bits LT-rel. function ptr.  */
-+#define R_PARISC_LTOFF_FPTR16WF	126	/* 16 bits LT-rel. function ptr.  */
-+#define R_PARISC_LTOFF_FPTR16DF	127	/* 16 bits LT-rel. function ptr.  */
-+#define R_PARISC_LORESERVE	128
-+#define R_PARISC_COPY		128	/* Copy relocation.  */
-+#define R_PARISC_IPLT		129	/* Dynamic reloc, imported PLT */
-+#define R_PARISC_EPLT		130	/* Dynamic reloc, exported PLT */
-+#define R_PARISC_TPREL32	153	/* 32 bits TP-rel. address.  */
-+#define R_PARISC_TPREL21L	154	/* TP-rel. address, left 21 bits.  */
-+#define R_PARISC_TPREL14R	158	/* TP-rel. address, right 14 bits.  */
-+#define R_PARISC_LTOFF_TP21L	162	/* LT-TP-rel. address, left 21 bits. */
-+#define R_PARISC_LTOFF_TP14R	166	/* LT-TP-rel. address, right 14 bits.*/
-+#define R_PARISC_LTOFF_TP14F	167	/* 14 bits LT-TP-rel. address.  */
-+#define R_PARISC_TPREL64	216	/* 64 bits TP-rel. address.  */
-+#define R_PARISC_TPREL14WR	219	/* TP-rel. address, right 14 bits.  */
-+#define R_PARISC_TPREL14DR	220	/* TP-rel. address, right 14 bits.  */
-+#define R_PARISC_TPREL16F	221	/* 16 bits TP-rel. address.  */
-+#define R_PARISC_TPREL16WF	222	/* 16 bits TP-rel. address.  */
-+#define R_PARISC_TPREL16DF	223	/* 16 bits TP-rel. address.  */
-+#define R_PARISC_LTOFF_TP64	224	/* 64 bits LT-TP-rel. address.  */
-+#define R_PARISC_LTOFF_TP14WR	227	/* LT-TP-rel. address, right 14 bits.*/
-+#define R_PARISC_LTOFF_TP14DR	228	/* LT-TP-rel. address, right 14 bits.*/
-+#define R_PARISC_LTOFF_TP16F	229	/* 16 bits LT-TP-rel. address.  */
-+#define R_PARISC_LTOFF_TP16WF	230	/* 16 bits LT-TP-rel. address.  */
-+#define R_PARISC_LTOFF_TP16DF	231	/* 16 bits LT-TP-rel. address.  */
-+#define R_PARISC_GNU_VTENTRY	232
-+#define R_PARISC_GNU_VTINHERIT	233
-+#define R_PARISC_TLS_GD21L	234	/* GD 21-bit left.  */
-+#define R_PARISC_TLS_GD14R	235	/* GD 14-bit right.  */
-+#define R_PARISC_TLS_GDCALL	236	/* GD call to __t_g_a.  */
-+#define R_PARISC_TLS_LDM21L	237	/* LD module 21-bit left.  */
-+#define R_PARISC_TLS_LDM14R	238	/* LD module 14-bit right.  */
-+#define R_PARISC_TLS_LDMCALL	239	/* LD module call to __t_g_a.  */
-+#define R_PARISC_TLS_LDO21L	240	/* LD offset 21-bit left.  */
-+#define R_PARISC_TLS_LDO14R	241	/* LD offset 14-bit right.  */
-+#define R_PARISC_TLS_DTPMOD32	242	/* DTP module 32-bit.  */
-+#define R_PARISC_TLS_DTPMOD64	243	/* DTP module 64-bit.  */
-+#define R_PARISC_TLS_DTPOFF32	244	/* DTP offset 32-bit.  */
-+#define R_PARISC_TLS_DTPOFF64	245	/* DTP offset 32-bit.  */
-+#define R_PARISC_TLS_LE21L	R_PARISC_TPREL21L
-+#define R_PARISC_TLS_LE14R	R_PARISC_TPREL14R
-+#define R_PARISC_TLS_IE21L	R_PARISC_LTOFF_TP21L
-+#define R_PARISC_TLS_IE14R	R_PARISC_LTOFF_TP14R
-+#define R_PARISC_TLS_TPREL32	R_PARISC_TPREL32
-+#define R_PARISC_TLS_TPREL64	R_PARISC_TPREL64
-+#define R_PARISC_HIRESERVE	255
-+
-+/* Legal values for p_type field of Elf32_Phdr/Elf64_Phdr.  */
-+
-+#define PT_HP_TLS		(PT_LOOS + 0x0)
-+#define PT_HP_CORE_NONE		(PT_LOOS + 0x1)
-+#define PT_HP_CORE_VERSION	(PT_LOOS + 0x2)
-+#define PT_HP_CORE_KERNEL	(PT_LOOS + 0x3)
-+#define PT_HP_CORE_COMM		(PT_LOOS + 0x4)
-+#define PT_HP_CORE_PROC		(PT_LOOS + 0x5)
-+#define PT_HP_CORE_LOADABLE	(PT_LOOS + 0x6)
-+#define PT_HP_CORE_STACK	(PT_LOOS + 0x7)
-+#define PT_HP_CORE_SHM		(PT_LOOS + 0x8)
-+#define PT_HP_CORE_MMF		(PT_LOOS + 0x9)
-+#define PT_HP_PARALLEL		(PT_LOOS + 0x10)
-+#define PT_HP_FASTBIND		(PT_LOOS + 0x11)
-+#define PT_HP_OPT_ANNOT		(PT_LOOS + 0x12)
-+#define PT_HP_HSL_ANNOT		(PT_LOOS + 0x13)
-+#define PT_HP_STACK		(PT_LOOS + 0x14)
-+
-+#define PT_PARISC_ARCHEXT	0x70000000
-+#define PT_PARISC_UNWIND	0x70000001
-+
-+/* Legal values for p_flags field of Elf32_Phdr/Elf64_Phdr.  */
-+
-+#define PF_PARISC_SBP		0x08000000
-+
-+#define PF_HP_PAGE_SIZE		0x00100000
-+#define PF_HP_FAR_SHARED	0x00200000
-+#define PF_HP_NEAR_SHARED	0x00400000
-+#define PF_HP_CODE		0x01000000
-+#define PF_HP_MODIFY		0x02000000
-+#define PF_HP_LAZYSWAP		0x04000000
-+#define PF_HP_SBP		0x08000000
-+
-+
-+/* Alpha specific definitions.  */
-+
-+/* Legal values for e_flags field of Elf64_Ehdr.  */
-+
-+#define EF_ALPHA_32BIT		1	/* All addresses must be < 2GB.  */
-+#define EF_ALPHA_CANRELAX	2	/* Relocations for relaxing exist.  */
-+
-+/* Legal values for sh_type field of Elf64_Shdr.  */
-+
-+/* These two are primerily concerned with ECOFF debugging info.  */
-+#define SHT_ALPHA_DEBUG		0x70000001
-+#define SHT_ALPHA_REGINFO	0x70000002
-+
-+/* Legal values for sh_flags field of Elf64_Shdr.  */
-+
-+#define SHF_ALPHA_GPREL		0x10000000
-+
-+/* Legal values for st_other field of Elf64_Sym.  */
-+#define STO_ALPHA_NOPV		0x80	/* No PV required.  */
-+#define STO_ALPHA_STD_GPLOAD	0x88	/* PV only used for initial ldgp.  */
-+
-+/* Alpha relocs.  */
-+
-+#define R_ALPHA_NONE		0	/* No reloc */
-+#define R_ALPHA_REFLONG		1	/* Direct 32 bit */
-+#define R_ALPHA_REFQUAD		2	/* Direct 64 bit */
-+#define R_ALPHA_GPREL32		3	/* GP relative 32 bit */
-+#define R_ALPHA_LITERAL		4	/* GP relative 16 bit w/optimization */
-+#define R_ALPHA_LITUSE		5	/* Optimization hint for LITERAL */
-+#define R_ALPHA_GPDISP		6	/* Add displacement to GP */
-+#define R_ALPHA_BRADDR		7	/* PC+4 relative 23 bit shifted */
-+#define R_ALPHA_HINT		8	/* PC+4 relative 16 bit shifted */
-+#define R_ALPHA_SREL16		9	/* PC relative 16 bit */
-+#define R_ALPHA_SREL32		10	/* PC relative 32 bit */
-+#define R_ALPHA_SREL64		11	/* PC relative 64 bit */
-+#define R_ALPHA_GPRELHIGH	17	/* GP relative 32 bit, high 16 bits */
-+#define R_ALPHA_GPRELLOW	18	/* GP relative 32 bit, low 16 bits */
-+#define R_ALPHA_GPREL16		19	/* GP relative 16 bit */
-+#define R_ALPHA_COPY		24	/* Copy symbol at runtime */
-+#define R_ALPHA_GLOB_DAT	25	/* Create GOT entry */
-+#define R_ALPHA_JMP_SLOT	26	/* Create PLT entry */
-+#define R_ALPHA_RELATIVE	27	/* Adjust by program base */
-+#define R_ALPHA_TLS_GD_HI	28
-+#define R_ALPHA_TLSGD		29
-+#define R_ALPHA_TLS_LDM		30
-+#define R_ALPHA_DTPMOD64	31
-+#define R_ALPHA_GOTDTPREL	32
-+#define R_ALPHA_DTPREL64	33
-+#define R_ALPHA_DTPRELHI	34
-+#define R_ALPHA_DTPRELLO	35
-+#define R_ALPHA_DTPREL16	36
-+#define R_ALPHA_GOTTPREL	37
-+#define R_ALPHA_TPREL64		38
-+#define R_ALPHA_TPRELHI		39
-+#define R_ALPHA_TPRELLO		40
-+#define R_ALPHA_TPREL16		41
-+/* Keep this the last entry.  */
-+#define R_ALPHA_NUM		46
-+
-+/* Magic values of the LITUSE relocation addend.  */
-+#define LITUSE_ALPHA_ADDR	0
-+#define LITUSE_ALPHA_BASE	1
-+#define LITUSE_ALPHA_BYTOFF	2
-+#define LITUSE_ALPHA_JSR	3
-+#define LITUSE_ALPHA_TLS_GD	4
-+#define LITUSE_ALPHA_TLS_LDM	5
-+
-+/* Legal values for d_tag of Elf64_Dyn.  */
-+#define DT_ALPHA_PLTRO		(DT_LOPROC + 0)
-+#define DT_ALPHA_NUM		1
-+
-+/* PowerPC specific declarations */
-+
-+/* Values for Elf32/64_Ehdr.e_flags.  */
-+#define EF_PPC_EMB		0x80000000	/* PowerPC embedded flag */
-+
-+/* Cygnus local bits below */
-+#define EF_PPC_RELOCATABLE	0x00010000	/* PowerPC -mrelocatable flag*/
-+#define EF_PPC_RELOCATABLE_LIB	0x00008000	/* PowerPC -mrelocatable-lib
-+						   flag */
-+
-+/* PowerPC relocations defined by the ABIs */
-+#define R_PPC_NONE		0
-+#define R_PPC_ADDR32		1	/* 32bit absolute address */
-+#define R_PPC_ADDR24		2	/* 26bit address, 2 bits ignored.  */
-+#define R_PPC_ADDR16		3	/* 16bit absolute address */
-+#define R_PPC_ADDR16_LO		4	/* lower 16bit of absolute address */
-+#define R_PPC_ADDR16_HI		5	/* high 16bit of absolute address */
-+#define R_PPC_ADDR16_HA		6	/* adjusted high 16bit */
-+#define R_PPC_ADDR14		7	/* 16bit address, 2 bits ignored */
-+#define R_PPC_ADDR14_BRTAKEN	8
-+#define R_PPC_ADDR14_BRNTAKEN	9
-+#define R_PPC_REL24		10	/* PC relative 26 bit */
-+#define R_PPC_REL14		11	/* PC relative 16 bit */
-+#define R_PPC_REL14_BRTAKEN	12
-+#define R_PPC_REL14_BRNTAKEN	13
-+#define R_PPC_GOT16		14
-+#define R_PPC_GOT16_LO		15
-+#define R_PPC_GOT16_HI		16
-+#define R_PPC_GOT16_HA		17
-+#define R_PPC_PLTREL24		18
-+#define R_PPC_COPY		19
-+#define R_PPC_GLOB_DAT		20
-+#define R_PPC_JMP_SLOT		21
-+#define R_PPC_RELATIVE		22
-+#define R_PPC_LOCAL24PC		23
-+#define R_PPC_UADDR32		24
-+#define R_PPC_UADDR16		25
-+#define R_PPC_REL32		26
-+#define R_PPC_PLT32		27
-+#define R_PPC_PLTREL32		28
-+#define R_PPC_PLT16_LO		29
-+#define R_PPC_PLT16_HI		30
-+#define R_PPC_PLT16_HA		31
-+#define R_PPC_SDAREL16		32
-+#define R_PPC_SECTOFF		33
-+#define R_PPC_SECTOFF_LO	34
-+#define R_PPC_SECTOFF_HI	35
-+#define R_PPC_SECTOFF_HA	36
-+
-+/* PowerPC relocations defined for the TLS access ABI.  */
-+#define R_PPC_TLS		67 /* none	(sym+add)@tls */
-+#define R_PPC_DTPMOD32		68 /* word32	(sym+add)@dtpmod */
-+#define R_PPC_TPREL16		69 /* half16*	(sym+add)@tprel */
-+#define R_PPC_TPREL16_LO	70 /* half16	(sym+add)@tprel@l */
-+#define R_PPC_TPREL16_HI	71 /* half16	(sym+add)@tprel@h */
-+#define R_PPC_TPREL16_HA	72 /* half16	(sym+add)@tprel@ha */
-+#define R_PPC_TPREL32		73 /* word32	(sym+add)@tprel */
-+#define R_PPC_DTPREL16		74 /* half16*	(sym+add)@dtprel */
-+#define R_PPC_DTPREL16_LO	75 /* half16	(sym+add)@dtprel@l */
-+#define R_PPC_DTPREL16_HI	76 /* half16	(sym+add)@dtprel@h */
-+#define R_PPC_DTPREL16_HA	77 /* half16	(sym+add)@dtprel@ha */
-+#define R_PPC_DTPREL32		78 /* word32	(sym+add)@dtprel */
-+#define R_PPC_GOT_TLSGD16	79 /* half16*	(sym+add)@got@tlsgd */
-+#define R_PPC_GOT_TLSGD16_LO	80 /* half16	(sym+add)@got@tlsgd@l */
-+#define R_PPC_GOT_TLSGD16_HI	81 /* half16	(sym+add)@got@tlsgd@h */
-+#define R_PPC_GOT_TLSGD16_HA	82 /* half16	(sym+add)@got@tlsgd@ha */
-+#define R_PPC_GOT_TLSLD16	83 /* half16*	(sym+add)@got@tlsld */
-+#define R_PPC_GOT_TLSLD16_LO	84 /* half16	(sym+add)@got@tlsld@l */
-+#define R_PPC_GOT_TLSLD16_HI	85 /* half16	(sym+add)@got@tlsld@h */
-+#define R_PPC_GOT_TLSLD16_HA	86 /* half16	(sym+add)@got@tlsld@ha */
-+#define R_PPC_GOT_TPREL16	87 /* half16*	(sym+add)@got@tprel */
-+#define R_PPC_GOT_TPREL16_LO	88 /* half16	(sym+add)@got@tprel@l */
-+#define R_PPC_GOT_TPREL16_HI	89 /* half16	(sym+add)@got@tprel@h */
-+#define R_PPC_GOT_TPREL16_HA	90 /* half16	(sym+add)@got@tprel@ha */
-+#define R_PPC_GOT_DTPREL16	91 /* half16*	(sym+add)@got@dtprel */
-+#define R_PPC_GOT_DTPREL16_LO	92 /* half16*	(sym+add)@got@dtprel@l */
-+#define R_PPC_GOT_DTPREL16_HI	93 /* half16*	(sym+add)@got@dtprel@h */
-+#define R_PPC_GOT_DTPREL16_HA	94 /* half16*	(sym+add)@got@dtprel@ha */
-+
-+/* The remaining relocs are from the Embedded ELF ABI, and are not
-+   in the SVR4 ELF ABI.  */
-+#define R_PPC_EMB_NADDR32	101
-+#define R_PPC_EMB_NADDR16	102
-+#define R_PPC_EMB_NADDR16_LO	103
-+#define R_PPC_EMB_NADDR16_HI	104
-+#define R_PPC_EMB_NADDR16_HA	105
-+#define R_PPC_EMB_SDAI16	106
-+#define R_PPC_EMB_SDA2I16	107
-+#define R_PPC_EMB_SDA2REL	108
-+#define R_PPC_EMB_SDA21		109	/* 16 bit offset in SDA */
-+#define R_PPC_EMB_MRKREF	110
-+#define R_PPC_EMB_RELSEC16	111
-+#define R_PPC_EMB_RELST_LO	112
-+#define R_PPC_EMB_RELST_HI	113
-+#define R_PPC_EMB_RELST_HA	114
-+#define R_PPC_EMB_BIT_FLD	115
-+#define R_PPC_EMB_RELSDA	116	/* 16 bit relative offset in SDA */
-+
-+/* Diab tool relocations.  */
-+#define R_PPC_DIAB_SDA21_LO	180	/* like EMB_SDA21, but lower 16 bit */
-+#define R_PPC_DIAB_SDA21_HI	181	/* like EMB_SDA21, but high 16 bit */
-+#define R_PPC_DIAB_SDA21_HA	182	/* like EMB_SDA21, adjusted high 16 */
-+#define R_PPC_DIAB_RELSDA_LO	183	/* like EMB_RELSDA, but lower 16 bit */
-+#define R_PPC_DIAB_RELSDA_HI	184	/* like EMB_RELSDA, but high 16 bit */
-+#define R_PPC_DIAB_RELSDA_HA	185	/* like EMB_RELSDA, adjusted high 16 */
-+
-+/* GNU extension to support local ifunc.  */
-+#define R_PPC_IRELATIVE		248
-+
-+/* GNU relocs used in PIC code sequences.  */
-+#define R_PPC_REL16		249	/* half16   (sym+add-.) */
-+#define R_PPC_REL16_LO		250	/* half16   (sym+add-.)@l */
-+#define R_PPC_REL16_HI		251	/* half16   (sym+add-.)@h */
-+#define R_PPC_REL16_HA		252	/* half16   (sym+add-.)@ha */
-+
-+/* This is a phony reloc to handle any old fashioned TOC16 references
-+   that may still be in object files.  */
-+#define R_PPC_TOC16		255
-+
-+/* PowerPC specific values for the Dyn d_tag field.  */
-+#define DT_PPC_GOT		(DT_LOPROC + 0)
-+#define DT_PPC_NUM		1
-+
-+/* PowerPC64 relocations defined by the ABIs */
-+#define R_PPC64_NONE		R_PPC_NONE
-+#define R_PPC64_ADDR32		R_PPC_ADDR32 /* 32bit absolute address */
-+#define R_PPC64_ADDR24		R_PPC_ADDR24 /* 26bit address, word aligned */
-+#define R_PPC64_ADDR16		R_PPC_ADDR16 /* 16bit absolute address */
-+#define R_PPC64_ADDR16_LO	R_PPC_ADDR16_LO	/* lower 16bits of address */
-+#define R_PPC64_ADDR16_HI	R_PPC_ADDR16_HI	/* high 16bits of address. */
-+#define R_PPC64_ADDR16_HA	R_PPC_ADDR16_HA /* adjusted high 16bits.  */
-+#define R_PPC64_ADDR14		R_PPC_ADDR14 /* 16bit address, word aligned */
-+#define R_PPC64_ADDR14_BRTAKEN	R_PPC_ADDR14_BRTAKEN
-+#define R_PPC64_ADDR14_BRNTAKEN	R_PPC_ADDR14_BRNTAKEN
-+#define R_PPC64_REL24		R_PPC_REL24 /* PC-rel. 26 bit, word aligned */
-+#define R_PPC64_REL14		R_PPC_REL14 /* PC relative 16 bit */
-+#define R_PPC64_REL14_BRTAKEN	R_PPC_REL14_BRTAKEN
-+#define R_PPC64_REL14_BRNTAKEN	R_PPC_REL14_BRNTAKEN
-+#define R_PPC64_GOT16		R_PPC_GOT16
-+#define R_PPC64_GOT16_LO	R_PPC_GOT16_LO
-+#define R_PPC64_GOT16_HI	R_PPC_GOT16_HI
-+#define R_PPC64_GOT16_HA	R_PPC_GOT16_HA
-+
-+#define R_PPC64_COPY		R_PPC_COPY
-+#define R_PPC64_GLOB_DAT	R_PPC_GLOB_DAT
-+#define R_PPC64_JMP_SLOT	R_PPC_JMP_SLOT
-+#define R_PPC64_RELATIVE	R_PPC_RELATIVE
-+
-+#define R_PPC64_UADDR32		R_PPC_UADDR32
-+#define R_PPC64_UADDR16		R_PPC_UADDR16
-+#define R_PPC64_REL32		R_PPC_REL32
-+#define R_PPC64_PLT32		R_PPC_PLT32
-+#define R_PPC64_PLTREL32	R_PPC_PLTREL32
-+#define R_PPC64_PLT16_LO	R_PPC_PLT16_LO
-+#define R_PPC64_PLT16_HI	R_PPC_PLT16_HI
-+#define R_PPC64_PLT16_HA	R_PPC_PLT16_HA
-+
-+#define R_PPC64_SECTOFF		R_PPC_SECTOFF
-+#define R_PPC64_SECTOFF_LO	R_PPC_SECTOFF_LO
-+#define R_PPC64_SECTOFF_HI	R_PPC_SECTOFF_HI
-+#define R_PPC64_SECTOFF_HA	R_PPC_SECTOFF_HA
-+#define R_PPC64_ADDR30		37 /* word30 (S + A - P) >> 2 */
-+#define R_PPC64_ADDR64		38 /* doubleword64 S + A */
-+#define R_PPC64_ADDR16_HIGHER	39 /* half16 #higher(S + A) */
-+#define R_PPC64_ADDR16_HIGHERA	40 /* half16 #highera(S + A) */
-+#define R_PPC64_ADDR16_HIGHEST	41 /* half16 #highest(S + A) */
-+#define R_PPC64_ADDR16_HIGHESTA	42 /* half16 #highesta(S + A) */
-+#define R_PPC64_UADDR64		43 /* doubleword64 S + A */
-+#define R_PPC64_REL64		44 /* doubleword64 S + A - P */
-+#define R_PPC64_PLT64		45 /* doubleword64 L + A */
-+#define R_PPC64_PLTREL64	46 /* doubleword64 L + A - P */
-+#define R_PPC64_TOC16		47 /* half16* S + A - .TOC */
-+#define R_PPC64_TOC16_LO	48 /* half16 #lo(S + A - .TOC.) */
-+#define R_PPC64_TOC16_HI	49 /* half16 #hi(S + A - .TOC.) */
-+#define R_PPC64_TOC16_HA	50 /* half16 #ha(S + A - .TOC.) */
-+#define R_PPC64_TOC		51 /* doubleword64 .TOC */
-+#define R_PPC64_PLTGOT16	52 /* half16* M + A */
-+#define R_PPC64_PLTGOT16_LO	53 /* half16 #lo(M + A) */
-+#define R_PPC64_PLTGOT16_HI	54 /* half16 #hi(M + A) */
-+#define R_PPC64_PLTGOT16_HA	55 /* half16 #ha(M + A) */
-+
-+#define R_PPC64_ADDR16_DS	56 /* half16ds* (S + A) >> 2 */
-+#define R_PPC64_ADDR16_LO_DS	57 /* half16ds  #lo(S + A) >> 2 */
-+#define R_PPC64_GOT16_DS	58 /* half16ds* (G + A) >> 2 */
-+#define R_PPC64_GOT16_LO_DS	59 /* half16ds  #lo(G + A) >> 2 */
-+#define R_PPC64_PLT16_LO_DS	60 /* half16ds  #lo(L + A) >> 2 */
-+#define R_PPC64_SECTOFF_DS	61 /* half16ds* (R + A) >> 2 */
-+#define R_PPC64_SECTOFF_LO_DS	62 /* half16ds  #lo(R + A) >> 2 */
-+#define R_PPC64_TOC16_DS	63 /* half16ds* (S + A - .TOC.) >> 2 */
-+#define R_PPC64_TOC16_LO_DS	64 /* half16ds  #lo(S + A - .TOC.) >> 2 */
-+#define R_PPC64_PLTGOT16_DS	65 /* half16ds* (M + A) >> 2 */
-+#define R_PPC64_PLTGOT16_LO_DS	66 /* half16ds  #lo(M + A) >> 2 */
-+
-+/* PowerPC64 relocations defined for the TLS access ABI.  */
-+#define R_PPC64_TLS		67 /* none	(sym+add)@tls */
-+#define R_PPC64_DTPMOD64	68 /* doubleword64 (sym+add)@dtpmod */
-+#define R_PPC64_TPREL16		69 /* half16*	(sym+add)@tprel */
-+#define R_PPC64_TPREL16_LO	70 /* half16	(sym+add)@tprel@l */
-+#define R_PPC64_TPREL16_HI	71 /* half16	(sym+add)@tprel@h */
-+#define R_PPC64_TPREL16_HA	72 /* half16	(sym+add)@tprel@ha */
-+#define R_PPC64_TPREL64		73 /* doubleword64 (sym+add)@tprel */
-+#define R_PPC64_DTPREL16	74 /* half16*	(sym+add)@dtprel */
-+#define R_PPC64_DTPREL16_LO	75 /* half16	(sym+add)@dtprel@l */
-+#define R_PPC64_DTPREL16_HI	76 /* half16	(sym+add)@dtprel@h */
-+#define R_PPC64_DTPREL16_HA	77 /* half16	(sym+add)@dtprel@ha */
-+#define R_PPC64_DTPREL64	78 /* doubleword64 (sym+add)@dtprel */
-+#define R_PPC64_GOT_TLSGD16	79 /* half16*	(sym+add)@got@tlsgd */
-+#define R_PPC64_GOT_TLSGD16_LO	80 /* half16	(sym+add)@got@tlsgd@l */
-+#define R_PPC64_GOT_TLSGD16_HI	81 /* half16	(sym+add)@got@tlsgd@h */
-+#define R_PPC64_GOT_TLSGD16_HA	82 /* half16	(sym+add)@got@tlsgd@ha */
-+#define R_PPC64_GOT_TLSLD16	83 /* half16*	(sym+add)@got@tlsld */
-+#define R_PPC64_GOT_TLSLD16_LO	84 /* half16	(sym+add)@got@tlsld@l */
-+#define R_PPC64_GOT_TLSLD16_HI	85 /* half16	(sym+add)@got@tlsld@h */
-+#define R_PPC64_GOT_TLSLD16_HA	86 /* half16	(sym+add)@got@tlsld@ha */
-+#define R_PPC64_GOT_TPREL16_DS	87 /* half16ds*	(sym+add)@got@tprel */
-+#define R_PPC64_GOT_TPREL16_LO_DS 88 /* half16ds (sym+add)@got@tprel@l */
-+#define R_PPC64_GOT_TPREL16_HI	89 /* half16	(sym+add)@got@tprel@h */
-+#define R_PPC64_GOT_TPREL16_HA	90 /* half16	(sym+add)@got@tprel@ha */
-+#define R_PPC64_GOT_DTPREL16_DS	91 /* half16ds*	(sym+add)@got@dtprel */
-+#define R_PPC64_GOT_DTPREL16_LO_DS 92 /* half16ds (sym+add)@got@dtprel@l */
-+#define R_PPC64_GOT_DTPREL16_HI	93 /* half16	(sym+add)@got@dtprel@h */
-+#define R_PPC64_GOT_DTPREL16_HA	94 /* half16	(sym+add)@got@dtprel@ha */
-+#define R_PPC64_TPREL16_DS	95 /* half16ds*	(sym+add)@tprel */
-+#define R_PPC64_TPREL16_LO_DS	96 /* half16ds	(sym+add)@tprel@l */
-+#define R_PPC64_TPREL16_HIGHER	97 /* half16	(sym+add)@tprel@higher */
-+#define R_PPC64_TPREL16_HIGHERA	98 /* half16	(sym+add)@tprel@highera */
-+#define R_PPC64_TPREL16_HIGHEST	99 /* half16	(sym+add)@tprel@highest */
-+#define R_PPC64_TPREL16_HIGHESTA 100 /* half16	(sym+add)@tprel@highesta */
-+#define R_PPC64_DTPREL16_DS	101 /* half16ds* (sym+add)@dtprel */
-+#define R_PPC64_DTPREL16_LO_DS	102 /* half16ds	(sym+add)@dtprel@l */
-+#define R_PPC64_DTPREL16_HIGHER	103 /* half16	(sym+add)@dtprel@higher */
-+#define R_PPC64_DTPREL16_HIGHERA 104 /* half16	(sym+add)@dtprel@highera */
-+#define R_PPC64_DTPREL16_HIGHEST 105 /* half16	(sym+add)@dtprel@highest */
-+#define R_PPC64_DTPREL16_HIGHESTA 106 /* half16	(sym+add)@dtprel@highesta */
-+
-+/* GNU extension to support local ifunc.  */
-+#define R_PPC64_JMP_IREL	247
-+#define R_PPC64_IRELATIVE	248
-+#define R_PPC64_REL16		249	/* half16   (sym+add-.) */
-+#define R_PPC64_REL16_LO	250	/* half16   (sym+add-.)@l */
-+#define R_PPC64_REL16_HI	251	/* half16   (sym+add-.)@h */
-+#define R_PPC64_REL16_HA	252	/* half16   (sym+add-.)@ha */
-+
-+/* PowerPC64 specific values for the Dyn d_tag field.  */
-+#define DT_PPC64_GLINK  (DT_LOPROC + 0)
-+#define DT_PPC64_OPD	(DT_LOPROC + 1)
-+#define DT_PPC64_OPDSZ	(DT_LOPROC + 2)
-+#define DT_PPC64_NUM    3
-+
-+
-+/* ARM specific declarations */
-+
-+/* Processor specific flags for the ELF header e_flags field.  */
-+#define EF_ARM_RELEXEC		0x01
-+#define EF_ARM_HASENTRY		0x02
-+#define EF_ARM_INTERWORK	0x04
-+#define EF_ARM_APCS_26		0x08
-+#define EF_ARM_APCS_FLOAT	0x10
-+#define EF_ARM_PIC		0x20
-+#define EF_ARM_ALIGN8		0x40 /* 8-bit structure alignment is in use */
-+#define EF_ARM_NEW_ABI		0x80
-+#define EF_ARM_OLD_ABI		0x100
-+#define EF_ARM_SOFT_FLOAT	0x200
-+#define EF_ARM_VFP_FLOAT	0x400
-+#define EF_ARM_MAVERICK_FLOAT	0x800
-+
-+
-+/* Other constants defined in the ARM ELF spec. version B-01.  */
-+/* NB. These conflict with values defined above.  */
-+#define EF_ARM_SYMSARESORTED	0x04
-+#define EF_ARM_DYNSYMSUSESEGIDX	0x08
-+#define EF_ARM_MAPSYMSFIRST	0x10
-+#define EF_ARM_EABIMASK		0XFF000000
-+
-+/* Constants defined in AAELF.  */
-+#define EF_ARM_BE8	    0x00800000
-+#define EF_ARM_LE8	    0x00400000
-+
-+#define EF_ARM_EABI_VERSION(flags)	((flags) & EF_ARM_EABIMASK)
-+#define EF_ARM_EABI_UNKNOWN	0x00000000
-+#define EF_ARM_EABI_VER1	0x01000000
-+#define EF_ARM_EABI_VER2	0x02000000
-+#define EF_ARM_EABI_VER3	0x03000000
-+#define EF_ARM_EABI_VER4	0x04000000
-+#define EF_ARM_EABI_VER5	0x05000000
-+
-+/* Additional symbol types for Thumb.  */
-+#define STT_ARM_TFUNC		STT_LOPROC /* A Thumb function.  */
-+#define STT_ARM_16BIT		STT_HIPROC /* A Thumb label.  */
-+
-+/* ARM-specific values for sh_flags */
-+#define SHF_ARM_ENTRYSECT	0x10000000 /* Section contains an entry point */
-+#define SHF_ARM_COMDEF		0x80000000 /* Section may be multiply defined
-+					      in the input to a link step.  */
-+
-+/* ARM-specific program header flags */
-+#define PF_ARM_SB		0x10000000 /* Segment contains the location
-+					      addressed by the static base. */
-+#define PF_ARM_PI		0x20000000 /* Position-independent segment.  */
-+#define PF_ARM_ABS		0x40000000 /* Absolute segment.  */
-+
-+/* Processor specific values for the Phdr p_type field.  */
-+#define PT_ARM_EXIDX		(PT_LOPROC + 1)	/* ARM unwind segment.  */
-+
-+/* Processor specific values for the Shdr sh_type field.  */
-+#define SHT_ARM_EXIDX		(SHT_LOPROC + 1) /* ARM unwind section.  */
-+#define SHT_ARM_PREEMPTMAP	(SHT_LOPROC + 2) /* Preemption details.  */
-+#define SHT_ARM_ATTRIBUTES	(SHT_LOPROC + 3) /* ARM attributes section.  */
-+
-+
-+/* ARM relocs.  */
-+
-+#define R_ARM_NONE		0	/* No reloc */
-+#define R_ARM_PC24		1	/* PC relative 26 bit branch */
-+#define R_ARM_ABS32		2	/* Direct 32 bit  */
-+#define R_ARM_REL32		3	/* PC relative 32 bit */
-+#define R_ARM_PC13		4
-+#define R_ARM_ABS16		5	/* Direct 16 bit */
-+#define R_ARM_ABS12		6	/* Direct 12 bit */
-+#define R_ARM_THM_ABS5		7
-+#define R_ARM_ABS8		8	/* Direct 8 bit */
-+#define R_ARM_SBREL32		9
-+#define R_ARM_THM_PC22		10
-+#define R_ARM_THM_PC8		11
-+#define R_ARM_AMP_VCALL9	12
-+#define R_ARM_SWI24		13	/* Obsolete static relocation.  */
-+#define R_ARM_TLS_DESC		13      /* Dynamic relocation.  */
-+#define R_ARM_THM_SWI8		14
-+#define R_ARM_XPC25		15
-+#define R_ARM_THM_XPC22		16
-+#define R_ARM_TLS_DTPMOD32	17	/* ID of module containing symbol */
-+#define R_ARM_TLS_DTPOFF32	18	/* Offset in TLS block */
-+#define R_ARM_TLS_TPOFF32	19	/* Offset in static TLS block */
-+#define R_ARM_COPY		20	/* Copy symbol at runtime */
-+#define R_ARM_GLOB_DAT		21	/* Create GOT entry */
-+#define R_ARM_JUMP_SLOT		22	/* Create PLT entry */
-+#define R_ARM_RELATIVE		23	/* Adjust by program base */
-+#define R_ARM_GOTOFF		24	/* 32 bit offset to GOT */
-+#define R_ARM_GOTPC		25	/* 32 bit PC relative offset to GOT */
-+#define R_ARM_GOT32		26	/* 32 bit GOT entry */
-+#define R_ARM_PLT32		27	/* 32 bit PLT address */
-+#define R_ARM_ALU_PCREL_7_0	32
-+#define R_ARM_ALU_PCREL_15_8	33
-+#define R_ARM_ALU_PCREL_23_15	34
-+#define R_ARM_LDR_SBREL_11_0	35
-+#define R_ARM_ALU_SBREL_19_12	36
-+#define R_ARM_ALU_SBREL_27_20	37
-+#define R_ARM_TLS_GOTDESC	90
-+#define R_ARM_TLS_CALL		91
-+#define R_ARM_TLS_DESCSEQ	92
-+#define R_ARM_THM_TLS_CALL	93
-+#define R_ARM_GNU_VTENTRY	100
-+#define R_ARM_GNU_VTINHERIT	101
-+#define R_ARM_THM_PC11		102	/* thumb unconditional branch */
-+#define R_ARM_THM_PC9		103	/* thumb conditional branch */
-+#define R_ARM_TLS_GD32		104	/* PC-rel 32 bit for global dynamic
-+					   thread local data */
-+#define R_ARM_TLS_LDM32		105	/* PC-rel 32 bit for local dynamic
-+					   thread local data */
-+#define R_ARM_TLS_LDO32		106	/* 32 bit offset relative to TLS
-+					   block */
-+#define R_ARM_TLS_IE32		107	/* PC-rel 32 bit for GOT entry of
-+					   static TLS block offset */
-+#define R_ARM_TLS_LE32		108	/* 32 bit offset relative to static
-+					   TLS block */
-+#define	R_ARM_THM_TLS_DESCSEQ	129
-+#define R_ARM_IRELATIVE		160
-+#define R_ARM_RXPC25		249
-+#define R_ARM_RSBREL32		250
-+#define R_ARM_THM_RPC22		251
-+#define R_ARM_RREL32		252
-+#define R_ARM_RABS22		253
-+#define R_ARM_RPC24		254
-+#define R_ARM_RBASE		255
-+/* Keep this the last entry.  */
-+#define R_ARM_NUM		256
-+
-+/* IA-64 specific declarations.  */
-+
-+/* Processor specific flags for the Ehdr e_flags field.  */
-+#define EF_IA_64_MASKOS		0x0000000f	/* os-specific flags */
-+#define EF_IA_64_ABI64		0x00000010	/* 64-bit ABI */
-+#define EF_IA_64_ARCH		0xff000000	/* arch. version mask */
-+
-+/* Processor specific values for the Phdr p_type field.  */
-+#define PT_IA_64_ARCHEXT	(PT_LOPROC + 0)	/* arch extension bits */
-+#define PT_IA_64_UNWIND		(PT_LOPROC + 1)	/* ia64 unwind bits */
-+#define PT_IA_64_HP_OPT_ANOT	(PT_LOOS + 0x12)
-+#define PT_IA_64_HP_HSL_ANOT	(PT_LOOS + 0x13)
-+#define PT_IA_64_HP_STACK	(PT_LOOS + 0x14)
-+
-+/* Processor specific flags for the Phdr p_flags field.  */
-+#define PF_IA_64_NORECOV	0x80000000	/* spec insns w/o recovery */
-+
-+/* Processor specific values for the Shdr sh_type field.  */
-+#define SHT_IA_64_EXT		(SHT_LOPROC + 0) /* extension bits */
-+#define SHT_IA_64_UNWIND	(SHT_LOPROC + 1) /* unwind bits */
-+
-+/* Processor specific flags for the Shdr sh_flags field.  */
-+#define SHF_IA_64_SHORT		0x10000000	/* section near gp */
-+#define SHF_IA_64_NORECOV	0x20000000	/* spec insns w/o recovery */
-+
-+/* Processor specific values for the Dyn d_tag field.  */
-+#define DT_IA_64_PLT_RESERVE	(DT_LOPROC + 0)
-+#define DT_IA_64_NUM		1
-+
-+/* IA-64 relocations.  */
-+#define R_IA64_NONE		0x00	/* none */
-+#define R_IA64_IMM14		0x21	/* symbol + addend, add imm14 */
-+#define R_IA64_IMM22		0x22	/* symbol + addend, add imm22 */
-+#define R_IA64_IMM64		0x23	/* symbol + addend, mov imm64 */
-+#define R_IA64_DIR32MSB		0x24	/* symbol + addend, data4 MSB */
-+#define R_IA64_DIR32LSB		0x25	/* symbol + addend, data4 LSB */
-+#define R_IA64_DIR64MSB		0x26	/* symbol + addend, data8 MSB */
-+#define R_IA64_DIR64LSB		0x27	/* symbol + addend, data8 LSB */
-+#define R_IA64_GPREL22		0x2a	/* @gprel(sym + add), add imm22 */
-+#define R_IA64_GPREL64I		0x2b	/* @gprel(sym + add), mov imm64 */
-+#define R_IA64_GPREL32MSB	0x2c	/* @gprel(sym + add), data4 MSB */
-+#define R_IA64_GPREL32LSB	0x2d	/* @gprel(sym + add), data4 LSB */
-+#define R_IA64_GPREL64MSB	0x2e	/* @gprel(sym + add), data8 MSB */
-+#define R_IA64_GPREL64LSB	0x2f	/* @gprel(sym + add), data8 LSB */
-+#define R_IA64_LTOFF22		0x32	/* @ltoff(sym + add), add imm22 */
-+#define R_IA64_LTOFF64I		0x33	/* @ltoff(sym + add), mov imm64 */
-+#define R_IA64_PLTOFF22		0x3a	/* @pltoff(sym + add), add imm22 */
-+#define R_IA64_PLTOFF64I	0x3b	/* @pltoff(sym + add), mov imm64 */
-+#define R_IA64_PLTOFF64MSB	0x3e	/* @pltoff(sym + add), data8 MSB */
-+#define R_IA64_PLTOFF64LSB	0x3f	/* @pltoff(sym + add), data8 LSB */
-+#define R_IA64_FPTR64I		0x43	/* @fptr(sym + add), mov imm64 */
-+#define R_IA64_FPTR32MSB	0x44	/* @fptr(sym + add), data4 MSB */
-+#define R_IA64_FPTR32LSB	0x45	/* @fptr(sym + add), data4 LSB */
-+#define R_IA64_FPTR64MSB	0x46	/* @fptr(sym + add), data8 MSB */
-+#define R_IA64_FPTR64LSB	0x47	/* @fptr(sym + add), data8 LSB */
-+#define R_IA64_PCREL60B		0x48	/* @pcrel(sym + add), brl */
-+#define R_IA64_PCREL21B		0x49	/* @pcrel(sym + add), ptb, call */
-+#define R_IA64_PCREL21M		0x4a	/* @pcrel(sym + add), chk.s */
-+#define R_IA64_PCREL21F		0x4b	/* @pcrel(sym + add), fchkf */
-+#define R_IA64_PCREL32MSB	0x4c	/* @pcrel(sym + add), data4 MSB */
-+#define R_IA64_PCREL32LSB	0x4d	/* @pcrel(sym + add), data4 LSB */
-+#define R_IA64_PCREL64MSB	0x4e	/* @pcrel(sym + add), data8 MSB */
-+#define R_IA64_PCREL64LSB	0x4f	/* @pcrel(sym + add), data8 LSB */
-+#define R_IA64_LTOFF_FPTR22	0x52	/* @ltoff(@fptr(s+a)), imm22 */
-+#define R_IA64_LTOFF_FPTR64I	0x53	/* @ltoff(@fptr(s+a)), imm64 */
-+#define R_IA64_LTOFF_FPTR32MSB	0x54	/* @ltoff(@fptr(s+a)), data4 MSB */
-+#define R_IA64_LTOFF_FPTR32LSB	0x55	/* @ltoff(@fptr(s+a)), data4 LSB */
-+#define R_IA64_LTOFF_FPTR64MSB	0x56	/* @ltoff(@fptr(s+a)), data8 MSB */
-+#define R_IA64_LTOFF_FPTR64LSB	0x57	/* @ltoff(@fptr(s+a)), data8 LSB */
-+#define R_IA64_SEGREL32MSB	0x5c	/* @segrel(sym + add), data4 MSB */
-+#define R_IA64_SEGREL32LSB	0x5d	/* @segrel(sym + add), data4 LSB */
-+#define R_IA64_SEGREL64MSB	0x5e	/* @segrel(sym + add), data8 MSB */
-+#define R_IA64_SEGREL64LSB	0x5f	/* @segrel(sym + add), data8 LSB */
-+#define R_IA64_SECREL32MSB	0x64	/* @secrel(sym + add), data4 MSB */
-+#define R_IA64_SECREL32LSB	0x65	/* @secrel(sym + add), data4 LSB */
-+#define R_IA64_SECREL64MSB	0x66	/* @secrel(sym + add), data8 MSB */
-+#define R_IA64_SECREL64LSB	0x67	/* @secrel(sym + add), data8 LSB */
-+#define R_IA64_REL32MSB		0x6c	/* data 4 + REL */
-+#define R_IA64_REL32LSB		0x6d	/* data 4 + REL */
-+#define R_IA64_REL64MSB		0x6e	/* data 8 + REL */
-+#define R_IA64_REL64LSB		0x6f	/* data 8 + REL */
-+#define R_IA64_LTV32MSB		0x74	/* symbol + addend, data4 MSB */
-+#define R_IA64_LTV32LSB		0x75	/* symbol + addend, data4 LSB */
-+#define R_IA64_LTV64MSB		0x76	/* symbol + addend, data8 MSB */
-+#define R_IA64_LTV64LSB		0x77	/* symbol + addend, data8 LSB */
-+#define R_IA64_PCREL21BI	0x79	/* @pcrel(sym + add), 21bit inst */
-+#define R_IA64_PCREL22		0x7a	/* @pcrel(sym + add), 22bit inst */
-+#define R_IA64_PCREL64I		0x7b	/* @pcrel(sym + add), 64bit inst */
-+#define R_IA64_IPLTMSB		0x80	/* dynamic reloc, imported PLT, MSB */
-+#define R_IA64_IPLTLSB		0x81	/* dynamic reloc, imported PLT, LSB */
-+#define R_IA64_COPY		0x84	/* copy relocation */
-+#define R_IA64_SUB		0x85	/* Addend and symbol difference */
-+#define R_IA64_LTOFF22X		0x86	/* LTOFF22, relaxable.  */
-+#define R_IA64_LDXMOV		0x87	/* Use of LTOFF22X.  */
-+#define R_IA64_TPREL14		0x91	/* @tprel(sym + add), imm14 */
-+#define R_IA64_TPREL22		0x92	/* @tprel(sym + add), imm22 */
-+#define R_IA64_TPREL64I		0x93	/* @tprel(sym + add), imm64 */
-+#define R_IA64_TPREL64MSB	0x96	/* @tprel(sym + add), data8 MSB */
-+#define R_IA64_TPREL64LSB	0x97	/* @tprel(sym + add), data8 LSB */
-+#define R_IA64_LTOFF_TPREL22	0x9a	/* @ltoff(@tprel(s+a)), imm2 */
-+#define R_IA64_DTPMOD64MSB	0xa6	/* @dtpmod(sym + add), data8 MSB */
-+#define R_IA64_DTPMOD64LSB	0xa7	/* @dtpmod(sym + add), data8 LSB */
-+#define R_IA64_LTOFF_DTPMOD22	0xaa	/* @ltoff(@dtpmod(sym + add)), imm22 */
-+#define R_IA64_DTPREL14		0xb1	/* @dtprel(sym + add), imm14 */
-+#define R_IA64_DTPREL22		0xb2	/* @dtprel(sym + add), imm22 */
-+#define R_IA64_DTPREL64I	0xb3	/* @dtprel(sym + add), imm64 */
-+#define R_IA64_DTPREL32MSB	0xb4	/* @dtprel(sym + add), data4 MSB */
-+#define R_IA64_DTPREL32LSB	0xb5	/* @dtprel(sym + add), data4 LSB */
-+#define R_IA64_DTPREL64MSB	0xb6	/* @dtprel(sym + add), data8 MSB */
-+#define R_IA64_DTPREL64LSB	0xb7	/* @dtprel(sym + add), data8 LSB */
-+#define R_IA64_LTOFF_DTPREL22	0xba	/* @ltoff(@dtprel(s+a)), imm22 */
-+
-+/* SH specific declarations */
-+
-+/* Processor specific flags for the ELF header e_flags field.  */
-+#define EF_SH_MACH_MASK		0x1f
-+#define EF_SH_UNKNOWN		0x0
-+#define EF_SH1			0x1
-+#define EF_SH2			0x2
-+#define EF_SH3			0x3
-+#define EF_SH_DSP		0x4
-+#define EF_SH3_DSP		0x5
-+#define EF_SH4AL_DSP		0x6
-+#define EF_SH3E			0x8
-+#define EF_SH4			0x9
-+#define EF_SH2E			0xb
-+#define EF_SH4A			0xc
-+#define EF_SH2A			0xd
-+#define EF_SH4_NOFPU		0x10
-+#define EF_SH4A_NOFPU		0x11
-+#define EF_SH4_NOMMU_NOFPU	0x12
-+#define EF_SH2A_NOFPU		0x13
-+#define EF_SH3_NOMMU		0x14
-+#define EF_SH2A_SH4_NOFPU	0x15
-+#define EF_SH2A_SH3_NOFPU	0x16
-+#define EF_SH2A_SH4		0x17
-+#define EF_SH2A_SH3E		0x18
-+
-+/* SH relocs.  */
-+#define	R_SH_NONE		0
-+#define	R_SH_DIR32		1
-+#define	R_SH_REL32		2
-+#define	R_SH_DIR8WPN		3
-+#define	R_SH_IND12W		4
-+#define	R_SH_DIR8WPL		5
-+#define	R_SH_DIR8WPZ		6
-+#define	R_SH_DIR8BP		7
-+#define	R_SH_DIR8W		8
-+#define	R_SH_DIR8L		9
-+#define	R_SH_SWITCH16		25
-+#define	R_SH_SWITCH32		26
-+#define	R_SH_USES		27
-+#define	R_SH_COUNT		28
-+#define	R_SH_ALIGN		29
-+#define	R_SH_CODE		30
-+#define	R_SH_DATA		31
-+#define	R_SH_LABEL		32
-+#define	R_SH_SWITCH8		33
-+#define	R_SH_GNU_VTINHERIT	34
-+#define	R_SH_GNU_VTENTRY	35
-+#define	R_SH_TLS_GD_32		144
-+#define	R_SH_TLS_LD_32		145
-+#define	R_SH_TLS_LDO_32		146
-+#define	R_SH_TLS_IE_32		147
-+#define	R_SH_TLS_LE_32		148
-+#define	R_SH_TLS_DTPMOD32	149
-+#define	R_SH_TLS_DTPOFF32	150
-+#define	R_SH_TLS_TPOFF32	151
-+#define	R_SH_GOT32		160
-+#define	R_SH_PLT32		161
-+#define	R_SH_COPY		162
-+#define	R_SH_GLOB_DAT		163
-+#define	R_SH_JMP_SLOT		164
-+#define	R_SH_RELATIVE		165
-+#define	R_SH_GOTOFF		166
-+#define	R_SH_GOTPC		167
-+/* Keep this the last entry.  */
-+#define	R_SH_NUM		256
-+
-+/* S/390 specific definitions.  */
-+
-+/* Valid values for the e_flags field.  */
-+
-+#define EF_S390_HIGH_GPRS    0x00000001  /* High GPRs kernel facility needed.  */
-+
-+/* Additional s390 relocs */
-+
-+#define R_390_NONE		0	/* No reloc.  */
-+#define R_390_8			1	/* Direct 8 bit.  */
-+#define R_390_12		2	/* Direct 12 bit.  */
-+#define R_390_16		3	/* Direct 16 bit.  */
-+#define R_390_32		4	/* Direct 32 bit.  */
-+#define R_390_PC32		5	/* PC relative 32 bit.	*/
-+#define R_390_GOT12		6	/* 12 bit GOT offset.  */
-+#define R_390_GOT32		7	/* 32 bit GOT offset.  */
-+#define R_390_PLT32		8	/* 32 bit PC relative PLT address.  */
-+#define R_390_COPY		9	/* Copy symbol at runtime.  */
-+#define R_390_GLOB_DAT		10	/* Create GOT entry.  */
-+#define R_390_JMP_SLOT		11	/* Create PLT entry.  */
-+#define R_390_RELATIVE		12	/* Adjust by program base.  */
-+#define R_390_GOTOFF32		13	/* 32 bit offset to GOT.	 */
-+#define R_390_GOTPC		14	/* 32 bit PC relative offset to GOT.  */
-+#define R_390_GOT16		15	/* 16 bit GOT offset.  */
-+#define R_390_PC16		16	/* PC relative 16 bit.	*/
-+#define R_390_PC16DBL		17	/* PC relative 16 bit shifted by 1.  */
-+#define R_390_PLT16DBL		18	/* 16 bit PC rel. PLT shifted by 1.  */
-+#define R_390_PC32DBL		19	/* PC relative 32 bit shifted by 1.  */
-+#define R_390_PLT32DBL		20	/* 32 bit PC rel. PLT shifted by 1.  */
-+#define R_390_GOTPCDBL		21	/* 32 bit PC rel. GOT shifted by 1.  */
-+#define R_390_64		22	/* Direct 64 bit.  */
-+#define R_390_PC64		23	/* PC relative 64 bit.	*/
-+#define R_390_GOT64		24	/* 64 bit GOT offset.  */
-+#define R_390_PLT64		25	/* 64 bit PC relative PLT address.  */
-+#define R_390_GOTENT		26	/* 32 bit PC rel. to GOT entry >> 1. */
-+#define R_390_GOTOFF16		27	/* 16 bit offset to GOT. */
-+#define R_390_GOTOFF64		28	/* 64 bit offset to GOT. */
-+#define R_390_GOTPLT12		29	/* 12 bit offset to jump slot.	*/
-+#define R_390_GOTPLT16		30	/* 16 bit offset to jump slot.	*/
-+#define R_390_GOTPLT32		31	/* 32 bit offset to jump slot.	*/
-+#define R_390_GOTPLT64		32	/* 64 bit offset to jump slot.	*/
-+#define R_390_GOTPLTENT		33	/* 32 bit rel. offset to jump slot.  */
-+#define R_390_PLTOFF16		34	/* 16 bit offset from GOT to PLT. */
-+#define R_390_PLTOFF32		35	/* 32 bit offset from GOT to PLT. */
-+#define R_390_PLTOFF64		36	/* 16 bit offset from GOT to PLT. */
-+#define R_390_TLS_LOAD		37	/* Tag for load insn in TLS code.  */
-+#define R_390_TLS_GDCALL	38	/* Tag for function call in general
-+					   dynamic TLS code. */
-+#define R_390_TLS_LDCALL	39	/* Tag for function call in local
-+					   dynamic TLS code. */
-+#define R_390_TLS_GD32		40	/* Direct 32 bit for general dynamic
-+					   thread local data.  */
-+#define R_390_TLS_GD64		41	/* Direct 64 bit for general dynamic
-+					  thread local data.  */
-+#define R_390_TLS_GOTIE12	42	/* 12 bit GOT offset for static TLS
-+					   block offset.  */
-+#define R_390_TLS_GOTIE32	43	/* 32 bit GOT offset for static TLS
-+					   block offset.  */
-+#define R_390_TLS_GOTIE64	44	/* 64 bit GOT offset for static TLS
-+					   block offset. */
-+#define R_390_TLS_LDM32		45	/* Direct 32 bit for local dynamic
-+					   thread local data in LE code.  */
-+#define R_390_TLS_LDM64		46	/* Direct 64 bit for local dynamic
-+					   thread local data in LE code.  */
-+#define R_390_TLS_IE32		47	/* 32 bit address of GOT entry for
-+					   negated static TLS block offset.  */
-+#define R_390_TLS_IE64		48	/* 64 bit address of GOT entry for
-+					   negated static TLS block offset.  */
-+#define R_390_TLS_IEENT		49	/* 32 bit rel. offset to GOT entry for
-+					   negated static TLS block offset.  */
-+#define R_390_TLS_LE32		50	/* 32 bit negated offset relative to
-+					   static TLS block.  */
-+#define R_390_TLS_LE64		51	/* 64 bit negated offset relative to
-+					   static TLS block.  */
-+#define R_390_TLS_LDO32		52	/* 32 bit offset relative to TLS
-+					   block.  */
-+#define R_390_TLS_LDO64		53	/* 64 bit offset relative to TLS
-+					   block.  */
-+#define R_390_TLS_DTPMOD	54	/* ID of module containing symbol.  */
-+#define R_390_TLS_DTPOFF	55	/* Offset in TLS block.	 */
-+#define R_390_TLS_TPOFF		56	/* Negated offset in static TLS
-+					   block.  */
-+#define R_390_20		57	/* Direct 20 bit.  */
-+#define R_390_GOT20		58	/* 20 bit GOT offset.  */
-+#define R_390_GOTPLT20		59	/* 20 bit offset to jump slot.  */
-+#define R_390_TLS_GOTIE20	60	/* 20 bit GOT offset for static TLS
-+					   block offset.  */
-+#define R_390_IRELATIVE         61      /* STT_GNU_IFUNC relocation.  */
-+/* Keep this the last entry.  */
-+#define R_390_NUM		62
-+
-+
-+/* CRIS relocations.  */
-+#define R_CRIS_NONE		0
-+#define R_CRIS_8		1
-+#define R_CRIS_16		2
-+#define R_CRIS_32		3
-+#define R_CRIS_8_PCREL		4
-+#define R_CRIS_16_PCREL		5
-+#define R_CRIS_32_PCREL		6
-+#define R_CRIS_GNU_VTINHERIT	7
-+#define R_CRIS_GNU_VTENTRY	8
-+#define R_CRIS_COPY		9
-+#define R_CRIS_GLOB_DAT		10
-+#define R_CRIS_JUMP_SLOT	11
-+#define R_CRIS_RELATIVE		12
-+#define R_CRIS_16_GOT		13
-+#define R_CRIS_32_GOT		14
-+#define R_CRIS_16_GOTPLT	15
-+#define R_CRIS_32_GOTPLT	16
-+#define R_CRIS_32_GOTREL	17
-+#define R_CRIS_32_PLT_GOTREL	18
-+#define R_CRIS_32_PLT_PCREL	19
-+
-+#define R_CRIS_NUM		20
-+
-+
-+/* AMD x86-64 relocations.  */
-+#define R_X86_64_NONE		0	/* No reloc */
-+#define R_X86_64_64		1	/* Direct 64 bit  */
-+#define R_X86_64_PC32		2	/* PC relative 32 bit signed */
-+#define R_X86_64_GOT32		3	/* 32 bit GOT entry */
-+#define R_X86_64_PLT32		4	/* 32 bit PLT address */
-+#define R_X86_64_COPY		5	/* Copy symbol at runtime */
-+#define R_X86_64_GLOB_DAT	6	/* Create GOT entry */
-+#define R_X86_64_JUMP_SLOT	7	/* Create PLT entry */
-+#define R_X86_64_RELATIVE	8	/* Adjust by program base */
-+#define R_X86_64_GOTPCREL	9	/* 32 bit signed PC relative
-+					   offset to GOT */
-+#define R_X86_64_32		10	/* Direct 32 bit zero extended */
-+#define R_X86_64_32S		11	/* Direct 32 bit sign extended */
-+#define R_X86_64_16		12	/* Direct 16 bit zero extended */
-+#define R_X86_64_PC16		13	/* 16 bit sign extended pc relative */
-+#define R_X86_64_8		14	/* Direct 8 bit sign extended  */
-+#define R_X86_64_PC8		15	/* 8 bit sign extended pc relative */
-+#define R_X86_64_DTPMOD64	16	/* ID of module containing symbol */
-+#define R_X86_64_DTPOFF64	17	/* Offset in module's TLS block */
-+#define R_X86_64_TPOFF64	18	/* Offset in initial TLS block */
-+#define R_X86_64_TLSGD		19	/* 32 bit signed PC relative offset
-+					   to two GOT entries for GD symbol */
-+#define R_X86_64_TLSLD		20	/* 32 bit signed PC relative offset
-+					   to two GOT entries for LD symbol */
-+#define R_X86_64_DTPOFF32	21	/* Offset in TLS block */
-+#define R_X86_64_GOTTPOFF	22	/* 32 bit signed PC relative offset
-+					   to GOT entry for IE symbol */
-+#define R_X86_64_TPOFF32	23	/* Offset in initial TLS block */
-+#define R_X86_64_PC64		24	/* PC relative 64 bit */
-+#define R_X86_64_GOTOFF64	25	/* 64 bit offset to GOT */
-+#define R_X86_64_GOTPC32	26	/* 32 bit signed pc relative
-+					   offset to GOT */
-+#define R_X86_64_GOT64		27	/* 64-bit GOT entry offset */
-+#define R_X86_64_GOTPCREL64	28	/* 64-bit PC relative offset
-+					   to GOT entry */
-+#define R_X86_64_GOTPC64	29	/* 64-bit PC relative offset to GOT */
-+#define R_X86_64_GOTPLT64	30 	/* like GOT64, says PLT entry needed */
-+#define R_X86_64_PLTOFF64	31	/* 64-bit GOT relative offset
-+					   to PLT entry */
-+#define R_X86_64_SIZE32		32	/* Size of symbol plus 32-bit addend */
-+#define R_X86_64_SIZE64		33	/* Size of symbol plus 64-bit addend */
-+#define R_X86_64_GOTPC32_TLSDESC 34	/* GOT offset for TLS descriptor.  */
-+#define R_X86_64_TLSDESC_CALL   35	/* Marker for call through TLS
-+					   descriptor.  */
-+#define R_X86_64_TLSDESC        36	/* TLS descriptor.  */
-+#define R_X86_64_IRELATIVE	37	/* Adjust indirectly by program base */
-+#define R_X86_64_RELATIVE64	38	/* 64-bit adjust by program base */
-+
-+#define R_X86_64_NUM		39
-+
-+
-+/* AM33 relocations.  */
-+#define R_MN10300_NONE		0	/* No reloc.  */
-+#define R_MN10300_32		1	/* Direct 32 bit.  */
-+#define R_MN10300_16		2	/* Direct 16 bit.  */
-+#define R_MN10300_8		3	/* Direct 8 bit.  */
-+#define R_MN10300_PCREL32	4	/* PC-relative 32-bit.  */
-+#define R_MN10300_PCREL16	5	/* PC-relative 16-bit signed.  */
-+#define R_MN10300_PCREL8	6	/* PC-relative 8-bit signed.  */
-+#define R_MN10300_GNU_VTINHERIT	7	/* Ancient C++ vtable garbage... */
-+#define R_MN10300_GNU_VTENTRY	8	/* ... collection annotation.  */
-+#define R_MN10300_24		9	/* Direct 24 bit.  */
-+#define R_MN10300_GOTPC32	10	/* 32-bit PCrel offset to GOT.  */
-+#define R_MN10300_GOTPC16	11	/* 16-bit PCrel offset to GOT.  */
-+#define R_MN10300_GOTOFF32	12	/* 32-bit offset from GOT.  */
-+#define R_MN10300_GOTOFF24	13	/* 24-bit offset from GOT.  */
-+#define R_MN10300_GOTOFF16	14	/* 16-bit offset from GOT.  */
-+#define R_MN10300_PLT32		15	/* 32-bit PCrel to PLT entry.  */
-+#define R_MN10300_PLT16		16	/* 16-bit PCrel to PLT entry.  */
-+#define R_MN10300_GOT32		17	/* 32-bit offset to GOT entry.  */
-+#define R_MN10300_GOT24		18	/* 24-bit offset to GOT entry.  */
-+#define R_MN10300_GOT16		19	/* 16-bit offset to GOT entry.  */
-+#define R_MN10300_COPY		20	/* Copy symbol at runtime.  */
-+#define R_MN10300_GLOB_DAT	21	/* Create GOT entry.  */
-+#define R_MN10300_JMP_SLOT	22	/* Create PLT entry.  */
-+#define R_MN10300_RELATIVE	23	/* Adjust by program base.  */
-+
-+#define R_MN10300_NUM		24
-+
-+
-+/* M32R relocs.  */
-+#define R_M32R_NONE		0	/* No reloc. */
-+#define R_M32R_16		1	/* Direct 16 bit. */
-+#define R_M32R_32		2	/* Direct 32 bit. */
-+#define R_M32R_24		3	/* Direct 24 bit. */
-+#define R_M32R_10_PCREL		4	/* PC relative 10 bit shifted. */
-+#define R_M32R_18_PCREL		5	/* PC relative 18 bit shifted. */
-+#define R_M32R_26_PCREL		6	/* PC relative 26 bit shifted. */
-+#define R_M32R_HI16_ULO		7	/* High 16 bit with unsigned low. */
-+#define R_M32R_HI16_SLO		8	/* High 16 bit with signed low. */
-+#define R_M32R_LO16		9	/* Low 16 bit. */
-+#define R_M32R_SDA16		10	/* 16 bit offset in SDA. */
-+#define R_M32R_GNU_VTINHERIT	11
-+#define R_M32R_GNU_VTENTRY	12
-+/* M32R relocs use SHT_RELA.  */
-+#define R_M32R_16_RELA		33	/* Direct 16 bit. */
-+#define R_M32R_32_RELA		34	/* Direct 32 bit. */
-+#define R_M32R_24_RELA		35	/* Direct 24 bit. */
-+#define R_M32R_10_PCREL_RELA	36	/* PC relative 10 bit shifted. */
-+#define R_M32R_18_PCREL_RELA	37	/* PC relative 18 bit shifted. */
-+#define R_M32R_26_PCREL_RELA	38	/* PC relative 26 bit shifted. */
-+#define R_M32R_HI16_ULO_RELA	39	/* High 16 bit with unsigned low */
-+#define R_M32R_HI16_SLO_RELA	40	/* High 16 bit with signed low */
-+#define R_M32R_LO16_RELA	41	/* Low 16 bit */
-+#define R_M32R_SDA16_RELA	42	/* 16 bit offset in SDA */
-+#define R_M32R_RELA_GNU_VTINHERIT	43
-+#define R_M32R_RELA_GNU_VTENTRY	44
-+#define R_M32R_REL32		45	/* PC relative 32 bit.  */
-+
-+#define R_M32R_GOT24		48	/* 24 bit GOT entry */
-+#define R_M32R_26_PLTREL	49	/* 26 bit PC relative to PLT shifted */
-+#define R_M32R_COPY		50	/* Copy symbol at runtime */
-+#define R_M32R_GLOB_DAT		51	/* Create GOT entry */
-+#define R_M32R_JMP_SLOT		52	/* Create PLT entry */
-+#define R_M32R_RELATIVE		53	/* Adjust by program base */
-+#define R_M32R_GOTOFF		54	/* 24 bit offset to GOT */
-+#define R_M32R_GOTPC24		55	/* 24 bit PC relative offset to GOT */
-+#define R_M32R_GOT16_HI_ULO	56	/* High 16 bit GOT entry with unsigned
-+					   low */
-+#define R_M32R_GOT16_HI_SLO	57	/* High 16 bit GOT entry with signed
-+					   low */
-+#define R_M32R_GOT16_LO		58	/* Low 16 bit GOT entry */
-+#define R_M32R_GOTPC_HI_ULO	59	/* High 16 bit PC relative offset to
-+					   GOT with unsigned low */
-+#define R_M32R_GOTPC_HI_SLO	60	/* High 16 bit PC relative offset to
-+					   GOT with signed low */
-+#define R_M32R_GOTPC_LO		61	/* Low 16 bit PC relative offset to
-+					   GOT */
-+#define R_M32R_GOTOFF_HI_ULO	62	/* High 16 bit offset to GOT
-+					   with unsigned low */
-+#define R_M32R_GOTOFF_HI_SLO	63	/* High 16 bit offset to GOT
-+					   with signed low */
-+#define R_M32R_GOTOFF_LO	64	/* Low 16 bit offset to GOT */
-+#define R_M32R_NUM		256	/* Keep this the last entry. */
-+
-+
-+/* TILEPro relocations.  */
-+#define R_TILEPRO_NONE		0	/* No reloc */
-+#define R_TILEPRO_32		1	/* Direct 32 bit */
-+#define R_TILEPRO_16		2	/* Direct 16 bit */
-+#define R_TILEPRO_8		3	/* Direct 8 bit */
-+#define R_TILEPRO_32_PCREL	4	/* PC relative 32 bit */
-+#define R_TILEPRO_16_PCREL	5	/* PC relative 16 bit */
-+#define R_TILEPRO_8_PCREL	6	/* PC relative 8 bit */
-+#define R_TILEPRO_LO16		7	/* Low 16 bit */
-+#define R_TILEPRO_HI16		8	/* High 16 bit */
-+#define R_TILEPRO_HA16		9	/* High 16 bit, adjusted */
-+#define R_TILEPRO_COPY		10	/* Copy relocation */
-+#define R_TILEPRO_GLOB_DAT	11	/* Create GOT entry */
-+#define R_TILEPRO_JMP_SLOT	12	/* Create PLT entry */
-+#define R_TILEPRO_RELATIVE	13	/* Adjust by program base */
-+#define R_TILEPRO_BROFF_X1	14	/* X1 pipe branch offset */
-+#define R_TILEPRO_JOFFLONG_X1	15	/* X1 pipe jump offset */
-+#define R_TILEPRO_JOFFLONG_X1_PLT 16	/* X1 pipe jump offset to PLT */
-+#define R_TILEPRO_IMM8_X0	17	/* X0 pipe 8-bit */
-+#define R_TILEPRO_IMM8_Y0	18	/* Y0 pipe 8-bit */
-+#define R_TILEPRO_IMM8_X1	19	/* X1 pipe 8-bit */
-+#define R_TILEPRO_IMM8_Y1	20	/* Y1 pipe 8-bit */
-+#define R_TILEPRO_MT_IMM15_X1	21	/* X1 pipe mtspr */
-+#define R_TILEPRO_MF_IMM15_X1	22	/* X1 pipe mfspr */
-+#define R_TILEPRO_IMM16_X0	23	/* X0 pipe 16-bit */
-+#define R_TILEPRO_IMM16_X1	24	/* X1 pipe 16-bit */
-+#define R_TILEPRO_IMM16_X0_LO	25	/* X0 pipe low 16-bit */
-+#define R_TILEPRO_IMM16_X1_LO	26	/* X1 pipe low 16-bit */
-+#define R_TILEPRO_IMM16_X0_HI	27	/* X0 pipe high 16-bit */
-+#define R_TILEPRO_IMM16_X1_HI	28	/* X1 pipe high 16-bit */
-+#define R_TILEPRO_IMM16_X0_HA	29	/* X0 pipe high 16-bit, adjusted */
-+#define R_TILEPRO_IMM16_X1_HA	30	/* X1 pipe high 16-bit, adjusted */
-+#define R_TILEPRO_IMM16_X0_PCREL 31	/* X0 pipe PC relative 16 bit */
-+#define R_TILEPRO_IMM16_X1_PCREL 32	/* X1 pipe PC relative 16 bit */
-+#define R_TILEPRO_IMM16_X0_LO_PCREL 33	/* X0 pipe PC relative low 16 bit */
-+#define R_TILEPRO_IMM16_X1_LO_PCREL 34	/* X1 pipe PC relative low 16 bit */
-+#define R_TILEPRO_IMM16_X0_HI_PCREL 35	/* X0 pipe PC relative high 16 bit */
-+#define R_TILEPRO_IMM16_X1_HI_PCREL 36	/* X1 pipe PC relative high 16 bit */
-+#define R_TILEPRO_IMM16_X0_HA_PCREL 37	/* X0 pipe PC relative ha() 16 bit */
-+#define R_TILEPRO_IMM16_X1_HA_PCREL 38	/* X1 pipe PC relative ha() 16 bit */
-+#define R_TILEPRO_IMM16_X0_GOT	39	/* X0 pipe 16-bit GOT offset */
-+#define R_TILEPRO_IMM16_X1_GOT	40	/* X1 pipe 16-bit GOT offset */
-+#define R_TILEPRO_IMM16_X0_GOT_LO 41	/* X0 pipe low 16-bit GOT offset */
-+#define R_TILEPRO_IMM16_X1_GOT_LO 42	/* X1 pipe low 16-bit GOT offset */
-+#define R_TILEPRO_IMM16_X0_GOT_HI 43	/* X0 pipe high 16-bit GOT offset */
-+#define R_TILEPRO_IMM16_X1_GOT_HI 44	/* X1 pipe high 16-bit GOT offset */
-+#define R_TILEPRO_IMM16_X0_GOT_HA 45	/* X0 pipe ha() 16-bit GOT offset */
-+#define R_TILEPRO_IMM16_X1_GOT_HA 46	/* X1 pipe ha() 16-bit GOT offset */
-+#define R_TILEPRO_MMSTART_X0	47	/* X0 pipe mm "start" */
-+#define R_TILEPRO_MMEND_X0	48	/* X0 pipe mm "end" */
-+#define R_TILEPRO_MMSTART_X1	49	/* X1 pipe mm "start" */
-+#define R_TILEPRO_MMEND_X1	50	/* X1 pipe mm "end" */
-+#define R_TILEPRO_SHAMT_X0	51	/* X0 pipe shift amount */
-+#define R_TILEPRO_SHAMT_X1	52	/* X1 pipe shift amount */
-+#define R_TILEPRO_SHAMT_Y0	53	/* Y0 pipe shift amount */
-+#define R_TILEPRO_SHAMT_Y1	54	/* Y1 pipe shift amount */
-+#define R_TILEPRO_DEST_IMM8_X1	55	/* X1 pipe destination 8-bit */
-+/* Relocs 56-59 are currently not defined.  */
-+#define R_TILEPRO_TLS_GD_CALL	60	/* "jal" for TLS GD */
-+#define R_TILEPRO_IMM8_X0_TLS_GD_ADD 61	/* X0 pipe "addi" for TLS GD */
-+#define R_TILEPRO_IMM8_X1_TLS_GD_ADD 62	/* X1 pipe "addi" for TLS GD */
-+#define R_TILEPRO_IMM8_Y0_TLS_GD_ADD 63	/* Y0 pipe "addi" for TLS GD */
-+#define R_TILEPRO_IMM8_Y1_TLS_GD_ADD 64	/* Y1 pipe "addi" for TLS GD */
-+#define R_TILEPRO_TLS_IE_LOAD	65	/* "lw_tls" for TLS IE */
-+#define R_TILEPRO_IMM16_X0_TLS_GD 66	/* X0 pipe 16-bit TLS GD offset */
-+#define R_TILEPRO_IMM16_X1_TLS_GD 67	/* X1 pipe 16-bit TLS GD offset */
-+#define R_TILEPRO_IMM16_X0_TLS_GD_LO 68	/* X0 pipe low 16-bit TLS GD offset */
-+#define R_TILEPRO_IMM16_X1_TLS_GD_LO 69	/* X1 pipe low 16-bit TLS GD offset */
-+#define R_TILEPRO_IMM16_X0_TLS_GD_HI 70	/* X0 pipe high 16-bit TLS GD offset */
-+#define R_TILEPRO_IMM16_X1_TLS_GD_HI 71	/* X1 pipe high 16-bit TLS GD offset */
-+#define R_TILEPRO_IMM16_X0_TLS_GD_HA 72	/* X0 pipe ha() 16-bit TLS GD offset */
-+#define R_TILEPRO_IMM16_X1_TLS_GD_HA 73	/* X1 pipe ha() 16-bit TLS GD offset */
-+#define R_TILEPRO_IMM16_X0_TLS_IE 74	/* X0 pipe 16-bit TLS IE offset */
-+#define R_TILEPRO_IMM16_X1_TLS_IE 75	/* X1 pipe 16-bit TLS IE offset */
-+#define R_TILEPRO_IMM16_X0_TLS_IE_LO 76	/* X0 pipe low 16-bit TLS IE offset */
-+#define R_TILEPRO_IMM16_X1_TLS_IE_LO 77	/* X1 pipe low 16-bit TLS IE offset */
-+#define R_TILEPRO_IMM16_X0_TLS_IE_HI 78	/* X0 pipe high 16-bit TLS IE offset */
-+#define R_TILEPRO_IMM16_X1_TLS_IE_HI 79	/* X1 pipe high 16-bit TLS IE offset */
-+#define R_TILEPRO_IMM16_X0_TLS_IE_HA 80	/* X0 pipe ha() 16-bit TLS IE offset */
-+#define R_TILEPRO_IMM16_X1_TLS_IE_HA 81	/* X1 pipe ha() 16-bit TLS IE offset */
-+#define R_TILEPRO_TLS_DTPMOD32	82	/* ID of module containing symbol */
-+#define R_TILEPRO_TLS_DTPOFF32	83	/* Offset in TLS block */
-+#define R_TILEPRO_TLS_TPOFF32	84	/* Offset in static TLS block */
-+#define R_TILEPRO_IMM16_X0_TLS_LE 85	/* X0 pipe 16-bit TLS LE offset */
-+#define R_TILEPRO_IMM16_X1_TLS_LE 86	/* X1 pipe 16-bit TLS LE offset */
-+#define R_TILEPRO_IMM16_X0_TLS_LE_LO 87	/* X0 pipe low 16-bit TLS LE offset */
-+#define R_TILEPRO_IMM16_X1_TLS_LE_LO 88	/* X1 pipe low 16-bit TLS LE offset */
-+#define R_TILEPRO_IMM16_X0_TLS_LE_HI 89	/* X0 pipe high 16-bit TLS LE offset */
-+#define R_TILEPRO_IMM16_X1_TLS_LE_HI 90	/* X1 pipe high 16-bit TLS LE offset */
-+#define R_TILEPRO_IMM16_X0_TLS_LE_HA 91	/* X0 pipe ha() 16-bit TLS LE offset */
-+#define R_TILEPRO_IMM16_X1_TLS_LE_HA 92	/* X1 pipe ha() 16-bit TLS LE offset */
-+
-+#define R_TILEPRO_GNU_VTINHERIT	128	/* GNU C++ vtable hierarchy */
-+#define R_TILEPRO_GNU_VTENTRY	129	/* GNU C++ vtable member usage */
-+
-+#define R_TILEPRO_NUM		130
-+
-+
-+/* TILE-Gx relocations.  */
-+#define R_TILEGX_NONE		0	/* No reloc */
-+#define R_TILEGX_64		1	/* Direct 64 bit */
-+#define R_TILEGX_32		2	/* Direct 32 bit */
-+#define R_TILEGX_16		3	/* Direct 16 bit */
-+#define R_TILEGX_8		4	/* Direct 8 bit */
-+#define R_TILEGX_64_PCREL	5	/* PC relative 64 bit */
-+#define R_TILEGX_32_PCREL	6	/* PC relative 32 bit */
-+#define R_TILEGX_16_PCREL	7	/* PC relative 16 bit */
-+#define R_TILEGX_8_PCREL	8	/* PC relative 8 bit */
-+#define R_TILEGX_HW0		9	/* hword 0 16-bit */
-+#define R_TILEGX_HW1		10	/* hword 1 16-bit */
-+#define R_TILEGX_HW2		11	/* hword 2 16-bit */
-+#define R_TILEGX_HW3		12	/* hword 3 16-bit */
-+#define R_TILEGX_HW0_LAST	13	/* last hword 0 16-bit */
-+#define R_TILEGX_HW1_LAST	14	/* last hword 1 16-bit */
-+#define R_TILEGX_HW2_LAST	15	/* last hword 2 16-bit */
-+#define R_TILEGX_COPY		16	/* Copy relocation */
-+#define R_TILEGX_GLOB_DAT	17	/* Create GOT entry */
-+#define R_TILEGX_JMP_SLOT	18	/* Create PLT entry */
-+#define R_TILEGX_RELATIVE	19	/* Adjust by program base */
-+#define R_TILEGX_BROFF_X1	20	/* X1 pipe branch offset */
-+#define R_TILEGX_JUMPOFF_X1	21	/* X1 pipe jump offset */
-+#define R_TILEGX_JUMPOFF_X1_PLT	22	/* X1 pipe jump offset to PLT */
-+#define R_TILEGX_IMM8_X0	23	/* X0 pipe 8-bit */
-+#define R_TILEGX_IMM8_Y0	24	/* Y0 pipe 8-bit */
-+#define R_TILEGX_IMM8_X1	25	/* X1 pipe 8-bit */
-+#define R_TILEGX_IMM8_Y1	26	/* Y1 pipe 8-bit */
-+#define R_TILEGX_DEST_IMM8_X1	27	/* X1 pipe destination 8-bit */
-+#define R_TILEGX_MT_IMM14_X1	28	/* X1 pipe mtspr */
-+#define R_TILEGX_MF_IMM14_X1	29	/* X1 pipe mfspr */
-+#define R_TILEGX_MMSTART_X0	30	/* X0 pipe mm "start" */
-+#define R_TILEGX_MMEND_X0	31	/* X0 pipe mm "end" */
-+#define R_TILEGX_SHAMT_X0	32	/* X0 pipe shift amount */
-+#define R_TILEGX_SHAMT_X1	33	/* X1 pipe shift amount */
-+#define R_TILEGX_SHAMT_Y0	34	/* Y0 pipe shift amount */
-+#define R_TILEGX_SHAMT_Y1	35	/* Y1 pipe shift amount */
-+#define R_TILEGX_IMM16_X0_HW0	36	/* X0 pipe hword 0 */
-+#define R_TILEGX_IMM16_X1_HW0	37	/* X1 pipe hword 0 */
-+#define R_TILEGX_IMM16_X0_HW1	38	/* X0 pipe hword 1 */
-+#define R_TILEGX_IMM16_X1_HW1	39	/* X1 pipe hword 1 */
-+#define R_TILEGX_IMM16_X0_HW2	40	/* X0 pipe hword 2 */
-+#define R_TILEGX_IMM16_X1_HW2	41	/* X1 pipe hword 2 */
-+#define R_TILEGX_IMM16_X0_HW3	42	/* X0 pipe hword 3 */
-+#define R_TILEGX_IMM16_X1_HW3	43	/* X1 pipe hword 3 */
-+#define R_TILEGX_IMM16_X0_HW0_LAST 44	/* X0 pipe last hword 0 */
-+#define R_TILEGX_IMM16_X1_HW0_LAST 45	/* X1 pipe last hword 0 */
-+#define R_TILEGX_IMM16_X0_HW1_LAST 46	/* X0 pipe last hword 1 */
-+#define R_TILEGX_IMM16_X1_HW1_LAST 47	/* X1 pipe last hword 1 */
-+#define R_TILEGX_IMM16_X0_HW2_LAST 48	/* X0 pipe last hword 2 */
-+#define R_TILEGX_IMM16_X1_HW2_LAST 49	/* X1 pipe last hword 2 */
-+#define R_TILEGX_IMM16_X0_HW0_PCREL 50	/* X0 pipe PC relative hword 0 */
-+#define R_TILEGX_IMM16_X1_HW0_PCREL 51	/* X1 pipe PC relative hword 0 */
-+#define R_TILEGX_IMM16_X0_HW1_PCREL 52	/* X0 pipe PC relative hword 1 */
-+#define R_TILEGX_IMM16_X1_HW1_PCREL 53	/* X1 pipe PC relative hword 1 */
-+#define R_TILEGX_IMM16_X0_HW2_PCREL 54	/* X0 pipe PC relative hword 2 */
-+#define R_TILEGX_IMM16_X1_HW2_PCREL 55	/* X1 pipe PC relative hword 2 */
-+#define R_TILEGX_IMM16_X0_HW3_PCREL 56	/* X0 pipe PC relative hword 3 */
-+#define R_TILEGX_IMM16_X1_HW3_PCREL 57	/* X1 pipe PC relative hword 3 */
-+#define R_TILEGX_IMM16_X0_HW0_LAST_PCREL 58 /* X0 pipe PC-rel last hword 0 */
-+#define R_TILEGX_IMM16_X1_HW0_LAST_PCREL 59 /* X1 pipe PC-rel last hword 0 */
-+#define R_TILEGX_IMM16_X0_HW1_LAST_PCREL 60 /* X0 pipe PC-rel last hword 1 */
-+#define R_TILEGX_IMM16_X1_HW1_LAST_PCREL 61 /* X1 pipe PC-rel last hword 1 */
-+#define R_TILEGX_IMM16_X0_HW2_LAST_PCREL 62 /* X0 pipe PC-rel last hword 2 */
-+#define R_TILEGX_IMM16_X1_HW2_LAST_PCREL 63 /* X1 pipe PC-rel last hword 2 */
-+#define R_TILEGX_IMM16_X0_HW0_GOT 64	/* X0 pipe hword 0 GOT offset */
-+#define R_TILEGX_IMM16_X1_HW0_GOT 65	/* X1 pipe hword 0 GOT offset */
-+/* Relocs 66-71 are currently not defined.  */
-+#define R_TILEGX_IMM16_X0_HW0_LAST_GOT 72 /* X0 pipe last hword 0 GOT offset */
-+#define R_TILEGX_IMM16_X1_HW0_LAST_GOT 73 /* X1 pipe last hword 0 GOT offset */
-+#define R_TILEGX_IMM16_X0_HW1_LAST_GOT 74 /* X0 pipe last hword 1 GOT offset */
-+#define R_TILEGX_IMM16_X1_HW1_LAST_GOT 75 /* X1 pipe last hword 1 GOT offset */
-+/* Relocs 76-77 are currently not defined.  */
-+#define R_TILEGX_IMM16_X0_HW0_TLS_GD 78	/* X0 pipe hword 0 TLS GD offset */
-+#define R_TILEGX_IMM16_X1_HW0_TLS_GD 79	/* X1 pipe hword 0 TLS GD offset */
-+#define R_TILEGX_IMM16_X0_HW0_TLS_LE 80	/* X0 pipe hword 0 TLS LE offset */
-+#define R_TILEGX_IMM16_X1_HW0_TLS_LE 81	/* X1 pipe hword 0 TLS LE offset */
-+#define R_TILEGX_IMM16_X0_HW0_LAST_TLS_LE 82 /* X0 pipe last hword 0 LE off */
-+#define R_TILEGX_IMM16_X1_HW0_LAST_TLS_LE 83 /* X1 pipe last hword 0 LE off */
-+#define R_TILEGX_IMM16_X0_HW1_LAST_TLS_LE 84 /* X0 pipe last hword 1 LE off */
-+#define R_TILEGX_IMM16_X1_HW1_LAST_TLS_LE 85 /* X1 pipe last hword 1 LE off */
-+#define R_TILEGX_IMM16_X0_HW0_LAST_TLS_GD 86 /* X0 pipe last hword 0 GD off */
-+#define R_TILEGX_IMM16_X1_HW0_LAST_TLS_GD 87 /* X1 pipe last hword 0 GD off */
-+#define R_TILEGX_IMM16_X0_HW1_LAST_TLS_GD 88 /* X0 pipe last hword 1 GD off */
-+#define R_TILEGX_IMM16_X1_HW1_LAST_TLS_GD 89 /* X1 pipe last hword 1 GD off */
-+/* Relocs 90-91 are currently not defined.  */
-+#define R_TILEGX_IMM16_X0_HW0_TLS_IE 92	/* X0 pipe hword 0 TLS IE offset */
-+#define R_TILEGX_IMM16_X1_HW0_TLS_IE 93	/* X1 pipe hword 0 TLS IE offset */
-+/* Relocs 94-99 are currently not defined.  */
-+#define R_TILEGX_IMM16_X0_HW0_LAST_TLS_IE 100 /* X0 pipe last hword 0 IE off */
-+#define R_TILEGX_IMM16_X1_HW0_LAST_TLS_IE 101 /* X1 pipe last hword 0 IE off */
-+#define R_TILEGX_IMM16_X0_HW1_LAST_TLS_IE 102 /* X0 pipe last hword 1 IE off */
-+#define R_TILEGX_IMM16_X1_HW1_LAST_TLS_IE 103 /* X1 pipe last hword 1 IE off */
-+/* Relocs 104-105 are currently not defined.  */
-+#define R_TILEGX_TLS_DTPMOD64	106	/* 64-bit ID of symbol's module */
-+#define R_TILEGX_TLS_DTPOFF64	107	/* 64-bit offset in TLS block */
-+#define R_TILEGX_TLS_TPOFF64	108	/* 64-bit offset in static TLS block */
-+#define R_TILEGX_TLS_DTPMOD32	109	/* 32-bit ID of symbol's module */
-+#define R_TILEGX_TLS_DTPOFF32	110	/* 32-bit offset in TLS block */
-+#define R_TILEGX_TLS_TPOFF32	111	/* 32-bit offset in static TLS block */
-+#define R_TILEGX_TLS_GD_CALL	112	/* "jal" for TLS GD */
-+#define R_TILEGX_IMM8_X0_TLS_GD_ADD 113	/* X0 pipe "addi" for TLS GD */
-+#define R_TILEGX_IMM8_X1_TLS_GD_ADD 114	/* X1 pipe "addi" for TLS GD */
-+#define R_TILEGX_IMM8_Y0_TLS_GD_ADD 115	/* Y0 pipe "addi" for TLS GD */
-+#define R_TILEGX_IMM8_Y1_TLS_GD_ADD 116	/* Y1 pipe "addi" for TLS GD */
-+#define R_TILEGX_TLS_IE_LOAD	117	/* "ld_tls" for TLS IE */
-+#define R_TILEGX_IMM8_X0_TLS_ADD 118	/* X0 pipe "addi" for TLS GD/IE */
-+#define R_TILEGX_IMM8_X1_TLS_ADD 119	/* X1 pipe "addi" for TLS GD/IE */
-+#define R_TILEGX_IMM8_Y0_TLS_ADD 120	/* Y0 pipe "addi" for TLS GD/IE */
-+#define R_TILEGX_IMM8_Y1_TLS_ADD 121	/* Y1 pipe "addi" for TLS GD/IE */
-+
-+#define R_TILEGX_GNU_VTINHERIT	128	/* GNU C++ vtable hierarchy */
-+#define R_TILEGX_GNU_VTENTRY	129	/* GNU C++ vtable member usage */
-+
-+#define R_TILEGX_NUM		130
-+
-+#endif	/* elf.h */
--- a/target/linux/generic/pending-3.18/212-byteshift_portability.patch	2022-03-22 08:54:47.291464809 +0800
+++ b/target/linux/generic/pending-3.18/212-byteshift_portability.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,51 +0,0 @@
---- a/tools/include/tools/be_byteshift.h
-+++ b/tools/include/tools/be_byteshift.h
-@@ -1,6 +1,10 @@
- #ifndef _TOOLS_BE_BYTESHIFT_H
- #define _TOOLS_BE_BYTESHIFT_H
- 
-+#ifndef __linux__
-+#include "linux_types.h"
-+#endif
-+
- #include <stdint.h>
- 
- static inline uint16_t __get_unaligned_be16(const uint8_t *p)
---- a/tools/include/tools/le_byteshift.h
-+++ b/tools/include/tools/le_byteshift.h
-@@ -1,6 +1,10 @@
- #ifndef _TOOLS_LE_BYTESHIFT_H
- #define _TOOLS_LE_BYTESHIFT_H
- 
-+#ifndef __linux__
-+#include "linux_types.h"
-+#endif
-+
- #include <stdint.h>
- 
- static inline uint16_t __get_unaligned_le16(const uint8_t *p)
---- /dev/null
-+++ b/tools/include/tools/linux_types.h
-@@ -0,0 +1,22 @@
-+#ifndef __LINUX_TYPES_H
-+#define __LINUX_TYPES_H
-+
-+#include <stdint.h>
-+
-+typedef uint8_t __u8;
-+typedef uint8_t __be8;
-+typedef uint8_t __le8;
-+
-+typedef uint16_t __u16;
-+typedef uint16_t __be16;
-+typedef uint16_t __le16;
-+
-+typedef uint32_t __u32;
-+typedef uint32_t __be32;
-+typedef uint32_t __le32;
-+
-+typedef uint64_t __u64;
-+typedef uint64_t __be64;
-+typedef uint64_t __le64;
-+
-+#endif
--- a/target/linux/generic/pending-3.18/213-x86_vdso_portability.patch	2022-03-22 08:54:47.291464809 +0800
+++ b/target/linux/generic/pending-3.18/213-x86_vdso_portability.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,13 +0,0 @@
---- a/arch/x86/vdso/vdso2c.c
-+++ b/arch/x86/vdso/vdso2c.c
-@@ -63,8 +63,8 @@
- 
- #include <tools/le_byteshift.h>
- 
--#include <linux/elf.h>
--#include <linux/types.h>
-+#include <elf.h>
-+#include <stdbool.h>
- 
- const char *outfilename;
- 
--- a/target/linux/generic/pending-3.18/214-spidev_h_portability.patch	2022-03-22 08:54:47.291464809 +0800
+++ b/target/linux/generic/pending-3.18/214-spidev_h_portability.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,11 +0,0 @@
---- a/include/uapi/linux/spi/spidev.h
-+++ b/include/uapi/linux/spi/spidev.h
-@@ -112,7 +112,7 @@ struct spi_ioc_transfer {
- 
- /* not all platforms use <asm-generic/ioctl.h> or _IOC_TYPECHECK() ... */
- #define SPI_MSGSIZE(N) \
--	((((N)*(sizeof (struct spi_ioc_transfer))) < (1 << _IOC_SIZEBITS)) \
-+	((((N)*(sizeof (struct spi_ioc_transfer))) < (1 << 13)) \
- 		? ((N)*(sizeof (struct spi_ioc_transfer))) : 0)
- #define SPI_IOC_MESSAGE(N) _IOW(SPI_IOC_MAGIC, 0, char[SPI_MSGSIZE(N)])
- 
--- a/target/linux/generic/pending-3.18/220-gc_sections.patch	2022-03-22 08:54:47.292464811 +0800
+++ b/target/linux/generic/pending-3.18/220-gc_sections.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,531 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-
-use -ffunction-sections, -fdata-sections and --gc-sections
-
-In combination with kernel symbol export stripping this significantly reduces
-the kernel image size. Used on both ARM and MIPS architectures.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
-Signed-off-by: Jonas Gorski <jogo@openwrt.org>
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
-
---- a/arch/mips/Makefile
-+++ b/arch/mips/Makefile
-@@ -89,10 +89,14 @@ all-$(CONFIG_SYS_SUPPORTS_ZBOOT)+= vmlin
- #
- cflags-y			+= -G 0 -mno-abicalls -fno-pic -pipe
- cflags-y			+= -msoft-float
--LDFLAGS_vmlinux			+= -G 0 -static -n -nostdlib
-+LDFLAGS_vmlinux			+= -G 0 -static -n -nostdlib --gc-sections
- KBUILD_AFLAGS_MODULE		+= -mlong-calls
- KBUILD_CFLAGS_MODULE		+= -mlong-calls
- 
-+ifndef CONFIG_FUNCTION_TRACER
-+KBUILD_CFLAGS_KERNEL		+= -ffunction-sections -fdata-sections
-+endif
-+
- #
- # pass -msoft-float to GAS if it supports it.  However on newer binutils
- # (specifically newer than 2.24.51.20140728) we then also need to explicitly
---- a/arch/mips/kernel/vmlinux.lds.S
-+++ b/arch/mips/kernel/vmlinux.lds.S
-@@ -67,7 +67,7 @@ SECTIONS
- 	/* Exception table for data bus errors */
- 	__dbe_table : {
- 		__start___dbe_table = .;
--		*(__dbe_table)
-+		KEEP(*(__dbe_table))
- 		__stop___dbe_table = .;
- 	}
- 
-@@ -112,7 +112,7 @@ SECTIONS
- 	. = ALIGN(4);
- 	.mips.machines.init : AT(ADDR(.mips.machines.init) - LOAD_OFFSET) {
- 		__mips_machines_start = .;
--		*(.mips.machines.init)
-+		KEEP(*(.mips.machines.init))
- 		__mips_machines_end = .;
- 	}
- 
---- a/include/asm-generic/vmlinux.lds.h
-+++ b/include/asm-generic/vmlinux.lds.h
-@@ -89,7 +89,7 @@
- #ifdef CONFIG_FTRACE_MCOUNT_RECORD
- #define MCOUNT_REC()	. = ALIGN(8);				\
- 			VMLINUX_SYMBOL(__start_mcount_loc) = .; \
--			*(__mcount_loc)				\
-+			KEEP(*(__mcount_loc))			\
- 			VMLINUX_SYMBOL(__stop_mcount_loc) = .;
- #else
- #define MCOUNT_REC()
-@@ -97,7 +97,7 @@
- 
- #ifdef CONFIG_TRACE_BRANCH_PROFILING
- #define LIKELY_PROFILE()	VMLINUX_SYMBOL(__start_annotated_branch_profile) = .; \
--				*(_ftrace_annotated_branch)			      \
-+				KEEP(*(_ftrace_annotated_branch))		      \
- 				VMLINUX_SYMBOL(__stop_annotated_branch_profile) = .;
- #else
- #define LIKELY_PROFILE()
-@@ -105,7 +105,7 @@
- 
- #ifdef CONFIG_PROFILE_ALL_BRANCHES
- #define BRANCH_PROFILE()	VMLINUX_SYMBOL(__start_branch_profile) = .;   \
--				*(_ftrace_branch)			      \
-+				KEEP(*(_ftrace_branch))			      \
- 				VMLINUX_SYMBOL(__stop_branch_profile) = .;
- #else
- #define BRANCH_PROFILE()
-@@ -114,7 +114,7 @@
- #ifdef CONFIG_KPROBES
- #define KPROBE_BLACKLIST()	. = ALIGN(8);				      \
- 				VMLINUX_SYMBOL(__start_kprobe_blacklist) = .; \
--				*(_kprobe_blacklist)			      \
-+				KEEP(*(_kprobe_blacklist))		      \
- 				VMLINUX_SYMBOL(__stop_kprobe_blacklist) = .;
- #else
- #define KPROBE_BLACKLIST()
-@@ -123,7 +123,7 @@
- #ifdef CONFIG_EVENT_TRACING
- #define FTRACE_EVENTS()	. = ALIGN(8);					\
- 			VMLINUX_SYMBOL(__start_ftrace_events) = .;	\
--			*(_ftrace_events)				\
-+			KEEP(*(_ftrace_events))				\
- 			VMLINUX_SYMBOL(__stop_ftrace_events) = .;
- #else
- #define FTRACE_EVENTS()
-@@ -131,7 +131,7 @@
- 
- #ifdef CONFIG_TRACING
- #define TRACE_PRINTKS() VMLINUX_SYMBOL(__start___trace_bprintk_fmt) = .;      \
--			 *(__trace_printk_fmt) /* Trace_printk fmt' pointer */ \
-+			 KEEP(*(__trace_printk_fmt)) /* Trace_printk fmt' pointer */ \
- 			 VMLINUX_SYMBOL(__stop___trace_bprintk_fmt) = .;
- #define TRACEPOINT_STR() VMLINUX_SYMBOL(__start___tracepoint_str) = .;	\
- 			 *(__tracepoint_str) /* Trace_printk fmt' pointer */ \
-@@ -144,7 +144,7 @@
- #ifdef CONFIG_FTRACE_SYSCALLS
- #define TRACE_SYSCALLS() . = ALIGN(8);					\
- 			 VMLINUX_SYMBOL(__start_syscalls_metadata) = .;	\
--			 *(__syscalls_metadata)				\
-+			 KEEP(*(__syscalls_metadata))			\
- 			 VMLINUX_SYMBOL(__stop_syscalls_metadata) = .;
- #else
- #define TRACE_SYSCALLS()
-@@ -158,8 +158,8 @@
- #define _OF_TABLE_1(name)						\
- 	. = ALIGN(8);							\
- 	VMLINUX_SYMBOL(__##name##_of_table) = .;			\
--	*(__##name##_of_table)						\
--	*(__##name##_of_table_end)
-+	KEEP(*(__##name##_of_table))					\
-+	KEEP(*(__##name##_of_table_end))
- 
- #define CLKSRC_OF_TABLES()	OF_TABLE(CONFIG_CLKSRC_OF, clksrc)
- #define IRQCHIP_OF_MATCH_TABLE() OF_TABLE(CONFIG_IRQCHIP, irqchip)
-@@ -171,7 +171,7 @@
- #define KERNEL_DTB()							\
- 	STRUCT_ALIGN();							\
- 	VMLINUX_SYMBOL(__dtb_start) = .;				\
--	*(.dtb.init.rodata)						\
-+	KEEP(*(.dtb.init.rodata))					\
- 	VMLINUX_SYMBOL(__dtb_end) = .;
- 
- /* .data section */
-@@ -187,16 +187,17 @@
- 	/* implement dynamic printk debug */				\
- 	. = ALIGN(8);                                                   \
- 	VMLINUX_SYMBOL(__start___jump_table) = .;                       \
--	*(__jump_table)                                                 \
-+	KEEP(*(__jump_table))                                           \
- 	VMLINUX_SYMBOL(__stop___jump_table) = .;                        \
- 	. = ALIGN(8);							\
- 	VMLINUX_SYMBOL(__start___verbose) = .;                          \
--	*(__verbose)                                                    \
-+	KEEP(*(__verbose))                                              \
- 	VMLINUX_SYMBOL(__stop___verbose) = .;				\
- 	LIKELY_PROFILE()		       				\
- 	BRANCH_PROFILE()						\
- 	TRACE_PRINTKS()							\
--	TRACEPOINT_STR()
-+	TRACEPOINT_STR()                                                \
-+	*(.data.[a-zA-Z_]*)
- 
- /*
-  * Data section helpers
-@@ -250,35 +251,35 @@
- 	/* PCI quirks */						\
- 	.pci_fixup        : AT(ADDR(.pci_fixup) - LOAD_OFFSET) {	\
- 		VMLINUX_SYMBOL(__start_pci_fixups_early) = .;		\
--		*(.pci_fixup_early)					\
-+		KEEP(*(.pci_fixup_early))				\
- 		VMLINUX_SYMBOL(__end_pci_fixups_early) = .;		\
- 		VMLINUX_SYMBOL(__start_pci_fixups_header) = .;		\
--		*(.pci_fixup_header)					\
-+		KEEP(*(.pci_fixup_header))				\
- 		VMLINUX_SYMBOL(__end_pci_fixups_header) = .;		\
- 		VMLINUX_SYMBOL(__start_pci_fixups_final) = .;		\
--		*(.pci_fixup_final)					\
-+		KEEP(*(.pci_fixup_final))				\
- 		VMLINUX_SYMBOL(__end_pci_fixups_final) = .;		\
- 		VMLINUX_SYMBOL(__start_pci_fixups_enable) = .;		\
--		*(.pci_fixup_enable)					\
-+		KEEP(*(.pci_fixup_enable))				\
- 		VMLINUX_SYMBOL(__end_pci_fixups_enable) = .;		\
- 		VMLINUX_SYMBOL(__start_pci_fixups_resume) = .;		\
--		*(.pci_fixup_resume)					\
-+		KEEP(*(.pci_fixup_resume))				\
- 		VMLINUX_SYMBOL(__end_pci_fixups_resume) = .;		\
- 		VMLINUX_SYMBOL(__start_pci_fixups_resume_early) = .;	\
--		*(.pci_fixup_resume_early)				\
-+		KEEP(*(.pci_fixup_resume_early))			\
- 		VMLINUX_SYMBOL(__end_pci_fixups_resume_early) = .;	\
- 		VMLINUX_SYMBOL(__start_pci_fixups_suspend) = .;		\
--		*(.pci_fixup_suspend)					\
-+		KEEP(*(.pci_fixup_suspend))				\
- 		VMLINUX_SYMBOL(__end_pci_fixups_suspend) = .;		\
- 		VMLINUX_SYMBOL(__start_pci_fixups_suspend_late) = .;	\
--		*(.pci_fixup_suspend_late)				\
-+		KEEP(*(.pci_fixup_suspend_late))			\
- 		VMLINUX_SYMBOL(__end_pci_fixups_suspend_late) = .;	\
- 	}								\
- 									\
- 	/* Built-in firmware blobs */					\
- 	.builtin_fw        : AT(ADDR(.builtin_fw) - LOAD_OFFSET) {	\
- 		VMLINUX_SYMBOL(__start_builtin_fw) = .;			\
--		*(.builtin_fw)						\
-+		KEEP(*(.builtin_fw))					\
- 		VMLINUX_SYMBOL(__end_builtin_fw) = .;			\
- 	}								\
- 									\
-@@ -287,49 +288,49 @@
- 	/* Kernel symbol table: Normal symbols */			\
- 	__ksymtab         : AT(ADDR(__ksymtab) - LOAD_OFFSET) {		\
- 		VMLINUX_SYMBOL(__start___ksymtab) = .;			\
--		*(SORT(___ksymtab+*))					\
-+		KEEP(*(SORT(___ksymtab+*)))				\
- 		VMLINUX_SYMBOL(__stop___ksymtab) = .;			\
- 	}								\
- 									\
- 	/* Kernel symbol table: GPL-only symbols */			\
- 	__ksymtab_gpl     : AT(ADDR(__ksymtab_gpl) - LOAD_OFFSET) {	\
- 		VMLINUX_SYMBOL(__start___ksymtab_gpl) = .;		\
--		*(SORT(___ksymtab_gpl+*))				\
-+		KEEP(*(SORT(___ksymtab_gpl+*)))				\
- 		VMLINUX_SYMBOL(__stop___ksymtab_gpl) = .;		\
- 	}								\
- 									\
- 	/* Kernel symbol table: Normal unused symbols */		\
- 	__ksymtab_unused  : AT(ADDR(__ksymtab_unused) - LOAD_OFFSET) {	\
- 		VMLINUX_SYMBOL(__start___ksymtab_unused) = .;		\
--		*(SORT(___ksymtab_unused+*))				\
-+		KEEP(*(SORT(___ksymtab_unused+*)))			\
- 		VMLINUX_SYMBOL(__stop___ksymtab_unused) = .;		\
- 	}								\
- 									\
- 	/* Kernel symbol table: GPL-only unused symbols */		\
- 	__ksymtab_unused_gpl : AT(ADDR(__ksymtab_unused_gpl) - LOAD_OFFSET) { \
- 		VMLINUX_SYMBOL(__start___ksymtab_unused_gpl) = .;	\
--		*(SORT(___ksymtab_unused_gpl+*))			\
-+		KEEP(*(SORT(___ksymtab_unused_gpl+*)))			\
- 		VMLINUX_SYMBOL(__stop___ksymtab_unused_gpl) = .;	\
- 	}								\
- 									\
- 	/* Kernel symbol table: GPL-future-only symbols */		\
- 	__ksymtab_gpl_future : AT(ADDR(__ksymtab_gpl_future) - LOAD_OFFSET) { \
- 		VMLINUX_SYMBOL(__start___ksymtab_gpl_future) = .;	\
--		*(SORT(___ksymtab_gpl_future+*))			\
-+		KEEP(*(SORT(___ksymtab_gpl_future+*)))			\
- 		VMLINUX_SYMBOL(__stop___ksymtab_gpl_future) = .;	\
- 	}								\
- 									\
- 	/* Kernel symbol table: Normal symbols */			\
- 	__kcrctab         : AT(ADDR(__kcrctab) - LOAD_OFFSET) {		\
- 		VMLINUX_SYMBOL(__start___kcrctab) = .;			\
--		*(SORT(___kcrctab+*))					\
-+		KEEP(*(SORT(___kcrctab+*)))				\
- 		VMLINUX_SYMBOL(__stop___kcrctab) = .;			\
- 	}								\
- 									\
- 	/* Kernel symbol table: GPL-only symbols */			\
- 	__kcrctab_gpl     : AT(ADDR(__kcrctab_gpl) - LOAD_OFFSET) {	\
- 		VMLINUX_SYMBOL(__start___kcrctab_gpl) = .;		\
--		*(SORT(___kcrctab_gpl+*))				\
-+		KEEP(*(SORT(___kcrctab_gpl+*)))				\
- 		VMLINUX_SYMBOL(__stop___kcrctab_gpl) = .;		\
- 	}								\
- 									\
-@@ -343,14 +344,14 @@
- 	/* Kernel symbol table: GPL-only unused symbols */		\
- 	__kcrctab_unused_gpl : AT(ADDR(__kcrctab_unused_gpl) - LOAD_OFFSET) { \
- 		VMLINUX_SYMBOL(__start___kcrctab_unused_gpl) = .;	\
--		*(SORT(___kcrctab_unused_gpl+*))			\
-+		KEEP(*(SORT(___kcrctab_unused_gpl+*)))			\
- 		VMLINUX_SYMBOL(__stop___kcrctab_unused_gpl) = .;	\
- 	}								\
- 									\
- 	/* Kernel symbol table: GPL-future-only symbols */		\
- 	__kcrctab_gpl_future : AT(ADDR(__kcrctab_gpl_future) - LOAD_OFFSET) { \
- 		VMLINUX_SYMBOL(__start___kcrctab_gpl_future) = .;	\
--		*(SORT(___kcrctab_gpl_future+*))			\
-+		KEEP(*(SORT(___kcrctab_gpl_future+*)))			\
- 		VMLINUX_SYMBOL(__stop___kcrctab_gpl_future) = .;	\
- 	}								\
- 									\
-@@ -369,14 +370,14 @@
- 	/* Built-in module parameters. */				\
- 	__param : AT(ADDR(__param) - LOAD_OFFSET) {			\
- 		VMLINUX_SYMBOL(__start___param) = .;			\
--		*(__param)						\
-+		KEEP(*(__param))					\
- 		VMLINUX_SYMBOL(__stop___param) = .;			\
- 	}								\
- 									\
- 	/* Built-in module versions. */					\
- 	__modver : AT(ADDR(__modver) - LOAD_OFFSET) {			\
- 		VMLINUX_SYMBOL(__start___modver) = .;			\
--		*(__modver)						\
-+		KEEP(*(__modver))					\
- 		VMLINUX_SYMBOL(__stop___modver) = .;			\
- 		. = ALIGN((align));					\
- 		VMLINUX_SYMBOL(__end_rodata) = .;			\
-@@ -432,7 +433,7 @@
- #define ENTRY_TEXT							\
- 		ALIGN_FUNCTION();					\
- 		VMLINUX_SYMBOL(__entry_text_start) = .;			\
--		*(.entry.text)						\
-+		KEEP(*(.entry.text))					\
- 		VMLINUX_SYMBOL(__entry_text_end) = .;
- 
- #ifdef CONFIG_FUNCTION_GRAPH_TRACER
-@@ -460,7 +461,7 @@
- 	. = ALIGN(align);						\
- 	__ex_table : AT(ADDR(__ex_table) - LOAD_OFFSET) {		\
- 		VMLINUX_SYMBOL(__start___ex_table) = .;			\
--		*(__ex_table)						\
-+		KEEP(*(__ex_table))						\
- 		VMLINUX_SYMBOL(__stop___ex_table) = .;			\
- 	}
- 
-@@ -476,8 +477,8 @@
- #ifdef CONFIG_CONSTRUCTORS
- #define KERNEL_CTORS()	. = ALIGN(8);			   \
- 			VMLINUX_SYMBOL(__ctors_start) = .; \
--			*(.ctors)			   \
--			*(.init_array)			   \
-+			KEEP(*(.ctors))			   \
-+			KEEP(*(.init_array))		   \
- 			VMLINUX_SYMBOL(__ctors_end) = .;
- #else
- #define KERNEL_CTORS()
-@@ -525,7 +526,7 @@
- #define SBSS(sbss_align)						\
- 	. = ALIGN(sbss_align);						\
- 	.sbss : AT(ADDR(.sbss) - LOAD_OFFSET) {				\
--		*(.sbss)						\
-+		*(.sbss .sbss.*)					\
- 		*(.scommon)						\
- 	}
- 
-@@ -543,7 +544,7 @@
- 		BSS_FIRST_SECTIONS					\
- 		*(.bss..page_aligned)					\
- 		*(.dynbss)						\
--		*(.bss)							\
-+		*(.bss .bss.*)						\
- 		*(COMMON)						\
- 	}
- 
-@@ -592,7 +593,7 @@
- 	. = ALIGN(8);							\
- 	__bug_table : AT(ADDR(__bug_table) - LOAD_OFFSET) {		\
- 		VMLINUX_SYMBOL(__start___bug_table) = .;		\
--		*(__bug_table)						\
-+		KEEP(*(__bug_table))					\
- 		VMLINUX_SYMBOL(__stop___bug_table) = .;			\
- 	}
- #else
-@@ -604,7 +605,7 @@
- 	. = ALIGN(4);							\
- 	.tracedata : AT(ADDR(.tracedata) - LOAD_OFFSET) {		\
- 		VMLINUX_SYMBOL(__tracedata_start) = .;			\
--		*(.tracedata)						\
-+		KEEP(*(.tracedata))					\
- 		VMLINUX_SYMBOL(__tracedata_end) = .;			\
- 	}
- #else
-@@ -621,17 +622,17 @@
- #define INIT_SETUP(initsetup_align)					\
- 		. = ALIGN(initsetup_align);				\
- 		VMLINUX_SYMBOL(__setup_start) = .;			\
--		*(.init.setup)						\
-+		KEEP(*(.init.setup))					\
- 		VMLINUX_SYMBOL(__setup_end) = .;
- 
- #define INIT_CALLS_LEVEL(level)						\
- 		VMLINUX_SYMBOL(__initcall##level##_start) = .;		\
--		*(.initcall##level##.init)				\
--		*(.initcall##level##s.init)				\
-+		KEEP(*(.initcall##level##.init))			\
-+		KEEP(*(.initcall##level##s.init))			\
- 
- #define INIT_CALLS							\
- 		VMLINUX_SYMBOL(__initcall_start) = .;			\
--		*(.initcallearly.init)					\
-+		KEEP(*(.initcallearly.init))				\
- 		INIT_CALLS_LEVEL(0)					\
- 		INIT_CALLS_LEVEL(1)					\
- 		INIT_CALLS_LEVEL(2)					\
-@@ -645,21 +646,21 @@
- 
- #define CON_INITCALL							\
- 		VMLINUX_SYMBOL(__con_initcall_start) = .;		\
--		*(.con_initcall.init)					\
-+		KEEP(*(.con_initcall.init))				\
- 		VMLINUX_SYMBOL(__con_initcall_end) = .;
- 
- #define SECURITY_INITCALL						\
- 		VMLINUX_SYMBOL(__security_initcall_start) = .;		\
--		*(.security_initcall.init)				\
-+		KEEP(*(.security_initcall.init))			\
- 		VMLINUX_SYMBOL(__security_initcall_end) = .;
- 
- #ifdef CONFIG_BLK_DEV_INITRD
- #define INIT_RAM_FS							\
- 	. = ALIGN(4);							\
- 	VMLINUX_SYMBOL(__initramfs_start) = .;				\
--	*(.init.ramfs)							\
-+	KEEP(*(.init.ramfs))						\
- 	. = ALIGN(8);							\
--	*(.init.ramfs.info)
-+	KEEP(*(.init.ramfs.info))
- #else
- #define INIT_RAM_FS
- #endif
---- a/arch/arm/Makefile
-+++ b/arch/arm/Makefile
-@@ -18,11 +18,16 @@ ifeq ($(CONFIG_CPU_ENDIAN_BE8),y)
- LDFLAGS_vmlinux	+= --be8
- LDFLAGS_MODULE	+= --be8
- endif
-+LDFLAGS_vmlinux += --gc-sections
- 
- OBJCOPYFLAGS	:=-O binary -R .comment -S
- GZFLAGS		:=-9
- #KBUILD_CFLAGS	+=-pipe
- 
-+ifndef CONFIG_FUNCTION_TRACER
-+KBUILD_CFLAGS_KERNEL += -ffunction-sections -fdata-sections
-+endif
-+
- # Never generate .eh_frame
- KBUILD_CFLAGS	+= $(call cc-option,-fno-dwarf2-cfi-asm)
- 
---- a/arch/arm/kernel/vmlinux.lds.S
-+++ b/arch/arm/kernel/vmlinux.lds.S
-@@ -12,13 +12,13 @@
- #define PROC_INFO							\
- 	. = ALIGN(4);							\
- 	VMLINUX_SYMBOL(__proc_info_begin) = .;				\
--	*(.proc.info.init)						\
-+	KEEP(*(.proc.info.init))					\
- 	VMLINUX_SYMBOL(__proc_info_end) = .;
- 
- #define IDMAP_TEXT							\
- 	ALIGN_FUNCTION();						\
- 	VMLINUX_SYMBOL(__idmap_text_start) = .;				\
--	*(.idmap.text)							\
-+	KEEP(*(.idmap.text))						\
- 	VMLINUX_SYMBOL(__idmap_text_end) = .;				\
- 	. = ALIGN(32);							\
- 	VMLINUX_SYMBOL(__hyp_idmap_text_start) = .;			\
-@@ -93,7 +93,7 @@ SECTIONS
- 	.text : {			/* Real text segment		*/
- 		_stext = .;		/* Text and read-only data	*/
- 			__exception_text_start = .;
--			*(.exception.text)
-+			KEEP(*(.exception.text))
- 			__exception_text_end = .;
- 			IRQENTRY_TEXT
- 			TEXT_TEXT
-@@ -118,7 +118,7 @@ SECTIONS
- 	__ex_table : AT(ADDR(__ex_table) - LOAD_OFFSET) {
- 		__start___ex_table = .;
- #ifdef CONFIG_MMU
--		*(__ex_table)
-+		KEEP(*(__ex_table))
- #endif
- 		__stop___ex_table = .;
- 	}
-@@ -130,12 +130,12 @@ SECTIONS
- 	. = ALIGN(8);
- 	.ARM.unwind_idx : {
- 		__start_unwind_idx = .;
--		*(.ARM.exidx*)
-+		KEEP(*(.ARM.exidx*))
- 		__stop_unwind_idx = .;
- 	}
- 	.ARM.unwind_tab : {
- 		__start_unwind_tab = .;
--		*(.ARM.extab*)
-+		KEEP(*(.ARM.extab*))
- 		__stop_unwind_tab = .;
- 	}
- #endif
-@@ -154,14 +154,14 @@ SECTIONS
- 	 */
- 	__vectors_start = .;
- 	.vectors 0 : AT(__vectors_start) {
--		*(.vectors)
-+		KEEP(*(.vectors))
- 	}
- 	. = __vectors_start + SIZEOF(.vectors);
- 	__vectors_end = .;
- 
- 	__stubs_start = .;
- 	.stubs 0x1000 : AT(__stubs_start) {
--		*(.stubs)
-+		KEEP(*(.stubs))
- 	}
- 	. = __stubs_start + SIZEOF(.stubs);
- 	__stubs_end = .;
-@@ -175,24 +175,24 @@ SECTIONS
- 	}
- 	.init.arch.info : {
- 		__arch_info_begin = .;
--		*(.arch.info.init)
-+		KEEP(*(.arch.info.init))
- 		__arch_info_end = .;
- 	}
- 	.init.tagtable : {
- 		__tagtable_begin = .;
--		*(.taglist.init)
-+		KEEP(*(.taglist.init))
- 		__tagtable_end = .;
- 	}
- #ifdef CONFIG_SMP_ON_UP
- 	.init.smpalt : {
- 		__smpalt_begin = .;
--		*(.alt.smp.init)
-+		KEEP(*(.alt.smp.init))
- 		__smpalt_end = .;
- 	}
- #endif
- 	.init.pv_table : {
- 		__pv_table_begin = .;
--		*(.pv_table)
-+		KEEP(*(.pv_table))
- 		__pv_table_end = .;
- 	}
- 	.init.data : {
---- a/arch/arm/boot/compressed/Makefile
-+++ b/arch/arm/boot/compressed/Makefile
-@@ -122,6 +122,7 @@ ifeq ($(CONFIG_FUNCTION_TRACER),y)
- ORIG_CFLAGS := $(KBUILD_CFLAGS)
- KBUILD_CFLAGS = $(subst -pg, , $(ORIG_CFLAGS))
- endif
-+KBUILD_CFLAGS_KERNEL := $(patsubst -f%-sections,,$(KBUILD_CFLAGS_KERNEL))
- 
- ccflags-y := -fpic -mno-single-pic-base -fno-builtin -I$(obj)
- asflags-y := -DZIMAGE
--- a/target/linux/generic/pending-3.18/221-module_exports.patch	2022-03-22 08:54:47.292464811 +0800
+++ b/target/linux/generic/pending-3.18/221-module_exports.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,88 +0,0 @@
---- a/include/asm-generic/vmlinux.lds.h
-+++ b/include/asm-generic/vmlinux.lds.h
-@@ -54,6 +54,16 @@
- #define LOAD_OFFSET 0
- #endif
- 
-+#ifndef SYMTAB_KEEP
-+#define SYMTAB_KEEP KEEP(*(SORT(___ksymtab+*)))
-+#define SYMTAB_KEEP_GPL KEEP(*(SORT(___ksymtab_gpl+*)))
-+#endif
-+
-+#ifndef SYMTAB_DISCARD
-+#define SYMTAB_DISCARD
-+#define SYMTAB_DISCARD_GPL
-+#endif
-+
- #include <linux/export.h>
- 
- /* Align . to a 8 byte boundary equals to maximum function alignment. */
-@@ -288,14 +298,14 @@
- 	/* Kernel symbol table: Normal symbols */			\
- 	__ksymtab         : AT(ADDR(__ksymtab) - LOAD_OFFSET) {		\
- 		VMLINUX_SYMBOL(__start___ksymtab) = .;			\
--		KEEP(*(SORT(___ksymtab+*)))				\
-+		SYMTAB_KEEP						\
- 		VMLINUX_SYMBOL(__stop___ksymtab) = .;			\
- 	}								\
- 									\
- 	/* Kernel symbol table: GPL-only symbols */			\
- 	__ksymtab_gpl     : AT(ADDR(__ksymtab_gpl) - LOAD_OFFSET) {	\
- 		VMLINUX_SYMBOL(__start___ksymtab_gpl) = .;		\
--		KEEP(*(SORT(___ksymtab_gpl+*)))				\
-+		SYMTAB_KEEP_GPL						\
- 		VMLINUX_SYMBOL(__stop___ksymtab_gpl) = .;		\
- 	}								\
- 									\
-@@ -357,7 +367,7 @@
- 									\
- 	/* Kernel symbol table: strings */				\
-         __ksymtab_strings : AT(ADDR(__ksymtab_strings) - LOAD_OFFSET) {	\
--		*(__ksymtab_strings)					\
-+		*(__ksymtab_strings+*)					\
- 	}								\
- 									\
- 	/* __*init sections */						\
-@@ -679,6 +689,8 @@
- 	EXIT_TEXT							\
- 	EXIT_DATA							\
- 	EXIT_CALL							\
-+	SYMTAB_DISCARD							\
-+	SYMTAB_DISCARD_GPL						\
- 	*(.discard)							\
- 	*(.discard.*)							\
- 	}
---- a/scripts/Makefile.build
-+++ b/scripts/Makefile.build
-@@ -298,7 +298,7 @@ targets += $(extra-y) $(MAKECMDGOALS) $(
- # Linker scripts preprocessor (.lds.S -> .lds)
- # ---------------------------------------------------------------------------
- quiet_cmd_cpp_lds_S = LDS     $@
--      cmd_cpp_lds_S = $(CPP) $(cpp_flags) -P -C -U$(ARCH) \
-+      cmd_cpp_lds_S = $(CPP) $(EXTRA_LDSFLAGS) $(cpp_flags) -P -C -U$(ARCH) \
- 	                     -D__ASSEMBLY__ -DLINKER_SCRIPT -o $@ $<
- 
- $(obj)/%.lds: $(src)/%.lds.S FORCE
---- a/include/linux/export.h
-+++ b/include/linux/export.h
-@@ -52,12 +52,19 @@ extern struct module __this_module;
- #define __CRC_SYMBOL(sym, sec)
- #endif
- 
-+#ifdef MODULE
-+#define __EXPORT_SUFFIX(sym)
-+#else
-+#define __EXPORT_SUFFIX(sym) "+" #sym
-+#endif
-+
- /* For every exported symbol, place a struct in the __ksymtab section */
- #define __EXPORT_SYMBOL(sym, sec)				\
- 	extern typeof(sym) sym;					\
- 	__CRC_SYMBOL(sym, sec)					\
- 	static const char __kstrtab_##sym[]			\
--	__attribute__((section("__ksymtab_strings"), aligned(1))) \
-+	__attribute__((section("__ksymtab_strings"		\
-+	  __EXPORT_SUFFIX(sym)), aligned(1)))			\
- 	= VMLINUX_SYMBOL_STR(sym);				\
- 	extern const struct kernel_symbol __ksymtab_##sym;	\
- 	__visible const struct kernel_symbol __ksymtab_##sym	\
--- a/target/linux/generic/pending-3.18/230-openwrt_lzma_options.patch	2022-03-22 08:54:47.293464813 +0800
+++ b/target/linux/generic/pending-3.18/230-openwrt_lzma_options.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,58 +0,0 @@
---- a/scripts/Makefile.lib
-+++ b/scripts/Makefile.lib
-@@ -325,7 +325,7 @@ cmd_bzip2 = (cat $(filter-out FORCE,$^)
- 
- quiet_cmd_lzma = LZMA    $@
- cmd_lzma = (cat $(filter-out FORCE,$^) | \
--	lzma -9 && $(call size_append, $(filter-out FORCE,$^))) > $@ || \
-+	lzma e -d20 -lc1 -lp2 -pb2 -eos -si -so && $(call size_append, $(filter-out FORCE,$^))) > $@ || \
- 	(rm -f $@ ; false)
- 
- quiet_cmd_lzo = LZO     $@
---- a/scripts/gen_initramfs_list.sh
-+++ b/scripts/gen_initramfs_list.sh
-@@ -226,7 +226,7 @@ cpio_list=
- output="/dev/stdout"
- output_file=""
- is_cpio_compressed=
--compr="gzip -n -9 -f"
-+compr="gzip -n -9 -f -"
- 
- arg="$1"
- case "$arg" in
-@@ -242,13 +242,13 @@ case "$arg" in
- 		output=${cpio_list}
- 		echo "$output_file" | grep -q "\.gz$" \
-                 && [ -x "`which gzip 2> /dev/null`" ] \
--                && compr="gzip -n -9 -f"
-+                && compr="gzip -n -9 -f -"
- 		echo "$output_file" | grep -q "\.bz2$" \
-                 && [ -x "`which bzip2 2> /dev/null`" ] \
--                && compr="bzip2 -9 -f"
-+                && compr="bzip2 -9 -f -"
- 		echo "$output_file" | grep -q "\.lzma$" \
-                 && [ -x "`which lzma 2> /dev/null`" ] \
--                && compr="lzma -9 -f"
-+                && compr="lzma e -d20 -lc1 -lp2 -pb2 -eos -si -so"
- 		echo "$output_file" | grep -q "\.xz$" \
-                 && [ -x "`which xz 2> /dev/null`" ] \
-                 && compr="xz --check=crc32 --lzma2=dict=1MiB"
-@@ -315,7 +315,7 @@ if [ ! -z ${output_file} ]; then
- 	if [ "${is_cpio_compressed}" = "compressed" ]; then
- 		cat ${cpio_tfile} > ${output_file}
- 	else
--		(cat ${cpio_tfile} | ${compr}  - > ${output_file}) \
-+		(cat ${cpio_tfile} | ${compr} > ${output_file}) \
- 		|| (rm -f ${output_file} ; false)
- 	fi
- 	[ -z ${cpio_file} ] && rm ${cpio_tfile}
---- a/lib/decompress.c
-+++ b/lib/decompress.c
-@@ -48,6 +48,7 @@ static const struct compress_format comp
- 	{ {037, 0236}, "gzip", gunzip },
- 	{ {0x42, 0x5a}, "bzip2", bunzip2 },
- 	{ {0x5d, 0x00}, "lzma", unlzma },
-+	{ {0x6d, 0x00}, "lzma-openwrt", unlzma },
- 	{ {0xfd, 0x37}, "xz", unxz },
- 	{ {0x89, 0x4c}, "lzo", unlzo },
- 	{ {0x02, 0x21}, "lz4", unlz4 },
--- a/target/linux/generic/pending-3.18/250-netfilter_depends.patch	2022-03-22 08:54:47.293464813 +0800
+++ b/target/linux/generic/pending-3.18/250-netfilter_depends.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,18 +0,0 @@
---- a/net/netfilter/Kconfig
-+++ b/net/netfilter/Kconfig
-@@ -210,7 +210,6 @@ config NF_CONNTRACK_FTP
- 
- config NF_CONNTRACK_H323
- 	tristate "H.323 protocol support"
--	depends on (IPV6 || IPV6=n)
- 	depends on NETFILTER_ADVANCED
- 	help
- 	  H.323 is a VoIP signalling protocol from ITU-T. As one of the most
-@@ -907,7 +906,6 @@ config NETFILTER_XT_TARGET_SECMARK
- 
- config NETFILTER_XT_TARGET_TCPMSS
- 	tristate '"TCPMSS" target support'
--	depends on (IPV6 || IPV6=n)
- 	default m if NETFILTER_ADVANCED=n
- 	---help---
- 	  This option adds a `TCPMSS' target, which allows you to alter the
--- a/target/linux/generic/pending-3.18/251-sound_kconfig.patch	2022-03-22 08:54:47.293464813 +0800
+++ b/target/linux/generic/pending-3.18/251-sound_kconfig.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,18 +0,0 @@
---- a/sound/core/Kconfig
-+++ b/sound/core/Kconfig
-@@ -10,13 +10,13 @@ config SND_DMAENGINE_PCM
- 	tristate
- 
- config SND_HWDEP
--	tristate
-+	tristate "Sound hardware support"
- 
- config SND_RAWMIDI
- 	tristate
- 
- config SND_COMPRESS_OFFLOAD
--	tristate
-+	tristate "Compression offloading support"
- 
- # To be effective this also requires INPUT - users should say:
- #    select SND_JACK if INPUT=y || INPUT=SND
--- a/target/linux/generic/pending-3.18/252-mv_cesa_depends.patch	2022-03-22 08:54:47.293464813 +0800
+++ b/target/linux/generic/pending-3.18/252-mv_cesa_depends.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,10 +0,0 @@
---- a/drivers/crypto/Kconfig
-+++ b/drivers/crypto/Kconfig
-@@ -164,6 +164,7 @@ config CRYPTO_DEV_MV_CESA
- 	depends on PLAT_ORION
- 	select CRYPTO_ALGAPI
- 	select CRYPTO_AES
-+	select CRYPTO_HASH2
- 	select CRYPTO_BLKCIPHER2
- 	select CRYPTO_HASH
- 	help
--- a/target/linux/generic/pending-3.18/253-ssb_b43_default_on.patch	2022-03-22 08:54:47.294464814 +0800
+++ b/target/linux/generic/pending-3.18/253-ssb_b43_default_on.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,29 +0,0 @@
---- a/drivers/ssb/Kconfig
-+++ b/drivers/ssb/Kconfig
-@@ -29,6 +29,7 @@ config SSB_SPROM
- config SSB_BLOCKIO
- 	bool
- 	depends on SSB
-+	default y
- 
- config SSB_PCIHOST_POSSIBLE
- 	bool
-@@ -49,7 +50,7 @@ config SSB_PCIHOST
- config SSB_B43_PCI_BRIDGE
- 	bool
- 	depends on SSB_PCIHOST
--	default n
-+	default y
- 
- config SSB_PCMCIAHOST_POSSIBLE
- 	bool
---- a/drivers/bcma/Kconfig
-+++ b/drivers/bcma/Kconfig
-@@ -17,6 +17,7 @@ config BCMA
- config BCMA_BLOCKIO
- 	bool
- 	depends on BCMA
-+	default y
- 
- config BCMA_HOST_PCI_POSSIBLE
- 	bool
--- a/target/linux/generic/pending-3.18/254-textsearch_kconfig_hacks.patch	2022-03-22 08:54:47.294464814 +0800
+++ b/target/linux/generic/pending-3.18/254-textsearch_kconfig_hacks.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,23 +0,0 @@
---- a/lib/Kconfig
-+++ b/lib/Kconfig
-@@ -320,16 +320,16 @@ config BCH_CONST_T
- # Textsearch support is select'ed if needed
- #
- config TEXTSEARCH
--	boolean
-+	boolean	"Textsearch support"
- 
- config TEXTSEARCH_KMP
--	tristate
-+	tristate "Textsearch KMP"
- 
- config TEXTSEARCH_BM
--	tristate
-+	tristate "Textsearch BM"
- 
- config TEXTSEARCH_FSM
--	tristate
-+	tristate "Textsearch FSM"
- 
- config BTREE
- 	boolean
--- a/target/linux/generic/pending-3.18/255-lib80211_kconfig_hacks.patch	2022-03-22 08:54:47.294464814 +0800
+++ b/target/linux/generic/pending-3.18/255-lib80211_kconfig_hacks.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,31 +0,0 @@
---- a/net/wireless/Kconfig
-+++ b/net/wireless/Kconfig
-@@ -183,7 +183,7 @@ config CFG80211_WEXT
- 	  extensions with cfg80211-based drivers.
- 
- config LIB80211
--	tristate
-+	tristate "LIB80211"
- 	default n
- 	help
- 	  This options enables a library of common routines used
-@@ -192,13 +192,16 @@ config LIB80211
- 	  Drivers should select this themselves if needed.
- 
- config LIB80211_CRYPT_WEP
--	tristate
-+	tristate "LIB80211_CRYPT_WEP"
-+	select LIB80211
- 
- config LIB80211_CRYPT_CCMP
--	tristate
-+	tristate "LIB80211_CRYPT_CCMP"
-+	select LIB80211
- 
- config LIB80211_CRYPT_TKIP
--	tristate
-+	tristate "LIB80211_CRYPT_TKIP"
-+	select LIB80211
- 
- config LIB80211_DEBUG
- 	bool "lib80211 debugging messages"
--- a/target/linux/generic/pending-3.18/256-crypto_add_kconfig_prompts.patch	2022-03-22 08:54:47.295464816 +0800
+++ b/target/linux/generic/pending-3.18/256-crypto_add_kconfig_prompts.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,47 +0,0 @@
---- a/crypto/Kconfig
-+++ b/crypto/Kconfig
-@@ -32,7 +32,7 @@ config CRYPTO_FIPS
- 	  this is.
- 
- config CRYPTO_ALGAPI
--	tristate
-+	tristate "ALGAPI"
- 	select CRYPTO_ALGAPI2
- 	help
- 	  This option provides the API for cryptographic algorithms.
-@@ -41,7 +41,7 @@ config CRYPTO_ALGAPI2
- 	tristate
- 
- config CRYPTO_AEAD
--	tristate
-+	tristate "AEAD"
- 	select CRYPTO_AEAD2
- 	select CRYPTO_ALGAPI
- 
-@@ -50,7 +50,7 @@ config CRYPTO_AEAD2
- 	select CRYPTO_ALGAPI2
- 
- config CRYPTO_BLKCIPHER
--	tristate
-+	tristate "BLKCIPHER"
- 	select CRYPTO_BLKCIPHER2
- 	select CRYPTO_ALGAPI
- 
-@@ -61,7 +61,7 @@ config CRYPTO_BLKCIPHER2
- 	select CRYPTO_WORKQUEUE
- 
- config CRYPTO_HASH
--	tristate
-+	tristate "HASH"
- 	select CRYPTO_HASH2
- 	select CRYPTO_ALGAPI
- 
-@@ -70,7 +70,7 @@ config CRYPTO_HASH2
- 	select CRYPTO_ALGAPI2
- 
- config CRYPTO_RNG
--	tristate
-+	tristate "RNG"
- 	select CRYPTO_RNG2
- 	select CRYPTO_ALGAPI
- 
--- a/target/linux/generic/pending-3.18/257-wireless_ext_kconfig_hack.patch	2022-03-22 08:54:47.295464816 +0800
+++ b/target/linux/generic/pending-3.18/257-wireless_ext_kconfig_hack.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,22 +0,0 @@
---- a/net/wireless/Kconfig
-+++ b/net/wireless/Kconfig
-@@ -1,5 +1,5 @@
- config WIRELESS_EXT
--	bool
-+	bool "Wireless extensions"
- 
- config WEXT_CORE
- 	def_bool y
-@@ -11,10 +11,10 @@ config WEXT_PROC
- 	depends on WEXT_CORE
- 
- config WEXT_SPY
--	bool
-+	bool "WEXT_SPY"
- 
- config WEXT_PRIV
--	bool
-+	bool "WEXT_PRIV"
- 
- config CFG80211
- 	tristate "cfg80211 - wireless configuration API"
--- a/target/linux/generic/pending-3.18/258-netfilter_netlink_kconfig_hack.patch	2022-03-22 08:54:47.295464816 +0800
+++ b/target/linux/generic/pending-3.18/258-netfilter_netlink_kconfig_hack.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,11 +0,0 @@
---- a/net/netfilter/Kconfig
-+++ b/net/netfilter/Kconfig
-@@ -2,7 +2,7 @@ menu "Core Netfilter Configuration"
- 	depends on NET && INET && NETFILTER
- 
- config NETFILTER_NETLINK
--	tristate
-+	tristate "Netfilter NFNETLINK interface"
- 
- config NETFILTER_NETLINK_ACCT
- tristate "Netfilter NFACCT over NFNETLINK interface"
--- a/target/linux/generic/pending-3.18/259-regmap_dynamic.patch	2022-03-22 08:54:47.295464816 +0800
+++ b/target/linux/generic/pending-3.18/259-regmap_dynamic.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,83 +0,0 @@
---- a/drivers/base/regmap/Kconfig
-+++ b/drivers/base/regmap/Kconfig
-@@ -3,9 +3,8 @@
- # subsystems should select the appropriate symbols.
- 
- config REGMAP
--	default y if (REGMAP_I2C || REGMAP_SPI || REGMAP_SPMI || REGMAP_MMIO || REGMAP_IRQ)
- 	select IRQ_DOMAIN if REGMAP_IRQ
--	bool
-+	tristate
- 
- config REGCACHE_COMPRESSED
- 	select LZO_COMPRESS
-@@ -14,18 +13,24 @@ config REGCACHE_COMPRESSED
- 
- config REGMAP_I2C
- 	tristate
-+	select REGMAP
- 	depends on I2C
- 
- config REGMAP_SPI
- 	tristate
-+	select REGMAP
-+	depends on SPI_MASTER
- 	depends on SPI
- 
- config REGMAP_SPMI
-+	select REGMAP
- 	tristate
- 	depends on SPMI
- 
- config REGMAP_MMIO
- 	tristate
-+	select REGMAP
- 
- config REGMAP_IRQ
-+	select REGMAP
- 	bool
---- a/include/linux/regmap.h
-+++ b/include/linux/regmap.h
-@@ -49,7 +49,7 @@ struct reg_default {
- 	unsigned int def;
- };
- 
--#ifdef CONFIG_REGMAP
-+#if IS_ENABLED(CONFIG_REGMAP)
- 
- enum regmap_endian {
- 	/* Unspecified -> 0 -> Backwards compatible default */
---- a/drivers/base/regmap/Makefile
-+++ b/drivers/base/regmap/Makefile
-@@ -1,7 +1,11 @@
--obj-$(CONFIG_REGMAP) += regmap.o regcache.o
--obj-$(CONFIG_REGMAP) += regcache-rbtree.o regcache-flat.o
--obj-$(CONFIG_REGCACHE_COMPRESSED) += regcache-lzo.o
--obj-$(CONFIG_DEBUG_FS) += regmap-debugfs.o
-+regmap-core-objs = regmap.o regcache.o regcache-rbtree.o regcache-flat.o
-+ifdef CONFIG_DEBUG_FS
-+regmap-core-objs += regmap-debugfs.o
-+endif
-+ifdef CONFIG_REGCACHE_COMPRESSED
-+regmap-core-objs += regcache-lzo.o
-+endif
-+obj-$(CONFIG_REGMAP) += regmap-core.o
- obj-$(CONFIG_REGMAP_I2C) += regmap-i2c.o
- obj-$(CONFIG_REGMAP_SPI) += regmap-spi.o
- obj-$(CONFIG_REGMAP_SPMI) += regmap-spmi.o
---- a/drivers/base/regmap/regmap.c
-+++ b/drivers/base/regmap/regmap.c
-@@ -13,6 +13,7 @@
- #include <linux/device.h>
- #include <linux/slab.h>
- #include <linux/export.h>
-+#include <linux/module.h>
- #include <linux/mutex.h>
- #include <linux/err.h>
- #include <linux/of.h>
-@@ -2630,3 +2631,5 @@ static int __init regmap_initcall(void)
- 	return 0;
- }
- postcore_initcall(regmap_initcall);
-+
-+MODULE_LICENSE("GPL");
--- a/target/linux/generic/pending-3.18/260-crypto_test_dependencies.patch	2022-03-22 08:54:47.296464818 +0800
+++ b/target/linux/generic/pending-3.18/260-crypto_test_dependencies.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,37 +0,0 @@
---- a/crypto/Kconfig
-+++ b/crypto/Kconfig
-@@ -96,10 +96,10 @@ config CRYPTO_MANAGER
- 
- config CRYPTO_MANAGER2
- 	def_tristate CRYPTO_MANAGER || (CRYPTO_MANAGER!=n && CRYPTO_ALGAPI=y)
--	select CRYPTO_AEAD2
--	select CRYPTO_HASH2
--	select CRYPTO_BLKCIPHER2
--	select CRYPTO_PCOMP2
-+	select CRYPTO_AEAD2 if !CRYPTO_MANAGER_DISABLE_TESTS
-+	select CRYPTO_HASH2 if !CRYPTO_MANAGER_DISABLE_TESTS
-+	select CRYPTO_BLKCIPHER2 if !CRYPTO_MANAGER_DISABLE_TESTS
-+	select CRYPTO_PCOMP2 if !CRYPTO_MANAGER_DISABLE_TESTS
- 
- config CRYPTO_USER
- 	tristate "Userspace cryptographic algorithm configuration"
---- a/crypto/algboss.c
-+++ b/crypto/algboss.c
-@@ -248,6 +248,9 @@ static int cryptomgr_schedule_test(struc
- 	type = alg->cra_flags;
- 
- 	/* This piece of crap needs to disappear into per-type test hooks. */
-+#ifdef CONFIG_CRYPTO_MANAGER_DISABLE_TESTS
-+	type |= CRYPTO_ALG_TESTED;
-+#else
- 	if ((!((type ^ CRYPTO_ALG_TYPE_BLKCIPHER) &
- 	       CRYPTO_ALG_TYPE_BLKCIPHER_MASK) && !(type & CRYPTO_ALG_GENIV) &&
- 	     ((alg->cra_flags & CRYPTO_ALG_TYPE_MASK) ==
-@@ -256,6 +259,7 @@ static int cryptomgr_schedule_test(struc
- 	    (!((type ^ CRYPTO_ALG_TYPE_AEAD) & CRYPTO_ALG_TYPE_MASK) &&
- 	     alg->cra_type == &crypto_nivaead_type && alg->cra_aead.ivsize))
- 		type |= CRYPTO_ALG_TESTED;
-+#endif
- 
- 	param->type = type;
- 
--- a/target/linux/generic/pending-3.18/270-uapi-libc-compat-add-fallback-for-unsupported-libcs.patch	2022-03-22 08:54:47.296464818 +0800
+++ b/target/linux/generic/pending-3.18/270-uapi-libc-compat-add-fallback-for-unsupported-libcs.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,102 +0,0 @@
-From c6bdd0d302119819de72439972d0462c26ef9eda Mon Sep 17 00:00:00 2001
-From: Felix Janda <felix.janda@posteo.de>
-Date: Sun, 12 Nov 2017 13:30:17 -0500
-Subject: uapi libc compat: add fallback for unsupported libcs
-
-libc-compat.h aims to prevent symbol collisions between uapi and libc
-headers for each supported libc. This requires continuous coordination
-between them.
-
-The goal of this commit is to improve the situation for libcs (such as
-musl) which are not yet supported and/or do not wish to be explicitly
-supported, while not affecting supported libcs. More precisely, with
-this commit, unsupported libcs can request the suppression of any
-specific uapi definition by defining the correspondings _UAPI_DEF_*
-macro as 0. This can fix symbol collisions for them, as long as the
-libc headers are included before the uapi headers. Inclusion in the
-other order is outside the scope of this commit.
-
-All infrastructure in order to enable this fallback for unsupported
-libcs is already in place, except that libc-compat.h unconditionally
-defines all _UAPI_DEF_* macros to 1 for all unsupported libcs so that
-any previous definitions are ignored. In order to fix this, this commit
-merely makes these definitions conditional.
-
-This commit together with the musl libc commit
-
-http://git.musl-libc.org/cgit/musl/commit/?id=04983f2272382af92eb8f8838964ff944fbb8258
-
-fixes for example the following compiler errors when <linux/in6.h> is
-included after musl's <netinet/in.h>:
-
-./linux/in6.h:32:8: error: redefinition of 'struct in6_addr'
-./linux/in6.h:49:8: error: redefinition of 'struct sockaddr_in6'
-./linux/in6.h:59:8: error: redefinition of 'struct ipv6_mreq'
-
-The comments referencing glibc are still correct, but this file is not
-only used for glibc any more.
-
-Signed-off-by: Felix Janda <felix.janda@posteo.de>
-Reviewed-by: Hauke Mehrtens <hauke@hauke-m.de>
----
- include/uapi/linux/libc-compat.h | 55 +++++++++++++++++++++++++++++++++++++++-
- 1 file changed, 54 insertions(+), 1 deletion(-)
-
---- a/include/uapi/linux/libc-compat.h
-+++ b/include/uapi/linux/libc-compat.h
-@@ -110,27 +110,54 @@
- 
- /* If we did not see any headers from any supported C libraries,
-  * or we are being included in the kernel, then define everything
-- * that we need. */
-+ * that we need. Check for previous __UAPI_* definitions to give
-+ * unsupported C libraries a way to opt out of any kernel definition. */
- #else /* !defined(__GLIBC__) */
- 
- /* Definitions for in.h */
-+#ifndef __UAPI_DEF_IN_ADDR
- #define __UAPI_DEF_IN_ADDR		1
-+#endif
-+#ifndef __UAPI_DEF_IN_IPPROTO
- #define __UAPI_DEF_IN_IPPROTO		1
-+#endif
-+#ifndef __UAPI_DEF_IN_PKTINFO
- #define __UAPI_DEF_IN_PKTINFO		1
-+#endif
-+#ifndef __UAPI_DEF_IP_MREQ
- #define __UAPI_DEF_IP_MREQ		1
-+#endif
-+#ifndef __UAPI_DEF_SOCKADDR_IN
- #define __UAPI_DEF_SOCKADDR_IN		1
-+#endif
-+#ifndef __UAPI_DEF_IN_CLASS
- #define __UAPI_DEF_IN_CLASS		1
-+#endif
- 
- /* Definitions for in6.h */
-+#ifndef __UAPI_DEF_IN6_ADDR
- #define __UAPI_DEF_IN6_ADDR		1
-+#endif
-+#ifndef __UAPI_DEF_IN6_ADDR_ALT
- #define __UAPI_DEF_IN6_ADDR_ALT		1
-+#endif
-+#ifndef __UAPI_DEF_SOCKADDR_IN6
- #define __UAPI_DEF_SOCKADDR_IN6		1
-+#endif
-+#ifndef __UAPI_DEF_IPV6_MREQ
- #define __UAPI_DEF_IPV6_MREQ		1
-+#endif
-+#ifndef __UAPI_DEF_IPPROTO_V6
- #define __UAPI_DEF_IPPROTO_V6		1
-+#endif
-+#ifndef __UAPI_DEF_IPV6_OPTIONS
- #define __UAPI_DEF_IPV6_OPTIONS		1
-+#endif
- 
- /* Definitions for xattr.h */
-+#ifndef __UAPI_DEF_XATTR
- #define __UAPI_DEF_XATTR		1
-+#endif
- 
- #endif /* __GLIBC__ */
- 
--- a/target/linux/generic/pending-3.18/272-uapi-if_ether.h-prevent-redefinition-of-struct-ethhd.patch	2022-03-22 08:54:47.296464818 +0800
+++ b/target/linux/generic/pending-3.18/272-uapi-if_ether.h-prevent-redefinition-of-struct-ethhd.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,55 +0,0 @@
-From 649affd04813c43e0a72886517fcfccd63230981 Mon Sep 17 00:00:00 2001
-From: Hauke Mehrtens <hauke@hauke-m.de>
-Date: Mon, 29 Jun 2015 16:53:03 +0200
-Subject: uapi/if_ether.h: prevent redefinition of struct ethhdr
-
-Musl provides its own ethhdr struct definition. Add a guard to prevent
-its definition of the appropriate musl header has already been included.
-
-glibc does not implement this header, but when glibc will implement this
-they can just define __UAPI_DEF_ETHHDR 0 to make it work with the
-kernel.
-
-Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
----
- include/uapi/linux/if_ether.h    | 3 +++
- include/uapi/linux/libc-compat.h | 6 ++++++
- 2 files changed, 9 insertions(+)
-
---- a/include/uapi/linux/if_ether.h
-+++ b/include/uapi/linux/if_ether.h
-@@ -22,6 +22,7 @@
- #define _UAPI_LINUX_IF_ETHER_H
- 
- #include <linux/types.h>
-+#include <linux/libc-compat.h>
- 
- /*
-  *	IEEE 802.3 Ethernet magic constants.  The frame sizes omit the preamble
-@@ -135,11 +136,13 @@
-  *	This is an Ethernet frame header.
-  */
- 
-+#if __UAPI_DEF_ETHHDR
- struct ethhdr {
- 	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
- 	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
- 	__be16		h_proto;		/* packet type ID field	*/
- } __attribute__((packed));
-+#endif
- 
- 
- #endif /* _UAPI_LINUX_IF_ETHER_H */
---- a/include/uapi/linux/libc-compat.h
-+++ b/include/uapi/linux/libc-compat.h
-@@ -161,4 +161,10 @@
- 
- #endif /* __GLIBC__ */
- 
-+/* Definitions for if_ether.h */
-+/* allow libcs like musl to deactivate this, glibc does not implement this. */
-+#ifndef __UAPI_DEF_ETHHDR
-+#define __UAPI_DEF_ETHHDR		1
-+#endif
-+
- #endif /* _UAPI_LIBC_COMPAT_H */
--- a/target/linux/generic/pending-3.18/300-mips_expose_boot_raw.patch	2022-03-22 08:54:47.297464819 +0800
+++ b/target/linux/generic/pending-3.18/300-mips_expose_boot_raw.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,39 +0,0 @@
-From: Mark Miller <mark@mirell.org>
-
-This exposes the CONFIG_BOOT_RAW symbol in Kconfig. This is needed on
-certain Broadcom chipsets running CFE in order to load the kernel.
-
-Signed-off-by: Mark Miller <mark@mirell.org>
-Acked-by: Rob Landley <rob@landley.net>
----
---- a/arch/mips/Kconfig
-+++ b/arch/mips/Kconfig
-@@ -895,9 +895,6 @@ config FW_ARC
- config ARCH_MAY_HAVE_PC_FDC
- 	bool
- 
--config BOOT_RAW
--	bool
--
- config CEVT_BCM1480
- 	bool
- 
-@@ -2506,6 +2503,18 @@ config USE_OF
- config BUILTIN_DTB
- 	bool
- 
-+config BOOT_RAW
-+	bool "Enable the kernel to be executed from the load address"
-+	default n
-+	help
-+	 Allow the kernel to be executed from the load address for
-+	 bootloaders which cannot read the ELF format. This places
-+	 a jump to start_kernel at the load address.
-+
-+	 If unsure, say N.
-+
-+
-+
- endmenu
- 
- config LOCKDEP_SUPPORT
--- a/target/linux/generic/pending-3.18/301-mips_image_cmdline_hack.patch	2022-03-22 08:54:47.297464819 +0800
+++ b/target/linux/generic/pending-3.18/301-mips_image_cmdline_hack.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,28 +0,0 @@
---- a/arch/mips/Kconfig
-+++ b/arch/mips/Kconfig
-@@ -991,6 +991,10 @@ config SYNC_R4K
- config MIPS_MACHINE
- 	def_bool n
- 
-+config IMAGE_CMDLINE_HACK
-+	bool "OpenWrt specific image command line hack"
-+	default n
-+
- config NO_IOPORT_MAP
- 	def_bool n
- 
---- a/arch/mips/kernel/head.S
-+++ b/arch/mips/kernel/head.S
-@@ -80,6 +80,12 @@ FEXPORT(__kernel_entry)
- 	j	kernel_entry
- #endif
- 
-+#ifdef CONFIG_IMAGE_CMDLINE_HACK
-+	.ascii	"CMDLINE:"
-+EXPORT(__image_cmdline)
-+	.fill	0x400
-+#endif /* CONFIG_IMAGE_CMDLINE_HACK */
-+
- 	__REF
- 
- NESTED(kernel_entry, 16, sp)			# kernel entry point
--- a/target/linux/generic/pending-3.18/302-mips_no_branch_likely.patch	2022-03-22 08:54:47.297464819 +0800
+++ b/target/linux/generic/pending-3.18/302-mips_no_branch_likely.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,11 +0,0 @@
---- a/arch/mips/Makefile
-+++ b/arch/mips/Makefile
-@@ -87,7 +87,7 @@ all-$(CONFIG_SYS_SUPPORTS_ZBOOT)+= vmlin
- # machines may also.  Since BFD is incredibly buggy with respect to
- # crossformat linking we rely on the elf2ecoff tool for format conversion.
- #
--cflags-y			+= -G 0 -mno-abicalls -fno-pic -pipe
-+cflags-y			+= -G 0 -mno-abicalls -fno-pic -pipe -mno-branch-likely
- cflags-y			+= -msoft-float
- LDFLAGS_vmlinux			+= -G 0 -static -n -nostdlib --gc-sections
- KBUILD_AFLAGS_MODULE		+= -mlong-calls
--- a/target/linux/generic/pending-3.18/304-mips_disable_fpu.patch	2022-03-22 08:54:47.298464821 +0800
+++ b/target/linux/generic/pending-3.18/304-mips_disable_fpu.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,105 +0,0 @@
-From:   Manuel Lauss <manuel.lauss@gmail.com>
-Subject: [RFC PATCH v4 2/2] MIPS: make FPU emulator optional
-Date:   Mon,  7 Apr 2014 12:57:04 +0200
-Message-Id: <1396868224-252888-2-git-send-email-manuel.lauss@gmail.com>
-
-This small patch makes the MIPS FPU emulator optional. The kernel
-kills float-users on systems without a hardware FPU by sending a SIGILL.
-
-Disabling the emulator shrinks vmlinux by about 54kBytes (32bit,
-optimizing for size).
-
-Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
----
-v4: rediffed because of patch 1/2, should now work with micromips as well
-v3: updated patch description with size savings.
-v2: incorporated changes suggested by Jonas Gorski
-    force the fpu emulator on for micromips: relocating the parts
-    of the mmips code in the emulator to other areas would be a
-    much larger change; I went the cheap route instead with this.
-
- arch/mips/Kbuild                     |  2 +-
- arch/mips/Kconfig                    | 14 ++++++++++++++
- arch/mips/include/asm/fpu.h          |  5 +++--
- arch/mips/include/asm/fpu_emulator.h | 15 +++++++++++++++
- 4 files changed, 33 insertions(+), 3 deletions(-)
-
---- a/arch/mips/Kconfig
-+++ b/arch/mips/Kconfig
-@@ -2498,6 +2498,20 @@ config MIPS_O32_FP64_SUPPORT
- 
- 	  If unsure, say N.
- 
-+config MIPS_FPU_EMULATOR
-+	bool "MIPS FPU Emulator"
-+	default y
-+	help
-+	  This option lets you disable the built-in MIPS FPU (Coprocessor 1)
-+	  emulator, which handles floating-point instructions on processors
-+	  without a hardware FPU.  It is generally a good idea to keep the
-+	  emulator built-in, unless you are perfectly sure you have a
-+	  complete soft-float environment.  With the emulator disabled, all
-+	  users of float operations will be killed with an illegal instr-
-+	  uction exception.
-+
-+	  Say Y, please.
-+
- config USE_OF
- 	bool
- 	select OF
---- a/arch/mips/Makefile
-+++ b/arch/mips/Makefile
-@@ -275,7 +275,7 @@ OBJCOPYFLAGS		+= --remove-section=.regin
- head-y := arch/mips/kernel/head.o
- 
- libs-y			+= arch/mips/lib/
--libs-y			+= arch/mips/math-emu/
-+libs-$(CONFIG_MIPS_FPU_EMULATOR)	+= arch/mips/math-emu/
- 
- # See arch/mips/Kbuild for content of core part of the kernel
- core-y += arch/mips/
---- a/arch/mips/include/asm/fpu.h
-+++ b/arch/mips/include/asm/fpu.h
-@@ -169,8 +169,10 @@ static inline int init_fpu(void)
- 		ret = __own_fpu();
- 		if (!ret)
- 			_init_fpu();
--	} else
-+	} else if (IS_ENABLED(CONFIG_MIPS_FPU_EMULATOR))
- 		fpu_emulator_init_fpu();
-+	else
-+		ret = SIGILL;
- 
- 	return ret;
- }
---- a/arch/mips/include/asm/fpu_emulator.h
-+++ b/arch/mips/include/asm/fpu_emulator.h
-@@ -30,6 +30,7 @@
- #include <asm/local.h>
- #include <asm/processor.h>
- 
-+#ifdef CONFIG_MIPS_FPU_EMULATOR
- #ifdef CONFIG_DEBUG_FS
- 
- struct mips_fpu_emulator_stats {
-@@ -65,6 +66,20 @@ extern int do_dsemulret(struct pt_regs *
- extern int fpu_emulator_cop1Handler(struct pt_regs *xcp,
- 				    struct mips_fpu_struct *ctx, int has_fpu,
- 				    void *__user *fault_addr);
-+#else	/* no CONFIG_MIPS_FPU_EMULATOR */
-+static inline int do_dsemulret(struct pt_regs *xcp)
-+{
-+	return 0;	/* 0 means error, should never get here anyway */
-+}
-+
-+static inline int fpu_emulator_cop1Handler(struct pt_regs *xcp,
-+				struct mips_fpu_struct *ctx, int has_fpu,
-+				void *__user *fault_addr)
-+{
-+	return SIGILL;	/* we don't speak MIPS FPU */
-+}
-+#endif	/* CONFIG_MIPS_FPU_EMULATOR */
-+
- int process_fpemu_return(int sig, void __user *fault_addr);
- int mm_isBranchInstr(struct pt_regs *regs, struct mm_decoded_insn dec_insn,
- 		     unsigned long *contpc);
--- a/target/linux/generic/pending-3.18/305-mips_module_reloc.patch	2022-03-22 08:54:47.298464821 +0800
+++ b/target/linux/generic/pending-3.18/305-mips_module_reloc.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,356 +0,0 @@
---- a/arch/mips/Makefile
-+++ b/arch/mips/Makefile
-@@ -90,8 +90,13 @@ all-$(CONFIG_SYS_SUPPORTS_ZBOOT)+= vmlin
- cflags-y			+= -G 0 -mno-abicalls -fno-pic -pipe -mno-branch-likely
- cflags-y			+= -msoft-float
- LDFLAGS_vmlinux			+= -G 0 -static -n -nostdlib --gc-sections
-+ifdef CONFIG_64BIT
- KBUILD_AFLAGS_MODULE		+= -mlong-calls
- KBUILD_CFLAGS_MODULE		+= -mlong-calls
-+else
-+KBUILD_AFLAGS_MODULE		+= -mno-long-calls
-+KBUILD_CFLAGS_MODULE		+= -mno-long-calls
-+endif
- 
- ifndef CONFIG_FUNCTION_TRACER
- KBUILD_CFLAGS_KERNEL		+= -ffunction-sections -fdata-sections
---- a/arch/mips/include/asm/module.h
-+++ b/arch/mips/include/asm/module.h
-@@ -11,6 +11,11 @@ struct mod_arch_specific {
- 	const struct exception_table_entry *dbe_start;
- 	const struct exception_table_entry *dbe_end;
- 	struct mips_hi16 *r_mips_hi16_list;
-+
-+	void *phys_plt_tbl;
-+	void *virt_plt_tbl;
-+	unsigned int phys_plt_offset;
-+	unsigned int virt_plt_offset;
- };
- 
- typedef uint8_t Elf64_Byte;		/* Type for a 8-bit quantity.  */
---- a/arch/mips/kernel/module.c
-+++ b/arch/mips/kernel/module.c
-@@ -43,14 +43,222 @@ struct mips_hi16 {
- static LIST_HEAD(dbe_list);
- static DEFINE_SPINLOCK(dbe_lock);
- 
--#ifdef MODULE_START
-+/*
-+ * Get the potential max trampolines size required of the init and
-+ * non-init sections. Only used if we cannot find enough contiguous
-+ * physically mapped memory to put the module into.
-+ */
-+static unsigned int
-+get_plt_size(const Elf_Ehdr *hdr, const Elf_Shdr *sechdrs,
-+             const char *secstrings, unsigned int symindex, bool is_init)
-+{
-+	unsigned long ret = 0;
-+	unsigned int i, j;
-+	Elf_Sym *syms;
-+
-+	/* Everything marked ALLOC (this includes the exported symbols) */
-+	for (i = 1; i < hdr->e_shnum; ++i) {
-+		unsigned int info = sechdrs[i].sh_info;
-+
-+		if (sechdrs[i].sh_type != SHT_REL
-+		    && sechdrs[i].sh_type != SHT_RELA)
-+			continue;
-+
-+		/* Not a valid relocation section? */
-+		if (info >= hdr->e_shnum)
-+			continue;
-+
-+		/* Don't bother with non-allocated sections */
-+		if (!(sechdrs[info].sh_flags & SHF_ALLOC))
-+			continue;
-+
-+		/* If it's called *.init*, and we're not init, we're
-+                   not interested */
-+		if ((strstr(secstrings + sechdrs[i].sh_name, ".init") != 0)
-+		    != is_init)
-+			continue;
-+
-+		syms = (Elf_Sym *) sechdrs[symindex].sh_addr;
-+		if (sechdrs[i].sh_type == SHT_REL) {
-+			Elf_Mips_Rel *rel = (void *) sechdrs[i].sh_addr;
-+			unsigned int size = sechdrs[i].sh_size / sizeof(*rel);
-+
-+			for (j = 0; j < size; ++j) {
-+				Elf_Sym *sym;
-+
-+				if (ELF_MIPS_R_TYPE(rel[j]) != R_MIPS_26)
-+					continue;
-+
-+				sym = syms + ELF_MIPS_R_SYM(rel[j]);
-+				if (!is_init && sym->st_shndx != SHN_UNDEF)
-+					continue;
-+
-+				ret += 4 * sizeof(int);
-+			}
-+		} else {
-+			Elf_Mips_Rela *rela = (void *) sechdrs[i].sh_addr;
-+			unsigned int size = sechdrs[i].sh_size / sizeof(*rela);
-+
-+			for (j = 0; j < size; ++j) {
-+				Elf_Sym *sym;
-+
-+				if (ELF_MIPS_R_TYPE(rela[j]) != R_MIPS_26)
-+					continue;
-+
-+				sym = syms + ELF_MIPS_R_SYM(rela[j]);
-+				if (!is_init && sym->st_shndx != SHN_UNDEF)
-+					continue;
-+
-+				ret += 4 * sizeof(int);
-+			}
-+		}
-+	}
-+
-+	return ret;
-+}
-+
-+#ifndef MODULE_START
-+static void *alloc_phys(unsigned long size)
-+{
-+	unsigned order;
-+	struct page *page;
-+	struct page *p;
-+
-+	size = PAGE_ALIGN(size);
-+	order = get_order(size);
-+
-+	page = alloc_pages(GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN |
-+			__GFP_THISNODE, order);
-+	if (!page)
-+		return NULL;
-+
-+	split_page(page, order);
-+
-+	for (p = page + (size >> PAGE_SHIFT); p < page + (1 << order); ++p)
-+		__free_page(p);
-+
-+	return page_address(page);
-+}
-+#endif
-+
-+static void free_phys(void *ptr, unsigned long size)
-+{
-+	struct page *page;
-+	struct page *end;
-+
-+	page = virt_to_page(ptr);
-+	end = page + (PAGE_ALIGN(size) >> PAGE_SHIFT);
-+
-+	for (; page < end; ++page)
-+		__free_page(page);
-+}
-+
-+
- void *module_alloc(unsigned long size)
- {
-+#ifdef MODULE_START
- 	return __vmalloc_node_range(size, 1, MODULE_START, MODULE_END,
- 				GFP_KERNEL, PAGE_KERNEL, NUMA_NO_NODE,
- 				__builtin_return_address(0));
-+#else
-+	void *ptr;
-+
-+	if (size == 0)
-+		return NULL;
-+
-+	ptr = alloc_phys(size);
-+
-+	/* If we failed to allocate physically contiguous memory,
-+	 * fall back to regular vmalloc. The module loader code will
-+	 * create jump tables to handle long jumps */
-+	if (!ptr)
-+		return vmalloc(size);
-+
-+	return ptr;
-+#endif
- }
-+
-+static inline bool is_phys_addr(void *ptr)
-+{
-+#ifdef CONFIG_64BIT
-+	return (KSEGX((unsigned long)ptr) == CKSEG0);
-+#else
-+	return (KSEGX(ptr) == KSEG0);
- #endif
-+}
-+
-+/* Free memory returned from module_alloc */
-+void module_free(struct module *mod, void *module_region)
-+{
-+	if (is_phys_addr(module_region)) {
-+		if (mod->module_init == module_region)
-+			free_phys(module_region, mod->init_size);
-+		else if (mod->module_core == module_region)
-+			free_phys(module_region, mod->core_size);
-+		else
-+			BUG();
-+	} else {
-+		vfree(module_region);
-+	}
-+}
-+
-+static void *__module_alloc(int size, bool phys)
-+{
-+	void *ptr;
-+
-+	if (phys)
-+		ptr = kmalloc(size, GFP_KERNEL);
-+	else
-+		ptr = vmalloc(size);
-+	return ptr;
-+}
-+
-+static void __module_free(void *ptr)
-+{
-+	if (is_phys_addr(ptr))
-+		kfree(ptr);
-+	else
-+		vfree(ptr);
-+}
-+
-+int module_frob_arch_sections(Elf_Ehdr *hdr, Elf_Shdr *sechdrs,
-+			      char *secstrings, struct module *mod)
-+{
-+	unsigned int symindex = 0;
-+	unsigned int core_size, init_size;
-+	int i;
-+
-+	mod->arch.phys_plt_offset = 0;
-+	mod->arch.virt_plt_offset = 0;
-+	mod->arch.phys_plt_tbl = NULL;
-+	mod->arch.virt_plt_tbl = NULL;
-+
-+	if (IS_ENABLED(CONFIG_64BIT))
-+		return 0;
-+
-+	for (i = 1; i < hdr->e_shnum; i++)
-+		if (sechdrs[i].sh_type == SHT_SYMTAB)
-+			symindex = i;
-+
-+	core_size = get_plt_size(hdr, sechdrs, secstrings, symindex, false);
-+	init_size = get_plt_size(hdr, sechdrs, secstrings, symindex, true);
-+
-+	if ((core_size + init_size) == 0)
-+		return 0;
-+
-+	mod->arch.phys_plt_tbl = __module_alloc(core_size + init_size, 1);
-+	if (!mod->arch.phys_plt_tbl)
-+		return -ENOMEM;
-+
-+	mod->arch.virt_plt_tbl = __module_alloc(core_size + init_size, 0);
-+	if (!mod->arch.virt_plt_tbl) {
-+		__module_free(mod->arch.phys_plt_tbl);
-+		mod->arch.phys_plt_tbl = NULL;
-+		return -ENOMEM;
-+	}
-+
-+	return 0;
-+}
- 
- int apply_r_mips_none(struct module *me, u32 *location, Elf_Addr v)
- {
-@@ -64,8 +272,39 @@ static int apply_r_mips_32_rel(struct mo
- 	return 0;
- }
- 
-+static Elf_Addr add_plt_entry_to(unsigned *plt_offset,
-+				 void *start, Elf_Addr v)
-+{
-+	unsigned *tramp = start + *plt_offset;
-+	*plt_offset += 4 * sizeof(int);
-+
-+	/* adjust carry for addiu */
-+	if (v & 0x00008000)
-+		v += 0x10000;
-+
-+	tramp[0] = 0x3c190000 | (v >> 16);      /* lui t9, hi16 */
-+	tramp[1] = 0x27390000 | (v & 0xffff);   /* addiu t9, t9, lo16 */
-+	tramp[2] = 0x03200008;                  /* jr t9 */
-+	tramp[3] = 0x00000000;                  /* nop */
-+
-+	return (Elf_Addr) tramp;
-+}
-+
-+static Elf_Addr add_plt_entry(struct module *me, void *location, Elf_Addr v)
-+{
-+	if (is_phys_addr(location))
-+		return add_plt_entry_to(&me->arch.phys_plt_offset,
-+				me->arch.phys_plt_tbl, v);
-+	else
-+		return add_plt_entry_to(&me->arch.virt_plt_offset,
-+				me->arch.virt_plt_tbl, v);
-+
-+}
-+
- static int apply_r_mips_26_rel(struct module *me, u32 *location, Elf_Addr v)
- {
-+	u32 ofs = *location & 0x03ffffff;
-+
- 	if (v % 4) {
- 		pr_err("module %s: dangerous R_MIPS_26 REL relocation\n",
- 		       me->name);
-@@ -73,14 +312,17 @@ static int apply_r_mips_26_rel(struct mo
- 	}
- 
- 	if ((v & 0xf0000000) != (((unsigned long)location + 4) & 0xf0000000)) {
--		printk(KERN_ERR
--		       "module %s: relocation overflow\n",
--		       me->name);
--		return -ENOEXEC;
-+		v = add_plt_entry(me, location, v + (ofs << 2));
-+		if (!v) {
-+			printk(KERN_ERR
-+				"module %s: relocation overflow\n", me->name);
-+			return -ENOEXEC;
-+		}
-+		ofs = 0;
- 	}
- 
- 	*location = (*location & ~0x03ffffff) |
--		    ((*location + (v >> 2)) & 0x03ffffff);
-+		    ((ofs + (v >> 2)) & 0x03ffffff);
- 
- 	return 0;
- }
-@@ -287,9 +529,36 @@ int module_finalize(const Elf_Ehdr *hdr,
- 		list_add(&me->arch.dbe_list, &dbe_list);
- 		spin_unlock_irq(&dbe_lock);
- 	}
-+
-+	/* Get rid of the fixup trampoline if we're running the module
-+	 * from physically mapped address space */
-+	if (me->arch.phys_plt_offset == 0) {
-+		__module_free(me->arch.phys_plt_tbl);
-+		me->arch.phys_plt_tbl = NULL;
-+	}
-+	if (me->arch.virt_plt_offset == 0) {
-+		__module_free(me->arch.virt_plt_tbl);
-+		me->arch.virt_plt_tbl = NULL;
-+	}
-+
- 	return 0;
- }
- 
-+void module_arch_freeing_init(struct module *mod)
-+{
-+	if (mod->state == MODULE_STATE_LIVE)
-+		return;
-+
-+	if (mod->arch.phys_plt_tbl) {
-+		__module_free(mod->arch.phys_plt_tbl);
-+		mod->arch.phys_plt_tbl = NULL;
-+	}
-+	if (mod->arch.virt_plt_tbl) {
-+		__module_free(mod->arch.virt_plt_tbl);
-+		mod->arch.virt_plt_tbl = NULL;
-+	}
-+}
-+
- void module_arch_cleanup(struct module *mod)
- {
- 	spin_lock_irq(&dbe_lock);
--- a/target/linux/generic/pending-3.18/306-mips_mem_functions_performance.patch	2022-03-22 08:54:47.299464823 +0800
+++ b/target/linux/generic/pending-3.18/306-mips_mem_functions_performance.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,83 +0,0 @@
---- a/arch/mips/include/asm/string.h
-+++ b/arch/mips/include/asm/string.h
-@@ -133,11 +133,44 @@ strncmp(__const__ char *__cs, __const__
- 
- #define __HAVE_ARCH_MEMSET
- extern void *memset(void *__s, int __c, size_t __count);
-+#define memset(__s, __c, len)					\
-+({								\
-+	size_t __len = (len);					\
-+	void *__ret;						\
-+	if (__builtin_constant_p(len) && __len >= 64)		\
-+		__ret = memset((__s), (__c), __len);		\
-+	else							\
-+		__ret = __builtin_memset((__s), (__c), __len);	\
-+	__ret;							\
-+})
- 
- #define __HAVE_ARCH_MEMCPY
- extern void *memcpy(void *__to, __const__ void *__from, size_t __n);
-+#define memcpy(dst, src, len)					\
-+({								\
-+	size_t __len = (len);					\
-+	void *__ret;						\
-+	if (__builtin_constant_p(len) && __len >= 64)		\
-+		__ret = memcpy((dst), (src), __len);		\
-+	else							\
-+		__ret = __builtin_memcpy((dst), (src), __len);	\
-+	__ret;							\
-+})
- 
- #define __HAVE_ARCH_MEMMOVE
- extern void *memmove(void *__dest, __const__ void *__src, size_t __n);
-+#define memmove(dst, src, len)					\
-+({								\
-+	size_t __len = (len);					\
-+	void *__ret;						\
-+	if (__builtin_constant_p(len) && __len >= 64)		\
-+		__ret = memmove((dst), (src), __len);		\
-+	else							\
-+		__ret = __builtin_memmove((dst), (src), __len);	\
-+	__ret;							\
-+})
-+
-+#define __HAVE_ARCH_MEMCMP
-+#define memcmp(src1, src2, len) __builtin_memcmp((src1), (src2), (len))
- 
- #endif /* _ASM_STRING_H */
---- a/arch/mips/lib/Makefile
-+++ b/arch/mips/lib/Makefile
-@@ -4,7 +4,7 @@
- 
- lib-y	+= bitops.o csum_partial.o delay.o memcpy.o memset.o \
- 	   mips-atomic.o strlen_user.o strncpy_user.o \
--	   strnlen_user.o uncached.o
-+	   strnlen_user.o uncached.o memcmp.o
- 
- obj-y			+= iomap.o
- obj-$(CONFIG_PCI)	+= iomap-pci.o
---- /dev/null
-+++ b/arch/mips/lib/memcmp.c
-@@ -0,0 +1,22 @@
-+/*
-+ *  copied from linux/lib/string.c
-+ *
-+ *  Copyright (C) 1991, 1992  Linus Torvalds
-+ */
-+
-+#include <linux/module.h>
-+#include <linux/string.h>
-+
-+#undef memcmp
-+int memcmp(const void *cs, const void *ct, size_t count)
-+{
-+	const unsigned char *su1, *su2;
-+	int res = 0;
-+
-+	for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
-+		if ((res = *su1 - *su2) != 0)
-+			break;
-+	return res;
-+}
-+EXPORT_SYMBOL(memcmp);
-+
--- a/target/linux/generic/pending-3.18/307-mips_highmem_offset.patch	2022-03-22 08:54:47.299464823 +0800
+++ b/target/linux/generic/pending-3.18/307-mips_highmem_offset.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,17 +0,0 @@
-Adjust highmem offset to 0x10000000 to ensure that all kmalloc allocations
-stay within the same 256M boundary. This ensures that -mlong-calls is not
-needed on systems with more than 256M RAM.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
---- a/arch/mips/include/asm/mach-generic/spaces.h
-+++ b/arch/mips/include/asm/mach-generic/spaces.h
-@@ -44,7 +44,7 @@
-  * Memory above this physical address will be considered highmem.
-  */
- #ifndef HIGHMEM_START
--#define HIGHMEM_START		_AC(0x20000000, UL)
-+#define HIGHMEM_START		_AC(0x10000000, UL)
- #endif
- 
- #endif /* CONFIG_32BIT */
--- a/target/linux/generic/pending-3.18/310-arm_module_unresolved_weak_sym.patch	2022-03-22 08:54:47.299464823 +0800
+++ b/target/linux/generic/pending-3.18/310-arm_module_unresolved_weak_sym.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,13 +0,0 @@
---- a/arch/arm/kernel/module.c
-+++ b/arch/arm/kernel/module.c
-@@ -83,6 +83,10 @@ apply_relocate(Elf32_Shdr *sechdrs, cons
- 			return -ENOEXEC;
- 		}
- 
-+		if ((IS_ERR_VALUE(sym->st_value) || !sym->st_value) &&
-+		    ELF_ST_BIND(sym->st_info) == STB_WEAK)
-+			continue;
-+
- 		loc = dstsec->sh_addr + rel->r_offset;
- 
- 		switch (ELF32_R_TYPE(rel->r_info)) {
--- a/target/linux/generic/pending-3.18/320-ppc4xx_optimization.patch	2022-03-22 08:54:47.300464824 +0800
+++ b/target/linux/generic/pending-3.18/320-ppc4xx_optimization.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,31 +0,0 @@
-Upstream doesn't optimize the kernel and bootwrappers for ppc44x because
-they still want to support gcc 3.3 -- well, we don't.
-
---- a/arch/powerpc/Makefile
-+++ b/arch/powerpc/Makefile
-@@ -203,7 +203,8 @@ ifeq ($(CONFIG_FUNCTION_TRACER),y)
- KBUILD_CFLAGS		+= -mno-sched-epilog
- endif
- 
--cpu-as-$(CONFIG_4xx)		+= -Wa,-m405
-+cpu-as-$(CONFIG_40x)		+= -Wa,-m405
-+cpu-as-$(CONFIG_44x)		+= -Wa,-m440
- cpu-as-$(CONFIG_ALTIVEC)	+= -Wa,-maltivec
- cpu-as-$(CONFIG_E200)		+= -Wa,-me200
- 
---- a/arch/powerpc/boot/Makefile
-+++ b/arch/powerpc/boot/Makefile
-@@ -45,10 +45,10 @@ BOOTCFLAGS	+= -I$(obj) -I$(srctree)/$(ob
- DTC_FLAGS	?= -p 1024
- 
- $(obj)/4xx.o: BOOTCFLAGS += -mcpu=405
--$(obj)/ebony.o: BOOTCFLAGS += -mcpu=405
-+$(obj)/ebony.o: BOOTCFLAGS += -mcpu=440
- $(obj)/cuboot-hotfoot.o: BOOTCFLAGS += -mcpu=405
--$(obj)/cuboot-taishan.o: BOOTCFLAGS += -mcpu=405
--$(obj)/cuboot-katmai.o: BOOTCFLAGS += -mcpu=405
-+$(obj)/cuboot-taishan.o: BOOTCFLAGS += -mcpu=440
-+$(obj)/cuboot-katmai.o: BOOTCFLAGS += -mcpu=440
- $(obj)/cuboot-acadia.o: BOOTCFLAGS += -mcpu=405
- $(obj)/treeboot-walnut.o: BOOTCFLAGS += -mcpu=405
- $(obj)/treeboot-iss4xx.o: BOOTCFLAGS += -mcpu=405
--- a/target/linux/generic/pending-3.18/321-powerpc_crtsavres_prereq.patch	2022-03-22 08:54:47.300464824 +0800
+++ b/target/linux/generic/pending-3.18/321-powerpc_crtsavres_prereq.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,10 +0,0 @@
---- a/arch/powerpc/Makefile
-+++ b/arch/powerpc/Makefile
-@@ -165,7 +165,6 @@ CPP		= $(CC) -E $(KBUILD_CFLAGS)
- 
- CHECKFLAGS	+= -m$(CONFIG_WORD_SIZE) -D__powerpc__ -D__powerpc$(CONFIG_WORD_SIZE)__
- 
--KBUILD_LDFLAGS_MODULE += arch/powerpc/lib/crtsavres.o
- 
- ifeq ($(CONFIG_476FPE_ERR46),y)
- 	KBUILD_LDFLAGS_MODULE += --ppc476-workaround \
--- a/target/linux/generic/pending-3.18/330-MIPS-kexec-Accept-command-line-parameters-from-users.patch	2022-03-22 08:54:47.300464824 +0800
+++ b/target/linux/generic/pending-3.18/330-MIPS-kexec-Accept-command-line-parameters-from-users.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,298 +0,0 @@
-From d8582dcf1ed66eee88a11e4760f42c0d6c8822be Mon Sep 17 00:00:00 2001
-From: Yousong Zhou <yszhou4tech@gmail.com>
-Date: Sat, 31 Jan 2015 22:26:03 +0800
-Subject: [PATCH 331/331] MIPS: kexec: Accept command line parameters from
- userspace.
-
-Signed-off-by: Yousong Zhou <yszhou4tech@gmail.com>
----
- arch/mips/kernel/machine_kexec.c   |  153 +++++++++++++++++++++++++++++++-----
- arch/mips/kernel/machine_kexec.h   |   20 +++++
- arch/mips/kernel/relocate_kernel.S |   21 +++--
- 3 files changed, 167 insertions(+), 27 deletions(-)
- create mode 100644 arch/mips/kernel/machine_kexec.h
-
---- a/arch/mips/kernel/machine_kexec.c
-+++ b/arch/mips/kernel/machine_kexec.c
-@@ -10,45 +10,145 @@
- #include <linux/mm.h>
- #include <linux/delay.h>
- 
-+#include <asm/bootinfo.h>
- #include <asm/cacheflush.h>
- #include <asm/page.h>
--
--extern const unsigned char relocate_new_kernel[];
--extern const size_t relocate_new_kernel_size;
--
--extern unsigned long kexec_start_address;
--extern unsigned long kexec_indirection_page;
-+#include <asm/uaccess.h>
-+#include "machine_kexec.h"
- 
- int (*_machine_kexec_prepare)(struct kimage *) = NULL;
- void (*_machine_kexec_shutdown)(void) = NULL;
- void (*_machine_crash_shutdown)(struct pt_regs *regs) = NULL;
-+
- #ifdef CONFIG_SMP
- void (*relocated_kexec_smp_wait) (void *);
- atomic_t kexec_ready_to_reboot = ATOMIC_INIT(0);
- #endif
- 
--int
--machine_kexec_prepare(struct kimage *kimage)
-+static void machine_kexec_print_args(void)
- {
-+	unsigned long argc = (int)kexec_args[0];
-+	int i;
-+
-+	pr_info("kexec_args[0] (argc): %lu\n", argc);
-+	pr_info("kexec_args[1] (argv): %p\n", (void *)kexec_args[1]);
-+	pr_info("kexec_args[2] (env ): %p\n", (void *)kexec_args[2]);
-+	pr_info("kexec_args[3] (desc): %p\n", (void *)kexec_args[3]);
-+
-+	for (i = 0; i < argc; i++) {
-+		pr_info("kexec_argv[%d] = %p, %s\n",
-+				i, kexec_argv[i], kexec_argv[i]);
-+	}
-+}
-+
-+static void machine_kexec_init_argv(struct kimage *image)
-+{
-+	void __user *buf = NULL;
-+	size_t bufsz;
-+	size_t size;
-+	int i;
-+
-+	bufsz = 0;
-+	for (i = 0; i < image->nr_segments; i++) {
-+		struct kexec_segment *seg;
-+
-+		seg = &image->segment[i];
-+		if (seg->bufsz < 6)
-+			continue;
-+
-+		if (strncmp((char *) seg->buf, "kexec ", 6))
-+			continue;
-+
-+		buf = seg->buf;
-+		bufsz = seg->bufsz;
-+		break;
-+	}
-+
-+	if (!buf)
-+		return;
-+
-+	size = KEXEC_COMMAND_LINE_SIZE;
-+	size = min(size, bufsz);
-+	if (size < bufsz)
-+		pr_warn("kexec command line truncated to %zd bytes\n", size);
-+
-+	/* Copy to kernel space */
-+	copy_from_user(kexec_argv_buf, buf, size);
-+	kexec_argv_buf[size - 1] = 0;
-+}
-+
-+static void machine_kexec_parse_argv(struct kimage *image)
-+{
-+	char *reboot_code_buffer;
-+	int reloc_delta;
-+	char *ptr;
-+	int argc;
-+	int i;
-+
-+	ptr = kexec_argv_buf;
-+	argc = 0;
-+
-+	/*
-+	 * convert command line string to array of parameters
-+	 * (as bootloader does).
-+	 */
-+	while (ptr && *ptr && (KEXEC_MAX_ARGC > argc)) {
-+		if (*ptr == ' ') {
-+			*ptr++ = '\0';
-+			continue;
-+		}
-+
-+		kexec_argv[argc++] = ptr;
-+		ptr = strchr(ptr, ' ');
-+	}
-+
-+	if (!argc)
-+		return;
-+
-+	kexec_args[0] = argc;
-+	kexec_args[1] = (unsigned long)kexec_argv;
-+	kexec_args[2] = 0;
-+	kexec_args[3] = 0;
-+
-+	reboot_code_buffer = page_address(image->control_code_page);
-+	reloc_delta = reboot_code_buffer - (char *)kexec_relocate_new_kernel;
-+
-+	kexec_args[1] += reloc_delta;
-+	for (i = 0; i < argc; i++)
-+		kexec_argv[i] += reloc_delta;
-+}
-+
-+int machine_kexec_prepare(struct kimage *kimage)
-+{
-+	/*
-+	 * Whenever arguments passed from kexec-tools, Init the arguments as
-+	 * the original ones to try avoiding booting failure.
-+	 */
-+
-+	kexec_args[0] = fw_arg0;
-+	kexec_args[1] = fw_arg1;
-+	kexec_args[2] = fw_arg2;
-+	kexec_args[3] = fw_arg3;
-+
-+	machine_kexec_init_argv(kimage);
-+	machine_kexec_parse_argv(kimage);
-+
- 	if (_machine_kexec_prepare)
- 		return _machine_kexec_prepare(kimage);
- 	return 0;
- }
- 
--void
--machine_kexec_cleanup(struct kimage *kimage)
-+void machine_kexec_cleanup(struct kimage *kimage)
- {
- }
- 
--void
--machine_shutdown(void)
-+void machine_shutdown(void)
- {
- 	if (_machine_kexec_shutdown)
- 		_machine_kexec_shutdown();
- }
- 
--void
--machine_crash_shutdown(struct pt_regs *regs)
-+void machine_crash_shutdown(struct pt_regs *regs)
- {
- 	if (_machine_crash_shutdown)
- 		_machine_crash_shutdown(regs);
-@@ -66,10 +166,12 @@ machine_kexec(struct kimage *image)
- 	unsigned long *ptr;
- 
- 	reboot_code_buffer =
--	  (unsigned long)page_address(image->control_code_page);
-+		(unsigned long)page_address(image->control_code_page);
-+	pr_info("reboot_code_buffer = %p\n", (void *)reboot_code_buffer);
- 
- 	kexec_start_address =
- 		(unsigned long) phys_to_virt(image->start);
-+	pr_info("kexec_start_address = %p\n", (void *)kexec_start_address);
- 
- 	if (image->type == KEXEC_TYPE_DEFAULT) {
- 		kexec_indirection_page =
-@@ -77,9 +179,19 @@ machine_kexec(struct kimage *image)
- 	} else {
- 		kexec_indirection_page = (unsigned long)&image->head;
- 	}
-+	pr_info("kexec_indirection_page = %p\n", (void *)kexec_indirection_page);
- 
--	memcpy((void*)reboot_code_buffer, relocate_new_kernel,
--	       relocate_new_kernel_size);
-+	pr_info("Where is memcpy: %p\n", memcpy);
-+	pr_info("kexec_relocate_new_kernel = %p, kexec_relocate_new_kernel_end = %p\n",
-+		(void *)kexec_relocate_new_kernel, &kexec_relocate_new_kernel_end);
-+	pr_info("Copy %lu bytes from %p to %p\n", KEXEC_RELOCATE_NEW_KERNEL_SIZE,
-+		(void *)kexec_relocate_new_kernel, (void *)reboot_code_buffer);
-+	memcpy((void*)reboot_code_buffer, kexec_relocate_new_kernel,
-+	       KEXEC_RELOCATE_NEW_KERNEL_SIZE);
-+
-+	pr_info("Before _print_args().\n");
-+	machine_kexec_print_args();
-+	pr_info("Before eval loop.\n");
- 
- 	/*
- 	 * The generic kexec code builds a page list with physical
-@@ -101,15 +213,16 @@ machine_kexec(struct kimage *image)
- 	/*
- 	 * we do not want to be bothered.
- 	 */
-+	pr_info("Before irq_disable.\n");
- 	local_irq_disable();
- 
--	printk("Will call new kernel at %08lx\n", image->start);
--	printk("Bye ...\n");
-+	pr_info("Will call new kernel at %08lx\n", image->start);
-+	pr_info("Bye ...\n");
- 	__flush_cache_all();
- #ifdef CONFIG_SMP
- 	/* All secondary cpus now may jump to kexec_wait cycle */
- 	relocated_kexec_smp_wait = reboot_code_buffer +
--		(void *)(kexec_smp_wait - relocate_new_kernel);
-+		(void *)(kexec_smp_wait - kexec_relocate_new_kernel);
- 	smp_wmb();
- 	atomic_set(&kexec_ready_to_reboot, 1);
- #endif
---- /dev/null
-+++ b/arch/mips/kernel/machine_kexec.h
-@@ -0,0 +1,20 @@
-+#ifndef _MACHINE_KEXEC_H
-+#define _MACHINE_KEXEC_H
-+
-+#ifndef __ASSEMBLY__
-+extern const unsigned char kexec_relocate_new_kernel[];
-+extern unsigned long kexec_relocate_new_kernel_end;
-+extern unsigned long kexec_start_address;
-+extern unsigned long kexec_indirection_page;
-+
-+extern char kexec_argv_buf[];
-+extern char *kexec_argv[];
-+
-+#define KEXEC_RELOCATE_NEW_KERNEL_SIZE	((unsigned long)&kexec_relocate_new_kernel_end - (unsigned long)kexec_relocate_new_kernel)
-+#endif /* !__ASSEMBLY__ */
-+
-+#define KEXEC_COMMAND_LINE_SIZE		256
-+#define KEXEC_ARGV_SIZE			(KEXEC_COMMAND_LINE_SIZE / 16)
-+#define KEXEC_MAX_ARGC			(KEXEC_ARGV_SIZE / sizeof(long))
-+
-+#endif
---- a/arch/mips/kernel/relocate_kernel.S
-+++ b/arch/mips/kernel/relocate_kernel.S
-@@ -12,8 +12,9 @@
- #include <asm/mipsregs.h>
- #include <asm/stackframe.h>
- #include <asm/addrspace.h>
-+#include "machine_kexec.h"
- 
--LEAF(relocate_new_kernel)
-+LEAF(kexec_relocate_new_kernel)
- 	PTR_L a0,	arg0
- 	PTR_L a1,	arg1
- 	PTR_L a2,	arg2
-@@ -98,7 +99,7 @@ done:
- #endif
- 	/* jump to kexec_start_address */
- 	j		s1
--	END(relocate_new_kernel)
-+	END(kexec_relocate_new_kernel)
- 
- #ifdef CONFIG_SMP
- /*
-@@ -184,9 +185,15 @@ kexec_indirection_page:
- 	PTR		0
- 	.size		kexec_indirection_page, PTRSIZE
- 
--relocate_new_kernel_end:
-+kexec_argv_buf:
-+	EXPORT(kexec_argv_buf)
-+	.skip		KEXEC_COMMAND_LINE_SIZE
-+	.size		kexec_argv_buf, KEXEC_COMMAND_LINE_SIZE
-+
-+kexec_argv:
-+	EXPORT(kexec_argv)
-+	.skip		KEXEC_ARGV_SIZE
-+	.size		kexec_argv, KEXEC_ARGV_SIZE
- 
--relocate_new_kernel_size:
--	EXPORT(relocate_new_kernel_size)
--	PTR		relocate_new_kernel_end - relocate_new_kernel
--	.size		relocate_new_kernel_size, PTRSIZE
-+kexec_relocate_new_kernel_end:
-+	EXPORT(kexec_relocate_new_kernel_end)
--- a/target/linux/generic/pending-3.18/400-mtd-add-rootfs-split-support.patch	2022-03-22 08:54:47.301464826 +0800
+++ b/target/linux/generic/pending-3.18/400-mtd-add-rootfs-split-support.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,171 +0,0 @@
---- a/drivers/mtd/Kconfig
-+++ b/drivers/mtd/Kconfig
-@@ -12,6 +12,23 @@ menuconfig MTD
- 
- if MTD
- 
-+menu "OpenWrt specific MTD options"
-+
-+config MTD_ROOTFS_ROOT_DEV
-+	bool "Automatically set 'rootfs' partition to be root filesystem"
-+	default y
-+
-+config MTD_SPLIT_FIRMWARE
-+	bool "Automatically split firmware partition for kernel+rootfs"
-+	default y
-+
-+config MTD_SPLIT_FIRMWARE_NAME
-+	string "Firmware partition name"
-+	depends on MTD_SPLIT_FIRMWARE
-+	default "firmware"
-+
-+endmenu
-+
- config MTD_TESTS
- 	tristate "MTD tests support (DANGEROUS)"
- 	depends on m
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -30,9 +30,11 @@
- #include <linux/mtd/mtd.h>
- #include <linux/mtd/partitions.h>
- #include <linux/of.h>
-+#include <linux/magic.h>
- #include <linux/err.h>
- 
- #include "mtdcore.h"
-+#include "mtdsplit/mtdsplit.h"
- 
- /* Our partition linked list */
- static LIST_HEAD(mtd_partitions);
-@@ -46,13 +48,14 @@ struct mtd_part {
- 	struct list_head list;
- };
- 
-+static void mtd_partition_split(struct mtd_info *master, struct mtd_part *part);
-+
- /*
-  * Given a pointer to the MTD object in the mtd_part structure, we can retrieve
-  * the pointer to that structure with this macro.
-  */
- #define PART(x)  ((struct mtd_part *)(x))
- 
--
- /*
-  * MTD methods which simply translate the effective address and pass through
-  * to the _real_ device.
-@@ -548,8 +551,10 @@ out_register:
- 	return slave;
- }
- 
--int mtd_add_partition(struct mtd_info *master, const char *name,
--		      long long offset, long long length)
-+
-+static int
-+__mtd_add_partition(struct mtd_info *master, const char *name,
-+		    long long offset, long long length, bool dup_check)
- {
- 	struct mtd_partition part;
- 	struct mtd_part *p, *new;
-@@ -581,21 +586,24 @@ int mtd_add_partition(struct mtd_info *m
- 	end = offset + length;
- 
- 	mutex_lock(&mtd_partitions_mutex);
--	list_for_each_entry(p, &mtd_partitions, list)
--		if (p->master == master) {
--			if ((start >= p->offset) &&
--			    (start < (p->offset + p->mtd.size)))
--				goto err_inv;
--
--			if ((end >= p->offset) &&
--			    (end < (p->offset + p->mtd.size)))
--				goto err_inv;
--		}
-+	if (dup_check) {
-+		list_for_each_entry(p, &mtd_partitions, list)
-+			if (p->master == master) {
-+				if ((start >= p->offset) &&
-+				    (start < (p->offset + p->mtd.size)))
-+					goto err_inv;
-+
-+				if ((end >= p->offset) &&
-+				    (end < (p->offset + p->mtd.size)))
-+					goto err_inv;
-+			}
-+	}
- 
- 	list_add(&new->list, &mtd_partitions);
- 	mutex_unlock(&mtd_partitions_mutex);
- 
- 	add_mtd_device(&new->mtd);
-+	mtd_partition_split(master, new);
- 
- 	return ret;
- err_inv:
-@@ -605,6 +613,12 @@ err_inv:
- }
- EXPORT_SYMBOL_GPL(mtd_add_partition);
- 
-+int mtd_add_partition(struct mtd_info *master, const char *name,
-+		      long long offset, long long length)
-+{
-+	return __mtd_add_partition(master, name, offset, length, true);
-+}
-+
- int mtd_del_partition(struct mtd_info *master, int partno)
- {
- 	struct mtd_part *slave, *next;
-@@ -628,6 +642,35 @@ int mtd_del_partition(struct mtd_info *m
- }
- EXPORT_SYMBOL_GPL(mtd_del_partition);
- 
-+#ifdef CONFIG_MTD_SPLIT_FIRMWARE_NAME
-+#define SPLIT_FIRMWARE_NAME	CONFIG_MTD_SPLIT_FIRMWARE_NAME
-+#else
-+#define SPLIT_FIRMWARE_NAME	"unused"
-+#endif
-+
-+static void split_firmware(struct mtd_info *master, struct mtd_part *part)
-+{
-+}
-+
-+void __weak arch_split_mtd_part(struct mtd_info *master, const char *name,
-+                                int offset, int size)
-+{
-+}
-+
-+static void mtd_partition_split(struct mtd_info *master, struct mtd_part *part)
-+{
-+	static int rootfs_found = 0;
-+
-+	if (rootfs_found)
-+		return;
-+
-+	if (!strcmp(part->mtd.name, SPLIT_FIRMWARE_NAME) &&
-+	    config_enabled(CONFIG_MTD_SPLIT_FIRMWARE))
-+		split_firmware(master, part);
-+
-+	arch_split_mtd_part(master, part->mtd.name, part->offset,
-+			    part->mtd.size);
-+}
- /*
-  * This function, given a master MTD object and a partition table, creates
-  * and registers slave MTD objects which are bound to the master according to
-@@ -657,6 +700,7 @@ int add_mtd_partitions(struct mtd_info *
- 		mutex_unlock(&mtd_partitions_mutex);
- 
- 		add_mtd_device(&slave->mtd);
-+		mtd_partition_split(master, slave);
- 
- 		cur_offset = slave->offset + slave->mtd.size;
- 	}
---- a/include/linux/mtd/partitions.h
-+++ b/include/linux/mtd/partitions.h
-@@ -84,5 +84,7 @@ int mtd_add_partition(struct mtd_info *m
- 		      long long offset, long long length);
- int mtd_del_partition(struct mtd_info *master, int partno);
- uint64_t mtd_get_device_size(const struct mtd_info *mtd);
-+extern void __weak arch_split_mtd_part(struct mtd_info *master,
-+				       const char *name, int offset, int size);
- 
- #endif
--- a/target/linux/generic/pending-3.18/401-mtd-add-support-for-different-partition-parser-types.patch	2022-03-22 08:54:47.301464826 +0800
+++ b/target/linux/generic/pending-3.18/401-mtd-add-support-for-different-partition-parser-types.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,113 +0,0 @@
-From 02cff0ccaa6d364f5c1eeea83f47ac80ccc967d4 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Tue, 3 Sep 2013 18:11:50 +0200
-Subject: [PATCH] mtd: add support for different partition parser types
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/mtd/mtdpart.c          |   56 ++++++++++++++++++++++++++++++++++++++++
- include/linux/mtd/partitions.h |   11 ++++++++
- 2 files changed, 67 insertions(+)
-
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -730,6 +730,30 @@ static struct mtd_part_parser *get_parti
- 
- #define put_partition_parser(p) do { module_put((p)->owner); } while (0)
- 
-+static struct mtd_part_parser *
-+get_partition_parser_by_type(enum mtd_parser_type type,
-+			     struct mtd_part_parser *start)
-+{
-+	struct mtd_part_parser *p, *ret = NULL;
-+
-+	spin_lock(&part_parser_lock);
-+
-+	p = list_prepare_entry(start, &part_parsers, list);
-+	if (start)
-+		put_partition_parser(start);
-+
-+	list_for_each_entry_continue(p, &part_parsers, list) {
-+		if (p->type == type && try_module_get(p->owner)) {
-+			ret = p;
-+			break;
-+		}
-+	}
-+
-+	spin_unlock(&part_parser_lock);
-+
-+	return ret;
-+}
-+
- void register_mtd_parser(struct mtd_part_parser *p)
- {
- 	spin_lock(&part_parser_lock);
-@@ -845,6 +869,38 @@ int parse_mtd_partitions(struct mtd_info
- 	return ret;
- }
- 
-+int parse_mtd_partitions_by_type(struct mtd_info *master,
-+				 enum mtd_parser_type type,
-+				 struct mtd_partition **pparts,
-+				 struct mtd_part_parser_data *data)
-+{
-+	struct mtd_part_parser *prev = NULL;
-+	int ret = 0;
-+
-+	while (1) {
-+		struct mtd_part_parser *parser;
-+
-+		parser = get_partition_parser_by_type(type, prev);
-+		if (!parser)
-+			break;
-+
-+		ret = (*parser->parse_fn)(master, pparts, data);
-+
-+		if (ret > 0) {
-+			put_partition_parser(parser);
-+			printk(KERN_NOTICE
-+			       "%d %s partitions found on MTD device %s\n",
-+			       ret, parser->name, master->name);
-+			break;
-+		}
-+
-+		prev = parser;
-+	}
-+
-+	return ret;
-+}
-+EXPORT_SYMBOL_GPL(parse_mtd_partitions_by_type);
-+
- int mtd_is_partition(const struct mtd_info *mtd)
- {
- 	struct mtd_part *part;
---- a/include/linux/mtd/partitions.h
-+++ b/include/linux/mtd/partitions.h
-@@ -68,12 +68,17 @@ struct mtd_part_parser_data {
-  * Functions dealing with the various ways of partitioning the space
-  */
- 
-+enum mtd_parser_type {
-+	MTD_PARSER_TYPE_DEVICE = 0,
-+};
-+
- struct mtd_part_parser {
- 	struct list_head list;
- 	struct module *owner;
- 	const char *name;
- 	int (*parse_fn)(struct mtd_info *, struct mtd_partition **,
- 			struct mtd_part_parser_data *);
-+	enum mtd_parser_type type;
- };
- 
- extern void register_mtd_parser(struct mtd_part_parser *parser);
-@@ -87,4 +92,9 @@ uint64_t mtd_get_device_size(const struc
- extern void __weak arch_split_mtd_part(struct mtd_info *master,
- 				       const char *name, int offset, int size);
- 
-+int parse_mtd_partitions_by_type(struct mtd_info *master,
-+				 enum mtd_parser_type type,
-+				 struct mtd_partition **pparts,
-+				 struct mtd_part_parser_data *data);
-+
- #endif
--- a/target/linux/generic/pending-3.18/402-mtd-use-typed-mtd-parsers-for-rootfs-and-firmware-split.patch	2022-03-22 08:54:47.302464828 +0800
+++ b/target/linux/generic/pending-3.18/402-mtd-use-typed-mtd-parsers-for-rootfs-and-firmware-split.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,72 +0,0 @@
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -642,6 +642,37 @@ int mtd_del_partition(struct mtd_info *m
- }
- EXPORT_SYMBOL_GPL(mtd_del_partition);
- 
-+static int
-+run_parsers_by_type(struct mtd_part *slave, enum mtd_parser_type type)
-+{
-+	struct mtd_partition *parts;
-+	int nr_parts;
-+	int i;
-+
-+	nr_parts = parse_mtd_partitions_by_type(&slave->mtd, type, &parts,
-+						NULL);
-+	if (nr_parts <= 0)
-+		return nr_parts;
-+
-+	if (WARN_ON(!parts))
-+		return 0;
-+
-+	for (i = 0; i < nr_parts; i++) {
-+		/* adjust partition offsets */
-+		parts[i].offset += slave->offset;
-+
-+		__mtd_add_partition(slave->master,
-+				    parts[i].name,
-+				    parts[i].offset,
-+				    parts[i].size,
-+				    false);
-+	}
-+
-+	kfree(parts);
-+
-+	return nr_parts;
-+}
-+
- #ifdef CONFIG_MTD_SPLIT_FIRMWARE_NAME
- #define SPLIT_FIRMWARE_NAME	CONFIG_MTD_SPLIT_FIRMWARE_NAME
- #else
-@@ -650,6 +681,7 @@ EXPORT_SYMBOL_GPL(mtd_del_partition);
- 
- static void split_firmware(struct mtd_info *master, struct mtd_part *part)
- {
-+	run_parsers_by_type(part, MTD_PARSER_TYPE_FIRMWARE);
- }
- 
- void __weak arch_split_mtd_part(struct mtd_info *master, const char *name,
-@@ -664,6 +696,12 @@ static void mtd_partition_split(struct m
- 	if (rootfs_found)
- 		return;
- 
-+	if (!strcmp(part->mtd.name, "rootfs")) {
-+		run_parsers_by_type(part, MTD_PARSER_TYPE_ROOTFS);
-+
-+		rootfs_found = 1;
-+	}
-+
- 	if (!strcmp(part->mtd.name, SPLIT_FIRMWARE_NAME) &&
- 	    config_enabled(CONFIG_MTD_SPLIT_FIRMWARE))
- 		split_firmware(master, part);
---- a/include/linux/mtd/partitions.h
-+++ b/include/linux/mtd/partitions.h
-@@ -70,6 +70,8 @@ struct mtd_part_parser_data {
- 
- enum mtd_parser_type {
- 	MTD_PARSER_TYPE_DEVICE = 0,
-+	MTD_PARSER_TYPE_ROOTFS,
-+	MTD_PARSER_TYPE_FIRMWARE,
- };
- 
- struct mtd_part_parser {
--- a/target/linux/generic/pending-3.18/403-mtd-hook-mtdsplit-to-Kbuild.patch	2022-03-22 08:54:47.302464828 +0800
+++ b/target/linux/generic/pending-3.18/403-mtd-hook-mtdsplit-to-Kbuild.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,22 +0,0 @@
---- a/drivers/mtd/Kconfig
-+++ b/drivers/mtd/Kconfig
-@@ -27,6 +27,8 @@ config MTD_SPLIT_FIRMWARE_NAME
- 	depends on MTD_SPLIT_FIRMWARE
- 	default "firmware"
- 
-+source "drivers/mtd/mtdsplit/Kconfig"
-+
- endmenu
- 
- config MTD_TESTS
---- a/drivers/mtd/Makefile
-+++ b/drivers/mtd/Makefile
-@@ -6,6 +6,8 @@
- obj-$(CONFIG_MTD)		+= mtd.o
- mtd-y				:= mtdcore.o mtdsuper.o mtdconcat.o mtdpart.o mtdchar.o
- 
-+obj-$(CONFIG_MTD_SPLIT)		+= mtdsplit/
-+
- obj-$(CONFIG_MTD_OF_PARTS)	+= ofpart.o
- obj-$(CONFIG_MTD_REDBOOT_PARTS) += redboot.o
- obj-$(CONFIG_MTD_CMDLINE_PARTS) += cmdlinepart.o
--- a/target/linux/generic/pending-3.18/404-mtd-add-more-helper-functions.patch	2022-03-22 08:54:47.303464829 +0800
+++ b/target/linux/generic/pending-3.18/404-mtd-add-more-helper-functions.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,101 +0,0 @@
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -446,14 +446,12 @@ static struct mtd_part *allocate_partiti
- 	if (slave->offset == MTDPART_OFS_APPEND)
- 		slave->offset = cur_offset;
- 	if (slave->offset == MTDPART_OFS_NXTBLK) {
--		slave->offset = cur_offset;
--		if (mtd_mod_by_eb(cur_offset, master) != 0) {
--			/* Round up to next erasesize */
--			slave->offset = (mtd_div_by_eb(cur_offset, master) + 1) * master->erasesize;
-+		/* Round up to next erasesize */
-+		slave->offset = mtd_roundup_to_eb(cur_offset, master);
-+		if (slave->offset != cur_offset)
- 			printk(KERN_NOTICE "Moving partition %d: "
- 			       "0x%012llx -> 0x%012llx\n", partno,
- 			       (unsigned long long)cur_offset, (unsigned long long)slave->offset);
--		}
- 	}
- 	if (slave->offset == MTDPART_OFS_RETAIN) {
- 		slave->offset = cur_offset;
-@@ -673,6 +671,17 @@ run_parsers_by_type(struct mtd_part *sla
- 	return nr_parts;
- }
- 
-+static inline unsigned long
-+mtd_pad_erasesize(struct mtd_info *mtd, int offset, int len)
-+{
-+	unsigned long mask = mtd->erasesize - 1;
-+
-+	len += offset & mask;
-+	len = (len + mask) & ~mask;
-+	len -= offset & mask;
-+	return len;
-+}
-+
- #ifdef CONFIG_MTD_SPLIT_FIRMWARE_NAME
- #define SPLIT_FIRMWARE_NAME	CONFIG_MTD_SPLIT_FIRMWARE_NAME
- #else
-@@ -956,6 +965,24 @@ int mtd_is_partition(const struct mtd_in
- }
- EXPORT_SYMBOL_GPL(mtd_is_partition);
- 
-+struct mtd_info *mtdpart_get_master(const struct mtd_info *mtd)
-+{
-+	if (!mtd_is_partition(mtd))
-+		return (struct mtd_info *)mtd;
-+
-+	return PART(mtd)->master;
-+}
-+EXPORT_SYMBOL_GPL(mtdpart_get_master);
-+
-+uint64_t mtdpart_get_offset(const struct mtd_info *mtd)
-+{
-+	if (!mtd_is_partition(mtd))
-+		return 0;
-+
-+	return PART(mtd)->offset;
-+}
-+EXPORT_SYMBOL_GPL(mtdpart_get_offset);
-+
- /* Returns the size of the entire flash chip */
- uint64_t mtd_get_device_size(const struct mtd_info *mtd)
- {
---- a/include/linux/mtd/partitions.h
-+++ b/include/linux/mtd/partitions.h
-@@ -90,6 +90,8 @@ int mtd_is_partition(const struct mtd_in
- int mtd_add_partition(struct mtd_info *master, const char *name,
- 		      long long offset, long long length);
- int mtd_del_partition(struct mtd_info *master, int partno);
-+struct mtd_info *mtdpart_get_master(const struct mtd_info *mtd);
-+uint64_t mtdpart_get_offset(const struct mtd_info *mtd);
- uint64_t mtd_get_device_size(const struct mtd_info *mtd);
- extern void __weak arch_split_mtd_part(struct mtd_info *master,
- 				       const char *name, int offset, int size);
---- a/include/linux/mtd/mtd.h
-+++ b/include/linux/mtd/mtd.h
-@@ -333,6 +333,24 @@ static inline uint32_t mtd_mod_by_eb(uin
- 	return do_div(sz, mtd->erasesize);
- }
- 
-+static inline uint64_t mtd_roundup_to_eb(uint64_t sz, struct mtd_info *mtd)
-+{
-+	if (mtd_mod_by_eb(sz, mtd) == 0)
-+		return sz;
-+
-+	/* Round up to next erase block */
-+	return (mtd_div_by_eb(sz, mtd) + 1) * mtd->erasesize;
-+}
-+
-+static inline uint64_t mtd_rounddown_to_eb(uint64_t sz, struct mtd_info *mtd)
-+{
-+	if (mtd_mod_by_eb(sz, mtd) == 0)
-+		return sz;
-+
-+	/* Round down to the start of the current erase block */
-+	return (mtd_div_by_eb(sz, mtd)) * mtd->erasesize;
-+}
-+
- static inline uint32_t mtd_div_by_ws(uint64_t sz, struct mtd_info *mtd)
- {
- 	if (mtd->writesize_shift)
--- a/target/linux/generic/pending-3.18/405-mtd-old-firmware-uimage-splitter.patch	2022-03-22 08:54:47.303464829 +0800
+++ b/target/linux/generic/pending-3.18/405-mtd-old-firmware-uimage-splitter.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,70 +0,0 @@
---- a/drivers/mtd/Kconfig
-+++ b/drivers/mtd/Kconfig
-@@ -27,6 +27,11 @@ config MTD_SPLIT_FIRMWARE_NAME
- 	depends on MTD_SPLIT_FIRMWARE
- 	default "firmware"
- 
-+config MTD_UIMAGE_SPLIT
-+	bool "Enable split support for firmware partitions containing a uImage"
-+	depends on MTD_SPLIT_FIRMWARE
-+	default y
-+
- source "drivers/mtd/mtdsplit/Kconfig"
- 
- endmenu
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -682,6 +682,37 @@ mtd_pad_erasesize(struct mtd_info *mtd,
- 	return len;
- }
- 
-+#define UBOOT_MAGIC	0x27051956
-+
-+static void split_uimage(struct mtd_info *master, struct mtd_part *part)
-+{
-+	struct {
-+		__be32 magic;
-+		__be32 pad[2];
-+		__be32 size;
-+	} hdr;
-+	size_t len;
-+
-+	if (mtd_read(master, part->offset, sizeof(hdr), &len, (void *) &hdr))
-+		return;
-+
-+	if (len != sizeof(hdr) || hdr.magic != cpu_to_be32(UBOOT_MAGIC))
-+		return;
-+
-+	len = be32_to_cpu(hdr.size) + 0x40;
-+	len = mtd_pad_erasesize(master, part->offset, len);
-+	if (len + master->erasesize > part->mtd.size)
-+		return;
-+
-+	if (config_enabled(CONFIG_MTD_SPLIT_UIMAGE_FW))
-+		pr_err("Dedicated partitioner didn't split firmware partition, please fill a bug report!\n");
-+	else
-+		pr_warn("Support for built-in firmware splitter will be removed, please use CONFIG_MTD_SPLIT_UIMAGE_FW\n");
-+
-+	__mtd_add_partition(master, "rootfs", part->offset + len,
-+			    part->mtd.size - len, false);
-+}
-+
- #ifdef CONFIG_MTD_SPLIT_FIRMWARE_NAME
- #define SPLIT_FIRMWARE_NAME	CONFIG_MTD_SPLIT_FIRMWARE_NAME
- #else
-@@ -690,7 +721,14 @@ mtd_pad_erasesize(struct mtd_info *mtd,
- 
- static void split_firmware(struct mtd_info *master, struct mtd_part *part)
- {
--	run_parsers_by_type(part, MTD_PARSER_TYPE_FIRMWARE);
-+	int ret;
-+
-+	ret = run_parsers_by_type(part, MTD_PARSER_TYPE_FIRMWARE);
-+	if (ret > 0)
-+		return;
-+
-+	if (config_enabled(CONFIG_MTD_UIMAGE_SPLIT))
-+		split_uimage(master, part);
- }
- 
- void __weak arch_split_mtd_part(struct mtd_info *master, const char *name,
--- a/target/linux/generic/pending-3.18/406-mtd-old-rootfs-squashfs-splitter.patch	2022-03-22 08:54:47.303464829 +0800
+++ b/target/linux/generic/pending-3.18/406-mtd-old-rootfs-squashfs-splitter.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,76 +0,0 @@
---- a/drivers/mtd/Kconfig
-+++ b/drivers/mtd/Kconfig
-@@ -18,6 +18,11 @@ config MTD_ROOTFS_ROOT_DEV
- 	bool "Automatically set 'rootfs' partition to be root filesystem"
- 	default y
- 
-+config MTD_ROOTFS_SPLIT
-+	bool "Automatically split 'rootfs' partition for squashfs"
-+	select MTD_SPLIT
-+	default y
-+
- config MTD_SPLIT_FIRMWARE
- 	bool "Automatically split firmware partition for kernel+rootfs"
- 	default y
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -682,6 +682,47 @@ mtd_pad_erasesize(struct mtd_info *mtd,
- 	return len;
- }
- 
-+static int split_squashfs(struct mtd_info *master, int offset, int *split_offset)
-+{
-+	size_t squashfs_len;
-+	int len, ret;
-+
-+	ret = mtd_get_squashfs_len(master, offset, &squashfs_len);
-+	if (ret)
-+		return ret;
-+
-+	len = mtd_pad_erasesize(master, offset, squashfs_len);
-+	*split_offset = offset + len;
-+
-+	return 0;
-+}
-+
-+static void split_rootfs_data(struct mtd_info *master, struct mtd_part *part)
-+{
-+	unsigned int split_offset = 0;
-+	unsigned int split_size;
-+	int ret;
-+
-+	ret = split_squashfs(master, part->offset, &split_offset);
-+	if (ret)
-+		return;
-+
-+	if (split_offset <= 0)
-+		return;
-+
-+	if (config_enabled(CONFIG_MTD_SPLIT_SQUASHFS_ROOT))
-+		pr_err("Dedicated partitioner didn't create \"rootfs_data\" partition, please fill a bug report!\n");
-+	else
-+		pr_warn("Support for built-in \"rootfs_data\" splitter will be removed, please use CONFIG_MTD_SPLIT_SQUASHFS_ROOT\n");
-+
-+	split_size = part->mtd.size - (split_offset - part->offset);
-+	printk(KERN_INFO "mtd: partition \"%s\" created automatically, ofs=0x%x, len=0x%x\n",
-+		ROOTFS_SPLIT_NAME, split_offset, split_size);
-+
-+	__mtd_add_partition(master, ROOTFS_SPLIT_NAME, split_offset,
-+			    split_size, false);
-+}
-+
- #define UBOOT_MAGIC	0x27051956
- 
- static void split_uimage(struct mtd_info *master, struct mtd_part *part)
-@@ -744,7 +785,10 @@ static void mtd_partition_split(struct m
- 		return;
- 
- 	if (!strcmp(part->mtd.name, "rootfs")) {
--		run_parsers_by_type(part, MTD_PARSER_TYPE_ROOTFS);
-+		int num = run_parsers_by_type(part, MTD_PARSER_TYPE_ROOTFS);
-+
-+		if (num <= 0 && config_enabled(CONFIG_MTD_ROOTFS_SPLIT))
-+			split_rootfs_data(master, part);
- 
- 		rootfs_found = 1;
- 	}
--- a/target/linux/generic/pending-3.18/410-mtd-move-forward-declaration-of-struct-mtd_info.patch	2022-03-22 08:54:47.304464831 +0800
+++ b/target/linux/generic/pending-3.18/410-mtd-move-forward-declaration-of-struct-mtd_info.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,18 +0,0 @@
---- a/include/linux/mtd/partitions.h
-+++ b/include/linux/mtd/partitions.h
-@@ -35,6 +35,7 @@
-  * Note: writeable partitions require their size and offset be
-  * erasesize aligned (e.g. use MTDPART_OFS_NEXTBLK).
-  */
-+struct mtd_info;
- 
- struct mtd_partition {
- 	const char *name;		/* identifier string */
-@@ -50,7 +51,6 @@ struct mtd_partition {
- #define MTDPART_SIZ_FULL	(0)
- 
- 
--struct mtd_info;
- struct device_node;
- 
- /**
--- a/target/linux/generic/pending-3.18/411-mtd-partial_eraseblock_write.patch	2022-03-22 08:54:47.304464831 +0800
+++ b/target/linux/generic/pending-3.18/411-mtd-partial_eraseblock_write.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,142 +0,0 @@
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -36,6 +36,8 @@
- #include "mtdcore.h"
- #include "mtdsplit/mtdsplit.h"
- 
-+#define MTD_ERASE_PARTIAL	0x8000 /* partition only covers parts of an erase block */
-+
- /* Our partition linked list */
- static LIST_HEAD(mtd_partitions);
- static DEFINE_MUTEX(mtd_partitions_mutex);
-@@ -234,13 +236,61 @@ static int part_erase(struct mtd_info *m
- 	struct mtd_part *part = PART(mtd);
- 	int ret;
- 
-+
-+	instr->partial_start = false;
-+	if (mtd->flags & MTD_ERASE_PARTIAL) {
-+		size_t readlen = 0;
-+		u64 mtd_ofs;
-+
-+		instr->erase_buf = kmalloc(part->master->erasesize, GFP_ATOMIC);
-+		if (!instr->erase_buf)
-+			return -ENOMEM;
-+
-+		mtd_ofs = part->offset + instr->addr;
-+		instr->erase_buf_ofs = do_div(mtd_ofs, part->master->erasesize);
-+
-+		if (instr->erase_buf_ofs > 0) {
-+			instr->addr -= instr->erase_buf_ofs;
-+			ret = mtd_read(part->master,
-+				instr->addr + part->offset,
-+				part->master->erasesize,
-+				&readlen, instr->erase_buf);
-+
-+			instr->len += instr->erase_buf_ofs;
-+			instr->partial_start = true;
-+		} else {
-+			mtd_ofs = part->offset + part->mtd.size;
-+			instr->erase_buf_ofs = part->master->erasesize -
-+				do_div(mtd_ofs, part->master->erasesize);
-+
-+			if (instr->erase_buf_ofs > 0) {
-+				instr->len += instr->erase_buf_ofs;
-+				ret = mtd_read(part->master,
-+					part->offset + instr->addr +
-+					instr->len - part->master->erasesize,
-+					part->master->erasesize, &readlen,
-+					instr->erase_buf);
-+			} else {
-+				ret = 0;
-+			}
-+		}
-+		if (ret < 0) {
-+			kfree(instr->erase_buf);
-+			return ret;
-+		}
-+
-+	}
-+
- 	instr->addr += part->offset;
- 	ret = part->master->_erase(part->master, instr);
- 	if (ret) {
- 		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
- 			instr->fail_addr -= part->offset;
- 		instr->addr -= part->offset;
-+		if (mtd->flags & MTD_ERASE_PARTIAL)
-+			kfree(instr->erase_buf);
- 	}
-+
- 	return ret;
- }
- 
-@@ -248,7 +298,25 @@ void mtd_erase_callback(struct erase_inf
- {
- 	if (instr->mtd->_erase == part_erase) {
- 		struct mtd_part *part = PART(instr->mtd);
-+		size_t wrlen = 0;
- 
-+		if (instr->mtd->flags & MTD_ERASE_PARTIAL) {
-+			if (instr->partial_start) {
-+				part->master->_write(part->master,
-+					instr->addr, instr->erase_buf_ofs,
-+					&wrlen, instr->erase_buf);
-+				instr->addr += instr->erase_buf_ofs;
-+			} else {
-+				instr->len -= instr->erase_buf_ofs;
-+				part->master->_write(part->master,
-+					instr->addr + instr->len,
-+					instr->erase_buf_ofs, &wrlen,
-+					instr->erase_buf +
-+					part->master->erasesize -
-+					instr->erase_buf_ofs);
-+			}
-+			kfree(instr->erase_buf);
-+		}
- 		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
- 			instr->fail_addr -= part->offset;
- 		instr->addr -= part->offset;
-@@ -515,17 +583,20 @@ static struct mtd_part *allocate_partiti
- 	if ((slave->mtd.flags & MTD_WRITEABLE) &&
- 	    mtd_mod_by_eb(slave->offset, &slave->mtd)) {
- 		/* Doesn't start on a boundary of major erase size */
--		/* FIXME: Let it be writable if it is on a boundary of
--		 * _minor_ erase size though */
--		slave->mtd.flags &= ~MTD_WRITEABLE;
--		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase block boundary -- force read-only\n",
--			part->name);
-+		slave->mtd.flags |= MTD_ERASE_PARTIAL;
-+		if (((u32) slave->mtd.size) > master->erasesize)
-+			slave->mtd.flags &= ~MTD_WRITEABLE;
-+		else
-+			slave->mtd.erasesize = slave->mtd.size;
- 	}
- 	if ((slave->mtd.flags & MTD_WRITEABLE) &&
--	    mtd_mod_by_eb(slave->mtd.size, &slave->mtd)) {
--		slave->mtd.flags &= ~MTD_WRITEABLE;
--		printk(KERN_WARNING"mtd: partition \"%s\" doesn't end on an erase block -- force read-only\n",
--			part->name);
-+	    mtd_mod_by_eb(slave->offset + slave->mtd.size, &slave->mtd)) {
-+		slave->mtd.flags |= MTD_ERASE_PARTIAL;
-+
-+		if ((u32) slave->mtd.size > master->erasesize)
-+			slave->mtd.flags &= ~MTD_WRITEABLE;
-+		else
-+			slave->mtd.erasesize = slave->mtd.size;
- 	}
- 
- 	slave->mtd.ecclayout = master->ecclayout;
---- a/include/linux/mtd/mtd.h
-+++ b/include/linux/mtd/mtd.h
-@@ -55,6 +55,10 @@ struct erase_info {
- 	u_long priv;
- 	u_char state;
- 	struct erase_info *next;
-+
-+	u8 *erase_buf;
-+	u32 erase_buf_ofs;
-+	bool partial_start;
- };
- 
- struct mtd_erase_region_info {
--- a/target/linux/generic/pending-3.18/412-mtd-partial_eraseblock_unlock.patch	2022-03-22 08:54:47.304464831 +0800
+++ b/target/linux/generic/pending-3.18/412-mtd-partial_eraseblock_unlock.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,18 +0,0 @@
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -335,7 +335,14 @@ static int part_lock(struct mtd_info *mt
- static int part_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
- {
- 	struct mtd_part *part = PART(mtd);
--	return part->master->_unlock(part->master, ofs + part->offset, len);
-+
-+	ofs += part->offset;
-+	if (mtd->flags & MTD_ERASE_PARTIAL) {
-+		/* round up len to next erasesize and round down offset to prev block */
-+		len = (mtd_div_by_eb(len, part->master) + 1) * part->master->erasesize;
-+		ofs &= ~(part->master->erasesize - 1);
-+	}
-+	return part->master->_unlock(part->master, ofs, len);
- }
- 
- static int part_is_locked(struct mtd_info *mtd, loff_t ofs, uint64_t len)
--- a/target/linux/generic/pending-3.18/420-mtd-redboot_space.patch	2022-03-22 08:54:47.305464833 +0800
+++ b/target/linux/generic/pending-3.18/420-mtd-redboot_space.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,30 +0,0 @@
---- a/drivers/mtd/redboot.c
-+++ b/drivers/mtd/redboot.c
-@@ -265,14 +265,21 @@ static int parse_redboot_partitions(stru
- #endif
- 		names += strlen(names)+1;
- 
--#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED
- 		if(fl->next && fl->img->flash_base + fl->img->size + master->erasesize <= fl->next->img->flash_base) {
--			i++;
--			parts[i].offset = parts[i-1].size + parts[i-1].offset;
--			parts[i].size = fl->next->img->flash_base - parts[i].offset;
--			parts[i].name = nullname;
--		}
-+			if (!strcmp(parts[i].name, "rootfs")) {
-+				parts[i].size = fl->next->img->flash_base;
-+				parts[i].size &= ~(master->erasesize - 1);
-+				parts[i].size -= parts[i].offset;
-+#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED
-+				nrparts--;
-+			} else {
-+				i++;
-+				parts[i].offset = parts[i-1].size + parts[i-1].offset;
-+				parts[i].size = fl->next->img->flash_base - parts[i].offset;
-+				parts[i].name = nullname;
- #endif
-+			}
-+		}
- 		tmp_fl = fl;
- 		fl = fl->next;
- 		kfree(tmp_fl);
--- a/target/linux/generic/pending-3.18/430-mtd-add-myloader-partition-parser.patch	2022-03-22 08:54:47.305464833 +0800
+++ b/target/linux/generic/pending-3.18/430-mtd-add-myloader-partition-parser.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,35 +0,0 @@
---- a/drivers/mtd/Kconfig
-+++ b/drivers/mtd/Kconfig
-@@ -184,6 +184,22 @@ config MTD_BCM47XX_PARTS
- 	  This provides partitions parser for devices based on BCM47xx
- 	  boards.
- 
-+config MTD_MYLOADER_PARTS
-+	tristate "MyLoader partition parsing"
-+	depends on ADM5120 || ATH25 || ATH79
-+	---help---
-+	  MyLoader is a bootloader which allows the user to define partitions
-+	  in flash devices, by putting a table in the second erase block
-+	  on the device, similar to a partition table. This table gives the 
-+	  offsets and lengths of the user defined partitions.
-+
-+	  If you need code which can detect and parse these tables, and
-+	  register MTD 'partitions' corresponding to each image detected,
-+	  enable this option.
-+
-+	  You will still need the parsing functions to be called by the driver
-+	  for your particular device. It won't happen automatically.
-+
- comment "User Modules And Translation Layers"
- 
- #
---- a/drivers/mtd/Makefile
-+++ b/drivers/mtd/Makefile
-@@ -15,6 +15,7 @@ obj-$(CONFIG_MTD_AFS_PARTS)	+= afs.o
- obj-$(CONFIG_MTD_AR7_PARTS)	+= ar7part.o
- obj-$(CONFIG_MTD_BCM63XX_PARTS)	+= bcm63xxpart.o
- obj-$(CONFIG_MTD_BCM47XX_PARTS)	+= bcm47xxpart.o
-+obj-$(CONFIG_MTD_MYLOADER_PARTS) += myloader.o
- 
- # 'Users' - code which presents functionality to userspace.
- obj-$(CONFIG_MTD_BLKDEVS)	+= mtd_blkdevs.o
--- a/target/linux/generic/pending-3.18/431-mtd-bcm47xxpart-check-for-bad-blocks-when-calculatin.patch	2022-03-22 08:54:47.305464833 +0800
+++ b/target/linux/generic/pending-3.18/431-mtd-bcm47xxpart-check-for-bad-blocks-when-calculatin.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,100 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
-Date: Sat, 2 Jan 2016 01:04:52 +0100
-Subject: [PATCH] mtd: bcm47xxpart: check for bad blocks when calculating
- offsets
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Signed-off-by: Rafa Miecki <zajec5@gmail.com>
----
- drivers/mtd/bcm47xxpart.c | 50 +++++++++++++++++++++++++++++++++++++----------
- 1 file changed, 40 insertions(+), 10 deletions(-)
-
---- a/drivers/mtd/bcm47xxpart.c
-+++ b/drivers/mtd/bcm47xxpart.c
-@@ -61,6 +61,34 @@ static void bcm47xxpart_add_part(struct
- 	part->mask_flags = mask_flags;
- }
- 
-+/*
-+ * Calculate real end offset (address) for a given amount of data. It checks
-+ * all blocks skipping bad ones.
-+ */
-+static size_t bcm47xxpart_real_offset(struct mtd_info *master, size_t offset,
-+				      size_t bytes)
-+{
-+	size_t real_offset = offset;
-+
-+	if (mtd_block_isbad(master, real_offset))
-+		pr_warn("Base offset shouldn't be at bad block");
-+
-+	while (bytes >= master->erasesize) {
-+		bytes -= master->erasesize;
-+		real_offset += master->erasesize;
-+		while (mtd_block_isbad(master, real_offset)) {
-+			real_offset += master->erasesize;
-+
-+			if (real_offset >= master->size)
-+				return real_offset - master->erasesize;
-+		}
-+	}
-+
-+	real_offset += bytes;
-+
-+	return real_offset;
-+}
-+
- static const char *bcm47xxpart_trx_data_part_name(struct mtd_info *master,
- 						  size_t offset)
- {
-@@ -182,6 +210,8 @@ static int bcm47xxpart_parse(struct mtd_
- 
- 		/* TRX */
- 		if (buf[0x000 / 4] == TRX_MAGIC) {
-+			uint32_t tmp;
-+
- 			if (BCM47XXPART_MAX_PARTS - curr_part < 4) {
- 				pr_warn("Not enough partitions left to register trx, scanning stopped!\n");
- 				break;
-@@ -196,18 +226,18 @@ static int bcm47xxpart_parse(struct mtd_
- 			i = 0;
- 			/* We have LZMA loader if offset[2] points to sth */
- 			if (trx->offset[2]) {
-+				tmp = bcm47xxpart_real_offset(master, offset,
-+							      trx->offset[i]);
- 				bcm47xxpart_add_part(&parts[curr_part++],
--						     "loader",
--						     offset + trx->offset[i],
--						     0);
-+						     "loader", tmp, 0);
- 				i++;
- 			}
- 
- 			if (trx->offset[i]) {
-+				tmp = bcm47xxpart_real_offset(master, offset,
-+							      trx->offset[i]);
- 				bcm47xxpart_add_part(&parts[curr_part++],
--						     "linux",
--						     offset + trx->offset[i],
--						     0);
-+						     "linux", tmp, 0);
- 				i++;
- 			}
- 
-@@ -219,11 +249,11 @@ static int bcm47xxpart_parse(struct mtd_
- 			if (trx->offset[i]) {
- 				const char *name;
- 
--				name = bcm47xxpart_trx_data_part_name(master, offset + trx->offset[i]);
-+				tmp = bcm47xxpart_real_offset(master, offset,
-+							      trx->offset[i]);
-+				name = bcm47xxpart_trx_data_part_name(master, tmp);
- 				bcm47xxpart_add_part(&parts[curr_part++],
--						     name,
--						     offset + trx->offset[i],
--						     0);
-+						     name, tmp, 0);
- 				i++;
- 			}
- 
--- a/target/linux/generic/pending-3.18/432-mtd-bcm47xxpart-detect-T_Meter-partition.patch	2022-03-22 08:54:47.306464834 +0800
+++ b/target/linux/generic/pending-3.18/432-mtd-bcm47xxpart-detect-T_Meter-partition.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,42 +0,0 @@
-From fd54aa583296f9adfb1f519affbc10ba521eb809 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
-Date: Wed, 28 Jan 2015 22:14:41 +0100
-Subject: [PATCH] mtd: bcm47xxpart: detect T_Meter partition
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-It can be found on many Netgear devices. It consists of many 0x30 blocks
-starting with 4D 54.
-
-Signed-off-by: Rafa Miecki <zajec5@gmail.com>
----
- drivers/mtd/bcm47xxpart.c | 10 ++++++++++
- 1 file changed, 10 insertions(+)
-
---- a/drivers/mtd/bcm47xxpart.c
-+++ b/drivers/mtd/bcm47xxpart.c
-@@ -38,6 +38,7 @@
- #define NVRAM_HEADER			0x48534C46	/* FLSH */
- #define POT_MAGIC1			0x54544f50	/* POTT */
- #define POT_MAGIC2			0x504f		/* OP */
-+#define T_METER_MAGIC			0x4D540000	/* MT */
- #define ML_MAGIC1			0x39685a42
- #define ML_MAGIC2			0x26594131
- #define TRX_MAGIC			0x30524448
-@@ -207,6 +208,15 @@ static int bcm47xxpart_parse(struct mtd_
- 					     MTD_WRITEABLE);
- 			continue;
- 		}
-+
-+		/* T_Meter */
-+		if ((le32_to_cpu(buf[0x000 / 4]) & 0xFFFF0000) == T_METER_MAGIC &&
-+		    (le32_to_cpu(buf[0x030 / 4]) & 0xFFFF0000) == T_METER_MAGIC &&
-+		    (le32_to_cpu(buf[0x060 / 4]) & 0xFFFF0000) == T_METER_MAGIC) {
-+			bcm47xxpart_add_part(&parts[curr_part++], "T_Meter", offset,
-+					     MTD_WRITEABLE);
-+			continue;
-+		}
- 
- 		/* TRX */
- 		if (buf[0x000 / 4] == TRX_MAGIC) {
--- a/target/linux/generic/pending-3.18/440-block2mtd_init.patch	2022-03-22 08:54:47.306464834 +0800
+++ b/target/linux/generic/pending-3.18/440-block2mtd_init.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,107 +0,0 @@
---- a/drivers/mtd/devices/block2mtd.c
-+++ b/drivers/mtd/devices/block2mtd.c
-@@ -17,6 +17,7 @@
- #include <linux/list.h>
- #include <linux/init.h>
- #include <linux/mtd/mtd.h>
-+#include <linux/mtd/partitions.h>
- #include <linux/mutex.h>
- #include <linux/mount.h>
- #include <linux/slab.h>
-@@ -209,11 +210,12 @@ static void block2mtd_free_device(struct
- }
- 
- 
--static struct block2mtd_dev *add_device(char *devname, int erase_size)
-+static struct block2mtd_dev *add_device(char *devname, int erase_size, const char *mtdname)
- {
- 	const fmode_t mode = FMODE_READ | FMODE_WRITE | FMODE_EXCL;
- 	struct block_device *bdev;
- 	struct block2mtd_dev *dev;
-+	struct mtd_partition *part;
- 	char *name;
- 
- 	if (!devname)
-@@ -257,13 +259,16 @@ static struct block2mtd_dev *add_device(
- 
- 	/* Setup the MTD structure */
- 	/* make the name contain the block device in */
--	name = kasprintf(GFP_KERNEL, "block2mtd: %s", devname);
-+	if (!mtdname)
-+		mtdname = devname;
-+	name = kmalloc(strlen(mtdname) + 1, GFP_KERNEL);
- 	if (!name)
- 		goto err_destroy_mutex;
- 
-+	strcpy(name, mtdname);
- 	dev->mtd.name = name;
- 
--	dev->mtd.size = dev->blkdev->bd_inode->i_size & PAGE_MASK;
-+	dev->mtd.size = dev->blkdev->bd_inode->i_size & PAGE_MASK & ~(erase_size - 1);
- 	dev->mtd.erasesize = erase_size;
- 	dev->mtd.writesize = 1;
- 	dev->mtd.writebufsize = PAGE_SIZE;
-@@ -276,15 +281,18 @@ static struct block2mtd_dev *add_device(
- 	dev->mtd.priv = dev;
- 	dev->mtd.owner = THIS_MODULE;
- 
--	if (mtd_device_register(&dev->mtd, NULL, 0)) {
-+	part = kzalloc(sizeof(struct mtd_partition), GFP_KERNEL);
-+	part->name = name;
-+	part->offset = 0;
-+	part->size = dev->mtd.size;
-+	if (mtd_device_register(&dev->mtd, part, 1)) {
- 		/* Device didn't get added, so free the entry */
- 		goto err_destroy_mutex;
- 	}
- 	list_add(&dev->list, &blkmtd_device_list);
- 	pr_info("mtd%d: [%s] erase_size = %dKiB [%d]\n",
- 		dev->mtd.index,
--		dev->mtd.name + strlen("block2mtd: "),
--		dev->mtd.erasesize >> 10, dev->mtd.erasesize);
-+		mtdname, dev->mtd.erasesize >> 10, dev->mtd.erasesize);
- 	return dev;
- 
- err_destroy_mutex:
-@@ -353,9 +361,9 @@ static char block2mtd_paramline[80 + 12]
- 
- static int block2mtd_setup2(const char *val)
- {
--	char buf[80 + 12]; /* 80 for device, 12 for erase size */
-+	char buf[80 + 12 + 80]; /* 80 for device, 12 for erase size, 80 for name */
- 	char *str = buf;
--	char *token[2];
-+	char *token[3];
- 	char *name;
- 	size_t erase_size = PAGE_SIZE;
- 	int i, ret;
-@@ -368,7 +376,7 @@ static int block2mtd_setup2(const char *
- 	strcpy(str, val);
- 	kill_final_newline(str);
- 
--	for (i = 0; i < 2; i++)
-+	for (i = 0; i < 3; i++)
- 		token[i] = strsep(&str, ",");
- 
- 	if (str) {
-@@ -394,8 +402,10 @@ static int block2mtd_setup2(const char *
- 			return 0;
- 		}
- 	}
-+	if (token[2] && (strlen(token[2]) + 1 > 80))
-+		pr_err("mtd device name too long\n");
- 
--	add_device(name, erase_size);
-+	add_device(name, erase_size, token[2]);
- 
- 	return 0;
- }
-@@ -429,7 +439,7 @@ static int block2mtd_setup(const char *v
- 
- 
- module_param_call(block2mtd, block2mtd_setup, NULL, NULL, 0200);
--MODULE_PARM_DESC(block2mtd, "Device to use. \"block2mtd=<dev>[,<erasesize>]\"");
-+MODULE_PARM_DESC(block2mtd, "Device to use. \"block2mtd=<dev>[,<erasesize>[,<name>]]\"");
- 
- static int __init block2mtd_init(void)
- {
--- a/target/linux/generic/pending-3.18/441-block2mtd_probe.patch	2022-03-22 08:54:47.306464834 +0800
+++ b/target/linux/generic/pending-3.18/441-block2mtd_probe.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,110 +0,0 @@
---- a/drivers/mtd/devices/block2mtd.c
-+++ b/drivers/mtd/devices/block2mtd.c
-@@ -10,6 +10,7 @@
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/module.h>
-+#include <linux/delay.h>
- #include <linux/fs.h>
- #include <linux/blkdev.h>
- #include <linux/bio.h>
-@@ -210,13 +211,16 @@ static void block2mtd_free_device(struct
- }
- 
- 
--static struct block2mtd_dev *add_device(char *devname, int erase_size, const char *mtdname)
-+static struct block2mtd_dev *add_device(char *devname, int erase_size, const char *mtdname, int timeout)
- {
- 	const fmode_t mode = FMODE_READ | FMODE_WRITE | FMODE_EXCL;
--	struct block_device *bdev;
-+	struct block_device *bdev = ERR_PTR(-ENODEV);
- 	struct block2mtd_dev *dev;
- 	struct mtd_partition *part;
- 	char *name;
-+#ifndef MODULE
-+	int i;
-+#endif
- 
- 	if (!devname)
- 		return NULL;
-@@ -227,15 +231,20 @@ static struct block2mtd_dev *add_device(
- 
- 	/* Get a handle on the device */
- 	bdev = blkdev_get_by_path(devname, mode, dev);
-+
- #ifndef MODULE
--	if (IS_ERR(bdev)) {
-+	for (i = 0; IS_ERR(bdev) && i <= timeout; i++) {
-+		dev_t devt;
- 
--		/* We might not have rootfs mounted at this point. Try
--		   to resolve the device name by other means. */
-+		if (i)
-+			msleep(1000);
-+		wait_for_device_probe();
-+
-+		devt = name_to_dev_t(devname);
-+		if (!devt)
-+			continue;
- 
--		dev_t devt = name_to_dev_t(devname);
--		if (devt)
--			bdev = blkdev_get_by_dev(devt, mode, dev);
-+		bdev = blkdev_get_by_dev(devt, mode, dev);
- 	}
- #endif
- 
-@@ -361,11 +370,12 @@ static char block2mtd_paramline[80 + 12]
- 
- static int block2mtd_setup2(const char *val)
- {
--	char buf[80 + 12 + 80]; /* 80 for device, 12 for erase size, 80 for name */
-+	char buf[80 + 12 + 80 + 8]; /* 80 for device, 12 for erase size, 80 for name, 8 for timeout */
- 	char *str = buf;
--	char *token[3];
-+	char *token[4];
- 	char *name;
- 	size_t erase_size = PAGE_SIZE;
-+	unsigned long timeout = 0;
- 	int i, ret;
- 
- 	if (strnlen(val, sizeof(buf)) >= sizeof(buf)) {
-@@ -376,7 +386,7 @@ static int block2mtd_setup2(const char *
- 	strcpy(str, val);
- 	kill_final_newline(str);
- 
--	for (i = 0; i < 3; i++)
-+	for (i = 0; i < 4; i++)
- 		token[i] = strsep(&str, ",");
- 
- 	if (str) {
-@@ -405,7 +415,10 @@ static int block2mtd_setup2(const char *
- 	if (token[2] && (strlen(token[2]) + 1 > 80))
- 		pr_err("mtd device name too long\n");
- 
--	add_device(name, erase_size, token[2]);
-+	if (token[3] && kstrtoul(token[3], 0, &timeout))
-+		pr_err("invalid timeout\n");
-+
-+	add_device(name, erase_size, token[2], timeout);
- 
- 	return 0;
- }
-@@ -439,7 +452,7 @@ static int block2mtd_setup(const char *v
- 
- 
- module_param_call(block2mtd, block2mtd_setup, NULL, NULL, 0200);
--MODULE_PARM_DESC(block2mtd, "Device to use. \"block2mtd=<dev>[,<erasesize>[,<name>]]\"");
-+MODULE_PARM_DESC(block2mtd, "Device to use. \"block2mtd=<dev>[,<erasesize>[,<name>[,<timeout>]]]\"");
- 
- static int __init block2mtd_init(void)
- {
-@@ -474,7 +487,7 @@ static void block2mtd_exit(void)
- }
- 
- 
--module_init(block2mtd_init);
-+late_initcall(block2mtd_init);
- module_exit(block2mtd_exit);
- 
- MODULE_LICENSE("GPL");
--- a/target/linux/generic/pending-3.18/450-mtd-nand-allow-to-use-platform-specific-chip-fixup.patch	2022-03-22 08:54:47.307464836 +0800
+++ b/target/linux/generic/pending-3.18/450-mtd-nand-allow-to-use-platform-specific-chip-fixup.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,37 +0,0 @@
----
- drivers/mtd/nand/plat_nand.c |   13 ++++++++++++-
- include/linux/mtd/nand.h     |    1 +
- 2 files changed, 13 insertions(+), 1 deletion(-)
-
---- a/include/linux/mtd/nand.h
-+++ b/include/linux/mtd/nand.h
-@@ -851,6 +851,7 @@ struct platform_nand_chip {
- 	unsigned int options;
- 	unsigned int bbt_options;
- 	const char **part_probe_types;
-+	int (*chip_fixup)(struct mtd_info *mtd);
- };
- 
- /* Keep gcc happy */
---- a/drivers/mtd/nand/plat_nand.c
-+++ b/drivers/mtd/nand/plat_nand.c
-@@ -90,7 +90,18 @@ static int plat_nand_probe(struct platfo
- 	}
- 
- 	/* Scan to find existence of the device */
--	if (nand_scan(&data->mtd, pdata->chip.nr_chips)) {
-+	if (nand_scan_ident(&data->mtd, pdata->chip.nr_chips, NULL)) {
-+		err = -ENXIO;
-+		goto out;
-+	}
-+
-+	if (pdata->chip.chip_fixup) {
-+		err = pdata->chip.chip_fixup(&data->mtd);
-+		if (err)
-+			goto out;
-+	}
-+
-+	if (nand_scan_tail(&data->mtd)) {
- 		err = -ENXIO;
- 		goto out;
- 	}
--- a/target/linux/generic/pending-3.18/451-mtd-nand-fix-return-code-of-nand_correct_data-function.patch	2022-03-22 08:54:47.307464836 +0800
+++ b/target/linux/generic/pending-3.18/451-mtd-nand-fix-return-code-of-nand_correct_data-function.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,11 +0,0 @@
---- a/drivers/mtd/nand/nand_ecc.c
-+++ b/drivers/mtd/nand/nand_ecc.c
-@@ -507,7 +507,7 @@ int __nand_correct_data(unsigned char *b
- 		return 1;	/* error in ECC data; no action needed */
- 
- 	pr_err("%s: uncorrectable ECC error\n", __func__);
--	return -1;
-+	return -EBADMSG;
- }
- EXPORT_SYMBOL(__nand_correct_data);
- 
--- a/target/linux/generic/pending-3.18/460-mtd-cfi_cmdset_0002-no-erase_suspend.patch	2022-03-22 08:54:47.307464836 +0800
+++ b/target/linux/generic/pending-3.18/460-mtd-cfi_cmdset_0002-no-erase_suspend.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,11 +0,0 @@
---- a/drivers/mtd/chips/cfi_cmdset_0002.c
-+++ b/drivers/mtd/chips/cfi_cmdset_0002.c
-@@ -809,7 +809,7 @@ static int get_chip(struct map_info *map
- 		return 0;
- 
- 	case FL_ERASING:
--		if (!cfip || !(cfip->EraseSuspend & (0x1|0x2)) ||
-+		if (1 /* no suspend */ || !cfip || !(cfip->EraseSuspend & (0x1|0x2)) ||
- 		    !(mode == FL_READY || mode == FL_POINT ||
- 		    (mode == FL_WRITING && (cfip->EraseSuspend & 0x2))))
- 			goto sleep;
--- a/target/linux/generic/pending-3.18/461-mtd-cfi_cmdset_0002-add-buffer-write-cmd-timeout.patch	2022-03-22 08:54:47.308464838 +0800
+++ b/target/linux/generic/pending-3.18/461-mtd-cfi_cmdset_0002-add-buffer-write-cmd-timeout.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,18 +0,0 @@
-From: George Kashperko <george@znau.edu.ua>
-
-Issue map read after Write Buffer Load command to ensure chip is ready
-to receive data.
-Signed-off-by: George Kashperko <george@znau.edu.ua>
----
- drivers/mtd/chips/cfi_cmdset_0002.c |    1 +
- 1 file changed, 1 insertion(+)
---- a/drivers/mtd/chips/cfi_cmdset_0002.c
-+++ b/drivers/mtd/chips/cfi_cmdset_0002.c
-@@ -1831,6 +1831,7 @@ static int __xipram do_write_buffer(stru
- 
- 	/* Write Buffer Load */
- 	map_write(map, CMD(0x25), cmd_adr);
-+	(void) map_read(map, cmd_adr);
- 
- 	chip->state = FL_WRITING_TO_BUFFER;
- 
--- a/target/linux/generic/pending-3.18/472-mtd-m25p80-add-support-for-Winbond-W25X05-flash.patch	2022-03-22 08:54:47.308464838 +0800
+++ b/target/linux/generic/pending-3.18/472-mtd-m25p80-add-support-for-Winbond-W25X05-flash.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,20 +0,0 @@
-From eef9dfc4e821408af1af13aa0cc707fc496fb7c6 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Wed, 11 Dec 2013 19:05:59 +0100
-Subject: [PATCH] m25p80: add support for the Winbond W25X05 flash
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/mtd/devices/m25p80.c |    1 +
- 1 file changed, 1 insertion(+)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -618,6 +618,7 @@ static const struct spi_device_id spi_no
- 	{ "m25px80",    INFO(0x207114,  0, 64 * 1024, 16, 0) },
- 
- 	/* Winbond -- w25x "blocks" are 64K, "sectors" are 4KiB */
-+	{ "w25x05", INFO(0xef3010, 0, 64 * 1024,  1,  SECT_4K) },
- 	{ "w25x10", INFO(0xef3011, 0, 64 * 1024,  2,  SECT_4K) },
- 	{ "w25x20", INFO(0xef3012, 0, 64 * 1024,  4,  SECT_4K) },
- 	{ "w25x40", INFO(0xef3013, 0, 64 * 1024,  8,  SECT_4K) },
--- a/target/linux/generic/pending-3.18/473-mtd-spi-nor-add-support-for-the-Macronix-MX25L512E-S.patch	2022-03-22 08:54:47.308464838 +0800
+++ b/target/linux/generic/pending-3.18/473-mtd-spi-nor-add-support-for-the-Macronix-MX25L512E-S.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,21 +0,0 @@
-From 0d7388de0911c1a4fc4a8a3898ef9d0ab818ca08 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Tue, 7 Apr 2015 18:35:15 +0200
-Subject: [PATCH] mtd: spi-nor: add support for the Macronix MX25L512E SPI
- flash chip
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/mtd/spi-nor/spi-nor.c |    1 +
- 1 file changed, 1 insertion(+)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -518,6 +518,7 @@ static const struct spi_device_id spi_no
- 	{ "640s33b",  INFO(0x898913, 0, 64 * 1024, 128, 0) },
- 
- 	/* Macronix */
-+	{ "mx25l512e",   INFO(0xc22010, 0, 64 * 1024,   1, SECT_4K) },
- 	{ "mx25l2005a",  INFO(0xc22012, 0, 64 * 1024,   4, SECT_4K) },
- 	{ "mx25l4005a",  INFO(0xc22013, 0, 64 * 1024,   8, SECT_4K) },
- 	{ "mx25l8005",   INFO(0xc22014, 0, 64 * 1024,  16, 0) },
--- a/target/linux/generic/pending-3.18/474-mtd-spi-nor-add-support-for-the-ISSI-SI25CD512-SPI-f.patch	2022-03-22 08:54:47.308464838 +0800
+++ b/target/linux/generic/pending-3.18/474-mtd-spi-nor-add-support-for-the-ISSI-SI25CD512-SPI-f.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,22 +0,0 @@
-From 34e2b403040a2f9d3ba071d95a7f42457e2950f9 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Tue, 7 Apr 2015 18:35:15 +0200
-Subject: [PATCH] mtd: spi-nor: add support for the ISSI SI25CD512 SPI flash
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/mtd/spi-nor/spi-nor.c |    3 +++
- 1 file changed, 3 insertions(+)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -517,6 +517,9 @@ static const struct spi_device_id spi_no
- 	{ "320s33b",  INFO(0x898912, 0, 64 * 1024,  64, 0) },
- 	{ "640s33b",  INFO(0x898913, 0, 64 * 1024, 128, 0) },
- 
-+	/* ISSI */
-+	{ "is25cd512", INFO(0x7f9d20, 0, 32 * 1024,   2, SECT_4K) },
-+
- 	/* Macronix */
- 	{ "mx25l512e",   INFO(0xc22010, 0, 64 * 1024,   1, SECT_4K) },
- 	{ "mx25l2005a",  INFO(0xc22012, 0, 64 * 1024,   4, SECT_4K) },
--- a/target/linux/generic/pending-3.18/475-mtd-spi-nor-add-macronix-mx25u25635f.patch	2022-03-22 08:54:47.309464839 +0800
+++ b/target/linux/generic/pending-3.18/475-mtd-spi-nor-add-macronix-mx25u25635f.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,10 +0,0 @@
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -532,6 +532,7 @@ static const struct spi_device_id spi_no
- 	{ "mx25l12805d", INFO(0xc22018, 0, 64 * 1024, 256, 0) },
- 	{ "mx25l12855e", INFO(0xc22618, 0, 64 * 1024, 256, 0) },
- 	{ "mx25l25635e", INFO(0xc22019, 0, 64 * 1024, 512, 0) },
-+	{ "mx25u25635f", INFO(0xc22539, 0, 64 * 1024, 512, 0) },
- 	{ "mx25l25655e", INFO(0xc22619, 0, 64 * 1024, 512, 0) },
- 	{ "mx66l51235l", INFO(0xc2201a, 0, 64 * 1024, 1024, SPI_NOR_QUAD_READ) },
- 	{ "mx66l1g55g",  INFO(0xc2261b, 0, 64 * 1024, 2048, SPI_NOR_QUAD_READ) },
--- a/target/linux/generic/pending-3.18/476-mtd-spi-nor-add-eon-en25qh32.patch	2022-03-22 08:54:47.309464839 +0800
+++ b/target/linux/generic/pending-3.18/476-mtd-spi-nor-add-eon-en25qh32.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,10 +0,0 @@
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -497,6 +497,7 @@ static const struct spi_device_id spi_no
- 	{ "en25q32b",   INFO(0x1c3016, 0, 64 * 1024,   64, 0) },
- 	{ "en25p64",    INFO(0x1c2017, 0, 64 * 1024,  128, 0) },
- 	{ "en25q64",    INFO(0x1c3017, 0, 64 * 1024,  128, SECT_4K) },
-+	{ "en25qh32",   INFO(0x1c7016, 0, 64 * 1024,   64, 0) },
- 	{ "en25qh128",  INFO(0x1c7018, 0, 64 * 1024,  256, 0) },
- 	{ "en25qh256",  INFO(0x1c7019, 0, 64 * 1024,  512, 0) },
- 
--- a/target/linux/generic/pending-3.18/480-mtd-set-rootfs-to-be-root-dev.patch	2022-03-22 08:54:47.309464839 +0800
+++ b/target/linux/generic/pending-3.18/480-mtd-set-rootfs-to-be-root-dev.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,26 +0,0 @@
---- a/drivers/mtd/mtdcore.c
-+++ b/drivers/mtd/mtdcore.c
-@@ -37,6 +37,7 @@
- #include <linux/backing-dev.h>
- #include <linux/gfp.h>
- #include <linux/slab.h>
-+#include <linux/root_dev.h>
- 
- #include <linux/mtd/mtd.h>
- #include <linux/mtd/partitions.h>
-@@ -456,6 +457,15 @@ int add_mtd_device(struct mtd_info *mtd)
- 	   of this try_ nonsense, and no bitching about it
- 	   either. :) */
- 	__module_get(THIS_MODULE);
-+
-+	if (!strcmp(mtd->name, "rootfs") &&
-+	    config_enabled(CONFIG_MTD_ROOTFS_ROOT_DEV) &&
-+	    ROOT_DEV == 0) {
-+		pr_notice("mtd: device %d (%s) set to be root filesystem\n",
-+			  mtd->index, mtd->name);
-+		ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, mtd->index);
-+	}
-+
- 	return 0;
- 
- fail_added:
--- a/target/linux/generic/pending-3.18/490-ubi-auto-attach-mtd-device-named-ubi-or-data-on-boot.patch	2022-03-22 08:54:47.310464841 +0800
+++ b/target/linux/generic/pending-3.18/490-ubi-auto-attach-mtd-device-named-ubi-or-data-on-boot.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,76 +0,0 @@
-From 8a52e4100d7c3a4a1dfddfa02b8864a9b0068c13 Mon Sep 17 00:00:00 2001
-From: Daniel Golle <daniel@makrotopia.org>
-Date: Sat, 17 May 2014 03:36:18 +0200
-Subject: [PATCH 1/5] ubi: auto-attach mtd device named "ubi" or "data" on boot
-To: openwrt-devel@lists.openwrt.org
-
-Signed-off-by: Daniel Golle <daniel@makrotopia.org>
----
- drivers/mtd/ubi/build.c | 36 ++++++++++++++++++++++++++++++++++++
- 1 file changed, 36 insertions(+)
-
---- a/drivers/mtd/ubi/build.c
-+++ b/drivers/mtd/ubi/build.c
-@@ -1223,6 +1223,49 @@ static struct mtd_info * __init open_mtd
- 	return mtd;
- }
- 
-+/*
-+ * This function tries attaching mtd partitions named either "ubi" or "data"
-+ * during boot.
-+ */
-+static void __init ubi_auto_attach(void)
-+{
-+	int err;
-+	struct mtd_info *mtd;
-+
-+	/* try attaching mtd device named "ubi" or "data" */
-+	mtd = open_mtd_device("ubi");
-+	if (IS_ERR(mtd))
-+		mtd = open_mtd_device("data");
-+
-+	if (!IS_ERR(mtd)) {
-+		size_t len;
-+		char magic[4];
-+
-+		/* check for a valid ubi magic */
-+		err = mtd_read(mtd, 0, 4, &len, (void *) magic);
-+		if (!err && len == 4 && strncmp(magic, "UBI#", 4)) {
-+			ubi_err("no valid UBI magic found inside mtd%d", mtd->index);
-+			put_mtd_device(mtd);
-+			return;
-+		}
-+
-+		/* auto-add only media types where UBI makes sense */
-+		if (mtd->type == MTD_NANDFLASH ||
-+		    mtd->type == MTD_NORFLASH ||
-+		    mtd->type == MTD_DATAFLASH ||
-+		    mtd->type == MTD_MLCNANDFLASH) {
-+			mutex_lock(&ubi_devices_mutex);
-+			ubi_msg("auto-attach mtd%d", mtd->index);
-+			err = ubi_attach_mtd_dev(mtd, UBI_DEV_NUM_AUTO, 0, 0);
-+			mutex_unlock(&ubi_devices_mutex);
-+			if (err < 0) {
-+				ubi_err("cannot attach mtd%d", mtd->index);
-+				put_mtd_device(mtd);
-+			}
-+		}
-+	}
-+}
-+
- static int __init ubi_init(void)
- {
- 	int err, i, k;
-@@ -1312,6 +1355,12 @@ static int __init ubi_init(void)
- 		}
- 	}
- 
-+	/* auto-attach mtd devices only if built-in to the kernel and no ubi.mtd
-+	 * parameter was given */
-+	if (config_enabled(CONFIG_MTD_ROOTFS_ROOT_DEV) &&
-+	    !ubi_is_module() && !mtd_devs)
-+		ubi_auto_attach();
-+
- 	err = ubiblock_init();
- 	if (err) {
- 		ubi_err("block: cannot initialize, error %d", err);
--- a/target/linux/generic/pending-3.18/491-ubi-auto-create-ubiblock-device-for-rootfs.patch	2022-03-22 08:54:47.310464841 +0800
+++ b/target/linux/generic/pending-3.18/491-ubi-auto-create-ubiblock-device-for-rootfs.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,69 +0,0 @@
-From 0f3966579815f889bb2fcb4846152c35f65e79c4 Mon Sep 17 00:00:00 2001
-From: Daniel Golle <daniel@makrotopia.org>
-Date: Thu, 15 May 2014 21:06:33 +0200
-Subject: [PATCH 2/5] ubi: auto-create ubiblock device for rootfs
-To: openwrt-devel@lists.openwrt.org
-
-Signed-off-by: Daniel Golle <daniel@makrotopia.org>
----
- drivers/mtd/ubi/block.c | 42 ++++++++++++++++++++++++++++++++++++++++++
- 1 file changed, 42 insertions(+)
-
---- a/drivers/mtd/ubi/block.c
-+++ b/drivers/mtd/ubi/block.c
-@@ -615,6 +615,44 @@ static int __init ubiblock_create_from_p
- 	return ret;
- }
- 
-+#define UBIFS_NODE_MAGIC  0x06101831
-+static inline int ubi_vol_is_ubifs(struct ubi_volume_desc *desc)
-+{
-+	int ret;
-+	uint32_t magic_of, magic;
-+	ret = ubi_read(desc, 0, (char *)&magic_of, 0, 4);
-+	if (ret)
-+		return 0;
-+	magic = le32_to_cpu(magic_of);
-+	return magic == UBIFS_NODE_MAGIC;
-+}
-+
-+static void __init ubiblock_create_auto_rootfs(void)
-+{
-+	int ubi_num, ret, is_ubifs;
-+	struct ubi_volume_desc *desc;
-+	struct ubi_volume_info vi;
-+
-+	for (ubi_num = 0; ubi_num < UBI_MAX_DEVICES; ubi_num++) {
-+		desc = ubi_open_volume_nm(ubi_num, "rootfs", UBI_READONLY);
-+		if (IS_ERR(desc))
-+			continue;
-+
-+		ubi_get_volume_info(desc, &vi);
-+		is_ubifs = ubi_vol_is_ubifs(desc);
-+		ubi_close_volume(desc);
-+		if (is_ubifs)
-+			break;
-+
-+		ret = ubiblock_create(&vi);
-+		if (ret)
-+			ubi_err("block: can't add '%s' volume, err=%d\n",
-+				vi.name, ret);
-+		/* always break if we get here */
-+		break;
-+	}
-+}
-+
- static void ubiblock_remove_all(void)
- {
- 	struct ubiblock *next;
-@@ -645,6 +683,10 @@ int __init ubiblock_init(void)
- 	if (ret)
- 		goto err_remove;
- 
-+	/* auto-attach "rootfs" volume if existing and non-ubifs */
-+	if (config_enabled(CONFIG_MTD_ROOTFS_ROOT_DEV))
-+		ubiblock_create_auto_rootfs();
-+
- 	/*
- 	 * Block devices are only created upon user requests, so we ignore
- 	 * existing volumes.
--- a/target/linux/generic/pending-3.18/492-try-auto-mounting-ubi0-rootfs-in-init-do_mounts.c.patch	2022-03-22 08:54:47.311464843 +0800
+++ b/target/linux/generic/pending-3.18/492-try-auto-mounting-ubi0-rootfs-in-init-do_mounts.c.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,54 +0,0 @@
-From eea9e1785e4c05c2a3444506aabafa0ae958538f Mon Sep 17 00:00:00 2001
-From: Daniel Golle <daniel@makrotopia.org>
-Date: Sat, 17 May 2014 03:35:02 +0200
-Subject: [PATCH 4/5] try auto-mounting ubi0:rootfs in init/do_mounts.c
-To: openwrt-devel@lists.openwrt.org
-
-Signed-off-by: Daniel Golle <daniel@makrotopia.org>
----
- init/do_mounts.c | 26 +++++++++++++++++++++++++-
- 1 file changed, 25 insertions(+), 1 deletion(-)
-
---- a/init/do_mounts.c
-+++ b/init/do_mounts.c
-@@ -433,7 +433,28 @@ retry:
- out:
- 	put_page(page);
- }
-- 
-+
-+static int __init mount_ubi_rootfs(void)
-+{
-+	int flags = MS_SILENT;
-+	int err, tried = 0;
-+
-+	while (tried < 2) {
-+		err = do_mount_root("ubi0:rootfs", "ubifs", flags, \
-+					root_mount_data);
-+		switch (err) {
-+			case -EACCES:
-+				flags |= MS_RDONLY;
-+				tried++;
-+				break;
-+			default:
-+				return err;
-+		}
-+	}
-+
-+	return -EINVAL;
-+}
-+
- #ifdef CONFIG_ROOT_NFS
- 
- #define NFSROOT_TIMEOUT_MIN	5
-@@ -527,6 +548,10 @@ void __init mount_root(void)
- 			change_floppy("root floppy");
- 	}
- #endif
-+#ifdef CONFIG_MTD_ROOTFS_ROOT_DEV
-+	if (!mount_ubi_rootfs())
-+		return;
-+#endif
- #ifdef CONFIG_BLOCK
- 	create_dev("/dev/root", ROOT_DEV);
- 	mount_block_root("/dev/root", root_mountflags);
--- a/target/linux/generic/pending-3.18/493-ubi-set-ROOT_DEV-to-ubiblock-rootfs-if-unset.patch	2022-03-22 08:54:47.311464843 +0800
+++ b/target/linux/generic/pending-3.18/493-ubi-set-ROOT_DEV-to-ubiblock-rootfs-if-unset.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,37 +0,0 @@
-From cd68d1b12b5ea4c01a664c064179ada42bf55d3d Mon Sep 17 00:00:00 2001
-From: Daniel Golle <daniel@makrotopia.org>
-Date: Thu, 15 May 2014 20:55:42 +0200
-Subject: [PATCH 5/5] ubi: set ROOT_DEV to ubiblock "rootfs" if unset
-To: openwrt-devel@lists.openwrt.org
-
-Signed-off-by: Daniel Golle <daniel@makrotopia.org>
----
- drivers/mtd/ubi/block.c | 10 ++++++++++
- 1 file changed, 10 insertions(+)
-
---- a/drivers/mtd/ubi/block.c
-+++ b/drivers/mtd/ubi/block.c
-@@ -48,6 +48,7 @@
- #include <linux/blkdev.h>
- #include <linux/hdreg.h>
- #include <asm/div64.h>
-+#include <linux/root_dev.h>
- 
- #include "ubi-media.h"
- #include "ubi.h"
-@@ -448,6 +449,15 @@ int ubiblock_create(struct ubi_volume_in
- 	add_disk(dev->gd);
- 	ubi_msg("%s created from ubi%d:%d(%s)",
- 		dev->gd->disk_name, dev->ubi_num, dev->vol_id, vi->name);
-+
-+	if (!strcmp(vi->name, "rootfs") &&
-+	    config_enabled(CONFIG_MTD_ROOTFS_ROOT_DEV) &&
-+	    ROOT_DEV == 0) {
-+		pr_notice("ubiblock: device ubiblock%d_%d (%s) set to be root filesystem\n",
-+			  dev->ubi_num, dev->vol_id, vi->name);
-+		ROOT_DEV = MKDEV(gd->major, gd->first_minor);
-+	}
-+
- 	return 0;
- 
- out_free_queue:
--- a/target/linux/generic/pending-3.18/494-mtd-ubi-add-EOF-marker-support.patch	2022-03-22 08:54:47.312464844 +0800
+++ b/target/linux/generic/pending-3.18/494-mtd-ubi-add-EOF-marker-support.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,51 +0,0 @@
---- a/drivers/mtd/ubi/attach.c
-+++ b/drivers/mtd/ubi/attach.c
-@@ -800,6 +800,13 @@ out_unlock:
- 	return err;
- }
- 
-+static bool ec_hdr_has_eof(struct ubi_ec_hdr *ech)
-+{
-+	return ech->padding1[0] == 'E' &&
-+	       ech->padding1[1] == 'O' &&
-+	       ech->padding1[2] == 'F';
-+}
-+
- /**
-  * scan_peb - scan and process UBI headers of a PEB.
-  * @ubi: UBI device description object
-@@ -830,9 +837,21 @@ static int scan_peb(struct ubi_device *u
- 		return 0;
- 	}
- 
--	err = ubi_io_read_ec_hdr(ubi, pnum, ech, 0);
--	if (err < 0)
--		return err;
-+	if (!ai->eof_found) {
-+		err = ubi_io_read_ec_hdr(ubi, pnum, ech, 0);
-+		if (err < 0)
-+			return err;
-+
-+		if (ec_hdr_has_eof(ech)) {
-+			ubi_msg("EOF marker found, PEBs from %d will be erased",
-+				pnum);
-+			ai->eof_found = true;
-+		}
-+	}
-+
-+	if (ai->eof_found)
-+		err = UBI_IO_FF_BITFLIPS;
-+
- 	switch (err) {
- 	case 0:
- 		break;
---- a/drivers/mtd/ubi/ubi.h
-+++ b/drivers/mtd/ubi/ubi.h
-@@ -705,6 +705,7 @@ struct ubi_attach_info {
- 	int mean_ec;
- 	uint64_t ec_sum;
- 	int ec_count;
-+	bool eof_found;
- 	struct kmem_cache *aeb_slab_cache;
- };
- 
--- a/target/linux/generic/pending-3.18/530-jffs2_make_lzma_available.patch	2022-03-22 08:54:47.317464853 +0800
+++ b/target/linux/generic/pending-3.18/530-jffs2_make_lzma_available.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,5142 +0,0 @@
---- a/fs/jffs2/Kconfig
-+++ b/fs/jffs2/Kconfig
-@@ -139,6 +139,15 @@ config JFFS2_LZO
- 	  This feature was added in July, 2007. Say 'N' if you need
- 	  compatibility with older bootloaders or kernels.
- 
-+config JFFS2_LZMA
-+	bool "JFFS2 LZMA compression support" if JFFS2_COMPRESSION_OPTIONS
-+	select LZMA_COMPRESS
-+	select LZMA_DECOMPRESS
-+	depends on JFFS2_FS
-+	default n
-+	help
-+	  JFFS2 wrapper to the LZMA C SDK
-+
- config JFFS2_RTIME
- 	bool "JFFS2 RTIME compression support" if JFFS2_COMPRESSION_OPTIONS
- 	depends on JFFS2_FS
---- a/fs/jffs2/Makefile
-+++ b/fs/jffs2/Makefile
-@@ -18,4 +18,7 @@ jffs2-$(CONFIG_JFFS2_RUBIN)	+= compr_rub
- jffs2-$(CONFIG_JFFS2_RTIME)	+= compr_rtime.o
- jffs2-$(CONFIG_JFFS2_ZLIB)	+= compr_zlib.o
- jffs2-$(CONFIG_JFFS2_LZO)	+= compr_lzo.o
-+jffs2-$(CONFIG_JFFS2_LZMA)      += compr_lzma.o
- jffs2-$(CONFIG_JFFS2_SUMMARY)   += summary.o
-+
-+CFLAGS_compr_lzma.o += -Iinclude/linux -Ilib/lzma
---- a/fs/jffs2/compr.c
-+++ b/fs/jffs2/compr.c
-@@ -378,6 +378,9 @@ int __init jffs2_compressors_init(void)
- #ifdef CONFIG_JFFS2_LZO
- 	jffs2_lzo_init();
- #endif
-+#ifdef CONFIG_JFFS2_LZMA
-+        jffs2_lzma_init();
-+#endif
- /* Setting default compression mode */
- #ifdef CONFIG_JFFS2_CMODE_NONE
- 	jffs2_compression_mode = JFFS2_COMPR_MODE_NONE;
-@@ -401,6 +404,9 @@ int __init jffs2_compressors_init(void)
- int jffs2_compressors_exit(void)
- {
- /* Unregistering compressors */
-+#ifdef CONFIG_JFFS2_LZMA
-+        jffs2_lzma_exit();
-+#endif
- #ifdef CONFIG_JFFS2_LZO
- 	jffs2_lzo_exit();
- #endif
---- a/fs/jffs2/compr.h
-+++ b/fs/jffs2/compr.h
-@@ -29,9 +29,9 @@
- #define JFFS2_DYNRUBIN_PRIORITY  20
- #define JFFS2_LZARI_PRIORITY     30
- #define JFFS2_RTIME_PRIORITY     50
--#define JFFS2_ZLIB_PRIORITY      60
--#define JFFS2_LZO_PRIORITY       80
--
-+#define JFFS2_LZMA_PRIORITY      70
-+#define JFFS2_ZLIB_PRIORITY      80
-+#define JFFS2_LZO_PRIORITY       90
- 
- #define JFFS2_RUBINMIPS_DISABLED /* RUBINs will be used only */
- #define JFFS2_DYNRUBIN_DISABLED  /*	   for decompression */
-@@ -101,5 +101,9 @@ void jffs2_zlib_exit(void);
- int jffs2_lzo_init(void);
- void jffs2_lzo_exit(void);
- #endif
-+#ifdef CONFIG_JFFS2_LZMA
-+int jffs2_lzma_init(void);
-+void jffs2_lzma_exit(void);
-+#endif
- 
- #endif /* __JFFS2_COMPR_H__ */
---- /dev/null
-+++ b/fs/jffs2/compr_lzma.c
-@@ -0,0 +1,128 @@
-+/*
-+ * JFFS2 -- Journalling Flash File System, Version 2.
-+ *
-+ * For licensing information, see the file 'LICENCE' in this directory.
-+ *
-+ * JFFS2 wrapper to the LZMA C SDK
-+ *
-+ */
-+
-+#include <linux/lzma.h>
-+#include "compr.h"
-+
-+#ifdef __KERNEL__
-+	static DEFINE_MUTEX(deflate_mutex);
-+#endif
-+
-+CLzmaEncHandle *p;
-+Byte propsEncoded[LZMA_PROPS_SIZE];
-+SizeT propsSize = sizeof(propsEncoded);
-+
-+STATIC void lzma_free_workspace(void)
-+{
-+	LzmaEnc_Destroy(p, &lzma_alloc, &lzma_alloc);
-+}
-+
-+STATIC int INIT lzma_alloc_workspace(CLzmaEncProps *props)
-+{
-+	if ((p = (CLzmaEncHandle *)LzmaEnc_Create(&lzma_alloc)) == NULL)
-+	{
-+		PRINT_ERROR("Failed to allocate lzma deflate workspace\n");
-+		return -ENOMEM;
-+	}
-+
-+	if (LzmaEnc_SetProps(p, props) != SZ_OK)
-+	{
-+		lzma_free_workspace();
-+		return -1;
-+	}
-+	
-+	if (LzmaEnc_WriteProperties(p, propsEncoded, &propsSize) != SZ_OK)
-+	{
-+		lzma_free_workspace();
-+		return -1;
-+	}
-+
-+        return 0;
-+}
-+
-+STATIC int jffs2_lzma_compress(unsigned char *data_in, unsigned char *cpage_out,
-+			      uint32_t *sourcelen, uint32_t *dstlen)
-+{
-+	SizeT compress_size = (SizeT)(*dstlen);
-+	int ret;
-+
-+	#ifdef __KERNEL__
-+		mutex_lock(&deflate_mutex);
-+	#endif
-+
-+	ret = LzmaEnc_MemEncode(p, cpage_out, &compress_size, data_in, *sourcelen,
-+		0, NULL, &lzma_alloc, &lzma_alloc);
-+
-+	#ifdef __KERNEL__
-+		mutex_unlock(&deflate_mutex);
-+	#endif
-+
-+	if (ret != SZ_OK)
-+		return -1;
-+
-+	*dstlen = (uint32_t)compress_size;
-+
-+	return 0;
-+}
-+
-+STATIC int jffs2_lzma_decompress(unsigned char *data_in, unsigned char *cpage_out,
-+				 uint32_t srclen, uint32_t destlen)
-+{
-+	int ret;
-+	SizeT dl = (SizeT)destlen;
-+	SizeT sl = (SizeT)srclen;
-+	ELzmaStatus status;
-+	
-+	ret = LzmaDecode(cpage_out, &dl, data_in, &sl, propsEncoded,
-+		propsSize, LZMA_FINISH_ANY, &status, &lzma_alloc);
-+
-+	if (ret != SZ_OK || status == LZMA_STATUS_NOT_FINISHED || dl != (SizeT)destlen)
-+		return -1;
-+
-+	return 0;
-+}
-+
-+static struct jffs2_compressor jffs2_lzma_comp = {
-+	.priority = JFFS2_LZMA_PRIORITY,
-+	.name = "lzma",
-+	.compr = JFFS2_COMPR_LZMA,
-+	.compress = &jffs2_lzma_compress,
-+	.decompress = &jffs2_lzma_decompress,
-+	.disabled = 0,
-+};
-+
-+int INIT jffs2_lzma_init(void)
-+{
-+        int ret;
-+	CLzmaEncProps props;
-+	LzmaEncProps_Init(&props);
-+
-+        props.dictSize = LZMA_BEST_DICT(0x2000);
-+        props.level = LZMA_BEST_LEVEL;
-+        props.lc = LZMA_BEST_LC;
-+        props.lp = LZMA_BEST_LP;
-+        props.pb = LZMA_BEST_PB;
-+        props.fb = LZMA_BEST_FB;
-+
-+	ret = lzma_alloc_workspace(&props);
-+        if (ret < 0)
-+                return ret;
-+
-+	ret = jffs2_register_compressor(&jffs2_lzma_comp);
-+	if (ret)
-+		lzma_free_workspace();
-+	
-+        return ret;
-+}
-+
-+void jffs2_lzma_exit(void)
-+{
-+	jffs2_unregister_compressor(&jffs2_lzma_comp);
-+	lzma_free_workspace();
-+}
---- a/fs/jffs2/super.c
-+++ b/fs/jffs2/super.c
-@@ -374,14 +374,41 @@ static int __init init_jffs2_fs(void)
- 	BUILD_BUG_ON(sizeof(struct jffs2_raw_inode) != 68);
- 	BUILD_BUG_ON(sizeof(struct jffs2_raw_summary) != 32);
- 
--	pr_info("version 2.2."
-+	pr_info("version 2.2"
- #ifdef CONFIG_JFFS2_FS_WRITEBUFFER
- 	       " (NAND)"
- #endif
- #ifdef CONFIG_JFFS2_SUMMARY
--	       " (SUMMARY) "
-+	       " (SUMMARY)"
- #endif
--	       "  2001-2006 Red Hat, Inc.\n");
-+#ifdef CONFIG_JFFS2_ZLIB
-+	       " (ZLIB)"
-+#endif
-+#ifdef CONFIG_JFFS2_LZO
-+	       " (LZO)"
-+#endif
-+#ifdef CONFIG_JFFS2_LZMA
-+	       " (LZMA)"
-+#endif
-+#ifdef CONFIG_JFFS2_RTIME
-+	       " (RTIME)"
-+#endif
-+#ifdef CONFIG_JFFS2_RUBIN
-+	       " (RUBIN)"
-+#endif
-+#ifdef  CONFIG_JFFS2_CMODE_NONE
-+	       " (CMODE_NONE)"
-+#endif
-+#ifdef CONFIG_JFFS2_CMODE_PRIORITY
-+	       " (CMODE_PRIORITY)"
-+#endif
-+#ifdef CONFIG_JFFS2_CMODE_SIZE
-+	       " (CMODE_SIZE)"
-+#endif
-+#ifdef CONFIG_JFFS2_CMODE_FAVOURLZO
-+	       " (CMODE_FAVOURLZO)"
-+#endif
-+	       " (c) 2001-2006 Red Hat, Inc.\n");
- 
- 	jffs2_inode_cachep = kmem_cache_create("jffs2_i",
- 					     sizeof(struct jffs2_inode_info),
---- a/include/uapi/linux/jffs2.h
-+++ b/include/uapi/linux/jffs2.h
-@@ -46,6 +46,7 @@
- #define JFFS2_COMPR_DYNRUBIN	0x05
- #define JFFS2_COMPR_ZLIB	0x06
- #define JFFS2_COMPR_LZO		0x07
-+#define JFFS2_COMPR_LZMA	0x08
- /* Compatibility flags. */
- #define JFFS2_COMPAT_MASK 0xc000      /* What do to if an unknown nodetype is found */
- #define JFFS2_NODE_ACCURATE 0x2000
---- /dev/null
-+++ b/include/linux/lzma.h
-@@ -0,0 +1,62 @@
-+#ifndef __LZMA_H__
-+#define __LZMA_H__
-+
-+#ifdef __KERNEL__
-+	#include <linux/kernel.h>
-+	#include <linux/sched.h>
-+	#include <linux/slab.h>
-+	#include <linux/vmalloc.h>
-+	#include <linux/init.h>
-+	#define LZMA_MALLOC vmalloc
-+	#define LZMA_FREE vfree
-+	#define PRINT_ERROR(msg) printk(KERN_WARNING #msg)
-+	#define INIT __init
-+	#define STATIC static
-+#else
-+	#include <stdint.h>
-+	#include <stdlib.h>
-+	#include <stdio.h>
-+	#include <unistd.h>
-+	#include <string.h>
-+	#include <asm/types.h>
-+	#include <errno.h>
-+	#include <linux/jffs2.h>
-+	#ifndef PAGE_SIZE
-+		extern int page_size;
-+		#define PAGE_SIZE page_size
-+	#endif
-+	#define LZMA_MALLOC malloc
-+	#define LZMA_FREE free
-+	#define PRINT_ERROR(msg) fprintf(stderr, msg)
-+	#define INIT
-+	#define STATIC
-+#endif
-+
-+#include "lzma/LzmaDec.h"
-+#include "lzma/LzmaEnc.h"
-+
-+#define LZMA_BEST_LEVEL (9)
-+#define LZMA_BEST_LC    (0)
-+#define LZMA_BEST_LP    (0)
-+#define LZMA_BEST_PB    (0)
-+#define LZMA_BEST_FB  (273)
-+
-+#define LZMA_BEST_DICT(n) (((int)((n) / 2)) * 2)
-+
-+static void *p_lzma_malloc(void *p, size_t size)
-+{
-+        if (size == 0)
-+                return NULL;
-+
-+        return LZMA_MALLOC(size);
-+}
-+
-+static void p_lzma_free(void *p, void *address)
-+{
-+        if (address != NULL)
-+                LZMA_FREE(address);
-+}
-+
-+static ISzAlloc lzma_alloc = {p_lzma_malloc, p_lzma_free};
-+
-+#endif
---- /dev/null
-+++ b/include/linux/lzma/LzFind.h
-@@ -0,0 +1,115 @@
-+/* LzFind.h -- Match finder for LZ algorithms
-+2009-04-22 : Igor Pavlov : Public domain */
-+
-+#ifndef __LZ_FIND_H
-+#define __LZ_FIND_H
-+
-+#include "Types.h"
-+
-+#ifdef __cplusplus
-+extern "C" {
-+#endif
-+
-+typedef UInt32 CLzRef;
-+
-+typedef struct _CMatchFinder
-+{
-+  Byte *buffer;
-+  UInt32 pos;
-+  UInt32 posLimit;
-+  UInt32 streamPos;
-+  UInt32 lenLimit;
-+
-+  UInt32 cyclicBufferPos;
-+  UInt32 cyclicBufferSize; /* it must be = (historySize + 1) */
-+
-+  UInt32 matchMaxLen;
-+  CLzRef *hash;
-+  CLzRef *son;
-+  UInt32 hashMask;
-+  UInt32 cutValue;
-+
-+  Byte *bufferBase;
-+  ISeqInStream *stream;
-+  int streamEndWasReached;
-+
-+  UInt32 blockSize;
-+  UInt32 keepSizeBefore;
-+  UInt32 keepSizeAfter;
-+
-+  UInt32 numHashBytes;
-+  int directInput;
-+  size_t directInputRem;
-+  int btMode;
-+  int bigHash;
-+  UInt32 historySize;
-+  UInt32 fixedHashSize;
-+  UInt32 hashSizeSum;
-+  UInt32 numSons;
-+  SRes result;
-+  UInt32 crc[256];
-+} CMatchFinder;
-+
-+#define Inline_MatchFinder_GetPointerToCurrentPos(p) ((p)->buffer)
-+#define Inline_MatchFinder_GetIndexByte(p, index) ((p)->buffer[(Int32)(index)])
-+
-+#define Inline_MatchFinder_GetNumAvailableBytes(p) ((p)->streamPos - (p)->pos)
-+
-+int MatchFinder_NeedMove(CMatchFinder *p);
-+Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p);
-+void MatchFinder_MoveBlock(CMatchFinder *p);
-+void MatchFinder_ReadIfRequired(CMatchFinder *p);
-+
-+void MatchFinder_Construct(CMatchFinder *p);
-+
-+/* Conditions:
-+     historySize <= 3 GB
-+     keepAddBufferBefore + matchMaxLen + keepAddBufferAfter < 511MB
-+*/
-+int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
-+    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
-+    ISzAlloc *alloc);
-+void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc);
-+void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems);
-+void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue);
-+
-+UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *buffer, CLzRef *son,
-+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
-+    UInt32 *distances, UInt32 maxLen);
-+
-+/*
-+Conditions:
-+  Mf_GetNumAvailableBytes_Func must be called before each Mf_GetMatchLen_Func.
-+  Mf_GetPointerToCurrentPos_Func's result must be used only before any other function
-+*/
-+
-+typedef void (*Mf_Init_Func)(void *object);
-+typedef Byte (*Mf_GetIndexByte_Func)(void *object, Int32 index);
-+typedef UInt32 (*Mf_GetNumAvailableBytes_Func)(void *object);
-+typedef const Byte * (*Mf_GetPointerToCurrentPos_Func)(void *object);
-+typedef UInt32 (*Mf_GetMatches_Func)(void *object, UInt32 *distances);
-+typedef void (*Mf_Skip_Func)(void *object, UInt32);
-+
-+typedef struct _IMatchFinder
-+{
-+  Mf_Init_Func Init;
-+  Mf_GetIndexByte_Func GetIndexByte;
-+  Mf_GetNumAvailableBytes_Func GetNumAvailableBytes;
-+  Mf_GetPointerToCurrentPos_Func GetPointerToCurrentPos;
-+  Mf_GetMatches_Func GetMatches;
-+  Mf_Skip_Func Skip;
-+} IMatchFinder;
-+
-+void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable);
-+
-+void MatchFinder_Init(CMatchFinder *p);
-+UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
-+UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
-+void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
-+void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
-+
-+#ifdef __cplusplus
-+}
-+#endif
-+
-+#endif
---- /dev/null
-+++ b/include/linux/lzma/LzHash.h
-@@ -0,0 +1,54 @@
-+/* LzHash.h -- HASH functions for LZ algorithms
-+2009-02-07 : Igor Pavlov : Public domain */
-+
-+#ifndef __LZ_HASH_H
-+#define __LZ_HASH_H
-+
-+#define kHash2Size (1 << 10)
-+#define kHash3Size (1 << 16)
-+#define kHash4Size (1 << 20)
-+
-+#define kFix3HashSize (kHash2Size)
-+#define kFix4HashSize (kHash2Size + kHash3Size)
-+#define kFix5HashSize (kHash2Size + kHash3Size + kHash4Size)
-+
-+#define HASH2_CALC hashValue = cur[0] | ((UInt32)cur[1] << 8);
-+
-+#define HASH3_CALC { \
-+  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
-+  hash2Value = temp & (kHash2Size - 1); \
-+  hashValue = (temp ^ ((UInt32)cur[2] << 8)) & p->hashMask; }
-+
-+#define HASH4_CALC { \
-+  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
-+  hash2Value = temp & (kHash2Size - 1); \
-+  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
-+  hashValue = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)) & p->hashMask; }
-+
-+#define HASH5_CALC { \
-+  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
-+  hash2Value = temp & (kHash2Size - 1); \
-+  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
-+  hash4Value = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)); \
-+  hashValue = (hash4Value ^ (p->crc[cur[4]] << 3)) & p->hashMask; \
-+  hash4Value &= (kHash4Size - 1); }
-+
-+/* #define HASH_ZIP_CALC hashValue = ((cur[0] | ((UInt32)cur[1] << 8)) ^ p->crc[cur[2]]) & 0xFFFF; */
-+#define HASH_ZIP_CALC hashValue = ((cur[2] | ((UInt32)cur[0] << 8)) ^ p->crc[cur[1]]) & 0xFFFF;
-+
-+
-+#define MT_HASH2_CALC \
-+  hash2Value = (p->crc[cur[0]] ^ cur[1]) & (kHash2Size - 1);
-+
-+#define MT_HASH3_CALC { \
-+  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
-+  hash2Value = temp & (kHash2Size - 1); \
-+  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); }
-+
-+#define MT_HASH4_CALC { \
-+  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
-+  hash2Value = temp & (kHash2Size - 1); \
-+  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
-+  hash4Value = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)) & (kHash4Size - 1); }
-+
-+#endif
---- /dev/null
-+++ b/include/linux/lzma/LzmaDec.h
-@@ -0,0 +1,231 @@
-+/* LzmaDec.h -- LZMA Decoder
-+2009-02-07 : Igor Pavlov : Public domain */
-+
-+#ifndef __LZMA_DEC_H
-+#define __LZMA_DEC_H
-+
-+#include "Types.h"
-+
-+#ifdef __cplusplus
-+extern "C" {
-+#endif
-+
-+/* #define _LZMA_PROB32 */
-+/* _LZMA_PROB32 can increase the speed on some CPUs,
-+   but memory usage for CLzmaDec::probs will be doubled in that case */
-+
-+#ifdef _LZMA_PROB32
-+#define CLzmaProb UInt32
-+#else
-+#define CLzmaProb UInt16
-+#endif
-+
-+
-+/* ---------- LZMA Properties ---------- */
-+
-+#define LZMA_PROPS_SIZE 5
-+
-+typedef struct _CLzmaProps
-+{
-+  unsigned lc, lp, pb;
-+  UInt32 dicSize;
-+} CLzmaProps;
-+
-+/* LzmaProps_Decode - decodes properties
-+Returns:
-+  SZ_OK
-+  SZ_ERROR_UNSUPPORTED - Unsupported properties
-+*/
-+
-+SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size);
-+
-+
-+/* ---------- LZMA Decoder state ---------- */
-+
-+/* LZMA_REQUIRED_INPUT_MAX = number of required input bytes for worst case.
-+   Num bits = log2((2^11 / 31) ^ 22) + 26 < 134 + 26 = 160; */
-+
-+#define LZMA_REQUIRED_INPUT_MAX 20
-+
-+typedef struct
-+{
-+  CLzmaProps prop;
-+  CLzmaProb *probs;
-+  Byte *dic;
-+  const Byte *buf;
-+  UInt32 range, code;
-+  SizeT dicPos;
-+  SizeT dicBufSize;
-+  UInt32 processedPos;
-+  UInt32 checkDicSize;
-+  unsigned state;
-+  UInt32 reps[4];
-+  unsigned remainLen;
-+  int needFlush;
-+  int needInitState;
-+  UInt32 numProbs;
-+  unsigned tempBufSize;
-+  Byte tempBuf[LZMA_REQUIRED_INPUT_MAX];
-+} CLzmaDec;
-+
-+#define LzmaDec_Construct(p) { (p)->dic = 0; (p)->probs = 0; }
-+
-+void LzmaDec_Init(CLzmaDec *p);
-+
-+/* There are two types of LZMA streams:
-+     0) Stream with end mark. That end mark adds about 6 bytes to compressed size.
-+     1) Stream without end mark. You must know exact uncompressed size to decompress such stream. */
-+
-+typedef enum
-+{
-+  LZMA_FINISH_ANY,   /* finish at any point */
-+  LZMA_FINISH_END    /* block must be finished at the end */
-+} ELzmaFinishMode;
-+
-+/* ELzmaFinishMode has meaning only if the decoding reaches output limit !!!
-+
-+   You must use LZMA_FINISH_END, when you know that current output buffer
-+   covers last bytes of block. In other cases you must use LZMA_FINISH_ANY.
-+
-+   If LZMA decoder sees end marker before reaching output limit, it returns SZ_OK,
-+   and output value of destLen will be less than output buffer size limit.
-+   You can check status result also.
-+
-+   You can use multiple checks to test data integrity after full decompression:
-+     1) Check Result and "status" variable.
-+     2) Check that output(destLen) = uncompressedSize, if you know real uncompressedSize.
-+     3) Check that output(srcLen) = compressedSize, if you know real compressedSize.
-+        You must use correct finish mode in that case. */
-+
-+typedef enum
-+{
-+  LZMA_STATUS_NOT_SPECIFIED,               /* use main error code instead */
-+  LZMA_STATUS_FINISHED_WITH_MARK,          /* stream was finished with end mark. */
-+  LZMA_STATUS_NOT_FINISHED,                /* stream was not finished */
-+  LZMA_STATUS_NEEDS_MORE_INPUT,            /* you must provide more input bytes */
-+  LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK  /* there is probability that stream was finished without end mark */
-+} ELzmaStatus;
-+
-+/* ELzmaStatus is used only as output value for function call */
-+
-+
-+/* ---------- Interfaces ---------- */
-+
-+/* There are 3 levels of interfaces:
-+     1) Dictionary Interface
-+     2) Buffer Interface
-+     3) One Call Interface
-+   You can select any of these interfaces, but don't mix functions from different
-+   groups for same object. */
-+
-+
-+/* There are two variants to allocate state for Dictionary Interface:
-+     1) LzmaDec_Allocate / LzmaDec_Free
-+     2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs
-+   You can use variant 2, if you set dictionary buffer manually.
-+   For Buffer Interface you must always use variant 1.
-+
-+LzmaDec_Allocate* can return:
-+  SZ_OK
-+  SZ_ERROR_MEM         - Memory allocation error
-+  SZ_ERROR_UNSUPPORTED - Unsupported properties
-+*/
-+   
-+SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc);
-+void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc);
-+
-+SRes LzmaDec_Allocate(CLzmaDec *state, const Byte *prop, unsigned propsSize, ISzAlloc *alloc);
-+void LzmaDec_Free(CLzmaDec *state, ISzAlloc *alloc);
-+
-+/* ---------- Dictionary Interface ---------- */
-+
-+/* You can use it, if you want to eliminate the overhead for data copying from
-+   dictionary to some other external buffer.
-+   You must work with CLzmaDec variables directly in this interface.
-+
-+   STEPS:
-+     LzmaDec_Constr()
-+     LzmaDec_Allocate()
-+     for (each new stream)
-+     {
-+       LzmaDec_Init()
-+       while (it needs more decompression)
-+       {
-+         LzmaDec_DecodeToDic()
-+         use data from CLzmaDec::dic and update CLzmaDec::dicPos
-+       }
-+     }
-+     LzmaDec_Free()
-+*/
-+
-+/* LzmaDec_DecodeToDic
-+   
-+   The decoding to internal dictionary buffer (CLzmaDec::dic).
-+   You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!
-+
-+finishMode:
-+  It has meaning only if the decoding reaches output limit (dicLimit).
-+  LZMA_FINISH_ANY - Decode just dicLimit bytes.
-+  LZMA_FINISH_END - Stream must be finished after dicLimit.
-+
-+Returns:
-+  SZ_OK
-+    status:
-+      LZMA_STATUS_FINISHED_WITH_MARK
-+      LZMA_STATUS_NOT_FINISHED
-+      LZMA_STATUS_NEEDS_MORE_INPUT
-+      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
-+  SZ_ERROR_DATA - Data error
-+*/
-+
-+SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit,
-+    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
-+
-+
-+/* ---------- Buffer Interface ---------- */
-+
-+/* It's zlib-like interface.
-+   See LzmaDec_DecodeToDic description for information about STEPS and return results,
-+   but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need
-+   to work with CLzmaDec variables manually.
-+
-+finishMode:
-+  It has meaning only if the decoding reaches output limit (*destLen).
-+  LZMA_FINISH_ANY - Decode just destLen bytes.
-+  LZMA_FINISH_END - Stream must be finished after (*destLen).
-+*/
-+
-+SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen,
-+    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
-+
-+
-+/* ---------- One Call Interface ---------- */
-+
-+/* LzmaDecode
-+
-+finishMode:
-+  It has meaning only if the decoding reaches output limit (*destLen).
-+  LZMA_FINISH_ANY - Decode just destLen bytes.
-+  LZMA_FINISH_END - Stream must be finished after (*destLen).
-+
-+Returns:
-+  SZ_OK
-+    status:
-+      LZMA_STATUS_FINISHED_WITH_MARK
-+      LZMA_STATUS_NOT_FINISHED
-+      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
-+  SZ_ERROR_DATA - Data error
-+  SZ_ERROR_MEM  - Memory allocation error
-+  SZ_ERROR_UNSUPPORTED - Unsupported properties
-+  SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
-+*/
-+
-+SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
-+    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
-+    ELzmaStatus *status, ISzAlloc *alloc);
-+
-+#ifdef __cplusplus
-+}
-+#endif
-+
-+#endif
---- /dev/null
-+++ b/include/linux/lzma/LzmaEnc.h
-@@ -0,0 +1,80 @@
-+/*  LzmaEnc.h -- LZMA Encoder
-+2009-02-07 : Igor Pavlov : Public domain */
-+
-+#ifndef __LZMA_ENC_H
-+#define __LZMA_ENC_H
-+
-+#include "Types.h"
-+
-+#ifdef __cplusplus
-+extern "C" {
-+#endif
-+
-+#define LZMA_PROPS_SIZE 5
-+
-+typedef struct _CLzmaEncProps
-+{
-+  int level;       /*  0 <= level <= 9 */
-+  UInt32 dictSize; /* (1 << 12) <= dictSize <= (1 << 27) for 32-bit version
-+                      (1 << 12) <= dictSize <= (1 << 30) for 64-bit version
-+                       default = (1 << 24) */
-+  int lc;          /* 0 <= lc <= 8, default = 3 */
-+  int lp;          /* 0 <= lp <= 4, default = 0 */
-+  int pb;          /* 0 <= pb <= 4, default = 2 */
-+  int algo;        /* 0 - fast, 1 - normal, default = 1 */
-+  int fb;          /* 5 <= fb <= 273, default = 32 */
-+  int btMode;      /* 0 - hashChain Mode, 1 - binTree mode - normal, default = 1 */
-+  int numHashBytes; /* 2, 3 or 4, default = 4 */
-+  UInt32 mc;        /* 1 <= mc <= (1 << 30), default = 32 */
-+  unsigned writeEndMark;  /* 0 - do not write EOPM, 1 - write EOPM, default = 0 */
-+  int numThreads;  /* 1 or 2, default = 2 */
-+} CLzmaEncProps;
-+
-+void LzmaEncProps_Init(CLzmaEncProps *p);
-+void LzmaEncProps_Normalize(CLzmaEncProps *p);
-+UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2);
-+
-+
-+/* ---------- CLzmaEncHandle Interface ---------- */
-+
-+/* LzmaEnc_* functions can return the following exit codes:
-+Returns:
-+  SZ_OK           - OK
-+  SZ_ERROR_MEM    - Memory allocation error
-+  SZ_ERROR_PARAM  - Incorrect paramater in props
-+  SZ_ERROR_WRITE  - Write callback error.
-+  SZ_ERROR_PROGRESS - some break from progress callback
-+  SZ_ERROR_THREAD - errors in multithreading functions (only for Mt version)
-+*/
-+
-+typedef void * CLzmaEncHandle;
-+
-+CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc);
-+void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig);
-+SRes LzmaEnc_SetProps(CLzmaEncHandle p, const CLzmaEncProps *props);
-+SRes LzmaEnc_WriteProperties(CLzmaEncHandle p, Byte *properties, SizeT *size);
-+SRes LzmaEnc_Encode(CLzmaEncHandle p, ISeqOutStream *outStream, ISeqInStream *inStream,
-+    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
-+SRes LzmaEnc_MemEncode(CLzmaEncHandle p, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-+    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
-+
-+/* ---------- One Call Interface ---------- */
-+
-+/* LzmaEncode
-+Return code:
-+  SZ_OK               - OK
-+  SZ_ERROR_MEM        - Memory allocation error
-+  SZ_ERROR_PARAM      - Incorrect paramater
-+  SZ_ERROR_OUTPUT_EOF - output buffer overflow
-+  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
-+*/
-+
-+SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-+    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
-+    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
-+
-+#ifdef __cplusplus
-+}
-+#endif
-+
-+#endif
---- /dev/null
-+++ b/include/linux/lzma/Types.h
-@@ -0,0 +1,226 @@
-+/* Types.h -- Basic types
-+2009-11-23 : Igor Pavlov : Public domain */
-+
-+#ifndef __7Z_TYPES_H
-+#define __7Z_TYPES_H
-+
-+#include <stddef.h>
-+
-+#ifdef _WIN32
-+#include <windows.h>
-+#endif
-+
-+#ifndef EXTERN_C_BEGIN
-+#ifdef __cplusplus
-+#define EXTERN_C_BEGIN extern "C" {
-+#define EXTERN_C_END }
-+#else
-+#define EXTERN_C_BEGIN
-+#define EXTERN_C_END
-+#endif
-+#endif
-+
-+EXTERN_C_BEGIN
-+
-+#define SZ_OK 0
-+
-+#define SZ_ERROR_DATA 1
-+#define SZ_ERROR_MEM 2
-+#define SZ_ERROR_CRC 3
-+#define SZ_ERROR_UNSUPPORTED 4
-+#define SZ_ERROR_PARAM 5
-+#define SZ_ERROR_INPUT_EOF 6
-+#define SZ_ERROR_OUTPUT_EOF 7
-+#define SZ_ERROR_READ 8
-+#define SZ_ERROR_WRITE 9
-+#define SZ_ERROR_PROGRESS 10
-+#define SZ_ERROR_FAIL 11
-+#define SZ_ERROR_THREAD 12
-+
-+#define SZ_ERROR_ARCHIVE 16
-+#define SZ_ERROR_NO_ARCHIVE 17
-+
-+typedef int SRes;
-+
-+#ifdef _WIN32
-+typedef DWORD WRes;
-+#else
-+typedef int WRes;
-+#endif
-+
-+#ifndef RINOK
-+#define RINOK(x) { int __result__ = (x); if (__result__ != 0) return __result__; }
-+#endif
-+
-+typedef unsigned char Byte;
-+typedef short Int16;
-+typedef unsigned short UInt16;
-+
-+#ifdef _LZMA_UINT32_IS_ULONG
-+typedef long Int32;
-+typedef unsigned long UInt32;
-+#else
-+typedef int Int32;
-+typedef unsigned int UInt32;
-+#endif
-+
-+#ifdef _SZ_NO_INT_64
-+
-+/* define _SZ_NO_INT_64, if your compiler doesn't support 64-bit integers.
-+   NOTES: Some code will work incorrectly in that case! */
-+
-+typedef long Int64;
-+typedef unsigned long UInt64;
-+
-+#else
-+
-+#if defined(_MSC_VER) || defined(__BORLANDC__)
-+typedef __int64 Int64;
-+typedef unsigned __int64 UInt64;
-+#else
-+typedef long long int Int64;
-+typedef unsigned long long int UInt64;
-+#endif
-+
-+#endif
-+
-+#ifdef _LZMA_NO_SYSTEM_SIZE_T
-+typedef UInt32 SizeT;
-+#else
-+typedef size_t SizeT;
-+#endif
-+
-+typedef int Bool;
-+#define True 1
-+#define False 0
-+
-+
-+#ifdef _WIN32
-+#define MY_STD_CALL __stdcall
-+#else
-+#define MY_STD_CALL
-+#endif
-+
-+#ifdef _MSC_VER
-+
-+#if _MSC_VER >= 1300
-+#define MY_NO_INLINE __declspec(noinline)
-+#else
-+#define MY_NO_INLINE
-+#endif
-+
-+#define MY_CDECL __cdecl
-+#define MY_FAST_CALL __fastcall
-+
-+#else
-+
-+#define MY_CDECL
-+#define MY_FAST_CALL
-+
-+#endif
-+
-+
-+/* The following interfaces use first parameter as pointer to structure */
-+
-+typedef struct
-+{
-+  SRes (*Read)(void *p, void *buf, size_t *size);
-+    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
-+       (output(*size) < input(*size)) is allowed */
-+} ISeqInStream;
-+
-+/* it can return SZ_ERROR_INPUT_EOF */
-+SRes SeqInStream_Read(ISeqInStream *stream, void *buf, size_t size);
-+SRes SeqInStream_Read2(ISeqInStream *stream, void *buf, size_t size, SRes errorType);
-+SRes SeqInStream_ReadByte(ISeqInStream *stream, Byte *buf);
-+
-+typedef struct
-+{
-+  size_t (*Write)(void *p, const void *buf, size_t size);
-+    /* Returns: result - the number of actually written bytes.
-+       (result < size) means error */
-+} ISeqOutStream;
-+
-+typedef enum
-+{
-+  SZ_SEEK_SET = 0,
-+  SZ_SEEK_CUR = 1,
-+  SZ_SEEK_END = 2
-+} ESzSeek;
-+
-+typedef struct
-+{
-+  SRes (*Read)(void *p, void *buf, size_t *size);  /* same as ISeqInStream::Read */
-+  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
-+} ISeekInStream;
-+
-+typedef struct
-+{
-+  SRes (*Look)(void *p, void **buf, size_t *size);
-+    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
-+       (output(*size) > input(*size)) is not allowed
-+       (output(*size) < input(*size)) is allowed */
-+  SRes (*Skip)(void *p, size_t offset);
-+    /* offset must be <= output(*size) of Look */
-+
-+  SRes (*Read)(void *p, void *buf, size_t *size);
-+    /* reads directly (without buffer). It's same as ISeqInStream::Read */
-+  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
-+} ILookInStream;
-+
-+SRes LookInStream_LookRead(ILookInStream *stream, void *buf, size_t *size);
-+SRes LookInStream_SeekTo(ILookInStream *stream, UInt64 offset);
-+
-+/* reads via ILookInStream::Read */
-+SRes LookInStream_Read2(ILookInStream *stream, void *buf, size_t size, SRes errorType);
-+SRes LookInStream_Read(ILookInStream *stream, void *buf, size_t size);
-+
-+#define LookToRead_BUF_SIZE (1 << 14)
-+
-+typedef struct
-+{
-+  ILookInStream s;
-+  ISeekInStream *realStream;
-+  size_t pos;
-+  size_t size;
-+  Byte buf[LookToRead_BUF_SIZE];
-+} CLookToRead;
-+
-+void LookToRead_CreateVTable(CLookToRead *p, int lookahead);
-+void LookToRead_Init(CLookToRead *p);
-+
-+typedef struct
-+{
-+  ISeqInStream s;
-+  ILookInStream *realStream;
-+} CSecToLook;
-+
-+void SecToLook_CreateVTable(CSecToLook *p);
-+
-+typedef struct
-+{
-+  ISeqInStream s;
-+  ILookInStream *realStream;
-+} CSecToRead;
-+
-+void SecToRead_CreateVTable(CSecToRead *p);
-+
-+typedef struct
-+{
-+  SRes (*Progress)(void *p, UInt64 inSize, UInt64 outSize);
-+    /* Returns: result. (result != SZ_OK) means break.
-+       Value (UInt64)(Int64)-1 for size means unknown value. */
-+} ICompressProgress;
-+
-+typedef struct
-+{
-+  void *(*Alloc)(void *p, size_t size);
-+  void (*Free)(void *p, void *address); /* address can be 0 */
-+} ISzAlloc;
-+
-+#define IAlloc_Alloc(p, size) (p)->Alloc((p), size)
-+#define IAlloc_Free(p, a) (p)->Free((p), a)
-+
-+EXTERN_C_END
-+
-+#endif
---- a/lib/Kconfig
-+++ b/lib/Kconfig
-@@ -227,6 +227,12 @@ config LZ4_DECOMPRESS
- 
- source "lib/xz/Kconfig"
- 
-+config LZMA_COMPRESS
-+    tristate
-+
-+config LZMA_DECOMPRESS
-+    tristate
-+
- #
- # These all provide a common interface (hence the apparent duplication with
- # ZLIB_INFLATE; DECOMPRESS_GZIP is just a wrapper.)
---- a/lib/Makefile
-+++ b/lib/Makefile
-@@ -2,6 +2,16 @@
- # Makefile for some libs needed in the kernel.
- #
- 
-+ifdef CONFIG_JFFS2_ZLIB
-+	CONFIG_ZLIB_INFLATE:=y
-+	CONFIG_ZLIB_DEFLATE:=y
-+endif
-+
-+ifdef CONFIG_JFFS2_LZMA
-+	CONFIG_LZMA_DECOMPRESS:=y
-+	CONFIG_LZMA_COMPRESS:=y
-+endif
-+
- ifdef CONFIG_FUNCTION_TRACER
- ORIG_CFLAGS := $(KBUILD_CFLAGS)
- KBUILD_CFLAGS = $(subst -pg,,$(ORIG_CFLAGS))
-@@ -85,6 +95,8 @@ obj-$(CONFIG_LZ4HC_COMPRESS) += lz4/
- obj-$(CONFIG_LZ4_DECOMPRESS) += lz4/
- obj-$(CONFIG_XZ_DEC) += xz/
- obj-$(CONFIG_RAID6_PQ) += raid6/
-+obj-$(CONFIG_LZMA_COMPRESS) += lzma/
-+obj-$(CONFIG_LZMA_DECOMPRESS) += lzma/
- 
- lib-$(CONFIG_DECOMPRESS_GZIP) += decompress_inflate.o
- lib-$(CONFIG_DECOMPRESS_BZIP2) += decompress_bunzip2.o
---- /dev/null
-+++ b/lib/lzma/LzFind.c
-@@ -0,0 +1,761 @@
-+/* LzFind.c -- Match finder for LZ algorithms
-+2009-04-22 : Igor Pavlov : Public domain */
-+
-+#include <string.h>
-+
-+#include "LzFind.h"
-+#include "LzHash.h"
-+
-+#define kEmptyHashValue 0
-+#define kMaxValForNormalize ((UInt32)0xFFFFFFFF)
-+#define kNormalizeStepMin (1 << 10) /* it must be power of 2 */
-+#define kNormalizeMask (~(kNormalizeStepMin - 1))
-+#define kMaxHistorySize ((UInt32)3 << 30)
-+
-+#define kStartMaxLen 3
-+
-+static void LzInWindow_Free(CMatchFinder *p, ISzAlloc *alloc)
-+{
-+  if (!p->directInput)
-+  {
-+    alloc->Free(alloc, p->bufferBase);
-+    p->bufferBase = 0;
-+  }
-+}
-+
-+/* keepSizeBefore + keepSizeAfter + keepSizeReserv must be < 4G) */
-+
-+static int LzInWindow_Create(CMatchFinder *p, UInt32 keepSizeReserv, ISzAlloc *alloc)
-+{
-+  UInt32 blockSize = p->keepSizeBefore + p->keepSizeAfter + keepSizeReserv;
-+  if (p->directInput)
-+  {
-+    p->blockSize = blockSize;
-+    return 1;
-+  }
-+  if (p->bufferBase == 0 || p->blockSize != blockSize)
-+  {
-+    LzInWindow_Free(p, alloc);
-+    p->blockSize = blockSize;
-+    p->bufferBase = (Byte *)alloc->Alloc(alloc, (size_t)blockSize);
-+  }
-+  return (p->bufferBase != 0);
-+}
-+
-+Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }
-+Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p->buffer[index]; }
-+
-+UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }
-+
-+void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
-+{
-+  p->posLimit -= subValue;
-+  p->pos -= subValue;
-+  p->streamPos -= subValue;
-+}
-+
-+static void MatchFinder_ReadBlock(CMatchFinder *p)
-+{
-+  if (p->streamEndWasReached || p->result != SZ_OK)
-+    return;
-+  if (p->directInput)
-+  {
-+    UInt32 curSize = 0xFFFFFFFF - p->streamPos;
-+    if (curSize > p->directInputRem)
-+      curSize = (UInt32)p->directInputRem;
-+    p->directInputRem -= curSize;
-+    p->streamPos += curSize;
-+    if (p->directInputRem == 0)
-+      p->streamEndWasReached = 1;
-+    return;
-+  }
-+  for (;;)
-+  {
-+    Byte *dest = p->buffer + (p->streamPos - p->pos);
-+    size_t size = (p->bufferBase + p->blockSize - dest);
-+    if (size == 0)
-+      return;
-+    p->result = p->stream->Read(p->stream, dest, &size);
-+    if (p->result != SZ_OK)
-+      return;
-+    if (size == 0)
-+    {
-+      p->streamEndWasReached = 1;
-+      return;
-+    }
-+    p->streamPos += (UInt32)size;
-+    if (p->streamPos - p->pos > p->keepSizeAfter)
-+      return;
-+  }
-+}
-+
-+void MatchFinder_MoveBlock(CMatchFinder *p)
-+{
-+  memmove(p->bufferBase,
-+    p->buffer - p->keepSizeBefore,
-+    (size_t)(p->streamPos - p->pos + p->keepSizeBefore));
-+  p->buffer = p->bufferBase + p->keepSizeBefore;
-+}
-+
-+int MatchFinder_NeedMove(CMatchFinder *p)
-+{
-+  if (p->directInput)
-+    return 0;
-+  /* if (p->streamEndWasReached) return 0; */
-+  return ((size_t)(p->bufferBase + p->blockSize - p->buffer) <= p->keepSizeAfter);
-+}
-+
-+void MatchFinder_ReadIfRequired(CMatchFinder *p)
-+{
-+  if (p->streamEndWasReached)
-+    return;
-+  if (p->keepSizeAfter >= p->streamPos - p->pos)
-+    MatchFinder_ReadBlock(p);
-+}
-+
-+static void MatchFinder_CheckAndMoveAndRead(CMatchFinder *p)
-+{
-+  if (MatchFinder_NeedMove(p))
-+    MatchFinder_MoveBlock(p);
-+  MatchFinder_ReadBlock(p);
-+}
-+
-+static void MatchFinder_SetDefaultSettings(CMatchFinder *p)
-+{
-+  p->cutValue = 32;
-+  p->btMode = 1;
-+  p->numHashBytes = 4;
-+  p->bigHash = 0;
-+}
-+
-+#define kCrcPoly 0xEDB88320
-+
-+void MatchFinder_Construct(CMatchFinder *p)
-+{
-+  UInt32 i;
-+  p->bufferBase = 0;
-+  p->directInput = 0;
-+  p->hash = 0;
-+  MatchFinder_SetDefaultSettings(p);
-+
-+  for (i = 0; i < 256; i++)
-+  {
-+    UInt32 r = i;
-+    int j;
-+    for (j = 0; j < 8; j++)
-+      r = (r >> 1) ^ (kCrcPoly & ~((r & 1) - 1));
-+    p->crc[i] = r;
-+  }
-+}
-+
-+static void MatchFinder_FreeThisClassMemory(CMatchFinder *p, ISzAlloc *alloc)
-+{
-+  alloc->Free(alloc, p->hash);
-+  p->hash = 0;
-+}
-+
-+void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc)
-+{
-+  MatchFinder_FreeThisClassMemory(p, alloc);
-+  LzInWindow_Free(p, alloc);
-+}
-+
-+static CLzRef* AllocRefs(UInt32 num, ISzAlloc *alloc)
-+{
-+  size_t sizeInBytes = (size_t)num * sizeof(CLzRef);
-+  if (sizeInBytes / sizeof(CLzRef) != num)
-+    return 0;
-+  return (CLzRef *)alloc->Alloc(alloc, sizeInBytes);
-+}
-+
-+int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
-+    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
-+    ISzAlloc *alloc)
-+{
-+  UInt32 sizeReserv;
-+  if (historySize > kMaxHistorySize)
-+  {
-+    MatchFinder_Free(p, alloc);
-+    return 0;
-+  }
-+  sizeReserv = historySize >> 1;
-+  if (historySize > ((UInt32)2 << 30))
-+    sizeReserv = historySize >> 2;
-+  sizeReserv += (keepAddBufferBefore + matchMaxLen + keepAddBufferAfter) / 2 + (1 << 19);
-+
-+  p->keepSizeBefore = historySize + keepAddBufferBefore + 1;
-+  p->keepSizeAfter = matchMaxLen + keepAddBufferAfter;
-+  /* we need one additional byte, since we use MoveBlock after pos++ and before dictionary using */
-+  if (LzInWindow_Create(p, sizeReserv, alloc))
-+  {
-+    UInt32 newCyclicBufferSize = historySize + 1;
-+    UInt32 hs;
-+    p->matchMaxLen = matchMaxLen;
-+    {
-+      p->fixedHashSize = 0;
-+      if (p->numHashBytes == 2)
-+        hs = (1 << 16) - 1;
-+      else
-+      {
-+        hs = historySize - 1;
-+        hs |= (hs >> 1);
-+        hs |= (hs >> 2);
-+        hs |= (hs >> 4);
-+        hs |= (hs >> 8);
-+        hs >>= 1;
-+        hs |= 0xFFFF; /* don't change it! It's required for Deflate */
-+        if (hs > (1 << 24))
-+        {
-+          if (p->numHashBytes == 3)
-+            hs = (1 << 24) - 1;
-+          else
-+            hs >>= 1;
-+        }
-+      }
-+      p->hashMask = hs;
-+      hs++;
-+      if (p->numHashBytes > 2) p->fixedHashSize += kHash2Size;
-+      if (p->numHashBytes > 3) p->fixedHashSize += kHash3Size;
-+      if (p->numHashBytes > 4) p->fixedHashSize += kHash4Size;
-+      hs += p->fixedHashSize;
-+    }
-+
-+    {
-+      UInt32 prevSize = p->hashSizeSum + p->numSons;
-+      UInt32 newSize;
-+      p->historySize = historySize;
-+      p->hashSizeSum = hs;
-+      p->cyclicBufferSize = newCyclicBufferSize;
-+      p->numSons = (p->btMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);
-+      newSize = p->hashSizeSum + p->numSons;
-+      if (p->hash != 0 && prevSize == newSize)
-+        return 1;
-+      MatchFinder_FreeThisClassMemory(p, alloc);
-+      p->hash = AllocRefs(newSize, alloc);
-+      if (p->hash != 0)
-+      {
-+        p->son = p->hash + p->hashSizeSum;
-+        return 1;
-+      }
-+    }
-+  }
-+  MatchFinder_Free(p, alloc);
-+  return 0;
-+}
-+
-+static void MatchFinder_SetLimits(CMatchFinder *p)
-+{
-+  UInt32 limit = kMaxValForNormalize - p->pos;
-+  UInt32 limit2 = p->cyclicBufferSize - p->cyclicBufferPos;
-+  if (limit2 < limit)
-+    limit = limit2;
-+  limit2 = p->streamPos - p->pos;
-+  if (limit2 <= p->keepSizeAfter)
-+  {
-+    if (limit2 > 0)
-+      limit2 = 1;
-+  }
-+  else
-+    limit2 -= p->keepSizeAfter;
-+  if (limit2 < limit)
-+    limit = limit2;
-+  {
-+    UInt32 lenLimit = p->streamPos - p->pos;
-+    if (lenLimit > p->matchMaxLen)
-+      lenLimit = p->matchMaxLen;
-+    p->lenLimit = lenLimit;
-+  }
-+  p->posLimit = p->pos + limit;
-+}
-+
-+void MatchFinder_Init(CMatchFinder *p)
-+{
-+  UInt32 i;
-+  for (i = 0; i < p->hashSizeSum; i++)
-+    p->hash[i] = kEmptyHashValue;
-+  p->cyclicBufferPos = 0;
-+  p->buffer = p->bufferBase;
-+  p->pos = p->streamPos = p->cyclicBufferSize;
-+  p->result = SZ_OK;
-+  p->streamEndWasReached = 0;
-+  MatchFinder_ReadBlock(p);
-+  MatchFinder_SetLimits(p);
-+}
-+
-+static UInt32 MatchFinder_GetSubValue(CMatchFinder *p)
-+{
-+  return (p->pos - p->historySize - 1) & kNormalizeMask;
-+}
-+
-+void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems)
-+{
-+  UInt32 i;
-+  for (i = 0; i < numItems; i++)
-+  {
-+    UInt32 value = items[i];
-+    if (value <= subValue)
-+      value = kEmptyHashValue;
-+    else
-+      value -= subValue;
-+    items[i] = value;
-+  }
-+}
-+
-+static void MatchFinder_Normalize(CMatchFinder *p)
-+{
-+  UInt32 subValue = MatchFinder_GetSubValue(p);
-+  MatchFinder_Normalize3(subValue, p->hash, p->hashSizeSum + p->numSons);
-+  MatchFinder_ReduceOffsets(p, subValue);
-+}
-+
-+static void MatchFinder_CheckLimits(CMatchFinder *p)
-+{
-+  if (p->pos == kMaxValForNormalize)
-+    MatchFinder_Normalize(p);
-+  if (!p->streamEndWasReached && p->keepSizeAfter == p->streamPos - p->pos)
-+    MatchFinder_CheckAndMoveAndRead(p);
-+  if (p->cyclicBufferPos == p->cyclicBufferSize)
-+    p->cyclicBufferPos = 0;
-+  MatchFinder_SetLimits(p);
-+}
-+
-+static UInt32 * Hc_GetMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
-+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
-+    UInt32 *distances, UInt32 maxLen)
-+{
-+  son[_cyclicBufferPos] = curMatch;
-+  for (;;)
-+  {
-+    UInt32 delta = pos - curMatch;
-+    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
-+      return distances;
-+    {
-+      const Byte *pb = cur - delta;
-+      curMatch = son[_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)];
-+      if (pb[maxLen] == cur[maxLen] && *pb == *cur)
-+      {
-+        UInt32 len = 0;
-+        while (++len != lenLimit)
-+          if (pb[len] != cur[len])
-+            break;
-+        if (maxLen < len)
-+        {
-+          *distances++ = maxLen = len;
-+          *distances++ = delta - 1;
-+          if (len == lenLimit)
-+            return distances;
-+        }
-+      }
-+    }
-+  }
-+}
-+
-+UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
-+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
-+    UInt32 *distances, UInt32 maxLen)
-+{
-+  CLzRef *ptr0 = son + (_cyclicBufferPos << 1) + 1;
-+  CLzRef *ptr1 = son + (_cyclicBufferPos << 1);
-+  UInt32 len0 = 0, len1 = 0;
-+  for (;;)
-+  {
-+    UInt32 delta = pos - curMatch;
-+    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
-+    {
-+      *ptr0 = *ptr1 = kEmptyHashValue;
-+      return distances;
-+    }
-+    {
-+      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
-+      const Byte *pb = cur - delta;
-+      UInt32 len = (len0 < len1 ? len0 : len1);
-+      if (pb[len] == cur[len])
-+      {
-+        if (++len != lenLimit && pb[len] == cur[len])
-+          while (++len != lenLimit)
-+            if (pb[len] != cur[len])
-+              break;
-+        if (maxLen < len)
-+        {
-+          *distances++ = maxLen = len;
-+          *distances++ = delta - 1;
-+          if (len == lenLimit)
-+          {
-+            *ptr1 = pair[0];
-+            *ptr0 = pair[1];
-+            return distances;
-+          }
-+        }
-+      }
-+      if (pb[len] < cur[len])
-+      {
-+        *ptr1 = curMatch;
-+        ptr1 = pair + 1;
-+        curMatch = *ptr1;
-+        len1 = len;
-+      }
-+      else
-+      {
-+        *ptr0 = curMatch;
-+        ptr0 = pair;
-+        curMatch = *ptr0;
-+        len0 = len;
-+      }
-+    }
-+  }
-+}
-+
-+static void SkipMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
-+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue)
-+{
-+  CLzRef *ptr0 = son + (_cyclicBufferPos << 1) + 1;
-+  CLzRef *ptr1 = son + (_cyclicBufferPos << 1);
-+  UInt32 len0 = 0, len1 = 0;
-+  for (;;)
-+  {
-+    UInt32 delta = pos - curMatch;
-+    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
-+    {
-+      *ptr0 = *ptr1 = kEmptyHashValue;
-+      return;
-+    }
-+    {
-+      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
-+      const Byte *pb = cur - delta;
-+      UInt32 len = (len0 < len1 ? len0 : len1);
-+      if (pb[len] == cur[len])
-+      {
-+        while (++len != lenLimit)
-+          if (pb[len] != cur[len])
-+            break;
-+        {
-+          if (len == lenLimit)
-+          {
-+            *ptr1 = pair[0];
-+            *ptr0 = pair[1];
-+            return;
-+          }
-+        }
-+      }
-+      if (pb[len] < cur[len])
-+      {
-+        *ptr1 = curMatch;
-+        ptr1 = pair + 1;
-+        curMatch = *ptr1;
-+        len1 = len;
-+      }
-+      else
-+      {
-+        *ptr0 = curMatch;
-+        ptr0 = pair;
-+        curMatch = *ptr0;
-+        len0 = len;
-+      }
-+    }
-+  }
-+}
-+
-+#define MOVE_POS \
-+  ++p->cyclicBufferPos; \
-+  p->buffer++; \
-+  if (++p->pos == p->posLimit) MatchFinder_CheckLimits(p);
-+
-+#define MOVE_POS_RET MOVE_POS return offset;
-+
-+static void MatchFinder_MovePos(CMatchFinder *p) { MOVE_POS; }
-+
-+#define GET_MATCHES_HEADER2(minLen, ret_op) \
-+  UInt32 lenLimit; UInt32 hashValue; const Byte *cur; UInt32 curMatch; \
-+  lenLimit = p->lenLimit; { if (lenLimit < minLen) { MatchFinder_MovePos(p); ret_op; }} \
-+  cur = p->buffer;
-+
-+#define GET_MATCHES_HEADER(minLen) GET_MATCHES_HEADER2(minLen, return 0)
-+#define SKIP_HEADER(minLen)        GET_MATCHES_HEADER2(minLen, continue)
-+
-+#define MF_PARAMS(p) p->pos, p->buffer, p->son, p->cyclicBufferPos, p->cyclicBufferSize, p->cutValue
-+
-+#define GET_MATCHES_FOOTER(offset, maxLen) \
-+  offset = (UInt32)(GetMatchesSpec1(lenLimit, curMatch, MF_PARAMS(p), \
-+  distances + offset, maxLen) - distances); MOVE_POS_RET;
-+
-+#define SKIP_FOOTER \
-+  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MOVE_POS;
-+
-+static UInt32 Bt2_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-+{
-+  UInt32 offset;
-+  GET_MATCHES_HEADER(2)
-+  HASH2_CALC;
-+  curMatch = p->hash[hashValue];
-+  p->hash[hashValue] = p->pos;
-+  offset = 0;
-+  GET_MATCHES_FOOTER(offset, 1)
-+}
-+
-+UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-+{
-+  UInt32 offset;
-+  GET_MATCHES_HEADER(3)
-+  HASH_ZIP_CALC;
-+  curMatch = p->hash[hashValue];
-+  p->hash[hashValue] = p->pos;
-+  offset = 0;
-+  GET_MATCHES_FOOTER(offset, 2)
-+}
-+
-+static UInt32 Bt3_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-+{
-+  UInt32 hash2Value, delta2, maxLen, offset;
-+  GET_MATCHES_HEADER(3)
-+
-+  HASH3_CALC;
-+
-+  delta2 = p->pos - p->hash[hash2Value];
-+  curMatch = p->hash[kFix3HashSize + hashValue];
-+  
-+  p->hash[hash2Value] =
-+  p->hash[kFix3HashSize + hashValue] = p->pos;
-+
-+
-+  maxLen = 2;
-+  offset = 0;
-+  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
-+  {
-+    for (; maxLen != lenLimit; maxLen++)
-+      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
-+        break;
-+    distances[0] = maxLen;
-+    distances[1] = delta2 - 1;
-+    offset = 2;
-+    if (maxLen == lenLimit)
-+    {
-+      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
-+      MOVE_POS_RET;
-+    }
-+  }
-+  GET_MATCHES_FOOTER(offset, maxLen)
-+}
-+
-+static UInt32 Bt4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-+{
-+  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
-+  GET_MATCHES_HEADER(4)
-+
-+  HASH4_CALC;
-+
-+  delta2 = p->pos - p->hash[                hash2Value];
-+  delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
-+  curMatch = p->hash[kFix4HashSize + hashValue];
-+  
-+  p->hash[                hash2Value] =
-+  p->hash[kFix3HashSize + hash3Value] =
-+  p->hash[kFix4HashSize + hashValue] = p->pos;
-+
-+  maxLen = 1;
-+  offset = 0;
-+  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
-+  {
-+    distances[0] = maxLen = 2;
-+    distances[1] = delta2 - 1;
-+    offset = 2;
-+  }
-+  if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
-+  {
-+    maxLen = 3;
-+    distances[offset + 1] = delta3 - 1;
-+    offset += 2;
-+    delta2 = delta3;
-+  }
-+  if (offset != 0)
-+  {
-+    for (; maxLen != lenLimit; maxLen++)
-+      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
-+        break;
-+    distances[offset - 2] = maxLen;
-+    if (maxLen == lenLimit)
-+    {
-+      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
-+      MOVE_POS_RET;
-+    }
-+  }
-+  if (maxLen < 3)
-+    maxLen = 3;
-+  GET_MATCHES_FOOTER(offset, maxLen)
-+}
-+
-+static UInt32 Hc4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-+{
-+  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
-+  GET_MATCHES_HEADER(4)
-+
-+  HASH4_CALC;
-+
-+  delta2 = p->pos - p->hash[                hash2Value];
-+  delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
-+  curMatch = p->hash[kFix4HashSize + hashValue];
-+
-+  p->hash[                hash2Value] =
-+  p->hash[kFix3HashSize + hash3Value] =
-+  p->hash[kFix4HashSize + hashValue] = p->pos;
-+
-+  maxLen = 1;
-+  offset = 0;
-+  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
-+  {
-+    distances[0] = maxLen = 2;
-+    distances[1] = delta2 - 1;
-+    offset = 2;
-+  }
-+  if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
-+  {
-+    maxLen = 3;
-+    distances[offset + 1] = delta3 - 1;
-+    offset += 2;
-+    delta2 = delta3;
-+  }
-+  if (offset != 0)
-+  {
-+    for (; maxLen != lenLimit; maxLen++)
-+      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
-+        break;
-+    distances[offset - 2] = maxLen;
-+    if (maxLen == lenLimit)
-+    {
-+      p->son[p->cyclicBufferPos] = curMatch;
-+      MOVE_POS_RET;
-+    }
-+  }
-+  if (maxLen < 3)
-+    maxLen = 3;
-+  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
-+    distances + offset, maxLen) - (distances));
-+  MOVE_POS_RET
-+}
-+
-+UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-+{
-+  UInt32 offset;
-+  GET_MATCHES_HEADER(3)
-+  HASH_ZIP_CALC;
-+  curMatch = p->hash[hashValue];
-+  p->hash[hashValue] = p->pos;
-+  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
-+    distances, 2) - (distances));
-+  MOVE_POS_RET
-+}
-+
-+static void Bt2_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-+{
-+  do
-+  {
-+    SKIP_HEADER(2)
-+    HASH2_CALC;
-+    curMatch = p->hash[hashValue];
-+    p->hash[hashValue] = p->pos;
-+    SKIP_FOOTER
-+  }
-+  while (--num != 0);
-+}
-+
-+void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-+{
-+  do
-+  {
-+    SKIP_HEADER(3)
-+    HASH_ZIP_CALC;
-+    curMatch = p->hash[hashValue];
-+    p->hash[hashValue] = p->pos;
-+    SKIP_FOOTER
-+  }
-+  while (--num != 0);
-+}
-+
-+static void Bt3_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-+{
-+  do
-+  {
-+    UInt32 hash2Value;
-+    SKIP_HEADER(3)
-+    HASH3_CALC;
-+    curMatch = p->hash[kFix3HashSize + hashValue];
-+    p->hash[hash2Value] =
-+    p->hash[kFix3HashSize + hashValue] = p->pos;
-+    SKIP_FOOTER
-+  }
-+  while (--num != 0);
-+}
-+
-+static void Bt4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-+{
-+  do
-+  {
-+    UInt32 hash2Value, hash3Value;
-+    SKIP_HEADER(4)
-+    HASH4_CALC;
-+    curMatch = p->hash[kFix4HashSize + hashValue];
-+    p->hash[                hash2Value] =
-+    p->hash[kFix3HashSize + hash3Value] = p->pos;
-+    p->hash[kFix4HashSize + hashValue] = p->pos;
-+    SKIP_FOOTER
-+  }
-+  while (--num != 0);
-+}
-+
-+static void Hc4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-+{
-+  do
-+  {
-+    UInt32 hash2Value, hash3Value;
-+    SKIP_HEADER(4)
-+    HASH4_CALC;
-+    curMatch = p->hash[kFix4HashSize + hashValue];
-+    p->hash[                hash2Value] =
-+    p->hash[kFix3HashSize + hash3Value] =
-+    p->hash[kFix4HashSize + hashValue] = p->pos;
-+    p->son[p->cyclicBufferPos] = curMatch;
-+    MOVE_POS
-+  }
-+  while (--num != 0);
-+}
-+
-+void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-+{
-+  do
-+  {
-+    SKIP_HEADER(3)
-+    HASH_ZIP_CALC;
-+    curMatch = p->hash[hashValue];
-+    p->hash[hashValue] = p->pos;
-+    p->son[p->cyclicBufferPos] = curMatch;
-+    MOVE_POS
-+  }
-+  while (--num != 0);
-+}
-+
-+void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable)
-+{
-+  vTable->Init = (Mf_Init_Func)MatchFinder_Init;
-+  vTable->GetIndexByte = (Mf_GetIndexByte_Func)MatchFinder_GetIndexByte;
-+  vTable->GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinder_GetNumAvailableBytes;
-+  vTable->GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinder_GetPointerToCurrentPos;
-+  if (!p->btMode)
-+  {
-+    vTable->GetMatches = (Mf_GetMatches_Func)Hc4_MatchFinder_GetMatches;
-+    vTable->Skip = (Mf_Skip_Func)Hc4_MatchFinder_Skip;
-+  }
-+  else if (p->numHashBytes == 2)
-+  {
-+    vTable->GetMatches = (Mf_GetMatches_Func)Bt2_MatchFinder_GetMatches;
-+    vTable->Skip = (Mf_Skip_Func)Bt2_MatchFinder_Skip;
-+  }
-+  else if (p->numHashBytes == 3)
-+  {
-+    vTable->GetMatches = (Mf_GetMatches_Func)Bt3_MatchFinder_GetMatches;
-+    vTable->Skip = (Mf_Skip_Func)Bt3_MatchFinder_Skip;
-+  }
-+  else
-+  {
-+    vTable->GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
-+    vTable->Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
-+  }
-+}
---- /dev/null
-+++ b/lib/lzma/LzmaDec.c
-@@ -0,0 +1,999 @@
-+/* LzmaDec.c -- LZMA Decoder
-+2009-09-20 : Igor Pavlov : Public domain */
-+
-+#include "LzmaDec.h"
-+
-+#include <string.h>
-+
-+#define kNumTopBits 24
-+#define kTopValue ((UInt32)1 << kNumTopBits)
-+
-+#define kNumBitModelTotalBits 11
-+#define kBitModelTotal (1 << kNumBitModelTotalBits)
-+#define kNumMoveBits 5
-+
-+#define RC_INIT_SIZE 5
-+
-+#define NORMALIZE if (range < kTopValue) { range <<= 8; code = (code << 8) | (*buf++); }
-+
-+#define IF_BIT_0(p) ttt = *(p); NORMALIZE; bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)
-+#define UPDATE_0(p) range = bound; *(p) = (CLzmaProb)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits));
-+#define UPDATE_1(p) range -= bound; code -= bound; *(p) = (CLzmaProb)(ttt - (ttt >> kNumMoveBits));
-+#define GET_BIT2(p, i, A0, A1) IF_BIT_0(p) \
-+  { UPDATE_0(p); i = (i + i); A0; } else \
-+  { UPDATE_1(p); i = (i + i) + 1; A1; }
-+#define GET_BIT(p, i) GET_BIT2(p, i, ; , ;)
-+
-+#define TREE_GET_BIT(probs, i) { GET_BIT((probs + i), i); }
-+#define TREE_DECODE(probs, limit, i) \
-+  { i = 1; do { TREE_GET_BIT(probs, i); } while (i < limit); i -= limit; }
-+
-+/* #define _LZMA_SIZE_OPT */
-+
-+#ifdef _LZMA_SIZE_OPT
-+#define TREE_6_DECODE(probs, i) TREE_DECODE(probs, (1 << 6), i)
-+#else
-+#define TREE_6_DECODE(probs, i) \
-+  { i = 1; \
-+  TREE_GET_BIT(probs, i); \
-+  TREE_GET_BIT(probs, i); \
-+  TREE_GET_BIT(probs, i); \
-+  TREE_GET_BIT(probs, i); \
-+  TREE_GET_BIT(probs, i); \
-+  TREE_GET_BIT(probs, i); \
-+  i -= 0x40; }
-+#endif
-+
-+#define NORMALIZE_CHECK if (range < kTopValue) { if (buf >= bufLimit) return DUMMY_ERROR; range <<= 8; code = (code << 8) | (*buf++); }
-+
-+#define IF_BIT_0_CHECK(p) ttt = *(p); NORMALIZE_CHECK; bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)
-+#define UPDATE_0_CHECK range = bound;
-+#define UPDATE_1_CHECK range -= bound; code -= bound;
-+#define GET_BIT2_CHECK(p, i, A0, A1) IF_BIT_0_CHECK(p) \
-+  { UPDATE_0_CHECK; i = (i + i); A0; } else \
-+  { UPDATE_1_CHECK; i = (i + i) + 1; A1; }
-+#define GET_BIT_CHECK(p, i) GET_BIT2_CHECK(p, i, ; , ;)
-+#define TREE_DECODE_CHECK(probs, limit, i) \
-+  { i = 1; do { GET_BIT_CHECK(probs + i, i) } while (i < limit); i -= limit; }
-+
-+
-+#define kNumPosBitsMax 4
-+#define kNumPosStatesMax (1 << kNumPosBitsMax)
-+
-+#define kLenNumLowBits 3
-+#define kLenNumLowSymbols (1 << kLenNumLowBits)
-+#define kLenNumMidBits 3
-+#define kLenNumMidSymbols (1 << kLenNumMidBits)
-+#define kLenNumHighBits 8
-+#define kLenNumHighSymbols (1 << kLenNumHighBits)
-+
-+#define LenChoice 0
-+#define LenChoice2 (LenChoice + 1)
-+#define LenLow (LenChoice2 + 1)
-+#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
-+#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
-+#define kNumLenProbs (LenHigh + kLenNumHighSymbols)
-+
-+
-+#define kNumStates 12
-+#define kNumLitStates 7
-+
-+#define kStartPosModelIndex 4
-+#define kEndPosModelIndex 14
-+#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
-+
-+#define kNumPosSlotBits 6
-+#define kNumLenToPosStates 4
-+
-+#define kNumAlignBits 4
-+#define kAlignTableSize (1 << kNumAlignBits)
-+
-+#define kMatchMinLen 2
-+#define kMatchSpecLenStart (kMatchMinLen + kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)
-+
-+#define IsMatch 0
-+#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
-+#define IsRepG0 (IsRep + kNumStates)
-+#define IsRepG1 (IsRepG0 + kNumStates)
-+#define IsRepG2 (IsRepG1 + kNumStates)
-+#define IsRep0Long (IsRepG2 + kNumStates)
-+#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
-+#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
-+#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
-+#define LenCoder (Align + kAlignTableSize)
-+#define RepLenCoder (LenCoder + kNumLenProbs)
-+#define Literal (RepLenCoder + kNumLenProbs)
-+
-+#define LZMA_BASE_SIZE 1846
-+#define LZMA_LIT_SIZE 768
-+
-+#define LzmaProps_GetNumProbs(p) ((UInt32)LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((p)->lc + (p)->lp)))
-+
-+#if Literal != LZMA_BASE_SIZE
-+StopCompilingDueBUG
-+#endif
-+
-+#define LZMA_DIC_MIN (1 << 12)
-+
-+/* First LZMA-symbol is always decoded.
-+And it decodes new LZMA-symbols while (buf < bufLimit), but "buf" is without last normalization
-+Out:
-+  Result:
-+    SZ_OK - OK
-+    SZ_ERROR_DATA - Error
-+  p->remainLen:
-+    < kMatchSpecLenStart : normal remain
-+    = kMatchSpecLenStart : finished
-+    = kMatchSpecLenStart + 1 : Flush marker
-+    = kMatchSpecLenStart + 2 : State Init Marker
-+*/
-+
-+static int MY_FAST_CALL LzmaDec_DecodeReal(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
-+{
-+  CLzmaProb *probs = p->probs;
-+
-+  unsigned state = p->state;
-+  UInt32 rep0 = p->reps[0], rep1 = p->reps[1], rep2 = p->reps[2], rep3 = p->reps[3];
-+  unsigned pbMask = ((unsigned)1 << (p->prop.pb)) - 1;
-+  unsigned lpMask = ((unsigned)1 << (p->prop.lp)) - 1;
-+  unsigned lc = p->prop.lc;
-+
-+  Byte *dic = p->dic;
-+  SizeT dicBufSize = p->dicBufSize;
-+  SizeT dicPos = p->dicPos;
-+  
-+  UInt32 processedPos = p->processedPos;
-+  UInt32 checkDicSize = p->checkDicSize;
-+  unsigned len = 0;
-+
-+  const Byte *buf = p->buf;
-+  UInt32 range = p->range;
-+  UInt32 code = p->code;
-+
-+  do
-+  {
-+    CLzmaProb *prob;
-+    UInt32 bound;
-+    unsigned ttt;
-+    unsigned posState = processedPos & pbMask;
-+
-+    prob = probs + IsMatch + (state << kNumPosBitsMax) + posState;
-+    IF_BIT_0(prob)
-+    {
-+      unsigned symbol;
-+      UPDATE_0(prob);
-+      prob = probs + Literal;
-+      if (checkDicSize != 0 || processedPos != 0)
-+        prob += (LZMA_LIT_SIZE * (((processedPos & lpMask) << lc) +
-+        (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] >> (8 - lc))));
-+
-+      if (state < kNumLitStates)
-+      {
-+        state -= (state < 4) ? state : 3;
-+        symbol = 1;
-+        do { GET_BIT(prob + symbol, symbol) } while (symbol < 0x100);
-+      }
-+      else
-+      {
-+        unsigned matchByte = p->dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
-+        unsigned offs = 0x100;
-+        state -= (state < 10) ? 3 : 6;
-+        symbol = 1;
-+        do
-+        {
-+          unsigned bit;
-+          CLzmaProb *probLit;
-+          matchByte <<= 1;
-+          bit = (matchByte & offs);
-+          probLit = prob + offs + bit + symbol;
-+          GET_BIT2(probLit, symbol, offs &= ~bit, offs &= bit)
-+        }
-+        while (symbol < 0x100);
-+      }
-+      dic[dicPos++] = (Byte)symbol;
-+      processedPos++;
-+      continue;
-+    }
-+    else
-+    {
-+      UPDATE_1(prob);
-+      prob = probs + IsRep + state;
-+      IF_BIT_0(prob)
-+      {
-+        UPDATE_0(prob);
-+        state += kNumStates;
-+        prob = probs + LenCoder;
-+      }
-+      else
-+      {
-+        UPDATE_1(prob);
-+        if (checkDicSize == 0 && processedPos == 0)
-+          return SZ_ERROR_DATA;
-+        prob = probs + IsRepG0 + state;
-+        IF_BIT_0(prob)
-+        {
-+          UPDATE_0(prob);
-+          prob = probs + IsRep0Long + (state << kNumPosBitsMax) + posState;
-+          IF_BIT_0(prob)
-+          {
-+            UPDATE_0(prob);
-+            dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
-+            dicPos++;
-+            processedPos++;
-+            state = state < kNumLitStates ? 9 : 11;
-+            continue;
-+          }
-+          UPDATE_1(prob);
-+        }
-+        else
-+        {
-+          UInt32 distance;
-+          UPDATE_1(prob);
-+          prob = probs + IsRepG1 + state;
-+          IF_BIT_0(prob)
-+          {
-+            UPDATE_0(prob);
-+            distance = rep1;
-+          }
-+          else
-+          {
-+            UPDATE_1(prob);
-+            prob = probs + IsRepG2 + state;
-+            IF_BIT_0(prob)
-+            {
-+              UPDATE_0(prob);
-+              distance = rep2;
-+            }
-+            else
-+            {
-+              UPDATE_1(prob);
-+              distance = rep3;
-+              rep3 = rep2;
-+            }
-+            rep2 = rep1;
-+          }
-+          rep1 = rep0;
-+          rep0 = distance;
-+        }
-+        state = state < kNumLitStates ? 8 : 11;
-+        prob = probs + RepLenCoder;
-+      }
-+      {
-+        unsigned limit, offset;
-+        CLzmaProb *probLen = prob + LenChoice;
-+        IF_BIT_0(probLen)
-+        {
-+          UPDATE_0(probLen);
-+          probLen = prob + LenLow + (posState << kLenNumLowBits);
-+          offset = 0;
-+          limit = (1 << kLenNumLowBits);
-+        }
-+        else
-+        {
-+          UPDATE_1(probLen);
-+          probLen = prob + LenChoice2;
-+          IF_BIT_0(probLen)
-+          {
-+            UPDATE_0(probLen);
-+            probLen = prob + LenMid + (posState << kLenNumMidBits);
-+            offset = kLenNumLowSymbols;
-+            limit = (1 << kLenNumMidBits);
-+          }
-+          else
-+          {
-+            UPDATE_1(probLen);
-+            probLen = prob + LenHigh;
-+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
-+            limit = (1 << kLenNumHighBits);
-+          }
-+        }
-+        TREE_DECODE(probLen, limit, len);
-+        len += offset;
-+      }
-+
-+      if (state >= kNumStates)
-+      {
-+        UInt32 distance;
-+        prob = probs + PosSlot +
-+            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);
-+        TREE_6_DECODE(prob, distance);
-+        if (distance >= kStartPosModelIndex)
-+        {
-+          unsigned posSlot = (unsigned)distance;
-+          int numDirectBits = (int)(((distance >> 1) - 1));
-+          distance = (2 | (distance & 1));
-+          if (posSlot < kEndPosModelIndex)
-+          {
-+            distance <<= numDirectBits;
-+            prob = probs + SpecPos + distance - posSlot - 1;
-+            {
-+              UInt32 mask = 1;
-+              unsigned i = 1;
-+              do
-+              {
-+                GET_BIT2(prob + i, i, ; , distance |= mask);
-+                mask <<= 1;
-+              }
-+              while (--numDirectBits != 0);
-+            }
-+          }
-+          else
-+          {
-+            numDirectBits -= kNumAlignBits;
-+            do
-+            {
-+              NORMALIZE
-+              range >>= 1;
-+              
-+              {
-+                UInt32 t;
-+                code -= range;
-+                t = (0 - ((UInt32)code >> 31)); /* (UInt32)((Int32)code >> 31) */
-+                distance = (distance << 1) + (t + 1);
-+                code += range & t;
-+              }
-+              /*
-+              distance <<= 1;
-+              if (code >= range)
-+              {
-+                code -= range;
-+                distance |= 1;
-+              }
-+              */
-+            }
-+            while (--numDirectBits != 0);
-+            prob = probs + Align;
-+            distance <<= kNumAlignBits;
-+            {
-+              unsigned i = 1;
-+              GET_BIT2(prob + i, i, ; , distance |= 1);
-+              GET_BIT2(prob + i, i, ; , distance |= 2);
-+              GET_BIT2(prob + i, i, ; , distance |= 4);
-+              GET_BIT2(prob + i, i, ; , distance |= 8);
-+            }
-+            if (distance == (UInt32)0xFFFFFFFF)
-+            {
-+              len += kMatchSpecLenStart;
-+              state -= kNumStates;
-+              break;
-+            }
-+          }
-+        }
-+        rep3 = rep2;
-+        rep2 = rep1;
-+        rep1 = rep0;
-+        rep0 = distance + 1;
-+        if (checkDicSize == 0)
-+        {
-+          if (distance >= processedPos)
-+            return SZ_ERROR_DATA;
-+        }
-+        else if (distance >= checkDicSize)
-+          return SZ_ERROR_DATA;
-+        state = (state < kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3;
-+      }
-+
-+      len += kMatchMinLen;
-+
-+      if (limit == dicPos)
-+        return SZ_ERROR_DATA;
-+      {
-+        SizeT rem = limit - dicPos;
-+        unsigned curLen = ((rem < len) ? (unsigned)rem : len);
-+        SizeT pos = (dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0);
-+
-+        processedPos += curLen;
-+
-+        len -= curLen;
-+        if (pos + curLen <= dicBufSize)
-+        {
-+          Byte *dest = dic + dicPos;
-+          ptrdiff_t src = (ptrdiff_t)pos - (ptrdiff_t)dicPos;
-+          const Byte *lim = dest + curLen;
-+          dicPos += curLen;
-+          do
-+            *(dest) = (Byte)*(dest + src);
-+          while (++dest != lim);
-+        }
-+        else
-+        {
-+          do
-+          {
-+            dic[dicPos++] = dic[pos];
-+            if (++pos == dicBufSize)
-+              pos = 0;
-+          }
-+          while (--curLen != 0);
-+        }
-+      }
-+    }
-+  }
-+  while (dicPos < limit && buf < bufLimit);
-+  NORMALIZE;
-+  p->buf = buf;
-+  p->range = range;
-+  p->code = code;
-+  p->remainLen = len;
-+  p->dicPos = dicPos;
-+  p->processedPos = processedPos;
-+  p->reps[0] = rep0;
-+  p->reps[1] = rep1;
-+  p->reps[2] = rep2;
-+  p->reps[3] = rep3;
-+  p->state = state;
-+
-+  return SZ_OK;
-+}
-+
-+static void MY_FAST_CALL LzmaDec_WriteRem(CLzmaDec *p, SizeT limit)
-+{
-+  if (p->remainLen != 0 && p->remainLen < kMatchSpecLenStart)
-+  {
-+    Byte *dic = p->dic;
-+    SizeT dicPos = p->dicPos;
-+    SizeT dicBufSize = p->dicBufSize;
-+    unsigned len = p->remainLen;
-+    UInt32 rep0 = p->reps[0];
-+    if (limit - dicPos < len)
-+      len = (unsigned)(limit - dicPos);
-+
-+    if (p->checkDicSize == 0 && p->prop.dicSize - p->processedPos <= len)
-+      p->checkDicSize = p->prop.dicSize;
-+
-+    p->processedPos += len;
-+    p->remainLen -= len;
-+    while (len-- != 0)
-+    {
-+      dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
-+      dicPos++;
-+    }
-+    p->dicPos = dicPos;
-+  }
-+}
-+
-+static int MY_FAST_CALL LzmaDec_DecodeReal2(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
-+{
-+  do
-+  {
-+    SizeT limit2 = limit;
-+    if (p->checkDicSize == 0)
-+    {
-+      UInt32 rem = p->prop.dicSize - p->processedPos;
-+      if (limit - p->dicPos > rem)
-+        limit2 = p->dicPos + rem;
-+    }
-+    RINOK(LzmaDec_DecodeReal(p, limit2, bufLimit));
-+    if (p->processedPos >= p->prop.dicSize)
-+      p->checkDicSize = p->prop.dicSize;
-+    LzmaDec_WriteRem(p, limit);
-+  }
-+  while (p->dicPos < limit && p->buf < bufLimit && p->remainLen < kMatchSpecLenStart);
-+
-+  if (p->remainLen > kMatchSpecLenStart)
-+  {
-+    p->remainLen = kMatchSpecLenStart;
-+  }
-+  return 0;
-+}
-+
-+typedef enum
-+{
-+  DUMMY_ERROR, /* unexpected end of input stream */
-+  DUMMY_LIT,
-+  DUMMY_MATCH,
-+  DUMMY_REP
-+} ELzmaDummy;
-+
-+static ELzmaDummy LzmaDec_TryDummy(const CLzmaDec *p, const Byte *buf, SizeT inSize)
-+{
-+  UInt32 range = p->range;
-+  UInt32 code = p->code;
-+  const Byte *bufLimit = buf + inSize;
-+  CLzmaProb *probs = p->probs;
-+  unsigned state = p->state;
-+  ELzmaDummy res;
-+
-+  {
-+    CLzmaProb *prob;
-+    UInt32 bound;
-+    unsigned ttt;
-+    unsigned posState = (p->processedPos) & ((1 << p->prop.pb) - 1);
-+
-+    prob = probs + IsMatch + (state << kNumPosBitsMax) + posState;
-+    IF_BIT_0_CHECK(prob)
-+    {
-+      UPDATE_0_CHECK
-+
-+      /* if (bufLimit - buf >= 7) return DUMMY_LIT; */
-+
-+      prob = probs + Literal;
-+      if (p->checkDicSize != 0 || p->processedPos != 0)
-+        prob += (LZMA_LIT_SIZE *
-+          ((((p->processedPos) & ((1 << (p->prop.lp)) - 1)) << p->prop.lc) +
-+          (p->dic[(p->dicPos == 0 ? p->dicBufSize : p->dicPos) - 1] >> (8 - p->prop.lc))));
-+
-+      if (state < kNumLitStates)
-+      {
-+        unsigned symbol = 1;
-+        do { GET_BIT_CHECK(prob + symbol, symbol) } while (symbol < 0x100);
-+      }
-+      else
-+      {
-+        unsigned matchByte = p->dic[p->dicPos - p->reps[0] +
-+            ((p->dicPos < p->reps[0]) ? p->dicBufSize : 0)];
-+        unsigned offs = 0x100;
-+        unsigned symbol = 1;
-+        do
-+        {
-+          unsigned bit;
-+          CLzmaProb *probLit;
-+          matchByte <<= 1;
-+          bit = (matchByte & offs);
-+          probLit = prob + offs + bit + symbol;
-+          GET_BIT2_CHECK(probLit, symbol, offs &= ~bit, offs &= bit)
-+        }
-+        while (symbol < 0x100);
-+      }
-+      res = DUMMY_LIT;
-+    }
-+    else
-+    {
-+      unsigned len;
-+      UPDATE_1_CHECK;
-+
-+      prob = probs + IsRep + state;
-+      IF_BIT_0_CHECK(prob)
-+      {
-+        UPDATE_0_CHECK;
-+        state = 0;
-+        prob = probs + LenCoder;
-+        res = DUMMY_MATCH;
-+      }
-+      else
-+      {
-+        UPDATE_1_CHECK;
-+        res = DUMMY_REP;
-+        prob = probs + IsRepG0 + state;
-+        IF_BIT_0_CHECK(prob)
-+        {
-+          UPDATE_0_CHECK;
-+          prob = probs + IsRep0Long + (state << kNumPosBitsMax) + posState;
-+          IF_BIT_0_CHECK(prob)
-+          {
-+            UPDATE_0_CHECK;
-+            NORMALIZE_CHECK;
-+            return DUMMY_REP;
-+          }
-+          else
-+          {
-+            UPDATE_1_CHECK;
-+          }
-+        }
-+        else
-+        {
-+          UPDATE_1_CHECK;
-+          prob = probs + IsRepG1 + state;
-+          IF_BIT_0_CHECK(prob)
-+          {
-+            UPDATE_0_CHECK;
-+          }
-+          else
-+          {
-+            UPDATE_1_CHECK;
-+            prob = probs + IsRepG2 + state;
-+            IF_BIT_0_CHECK(prob)
-+            {
-+              UPDATE_0_CHECK;
-+            }
-+            else
-+            {
-+              UPDATE_1_CHECK;
-+            }
-+          }
-+        }
-+        state = kNumStates;
-+        prob = probs + RepLenCoder;
-+      }
-+      {
-+        unsigned limit, offset;
-+        CLzmaProb *probLen = prob + LenChoice;
-+        IF_BIT_0_CHECK(probLen)
-+        {
-+          UPDATE_0_CHECK;
-+          probLen = prob + LenLow + (posState << kLenNumLowBits);
-+          offset = 0;
-+          limit = 1 << kLenNumLowBits;
-+        }
-+        else
-+        {
-+          UPDATE_1_CHECK;
-+          probLen = prob + LenChoice2;
-+          IF_BIT_0_CHECK(probLen)
-+          {
-+            UPDATE_0_CHECK;
-+            probLen = prob + LenMid + (posState << kLenNumMidBits);
-+            offset = kLenNumLowSymbols;
-+            limit = 1 << kLenNumMidBits;
-+          }
-+          else
-+          {
-+            UPDATE_1_CHECK;
-+            probLen = prob + LenHigh;
-+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
-+            limit = 1 << kLenNumHighBits;
-+          }
-+        }
-+        TREE_DECODE_CHECK(probLen, limit, len);
-+        len += offset;
-+      }
-+
-+      if (state < 4)
-+      {
-+        unsigned posSlot;
-+        prob = probs + PosSlot +
-+            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) <<
-+            kNumPosSlotBits);
-+        TREE_DECODE_CHECK(prob, 1 << kNumPosSlotBits, posSlot);
-+        if (posSlot >= kStartPosModelIndex)
-+        {
-+          int numDirectBits = ((posSlot >> 1) - 1);
-+
-+          /* if (bufLimit - buf >= 8) return DUMMY_MATCH; */
-+
-+          if (posSlot < kEndPosModelIndex)
-+          {
-+            prob = probs + SpecPos + ((2 | (posSlot & 1)) << numDirectBits) - posSlot - 1;
-+          }
-+          else
-+          {
-+            numDirectBits -= kNumAlignBits;
-+            do
-+            {
-+              NORMALIZE_CHECK
-+              range >>= 1;
-+              code -= range & (((code - range) >> 31) - 1);
-+              /* if (code >= range) code -= range; */
-+            }
-+            while (--numDirectBits != 0);
-+            prob = probs + Align;
-+            numDirectBits = kNumAlignBits;
-+          }
-+          {
-+            unsigned i = 1;
-+            do
-+            {
-+              GET_BIT_CHECK(prob + i, i);
-+            }
-+            while (--numDirectBits != 0);
-+          }
-+        }
-+      }
-+    }
-+  }
-+  NORMALIZE_CHECK;
-+  return res;
-+}
-+
-+
-+static void LzmaDec_InitRc(CLzmaDec *p, const Byte *data)
-+{
-+  p->code = ((UInt32)data[1] << 24) | ((UInt32)data[2] << 16) | ((UInt32)data[3] << 8) | ((UInt32)data[4]);
-+  p->range = 0xFFFFFFFF;
-+  p->needFlush = 0;
-+}
-+
-+void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
-+{
-+  p->needFlush = 1;
-+  p->remainLen = 0;
-+  p->tempBufSize = 0;
-+
-+  if (initDic)
-+  {
-+    p->processedPos = 0;
-+    p->checkDicSize = 0;
-+    p->needInitState = 1;
-+  }
-+  if (initState)
-+    p->needInitState = 1;
-+}
-+
-+void LzmaDec_Init(CLzmaDec *p)
-+{
-+  p->dicPos = 0;
-+  LzmaDec_InitDicAndState(p, True, True);
-+}
-+
-+static void LzmaDec_InitStateReal(CLzmaDec *p)
-+{
-+  UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (p->prop.lc + p->prop.lp));
-+  UInt32 i;
-+  CLzmaProb *probs = p->probs;
-+  for (i = 0; i < numProbs; i++)
-+    probs[i] = kBitModelTotal >> 1;
-+  p->reps[0] = p->reps[1] = p->reps[2] = p->reps[3] = 1;
-+  p->state = 0;
-+  p->needInitState = 0;
-+}
-+
-+SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
-+    ELzmaFinishMode finishMode, ELzmaStatus *status)
-+{
-+  SizeT inSize = *srcLen;
-+  (*srcLen) = 0;
-+  LzmaDec_WriteRem(p, dicLimit);
-+  
-+  *status = LZMA_STATUS_NOT_SPECIFIED;
-+
-+  while (p->remainLen != kMatchSpecLenStart)
-+  {
-+      int checkEndMarkNow;
-+
-+      if (p->needFlush != 0)
-+      {
-+        for (; inSize > 0 && p->tempBufSize < RC_INIT_SIZE; (*srcLen)++, inSize--)
-+          p->tempBuf[p->tempBufSize++] = *src++;
-+        if (p->tempBufSize < RC_INIT_SIZE)
-+        {
-+          *status = LZMA_STATUS_NEEDS_MORE_INPUT;
-+          return SZ_OK;
-+        }
-+        if (p->tempBuf[0] != 0)
-+          return SZ_ERROR_DATA;
-+
-+        LzmaDec_InitRc(p, p->tempBuf);
-+        p->tempBufSize = 0;
-+      }
-+
-+      checkEndMarkNow = 0;
-+      if (p->dicPos >= dicLimit)
-+      {
-+        if (p->remainLen == 0 && p->code == 0)
-+        {
-+          *status = LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK;
-+          return SZ_OK;
-+        }
-+        if (finishMode == LZMA_FINISH_ANY)
-+        {
-+          *status = LZMA_STATUS_NOT_FINISHED;
-+          return SZ_OK;
-+        }
-+        if (p->remainLen != 0)
-+        {
-+          *status = LZMA_STATUS_NOT_FINISHED;
-+          return SZ_ERROR_DATA;
-+        }
-+        checkEndMarkNow = 1;
-+      }
-+
-+      if (p->needInitState)
-+        LzmaDec_InitStateReal(p);
-+  
-+      if (p->tempBufSize == 0)
-+      {
-+        SizeT processed;
-+        const Byte *bufLimit;
-+        if (inSize < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
-+        {
-+          int dummyRes = LzmaDec_TryDummy(p, src, inSize);
-+          if (dummyRes == DUMMY_ERROR)
-+          {
-+            memcpy(p->tempBuf, src, inSize);
-+            p->tempBufSize = (unsigned)inSize;
-+            (*srcLen) += inSize;
-+            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
-+            return SZ_OK;
-+          }
-+          if (checkEndMarkNow && dummyRes != DUMMY_MATCH)
-+          {
-+            *status = LZMA_STATUS_NOT_FINISHED;
-+            return SZ_ERROR_DATA;
-+          }
-+          bufLimit = src;
-+        }
-+        else
-+          bufLimit = src + inSize - LZMA_REQUIRED_INPUT_MAX;
-+        p->buf = src;
-+        if (LzmaDec_DecodeReal2(p, dicLimit, bufLimit) != 0)
-+          return SZ_ERROR_DATA;
-+        processed = (SizeT)(p->buf - src);
-+        (*srcLen) += processed;
-+        src += processed;
-+        inSize -= processed;
-+      }
-+      else
-+      {
-+        unsigned rem = p->tempBufSize, lookAhead = 0;
-+        while (rem < LZMA_REQUIRED_INPUT_MAX && lookAhead < inSize)
-+          p->tempBuf[rem++] = src[lookAhead++];
-+        p->tempBufSize = rem;
-+        if (rem < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
-+        {
-+          int dummyRes = LzmaDec_TryDummy(p, p->tempBuf, rem);
-+          if (dummyRes == DUMMY_ERROR)
-+          {
-+            (*srcLen) += lookAhead;
-+            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
-+            return SZ_OK;
-+          }
-+          if (checkEndMarkNow && dummyRes != DUMMY_MATCH)
-+          {
-+            *status = LZMA_STATUS_NOT_FINISHED;
-+            return SZ_ERROR_DATA;
-+          }
-+        }
-+        p->buf = p->tempBuf;
-+        if (LzmaDec_DecodeReal2(p, dicLimit, p->buf) != 0)
-+          return SZ_ERROR_DATA;
-+        lookAhead -= (rem - (unsigned)(p->buf - p->tempBuf));
-+        (*srcLen) += lookAhead;
-+        src += lookAhead;
-+        inSize -= lookAhead;
-+        p->tempBufSize = 0;
-+      }
-+  }
-+  if (p->code == 0)
-+    *status = LZMA_STATUS_FINISHED_WITH_MARK;
-+  return (p->code == 0) ? SZ_OK : SZ_ERROR_DATA;
-+}
-+
-+SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
-+{
-+  SizeT outSize = *destLen;
-+  SizeT inSize = *srcLen;
-+  *srcLen = *destLen = 0;
-+  for (;;)
-+  {
-+    SizeT inSizeCur = inSize, outSizeCur, dicPos;
-+    ELzmaFinishMode curFinishMode;
-+    SRes res;
-+    if (p->dicPos == p->dicBufSize)
-+      p->dicPos = 0;
-+    dicPos = p->dicPos;
-+    if (outSize > p->dicBufSize - dicPos)
-+    {
-+      outSizeCur = p->dicBufSize;
-+      curFinishMode = LZMA_FINISH_ANY;
-+    }
-+    else
-+    {
-+      outSizeCur = dicPos + outSize;
-+      curFinishMode = finishMode;
-+    }
-+
-+    res = LzmaDec_DecodeToDic(p, outSizeCur, src, &inSizeCur, curFinishMode, status);
-+    src += inSizeCur;
-+    inSize -= inSizeCur;
-+    *srcLen += inSizeCur;
-+    outSizeCur = p->dicPos - dicPos;
-+    memcpy(dest, p->dic + dicPos, outSizeCur);
-+    dest += outSizeCur;
-+    outSize -= outSizeCur;
-+    *destLen += outSizeCur;
-+    if (res != 0)
-+      return res;
-+    if (outSizeCur == 0 || outSize == 0)
-+      return SZ_OK;
-+  }
-+}
-+
-+void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
-+{
-+  alloc->Free(alloc, p->probs);
-+  p->probs = 0;
-+}
-+
-+static void LzmaDec_FreeDict(CLzmaDec *p, ISzAlloc *alloc)
-+{
-+  alloc->Free(alloc, p->dic);
-+  p->dic = 0;
-+}
-+
-+void LzmaDec_Free(CLzmaDec *p, ISzAlloc *alloc)
-+{
-+  LzmaDec_FreeProbs(p, alloc);
-+  LzmaDec_FreeDict(p, alloc);
-+}
-+
-+SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
-+{
-+  UInt32 dicSize;
-+  Byte d;
-+  
-+  if (size < LZMA_PROPS_SIZE)
-+    return SZ_ERROR_UNSUPPORTED;
-+  else
-+    dicSize = data[1] | ((UInt32)data[2] << 8) | ((UInt32)data[3] << 16) | ((UInt32)data[4] << 24);
-+ 
-+  if (dicSize < LZMA_DIC_MIN)
-+    dicSize = LZMA_DIC_MIN;
-+  p->dicSize = dicSize;
-+
-+  d = data[0];
-+  if (d >= (9 * 5 * 5))
-+    return SZ_ERROR_UNSUPPORTED;
-+
-+  p->lc = d % 9;
-+  d /= 9;
-+  p->pb = d / 5;
-+  p->lp = d % 5;
-+
-+  return SZ_OK;
-+}
-+
-+static SRes LzmaDec_AllocateProbs2(CLzmaDec *p, const CLzmaProps *propNew, ISzAlloc *alloc)
-+{
-+  UInt32 numProbs = LzmaProps_GetNumProbs(propNew);
-+  if (p->probs == 0 || numProbs != p->numProbs)
-+  {
-+    LzmaDec_FreeProbs(p, alloc);
-+    p->probs = (CLzmaProb *)alloc->Alloc(alloc, numProbs * sizeof(CLzmaProb));
-+    p->numProbs = numProbs;
-+    if (p->probs == 0)
-+      return SZ_ERROR_MEM;
-+  }
-+  return SZ_OK;
-+}
-+
-+SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
-+{
-+  CLzmaProps propNew;
-+  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
-+  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
-+  p->prop = propNew;
-+  return SZ_OK;
-+}
-+
-+SRes LzmaDec_Allocate(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
-+{
-+  CLzmaProps propNew;
-+  SizeT dicBufSize;
-+  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
-+  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
-+  dicBufSize = propNew.dicSize;
-+  if (p->dic == 0 || dicBufSize != p->dicBufSize)
-+  {
-+    LzmaDec_FreeDict(p, alloc);
-+    p->dic = (Byte *)alloc->Alloc(alloc, dicBufSize);
-+    if (p->dic == 0)
-+    {
-+      LzmaDec_FreeProbs(p, alloc);
-+      return SZ_ERROR_MEM;
-+    }
-+  }
-+  p->dicBufSize = dicBufSize;
-+  p->prop = propNew;
-+  return SZ_OK;
-+}
-+
-+SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
-+    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
-+    ELzmaStatus *status, ISzAlloc *alloc)
-+{
-+  CLzmaDec p;
-+  SRes res;
-+  SizeT inSize = *srcLen;
-+  SizeT outSize = *destLen;
-+  *srcLen = *destLen = 0;
-+  if (inSize < RC_INIT_SIZE)
-+    return SZ_ERROR_INPUT_EOF;
-+
-+  LzmaDec_Construct(&p);
-+  res = LzmaDec_AllocateProbs(&p, propData, propSize, alloc);
-+  if (res != 0)
-+    return res;
-+  p.dic = dest;
-+  p.dicBufSize = outSize;
-+
-+  LzmaDec_Init(&p);
-+  
-+  *srcLen = inSize;
-+  res = LzmaDec_DecodeToDic(&p, outSize, src, srcLen, finishMode, status);
-+
-+  if (res == SZ_OK && *status == LZMA_STATUS_NEEDS_MORE_INPUT)
-+    res = SZ_ERROR_INPUT_EOF;
-+
-+  (*destLen) = p.dicPos;
-+  LzmaDec_FreeProbs(&p, alloc);
-+  return res;
-+}
---- /dev/null
-+++ b/lib/lzma/LzmaEnc.c
-@@ -0,0 +1,2271 @@
-+/* LzmaEnc.c -- LZMA Encoder
-+2009-11-24 : Igor Pavlov : Public domain */
-+
-+#include <string.h>
-+
-+/* #define SHOW_STAT */
-+/* #define SHOW_STAT2 */
-+
-+#if defined(SHOW_STAT) || defined(SHOW_STAT2)
-+#include <stdio.h>
-+#endif
-+
-+#include "LzmaEnc.h"
-+
-+/* disable MT */
-+#define _7ZIP_ST
-+
-+#include "LzFind.h"
-+#ifndef _7ZIP_ST
-+#include "LzFindMt.h"
-+#endif
-+
-+#ifdef SHOW_STAT
-+static int ttt = 0;
-+#endif
-+
-+#define kBlockSizeMax ((1 << LZMA_NUM_BLOCK_SIZE_BITS) - 1)
-+
-+#define kBlockSize (9 << 10)
-+#define kUnpackBlockSize (1 << 18)
-+#define kMatchArraySize (1 << 21)
-+#define kMatchRecordMaxSize ((LZMA_MATCH_LEN_MAX * 2 + 3) * LZMA_MATCH_LEN_MAX)
-+
-+#define kNumMaxDirectBits (31)
-+
-+#define kNumTopBits 24
-+#define kTopValue ((UInt32)1 << kNumTopBits)
-+
-+#define kNumBitModelTotalBits 11
-+#define kBitModelTotal (1 << kNumBitModelTotalBits)
-+#define kNumMoveBits 5
-+#define kProbInitValue (kBitModelTotal >> 1)
-+
-+#define kNumMoveReducingBits 4
-+#define kNumBitPriceShiftBits 4
-+#define kBitPrice (1 << kNumBitPriceShiftBits)
-+
-+void LzmaEncProps_Init(CLzmaEncProps *p)
-+{
-+  p->level = 5;
-+  p->dictSize = p->mc = 0;
-+  p->lc = p->lp = p->pb = p->algo = p->fb = p->btMode = p->numHashBytes = p->numThreads = -1;
-+  p->writeEndMark = 0;
-+}
-+
-+void LzmaEncProps_Normalize(CLzmaEncProps *p)
-+{
-+  int level = p->level;
-+  if (level < 0) level = 5;
-+  p->level = level;
-+  if (p->dictSize == 0) p->dictSize = (level <= 5 ? (1 << (level * 2 + 14)) : (level == 6 ? (1 << 25) : (1 << 26)));
-+  if (p->lc < 0) p->lc = 3;
-+  if (p->lp < 0) p->lp = 0;
-+  if (p->pb < 0) p->pb = 2;
-+  if (p->algo < 0) p->algo = (level < 5 ? 0 : 1);
-+  if (p->fb < 0) p->fb = (level < 7 ? 32 : 64);
-+  if (p->btMode < 0) p->btMode = (p->algo == 0 ? 0 : 1);
-+  if (p->numHashBytes < 0) p->numHashBytes = 4;
-+  if (p->mc == 0)  p->mc = (16 + (p->fb >> 1)) >> (p->btMode ? 0 : 1);
-+  if (p->numThreads < 0)
-+    p->numThreads =
-+      #ifndef _7ZIP_ST
-+      ((p->btMode && p->algo) ? 2 : 1);
-+      #else
-+      1;
-+      #endif
-+}
-+
-+UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
-+{
-+  CLzmaEncProps props = *props2;
-+  LzmaEncProps_Normalize(&props);
-+  return props.dictSize;
-+}
-+
-+/* #define LZMA_LOG_BSR */
-+/* Define it for Intel's CPU */
-+
-+
-+#ifdef LZMA_LOG_BSR
-+
-+#define kDicLogSizeMaxCompress 30
-+
-+#define BSR2_RET(pos, res) { unsigned long i; _BitScanReverse(&i, (pos)); res = (i + i) + ((pos >> (i - 1)) & 1); }
-+
-+UInt32 GetPosSlot1(UInt32 pos)
-+{
-+  UInt32 res;
-+  BSR2_RET(pos, res);
-+  return res;
-+}
-+#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
-+#define GetPosSlot(pos, res) { if (pos < 2) res = pos; else BSR2_RET(pos, res); }
-+
-+#else
-+
-+#define kNumLogBits (9 + (int)sizeof(size_t) / 2)
-+#define kDicLogSizeMaxCompress ((kNumLogBits - 1) * 2 + 7)
-+
-+void LzmaEnc_FastPosInit(Byte *g_FastPos)
-+{
-+  int c = 2, slotFast;
-+  g_FastPos[0] = 0;
-+  g_FastPos[1] = 1;
-+  
-+  for (slotFast = 2; slotFast < kNumLogBits * 2; slotFast++)
-+  {
-+    UInt32 k = (1 << ((slotFast >> 1) - 1));
-+    UInt32 j;
-+    for (j = 0; j < k; j++, c++)
-+      g_FastPos[c] = (Byte)slotFast;
-+  }
-+}
-+
-+#define BSR2_RET(pos, res) { UInt32 i = 6 + ((kNumLogBits - 1) & \
-+  (0 - (((((UInt32)1 << (kNumLogBits + 6)) - 1) - pos) >> 31))); \
-+  res = p->g_FastPos[pos >> i] + (i * 2); }
-+/*
-+#define BSR2_RET(pos, res) { res = (pos < (1 << (kNumLogBits + 6))) ? \
-+  p->g_FastPos[pos >> 6] + 12 : \
-+  p->g_FastPos[pos >> (6 + kNumLogBits - 1)] + (6 + (kNumLogBits - 1)) * 2; }
-+*/
-+
-+#define GetPosSlot1(pos) p->g_FastPos[pos]
-+#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
-+#define GetPosSlot(pos, res) { if (pos < kNumFullDistances) res = p->g_FastPos[pos]; else BSR2_RET(pos, res); }
-+
-+#endif
-+
-+
-+#define LZMA_NUM_REPS 4
-+
-+typedef unsigned CState;
-+
-+typedef struct
-+{
-+  UInt32 price;
-+
-+  CState state;
-+  int prev1IsChar;
-+  int prev2;
-+
-+  UInt32 posPrev2;
-+  UInt32 backPrev2;
-+
-+  UInt32 posPrev;
-+  UInt32 backPrev;
-+  UInt32 backs[LZMA_NUM_REPS];
-+} COptimal;
-+
-+#define kNumOpts (1 << 12)
-+
-+#define kNumLenToPosStates 4
-+#define kNumPosSlotBits 6
-+#define kDicLogSizeMin 0
-+#define kDicLogSizeMax 32
-+#define kDistTableSizeMax (kDicLogSizeMax * 2)
-+
-+
-+#define kNumAlignBits 4
-+#define kAlignTableSize (1 << kNumAlignBits)
-+#define kAlignMask (kAlignTableSize - 1)
-+
-+#define kStartPosModelIndex 4
-+#define kEndPosModelIndex 14
-+#define kNumPosModels (kEndPosModelIndex - kStartPosModelIndex)
-+
-+#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
-+
-+#ifdef _LZMA_PROB32
-+#define CLzmaProb UInt32
-+#else
-+#define CLzmaProb UInt16
-+#endif
-+
-+#define LZMA_PB_MAX 4
-+#define LZMA_LC_MAX 8
-+#define LZMA_LP_MAX 4
-+
-+#define LZMA_NUM_PB_STATES_MAX (1 << LZMA_PB_MAX)
-+
-+
-+#define kLenNumLowBits 3
-+#define kLenNumLowSymbols (1 << kLenNumLowBits)
-+#define kLenNumMidBits 3
-+#define kLenNumMidSymbols (1 << kLenNumMidBits)
-+#define kLenNumHighBits 8
-+#define kLenNumHighSymbols (1 << kLenNumHighBits)
-+
-+#define kLenNumSymbolsTotal (kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)
-+
-+#define LZMA_MATCH_LEN_MIN 2
-+#define LZMA_MATCH_LEN_MAX (LZMA_MATCH_LEN_MIN + kLenNumSymbolsTotal - 1)
-+
-+#define kNumStates 12
-+
-+typedef struct
-+{
-+  CLzmaProb choice;
-+  CLzmaProb choice2;
-+  CLzmaProb low[LZMA_NUM_PB_STATES_MAX << kLenNumLowBits];
-+  CLzmaProb mid[LZMA_NUM_PB_STATES_MAX << kLenNumMidBits];
-+  CLzmaProb high[kLenNumHighSymbols];
-+} CLenEnc;
-+
-+typedef struct
-+{
-+  CLenEnc p;
-+  UInt32 prices[LZMA_NUM_PB_STATES_MAX][kLenNumSymbolsTotal];
-+  UInt32 tableSize;
-+  UInt32 counters[LZMA_NUM_PB_STATES_MAX];
-+} CLenPriceEnc;
-+
-+typedef struct
-+{
-+  UInt32 range;
-+  Byte cache;
-+  UInt64 low;
-+  UInt64 cacheSize;
-+  Byte *buf;
-+  Byte *bufLim;
-+  Byte *bufBase;
-+  ISeqOutStream *outStream;
-+  UInt64 processed;
-+  SRes res;
-+} CRangeEnc;
-+
-+typedef struct
-+{
-+  CLzmaProb *litProbs;
-+
-+  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
-+  CLzmaProb isRep[kNumStates];
-+  CLzmaProb isRepG0[kNumStates];
-+  CLzmaProb isRepG1[kNumStates];
-+  CLzmaProb isRepG2[kNumStates];
-+  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];
-+
-+  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 << kNumPosSlotBits];
-+  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
-+  CLzmaProb posAlignEncoder[1 << kNumAlignBits];
-+  
-+  CLenPriceEnc lenEnc;
-+  CLenPriceEnc repLenEnc;
-+
-+  UInt32 reps[LZMA_NUM_REPS];
-+  UInt32 state;
-+} CSaveState;
-+
-+typedef struct
-+{
-+  IMatchFinder matchFinder;
-+  void *matchFinderObj;
-+
-+  #ifndef _7ZIP_ST
-+  Bool mtMode;
-+  CMatchFinderMt matchFinderMt;
-+  #endif
-+
-+  CMatchFinder matchFinderBase;
-+
-+  #ifndef _7ZIP_ST
-+  Byte pad[128];
-+  #endif
-+  
-+  UInt32 optimumEndIndex;
-+  UInt32 optimumCurrentIndex;
-+
-+  UInt32 longestMatchLength;
-+  UInt32 numPairs;
-+  UInt32 numAvail;
-+  COptimal opt[kNumOpts];
-+  
-+  #ifndef LZMA_LOG_BSR
-+  Byte g_FastPos[1 << kNumLogBits];
-+  #endif
-+
-+  UInt32 ProbPrices[kBitModelTotal >> kNumMoveReducingBits];
-+  UInt32 matches[LZMA_MATCH_LEN_MAX * 2 + 2 + 1];
-+  UInt32 numFastBytes;
-+  UInt32 additionalOffset;
-+  UInt32 reps[LZMA_NUM_REPS];
-+  UInt32 state;
-+
-+  UInt32 posSlotPrices[kNumLenToPosStates][kDistTableSizeMax];
-+  UInt32 distancesPrices[kNumLenToPosStates][kNumFullDistances];
-+  UInt32 alignPrices[kAlignTableSize];
-+  UInt32 alignPriceCount;
-+
-+  UInt32 distTableSize;
-+
-+  unsigned lc, lp, pb;
-+  unsigned lpMask, pbMask;
-+
-+  CLzmaProb *litProbs;
-+
-+  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
-+  CLzmaProb isRep[kNumStates];
-+  CLzmaProb isRepG0[kNumStates];
-+  CLzmaProb isRepG1[kNumStates];
-+  CLzmaProb isRepG2[kNumStates];
-+  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];
-+
-+  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 << kNumPosSlotBits];
-+  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
-+  CLzmaProb posAlignEncoder[1 << kNumAlignBits];
-+  
-+  CLenPriceEnc lenEnc;
-+  CLenPriceEnc repLenEnc;
-+
-+  unsigned lclp;
-+
-+  Bool fastMode;
-+  
-+  CRangeEnc rc;
-+
-+  Bool writeEndMark;
-+  UInt64 nowPos64;
-+  UInt32 matchPriceCount;
-+  Bool finished;
-+  Bool multiThread;
-+
-+  SRes result;
-+  UInt32 dictSize;
-+  UInt32 matchFinderCycles;
-+
-+  int needInit;
-+
-+  CSaveState saveState;
-+} CLzmaEnc;
-+
-+void LzmaEnc_SaveState(CLzmaEncHandle pp)
-+{
-+  CLzmaEnc *p = (CLzmaEnc *)pp;
-+  CSaveState *dest = &p->saveState;
-+  int i;
-+  dest->lenEnc = p->lenEnc;
-+  dest->repLenEnc = p->repLenEnc;
-+  dest->state = p->state;
-+
-+  for (i = 0; i < kNumStates; i++)
-+  {
-+    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
-+    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
-+  }
-+  for (i = 0; i < kNumLenToPosStates; i++)
-+    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
-+  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
-+  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
-+  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
-+  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
-+  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
-+  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
-+  memcpy(dest->reps, p->reps, sizeof(p->reps));
-+  memcpy(dest->litProbs, p->litProbs, (0x300 << p->lclp) * sizeof(CLzmaProb));
-+}
-+
-+void LzmaEnc_RestoreState(CLzmaEncHandle pp)
-+{
-+  CLzmaEnc *dest = (CLzmaEnc *)pp;
-+  const CSaveState *p = &dest->saveState;
-+  int i;
-+  dest->lenEnc = p->lenEnc;
-+  dest->repLenEnc = p->repLenEnc;
-+  dest->state = p->state;
-+
-+  for (i = 0; i < kNumStates; i++)
-+  {
-+    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
-+    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
-+  }
-+  for (i = 0; i < kNumLenToPosStates; i++)
-+    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
-+  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
-+  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
-+  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
-+  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
-+  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
-+  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
-+  memcpy(dest->reps, p->reps, sizeof(p->reps));
-+  memcpy(dest->litProbs, p->litProbs, (0x300 << dest->lclp) * sizeof(CLzmaProb));
-+}
-+
-+SRes LzmaEnc_SetProps(CLzmaEncHandle pp, const CLzmaEncProps *props2)
-+{
-+  CLzmaEnc *p = (CLzmaEnc *)pp;
-+  CLzmaEncProps props = *props2;
-+  LzmaEncProps_Normalize(&props);
-+
-+  if (props.lc > LZMA_LC_MAX || props.lp > LZMA_LP_MAX || props.pb > LZMA_PB_MAX ||
-+      props.dictSize > (1 << kDicLogSizeMaxCompress) || props.dictSize > (1 << 30))
-+    return SZ_ERROR_PARAM;
-+  p->dictSize = props.dictSize;
-+  p->matchFinderCycles = props.mc;
-+  {
-+    unsigned fb = props.fb;
-+    if (fb < 5)
-+      fb = 5;
-+    if (fb > LZMA_MATCH_LEN_MAX)
-+      fb = LZMA_MATCH_LEN_MAX;
-+    p->numFastBytes = fb;
-+  }
-+  p->lc = props.lc;
-+  p->lp = props.lp;
-+  p->pb = props.pb;
-+  p->fastMode = (props.algo == 0);
-+  p->matchFinderBase.btMode = props.btMode;
-+  {
-+    UInt32 numHashBytes = 4;
-+    if (props.btMode)
-+    {
-+      if (props.numHashBytes < 2)
-+        numHashBytes = 2;
-+      else if (props.numHashBytes < 4)
-+        numHashBytes = props.numHashBytes;
-+    }
-+    p->matchFinderBase.numHashBytes = numHashBytes;
-+  }
-+
-+  p->matchFinderBase.cutValue = props.mc;
-+
-+  p->writeEndMark = props.writeEndMark;
-+
-+  #ifndef _7ZIP_ST
-+  /*
-+  if (newMultiThread != _multiThread)
-+  {
-+    ReleaseMatchFinder();
-+    _multiThread = newMultiThread;
-+  }
-+  */
-+  p->multiThread = (props.numThreads > 1);
-+  #endif
-+
-+  return SZ_OK;
-+}
-+
-+static const int kLiteralNextStates[kNumStates] = {0, 0, 0, 0, 1, 2, 3, 4,  5,  6,   4, 5};
-+static const int kMatchNextStates[kNumStates]   = {7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10};
-+static const int kRepNextStates[kNumStates]     = {8, 8, 8, 8, 8, 8, 8, 11, 11, 11, 11, 11};
-+static const int kShortRepNextStates[kNumStates]= {9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11};
-+
-+#define IsCharState(s) ((s) < 7)
-+
-+#define GetLenToPosState(len) (((len) < kNumLenToPosStates + 1) ? (len) - 2 : kNumLenToPosStates - 1)
-+
-+#define kInfinityPrice (1 << 30)
-+
-+static void RangeEnc_Construct(CRangeEnc *p)
-+{
-+  p->outStream = 0;
-+  p->bufBase = 0;
-+}
-+
-+#define RangeEnc_GetProcessed(p) ((p)->processed + ((p)->buf - (p)->bufBase) + (p)->cacheSize)
-+
-+#define RC_BUF_SIZE (1 << 16)
-+static int RangeEnc_Alloc(CRangeEnc *p, ISzAlloc *alloc)
-+{
-+  if (p->bufBase == 0)
-+  {
-+    p->bufBase = (Byte *)alloc->Alloc(alloc, RC_BUF_SIZE);
-+    if (p->bufBase == 0)
-+      return 0;
-+    p->bufLim = p->bufBase + RC_BUF_SIZE;
-+  }
-+  return 1;
-+}
-+
-+static void RangeEnc_Free(CRangeEnc *p, ISzAlloc *alloc)
-+{
-+  alloc->Free(alloc, p->bufBase);
-+  p->bufBase = 0;
-+}
-+
-+static void RangeEnc_Init(CRangeEnc *p)
-+{
-+  /* Stream.Init(); */
-+  p->low = 0;
-+  p->range = 0xFFFFFFFF;
-+  p->cacheSize = 1;
-+  p->cache = 0;
-+
-+  p->buf = p->bufBase;
-+
-+  p->processed = 0;
-+  p->res = SZ_OK;
-+}
-+
-+static void RangeEnc_FlushStream(CRangeEnc *p)
-+{
-+  size_t num;
-+  if (p->res != SZ_OK)
-+    return;
-+  num = p->buf - p->bufBase;
-+  if (num != p->outStream->Write(p->outStream, p->bufBase, num))
-+    p->res = SZ_ERROR_WRITE;
-+  p->processed += num;
-+  p->buf = p->bufBase;
-+}
-+
-+static void MY_FAST_CALL RangeEnc_ShiftLow(CRangeEnc *p)
-+{
-+  if ((UInt32)p->low < (UInt32)0xFF000000 || (int)(p->low >> 32) != 0)
-+  {
-+    Byte temp = p->cache;
-+    do
-+    {
-+      Byte *buf = p->buf;
-+      *buf++ = (Byte)(temp + (Byte)(p->low >> 32));
-+      p->buf = buf;
-+      if (buf == p->bufLim)
-+        RangeEnc_FlushStream(p);
-+      temp = 0xFF;
-+    }
-+    while (--p->cacheSize != 0);
-+    p->cache = (Byte)((UInt32)p->low >> 24);
-+  }
-+  p->cacheSize++;
-+  p->low = (UInt32)p->low << 8;
-+}
-+
-+static void RangeEnc_FlushData(CRangeEnc *p)
-+{
-+  int i;
-+  for (i = 0; i < 5; i++)
-+    RangeEnc_ShiftLow(p);
-+}
-+
-+static void RangeEnc_EncodeDirectBits(CRangeEnc *p, UInt32 value, int numBits)
-+{
-+  do
-+  {
-+    p->range >>= 1;
-+    p->low += p->range & (0 - ((value >> --numBits) & 1));
-+    if (p->range < kTopValue)
-+    {
-+      p->range <<= 8;
-+      RangeEnc_ShiftLow(p);
-+    }
-+  }
-+  while (numBits != 0);
-+}
-+
-+static void RangeEnc_EncodeBit(CRangeEnc *p, CLzmaProb *prob, UInt32 symbol)
-+{
-+  UInt32 ttt = *prob;
-+  UInt32 newBound = (p->range >> kNumBitModelTotalBits) * ttt;
-+  if (symbol == 0)
-+  {
-+    p->range = newBound;
-+    ttt += (kBitModelTotal - ttt) >> kNumMoveBits;
-+  }
-+  else
-+  {
-+    p->low += newBound;
-+    p->range -= newBound;
-+    ttt -= ttt >> kNumMoveBits;
-+  }
-+  *prob = (CLzmaProb)ttt;
-+  if (p->range < kTopValue)
-+  {
-+    p->range <<= 8;
-+    RangeEnc_ShiftLow(p);
-+  }
-+}
-+
-+static void LitEnc_Encode(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol)
-+{
-+  symbol |= 0x100;
-+  do
-+  {
-+    RangeEnc_EncodeBit(p, probs + (symbol >> 8), (symbol >> 7) & 1);
-+    symbol <<= 1;
-+  }
-+  while (symbol < 0x10000);
-+}
-+
-+static void LitEnc_EncodeMatched(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol, UInt32 matchByte)
-+{
-+  UInt32 offs = 0x100;
-+  symbol |= 0x100;
-+  do
-+  {
-+    matchByte <<= 1;
-+    RangeEnc_EncodeBit(p, probs + (offs + (matchByte & offs) + (symbol >> 8)), (symbol >> 7) & 1);
-+    symbol <<= 1;
-+    offs &= ~(matchByte ^ symbol);
-+  }
-+  while (symbol < 0x10000);
-+}
-+
-+void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
-+{
-+  UInt32 i;
-+  for (i = (1 << kNumMoveReducingBits) / 2; i < kBitModelTotal; i += (1 << kNumMoveReducingBits))
-+  {
-+    const int kCyclesBits = kNumBitPriceShiftBits;
-+    UInt32 w = i;
-+    UInt32 bitCount = 0;
-+    int j;
-+    for (j = 0; j < kCyclesBits; j++)
-+    {
-+      w = w * w;
-+      bitCount <<= 1;
-+      while (w >= ((UInt32)1 << 16))
-+      {
-+        w >>= 1;
-+        bitCount++;
-+      }
-+    }
-+    ProbPrices[i >> kNumMoveReducingBits] = ((kNumBitModelTotalBits << kCyclesBits) - 15 - bitCount);
-+  }
-+}
-+
-+
-+#define GET_PRICE(prob, symbol) \
-+  p->ProbPrices[((prob) ^ (((-(int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];
-+
-+#define GET_PRICEa(prob, symbol) \
-+  ProbPrices[((prob) ^ ((-((int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];
-+
-+#define GET_PRICE_0(prob) p->ProbPrices[(prob) >> kNumMoveReducingBits]
-+#define GET_PRICE_1(prob) p->ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]
-+
-+#define GET_PRICE_0a(prob) ProbPrices[(prob) >> kNumMoveReducingBits]
-+#define GET_PRICE_1a(prob) ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]
-+
-+static UInt32 LitEnc_GetPrice(const CLzmaProb *probs, UInt32 symbol, UInt32 *ProbPrices)
-+{
-+  UInt32 price = 0;
-+  symbol |= 0x100;
-+  do
-+  {
-+    price += GET_PRICEa(probs[symbol >> 8], (symbol >> 7) & 1);
-+    symbol <<= 1;
-+  }
-+  while (symbol < 0x10000);
-+  return price;
-+}
-+
-+static UInt32 LitEnc_GetPriceMatched(const CLzmaProb *probs, UInt32 symbol, UInt32 matchByte, UInt32 *ProbPrices)
-+{
-+  UInt32 price = 0;
-+  UInt32 offs = 0x100;
-+  symbol |= 0x100;
-+  do
-+  {
-+    matchByte <<= 1;
-+    price += GET_PRICEa(probs[offs + (matchByte & offs) + (symbol >> 8)], (symbol >> 7) & 1);
-+    symbol <<= 1;
-+    offs &= ~(matchByte ^ symbol);
-+  }
-+  while (symbol < 0x10000);
-+  return price;
-+}
-+
-+
-+static void RcTree_Encode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
-+{
-+  UInt32 m = 1;
-+  int i;
-+  for (i = numBitLevels; i != 0;)
-+  {
-+    UInt32 bit;
-+    i--;
-+    bit = (symbol >> i) & 1;
-+    RangeEnc_EncodeBit(rc, probs + m, bit);
-+    m = (m << 1) | bit;
-+  }
-+}
-+
-+static void RcTree_ReverseEncode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
-+{
-+  UInt32 m = 1;
-+  int i;
-+  for (i = 0; i < numBitLevels; i++)
-+  {
-+    UInt32 bit = symbol & 1;
-+    RangeEnc_EncodeBit(rc, probs + m, bit);
-+    m = (m << 1) | bit;
-+    symbol >>= 1;
-+  }
-+}
-+
-+static UInt32 RcTree_GetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
-+{
-+  UInt32 price = 0;
-+  symbol |= (1 << numBitLevels);
-+  while (symbol != 1)
-+  {
-+    price += GET_PRICEa(probs[symbol >> 1], symbol & 1);
-+    symbol >>= 1;
-+  }
-+  return price;
-+}
-+
-+static UInt32 RcTree_ReverseGetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
-+{
-+  UInt32 price = 0;
-+  UInt32 m = 1;
-+  int i;
-+  for (i = numBitLevels; i != 0; i--)
-+  {
-+    UInt32 bit = symbol & 1;
-+    symbol >>= 1;
-+    price += GET_PRICEa(probs[m], bit);
-+    m = (m << 1) | bit;
-+  }
-+  return price;
-+}
-+
-+
-+static void LenEnc_Init(CLenEnc *p)
-+{
-+  unsigned i;
-+  p->choice = p->choice2 = kProbInitValue;
-+  for (i = 0; i < (LZMA_NUM_PB_STATES_MAX << kLenNumLowBits); i++)
-+    p->low[i] = kProbInitValue;
-+  for (i = 0; i < (LZMA_NUM_PB_STATES_MAX << kLenNumMidBits); i++)
-+    p->mid[i] = kProbInitValue;
-+  for (i = 0; i < kLenNumHighSymbols; i++)
-+    p->high[i] = kProbInitValue;
-+}
-+
-+static void LenEnc_Encode(CLenEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState)
-+{
-+  if (symbol < kLenNumLowSymbols)
-+  {
-+    RangeEnc_EncodeBit(rc, &p->choice, 0);
-+    RcTree_Encode(rc, p->low + (posState << kLenNumLowBits), kLenNumLowBits, symbol);
-+  }
-+  else
-+  {
-+    RangeEnc_EncodeBit(rc, &p->choice, 1);
-+    if (symbol < kLenNumLowSymbols + kLenNumMidSymbols)
-+    {
-+      RangeEnc_EncodeBit(rc, &p->choice2, 0);
-+      RcTree_Encode(rc, p->mid + (posState << kLenNumMidBits), kLenNumMidBits, symbol - kLenNumLowSymbols);
-+    }
-+    else
-+    {
-+      RangeEnc_EncodeBit(rc, &p->choice2, 1);
-+      RcTree_Encode(rc, p->high, kLenNumHighBits, symbol - kLenNumLowSymbols - kLenNumMidSymbols);
-+    }
-+  }
-+}
-+
-+static void LenEnc_SetPrices(CLenEnc *p, UInt32 posState, UInt32 numSymbols, UInt32 *prices, UInt32 *ProbPrices)
-+{
-+  UInt32 a0 = GET_PRICE_0a(p->choice);
-+  UInt32 a1 = GET_PRICE_1a(p->choice);
-+  UInt32 b0 = a1 + GET_PRICE_0a(p->choice2);
-+  UInt32 b1 = a1 + GET_PRICE_1a(p->choice2);
-+  UInt32 i = 0;
-+  for (i = 0; i < kLenNumLowSymbols; i++)
-+  {
-+    if (i >= numSymbols)
-+      return;
-+    prices[i] = a0 + RcTree_GetPrice(p->low + (posState << kLenNumLowBits), kLenNumLowBits, i, ProbPrices);
-+  }
-+  for (; i < kLenNumLowSymbols + kLenNumMidSymbols; i++)
-+  {
-+    if (i >= numSymbols)
-+      return;
-+    prices[i] = b0 + RcTree_GetPrice(p->mid + (posState << kLenNumMidBits), kLenNumMidBits, i - kLenNumLowSymbols, ProbPrices);
-+  }
-+  for (; i < numSymbols; i++)
-+    prices[i] = b1 + RcTree_GetPrice(p->high, kLenNumHighBits, i - kLenNumLowSymbols - kLenNumMidSymbols, ProbPrices);
-+}
-+
-+static void MY_FAST_CALL LenPriceEnc_UpdateTable(CLenPriceEnc *p, UInt32 posState, UInt32 *ProbPrices)
-+{
-+  LenEnc_SetPrices(&p->p, posState, p->tableSize, p->prices[posState], ProbPrices);
-+  p->counters[posState] = p->tableSize;
-+}
-+
-+static void LenPriceEnc_UpdateTables(CLenPriceEnc *p, UInt32 numPosStates, UInt32 *ProbPrices)
-+{
-+  UInt32 posState;
-+  for (posState = 0; posState < numPosStates; posState++)
-+    LenPriceEnc_UpdateTable(p, posState, ProbPrices);
-+}
-+
-+static void LenEnc_Encode2(CLenPriceEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState, Bool updatePrice, UInt32 *ProbPrices)
-+{
-+  LenEnc_Encode(&p->p, rc, symbol, posState);
-+  if (updatePrice)
-+    if (--p->counters[posState] == 0)
-+      LenPriceEnc_UpdateTable(p, posState, ProbPrices);
-+}
-+
-+
-+
-+
-+static void MovePos(CLzmaEnc *p, UInt32 num)
-+{
-+  #ifdef SHOW_STAT
-+  ttt += num;
-+  printf("\n MovePos %d", num);
-+  #endif
-+  if (num != 0)
-+  {
-+    p->additionalOffset += num;
-+    p->matchFinder.Skip(p->matchFinderObj, num);
-+  }
-+}
-+
-+static UInt32 ReadMatchDistances(CLzmaEnc *p, UInt32 *numDistancePairsRes)
-+{
-+  UInt32 lenRes = 0, numPairs;
-+  p->numAvail = p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
-+  numPairs = p->matchFinder.GetMatches(p->matchFinderObj, p->matches);
-+  #ifdef SHOW_STAT
-+  printf("\n i = %d numPairs = %d    ", ttt, numPairs / 2);
-+  ttt++;
-+  {
-+    UInt32 i;
-+    for (i = 0; i < numPairs; i += 2)
-+      printf("%2d %6d   | ", p->matches[i], p->matches[i + 1]);
-+  }
-+  #endif
-+  if (numPairs > 0)
-+  {
-+    lenRes = p->matches[numPairs - 2];
-+    if (lenRes == p->numFastBytes)
-+    {
-+      const Byte *pby = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
-+      UInt32 distance = p->matches[numPairs - 1] + 1;
-+      UInt32 numAvail = p->numAvail;
-+      if (numAvail > LZMA_MATCH_LEN_MAX)
-+        numAvail = LZMA_MATCH_LEN_MAX;
-+      {
-+        const Byte *pby2 = pby - distance;
-+        for (; lenRes < numAvail && pby[lenRes] == pby2[lenRes]; lenRes++);
-+      }
-+    }
-+  }
-+  p->additionalOffset++;
-+  *numDistancePairsRes = numPairs;
-+  return lenRes;
-+}
-+
-+
-+#define MakeAsChar(p) (p)->backPrev = (UInt32)(-1); (p)->prev1IsChar = False;
-+#define MakeAsShortRep(p) (p)->backPrev = 0; (p)->prev1IsChar = False;
-+#define IsShortRep(p) ((p)->backPrev == 0)
-+
-+static UInt32 GetRepLen1Price(CLzmaEnc *p, UInt32 state, UInt32 posState)
-+{
-+  return
-+    GET_PRICE_0(p->isRepG0[state]) +
-+    GET_PRICE_0(p->isRep0Long[state][posState]);
-+}
-+
-+static UInt32 GetPureRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 state, UInt32 posState)
-+{
-+  UInt32 price;
-+  if (repIndex == 0)
-+  {
-+    price = GET_PRICE_0(p->isRepG0[state]);
-+    price += GET_PRICE_1(p->isRep0Long[state][posState]);
-+  }
-+  else
-+  {
-+    price = GET_PRICE_1(p->isRepG0[state]);
-+    if (repIndex == 1)
-+      price += GET_PRICE_0(p->isRepG1[state]);
-+    else
-+    {
-+      price += GET_PRICE_1(p->isRepG1[state]);
-+      price += GET_PRICE(p->isRepG2[state], repIndex - 2);
-+    }
-+  }
-+  return price;
-+}
-+
-+static UInt32 GetRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 len, UInt32 state, UInt32 posState)
-+{
-+  return p->repLenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN] +
-+    GetPureRepPrice(p, repIndex, state, posState);
-+}
-+
-+static UInt32 Backward(CLzmaEnc *p, UInt32 *backRes, UInt32 cur)
-+{
-+  UInt32 posMem = p->opt[cur].posPrev;
-+  UInt32 backMem = p->opt[cur].backPrev;
-+  p->optimumEndIndex = cur;
-+  do
-+  {
-+    if (p->opt[cur].prev1IsChar)
-+    {
-+      MakeAsChar(&p->opt[posMem])
-+      p->opt[posMem].posPrev = posMem - 1;
-+      if (p->opt[cur].prev2)
-+      {
-+        p->opt[posMem - 1].prev1IsChar = False;
-+        p->opt[posMem - 1].posPrev = p->opt[cur].posPrev2;
-+        p->opt[posMem - 1].backPrev = p->opt[cur].backPrev2;
-+      }
-+    }
-+    {
-+      UInt32 posPrev = posMem;
-+      UInt32 backCur = backMem;
-+      
-+      backMem = p->opt[posPrev].backPrev;
-+      posMem = p->opt[posPrev].posPrev;
-+      
-+      p->opt[posPrev].backPrev = backCur;
-+      p->opt[posPrev].posPrev = cur;
-+      cur = posPrev;
-+    }
-+  }
-+  while (cur != 0);
-+  *backRes = p->opt[0].backPrev;
-+  p->optimumCurrentIndex  = p->opt[0].posPrev;
-+  return p->optimumCurrentIndex;
-+}
-+
-+#define LIT_PROBS(pos, prevByte) (p->litProbs + ((((pos) & p->lpMask) << p->lc) + ((prevByte) >> (8 - p->lc))) * 0x300)
-+
-+static UInt32 GetOptimum(CLzmaEnc *p, UInt32 position, UInt32 *backRes)
-+{
-+  UInt32 numAvail, mainLen, numPairs, repMaxIndex, i, posState, lenEnd, len, cur;
-+  UInt32 matchPrice, repMatchPrice, normalMatchPrice;
-+  UInt32 reps[LZMA_NUM_REPS], repLens[LZMA_NUM_REPS];
-+  UInt32 *matches;
-+  const Byte *data;
-+  Byte curByte, matchByte;
-+  if (p->optimumEndIndex != p->optimumCurrentIndex)
-+  {
-+    const COptimal *opt = &p->opt[p->optimumCurrentIndex];
-+    UInt32 lenRes = opt->posPrev - p->optimumCurrentIndex;
-+    *backRes = opt->backPrev;
-+    p->optimumCurrentIndex = opt->posPrev;
-+    return lenRes;
-+  }
-+  p->optimumCurrentIndex = p->optimumEndIndex = 0;
-+  
-+  if (p->additionalOffset == 0)
-+    mainLen = ReadMatchDistances(p, &numPairs);
-+  else
-+  {
-+    mainLen = p->longestMatchLength;
-+    numPairs = p->numPairs;
-+  }
-+
-+  numAvail = p->numAvail;
-+  if (numAvail < 2)
-+  {
-+    *backRes = (UInt32)(-1);
-+    return 1;
-+  }
-+  if (numAvail > LZMA_MATCH_LEN_MAX)
-+    numAvail = LZMA_MATCH_LEN_MAX;
-+
-+  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
-+  repMaxIndex = 0;
-+  for (i = 0; i < LZMA_NUM_REPS; i++)
-+  {
-+    UInt32 lenTest;
-+    const Byte *data2;
-+    reps[i] = p->reps[i];
-+    data2 = data - (reps[i] + 1);
-+    if (data[0] != data2[0] || data[1] != data2[1])
-+    {
-+      repLens[i] = 0;
-+      continue;
-+    }
-+    for (lenTest = 2; lenTest < numAvail && data[lenTest] == data2[lenTest]; lenTest++);
-+    repLens[i] = lenTest;
-+    if (lenTest > repLens[repMaxIndex])
-+      repMaxIndex = i;
-+  }
-+  if (repLens[repMaxIndex] >= p->numFastBytes)
-+  {
-+    UInt32 lenRes;
-+    *backRes = repMaxIndex;
-+    lenRes = repLens[repMaxIndex];
-+    MovePos(p, lenRes - 1);
-+    return lenRes;
-+  }
-+
-+  matches = p->matches;
-+  if (mainLen >= p->numFastBytes)
-+  {
-+    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
-+    MovePos(p, mainLen - 1);
-+    return mainLen;
-+  }
-+  curByte = *data;
-+  matchByte = *(data - (reps[0] + 1));
-+
-+  if (mainLen < 2 && curByte != matchByte && repLens[repMaxIndex] < 2)
-+  {
-+    *backRes = (UInt32)-1;
-+    return 1;
-+  }
-+
-+  p->opt[0].state = (CState)p->state;
-+
-+  posState = (position & p->pbMask);
-+
-+  {
-+    const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
-+    p->opt[1].price = GET_PRICE_0(p->isMatch[p->state][posState]) +
-+        (!IsCharState(p->state) ?
-+          LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
-+          LitEnc_GetPrice(probs, curByte, p->ProbPrices));
-+  }
-+
-+  MakeAsChar(&p->opt[1]);
-+
-+  matchPrice = GET_PRICE_1(p->isMatch[p->state][posState]);
-+  repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[p->state]);
-+
-+  if (matchByte == curByte)
-+  {
-+    UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, p->state, posState);
-+    if (shortRepPrice < p->opt[1].price)
-+    {
-+      p->opt[1].price = shortRepPrice;
-+      MakeAsShortRep(&p->opt[1]);
-+    }
-+  }
-+  lenEnd = ((mainLen >= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);
-+
-+  if (lenEnd < 2)
-+  {
-+    *backRes = p->opt[1].backPrev;
-+    return 1;
-+  }
-+
-+  p->opt[1].posPrev = 0;
-+  for (i = 0; i < LZMA_NUM_REPS; i++)
-+    p->opt[0].backs[i] = reps[i];
-+
-+  len = lenEnd;
-+  do
-+    p->opt[len--].price = kInfinityPrice;
-+  while (len >= 2);
-+
-+  for (i = 0; i < LZMA_NUM_REPS; i++)
-+  {
-+    UInt32 repLen = repLens[i];
-+    UInt32 price;
-+    if (repLen < 2)
-+      continue;
-+    price = repMatchPrice + GetPureRepPrice(p, i, p->state, posState);
-+    do
-+    {
-+      UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][repLen - 2];
-+      COptimal *opt = &p->opt[repLen];
-+      if (curAndLenPrice < opt->price)
-+      {
-+        opt->price = curAndLenPrice;
-+        opt->posPrev = 0;
-+        opt->backPrev = i;
-+        opt->prev1IsChar = False;
-+      }
-+    }
-+    while (--repLen >= 2);
-+  }
-+
-+  normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[p->state]);
-+
-+  len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
-+  if (len <= mainLen)
-+  {
-+    UInt32 offs = 0;
-+    while (len > matches[offs])
-+      offs += 2;
-+    for (; ; len++)
-+    {
-+      COptimal *opt;
-+      UInt32 distance = matches[offs + 1];
-+
-+      UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN];
-+      UInt32 lenToPosState = GetLenToPosState(len);
-+      if (distance < kNumFullDistances)
-+        curAndLenPrice += p->distancesPrices[lenToPosState][distance];
-+      else
-+      {
-+        UInt32 slot;
-+        GetPosSlot2(distance, slot);
-+        curAndLenPrice += p->alignPrices[distance & kAlignMask] + p->posSlotPrices[lenToPosState][slot];
-+      }
-+      opt = &p->opt[len];
-+      if (curAndLenPrice < opt->price)
-+      {
-+        opt->price = curAndLenPrice;
-+        opt->posPrev = 0;
-+        opt->backPrev = distance + LZMA_NUM_REPS;
-+        opt->prev1IsChar = False;
-+      }
-+      if (len == matches[offs])
-+      {
-+        offs += 2;
-+        if (offs == numPairs)
-+          break;
-+      }
-+    }
-+  }
-+
-+  cur = 0;
-+
-+    #ifdef SHOW_STAT2
-+    if (position >= 0)
-+    {
-+      unsigned i;
-+      printf("\n pos = %4X", position);
-+      for (i = cur; i <= lenEnd; i++)
-+      printf("\nprice[%4X] = %d", position - cur + i, p->opt[i].price);
-+    }
-+    #endif
-+
-+  for (;;)
-+  {
-+    UInt32 numAvailFull, newLen, numPairs, posPrev, state, posState, startLen;
-+    UInt32 curPrice, curAnd1Price, matchPrice, repMatchPrice;
-+    Bool nextIsChar;
-+    Byte curByte, matchByte;
-+    const Byte *data;
-+    COptimal *curOpt;
-+    COptimal *nextOpt;
-+
-+    cur++;
-+    if (cur == lenEnd)
-+      return Backward(p, backRes, cur);
-+
-+    newLen = ReadMatchDistances(p, &numPairs);
-+    if (newLen >= p->numFastBytes)
-+    {
-+      p->numPairs = numPairs;
-+      p->longestMatchLength = newLen;
-+      return Backward(p, backRes, cur);
-+    }
-+    position++;
-+    curOpt = &p->opt[cur];
-+    posPrev = curOpt->posPrev;
-+    if (curOpt->prev1IsChar)
-+    {
-+      posPrev--;
-+      if (curOpt->prev2)
-+      {
-+        state = p->opt[curOpt->posPrev2].state;
-+        if (curOpt->backPrev2 < LZMA_NUM_REPS)
-+          state = kRepNextStates[state];
-+        else
-+          state = kMatchNextStates[state];
-+      }
-+      else
-+        state = p->opt[posPrev].state;
-+      state = kLiteralNextStates[state];
-+    }
-+    else
-+      state = p->opt[posPrev].state;
-+    if (posPrev == cur - 1)
-+    {
-+      if (IsShortRep(curOpt))
-+        state = kShortRepNextStates[state];
-+      else
-+        state = kLiteralNextStates[state];
-+    }
-+    else
-+    {
-+      UInt32 pos;
-+      const COptimal *prevOpt;
-+      if (curOpt->prev1IsChar && curOpt->prev2)
-+      {
-+        posPrev = curOpt->posPrev2;
-+        pos = curOpt->backPrev2;
-+        state = kRepNextStates[state];
-+      }
-+      else
-+      {
-+        pos = curOpt->backPrev;
-+        if (pos < LZMA_NUM_REPS)
-+          state = kRepNextStates[state];
-+        else
-+          state = kMatchNextStates[state];
-+      }
-+      prevOpt = &p->opt[posPrev];
-+      if (pos < LZMA_NUM_REPS)
-+      {
-+        UInt32 i;
-+        reps[0] = prevOpt->backs[pos];
-+        for (i = 1; i <= pos; i++)
-+          reps[i] = prevOpt->backs[i - 1];
-+        for (; i < LZMA_NUM_REPS; i++)
-+          reps[i] = prevOpt->backs[i];
-+      }
-+      else
-+      {
-+        UInt32 i;
-+        reps[0] = (pos - LZMA_NUM_REPS);
-+        for (i = 1; i < LZMA_NUM_REPS; i++)
-+          reps[i] = prevOpt->backs[i - 1];
-+      }
-+    }
-+    curOpt->state = (CState)state;
-+
-+    curOpt->backs[0] = reps[0];
-+    curOpt->backs[1] = reps[1];
-+    curOpt->backs[2] = reps[2];
-+    curOpt->backs[3] = reps[3];
-+
-+    curPrice = curOpt->price;
-+    nextIsChar = False;
-+    data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
-+    curByte = *data;
-+    matchByte = *(data - (reps[0] + 1));
-+
-+    posState = (position & p->pbMask);
-+
-+    curAnd1Price = curPrice + GET_PRICE_0(p->isMatch[state][posState]);
-+    {
-+      const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
-+      curAnd1Price +=
-+        (!IsCharState(state) ?
-+          LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
-+          LitEnc_GetPrice(probs, curByte, p->ProbPrices));
-+    }
-+
-+    nextOpt = &p->opt[cur + 1];
-+
-+    if (curAnd1Price < nextOpt->price)
-+    {
-+      nextOpt->price = curAnd1Price;
-+      nextOpt->posPrev = cur;
-+      MakeAsChar(nextOpt);
-+      nextIsChar = True;
-+    }
-+
-+    matchPrice = curPrice + GET_PRICE_1(p->isMatch[state][posState]);
-+    repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[state]);
-+    
-+    if (matchByte == curByte && !(nextOpt->posPrev < cur && nextOpt->backPrev == 0))
-+    {
-+      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, state, posState);
-+      if (shortRepPrice <= nextOpt->price)
-+      {
-+        nextOpt->price = shortRepPrice;
-+        nextOpt->posPrev = cur;
-+        MakeAsShortRep(nextOpt);
-+        nextIsChar = True;
-+      }
-+    }
-+    numAvailFull = p->numAvail;
-+    {
-+      UInt32 temp = kNumOpts - 1 - cur;
-+      if (temp < numAvailFull)
-+        numAvailFull = temp;
-+    }
-+
-+    if (numAvailFull < 2)
-+      continue;
-+    numAvail = (numAvailFull <= p->numFastBytes ? numAvailFull : p->numFastBytes);
-+
-+    if (!nextIsChar && matchByte != curByte) /* speed optimization */
-+    {
-+      /* try Literal + rep0 */
-+      UInt32 temp;
-+      UInt32 lenTest2;
-+      const Byte *data2 = data - (reps[0] + 1);
-+      UInt32 limit = p->numFastBytes + 1;
-+      if (limit > numAvailFull)
-+        limit = numAvailFull;
-+
-+      for (temp = 1; temp < limit && data[temp] == data2[temp]; temp++);
-+      lenTest2 = temp - 1;
-+      if (lenTest2 >= 2)
-+      {
-+        UInt32 state2 = kLiteralNextStates[state];
-+        UInt32 posStateNext = (position + 1) & p->pbMask;
-+        UInt32 nextRepMatchPrice = curAnd1Price +
-+            GET_PRICE_1(p->isMatch[state2][posStateNext]) +
-+            GET_PRICE_1(p->isRep[state2]);
-+        /* for (; lenTest2 >= 2; lenTest2--) */
-+        {
-+          UInt32 curAndLenPrice;
-+          COptimal *opt;
-+          UInt32 offset = cur + 1 + lenTest2;
-+          while (lenEnd < offset)
-+            p->opt[++lenEnd].price = kInfinityPrice;
-+          curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
-+          opt = &p->opt[offset];
-+          if (curAndLenPrice < opt->price)
-+          {
-+            opt->price = curAndLenPrice;
-+            opt->posPrev = cur + 1;
-+            opt->backPrev = 0;
-+            opt->prev1IsChar = True;
-+            opt->prev2 = False;
-+          }
-+        }
-+      }
-+    }
-+    
-+    startLen = 2; /* speed optimization */
-+    {
-+    UInt32 repIndex;
-+    for (repIndex = 0; repIndex < LZMA_NUM_REPS; repIndex++)
-+    {
-+      UInt32 lenTest;
-+      UInt32 lenTestTemp;
-+      UInt32 price;
-+      const Byte *data2 = data - (reps[repIndex] + 1);
-+      if (data[0] != data2[0] || data[1] != data2[1])
-+        continue;
-+      for (lenTest = 2; lenTest < numAvail && data[lenTest] == data2[lenTest]; lenTest++);
-+      while (lenEnd < cur + lenTest)
-+        p->opt[++lenEnd].price = kInfinityPrice;
-+      lenTestTemp = lenTest;
-+      price = repMatchPrice + GetPureRepPrice(p, repIndex, state, posState);
-+      do
-+      {
-+        UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][lenTest - 2];
-+        COptimal *opt = &p->opt[cur + lenTest];
-+        if (curAndLenPrice < opt->price)
-+        {
-+          opt->price = curAndLenPrice;
-+          opt->posPrev = cur;
-+          opt->backPrev = repIndex;
-+          opt->prev1IsChar = False;
-+        }
-+      }
-+      while (--lenTest >= 2);
-+      lenTest = lenTestTemp;
-+      
-+      if (repIndex == 0)
-+        startLen = lenTest + 1;
-+        
-+      /* if (_maxMode) */
-+        {
-+          UInt32 lenTest2 = lenTest + 1;
-+          UInt32 limit = lenTest2 + p->numFastBytes;
-+          UInt32 nextRepMatchPrice;
-+          if (limit > numAvailFull)
-+            limit = numAvailFull;
-+          for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
-+          lenTest2 -= lenTest + 1;
-+          if (lenTest2 >= 2)
-+          {
-+            UInt32 state2 = kRepNextStates[state];
-+            UInt32 posStateNext = (position + lenTest) & p->pbMask;
-+            UInt32 curAndLenCharPrice =
-+                price + p->repLenEnc.prices[posState][lenTest - 2] +
-+                GET_PRICE_0(p->isMatch[state2][posStateNext]) +
-+                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
-+                    data[lenTest], data2[lenTest], p->ProbPrices);
-+            state2 = kLiteralNextStates[state2];
-+            posStateNext = (position + lenTest + 1) & p->pbMask;
-+            nextRepMatchPrice = curAndLenCharPrice +
-+                GET_PRICE_1(p->isMatch[state2][posStateNext]) +
-+                GET_PRICE_1(p->isRep[state2]);
-+            
-+            /* for (; lenTest2 >= 2; lenTest2--) */
-+            {
-+              UInt32 curAndLenPrice;
-+              COptimal *opt;
-+              UInt32 offset = cur + lenTest + 1 + lenTest2;
-+              while (lenEnd < offset)
-+                p->opt[++lenEnd].price = kInfinityPrice;
-+              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
-+              opt = &p->opt[offset];
-+              if (curAndLenPrice < opt->price)
-+              {
-+                opt->price = curAndLenPrice;
-+                opt->posPrev = cur + lenTest + 1;
-+                opt->backPrev = 0;
-+                opt->prev1IsChar = True;
-+                opt->prev2 = True;
-+                opt->posPrev2 = cur;
-+                opt->backPrev2 = repIndex;
-+              }
-+            }
-+          }
-+        }
-+    }
-+    }
-+    /* for (UInt32 lenTest = 2; lenTest <= newLen; lenTest++) */
-+    if (newLen > numAvail)
-+    {
-+      newLen = numAvail;
-+      for (numPairs = 0; newLen > matches[numPairs]; numPairs += 2);
-+      matches[numPairs] = newLen;
-+      numPairs += 2;
-+    }
-+    if (newLen >= startLen)
-+    {
-+      UInt32 normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[state]);
-+      UInt32 offs, curBack, posSlot;
-+      UInt32 lenTest;
-+      while (lenEnd < cur + newLen)
-+        p->opt[++lenEnd].price = kInfinityPrice;
-+
-+      offs = 0;
-+      while (startLen > matches[offs])
-+        offs += 2;
-+      curBack = matches[offs + 1];
-+      GetPosSlot2(curBack, posSlot);
-+      for (lenTest = /*2*/ startLen; ; lenTest++)
-+      {
-+        UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][lenTest - LZMA_MATCH_LEN_MIN];
-+        UInt32 lenToPosState = GetLenToPosState(lenTest);
-+        COptimal *opt;
-+        if (curBack < kNumFullDistances)
-+          curAndLenPrice += p->distancesPrices[lenToPosState][curBack];
-+        else
-+          curAndLenPrice += p->posSlotPrices[lenToPosState][posSlot] + p->alignPrices[curBack & kAlignMask];
-+        
-+        opt = &p->opt[cur + lenTest];
-+        if (curAndLenPrice < opt->price)
-+        {
-+          opt->price = curAndLenPrice;
-+          opt->posPrev = cur;
-+          opt->backPrev = curBack + LZMA_NUM_REPS;
-+          opt->prev1IsChar = False;
-+        }
-+
-+        if (/*_maxMode && */lenTest == matches[offs])
-+        {
-+          /* Try Match + Literal + Rep0 */
-+          const Byte *data2 = data - (curBack + 1);
-+          UInt32 lenTest2 = lenTest + 1;
-+          UInt32 limit = lenTest2 + p->numFastBytes;
-+          UInt32 nextRepMatchPrice;
-+          if (limit > numAvailFull)
-+            limit = numAvailFull;
-+          for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
-+          lenTest2 -= lenTest + 1;
-+          if (lenTest2 >= 2)
-+          {
-+            UInt32 state2 = kMatchNextStates[state];
-+            UInt32 posStateNext = (position + lenTest) & p->pbMask;
-+            UInt32 curAndLenCharPrice = curAndLenPrice +
-+                GET_PRICE_0(p->isMatch[state2][posStateNext]) +
-+                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
-+                    data[lenTest], data2[lenTest], p->ProbPrices);
-+            state2 = kLiteralNextStates[state2];
-+            posStateNext = (posStateNext + 1) & p->pbMask;
-+            nextRepMatchPrice = curAndLenCharPrice +
-+                GET_PRICE_1(p->isMatch[state2][posStateNext]) +
-+                GET_PRICE_1(p->isRep[state2]);
-+            
-+            /* for (; lenTest2 >= 2; lenTest2--) */
-+            {
-+              UInt32 offset = cur + lenTest + 1 + lenTest2;
-+              UInt32 curAndLenPrice;
-+              COptimal *opt;
-+              while (lenEnd < offset)
-+                p->opt[++lenEnd].price = kInfinityPrice;
-+              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
-+              opt = &p->opt[offset];
-+              if (curAndLenPrice < opt->price)
-+              {
-+                opt->price = curAndLenPrice;
-+                opt->posPrev = cur + lenTest + 1;
-+                opt->backPrev = 0;
-+                opt->prev1IsChar = True;
-+                opt->prev2 = True;
-+                opt->posPrev2 = cur;
-+                opt->backPrev2 = curBack + LZMA_NUM_REPS;
-+              }
-+            }
-+          }
-+          offs += 2;
-+          if (offs == numPairs)
-+            break;
-+          curBack = matches[offs + 1];
-+          if (curBack >= kNumFullDistances)
-+            GetPosSlot2(curBack, posSlot);
-+        }
-+      }
-+    }
-+  }
-+}
-+
-+#define ChangePair(smallDist, bigDist) (((bigDist) >> 7) > (smallDist))
-+
-+static UInt32 GetOptimumFast(CLzmaEnc *p, UInt32 *backRes)
-+{
-+  UInt32 numAvail, mainLen, mainDist, numPairs, repIndex, repLen, i;
-+  const Byte *data;
-+  const UInt32 *matches;
-+
-+  if (p->additionalOffset == 0)
-+    mainLen = ReadMatchDistances(p, &numPairs);
-+  else
-+  {
-+    mainLen = p->longestMatchLength;
-+    numPairs = p->numPairs;
-+  }
-+
-+  numAvail = p->numAvail;
-+  *backRes = (UInt32)-1;
-+  if (numAvail < 2)
-+    return 1;
-+  if (numAvail > LZMA_MATCH_LEN_MAX)
-+    numAvail = LZMA_MATCH_LEN_MAX;
-+  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
-+
-+  repLen = repIndex = 0;
-+  for (i = 0; i < LZMA_NUM_REPS; i++)
-+  {
-+    UInt32 len;
-+    const Byte *data2 = data - (p->reps[i] + 1);
-+    if (data[0] != data2[0] || data[1] != data2[1])
-+      continue;
-+    for (len = 2; len < numAvail && data[len] == data2[len]; len++);
-+    if (len >= p->numFastBytes)
-+    {
-+      *backRes = i;
-+      MovePos(p, len - 1);
-+      return len;
-+    }
-+    if (len > repLen)
-+    {
-+      repIndex = i;
-+      repLen = len;
-+    }
-+  }
-+
-+  matches = p->matches;
-+  if (mainLen >= p->numFastBytes)
-+  {
-+    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
-+    MovePos(p, mainLen - 1);
-+    return mainLen;
-+  }
-+
-+  mainDist = 0; /* for GCC */
-+  if (mainLen >= 2)
-+  {
-+    mainDist = matches[numPairs - 1];
-+    while (numPairs > 2 && mainLen == matches[numPairs - 4] + 1)
-+    {
-+      if (!ChangePair(matches[numPairs - 3], mainDist))
-+        break;
-+      numPairs -= 2;
-+      mainLen = matches[numPairs - 2];
-+      mainDist = matches[numPairs - 1];
-+    }
-+    if (mainLen == 2 && mainDist >= 0x80)
-+      mainLen = 1;
-+  }
-+
-+  if (repLen >= 2 && (
-+        (repLen + 1 >= mainLen) ||
-+        (repLen + 2 >= mainLen && mainDist >= (1 << 9)) ||
-+        (repLen + 3 >= mainLen && mainDist >= (1 << 15))))
-+  {
-+    *backRes = repIndex;
-+    MovePos(p, repLen - 1);
-+    return repLen;
-+  }
-+  
-+  if (mainLen < 2 || numAvail <= 2)
-+    return 1;
-+
-+  p->longestMatchLength = ReadMatchDistances(p, &p->numPairs);
-+  if (p->longestMatchLength >= 2)
-+  {
-+    UInt32 newDistance = matches[p->numPairs - 1];
-+    if ((p->longestMatchLength >= mainLen && newDistance < mainDist) ||
-+        (p->longestMatchLength == mainLen + 1 && !ChangePair(mainDist, newDistance)) ||
-+        (p->longestMatchLength > mainLen + 1) ||
-+        (p->longestMatchLength + 1 >= mainLen && mainLen >= 3 && ChangePair(newDistance, mainDist)))
-+      return 1;
-+  }
-+  
-+  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
-+  for (i = 0; i < LZMA_NUM_REPS; i++)
-+  {
-+    UInt32 len, limit;
-+    const Byte *data2 = data - (p->reps[i] + 1);
-+    if (data[0] != data2[0] || data[1] != data2[1])
-+      continue;
-+    limit = mainLen - 1;
-+    for (len = 2; len < limit && data[len] == data2[len]; len++);
-+    if (len >= limit)
-+      return 1;
-+  }
-+  *backRes = mainDist + LZMA_NUM_REPS;
-+  MovePos(p, mainLen - 2);
-+  return mainLen;
-+}
-+
-+static void WriteEndMarker(CLzmaEnc *p, UInt32 posState)
-+{
-+  UInt32 len;
-+  RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 1);
-+  RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 0);
-+  p->state = kMatchNextStates[p->state];
-+  len = LZMA_MATCH_LEN_MIN;
-+  LenEnc_Encode2(&p->lenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
-+  RcTree_Encode(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, (1 << kNumPosSlotBits) - 1);
-+  RangeEnc_EncodeDirectBits(&p->rc, (((UInt32)1 << 30) - 1) >> kNumAlignBits, 30 - kNumAlignBits);
-+  RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, kAlignMask);
-+}
-+
-+static SRes CheckErrors(CLzmaEnc *p)
-+{
-+  if (p->result != SZ_OK)
-+    return p->result;
-+  if (p->rc.res != SZ_OK)
-+    p->result = SZ_ERROR_WRITE;
-+  if (p->matchFinderBase.result != SZ_OK)
-+    p->result = SZ_ERROR_READ;
-+  if (p->result != SZ_OK)
-+    p->finished = True;
-+  return p->result;
-+}
-+
-+static SRes Flush(CLzmaEnc *p, UInt32 nowPos)
-+{
-+  /* ReleaseMFStream(); */
-+  p->finished = True;
-+  if (p->writeEndMark)
-+    WriteEndMarker(p, nowPos & p->pbMask);
-+  RangeEnc_FlushData(&p->rc);
-+  RangeEnc_FlushStream(&p->rc);
-+  return CheckErrors(p);
-+}
-+
-+static void FillAlignPrices(CLzmaEnc *p)
-+{
-+  UInt32 i;
-+  for (i = 0; i < kAlignTableSize; i++)
-+    p->alignPrices[i] = RcTree_ReverseGetPrice(p->posAlignEncoder, kNumAlignBits, i, p->ProbPrices);
-+  p->alignPriceCount = 0;
-+}
-+
-+static void FillDistancesPrices(CLzmaEnc *p)
-+{
-+  UInt32 tempPrices[kNumFullDistances];
-+  UInt32 i, lenToPosState;
-+  for (i = kStartPosModelIndex; i < kNumFullDistances; i++)
-+  {
-+    UInt32 posSlot = GetPosSlot1(i);
-+    UInt32 footerBits = ((posSlot >> 1) - 1);
-+    UInt32 base = ((2 | (posSlot & 1)) << footerBits);
-+    tempPrices[i] = RcTree_ReverseGetPrice(p->posEncoders + base - posSlot - 1, footerBits, i - base, p->ProbPrices);
-+  }
-+
-+  for (lenToPosState = 0; lenToPosState < kNumLenToPosStates; lenToPosState++)
-+  {
-+    UInt32 posSlot;
-+    const CLzmaProb *encoder = p->posSlotEncoder[lenToPosState];
-+    UInt32 *posSlotPrices = p->posSlotPrices[lenToPosState];
-+    for (posSlot = 0; posSlot < p->distTableSize; posSlot++)
-+      posSlotPrices[posSlot] = RcTree_GetPrice(encoder, kNumPosSlotBits, posSlot, p->ProbPrices);
-+    for (posSlot = kEndPosModelIndex; posSlot < p->distTableSize; posSlot++)
-+      posSlotPrices[posSlot] += ((((posSlot >> 1) - 1) - kNumAlignBits) << kNumBitPriceShiftBits);
-+
-+    {
-+      UInt32 *distancesPrices = p->distancesPrices[lenToPosState];
-+      UInt32 i;
-+      for (i = 0; i < kStartPosModelIndex; i++)
-+        distancesPrices[i] = posSlotPrices[i];
-+      for (; i < kNumFullDistances; i++)
-+        distancesPrices[i] = posSlotPrices[GetPosSlot1(i)] + tempPrices[i];
-+    }
-+  }
-+  p->matchPriceCount = 0;
-+}
-+
-+void LzmaEnc_Construct(CLzmaEnc *p)
-+{
-+  RangeEnc_Construct(&p->rc);
-+  MatchFinder_Construct(&p->matchFinderBase);
-+  #ifndef _7ZIP_ST
-+  MatchFinderMt_Construct(&p->matchFinderMt);
-+  p->matchFinderMt.MatchFinder = &p->matchFinderBase;
-+  #endif
-+
-+  {
-+    CLzmaEncProps props;
-+    LzmaEncProps_Init(&props);
-+    LzmaEnc_SetProps(p, &props);
-+  }
-+
-+  #ifndef LZMA_LOG_BSR
-+  LzmaEnc_FastPosInit(p->g_FastPos);
-+  #endif
-+
-+  LzmaEnc_InitPriceTables(p->ProbPrices);
-+  p->litProbs = 0;
-+  p->saveState.litProbs = 0;
-+}
-+
-+CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc)
-+{
-+  void *p;
-+  p = alloc->Alloc(alloc, sizeof(CLzmaEnc));
-+  if (p != 0)
-+    LzmaEnc_Construct((CLzmaEnc *)p);
-+  return p;
-+}
-+
-+void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
-+{
-+  alloc->Free(alloc, p->litProbs);
-+  alloc->Free(alloc, p->saveState.litProbs);
-+  p->litProbs = 0;
-+  p->saveState.litProbs = 0;
-+}
-+
-+void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  #ifndef _7ZIP_ST
-+  MatchFinderMt_Destruct(&p->matchFinderMt, allocBig);
-+  #endif
-+  MatchFinder_Free(&p->matchFinderBase, allocBig);
-+  LzmaEnc_FreeLits(p, alloc);
-+  RangeEnc_Free(&p->rc, alloc);
-+}
-+
-+void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  LzmaEnc_Destruct((CLzmaEnc *)p, alloc, allocBig);
-+  alloc->Free(alloc, p);
-+}
-+
-+static SRes LzmaEnc_CodeOneBlock(CLzmaEnc *p, Bool useLimits, UInt32 maxPackSize, UInt32 maxUnpackSize)
-+{
-+  UInt32 nowPos32, startPos32;
-+  if (p->needInit)
-+  {
-+    p->matchFinder.Init(p->matchFinderObj);
-+    p->needInit = 0;
-+  }
-+
-+  if (p->finished)
-+    return p->result;
-+  RINOK(CheckErrors(p));
-+
-+  nowPos32 = (UInt32)p->nowPos64;
-+  startPos32 = nowPos32;
-+
-+  if (p->nowPos64 == 0)
-+  {
-+    UInt32 numPairs;
-+    Byte curByte;
-+    if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
-+      return Flush(p, nowPos32);
-+    ReadMatchDistances(p, &numPairs);
-+    RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][0], 0);
-+    p->state = kLiteralNextStates[p->state];
-+    curByte = p->matchFinder.GetIndexByte(p->matchFinderObj, 0 - p->additionalOffset);
-+    LitEnc_Encode(&p->rc, p->litProbs, curByte);
-+    p->additionalOffset--;
-+    nowPos32++;
-+  }
-+
-+  if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) != 0)
-+  for (;;)
-+  {
-+    UInt32 pos, len, posState;
-+
-+    if (p->fastMode)
-+      len = GetOptimumFast(p, &pos);
-+    else
-+      len = GetOptimum(p, nowPos32, &pos);
-+
-+    #ifdef SHOW_STAT2
-+    printf("\n pos = %4X,   len = %d   pos = %d", nowPos32, len, pos);
-+    #endif
-+
-+    posState = nowPos32 & p->pbMask;
-+    if (len == 1 && pos == (UInt32)-1)
-+    {
-+      Byte curByte;
-+      CLzmaProb *probs;
-+      const Byte *data;
-+
-+      RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 0);
-+      data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
-+      curByte = *data;
-+      probs = LIT_PROBS(nowPos32, *(data - 1));
-+      if (IsCharState(p->state))
-+        LitEnc_Encode(&p->rc, probs, curByte);
-+      else
-+        LitEnc_EncodeMatched(&p->rc, probs, curByte, *(data - p->reps[0] - 1));
-+      p->state = kLiteralNextStates[p->state];
-+    }
-+    else
-+    {
-+      RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 1);
-+      if (pos < LZMA_NUM_REPS)
-+      {
-+        RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 1);
-+        if (pos == 0)
-+        {
-+          RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 0);
-+          RangeEnc_EncodeBit(&p->rc, &p->isRep0Long[p->state][posState], ((len == 1) ? 0 : 1));
-+        }
-+        else
-+        {
-+          UInt32 distance = p->reps[pos];
-+          RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 1);
-+          if (pos == 1)
-+            RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 0);
-+          else
-+          {
-+            RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 1);
-+            RangeEnc_EncodeBit(&p->rc, &p->isRepG2[p->state], pos - 2);
-+            if (pos == 3)
-+              p->reps[3] = p->reps[2];
-+            p->reps[2] = p->reps[1];
-+          }
-+          p->reps[1] = p->reps[0];
-+          p->reps[0] = distance;
-+        }
-+        if (len == 1)
-+          p->state = kShortRepNextStates[p->state];
-+        else
-+        {
-+          LenEnc_Encode2(&p->repLenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
-+          p->state = kRepNextStates[p->state];
-+        }
-+      }
-+      else
-+      {
-+        UInt32 posSlot;
-+        RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 0);
-+        p->state = kMatchNextStates[p->state];
-+        LenEnc_Encode2(&p->lenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
-+        pos -= LZMA_NUM_REPS;
-+        GetPosSlot(pos, posSlot);
-+        RcTree_Encode(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, posSlot);
-+        
-+        if (posSlot >= kStartPosModelIndex)
-+        {
-+          UInt32 footerBits = ((posSlot >> 1) - 1);
-+          UInt32 base = ((2 | (posSlot & 1)) << footerBits);
-+          UInt32 posReduced = pos - base;
-+
-+          if (posSlot < kEndPosModelIndex)
-+            RcTree_ReverseEncode(&p->rc, p->posEncoders + base - posSlot - 1, footerBits, posReduced);
-+          else
-+          {
-+            RangeEnc_EncodeDirectBits(&p->rc, posReduced >> kNumAlignBits, footerBits - kNumAlignBits);
-+            RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, posReduced & kAlignMask);
-+            p->alignPriceCount++;
-+          }
-+        }
-+        p->reps[3] = p->reps[2];
-+        p->reps[2] = p->reps[1];
-+        p->reps[1] = p->reps[0];
-+        p->reps[0] = pos;
-+        p->matchPriceCount++;
-+      }
-+    }
-+    p->additionalOffset -= len;
-+    nowPos32 += len;
-+    if (p->additionalOffset == 0)
-+    {
-+      UInt32 processed;
-+      if (!p->fastMode)
-+      {
-+        if (p->matchPriceCount >= (1 << 7))
-+          FillDistancesPrices(p);
-+        if (p->alignPriceCount >= kAlignTableSize)
-+          FillAlignPrices(p);
-+      }
-+      if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
-+        break;
-+      processed = nowPos32 - startPos32;
-+      if (useLimits)
-+      {
-+        if (processed + kNumOpts + 300 >= maxUnpackSize ||
-+            RangeEnc_GetProcessed(&p->rc) + kNumOpts * 2 >= maxPackSize)
-+          break;
-+      }
-+      else if (processed >= (1 << 15))
-+      {
-+        p->nowPos64 += nowPos32 - startPos32;
-+        return CheckErrors(p);
-+      }
-+    }
-+  }
-+  p->nowPos64 += nowPos32 - startPos32;
-+  return Flush(p, nowPos32);
-+}
-+
-+#define kBigHashDicLimit ((UInt32)1 << 24)
-+
-+static SRes LzmaEnc_Alloc(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  UInt32 beforeSize = kNumOpts;
-+  Bool btMode;
-+  if (!RangeEnc_Alloc(&p->rc, alloc))
-+    return SZ_ERROR_MEM;
-+  btMode = (p->matchFinderBase.btMode != 0);
-+  #ifndef _7ZIP_ST
-+  p->mtMode = (p->multiThread && !p->fastMode && btMode);
-+  #endif
-+
-+  {
-+    unsigned lclp = p->lc + p->lp;
-+    if (p->litProbs == 0 || p->saveState.litProbs == 0 || p->lclp != lclp)
-+    {
-+      LzmaEnc_FreeLits(p, alloc);
-+      p->litProbs = (CLzmaProb *)alloc->Alloc(alloc, (0x300 << lclp) * sizeof(CLzmaProb));
-+      p->saveState.litProbs = (CLzmaProb *)alloc->Alloc(alloc, (0x300 << lclp) * sizeof(CLzmaProb));
-+      if (p->litProbs == 0 || p->saveState.litProbs == 0)
-+      {
-+        LzmaEnc_FreeLits(p, alloc);
-+        return SZ_ERROR_MEM;
-+      }
-+      p->lclp = lclp;
-+    }
-+  }
-+
-+  p->matchFinderBase.bigHash = (p->dictSize > kBigHashDicLimit);
-+
-+  if (beforeSize + p->dictSize < keepWindowSize)
-+    beforeSize = keepWindowSize - p->dictSize;
-+
-+  #ifndef _7ZIP_ST
-+  if (p->mtMode)
-+  {
-+    RINOK(MatchFinderMt_Create(&p->matchFinderMt, p->dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX, allocBig));
-+    p->matchFinderObj = &p->matchFinderMt;
-+    MatchFinderMt_CreateVTable(&p->matchFinderMt, &p->matchFinder);
-+  }
-+  else
-+  #endif
-+  {
-+    if (!MatchFinder_Create(&p->matchFinderBase, p->dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX, allocBig))
-+      return SZ_ERROR_MEM;
-+    p->matchFinderObj = &p->matchFinderBase;
-+    MatchFinder_CreateVTable(&p->matchFinderBase, &p->matchFinder);
-+  }
-+  return SZ_OK;
-+}
-+
-+void LzmaEnc_Init(CLzmaEnc *p)
-+{
-+  UInt32 i;
-+  p->state = 0;
-+  for (i = 0 ; i < LZMA_NUM_REPS; i++)
-+    p->reps[i] = 0;
-+
-+  RangeEnc_Init(&p->rc);
-+
-+
-+  for (i = 0; i < kNumStates; i++)
-+  {
-+    UInt32 j;
-+    for (j = 0; j < LZMA_NUM_PB_STATES_MAX; j++)
-+    {
-+      p->isMatch[i][j] = kProbInitValue;
-+      p->isRep0Long[i][j] = kProbInitValue;
-+    }
-+    p->isRep[i] = kProbInitValue;
-+    p->isRepG0[i] = kProbInitValue;
-+    p->isRepG1[i] = kProbInitValue;
-+    p->isRepG2[i] = kProbInitValue;
-+  }
-+
-+  {
-+    UInt32 num = 0x300 << (p->lp + p->lc);
-+    for (i = 0; i < num; i++)
-+      p->litProbs[i] = kProbInitValue;
-+  }
-+
-+  {
-+    for (i = 0; i < kNumLenToPosStates; i++)
-+    {
-+      CLzmaProb *probs = p->posSlotEncoder[i];
-+      UInt32 j;
-+      for (j = 0; j < (1 << kNumPosSlotBits); j++)
-+        probs[j] = kProbInitValue;
-+    }
-+  }
-+  {
-+    for (i = 0; i < kNumFullDistances - kEndPosModelIndex; i++)
-+      p->posEncoders[i] = kProbInitValue;
-+  }
-+
-+  LenEnc_Init(&p->lenEnc.p);
-+  LenEnc_Init(&p->repLenEnc.p);
-+
-+  for (i = 0; i < (1 << kNumAlignBits); i++)
-+    p->posAlignEncoder[i] = kProbInitValue;
-+
-+  p->optimumEndIndex = 0;
-+  p->optimumCurrentIndex = 0;
-+  p->additionalOffset = 0;
-+
-+  p->pbMask = (1 << p->pb) - 1;
-+  p->lpMask = (1 << p->lp) - 1;
-+}
-+
-+void LzmaEnc_InitPrices(CLzmaEnc *p)
-+{
-+  if (!p->fastMode)
-+  {
-+    FillDistancesPrices(p);
-+    FillAlignPrices(p);
-+  }
-+
-+  p->lenEnc.tableSize =
-+  p->repLenEnc.tableSize =
-+      p->numFastBytes + 1 - LZMA_MATCH_LEN_MIN;
-+  LenPriceEnc_UpdateTables(&p->lenEnc, 1 << p->pb, p->ProbPrices);
-+  LenPriceEnc_UpdateTables(&p->repLenEnc, 1 << p->pb, p->ProbPrices);
-+}
-+
-+static SRes LzmaEnc_AllocAndInit(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  UInt32 i;
-+  for (i = 0; i < (UInt32)kDicLogSizeMaxCompress; i++)
-+    if (p->dictSize <= ((UInt32)1 << i))
-+      break;
-+  p->distTableSize = i * 2;
-+
-+  p->finished = False;
-+  p->result = SZ_OK;
-+  RINOK(LzmaEnc_Alloc(p, keepWindowSize, alloc, allocBig));
-+  LzmaEnc_Init(p);
-+  LzmaEnc_InitPrices(p);
-+  p->nowPos64 = 0;
-+  return SZ_OK;
-+}
-+
-+static SRes LzmaEnc_Prepare(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream,
-+    ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  CLzmaEnc *p = (CLzmaEnc *)pp;
-+  p->matchFinderBase.stream = inStream;
-+  p->needInit = 1;
-+  p->rc.outStream = outStream;
-+  return LzmaEnc_AllocAndInit(p, 0, alloc, allocBig);
-+}
-+
-+SRes LzmaEnc_PrepareForLzma2(CLzmaEncHandle pp,
-+    ISeqInStream *inStream, UInt32 keepWindowSize,
-+    ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  CLzmaEnc *p = (CLzmaEnc *)pp;
-+  p->matchFinderBase.stream = inStream;
-+  p->needInit = 1;
-+  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
-+}
-+
-+static void LzmaEnc_SetInputBuf(CLzmaEnc *p, const Byte *src, SizeT srcLen)
-+{
-+  p->matchFinderBase.directInput = 1;
-+  p->matchFinderBase.bufferBase = (Byte *)src;
-+  p->matchFinderBase.directInputRem = srcLen;
-+}
-+
-+SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
-+    UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  CLzmaEnc *p = (CLzmaEnc *)pp;
-+  LzmaEnc_SetInputBuf(p, src, srcLen);
-+  p->needInit = 1;
-+
-+  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
-+}
-+
-+void LzmaEnc_Finish(CLzmaEncHandle pp)
-+{
-+  #ifndef _7ZIP_ST
-+  CLzmaEnc *p = (CLzmaEnc *)pp;
-+  if (p->mtMode)
-+    MatchFinderMt_ReleaseStream(&p->matchFinderMt);
-+  #else
-+  pp = pp;
-+  #endif
-+}
-+
-+typedef struct
-+{
-+  ISeqOutStream funcTable;
-+  Byte *data;
-+  SizeT rem;
-+  Bool overflow;
-+} CSeqOutStreamBuf;
-+
-+static size_t MyWrite(void *pp, const void *data, size_t size)
-+{
-+  CSeqOutStreamBuf *p = (CSeqOutStreamBuf *)pp;
-+  if (p->rem < size)
-+  {
-+    size = p->rem;
-+    p->overflow = True;
-+  }
-+  memcpy(p->data, data, size);
-+  p->rem -= size;
-+  p->data += size;
-+  return size;
-+}
-+
-+
-+UInt32 LzmaEnc_GetNumAvailableBytes(CLzmaEncHandle pp)
-+{
-+  const CLzmaEnc *p = (CLzmaEnc *)pp;
-+  return p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
-+}
-+
-+const Byte *LzmaEnc_GetCurBuf(CLzmaEncHandle pp)
-+{
-+  const CLzmaEnc *p = (CLzmaEnc *)pp;
-+  return p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
-+}
-+
-+SRes LzmaEnc_CodeOneMemBlock(CLzmaEncHandle pp, Bool reInit,
-+    Byte *dest, size_t *destLen, UInt32 desiredPackSize, UInt32 *unpackSize)
-+{
-+  CLzmaEnc *p = (CLzmaEnc *)pp;
-+  UInt64 nowPos64;
-+  SRes res;
-+  CSeqOutStreamBuf outStream;
-+
-+  outStream.funcTable.Write = MyWrite;
-+  outStream.data = dest;
-+  outStream.rem = *destLen;
-+  outStream.overflow = False;
-+
-+  p->writeEndMark = False;
-+  p->finished = False;
-+  p->result = SZ_OK;
-+
-+  if (reInit)
-+    LzmaEnc_Init(p);
-+  LzmaEnc_InitPrices(p);
-+  nowPos64 = p->nowPos64;
-+  RangeEnc_Init(&p->rc);
-+  p->rc.outStream = &outStream.funcTable;
-+
-+  res = LzmaEnc_CodeOneBlock(p, True, desiredPackSize, *unpackSize);
-+  
-+  *unpackSize = (UInt32)(p->nowPos64 - nowPos64);
-+  *destLen -= outStream.rem;
-+  if (outStream.overflow)
-+    return SZ_ERROR_OUTPUT_EOF;
-+
-+  return res;
-+}
-+
-+static SRes LzmaEnc_Encode2(CLzmaEnc *p, ICompressProgress *progress)
-+{
-+  SRes res = SZ_OK;
-+
-+  #ifndef _7ZIP_ST
-+  Byte allocaDummy[0x300];
-+  int i = 0;
-+  for (i = 0; i < 16; i++)
-+    allocaDummy[i] = (Byte)i;
-+  #endif
-+
-+  for (;;)
-+  {
-+    res = LzmaEnc_CodeOneBlock(p, False, 0, 0);
-+    if (res != SZ_OK || p->finished != 0)
-+      break;
-+    if (progress != 0)
-+    {
-+      res = progress->Progress(progress, p->nowPos64, RangeEnc_GetProcessed(&p->rc));
-+      if (res != SZ_OK)
-+      {
-+        res = SZ_ERROR_PROGRESS;
-+        break;
-+      }
-+    }
-+  }
-+  LzmaEnc_Finish(p);
-+  return res;
-+}
-+
-+SRes LzmaEnc_Encode(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress,
-+    ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  RINOK(LzmaEnc_Prepare(pp, outStream, inStream, alloc, allocBig));
-+  return LzmaEnc_Encode2((CLzmaEnc *)pp, progress);
-+}
-+
-+SRes LzmaEnc_WriteProperties(CLzmaEncHandle pp, Byte *props, SizeT *size)
-+{
-+  CLzmaEnc *p = (CLzmaEnc *)pp;
-+  int i;
-+  UInt32 dictSize = p->dictSize;
-+  if (*size < LZMA_PROPS_SIZE)
-+    return SZ_ERROR_PARAM;
-+  *size = LZMA_PROPS_SIZE;
-+  props[0] = (Byte)((p->pb * 5 + p->lp) * 9 + p->lc);
-+
-+  for (i = 11; i <= 30; i++)
-+  {
-+    if (dictSize <= ((UInt32)2 << i))
-+    {
-+      dictSize = (2 << i);
-+      break;
-+    }
-+    if (dictSize <= ((UInt32)3 << i))
-+    {
-+      dictSize = (3 << i);
-+      break;
-+    }
-+  }
-+
-+  for (i = 0; i < 4; i++)
-+    props[1 + i] = (Byte)(dictSize >> (8 * i));
-+  return SZ_OK;
-+}
-+
-+SRes LzmaEnc_MemEncode(CLzmaEncHandle pp, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-+    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  SRes res;
-+  CLzmaEnc *p = (CLzmaEnc *)pp;
-+
-+  CSeqOutStreamBuf outStream;
-+
-+  LzmaEnc_SetInputBuf(p, src, srcLen);
-+
-+  outStream.funcTable.Write = MyWrite;
-+  outStream.data = dest;
-+  outStream.rem = *destLen;
-+  outStream.overflow = False;
-+
-+  p->writeEndMark = writeEndMark;
-+
-+  p->rc.outStream = &outStream.funcTable;
-+  res = LzmaEnc_MemPrepare(pp, src, srcLen, 0, alloc, allocBig);
-+  if (res == SZ_OK)
-+    res = LzmaEnc_Encode2(p, progress);
-+
-+  *destLen -= outStream.rem;
-+  if (outStream.overflow)
-+    return SZ_ERROR_OUTPUT_EOF;
-+  return res;
-+}
-+
-+SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-+    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
-+    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  CLzmaEnc *p = (CLzmaEnc *)LzmaEnc_Create(alloc);
-+  SRes res;
-+  if (p == 0)
-+    return SZ_ERROR_MEM;
-+
-+  res = LzmaEnc_SetProps(p, props);
-+  if (res == SZ_OK)
-+  {
-+    res = LzmaEnc_WriteProperties(p, propsEncoded, propsSize);
-+    if (res == SZ_OK)
-+      res = LzmaEnc_MemEncode(p, dest, destLen, src, srcLen,
-+          writeEndMark, progress, alloc, allocBig);
-+  }
-+
-+  LzmaEnc_Destroy(p, alloc, allocBig);
-+  return res;
-+}
---- /dev/null
-+++ b/lib/lzma/Makefile
-@@ -0,0 +1,7 @@
-+lzma_compress-objs := LzFind.o LzmaEnc.o
-+lzma_decompress-objs := LzmaDec.o
-+
-+obj-$(CONFIG_LZMA_COMPRESS) += lzma_compress.o
-+obj-$(CONFIG_LZMA_DECOMPRESS) += lzma_decompress.o
-+
-+EXTRA_CFLAGS += -Iinclude/linux -Iinclude/linux/lzma -include types.h
--- a/target/linux/generic/pending-3.18/531-debloat_lzma.patch	2022-03-22 08:54:47.319464856 +0800
+++ b/target/linux/generic/pending-3.18/531-debloat_lzma.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,1024 +0,0 @@
---- a/include/linux/lzma/LzmaDec.h
-+++ b/include/linux/lzma/LzmaDec.h
-@@ -31,14 +31,6 @@ typedef struct _CLzmaProps
-   UInt32 dicSize;
- } CLzmaProps;
- 
--/* LzmaProps_Decode - decodes properties
--Returns:
--  SZ_OK
--  SZ_ERROR_UNSUPPORTED - Unsupported properties
--*/
--
--SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size);
--
- 
- /* ---------- LZMA Decoder state ---------- */
- 
-@@ -70,8 +62,6 @@ typedef struct
- 
- #define LzmaDec_Construct(p) { (p)->dic = 0; (p)->probs = 0; }
- 
--void LzmaDec_Init(CLzmaDec *p);
--
- /* There are two types of LZMA streams:
-      0) Stream with end mark. That end mark adds about 6 bytes to compressed size.
-      1) Stream without end mark. You must know exact uncompressed size to decompress such stream. */
-@@ -108,97 +98,6 @@ typedef enum
- 
- /* ELzmaStatus is used only as output value for function call */
- 
--
--/* ---------- Interfaces ---------- */
--
--/* There are 3 levels of interfaces:
--     1) Dictionary Interface
--     2) Buffer Interface
--     3) One Call Interface
--   You can select any of these interfaces, but don't mix functions from different
--   groups for same object. */
--
--
--/* There are two variants to allocate state for Dictionary Interface:
--     1) LzmaDec_Allocate / LzmaDec_Free
--     2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs
--   You can use variant 2, if you set dictionary buffer manually.
--   For Buffer Interface you must always use variant 1.
--
--LzmaDec_Allocate* can return:
--  SZ_OK
--  SZ_ERROR_MEM         - Memory allocation error
--  SZ_ERROR_UNSUPPORTED - Unsupported properties
--*/
--   
--SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc);
--void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc);
--
--SRes LzmaDec_Allocate(CLzmaDec *state, const Byte *prop, unsigned propsSize, ISzAlloc *alloc);
--void LzmaDec_Free(CLzmaDec *state, ISzAlloc *alloc);
--
--/* ---------- Dictionary Interface ---------- */
--
--/* You can use it, if you want to eliminate the overhead for data copying from
--   dictionary to some other external buffer.
--   You must work with CLzmaDec variables directly in this interface.
--
--   STEPS:
--     LzmaDec_Constr()
--     LzmaDec_Allocate()
--     for (each new stream)
--     {
--       LzmaDec_Init()
--       while (it needs more decompression)
--       {
--         LzmaDec_DecodeToDic()
--         use data from CLzmaDec::dic and update CLzmaDec::dicPos
--       }
--     }
--     LzmaDec_Free()
--*/
--
--/* LzmaDec_DecodeToDic
--   
--   The decoding to internal dictionary buffer (CLzmaDec::dic).
--   You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!
--
--finishMode:
--  It has meaning only if the decoding reaches output limit (dicLimit).
--  LZMA_FINISH_ANY - Decode just dicLimit bytes.
--  LZMA_FINISH_END - Stream must be finished after dicLimit.
--
--Returns:
--  SZ_OK
--    status:
--      LZMA_STATUS_FINISHED_WITH_MARK
--      LZMA_STATUS_NOT_FINISHED
--      LZMA_STATUS_NEEDS_MORE_INPUT
--      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
--  SZ_ERROR_DATA - Data error
--*/
--
--SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit,
--    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
--
--
--/* ---------- Buffer Interface ---------- */
--
--/* It's zlib-like interface.
--   See LzmaDec_DecodeToDic description for information about STEPS and return results,
--   but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need
--   to work with CLzmaDec variables manually.
--
--finishMode:
--  It has meaning only if the decoding reaches output limit (*destLen).
--  LZMA_FINISH_ANY - Decode just destLen bytes.
--  LZMA_FINISH_END - Stream must be finished after (*destLen).
--*/
--
--SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen,
--    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
--
--
- /* ---------- One Call Interface ---------- */
- 
- /* LzmaDecode
---- a/lib/lzma/LzmaDec.c
-+++ b/lib/lzma/LzmaDec.c
-@@ -682,7 +682,7 @@ static void LzmaDec_InitRc(CLzmaDec *p,
-   p->needFlush = 0;
- }
- 
--void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
-+static void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
- {
-   p->needFlush = 1;
-   p->remainLen = 0;
-@@ -698,7 +698,7 @@ void LzmaDec_InitDicAndState(CLzmaDec *p
-     p->needInitState = 1;
- }
- 
--void LzmaDec_Init(CLzmaDec *p)
-+static void LzmaDec_Init(CLzmaDec *p)
- {
-   p->dicPos = 0;
-   LzmaDec_InitDicAndState(p, True, True);
-@@ -716,7 +716,7 @@ static void LzmaDec_InitStateReal(CLzmaD
-   p->needInitState = 0;
- }
- 
--SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
-+static SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
-     ELzmaFinishMode finishMode, ELzmaStatus *status)
- {
-   SizeT inSize = *srcLen;
-@@ -837,65 +837,13 @@ SRes LzmaDec_DecodeToDic(CLzmaDec *p, Si
-   return (p->code == 0) ? SZ_OK : SZ_ERROR_DATA;
- }
- 
--SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
--{
--  SizeT outSize = *destLen;
--  SizeT inSize = *srcLen;
--  *srcLen = *destLen = 0;
--  for (;;)
--  {
--    SizeT inSizeCur = inSize, outSizeCur, dicPos;
--    ELzmaFinishMode curFinishMode;
--    SRes res;
--    if (p->dicPos == p->dicBufSize)
--      p->dicPos = 0;
--    dicPos = p->dicPos;
--    if (outSize > p->dicBufSize - dicPos)
--    {
--      outSizeCur = p->dicBufSize;
--      curFinishMode = LZMA_FINISH_ANY;
--    }
--    else
--    {
--      outSizeCur = dicPos + outSize;
--      curFinishMode = finishMode;
--    }
--
--    res = LzmaDec_DecodeToDic(p, outSizeCur, src, &inSizeCur, curFinishMode, status);
--    src += inSizeCur;
--    inSize -= inSizeCur;
--    *srcLen += inSizeCur;
--    outSizeCur = p->dicPos - dicPos;
--    memcpy(dest, p->dic + dicPos, outSizeCur);
--    dest += outSizeCur;
--    outSize -= outSizeCur;
--    *destLen += outSizeCur;
--    if (res != 0)
--      return res;
--    if (outSizeCur == 0 || outSize == 0)
--      return SZ_OK;
--  }
--}
--
--void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
-+static void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
- {
-   alloc->Free(alloc, p->probs);
-   p->probs = 0;
- }
- 
--static void LzmaDec_FreeDict(CLzmaDec *p, ISzAlloc *alloc)
--{
--  alloc->Free(alloc, p->dic);
--  p->dic = 0;
--}
--
--void LzmaDec_Free(CLzmaDec *p, ISzAlloc *alloc)
--{
--  LzmaDec_FreeProbs(p, alloc);
--  LzmaDec_FreeDict(p, alloc);
--}
--
--SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
-+static SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
- {
-   UInt32 dicSize;
-   Byte d;
-@@ -935,7 +883,7 @@ static SRes LzmaDec_AllocateProbs2(CLzma
-   return SZ_OK;
- }
- 
--SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
-+static SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
- {
-   CLzmaProps propNew;
-   RINOK(LzmaProps_Decode(&propNew, props, propsSize));
-@@ -943,28 +891,6 @@ SRes LzmaDec_AllocateProbs(CLzmaDec *p,
-   p->prop = propNew;
-   return SZ_OK;
- }
--
--SRes LzmaDec_Allocate(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
--{
--  CLzmaProps propNew;
--  SizeT dicBufSize;
--  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
--  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
--  dicBufSize = propNew.dicSize;
--  if (p->dic == 0 || dicBufSize != p->dicBufSize)
--  {
--    LzmaDec_FreeDict(p, alloc);
--    p->dic = (Byte *)alloc->Alloc(alloc, dicBufSize);
--    if (p->dic == 0)
--    {
--      LzmaDec_FreeProbs(p, alloc);
--      return SZ_ERROR_MEM;
--    }
--  }
--  p->dicBufSize = dicBufSize;
--  p->prop = propNew;
--  return SZ_OK;
--}
- 
- SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
-     const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
---- a/include/linux/lzma/LzmaEnc.h
-+++ b/include/linux/lzma/LzmaEnc.h
-@@ -31,9 +31,6 @@ typedef struct _CLzmaEncProps
- } CLzmaEncProps;
- 
- void LzmaEncProps_Init(CLzmaEncProps *p);
--void LzmaEncProps_Normalize(CLzmaEncProps *p);
--UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2);
--
- 
- /* ---------- CLzmaEncHandle Interface ---------- */
- 
-@@ -53,26 +50,9 @@ CLzmaEncHandle LzmaEnc_Create(ISzAlloc *
- void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig);
- SRes LzmaEnc_SetProps(CLzmaEncHandle p, const CLzmaEncProps *props);
- SRes LzmaEnc_WriteProperties(CLzmaEncHandle p, Byte *properties, SizeT *size);
--SRes LzmaEnc_Encode(CLzmaEncHandle p, ISeqOutStream *outStream, ISeqInStream *inStream,
--    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
- SRes LzmaEnc_MemEncode(CLzmaEncHandle p, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-     int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
- 
--/* ---------- One Call Interface ---------- */
--
--/* LzmaEncode
--Return code:
--  SZ_OK               - OK
--  SZ_ERROR_MEM        - Memory allocation error
--  SZ_ERROR_PARAM      - Incorrect paramater
--  SZ_ERROR_OUTPUT_EOF - output buffer overflow
--  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
--*/
--
--SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
--    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
--    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
--
- #ifdef __cplusplus
- }
- #endif
---- a/lib/lzma/LzmaEnc.c
-+++ b/lib/lzma/LzmaEnc.c
-@@ -53,7 +53,7 @@ void LzmaEncProps_Init(CLzmaEncProps *p)
-   p->writeEndMark = 0;
- }
- 
--void LzmaEncProps_Normalize(CLzmaEncProps *p)
-+static void LzmaEncProps_Normalize(CLzmaEncProps *p)
- {
-   int level = p->level;
-   if (level < 0) level = 5;
-@@ -76,7 +76,7 @@ void LzmaEncProps_Normalize(CLzmaEncProp
-       #endif
- }
- 
--UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
-+static UInt32 __maybe_unused LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
- {
-   CLzmaEncProps props = *props2;
-   LzmaEncProps_Normalize(&props);
-@@ -93,7 +93,7 @@ UInt32 LzmaEncProps_GetDictSize(const CL
- 
- #define BSR2_RET(pos, res) { unsigned long i; _BitScanReverse(&i, (pos)); res = (i + i) + ((pos >> (i - 1)) & 1); }
- 
--UInt32 GetPosSlot1(UInt32 pos)
-+static UInt32 GetPosSlot1(UInt32 pos)
- {
-   UInt32 res;
-   BSR2_RET(pos, res);
-@@ -107,7 +107,7 @@ UInt32 GetPosSlot1(UInt32 pos)
- #define kNumLogBits (9 + (int)sizeof(size_t) / 2)
- #define kDicLogSizeMaxCompress ((kNumLogBits - 1) * 2 + 7)
- 
--void LzmaEnc_FastPosInit(Byte *g_FastPos)
-+static void LzmaEnc_FastPosInit(Byte *g_FastPos)
- {
-   int c = 2, slotFast;
-   g_FastPos[0] = 0;
-@@ -339,58 +339,6 @@ typedef struct
-   CSaveState saveState;
- } CLzmaEnc;
- 
--void LzmaEnc_SaveState(CLzmaEncHandle pp)
--{
--  CLzmaEnc *p = (CLzmaEnc *)pp;
--  CSaveState *dest = &p->saveState;
--  int i;
--  dest->lenEnc = p->lenEnc;
--  dest->repLenEnc = p->repLenEnc;
--  dest->state = p->state;
--
--  for (i = 0; i < kNumStates; i++)
--  {
--    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
--    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
--  }
--  for (i = 0; i < kNumLenToPosStates; i++)
--    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
--  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
--  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
--  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
--  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
--  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
--  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
--  memcpy(dest->reps, p->reps, sizeof(p->reps));
--  memcpy(dest->litProbs, p->litProbs, (0x300 << p->lclp) * sizeof(CLzmaProb));
--}
--
--void LzmaEnc_RestoreState(CLzmaEncHandle pp)
--{
--  CLzmaEnc *dest = (CLzmaEnc *)pp;
--  const CSaveState *p = &dest->saveState;
--  int i;
--  dest->lenEnc = p->lenEnc;
--  dest->repLenEnc = p->repLenEnc;
--  dest->state = p->state;
--
--  for (i = 0; i < kNumStates; i++)
--  {
--    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
--    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
--  }
--  for (i = 0; i < kNumLenToPosStates; i++)
--    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
--  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
--  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
--  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
--  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
--  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
--  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
--  memcpy(dest->reps, p->reps, sizeof(p->reps));
--  memcpy(dest->litProbs, p->litProbs, (0x300 << dest->lclp) * sizeof(CLzmaProb));
--}
--
- SRes LzmaEnc_SetProps(CLzmaEncHandle pp, const CLzmaEncProps *props2)
- {
-   CLzmaEnc *p = (CLzmaEnc *)pp;
-@@ -600,7 +548,7 @@ static void LitEnc_EncodeMatched(CRangeE
-   while (symbol < 0x10000);
- }
- 
--void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
-+static void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
- {
-   UInt32 i;
-   for (i = (1 << kNumMoveReducingBits) / 2; i < kBitModelTotal; i += (1 << kNumMoveReducingBits))
-@@ -1676,7 +1624,7 @@ static void FillDistancesPrices(CLzmaEnc
-   p->matchPriceCount = 0;
- }
- 
--void LzmaEnc_Construct(CLzmaEnc *p)
-+static void LzmaEnc_Construct(CLzmaEnc *p)
- {
-   RangeEnc_Construct(&p->rc);
-   MatchFinder_Construct(&p->matchFinderBase);
-@@ -1709,7 +1657,7 @@ CLzmaEncHandle LzmaEnc_Create(ISzAlloc *
-   return p;
- }
- 
--void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
-+static void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
- {
-   alloc->Free(alloc, p->litProbs);
-   alloc->Free(alloc, p->saveState.litProbs);
-@@ -1717,7 +1665,7 @@ void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAl
-   p->saveState.litProbs = 0;
- }
- 
--void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
-+static void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
- {
-   #ifndef _7ZIP_ST
-   MatchFinderMt_Destruct(&p->matchFinderMt, allocBig);
-@@ -1947,7 +1895,7 @@ static SRes LzmaEnc_Alloc(CLzmaEnc *p, U
-   return SZ_OK;
- }
- 
--void LzmaEnc_Init(CLzmaEnc *p)
-+static void LzmaEnc_Init(CLzmaEnc *p)
- {
-   UInt32 i;
-   p->state = 0;
-@@ -2005,7 +1953,7 @@ void LzmaEnc_Init(CLzmaEnc *p)
-   p->lpMask = (1 << p->lp) - 1;
- }
- 
--void LzmaEnc_InitPrices(CLzmaEnc *p)
-+static void LzmaEnc_InitPrices(CLzmaEnc *p)
- {
-   if (!p->fastMode)
-   {
-@@ -2037,26 +1985,6 @@ static SRes LzmaEnc_AllocAndInit(CLzmaEn
-   return SZ_OK;
- }
- 
--static SRes LzmaEnc_Prepare(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream,
--    ISzAlloc *alloc, ISzAlloc *allocBig)
--{
--  CLzmaEnc *p = (CLzmaEnc *)pp;
--  p->matchFinderBase.stream = inStream;
--  p->needInit = 1;
--  p->rc.outStream = outStream;
--  return LzmaEnc_AllocAndInit(p, 0, alloc, allocBig);
--}
--
--SRes LzmaEnc_PrepareForLzma2(CLzmaEncHandle pp,
--    ISeqInStream *inStream, UInt32 keepWindowSize,
--    ISzAlloc *alloc, ISzAlloc *allocBig)
--{
--  CLzmaEnc *p = (CLzmaEnc *)pp;
--  p->matchFinderBase.stream = inStream;
--  p->needInit = 1;
--  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
--}
--
- static void LzmaEnc_SetInputBuf(CLzmaEnc *p, const Byte *src, SizeT srcLen)
- {
-   p->matchFinderBase.directInput = 1;
-@@ -2064,7 +1992,7 @@ static void LzmaEnc_SetInputBuf(CLzmaEnc
-   p->matchFinderBase.directInputRem = srcLen;
- }
- 
--SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
-+static SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
-     UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
- {
-   CLzmaEnc *p = (CLzmaEnc *)pp;
-@@ -2074,7 +2002,7 @@ SRes LzmaEnc_MemPrepare(CLzmaEncHandle p
-   return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
- }
- 
--void LzmaEnc_Finish(CLzmaEncHandle pp)
-+static void LzmaEnc_Finish(CLzmaEncHandle pp)
- {
-   #ifndef _7ZIP_ST
-   CLzmaEnc *p = (CLzmaEnc *)pp;
-@@ -2107,53 +2035,6 @@ static size_t MyWrite(void *pp, const vo
-   return size;
- }
- 
--
--UInt32 LzmaEnc_GetNumAvailableBytes(CLzmaEncHandle pp)
--{
--  const CLzmaEnc *p = (CLzmaEnc *)pp;
--  return p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
--}
--
--const Byte *LzmaEnc_GetCurBuf(CLzmaEncHandle pp)
--{
--  const CLzmaEnc *p = (CLzmaEnc *)pp;
--  return p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
--}
--
--SRes LzmaEnc_CodeOneMemBlock(CLzmaEncHandle pp, Bool reInit,
--    Byte *dest, size_t *destLen, UInt32 desiredPackSize, UInt32 *unpackSize)
--{
--  CLzmaEnc *p = (CLzmaEnc *)pp;
--  UInt64 nowPos64;
--  SRes res;
--  CSeqOutStreamBuf outStream;
--
--  outStream.funcTable.Write = MyWrite;
--  outStream.data = dest;
--  outStream.rem = *destLen;
--  outStream.overflow = False;
--
--  p->writeEndMark = False;
--  p->finished = False;
--  p->result = SZ_OK;
--
--  if (reInit)
--    LzmaEnc_Init(p);
--  LzmaEnc_InitPrices(p);
--  nowPos64 = p->nowPos64;
--  RangeEnc_Init(&p->rc);
--  p->rc.outStream = &outStream.funcTable;
--
--  res = LzmaEnc_CodeOneBlock(p, True, desiredPackSize, *unpackSize);
--  
--  *unpackSize = (UInt32)(p->nowPos64 - nowPos64);
--  *destLen -= outStream.rem;
--  if (outStream.overflow)
--    return SZ_ERROR_OUTPUT_EOF;
--
--  return res;
--}
--
- static SRes LzmaEnc_Encode2(CLzmaEnc *p, ICompressProgress *progress)
- {
-   SRes res = SZ_OK;
-@@ -2184,13 +2065,6 @@ static SRes LzmaEnc_Encode2(CLzmaEnc *p,
-   return res;
- }
- 
--SRes LzmaEnc_Encode(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress,
--    ISzAlloc *alloc, ISzAlloc *allocBig)
--{
--  RINOK(LzmaEnc_Prepare(pp, outStream, inStream, alloc, allocBig));
--  return LzmaEnc_Encode2((CLzmaEnc *)pp, progress);
--}
--
- SRes LzmaEnc_WriteProperties(CLzmaEncHandle pp, Byte *props, SizeT *size)
- {
-   CLzmaEnc *p = (CLzmaEnc *)pp;
-@@ -2247,25 +2121,3 @@ SRes LzmaEnc_MemEncode(CLzmaEncHandle pp
-     return SZ_ERROR_OUTPUT_EOF;
-   return res;
- }
--
--SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
--    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
--    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
--{
--  CLzmaEnc *p = (CLzmaEnc *)LzmaEnc_Create(alloc);
--  SRes res;
--  if (p == 0)
--    return SZ_ERROR_MEM;
--
--  res = LzmaEnc_SetProps(p, props);
--  if (res == SZ_OK)
--  {
--    res = LzmaEnc_WriteProperties(p, propsEncoded, propsSize);
--    if (res == SZ_OK)
--      res = LzmaEnc_MemEncode(p, dest, destLen, src, srcLen,
--          writeEndMark, progress, alloc, allocBig);
--  }
--
--  LzmaEnc_Destroy(p, alloc, allocBig);
--  return res;
--}
---- a/include/linux/lzma/LzFind.h
-+++ b/include/linux/lzma/LzFind.h
-@@ -55,11 +55,6 @@ typedef struct _CMatchFinder
- 
- #define Inline_MatchFinder_GetNumAvailableBytes(p) ((p)->streamPos - (p)->pos)
- 
--int MatchFinder_NeedMove(CMatchFinder *p);
--Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p);
--void MatchFinder_MoveBlock(CMatchFinder *p);
--void MatchFinder_ReadIfRequired(CMatchFinder *p);
--
- void MatchFinder_Construct(CMatchFinder *p);
- 
- /* Conditions:
-@@ -70,12 +65,6 @@ int MatchFinder_Create(CMatchFinder *p,
-     UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
-     ISzAlloc *alloc);
- void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc);
--void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems);
--void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue);
--
--UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *buffer, CLzRef *son,
--    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
--    UInt32 *distances, UInt32 maxLen);
- 
- /*
- Conditions:
-@@ -102,12 +91,6 @@ typedef struct _IMatchFinder
- 
- void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable);
- 
--void MatchFinder_Init(CMatchFinder *p);
--UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
--UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
--void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
--void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
--
- #ifdef __cplusplus
- }
- #endif
---- a/lib/lzma/LzFind.c
-+++ b/lib/lzma/LzFind.c
-@@ -14,9 +14,15 @@
- 
- #define kStartMaxLen 3
- 
-+#if 0
-+#define DIRECT_INPUT	p->directInput
-+#else
-+#define DIRECT_INPUT	1
-+#endif
-+
- static void LzInWindow_Free(CMatchFinder *p, ISzAlloc *alloc)
- {
--  if (!p->directInput)
-+  if (!DIRECT_INPUT)
-   {
-     alloc->Free(alloc, p->bufferBase);
-     p->bufferBase = 0;
-@@ -28,7 +34,7 @@ static void LzInWindow_Free(CMatchFinder
- static int LzInWindow_Create(CMatchFinder *p, UInt32 keepSizeReserv, ISzAlloc *alloc)
- {
-   UInt32 blockSize = p->keepSizeBefore + p->keepSizeAfter + keepSizeReserv;
--  if (p->directInput)
-+  if (DIRECT_INPUT)
-   {
-     p->blockSize = blockSize;
-     return 1;
-@@ -42,12 +48,12 @@ static int LzInWindow_Create(CMatchFinde
-   return (p->bufferBase != 0);
- }
- 
--Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }
--Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p->buffer[index]; }
-+static Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }
-+static Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p->buffer[index]; }
- 
--UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }
-+static UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }
- 
--void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
-+static void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
- {
-   p->posLimit -= subValue;
-   p->pos -= subValue;
-@@ -58,7 +64,7 @@ static void MatchFinder_ReadBlock(CMatch
- {
-   if (p->streamEndWasReached || p->result != SZ_OK)
-     return;
--  if (p->directInput)
-+  if (DIRECT_INPUT)
-   {
-     UInt32 curSize = 0xFFFFFFFF - p->streamPos;
-     if (curSize > p->directInputRem)
-@@ -89,7 +95,7 @@ static void MatchFinder_ReadBlock(CMatch
-   }
- }
- 
--void MatchFinder_MoveBlock(CMatchFinder *p)
-+static void MatchFinder_MoveBlock(CMatchFinder *p)
- {
-   memmove(p->bufferBase,
-     p->buffer - p->keepSizeBefore,
-@@ -97,22 +103,14 @@ void MatchFinder_MoveBlock(CMatchFinder
-   p->buffer = p->bufferBase + p->keepSizeBefore;
- }
- 
--int MatchFinder_NeedMove(CMatchFinder *p)
-+static int MatchFinder_NeedMove(CMatchFinder *p)
- {
--  if (p->directInput)
-+  if (DIRECT_INPUT)
-     return 0;
-   /* if (p->streamEndWasReached) return 0; */
-   return ((size_t)(p->bufferBase + p->blockSize - p->buffer) <= p->keepSizeAfter);
- }
- 
--void MatchFinder_ReadIfRequired(CMatchFinder *p)
--{
--  if (p->streamEndWasReached)
--    return;
--  if (p->keepSizeAfter >= p->streamPos - p->pos)
--    MatchFinder_ReadBlock(p);
--}
--
- static void MatchFinder_CheckAndMoveAndRead(CMatchFinder *p)
- {
-   if (MatchFinder_NeedMove(p))
-@@ -268,7 +266,7 @@ static void MatchFinder_SetLimits(CMatch
-   p->posLimit = p->pos + limit;
- }
- 
--void MatchFinder_Init(CMatchFinder *p)
-+static void MatchFinder_Init(CMatchFinder *p)
- {
-   UInt32 i;
-   for (i = 0; i < p->hashSizeSum; i++)
-@@ -287,7 +285,7 @@ static UInt32 MatchFinder_GetSubValue(CM
-   return (p->pos - p->historySize - 1) & kNormalizeMask;
- }
- 
--void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems)
-+static void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems)
- {
-   UInt32 i;
-   for (i = 0; i < numItems; i++)
-@@ -319,38 +317,7 @@ static void MatchFinder_CheckLimits(CMat
-   MatchFinder_SetLimits(p);
- }
- 
--static UInt32 * Hc_GetMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
--    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
--    UInt32 *distances, UInt32 maxLen)
--{
--  son[_cyclicBufferPos] = curMatch;
--  for (;;)
--  {
--    UInt32 delta = pos - curMatch;
--    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
--      return distances;
--    {
--      const Byte *pb = cur - delta;
--      curMatch = son[_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)];
--      if (pb[maxLen] == cur[maxLen] && *pb == *cur)
--      {
--        UInt32 len = 0;
--        while (++len != lenLimit)
--          if (pb[len] != cur[len])
--            break;
--        if (maxLen < len)
--        {
--          *distances++ = maxLen = len;
--          *distances++ = delta - 1;
--          if (len == lenLimit)
--            return distances;
--        }
--      }
--    }
--  }
--}
--
--UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
-+static UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
-     UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
-     UInt32 *distances, UInt32 maxLen)
- {
-@@ -460,10 +427,10 @@ static void SkipMatchesSpec(UInt32 lenLi
-   p->buffer++; \
-   if (++p->pos == p->posLimit) MatchFinder_CheckLimits(p);
- 
--#define MOVE_POS_RET MOVE_POS return offset;
--
- static void MatchFinder_MovePos(CMatchFinder *p) { MOVE_POS; }
- 
-+#define MOVE_POS_RET MatchFinder_MovePos(p); return offset;
-+
- #define GET_MATCHES_HEADER2(minLen, ret_op) \
-   UInt32 lenLimit; UInt32 hashValue; const Byte *cur; UInt32 curMatch; \
-   lenLimit = p->lenLimit; { if (lenLimit < minLen) { MatchFinder_MovePos(p); ret_op; }} \
-@@ -479,62 +446,7 @@ static void MatchFinder_MovePos(CMatchFi
-   distances + offset, maxLen) - distances); MOVE_POS_RET;
- 
- #define SKIP_FOOTER \
--  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MOVE_POS;
--
--static UInt32 Bt2_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
--{
--  UInt32 offset;
--  GET_MATCHES_HEADER(2)
--  HASH2_CALC;
--  curMatch = p->hash[hashValue];
--  p->hash[hashValue] = p->pos;
--  offset = 0;
--  GET_MATCHES_FOOTER(offset, 1)
--}
--
--UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
--{
--  UInt32 offset;
--  GET_MATCHES_HEADER(3)
--  HASH_ZIP_CALC;
--  curMatch = p->hash[hashValue];
--  p->hash[hashValue] = p->pos;
--  offset = 0;
--  GET_MATCHES_FOOTER(offset, 2)
--}
--
--static UInt32 Bt3_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
--{
--  UInt32 hash2Value, delta2, maxLen, offset;
--  GET_MATCHES_HEADER(3)
--
--  HASH3_CALC;
--
--  delta2 = p->pos - p->hash[hash2Value];
--  curMatch = p->hash[kFix3HashSize + hashValue];
--  
--  p->hash[hash2Value] =
--  p->hash[kFix3HashSize + hashValue] = p->pos;
--
--
--  maxLen = 2;
--  offset = 0;
--  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
--  {
--    for (; maxLen != lenLimit; maxLen++)
--      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
--        break;
--    distances[0] = maxLen;
--    distances[1] = delta2 - 1;
--    offset = 2;
--    if (maxLen == lenLimit)
--    {
--      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
--      MOVE_POS_RET;
--    }
--  }
--  GET_MATCHES_FOOTER(offset, maxLen)
--}
-+  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MatchFinder_MovePos(p);
- 
- static UInt32 Bt4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
- {
-@@ -583,108 +495,6 @@ static UInt32 Bt4_MatchFinder_GetMatches
-   GET_MATCHES_FOOTER(offset, maxLen)
- }
- 
--static UInt32 Hc4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
--{
--  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
--  GET_MATCHES_HEADER(4)
--
--  HASH4_CALC;
--
--  delta2 = p->pos - p->hash[                hash2Value];
--  delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
--  curMatch = p->hash[kFix4HashSize + hashValue];
--
--  p->hash[                hash2Value] =
--  p->hash[kFix3HashSize + hash3Value] =
--  p->hash[kFix4HashSize + hashValue] = p->pos;
--
--  maxLen = 1;
--  offset = 0;
--  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
--  {
--    distances[0] = maxLen = 2;
--    distances[1] = delta2 - 1;
--    offset = 2;
--  }
--  if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
--  {
--    maxLen = 3;
--    distances[offset + 1] = delta3 - 1;
--    offset += 2;
--    delta2 = delta3;
--  }
--  if (offset != 0)
--  {
--    for (; maxLen != lenLimit; maxLen++)
--      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
--        break;
--    distances[offset - 2] = maxLen;
--    if (maxLen == lenLimit)
--    {
--      p->son[p->cyclicBufferPos] = curMatch;
--      MOVE_POS_RET;
--    }
--  }
--  if (maxLen < 3)
--    maxLen = 3;
--  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
--    distances + offset, maxLen) - (distances));
--  MOVE_POS_RET
--}
--
--UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
--{
--  UInt32 offset;
--  GET_MATCHES_HEADER(3)
--  HASH_ZIP_CALC;
--  curMatch = p->hash[hashValue];
--  p->hash[hashValue] = p->pos;
--  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
--    distances, 2) - (distances));
--  MOVE_POS_RET
--}
--
--static void Bt2_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
--{
--  do
--  {
--    SKIP_HEADER(2)
--    HASH2_CALC;
--    curMatch = p->hash[hashValue];
--    p->hash[hashValue] = p->pos;
--    SKIP_FOOTER
--  }
--  while (--num != 0);
--}
--
--void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
--{
--  do
--  {
--    SKIP_HEADER(3)
--    HASH_ZIP_CALC;
--    curMatch = p->hash[hashValue];
--    p->hash[hashValue] = p->pos;
--    SKIP_FOOTER
--  }
--  while (--num != 0);
--}
--
--static void Bt3_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
--{
--  do
--  {
--    UInt32 hash2Value;
--    SKIP_HEADER(3)
--    HASH3_CALC;
--    curMatch = p->hash[kFix3HashSize + hashValue];
--    p->hash[hash2Value] =
--    p->hash[kFix3HashSize + hashValue] = p->pos;
--    SKIP_FOOTER
--  }
--  while (--num != 0);
--}
--
- static void Bt4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
- {
-   do
-@@ -701,61 +511,12 @@ static void Bt4_MatchFinder_Skip(CMatchF
-   while (--num != 0);
- }
- 
--static void Hc4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
--{
--  do
--  {
--    UInt32 hash2Value, hash3Value;
--    SKIP_HEADER(4)
--    HASH4_CALC;
--    curMatch = p->hash[kFix4HashSize + hashValue];
--    p->hash[                hash2Value] =
--    p->hash[kFix3HashSize + hash3Value] =
--    p->hash[kFix4HashSize + hashValue] = p->pos;
--    p->son[p->cyclicBufferPos] = curMatch;
--    MOVE_POS
--  }
--  while (--num != 0);
--}
--
--void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
--{
--  do
--  {
--    SKIP_HEADER(3)
--    HASH_ZIP_CALC;
--    curMatch = p->hash[hashValue];
--    p->hash[hashValue] = p->pos;
--    p->son[p->cyclicBufferPos] = curMatch;
--    MOVE_POS
--  }
--  while (--num != 0);
--}
--
- void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable)
- {
-   vTable->Init = (Mf_Init_Func)MatchFinder_Init;
-   vTable->GetIndexByte = (Mf_GetIndexByte_Func)MatchFinder_GetIndexByte;
-   vTable->GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinder_GetNumAvailableBytes;
-   vTable->GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinder_GetPointerToCurrentPos;
--  if (!p->btMode)
--  {
--    vTable->GetMatches = (Mf_GetMatches_Func)Hc4_MatchFinder_GetMatches;
--    vTable->Skip = (Mf_Skip_Func)Hc4_MatchFinder_Skip;
--  }
--  else if (p->numHashBytes == 2)
--  {
--    vTable->GetMatches = (Mf_GetMatches_Func)Bt2_MatchFinder_GetMatches;
--    vTable->Skip = (Mf_Skip_Func)Bt2_MatchFinder_Skip;
--  }
--  else if (p->numHashBytes == 3)
--  {
--    vTable->GetMatches = (Mf_GetMatches_Func)Bt3_MatchFinder_GetMatches;
--    vTable->Skip = (Mf_Skip_Func)Bt3_MatchFinder_Skip;
--  }
--  else
--  {
--    vTable->GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
--    vTable->Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
--  }
-+  vTable->GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
-+  vTable->Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
- }
--- a/target/linux/generic/pending-3.18/532-jffs2_eofdetect.patch	2022-03-22 08:54:47.319464856 +0800
+++ b/target/linux/generic/pending-3.18/532-jffs2_eofdetect.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,56 +0,0 @@
---- a/fs/jffs2/build.c
-+++ b/fs/jffs2/build.c
-@@ -116,6 +116,16 @@ static int jffs2_build_filesystem(struct
- 	dbg_fsbuild("scanned flash completely\n");
- 	jffs2_dbg_dump_block_lists_nolock(c);
- 
-+	if (c->flags & (1 << 7)) {
-+		printk("%s(): unlocking the mtd device... ", __func__);
-+		mtd_unlock(c->mtd, 0, c->mtd->size);
-+		printk("done.\n");
-+
-+		printk("%s(): erasing all blocks after the end marker... ", __func__);
-+		jffs2_erase_pending_blocks(c, -1);
-+		printk("done.\n");
-+	}
-+
- 	dbg_fsbuild("pass 1 starting\n");
- 	c->flags |= JFFS2_SB_FLAG_BUILDING;
- 	/* Now scan the directory tree, increasing nlink according to every dirent found. */
---- a/fs/jffs2/scan.c
-+++ b/fs/jffs2/scan.c
-@@ -148,8 +148,14 @@ int jffs2_scan_medium(struct jffs2_sb_in
- 		/* reset summary info for next eraseblock scan */
- 		jffs2_sum_reset_collected(s);
- 
--		ret = jffs2_scan_eraseblock(c, jeb, buf_size?flashbuf:(flashbuf+jeb->offset),
--						buf_size, s);
-+		if (c->flags & (1 << 7)) {
-+			if (mtd_block_isbad(c->mtd, jeb->offset))
-+				ret = BLK_STATE_BADBLOCK;
-+			else
-+				ret = BLK_STATE_ALLFF;
-+		} else
-+			ret = jffs2_scan_eraseblock(c, jeb, buf_size?flashbuf:(flashbuf+jeb->offset),
-+							buf_size, s);
- 
- 		if (ret < 0)
- 			goto out;
-@@ -561,6 +567,17 @@ full_scan:
- 			return err;
- 	}
- 
-+	if ((buf[0] == 0xde) &&
-+		(buf[1] == 0xad) &&
-+		(buf[2] == 0xc0) &&
-+		(buf[3] == 0xde)) {
-+		/* end of filesystem. erase everything after this point */
-+		printk("%s(): End of filesystem marker found at 0x%x\n", __func__, jeb->offset);
-+		c->flags |= (1 << 7);
-+
-+		return BLK_STATE_ALLFF;
-+	}
-+
- 	/* We temporarily use 'ofs' as a pointer into the buffer/jeb */
- 	ofs = 0;
- 	max_ofs = EMPTY_SCAN_SIZE(c->sector_size);
--- a/target/linux/generic/pending-3.18/550-ubifs-symlink-xattr-support.patch	2022-03-22 08:54:47.320464858 +0800
+++ b/target/linux/generic/pending-3.18/550-ubifs-symlink-xattr-support.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,55 +0,0 @@
---- a/fs/ubifs/file.c
-+++ b/fs/ubifs/file.c
-@@ -1597,6 +1597,10 @@ const struct inode_operations ubifs_syml
- 	.follow_link = ubifs_follow_link,
- 	.setattr     = ubifs_setattr,
- 	.getattr     = ubifs_getattr,
-+	.setxattr    = ubifs_setxattr,
-+	.getxattr    = ubifs_getxattr,
-+	.listxattr   = ubifs_listxattr,
-+	.removexattr = ubifs_removexattr,
- };
- 
- const struct file_operations ubifs_file_operations = {
---- a/fs/ubifs/journal.c
-+++ b/fs/ubifs/journal.c
-@@ -572,6 +572,13 @@ int ubifs_jnl_update(struct ubifs_info *
- 	aligned_dlen = ALIGN(dlen, 8);
- 	aligned_ilen = ALIGN(ilen, 8);
- 	len = aligned_dlen + aligned_ilen + UBIFS_INO_NODE_SZ;
-+	if (xent) {
-+		/*
-+		 * Make sure to account for host_ui->data_len in
-+		 * length calculation in case there is extended attribute.
-+		 */
-+		len += host_ui->data_len;
-+	}
- 	dent = kmalloc(len, GFP_NOFS);
- 	if (!dent)
- 		return -ENOMEM;
-@@ -648,7 +655,8 @@ int ubifs_jnl_update(struct ubifs_info *
- 
- 	ino_key_init(c, &ino_key, dir->i_ino);
- 	ino_offs += aligned_ilen;
--	err = ubifs_tnc_add(c, &ino_key, lnum, ino_offs, UBIFS_INO_NODE_SZ);
-+	err = ubifs_tnc_add(c, &ino_key, lnum, ino_offs,
-+			    UBIFS_INO_NODE_SZ + host_ui->data_len);
- 	if (err)
- 		goto out_ro;
- 
---- a/fs/ubifs/xattr.c
-+++ b/fs/ubifs/xattr.c
-@@ -210,12 +210,12 @@ static int change_xattr(struct ubifs_inf
- 		goto out_free;
- 	}
- 	inode->i_size = ui->ui_size = size;
--	ui->data_len = size;
- 
- 	mutex_lock(&host_ui->ui_mutex);
- 	host->i_ctime = ubifs_current_time(host);
- 	host_ui->xattr_size -= CALC_XATTR_BYTES(ui->data_len);
- 	host_ui->xattr_size += CALC_XATTR_BYTES(size);
-+	ui->data_len = size;
- 
- 	/*
- 	 * It is important to write the host inode after the xattr inode
--- a/target/linux/generic/pending-3.18/551-ubifs-fix-default-compression-selection.patch	2022-03-22 08:54:47.320464858 +0800
+++ b/target/linux/generic/pending-3.18/551-ubifs-fix-default-compression-selection.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,29 +0,0 @@
---- a/fs/ubifs/sb.c
-+++ b/fs/ubifs/sb.c
-@@ -63,6 +63,17 @@
- /* Default time granularity in nanoseconds */
- #define DEFAULT_TIME_GRAN 1000000000
- 
-+static int get_default_compressor(void)
-+{
-+	if (ubifs_compr_present(UBIFS_COMPR_LZO))
-+		return UBIFS_COMPR_LZO;
-+
-+	if (ubifs_compr_present(UBIFS_COMPR_ZLIB))
-+		return UBIFS_COMPR_ZLIB;
-+
-+	return UBIFS_COMPR_NONE;
-+}
-+
- /**
-  * create_default_filesystem - format empty UBI volume.
-  * @c: UBIFS file-system description object
-@@ -183,7 +194,7 @@ static int create_default_filesystem(str
- 	if (c->mount_opts.override_compr)
- 		sup->default_compr = cpu_to_le16(c->mount_opts.compr_type);
- 	else
--		sup->default_compr = cpu_to_le16(UBIFS_COMPR_LZO);
-+		sup->default_compr = cpu_to_le16(get_default_compressor());
- 
- 	generate_random_uuid(sup->uuid);
- 
--- a/target/linux/generic/pending-3.18/600-netfilter_conntrack_flush.patch	2022-03-22 08:54:47.320464858 +0800
+++ b/target/linux/generic/pending-3.18/600-netfilter_conntrack_flush.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,86 +0,0 @@
---- a/net/netfilter/nf_conntrack_standalone.c
-+++ b/net/netfilter/nf_conntrack_standalone.c
-@@ -17,6 +17,7 @@
- #include <linux/percpu.h>
- #include <linux/netdevice.h>
- #include <linux/security.h>
-+#include <linux/inet.h>
- #include <net/net_namespace.h>
- #ifdef CONFIG_SYSCTL
- #include <linux/sysctl.h>
-@@ -262,10 +263,66 @@ static int ct_open(struct inode *inode,
- 			sizeof(struct ct_iter_state));
- }
- 
-+struct kill_request {
-+	u16 family;
-+	union nf_inet_addr addr;
-+};
-+
-+static int kill_matching(struct nf_conn *i, void *data)
-+{
-+	struct kill_request *kr = data;
-+	struct nf_conntrack_tuple *t1 = &i->tuplehash[IP_CT_DIR_ORIGINAL].tuple;
-+	struct nf_conntrack_tuple *t2 = &i->tuplehash[IP_CT_DIR_REPLY].tuple;
-+
-+	if (!kr->family)
-+		return 1;
-+
-+	if (t1->src.l3num != kr->family)
-+		return 0;
-+
-+	return (nf_inet_addr_cmp(&kr->addr, &t1->src.u3) ||
-+	        nf_inet_addr_cmp(&kr->addr, &t1->dst.u3) ||
-+	        nf_inet_addr_cmp(&kr->addr, &t2->src.u3) ||
-+	        nf_inet_addr_cmp(&kr->addr, &t2->dst.u3));
-+}
-+
-+static ssize_t ct_file_write(struct file *file, const char __user *buf,
-+			     size_t count, loff_t *ppos)
-+{
-+	struct seq_file *seq = file->private_data;
-+	struct net *net = seq_file_net(seq);
-+	struct kill_request kr = { };
-+	char req[INET6_ADDRSTRLEN] = { };
-+
-+	if (count == 0)
-+		return 0;
-+
-+	if (count >= INET6_ADDRSTRLEN)
-+		count = INET6_ADDRSTRLEN - 1;
-+
-+	if (copy_from_user(req, buf, count))
-+		return -EFAULT;
-+
-+	if (strnchr(req, count, ':')) {
-+		kr.family = AF_INET6;
-+		if (!in6_pton(req, count, (void *)&kr.addr, '\n', NULL))
-+			return -EINVAL;
-+	} else if (strnchr(req, count, '.')) {
-+		kr.family = AF_INET;
-+		if (!in4_pton(req, count, (void *)&kr.addr, '\n', NULL))
-+			return -EINVAL;
-+	}
-+
-+	nf_ct_iterate_cleanup(net, kill_matching, &kr, 0, 0);
-+
-+	return count;
-+}
-+
- static const struct file_operations ct_file_ops = {
- 	.owner   = THIS_MODULE,
- 	.open    = ct_open,
- 	.read    = seq_read,
-+	.write	 = ct_file_write,
- 	.llseek  = seq_lseek,
- 	.release = seq_release_net,
- };
-@@ -367,7 +424,7 @@ static int nf_conntrack_standalone_init_
- {
- 	struct proc_dir_entry *pde;
- 
--	pde = proc_create("nf_conntrack", 0440, net->proc_net, &ct_file_ops);
-+	pde = proc_create("nf_conntrack", 0660, net->proc_net, &ct_file_ops);
- 	if (!pde)
- 		goto out_nf_conntrack;
- 
--- a/target/linux/generic/pending-3.18/610-netfilter_match_bypass_default_checks.patch	2022-03-22 08:54:47.321464859 +0800
+++ b/target/linux/generic/pending-3.18/610-netfilter_match_bypass_default_checks.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,101 +0,0 @@
---- a/include/uapi/linux/netfilter_ipv4/ip_tables.h
-+++ b/include/uapi/linux/netfilter_ipv4/ip_tables.h
-@@ -87,6 +87,7 @@ struct ipt_ip {
- #define IPT_F_FRAG		0x01	/* Set if rule is a fragment rule */
- #define IPT_F_GOTO		0x02	/* Set if jump is a goto */
- #define IPT_F_MASK		0x03	/* All possible flag bits mask. */
-+#define IPT_F_NO_DEF_MATCH	0x80	/* Internal: no default match rules present */
- 
- /* Values for "inv" field in struct ipt_ip. */
- #define IPT_INV_VIA_IN		0x01	/* Invert the sense of IN IFACE. */
---- a/net/ipv4/netfilter/ip_tables.c
-+++ b/net/ipv4/netfilter/ip_tables.c
-@@ -82,6 +82,9 @@ ip_packet_match(const struct iphdr *ip,
- 
- #define FWINV(bool, invflg) ((bool) ^ !!(ipinfo->invflags & (invflg)))
- 
-+	if (ipinfo->flags & IPT_F_NO_DEF_MATCH)
-+		return true;
-+
- 	if (FWINV((ip->saddr&ipinfo->smsk.s_addr) != ipinfo->src.s_addr,
- 		  IPT_INV_SRCIP) ||
- 	    FWINV((ip->daddr&ipinfo->dmsk.s_addr) != ipinfo->dst.s_addr,
-@@ -135,6 +138,29 @@ ip_packet_match(const struct iphdr *ip,
- 	return true;
- }
- 
-+static void
-+ip_checkdefault(struct ipt_ip *ip)
-+{
-+	static const char iface_mask[IFNAMSIZ] = {};
-+
-+	if (ip->invflags || ip->flags & IPT_F_FRAG)
-+		return;
-+
-+	if (memcmp(ip->iniface_mask, iface_mask, IFNAMSIZ) != 0)
-+		return;
-+
-+	if (memcmp(ip->outiface_mask, iface_mask, IFNAMSIZ) != 0)
-+		return;
-+
-+	if (ip->smsk.s_addr || ip->dmsk.s_addr)
-+		return;
-+
-+	if (ip->proto)
-+		return;
-+
-+	ip->flags |= IPT_F_NO_DEF_MATCH;
-+}
-+
- static bool
- ip_checkentry(const struct ipt_ip *ip)
- {
-@@ -650,6 +676,8 @@ find_check_entry(struct ipt_entry *e, st
- 	struct xt_mtchk_param mtpar;
- 	struct xt_entry_match *ematch;
- 
-+	ip_checkdefault(&e->ip);
-+
- 	j = 0;
- 	memset(&mtpar, 0, sizeof(mtpar));
- 	mtpar.net	= net;
-@@ -943,6 +971,7 @@ copy_entries_to_user(unsigned int total_
- 	const struct xt_table_info *private = table->private;
- 	int ret = 0;
- 	const void *loc_cpu_entry;
-+	u8 flags;
- 
- 	counters = alloc_counters(table);
- 	if (IS_ERR(counters))
-@@ -974,6 +1003,14 @@ copy_entries_to_user(unsigned int total_
- 			goto free_counters;
- 		}
- 
-+		flags = e->ip.flags & IPT_F_MASK;
-+		if (copy_to_user(userptr + off
-+				 + offsetof(struct ipt_entry, ip.flags),
-+				 &flags, sizeof(flags)) != 0) {
-+			ret = -EFAULT;
-+			goto free_counters;
-+		}
-+
- 		for (i = sizeof(struct ipt_entry);
- 		     i < e->target_offset;
- 		     i += m->u.match_size) {
-@@ -1380,12 +1417,15 @@ compat_copy_entry_to_user(struct ipt_ent
- 	compat_uint_t origsize;
- 	const struct xt_entry_match *ematch;
- 	int ret = 0;
-+	u8 flags = e->ip.flags & IPT_F_MASK;
- 
- 	origsize = *size;
- 	ce = (struct compat_ipt_entry __user *)*dstptr;
- 	if (copy_to_user(ce, e, sizeof(struct ipt_entry)) != 0 ||
- 	    copy_to_user(&ce->counters, &counters[i],
--	    sizeof(counters[i])) != 0)
-+	    sizeof(counters[i])) != 0 ||
-+	    copy_to_user(&ce->ip.flags, &flags,
-+	    sizeof(flags)) != 0)
- 		return -EFAULT;
- 
- 	*dstptr += sizeof(struct compat_ipt_entry);
--- a/target/linux/generic/pending-3.18/611-netfilter_match_bypass_default_table.patch	2022-03-22 08:54:47.321464859 +0800
+++ b/target/linux/generic/pending-3.18/611-netfilter_match_bypass_default_table.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,94 +0,0 @@
---- a/net/ipv4/netfilter/ip_tables.c
-+++ b/net/ipv4/netfilter/ip_tables.c
-@@ -310,6 +310,33 @@ struct ipt_entry *ipt_next_entry(const s
- 	return (void *)entry + entry->next_offset;
- }
- 
-+static bool
-+ipt_handle_default_rule(struct ipt_entry *e, unsigned int *verdict)
-+{
-+	struct xt_entry_target *t;
-+	struct xt_standard_target *st;
-+
-+	if (e->target_offset != sizeof(struct ipt_entry))
-+		return false;
-+
-+	if (!(e->ip.flags & IPT_F_NO_DEF_MATCH))
-+		return false;
-+
-+	t = ipt_get_target(e);
-+	if (t->u.kernel.target->target)
-+		return false;
-+
-+	st = (struct xt_standard_target *) t;
-+	if (st->verdict == XT_RETURN)
-+		return false;
-+
-+	if (st->verdict >= 0)
-+		return false;
-+
-+	*verdict = (unsigned)(-st->verdict) - 1;
-+	return true;
-+}
-+
- /* Returns one of the generic firewall policies, like NF_ACCEPT. */
- unsigned int
- ipt_do_table(struct sk_buff *skb,
-@@ -331,9 +358,33 @@ ipt_do_table(struct sk_buff *skb,
- 	unsigned int addend;
- 
- 	/* Initialization */
-+	IP_NF_ASSERT(table->valid_hooks & (1 << hook));
-+	local_bh_disable();
-+	private = table->private;
-+	cpu        = smp_processor_id();
-+	/*
-+	 * Ensure we load private-> members after we've fetched the base
-+	 * pointer.
-+	 */
-+	smp_read_barrier_depends();
-+	table_base = private->entries[cpu];
-+
-+	e = get_entry(table_base, private->hook_entry[hook]);
-+	if (ipt_handle_default_rule(e, &verdict)) {
-+		ADD_COUNTER(e->counters, skb->len, 1);
-+		local_bh_enable();
-+		return verdict;
-+	}
-+
- 	ip = ip_hdr(skb);
- 	indev = in ? in->name : nulldevname;
- 	outdev = out ? out->name : nulldevname;
-+
-+	addend = xt_write_recseq_begin();
-+	jumpstack  = (struct ipt_entry **)private->jumpstack[cpu];
-+	stackptr   = per_cpu_ptr(private->stackptr, cpu);
-+	origptr    = *stackptr;
-+
- 	/* We handle fragments by dealing with the first fragment as
- 	 * if it was a normal packet.  All other fragments are treated
- 	 * normally, except that they will NEVER match rules that ask
-@@ -348,23 +399,6 @@ ipt_do_table(struct sk_buff *skb,
- 	acpar.family  = NFPROTO_IPV4;
- 	acpar.hooknum = hook;
- 
--	IP_NF_ASSERT(table->valid_hooks & (1 << hook));
--	local_bh_disable();
--	addend = xt_write_recseq_begin();
--	private = table->private;
--	cpu        = smp_processor_id();
--	/*
--	 * Ensure we load private-> members after we've fetched the base
--	 * pointer.
--	 */
--	smp_read_barrier_depends();
--	table_base = private->entries[cpu];
--	jumpstack  = (struct ipt_entry **)private->jumpstack[cpu];
--	stackptr   = per_cpu_ptr(private->stackptr, cpu);
--	origptr    = *stackptr;
--
--	e = get_entry(table_base, private->hook_entry[hook]);
--
- 	pr_debug("Entering %s(hook %u); sp at %u (UF %p)\n",
- 		 table->name, hook, origptr,
- 		 get_entry(table_base, private->underflow[hook]));
--- a/target/linux/generic/pending-3.18/612-netfilter_match_reduce_memory_access.patch	2022-03-22 08:54:47.321464859 +0800
+++ b/target/linux/generic/pending-3.18/612-netfilter_match_reduce_memory_access.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,16 +0,0 @@
---- a/net/ipv4/netfilter/ip_tables.c
-+++ b/net/ipv4/netfilter/ip_tables.c
-@@ -85,9 +85,11 @@ ip_packet_match(const struct iphdr *ip,
- 	if (ipinfo->flags & IPT_F_NO_DEF_MATCH)
- 		return true;
- 
--	if (FWINV((ip->saddr&ipinfo->smsk.s_addr) != ipinfo->src.s_addr,
-+	if (FWINV(ipinfo->smsk.s_addr &&
-+		  (ip->saddr&ipinfo->smsk.s_addr) != ipinfo->src.s_addr,
- 		  IPT_INV_SRCIP) ||
--	    FWINV((ip->daddr&ipinfo->dmsk.s_addr) != ipinfo->dst.s_addr,
-+	    FWINV(ipinfo->dmsk.s_addr &&
-+		  (ip->daddr&ipinfo->dmsk.s_addr) != ipinfo->dst.s_addr,
- 		  IPT_INV_DSTIP)) {
- 		dprintf("Source or dest mismatch.\n");
- 
--- a/target/linux/generic/pending-3.18/613-netfilter_optional_tcp_window_check.patch	2022-03-22 08:54:47.322464861 +0800
+++ b/target/linux/generic/pending-3.18/613-netfilter_optional_tcp_window_check.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,36 +0,0 @@
---- a/net/netfilter/nf_conntrack_proto_tcp.c
-+++ b/net/netfilter/nf_conntrack_proto_tcp.c
-@@ -33,6 +33,9 @@
- #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
- #include <net/netfilter/ipv6/nf_conntrack_ipv6.h>
- 
-+/* Do not check the TCP window for incoming packets  */
-+static int nf_ct_tcp_no_window_check __read_mostly = 1;
-+
- /* "Be conservative in what you do,
-     be liberal in what you accept from others."
-     If it's non-zero, we mark only out of window RST segments as INVALID. */
-@@ -515,6 +518,9 @@ static bool tcp_in_window(const struct n
- 	s32 receiver_offset;
- 	bool res, in_recv_win;
- 
-+	if (nf_ct_tcp_no_window_check)
-+		return true;
-+
- 	/*
- 	 * Get the required data from the packet.
- 	 */
-@@ -1452,6 +1458,13 @@ static struct ctl_table tcp_sysctl_table
- 		.mode		= 0644,
- 		.proc_handler	= proc_dointvec,
- 	},
-+	{
-+		.procname       = "nf_conntrack_tcp_no_window_check",
-+		.data           = &nf_ct_tcp_no_window_check,
-+		.maxlen         = sizeof(unsigned int),
-+		.mode           = 0644,
-+		.proc_handler   = proc_dointvec,
-+	},
- 	{ }
- };
- 
--- a/target/linux/generic/pending-3.18/616-net_optimize_xfrm_calls.patch	2022-03-22 08:54:47.322464861 +0800
+++ b/target/linux/generic/pending-3.18/616-net_optimize_xfrm_calls.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,12 +0,0 @@
---- a/net/netfilter/nf_nat_core.c
-+++ b/net/netfilter/nf_nat_core.c
-@@ -90,6 +90,9 @@ int nf_xfrm_me_harder(struct sk_buff *sk
- 	struct dst_entry *dst;
- 	int err;
- 
-+	if (skb->dev && !dev_net(skb->dev)->xfrm.policy_count[XFRM_POLICY_OUT])
-+		return 0;
-+
- 	err = xfrm_decode_session(skb, &fl, family);
- 	if (err < 0)
- 		return err;
--- a/target/linux/generic/pending-3.18/621-sched_act_connmark.patch	2022-03-22 08:54:47.323464863 +0800
+++ b/target/linux/generic/pending-3.18/621-sched_act_connmark.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,161 +0,0 @@
---- /dev/null
-+++ b/net/sched/act_connmark.c
-@@ -0,0 +1,126 @@
-+/*
-+ * Copyright (c) 2011 Felix Fietkau <nbd@nbd.name>
-+ *
-+ * This program is free software; you can redistribute it and/or modify it
-+ * under the terms and conditions of the GNU General Public License,
-+ * version 2, as published by the Free Software Foundation.
-+ *
-+ * This program is distributed in the hope it will be useful, but WITHOUT
-+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
-+ * more details.
-+ *
-+ * You should have received a copy of the GNU General Public License along with
-+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
-+ * Place - Suite 330, Boston, MA 02111-1307 USA.
-+ */
-+
-+#include <linux/module.h>
-+#include <linux/init.h>
-+#include <linux/kernel.h>
-+#include <linux/skbuff.h>
-+#include <linux/rtnetlink.h>
-+#include <linux/pkt_cls.h>
-+#include <linux/ip.h>
-+#include <linux/ipv6.h>
-+#include <net/netlink.h>
-+#include <net/pkt_sched.h>
-+#include <net/act_api.h>
-+
-+#include <net/netfilter/nf_conntrack.h>
-+#include <net/netfilter/nf_conntrack_core.h>
-+
-+#define TCA_ACT_CONNMARK	20
-+
-+#define CONNMARK_TAB_MASK     3
-+
-+static int tcf_connmark(struct sk_buff *skb, const struct tc_action *a,
-+		       struct tcf_result *res)
-+{
-+	struct nf_conn *c;
-+	enum ip_conntrack_info ctinfo;
-+	int proto;
-+	int r;
-+
-+	if (skb->protocol == htons(ETH_P_IP)) {
-+		if (skb->len < sizeof(struct iphdr))
-+			goto out;
-+		proto = PF_INET;
-+	} else if (skb->protocol == htons(ETH_P_IPV6)) {
-+		if (skb->len < sizeof(struct ipv6hdr))
-+			goto out;
-+		proto = PF_INET6;
-+	} else
-+		goto out;
-+
-+	r = nf_conntrack_in(dev_net(skb->dev), proto, NF_INET_PRE_ROUTING, skb);
-+	if (r != NF_ACCEPT)
-+		goto out;
-+
-+	c = nf_ct_get(skb, &ctinfo);
-+	if (!c)
-+		goto out;
-+
-+	skb->mark = c->mark;
-+	nf_conntrack_put(skb->nfct);
-+	skb->nfct = NULL;
-+
-+out:
-+	return TC_ACT_PIPE;
-+}
-+
-+static int tcf_connmark_init(struct net *net, struct nlattr *nla,
-+			     struct nlattr *est, struct tc_action *a,
-+			     int ovr, int bind)
-+{
-+	int ret = 0;
-+
-+	if (!tcf_hash_check(0, a, bind)) {
-+		ret = tcf_hash_create(0, est, a, sizeof(struct tcf_common), bind);
-+		if (ret)
-+		    return ret;
-+
-+		tcf_hash_insert(a);
-+		ret = ACT_P_CREATED;
-+	} else {
-+		if (!ovr) {
-+			tcf_hash_release(a, bind);
-+			return -EEXIST;
-+		}
-+	}
-+
-+	return ret;
-+}
-+
-+static inline int tcf_connmark_dump(struct sk_buff *skb, struct tc_action *a,
-+				int bind, int ref)
-+{
-+	return skb->len;
-+}
-+
-+static struct tc_action_ops act_connmark_ops = {
-+	.kind		=	"connmark",
-+	.type		=	TCA_ACT_CONNMARK,
-+	.owner		=	THIS_MODULE,
-+	.act		=	tcf_connmark,
-+	.dump		=	tcf_connmark_dump,
-+	.init		=	tcf_connmark_init,
-+};
-+
-+MODULE_AUTHOR("Felix Fietkau <nbd@nbd.name>");
-+MODULE_DESCRIPTION("Connection tracking mark restoring");
-+MODULE_LICENSE("GPL");
-+
-+static int __init connmark_init_module(void)
-+{
-+
-+	return tcf_register_action(&act_connmark_ops, CONNMARK_TAB_MASK);
-+}
-+
-+static void __exit connmark_cleanup_module(void)
-+{
-+	tcf_unregister_action(&act_connmark_ops);
-+}
-+
-+module_init(connmark_init_module);
-+module_exit(connmark_cleanup_module);
---- a/net/sched/Kconfig
-+++ b/net/sched/Kconfig
-@@ -686,6 +686,19 @@ config NET_ACT_CSUM
- 	  To compile this code as a module, choose M here: the
- 	  module will be called act_csum.
- 
-+config NET_ACT_CONNMARK
-+        tristate "Connection Tracking Marking"
-+        depends on NET_CLS_ACT
-+        depends on NF_CONNTRACK
-+	 depends on NF_CONNTRACK_MARK
-+        ---help---
-+	  Say Y here to restore the connmark from a scheduler action
-+
-+	  If unsure, say N.
-+
-+	  To compile this code as a module, choose M here: the
-+	  module will be called act_connmark.
-+
- config NET_CLS_IND
- 	bool "Incoming device classification"
- 	depends on NET_CLS_U32 || NET_CLS_FW
---- a/net/sched/Makefile
-+++ b/net/sched/Makefile
-@@ -16,6 +16,7 @@ obj-$(CONFIG_NET_ACT_PEDIT)	+= act_pedit
- obj-$(CONFIG_NET_ACT_SIMP)	+= act_simple.o
- obj-$(CONFIG_NET_ACT_SKBEDIT)	+= act_skbedit.o
- obj-$(CONFIG_NET_ACT_CSUM)	+= act_csum.o
-+obj-$(CONFIG_NET_ACT_CONNMARK)	+= act_connmark.o
- obj-$(CONFIG_NET_SCH_FIFO)	+= sch_fifo.o
- obj-$(CONFIG_NET_SCH_CBQ)	+= sch_cbq.o
- obj-$(CONFIG_NET_SCH_HTB)	+= sch_htb.o
--- a/target/linux/generic/pending-3.18/630-packet_socket_type.patch	2022-03-22 08:54:47.323464863 +0800
+++ b/target/linux/generic/pending-3.18/630-packet_socket_type.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,134 +0,0 @@
-This patch allows the user to specify desired packet types (outgoing,
-broadcast, unicast, etc.) on packet sockets via setsockopt.
-This can reduce the load in situations where only a limited number
-of packet types are necessary
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
-
---- a/include/uapi/linux/if_packet.h
-+++ b/include/uapi/linux/if_packet.h
-@@ -31,6 +31,8 @@ struct sockaddr_ll {
- #define PACKET_KERNEL		7		/* To kernel space	*/
- /* Unused, PACKET_FASTROUTE and PACKET_LOOPBACK are invisible to user space */
- #define PACKET_FASTROUTE	6		/* Fastrouted frame	*/
-+#define PACKET_MASK_ANY		0xffffffff	/* mask for packet type bits */
-+
- 
- /* Packet socket options */
- 
-@@ -54,6 +56,7 @@ struct sockaddr_ll {
- #define PACKET_FANOUT			18
- #define PACKET_TX_HAS_OFF		19
- #define PACKET_QDISC_BYPASS		20
-+#define PACKET_RECV_TYPE		21
- 
- #define PACKET_FANOUT_HASH		0
- #define PACKET_FANOUT_LB		1
---- a/net/packet/af_packet.c
-+++ b/net/packet/af_packet.c
-@@ -1551,6 +1551,7 @@ static int packet_rcv_spkt(struct sk_buf
- {
- 	struct sock *sk;
- 	struct sockaddr_pkt *spkt;
-+	struct packet_sock *po;
- 
- 	/*
- 	 *	When we registered the protocol we saved the socket in the data
-@@ -1558,6 +1559,7 @@ static int packet_rcv_spkt(struct sk_buf
- 	 */
- 
- 	sk = pt->af_packet_priv;
-+	po = pkt_sk(sk);
- 
- 	/*
- 	 *	Yank back the headers [hope the device set this
-@@ -1570,7 +1572,7 @@ static int packet_rcv_spkt(struct sk_buf
- 	 *	so that this procedure is noop.
- 	 */
- 
--	if (skb->pkt_type == PACKET_LOOPBACK)
-+	if (!(po->pkt_type & (1 << skb->pkt_type)))
- 		goto out;
- 
- 	if (!net_eq(dev_net(dev), sock_net(sk)))
-@@ -1769,12 +1771,12 @@ static int packet_rcv(struct sk_buff *sk
- 	int skb_len = skb->len;
- 	unsigned int snaplen, res;
- 
--	if (skb->pkt_type == PACKET_LOOPBACK)
--		goto drop;
--
- 	sk = pt->af_packet_priv;
- 	po = pkt_sk(sk);
- 
-+	if (!(po->pkt_type & (1 << skb->pkt_type)))
-+		goto drop;
-+
- 	if (!net_eq(dev_net(dev), sock_net(sk)))
- 		goto drop;
- 
-@@ -1894,12 +1896,12 @@ static int tpacket_rcv(struct sk_buff *s
- 	BUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h2)) != 32);
- 	BUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h3)) != 48);
- 
--	if (skb->pkt_type == PACKET_LOOPBACK)
--		goto drop;
--
- 	sk = pt->af_packet_priv;
- 	po = pkt_sk(sk);
- 
-+	if (!(po->pkt_type & (1 << skb->pkt_type)))
-+		goto drop;
-+
- 	if (!net_eq(dev_net(dev), sock_net(sk)))
- 		goto drop;
- 
-@@ -2866,6 +2868,7 @@ static int packet_create(struct net *net
- 	spin_lock_init(&po->bind_lock);
- 	mutex_init(&po->pg_vec_lock);
- 	po->prot_hook.func = packet_rcv;
-+	po->pkt_type = PACKET_MASK_ANY & ~(1 << PACKET_LOOPBACK);
- 
- 	if (sock->type == SOCK_PACKET)
- 		po->prot_hook.func = packet_rcv_spkt;
-@@ -3489,6 +3492,16 @@ packet_setsockopt(struct socket *sock, i
- 		po->xmit = val ? packet_direct_xmit : dev_queue_xmit;
- 		return 0;
- 	}
-+        case PACKET_RECV_TYPE:
-+        {
-+                unsigned int val;
-+                if (optlen != sizeof(val))
-+                        return -EINVAL;
-+                if (copy_from_user(&val, optval, sizeof(val)))
-+                        return -EFAULT;
-+                po->pkt_type = val & ~BIT(PACKET_LOOPBACK);
-+                return 0;
-+        }
- 	default:
- 		return -ENOPROTOOPT;
- 	}
-@@ -3540,6 +3553,13 @@ static int packet_getsockopt(struct sock
- 	case PACKET_VNET_HDR:
- 		val = po->has_vnet_hdr;
- 		break;
-+	case PACKET_RECV_TYPE:
-+		if (len > sizeof(unsigned int))
-+			len = sizeof(unsigned int);
-+		val = po->pkt_type;
-+
-+		data = &val;
-+		break;
- 	case PACKET_VERSION:
- 		val = po->tp_version;
- 		break;
---- a/net/packet/internal.h
-+++ b/net/packet/internal.h
-@@ -117,6 +117,7 @@ struct packet_sock {
- 	struct net_device __rcu	*cached_dev;
- 	int			(*xmit)(struct sk_buff *skb);
- 	struct packet_type	prot_hook ____cacheline_aligned_in_smp;
-+	unsigned int		pkt_type;
- };
- 
- static struct packet_sock *pkt_sk(struct sock *sk)
--- a/target/linux/generic/pending-3.18/640-bridge_no_eap_forward.patch	2022-03-22 08:54:47.324464864 +0800
+++ b/target/linux/generic/pending-3.18/640-bridge_no_eap_forward.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,23 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: [PATCH] bridge: no EAP forward
-
-When bridging, do not forward EAP frames to other ports, only deliver
-them locally.
-Fixes WPA authentication issues with multiples APs that are connected to
-each other via bridges.
----
---- a/net/bridge/br_input.c
-+++ b/net/bridge/br_input.c
-@@ -97,7 +97,11 @@ int br_handle_frame_finish(struct sk_buf
- 
- 	dst = NULL;
- 
--	if (is_broadcast_ether_addr(dest)) {
-+	if (skb->protocol == htons(ETH_P_PAE)) {
-+		skb2 = skb;
-+		/* Do not forward 802.1x/EAP frames */
-+		skb = NULL;
-+	} else if (is_broadcast_ether_addr(dest)) {
- 		skb2 = skb;
- 		unicast = false;
- 	} else if (is_multicast_ether_addr(dest)) {
--- a/target/linux/generic/pending-3.18/641-bridge_always_accept_eap.patch	2022-03-22 08:54:47.324464864 +0800
+++ b/target/linux/generic/pending-3.18/641-bridge_always_accept_eap.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,17 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: [PATCH] bridge: always accept EAP
-
-Allow EAP frames to pass through bridges even in learning state. Fixes
-issues with WDS.
----
---- a/net/bridge/br_input.c
-+++ b/net/bridge/br_input.c
-@@ -84,7 +84,7 @@ int br_handle_frame_finish(struct sk_buf
- 	    br_multicast_rcv(br, p, skb, vid))
- 		goto drop;
- 
--	if (p->state == BR_STATE_LEARNING)
-+	if ((p->state == BR_STATE_LEARNING) && skb->protocol != htons(ETH_P_PAE))
- 		goto drop;
- 
- 	BR_INPUT_SKB_CB(skb)->brdev = br->dev;
--- a/target/linux/generic/pending-3.18/642-bridge_port_isolate.patch	2022-03-22 08:54:47.324464864 +0800
+++ b/target/linux/generic/pending-3.18/642-bridge_port_isolate.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,92 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: [PATCH] bridge: port isolate
-
-Isolating individual bridge ports
----
---- a/net/bridge/br_private.h
-+++ b/net/bridge/br_private.h
-@@ -172,6 +172,7 @@ struct net_bridge_port
- #define BR_FLOOD		0x00000040
- #define BR_AUTO_MASK (BR_FLOOD | BR_LEARNING)
- #define BR_PROMISC		0x00000080
-+#define BR_ISOLATE_MODE		0x00000100
- 
- #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
- 	struct bridge_mcast_own_query	ip4_own_query;
---- a/net/bridge/br_sysfs_if.c
-+++ b/net/bridge/br_sysfs_if.c
-@@ -170,6 +170,7 @@ BRPORT_ATTR_FLAG(bpdu_guard, BR_BPDU_GUA
- BRPORT_ATTR_FLAG(root_block, BR_ROOT_BLOCK);
- BRPORT_ATTR_FLAG(learning, BR_LEARNING);
- BRPORT_ATTR_FLAG(unicast_flood, BR_FLOOD);
-+BRPORT_ATTR_FLAG(isolated, BR_ISOLATE_MODE);
- 
- #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
- static ssize_t show_multicast_router(struct net_bridge_port *p, char *buf)
-@@ -213,6 +214,7 @@ static const struct brport_attribute *br
- 	&brport_attr_multicast_router,
- 	&brport_attr_multicast_fast_leave,
- #endif
-+	&brport_attr_isolated,
- 	NULL
- };
- 
---- a/net/bridge/br_input.c
-+++ b/net/bridge/br_input.c
-@@ -120,8 +120,8 @@ int br_handle_frame_finish(struct sk_buf
- 
- 		unicast = false;
- 		br->dev->stats.multicast++;
--	} else if ((dst = __br_fdb_get(br, dest, vid)) &&
--			dst->is_local) {
-+	} else if ((p->flags & BR_ISOLATE_MODE) ||
-+		   ((dst = __br_fdb_get(br, dest, vid)) && dst->is_local)) {
- 		skb2 = skb;
- 		/* Do not forward the packet since it's local. */
- 		skb = NULL;
---- a/net/bridge/br_forward.c
-+++ b/net/bridge/br_forward.c
-@@ -117,7 +117,7 @@ EXPORT_SYMBOL_GPL(br_deliver);
- /* called with rcu_read_lock */
- void br_forward(const struct net_bridge_port *to, struct sk_buff *skb, struct sk_buff *skb0)
- {
--	if (should_deliver(to, skb)) {
-+	if (should_deliver(to, skb) && !(to->flags & BR_ISOLATE_MODE)) {
- 		if (skb0)
- 			deliver_clone(to, skb, __br_forward);
- 		else
-@@ -173,7 +173,7 @@ static void br_flood(struct net_bridge *
- 		     struct sk_buff *skb0,
- 		     void (*__packet_hook)(const struct net_bridge_port *p,
- 					   struct sk_buff *skb),
--		     bool unicast)
-+		     				bool unicast, bool forward)
- {
- 	struct net_bridge_port *p;
- 	struct net_bridge_port *prev;
-@@ -181,6 +181,8 @@ static void br_flood(struct net_bridge *
- 	prev = NULL;
- 
- 	list_for_each_entry_rcu(p, &br->port_list, list) {
-+		if (forward && (p->flags & BR_ISOLATE_MODE))
-+			continue;
- 		/* Do not flood unicast traffic to ports that turn it off */
- 		if (unicast && !(p->flags & BR_FLOOD))
- 			continue;
-@@ -207,14 +209,14 @@ out:
- /* called with rcu_read_lock */
- void br_flood_deliver(struct net_bridge *br, struct sk_buff *skb, bool unicast)
- {
--	br_flood(br, skb, NULL, __br_deliver, unicast);
-+	br_flood(br, skb, NULL, __br_deliver, unicast, false);
- }
- 
- /* called under bridge lock */
- void br_flood_forward(struct net_bridge *br, struct sk_buff *skb,
- 		      struct sk_buff *skb2, bool unicast)
- {
--	br_flood(br, skb, skb2, __br_forward, unicast);
-+	br_flood(br, skb, skb2, __br_forward, unicast, true);
- }
- 
- #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
--- a/target/linux/generic/pending-3.18/645-bridge_multicast_to_unicast.patch	2022-03-22 08:54:47.324464864 +0800
+++ b/target/linux/generic/pending-3.18/645-bridge_multicast_to_unicast.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,390 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: [PATCH] bridge: multicast to unicast
-
-Implement optinal multicast->unicast conversion for igmp snooping
----
---- a/net/bridge/br_multicast.c
-+++ b/net/bridge/br_multicast.c
-@@ -635,7 +635,8 @@ struct net_bridge_port_group *br_multica
- 			struct net_bridge_port *port,
- 			struct br_ip *group,
- 			struct net_bridge_port_group __rcu *next,
--			unsigned char state)
-+			unsigned char state,
-+			const unsigned char *src)
- {
- 	struct net_bridge_port_group *p;
- 
-@@ -650,12 +651,33 @@ struct net_bridge_port_group *br_multica
- 	hlist_add_head(&p->mglist, &port->mglist);
- 	setup_timer(&p->timer, br_multicast_port_group_expired,
- 		    (unsigned long)p);
-+	if ((port->flags & BR_MULTICAST_TO_UCAST) && src) {
-+		memcpy(p->eth_addr, src, ETH_ALEN);
-+		p->unicast = true;
-+	}
- 	return p;
- }
- 
-+static bool br_port_group_equal(struct net_bridge_port_group *p,
-+				struct net_bridge_port *port,
-+				const unsigned char *src)
-+{
-+	if (p->port != port)
-+		return false;
-+
-+	if (!p->unicast)
-+		return true;
-+
-+	if (!src)
-+		return false;
-+
-+	return ether_addr_equal(src, p->eth_addr);
-+}
-+
- static int br_multicast_add_group(struct net_bridge *br,
- 				  struct net_bridge_port *port,
--				  struct br_ip *group)
-+				  struct br_ip *group,
-+				  const unsigned char *src)
- {
- 	struct net_bridge_mdb_entry *mp;
- 	struct net_bridge_port_group *p;
-@@ -682,13 +704,13 @@ static int br_multicast_add_group(struct
- 	for (pp = &mp->ports;
- 	     (p = mlock_dereference(*pp, br)) != NULL;
- 	     pp = &p->next) {
--		if (p->port == port)
-+		if (br_port_group_equal(p, port, src))
- 			goto found;
- 		if ((unsigned long)p->port < (unsigned long)port)
- 			break;
- 	}
- 
--	p = br_multicast_new_port_group(port, group, *pp, MDB_TEMPORARY);
-+	p = br_multicast_new_port_group(port, group, *pp, MDB_TEMPORARY, src);
- 	if (unlikely(!p))
- 		goto err;
- 	rcu_assign_pointer(*pp, p);
-@@ -707,7 +729,7 @@ err:
- static int br_ip4_multicast_add_group(struct net_bridge *br,
- 				      struct net_bridge_port *port,
- 				      __be32 group,
--				      __u16 vid)
-+				      __u16 vid, const unsigned char *src)
- {
- 	struct br_ip br_group;
- 
-@@ -718,14 +740,14 @@ static int br_ip4_multicast_add_group(st
- 	br_group.proto = htons(ETH_P_IP);
- 	br_group.vid = vid;
- 
--	return br_multicast_add_group(br, port, &br_group);
-+	return br_multicast_add_group(br, port, &br_group, src);
- }
- 
- #if IS_ENABLED(CONFIG_IPV6)
- static int br_ip6_multicast_add_group(struct net_bridge *br,
- 				      struct net_bridge_port *port,
- 				      const struct in6_addr *group,
--				      __u16 vid)
-+				      __u16 vid, const unsigned char *src)
- {
- 	struct br_ip br_group;
- 
-@@ -736,7 +758,7 @@ static int br_ip6_multicast_add_group(st
- 	br_group.proto = htons(ETH_P_IPV6);
- 	br_group.vid = vid;
- 
--	return br_multicast_add_group(br, port, &br_group);
-+	return br_multicast_add_group(br, port, &br_group, src);
- }
- #endif
- 
-@@ -965,6 +987,7 @@ static int br_ip4_multicast_igmp3_report
- 					 struct sk_buff *skb,
- 					 u16 vid)
- {
-+	const unsigned char *src;
- 	struct igmpv3_report *ih;
- 	struct igmpv3_grec *grec;
- 	int i;
-@@ -1008,7 +1031,8 @@ static int br_ip4_multicast_igmp3_report
- 			continue;
- 		}
- 
--		err = br_ip4_multicast_add_group(br, port, group, vid);
-+		src = eth_hdr(skb)->h_source;
-+		err = br_ip4_multicast_add_group(br, port, group, vid, src);
- 		if (err)
- 			break;
- 	}
-@@ -1022,6 +1046,7 @@ static int br_ip6_multicast_mld2_report(
- 					struct sk_buff *skb,
- 					u16 vid)
- {
-+	const unsigned char *src;
- 	struct icmp6hdr *icmp6h;
- 	struct mld2_grec *grec;
- 	int i;
-@@ -1069,8 +1094,9 @@ static int br_ip6_multicast_mld2_report(
- 			continue;
- 		}
- 
-+		src = eth_hdr(skb)->h_source;
- 		err = br_ip6_multicast_add_group(br, port, &grec->grec_mca,
--						 vid);
-+						 vid, src);
- 		if (err)
- 			break;
- 	}
-@@ -1406,7 +1432,8 @@ br_multicast_leave_group(struct net_brid
- 			 struct net_bridge_port *port,
- 			 struct br_ip *group,
- 			 struct bridge_mcast_other_query *other_query,
--			 struct bridge_mcast_own_query *own_query)
-+			 struct bridge_mcast_own_query *own_query,
-+			 const unsigned char *src)
- {
- 	struct net_bridge_mdb_htable *mdb;
- 	struct net_bridge_mdb_entry *mp;
-@@ -1456,7 +1483,7 @@ br_multicast_leave_group(struct net_brid
- 		for (pp = &mp->ports;
- 		     (p = mlock_dereference(*pp, br)) != NULL;
- 		     pp = &p->next) {
--			if (p->port != port)
-+			if (!br_port_group_equal(p, port, src))
- 				continue;
- 
- 			rcu_assign_pointer(*pp, p->next);
-@@ -1490,7 +1517,7 @@ br_multicast_leave_group(struct net_brid
- 	for (p = mlock_dereference(mp->ports, br);
- 	     p != NULL;
- 	     p = mlock_dereference(p->next, br)) {
--		if (p->port != port)
-+		if (!br_port_group_equal(p, port, src))
- 			continue;
- 
- 		if (!hlist_unhashed(&p->mglist) &&
-@@ -1508,8 +1535,8 @@ out:
- 
- static void br_ip4_multicast_leave_group(struct net_bridge *br,
- 					 struct net_bridge_port *port,
--					 __be32 group,
--					 __u16 vid)
-+					 __be32 group, __u16 vid,
-+					 const unsigned char *src)
- {
- 	struct br_ip br_group;
- 	struct bridge_mcast_own_query *own_query;
-@@ -1524,14 +1551,14 @@ static void br_ip4_multicast_leave_group
- 	br_group.vid = vid;
- 
- 	br_multicast_leave_group(br, port, &br_group, &br->ip4_other_query,
--				 own_query);
-+				 own_query, src);
- }
- 
- #if IS_ENABLED(CONFIG_IPV6)
- static void br_ip6_multicast_leave_group(struct net_bridge *br,
- 					 struct net_bridge_port *port,
- 					 const struct in6_addr *group,
--					 __u16 vid)
-+					 __u16 vid, const unsigned char *src)
- {
- 	struct br_ip br_group;
- 	struct bridge_mcast_own_query *own_query;
-@@ -1546,7 +1573,7 @@ static void br_ip6_multicast_leave_group
- 	br_group.vid = vid;
- 
- 	br_multicast_leave_group(br, port, &br_group, &br->ip6_other_query,
--				 own_query);
-+				 own_query, src);
- }
- #endif
- 
-@@ -1555,6 +1582,7 @@ static int br_multicast_ipv4_rcv(struct
- 				 struct sk_buff *skb,
- 				 u16 vid)
- {
-+	const unsigned char *src;
- 	struct sk_buff *skb2 = skb;
- 	const struct iphdr *iph;
- 	struct igmphdr *ih;
-@@ -1628,7 +1656,8 @@ static int br_multicast_ipv4_rcv(struct
- 	case IGMP_HOST_MEMBERSHIP_REPORT:
- 	case IGMPV2_HOST_MEMBERSHIP_REPORT:
- 		BR_INPUT_SKB_CB(skb)->mrouters_only = 1;
--		err = br_ip4_multicast_add_group(br, port, ih->group, vid);
-+		src = eth_hdr(skb)->h_source;
-+		err = br_ip4_multicast_add_group(br, port, ih->group, vid, src);
- 		break;
- 	case IGMPV3_HOST_MEMBERSHIP_REPORT:
- 		err = br_ip4_multicast_igmp3_report(br, port, skb2, vid);
-@@ -1637,7 +1666,8 @@ static int br_multicast_ipv4_rcv(struct
- 		err = br_ip4_multicast_query(br, port, skb2, vid);
- 		break;
- 	case IGMP_HOST_LEAVE_MESSAGE:
--		br_ip4_multicast_leave_group(br, port, ih->group, vid);
-+		src = eth_hdr(skb)->h_source;
-+		br_ip4_multicast_leave_group(br, port, ih->group, vid, src);
- 		break;
- 	}
- 
-@@ -1655,6 +1685,7 @@ static int br_multicast_ipv6_rcv(struct
- 				 struct sk_buff *skb,
- 				 u16 vid)
- {
-+	const unsigned char *src;
- 	struct sk_buff *skb2;
- 	const struct ipv6hdr *ip6h;
- 	u8 icmp6_type;
-@@ -1764,7 +1795,9 @@ static int br_multicast_ipv6_rcv(struct
- 		}
- 		mld = (struct mld_msg *)skb_transport_header(skb2);
- 		BR_INPUT_SKB_CB(skb)->mrouters_only = 1;
--		err = br_ip6_multicast_add_group(br, port, &mld->mld_mca, vid);
-+		src = eth_hdr(skb)->h_source;
-+		err = br_ip6_multicast_add_group(br, port, &mld->mld_mca, vid,
-+						 src);
- 		break;
- 	    }
- 	case ICMPV6_MLD2_REPORT:
-@@ -1781,7 +1814,8 @@ static int br_multicast_ipv6_rcv(struct
- 			goto out;
- 		}
- 		mld = (struct mld_msg *)skb_transport_header(skb2);
--		br_ip6_multicast_leave_group(br, port, &mld->mld_mca, vid);
-+		src = eth_hdr(skb)->h_source;
-+		br_ip6_multicast_leave_group(br, port, &mld->mld_mca, vid, src);
- 	    }
- 	}
- 
---- a/net/bridge/br_private.h
-+++ b/net/bridge/br_private.h
-@@ -112,6 +112,9 @@ struct net_bridge_port_group {
- 	struct timer_list		timer;
- 	struct br_ip			addr;
- 	unsigned char			state;
-+
-+	unsigned char			eth_addr[ETH_ALEN];
-+	bool				unicast;
- };
- 
- struct net_bridge_mdb_entry
-@@ -173,6 +176,7 @@ struct net_bridge_port
- #define BR_AUTO_MASK (BR_FLOOD | BR_LEARNING)
- #define BR_PROMISC		0x00000080
- #define BR_ISOLATE_MODE		0x00000100
-+#define BR_MULTICAST_TO_UCAST	0x00000200
- 
- #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
- 	struct bridge_mcast_own_query	ip4_own_query;
-@@ -485,7 +489,8 @@ void br_multicast_free_pg(struct rcu_hea
- struct net_bridge_port_group *
- br_multicast_new_port_group(struct net_bridge_port *port, struct br_ip *group,
- 			    struct net_bridge_port_group __rcu *next,
--			    unsigned char state);
-+			    unsigned char state,
-+		       const unsigned char *src);
- void br_mdb_init(void);
- void br_mdb_uninit(void);
- void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,
---- a/net/bridge/br_mdb.c
-+++ b/net/bridge/br_mdb.c
-@@ -342,7 +342,7 @@ static int br_mdb_add_group(struct net_b
- 			break;
- 	}
- 
--	p = br_multicast_new_port_group(port, group, *pp, state);
-+	p = br_multicast_new_port_group(port, group, *pp, state, NULL);
- 	if (unlikely(!p))
- 		return -ENOMEM;
- 	rcu_assign_pointer(*pp, p);
---- a/net/bridge/br_forward.c
-+++ b/net/bridge/br_forward.c
-@@ -168,6 +168,34 @@ out:
- 	return p;
- }
- 
-+static struct net_bridge_port *maybe_deliver_addr(
-+	struct net_bridge_port *prev, struct net_bridge_port *p,
-+	struct sk_buff *skb, const unsigned char *addr,
-+	void (*__packet_hook)(const struct net_bridge_port *p,
-+			      struct sk_buff *skb))
-+{
-+	struct net_device *dev = BR_INPUT_SKB_CB(skb)->brdev;
-+	const unsigned char *src = eth_hdr(skb)->h_source;
-+
-+	if (!should_deliver(p, skb))
-+		return prev;
-+
-+	/* Even with hairpin, no soliloquies - prevent breaking IPv6 DAD */
-+	if (skb->dev == p->dev && ether_addr_equal(src, addr))
-+		return prev;
-+
-+	skb = skb_copy(skb, GFP_ATOMIC);
-+	if (!skb) {
-+		dev->stats.tx_dropped++;
-+		return prev;
-+	}
-+
-+	memcpy(eth_hdr(skb)->h_dest, addr, ETH_ALEN);
-+	__packet_hook(p, skb);
-+
-+	return prev;
-+}
-+
- /* called under bridge lock */
- static void br_flood(struct net_bridge *br, struct sk_buff *skb,
- 		     struct sk_buff *skb0,
-@@ -232,6 +260,7 @@ static void br_multicast_flood(struct ne
- 	struct net_bridge_port *prev = NULL;
- 	struct net_bridge_port_group *p;
- 	struct hlist_node *rp;
-+	const unsigned char *addr;
- 
- 	rp = rcu_dereference(hlist_first_rcu(&br->router_list));
- 	p = mdst ? rcu_dereference(mdst->ports) : NULL;
-@@ -242,10 +271,19 @@ static void br_multicast_flood(struct ne
- 		rport = rp ? hlist_entry(rp, struct net_bridge_port, rlist) :
- 			     NULL;
- 
--		port = (unsigned long)lport > (unsigned long)rport ?
--		       lport : rport;
--
--		prev = maybe_deliver(prev, port, skb, __packet_hook);
-+		if ((unsigned long)lport > (unsigned long)rport) {
-+			port = lport;
-+			addr = p->unicast ? p->eth_addr : NULL;
-+		} else {
-+			port = rport;
-+			addr = NULL;
-+		}
-+
-+		if (addr)
-+			prev = maybe_deliver_addr(prev, port, skb, addr,
-+						  __packet_hook);
-+		else
-+			prev = maybe_deliver(prev, port, skb, __packet_hook);
- 		if (IS_ERR(prev))
- 			goto out;
- 
---- a/net/bridge/br_sysfs_if.c
-+++ b/net/bridge/br_sysfs_if.c
-@@ -187,6 +187,7 @@ static BRPORT_ATTR(multicast_router, S_I
- 		   store_multicast_router);
- 
- BRPORT_ATTR_FLAG(multicast_fast_leave, BR_MULTICAST_FAST_LEAVE);
-+BRPORT_ATTR_FLAG(multicast_to_unicast, BR_MULTICAST_TO_UCAST);
- #endif
- 
- static const struct brport_attribute *brport_attrs[] = {
-@@ -213,6 +214,7 @@ static const struct brport_attribute *br
- #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
- 	&brport_attr_multicast_router,
- 	&brport_attr_multicast_fast_leave,
-+	&brport_attr_multicast_to_unicast,
- #endif
- 	&brport_attr_isolated,
- 	NULL
--- a/target/linux/generic/pending-3.18/651-wireless_mesh_header.patch	2022-03-22 08:54:47.325464866 +0800
+++ b/target/linux/generic/pending-3.18/651-wireless_mesh_header.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,11 +0,0 @@
---- a/include/linux/netdevice.h
-+++ b/include/linux/netdevice.h
-@@ -130,7 +130,7 @@ static inline bool dev_xmit_complete(int
-  */
- 
- #if defined(CONFIG_WLAN) || IS_ENABLED(CONFIG_AX25)
--# if defined(CONFIG_MAC80211_MESH)
-+# if 1 || defined(CONFIG_MAC80211_MESH)
- #  define LL_MAX_HEADER 128
- # else
- #  define LL_MAX_HEADER 96
--- a/target/linux/generic/pending-3.18/653-disable_netlink_trim.patch	2022-03-22 08:54:47.325464866 +0800
+++ b/target/linux/generic/pending-3.18/653-disable_netlink_trim.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,26 +0,0 @@
---- a/net/netlink/af_netlink.c
-+++ b/net/netlink/af_netlink.c
-@@ -1154,23 +1154,7 @@ void netlink_detachskb(struct sock *sk,
- 
- static struct sk_buff *netlink_trim(struct sk_buff *skb, gfp_t allocation)
- {
--	int delta;
--
- 	WARN_ON(skb->sk != NULL);
--	delta = skb->end - skb->tail;
--	if (is_vmalloc_addr(skb->head) || delta * 2 < skb->truesize)
--		return skb;
--
--	if (skb_shared(skb)) {
--		struct sk_buff *nskb = skb_clone(skb, allocation);
--		if (!nskb)
--			return skb;
--		consume_skb(skb);
--		skb = nskb;
--	}
--
--	if (!pskb_expand_head(skb, 0, -delta, allocation))
--		skb->truesize -= delta;
- 
- 	return skb;
- }
--- a/target/linux/generic/pending-3.18/655-increase_skb_pad.patch	2022-03-22 08:54:47.326464868 +0800
+++ b/target/linux/generic/pending-3.18/655-increase_skb_pad.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,11 +0,0 @@
---- a/include/linux/skbuff.h
-+++ b/include/linux/skbuff.h
-@@ -2024,7 +2024,7 @@ static inline int pskb_network_may_pull(
-  * NET_IP_ALIGN(2) + ethernet_header(14) + IP_header(20/40) + ports(8)
-  */
- #ifndef NET_SKB_PAD
--#define NET_SKB_PAD	max(32, L1_CACHE_BYTES)
-+#define NET_SKB_PAD	max(64, L1_CACHE_BYTES)
- #endif
- 
- int ___pskb_trim(struct sk_buff *skb, unsigned int len);
--- a/target/linux/generic/pending-3.18/656-skb_reduce_truesize-helper.patch	2022-03-22 08:54:47.326464868 +0800
+++ b/target/linux/generic/pending-3.18/656-skb_reduce_truesize-helper.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,41 +0,0 @@
-From 4593a806e31119c5bd3faa00c7210ad862d515af Mon Sep 17 00:00:00 2001
-From: Dave Taht <dave.taht@bufferbloat.net>
-Date: Mon, 31 Dec 2012 10:02:21 -0800
-Subject: [PATCH 3/7] skb_reduce_truesize: helper function for shrinking skbs
- whenever needed
-
-On embedded devices in particular, large queues of small packets from the rx
-path with a large truesize can exist. Reducing their size can reduce
-memory pressure. skb_reduce_truesize is a helper function for doing this,
-when needed.
----
- include/linux/skbuff.h |   18 ++++++++++++++++++
- 1 file changed, 18 insertions(+)
-
---- a/include/linux/skbuff.h
-+++ b/include/linux/skbuff.h
-@@ -2069,6 +2069,24 @@ static inline void pskb_trim_unique(stru
- 	BUG_ON(err);
- }
- 
-+/*
-+ * Caller wants to reduce memory needs before queueing skb
-+ * The (expensive) copy should not be be done in fast path.
-+ */
-+static inline struct sk_buff *skb_reduce_truesize(struct sk_buff *skb)
-+{
-+	if (skb->truesize > 2 * SKB_TRUESIZE(skb->len)) {
-+		struct sk_buff *nskb;
-+		nskb = skb_copy_expand(skb, skb_headroom(skb), 0,
-+			GFP_ATOMIC | __GFP_NOWARN);
-+		if (nskb) {
-+			__kfree_skb(skb);
-+			skb = nskb;
-+		}
-+	}
-+	return skb;
-+}
-+
- /**
-  *	skb_orphan - orphan a buffer
-  *	@skb: buffer to orphan
--- a/target/linux/generic/pending-3.18/657-qdisc_reduce_truesize.patch	2022-03-22 08:54:47.326464868 +0800
+++ b/target/linux/generic/pending-3.18/657-qdisc_reduce_truesize.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,63 +0,0 @@
-From bc9fec2f87d57bdbff30d296605e24504513f65c Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Dave=20T=C3=A4ht?= <dave.taht@bufferbloat.net>
-Date: Mon, 17 Sep 2012 19:20:22 -0700
-Subject: [PATCH 4/7] net: add skb_reduce_truesize support to common qdiscs
-
-Reduce skb size under load when queues begin to fill on the
-commont qdiscs.
----
- net/sched/sch_codel.c    |    2 ++
- net/sched/sch_fifo.c     |   12 ++++++++----
- net/sched/sch_fq_codel.c |    2 ++
- 3 files changed, 12 insertions(+), 4 deletions(-)
-
---- a/net/sched/sch_codel.c
-+++ b/net/sched/sch_codel.c
-@@ -97,6 +97,8 @@ static int codel_qdisc_enqueue(struct sk
- 	struct codel_sched_data *q;
- 
- 	if (likely(qdisc_qlen(sch) < sch->limit)) {
-+		if(qdisc_qlen(sch) > 128)
-+			skb = skb_reduce_truesize(skb);
- 		codel_set_enqueue_time(skb);
- 		return qdisc_enqueue_tail(skb, sch);
- 	}
---- a/net/sched/sch_fifo.c
-+++ b/net/sched/sch_fifo.c
-@@ -29,17 +29,21 @@ static int bfifo_enqueue(struct sk_buff
- 
- static int pfifo_enqueue(struct sk_buff *skb, struct Qdisc *sch)
- {
--	if (likely(skb_queue_len(&sch->q) < sch->limit))
-+	if (likely(skb_queue_len(&sch->q) < sch->limit)) {
-+		if (skb_queue_len(&sch->q) > 128)
-+			skb = skb_reduce_truesize(skb);
- 		return qdisc_enqueue_tail(skb, sch);
--
-+	}
- 	return qdisc_reshape_fail(skb, sch);
- }
- 
- static int pfifo_tail_enqueue(struct sk_buff *skb, struct Qdisc *sch)
- {
--	if (likely(skb_queue_len(&sch->q) < sch->limit))
-+	if (likely(skb_queue_len(&sch->q) < sch->limit)) {
-+		if (skb_queue_len(&sch->q) > 128)
-+			skb = skb_reduce_truesize(skb);
- 		return qdisc_enqueue_tail(skb, sch);
--
-+	}
- 	/* queue full, remove one skb to fulfill the limit */
- 	__qdisc_queue_drop_head(sch, &sch->q);
- 	qdisc_qstats_drop(sch);
---- a/net/sched/sch_fq_codel.c
-+++ b/net/sched/sch_fq_codel.c
-@@ -185,6 +185,8 @@ static int fq_codel_enqueue(struct sk_bu
- 		return ret;
- 	}
- 	idx--;
-+	if (sch->q.qlen > 128)
-+		skb = skb_reduce_truesize(skb);
- 
- 	codel_set_enqueue_time(skb);
- 	flow = &q->flows[idx];
--- a/target/linux/generic/pending-3.18/660-fq_codel_defaults.patch	2022-03-22 08:54:47.326464868 +0800
+++ b/target/linux/generic/pending-3.18/660-fq_codel_defaults.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,13 +0,0 @@
---- a/net/sched/sch_fq_codel.c
-+++ b/net/sched/sch_fq_codel.c
-@@ -394,8 +394,8 @@ static int fq_codel_init(struct Qdisc *s
- 	struct fq_codel_sched_data *q = qdisc_priv(sch);
- 	int i;
- 
--	sch->limit = 10*1024;
--	q->flows_cnt = 1024;
-+	sch->limit = 1024;
-+	q->flows_cnt = 128;
- 	q->quantum = psched_mtu(qdisc_dev(sch));
- 	q->perturbation = prandom_u32();
- 	INIT_LIST_HEAD(&q->new_flows);
--- a/target/linux/generic/pending-3.18/661-fq_codel_keep_dropped_stats.patch	2022-03-22 08:54:47.327464869 +0800
+++ b/target/linux/generic/pending-3.18/661-fq_codel_keep_dropped_stats.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,10 +0,0 @@
---- a/net/sched/sch_fq_codel.c
-+++ b/net/sched/sch_fq_codel.c
-@@ -198,7 +198,6 @@ static int fq_codel_enqueue(struct sk_bu
- 		list_add_tail(&flow->flowchain, &q->new_flows);
- 		q->new_flow_count++;
- 		flow->deficit = q->quantum;
--		flow->dropped = 0;
- 	}
- 	if (++sch->q.qlen <= sch->limit)
- 		return NET_XMIT_SUCCESS;
--- a/target/linux/generic/pending-3.18/662-use_fq_codel_by_default.patch	2022-03-22 08:54:47.327464869 +0800
+++ b/target/linux/generic/pending-3.18/662-use_fq_codel_by_default.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,95 +0,0 @@
---- a/net/sched/Kconfig
-+++ b/net/sched/Kconfig
-@@ -3,8 +3,9 @@
- # 
- 
- menuconfig NET_SCHED
--	bool "QoS and/or fair queueing"
-+	def_bool y
- 	select NET_SCH_FIFO
-+	select NET_SCH_FQ_CODEL
- 	---help---
- 	  When the kernel has several packets to send out over a network
- 	  device, it has to decide which ones to send first, which ones to
---- a/net/sched/sch_fq_codel.c
-+++ b/net/sched/sch_fq_codel.c
-@@ -599,7 +599,7 @@ static const struct Qdisc_class_ops fq_c
- 	.walk		=	fq_codel_walk,
- };
- 
--static struct Qdisc_ops fq_codel_qdisc_ops __read_mostly = {
-+struct Qdisc_ops fq_codel_qdisc_ops __read_mostly = {
- 	.cl_ops		=	&fq_codel_class_ops,
- 	.id		=	"fq_codel",
- 	.priv_size	=	sizeof(struct fq_codel_sched_data),
-@@ -615,6 +615,7 @@ static struct Qdisc_ops fq_codel_qdisc_o
- 	.dump_stats =	fq_codel_dump_stats,
- 	.owner		=	THIS_MODULE,
- };
-+EXPORT_SYMBOL(fq_codel_qdisc_ops);
- 
- static int __init fq_codel_module_init(void)
- {
---- a/include/net/sch_generic.h
-+++ b/include/net/sch_generic.h
-@@ -341,6 +341,7 @@ extern struct Qdisc noop_qdisc;
- extern struct Qdisc_ops noop_qdisc_ops;
- extern struct Qdisc_ops pfifo_fast_ops;
- extern struct Qdisc_ops mq_qdisc_ops;
-+extern struct Qdisc_ops fq_codel_qdisc_ops;
- extern const struct Qdisc_ops *default_qdisc_ops;
- 
- struct Qdisc_class_common {
---- a/net/sched/sch_generic.c
-+++ b/net/sched/sch_generic.c
-@@ -31,7 +31,7 @@
- #include <net/dst.h>
- 
- /* Qdisc to use by default */
--const struct Qdisc_ops *default_qdisc_ops = &pfifo_fast_ops;
-+const struct Qdisc_ops *default_qdisc_ops = &fq_codel_qdisc_ops;
- EXPORT_SYMBOL(default_qdisc_ops);
- 
- /* Main transmission queue. */
-@@ -742,7 +742,7 @@ static void attach_one_default_qdisc(str
- 
- 	if (dev->tx_queue_len) {
- 		qdisc = qdisc_create_dflt(dev_queue,
--					  default_qdisc_ops, TC_H_ROOT);
-+					  &fq_codel_qdisc_ops, TC_H_ROOT);
- 		if (!qdisc) {
- 			netdev_info(dev, "activation failed\n");
- 			return;
---- a/net/sched/sch_mq.c
-+++ b/net/sched/sch_mq.c
-@@ -57,7 +57,7 @@ static int mq_init(struct Qdisc *sch, st
- 
- 	for (ntx = 0; ntx < dev->num_tx_queues; ntx++) {
- 		dev_queue = netdev_get_tx_queue(dev, ntx);
--		qdisc = qdisc_create_dflt(dev_queue, default_qdisc_ops,
-+		qdisc = qdisc_create_dflt(dev_queue, &fq_codel_qdisc_ops,
- 					  TC_H_MAKE(TC_H_MAJ(sch->handle),
- 						    TC_H_MIN(ntx + 1)));
- 		if (qdisc == NULL)
---- a/net/sched/sch_mqprio.c
-+++ b/net/sched/sch_mqprio.c
-@@ -124,7 +124,7 @@ static int mqprio_init(struct Qdisc *sch
- 
- 	for (i = 0; i < dev->num_tx_queues; i++) {
- 		dev_queue = netdev_get_tx_queue(dev, i);
--		qdisc = qdisc_create_dflt(dev_queue, default_qdisc_ops,
-+		qdisc = qdisc_create_dflt(dev_queue, &fq_codel_qdisc_ops,
- 					  TC_H_MAKE(TC_H_MAJ(sch->handle),
- 						    TC_H_MIN(i + 1)));
- 		if (qdisc == NULL) {
---- a/net/sched/sch_api.c
-+++ b/net/sched/sch_api.c
-@@ -1949,7 +1949,7 @@ static int __init pktsched_init(void)
- 		return err;
- 	}
- 
--	register_qdisc(&pfifo_fast_ops);
-+	register_qdisc(&fq_codel_qdisc_ops);
- 	register_qdisc(&pfifo_qdisc_ops);
- 	register_qdisc(&bfifo_qdisc_ops);
- 	register_qdisc(&pfifo_head_drop_qdisc_ops);
--- a/target/linux/generic/pending-3.18/663-remove_pfifo_fast.patch	2022-03-22 08:54:47.327464869 +0800
+++ b/target/linux/generic/pending-3.18/663-remove_pfifo_fast.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,143 +0,0 @@
---- a/net/sched/sch_generic.c
-+++ b/net/sched/sch_generic.c
-@@ -445,140 +445,6 @@ static struct Qdisc noqueue_qdisc = {
- 	.busylock	=	__SPIN_LOCK_UNLOCKED(noqueue_qdisc.busylock),
- };
- 
--
--static const u8 prio2band[TC_PRIO_MAX + 1] = {
--	1, 2, 2, 2, 1, 2, 0, 0 , 1, 1, 1, 1, 1, 1, 1, 1
--};
--
--/* 3-band FIFO queue: old style, but should be a bit faster than
--   generic prio+fifo combination.
-- */
--
--#define PFIFO_FAST_BANDS 3
--
--/*
-- * Private data for a pfifo_fast scheduler containing:
-- * 	- queues for the three band
-- * 	- bitmap indicating which of the bands contain skbs
-- */
--struct pfifo_fast_priv {
--	u32 bitmap;
--	struct sk_buff_head q[PFIFO_FAST_BANDS];
--};
--
--/*
-- * Convert a bitmap to the first band number where an skb is queued, where:
-- * 	bitmap=0 means there are no skbs on any band.
-- * 	bitmap=1 means there is an skb on band 0.
-- *	bitmap=7 means there are skbs on all 3 bands, etc.
-- */
--static const int bitmap2band[] = {-1, 0, 1, 0, 2, 0, 1, 0};
--
--static inline struct sk_buff_head *band2list(struct pfifo_fast_priv *priv,
--					     int band)
--{
--	return priv->q + band;
--}
--
--static int pfifo_fast_enqueue(struct sk_buff *skb, struct Qdisc *qdisc)
--{
--	if (skb_queue_len(&qdisc->q) < qdisc_dev(qdisc)->tx_queue_len) {
--		int band = prio2band[skb->priority & TC_PRIO_MAX];
--		struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--		struct sk_buff_head *list = band2list(priv, band);
--
--		priv->bitmap |= (1 << band);
--		qdisc->q.qlen++;
--		return __qdisc_enqueue_tail(skb, qdisc, list);
--	}
--
--	return qdisc_drop(skb, qdisc);
--}
--
--static struct sk_buff *pfifo_fast_dequeue(struct Qdisc *qdisc)
--{
--	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--	int band = bitmap2band[priv->bitmap];
--
--	if (likely(band >= 0)) {
--		struct sk_buff_head *list = band2list(priv, band);
--		struct sk_buff *skb = __qdisc_dequeue_head(qdisc, list);
--
--		qdisc->q.qlen--;
--		if (skb_queue_empty(list))
--			priv->bitmap &= ~(1 << band);
--
--		return skb;
--	}
--
--	return NULL;
--}
--
--static struct sk_buff *pfifo_fast_peek(struct Qdisc *qdisc)
--{
--	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--	int band = bitmap2band[priv->bitmap];
--
--	if (band >= 0) {
--		struct sk_buff_head *list = band2list(priv, band);
--
--		return skb_peek(list);
--	}
--
--	return NULL;
--}
--
--static void pfifo_fast_reset(struct Qdisc *qdisc)
--{
--	int prio;
--	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--
--	for (prio = 0; prio < PFIFO_FAST_BANDS; prio++)
--		__qdisc_reset_queue(qdisc, band2list(priv, prio));
--
--	priv->bitmap = 0;
--	qdisc->qstats.backlog = 0;
--	qdisc->q.qlen = 0;
--}
--
--static int pfifo_fast_dump(struct Qdisc *qdisc, struct sk_buff *skb)
--{
--	struct tc_prio_qopt opt = { .bands = PFIFO_FAST_BANDS };
--
--	memcpy(&opt.priomap, prio2band, TC_PRIO_MAX + 1);
--	if (nla_put(skb, TCA_OPTIONS, sizeof(opt), &opt))
--		goto nla_put_failure;
--	return skb->len;
--
--nla_put_failure:
--	return -1;
--}
--
--static int pfifo_fast_init(struct Qdisc *qdisc, struct nlattr *opt)
--{
--	int prio;
--	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--
--	for (prio = 0; prio < PFIFO_FAST_BANDS; prio++)
--		__skb_queue_head_init(band2list(priv, prio));
--
--	/* Can by-pass the queue discipline */
--	qdisc->flags |= TCQ_F_CAN_BYPASS;
--	return 0;
--}
--
--struct Qdisc_ops pfifo_fast_ops __read_mostly = {
--	.id		=	"pfifo_fast",
--	.priv_size	=	sizeof(struct pfifo_fast_priv),
--	.enqueue	=	pfifo_fast_enqueue,
--	.dequeue	=	pfifo_fast_dequeue,
--	.peek		=	pfifo_fast_peek,
--	.init		=	pfifo_fast_init,
--	.reset		=	pfifo_fast_reset,
--	.dump		=	pfifo_fast_dump,
--	.owner		=	THIS_MODULE,
--};
--
- static struct lock_class_key qdisc_tx_busylock;
- 
- struct Qdisc *qdisc_alloc(struct netdev_queue *dev_queue,
--- a/target/linux/generic/pending-3.18/666-Add-support-for-MAP-E-FMRs-mesh-mode.patch	2022-03-22 08:54:47.328464871 +0800
+++ b/target/linux/generic/pending-3.18/666-Add-support-for-MAP-E-FMRs-mesh-mode.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,481 +0,0 @@
-From 775d6fe74d1eaec2ba387535b068dde2dc89de9e Mon Sep 17 00:00:00 2001
-From: Steven Barth <steven@midlink.org>
-Date: Thu, 22 May 2014 09:49:05 +0200
-Subject: [PATCH] Add support for MAP-E FMRs (mesh mode)
-
-MAP-E FMRs (draft-ietf-softwire-map-10) are rules for IPv4-communication
-between MAP CEs (mesh mode) without the need to forward such data to a
-border relay. This is similar to how 6rd works but for IPv4 over IPv6.
-
-Signed-off-by: Steven Barth <cyrus@openwrt.org>
----
- include/net/ip6_tunnel.h       |  13 ++
- include/uapi/linux/if_tunnel.h |  13 ++
- net/ipv6/ip6_tunnel.c          | 276 +++++++++++++++++++++++++++++++++++++++--
- 3 files changed, 291 insertions(+), 11 deletions(-)
-
---- a/include/net/ip6_tunnel.h
-+++ b/include/net/ip6_tunnel.h
-@@ -15,6 +15,18 @@
- /* determine capability on a per-packet basis */
- #define IP6_TNL_F_CAP_PER_PACKET 0x40000
- 
-+/* IPv6 tunnel FMR */
-+struct __ip6_tnl_fmr {
-+	struct __ip6_tnl_fmr *next; /* next fmr in list */
-+	struct in6_addr ip6_prefix;
-+	struct in_addr ip4_prefix;
-+
-+	__u8 ip6_prefix_len;
-+	__u8 ip4_prefix_len;
-+	__u8 ea_len;
-+	__u8 offset;
-+};
-+
- struct __ip6_tnl_parm {
- 	char name[IFNAMSIZ];	/* name of tunnel device */
- 	int link;		/* ifindex of underlying L2 interface */
-@@ -25,6 +37,7 @@ struct __ip6_tnl_parm {
- 	__u32 flags;		/* tunnel flags */
- 	struct in6_addr laddr;	/* local tunnel end-point address */
- 	struct in6_addr raddr;	/* remote tunnel end-point address */
-+	struct __ip6_tnl_fmr *fmrs;	/* FMRs */
- 
- 	__be16			i_flags;
- 	__be16			o_flags;
---- a/include/uapi/linux/if_tunnel.h
-+++ b/include/uapi/linux/if_tunnel.h
-@@ -57,10 +57,23 @@ enum {
- 	IFLA_IPTUN_ENCAP_FLAGS,
- 	IFLA_IPTUN_ENCAP_SPORT,
- 	IFLA_IPTUN_ENCAP_DPORT,
-+	IFLA_IPTUN_FMRS,
- 	__IFLA_IPTUN_MAX,
- };
- #define IFLA_IPTUN_MAX	(__IFLA_IPTUN_MAX - 1)
- 
-+enum {
-+	IFLA_IPTUN_FMR_UNSPEC,
-+	IFLA_IPTUN_FMR_IP6_PREFIX,
-+	IFLA_IPTUN_FMR_IP4_PREFIX,
-+	IFLA_IPTUN_FMR_IP6_PREFIX_LEN,
-+	IFLA_IPTUN_FMR_IP4_PREFIX_LEN,
-+	IFLA_IPTUN_FMR_EA_LEN,
-+	IFLA_IPTUN_FMR_OFFSET,
-+	__IFLA_IPTUN_FMR_MAX,
-+};
-+#define IFLA_IPTUN_FMR_MAX (__IFLA_IPTUN_FMR_MAX - 1)
-+
- enum tunnel_encap_types {
- 	TUNNEL_ENCAP_NONE,
- 	TUNNEL_ENCAP_FOU,
---- a/net/ipv6/ip6_tunnel.c
-+++ b/net/ipv6/ip6_tunnel.c
-@@ -16,6 +16,8 @@
-  *      as published by the Free Software Foundation; either version
-  *      2 of the License, or (at your option) any later version.
-  *
-+ *	Changes:
-+ * Steven Barth <cyrus@openwrt.org>:		MAP-E FMR support
-  */
- 
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-@@ -77,11 +79,9 @@ static bool log_ecn_error = true;
- module_param(log_ecn_error, bool, 0644);
- MODULE_PARM_DESC(log_ecn_error, "Log packets received with corrupted ECN");
- 
--static u32 HASH(const struct in6_addr *addr1, const struct in6_addr *addr2)
-+static u32 HASH(const struct in6_addr *addr)
- {
--	u32 hash = ipv6_addr_hash(addr1) ^ ipv6_addr_hash(addr2);
--
--	return hash_32(hash, HASH_SIZE_SHIFT);
-+	return hash_32(ipv6_addr_hash(addr), HASH_SIZE_SHIFT);
- }
- 
- static int ip6_tnl_dev_init(struct net_device *dev);
-@@ -180,15 +180,24 @@ EXPORT_SYMBOL_GPL(ip6_tnl_dst_store);
- static struct ip6_tnl *
- ip6_tnl_lookup(struct net *net, const struct in6_addr *remote, const struct in6_addr *local)
- {
--	unsigned int hash = HASH(remote, local);
-+	unsigned int hash = HASH(local);
- 	struct ip6_tnl *t;
- 	struct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);
-+	struct __ip6_tnl_fmr *fmr;
- 
- 	for_each_ip6_tunnel_rcu(ip6n->tnls_r_l[hash]) {
--		if (ipv6_addr_equal(local, &t->parms.laddr) &&
--		    ipv6_addr_equal(remote, &t->parms.raddr) &&
--		    (t->dev->flags & IFF_UP))
-+		if (!ipv6_addr_equal(local, &t->parms.laddr) ||
-+				!(t->dev->flags & IFF_UP))
-+			continue;
-+
-+		if (ipv6_addr_equal(remote, &t->parms.raddr))
- 			return t;
-+
-+		for (fmr = t->parms.fmrs; fmr; fmr = fmr->next) {
-+			if (ipv6_prefix_equal(remote, &fmr->ip6_prefix,
-+					fmr->ip6_prefix_len))
-+				return t;
-+		}
- 	}
- 	t = rcu_dereference(ip6n->tnls_wc[0]);
- 	if (t && (t->dev->flags & IFF_UP))
-@@ -218,7 +227,7 @@ ip6_tnl_bucket(struct ip6_tnl_net *ip6n,
- 
- 	if (!ipv6_addr_any(remote) || !ipv6_addr_any(local)) {
- 		prio = 1;
--		h = HASH(remote, local);
-+		h = HASH(local);
- 	}
- 	return &ip6n->tnls[prio][h];
- }
-@@ -391,6 +400,12 @@ ip6_tnl_dev_uninit(struct net_device *de
- 	struct net *net = t->net;
- 	struct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);
- 
-+	while (t->parms.fmrs) {
-+		struct __ip6_tnl_fmr *next = t->parms.fmrs->next;
-+		kfree(t->parms.fmrs);
-+		t->parms.fmrs = next;
-+	}
-+
- 	if (dev == ip6n->fb_tnl_dev)
- 		RCU_INIT_POINTER(ip6n->tnls_wc[0], NULL);
- 	else
-@@ -784,6 +799,108 @@ int ip6_tnl_rcv_ctl(struct ip6_tnl *t,
- }
- EXPORT_SYMBOL_GPL(ip6_tnl_rcv_ctl);
- 
-+
-+/**
-+ * ip4ip6_fmr_calc - calculate target / source IPv6-address based on FMR
-+ *   @dest: destination IPv6 address buffer
-+ *   @skb: received socket buffer
-+ *   @fmr: MAP FMR
-+ *   @xmit: Calculate for xmit or rcv
-+ **/
-+static void ip4ip6_fmr_calc(struct in6_addr *dest,
-+		const struct iphdr *iph, const uint8_t *end,
-+		const struct __ip6_tnl_fmr *fmr, bool xmit)
-+{
-+	int psidlen = fmr->ea_len - (32 - fmr->ip4_prefix_len);
-+	u8 *portp = NULL;
-+	bool use_dest_addr;
-+	const struct iphdr *dsth = iph;
-+
-+	if ((u8*)dsth >= end)
-+		return;
-+
-+	/* find significant IP header */
-+	if (iph->protocol == IPPROTO_ICMP) {
-+		struct icmphdr *ih = (struct icmphdr*)(((u8*)dsth) + dsth->ihl * 4);
-+		if (ih && ((u8*)&ih[1]) <= end && (
-+			ih->type == ICMP_DEST_UNREACH ||
-+			ih->type == ICMP_SOURCE_QUENCH ||
-+			ih->type == ICMP_TIME_EXCEEDED ||
-+			ih->type == ICMP_PARAMETERPROB ||
-+			ih->type == ICMP_REDIRECT))
-+				dsth = (const struct iphdr*)&ih[1];
-+	}
-+
-+	/* in xmit-path use dest port by default and source port only if
-+		this is an ICMP reply to something else; vice versa in rcv-path */
-+	use_dest_addr = (xmit && dsth == iph) || (!xmit && dsth != iph);
-+
-+	/* get dst port */
-+	if (((u8*)&dsth[1]) <= end && (
-+		dsth->protocol == IPPROTO_UDP ||
-+		dsth->protocol == IPPROTO_TCP ||
-+		dsth->protocol == IPPROTO_SCTP ||
-+		dsth->protocol == IPPROTO_DCCP)) {
-+			/* for UDP, TCP, SCTP and DCCP source and dest port
-+			follow IPv4 header directly */
-+			portp = ((u8*)dsth) + dsth->ihl * 4;
-+
-+			if (use_dest_addr)
-+				portp += sizeof(u16);
-+	} else if (iph->protocol == IPPROTO_ICMP) {
-+		struct icmphdr *ih = (struct icmphdr*)(((u8*)dsth) + dsth->ihl * 4);
-+
-+		/* use icmp identifier as port */
-+		if (((u8*)&ih) <= end && (
-+		    (use_dest_addr && (
-+		    ih->type == ICMP_ECHOREPLY ||
-+			ih->type == ICMP_TIMESTAMPREPLY ||
-+			ih->type == ICMP_INFO_REPLY ||
-+			ih->type == ICMP_ADDRESSREPLY)) ||
-+			(!use_dest_addr && (
-+			ih->type == ICMP_ECHO ||
-+			ih->type == ICMP_TIMESTAMP ||
-+			ih->type == ICMP_INFO_REQUEST ||
-+			ih->type == ICMP_ADDRESS)
-+			)))
-+				portp = (u8*)&ih->un.echo.id;
-+	}
-+
-+	if ((portp && &portp[2] <= end) || psidlen == 0) {
-+		int frombyte = fmr->ip6_prefix_len / 8;
-+		int fromrem = fmr->ip6_prefix_len % 8;
-+		int bytes = sizeof(struct in6_addr) - frombyte;
-+		const u32 *addr = (use_dest_addr) ? &iph->daddr : &iph->saddr;
-+		u64 eabits = ((u64)ntohl(*addr)) << (32 + fmr->ip4_prefix_len);
-+		u64 t = 0;
-+
-+		/* extract PSID from port and add it to eabits */
-+		u16 psidbits = 0;
-+		if (psidlen > 0) {
-+			psidbits = ((u16)portp[0]) << 8 | ((u16)portp[1]);
-+			psidbits >>= 16 - psidlen - fmr->offset;
-+			psidbits = (u16)(psidbits << (16 - psidlen));
-+			eabits |= ((u64)psidbits) << (48 - (fmr->ea_len - psidlen));
-+		}
-+
-+		/* rewrite destination address */
-+		*dest = fmr->ip6_prefix;
-+		memcpy(&dest->s6_addr[10], addr, sizeof(*addr));
-+		dest->s6_addr16[7] = htons(psidbits >> (16 - psidlen));
-+
-+		if (bytes > sizeof(u64))
-+			bytes = sizeof(u64);
-+
-+		/* insert eabits */
-+		memcpy(&t, &dest->s6_addr[frombyte], bytes);
-+		t = be64_to_cpu(t) & ~(((((u64)1) << fmr->ea_len) - 1)
-+			<< (64 - fmr->ea_len - fromrem));
-+		t = cpu_to_be64(t | (eabits >> fromrem));
-+		memcpy(&dest->s6_addr[frombyte], &t, bytes);
-+	}
-+}
-+
-+
- /**
-  * ip6_tnl_rcv - decapsulate IPv6 packet and retransmit it locally
-  *   @skb: received socket buffer
-@@ -828,6 +945,26 @@ static int ip6_tnl_rcv(struct sk_buff *s
- 		skb_reset_network_header(skb);
- 		skb->protocol = htons(protocol);
- 		memset(skb->cb, 0, sizeof(struct inet6_skb_parm));
-+		if (protocol == ETH_P_IP && t->parms.fmrs &&
-+			!ipv6_addr_equal(&ipv6h->saddr, &t->parms.raddr)) {
-+				/* Packet didn't come from BR, so lookup FMR */
-+				struct __ip6_tnl_fmr *fmr;
-+				struct in6_addr expected = t->parms.raddr;
-+				for (fmr = t->parms.fmrs; fmr; fmr = fmr->next)
-+					if (ipv6_prefix_equal(&ipv6h->saddr,
-+						&fmr->ip6_prefix, fmr->ip6_prefix_len))
-+							break;
-+
-+				/* Check that IPv6 matches IPv4 source to prevent spoofing */
-+				if (fmr)
-+					ip4ip6_fmr_calc(&expected, ip_hdr(skb),
-+							skb_tail_pointer(skb), fmr, false);
-+
-+				if (!ipv6_addr_equal(&ipv6h->saddr, &expected)) {
-+					rcu_read_unlock();
-+					goto discard;
-+				}
-+		}
- 
- 		__skb_tunnel_rx(skb, t->dev, t->net);
- 
-@@ -1089,6 +1226,7 @@ ip4ip6_tnl_xmit(struct sk_buff *skb, str
- 	__u8 dsfield;
- 	__u32 mtu;
- 	int err;
-+	struct __ip6_tnl_fmr *fmr;
- 
- 	/* ensure we can access the full inner ip header */
- 	if (!pskb_may_pull(skb, sizeof(struct iphdr)))
-@@ -1114,6 +1252,18 @@ ip4ip6_tnl_xmit(struct sk_buff *skb, str
- 	if (t->parms.flags & IP6_TNL_F_USE_ORIG_FWMARK)
- 		fl6.flowi6_mark = skb->mark;
- 
-+	/* try to find matching FMR */
-+	for (fmr = t->parms.fmrs; fmr; fmr = fmr->next) {
-+		unsigned mshift = 32 - fmr->ip4_prefix_len;
-+		if (ntohl(fmr->ip4_prefix.s_addr) >> mshift ==
-+				ntohl(iph->daddr) >> mshift)
-+			break;
-+	}
-+
-+	/* change dstaddr according to FMR */
-+	if (fmr)
-+		ip4ip6_fmr_calc(&fl6.daddr, iph, skb_tail_pointer(skb), fmr, true);
-+
- 	err = ip6_tnl_xmit2(skb, dev, dsfield, &fl6, encap_limit, &mtu);
- 	if (err != 0) {
- 		/* XXX: send ICMP error even if DF is not set. */
-@@ -1286,6 +1436,14 @@ ip6_tnl_change(struct ip6_tnl *t, const
- 	t->parms.flowinfo = p->flowinfo;
- 	t->parms.link = p->link;
- 	t->parms.proto = p->proto;
-+
-+	while (t->parms.fmrs) {
-+		struct __ip6_tnl_fmr *next = t->parms.fmrs->next;
-+		kfree(t->parms.fmrs);
-+		t->parms.fmrs = next;
-+	}
-+	t->parms.fmrs = p->fmrs;
-+
- 	ip6_tnl_dst_reset(t);
- 	ip6_tnl_link_config(t);
- 	return 0;
-@@ -1316,6 +1474,7 @@ ip6_tnl_parm_from_user(struct __ip6_tnl_
- 	p->flowinfo = u->flowinfo;
- 	p->link = u->link;
- 	p->proto = u->proto;
-+	p->fmrs = NULL;
- 	memcpy(p->name, u->name, sizeof(u->name));
- }
- 
-@@ -1591,6 +1750,15 @@ static int ip6_tnl_validate(struct nlatt
- 	return 0;
- }
- 
-+static const struct nla_policy ip6_tnl_fmr_policy[IFLA_IPTUN_FMR_MAX + 1] = {
-+	[IFLA_IPTUN_FMR_IP6_PREFIX] = { .len = sizeof(struct in6_addr) },
-+	[IFLA_IPTUN_FMR_IP4_PREFIX] = { .len = sizeof(struct in_addr) },
-+	[IFLA_IPTUN_FMR_IP6_PREFIX_LEN] = { .type = NLA_U8 },
-+	[IFLA_IPTUN_FMR_IP4_PREFIX_LEN] = { .type = NLA_U8 },
-+	[IFLA_IPTUN_FMR_EA_LEN] = { .type = NLA_U8 },
-+	[IFLA_IPTUN_FMR_OFFSET] = { .type = NLA_U8 }
-+};
-+
- static void ip6_tnl_netlink_parms(struct nlattr *data[],
- 				  struct __ip6_tnl_parm *parms)
- {
-@@ -1624,6 +1792,46 @@ static void ip6_tnl_netlink_parms(struct
- 
- 	if (data[IFLA_IPTUN_PROTO])
- 		parms->proto = nla_get_u8(data[IFLA_IPTUN_PROTO]);
-+
-+	if (data[IFLA_IPTUN_FMRS]) {
-+		unsigned rem;
-+		struct nlattr *fmr;
-+		nla_for_each_nested(fmr, data[IFLA_IPTUN_FMRS], rem) {
-+			struct nlattr *fmrd[IFLA_IPTUN_FMR_MAX + 1], *c;
-+			struct __ip6_tnl_fmr *nfmr;
-+
-+			nla_parse_nested(fmrd, IFLA_IPTUN_FMR_MAX,
-+				fmr, ip6_tnl_fmr_policy);
-+
-+			if (!(nfmr = kzalloc(sizeof(*nfmr), GFP_KERNEL)))
-+				continue;
-+
-+			nfmr->offset = 6;
-+
-+			if ((c = fmrd[IFLA_IPTUN_FMR_IP6_PREFIX]))
-+				nla_memcpy(&nfmr->ip6_prefix, fmrd[IFLA_IPTUN_FMR_IP6_PREFIX],
-+					sizeof(nfmr->ip6_prefix));
-+
-+			if ((c = fmrd[IFLA_IPTUN_FMR_IP4_PREFIX]))
-+				nla_memcpy(&nfmr->ip4_prefix, fmrd[IFLA_IPTUN_FMR_IP4_PREFIX],
-+					sizeof(nfmr->ip4_prefix));
-+
-+			if ((c = fmrd[IFLA_IPTUN_FMR_IP6_PREFIX_LEN]))
-+				nfmr->ip6_prefix_len = nla_get_u8(c);
-+
-+			if ((c = fmrd[IFLA_IPTUN_FMR_IP4_PREFIX_LEN]))
-+				nfmr->ip4_prefix_len = nla_get_u8(c);
-+
-+			if ((c = fmrd[IFLA_IPTUN_FMR_EA_LEN]))
-+				nfmr->ea_len = nla_get_u8(c);
-+
-+			if ((c = fmrd[IFLA_IPTUN_FMR_OFFSET]))
-+				nfmr->offset = nla_get_u8(c);
-+
-+			nfmr->next = parms->fmrs;
-+			parms->fmrs = nfmr;
-+		}
-+	}
- }
- 
- static int ip6_tnl_newlink(struct net *src_net, struct net_device *dev,
-@@ -1676,6 +1884,12 @@ static void ip6_tnl_dellink(struct net_d
- 
- static size_t ip6_tnl_get_size(const struct net_device *dev)
- {
-+	const struct ip6_tnl *t = netdev_priv(dev);
-+	struct __ip6_tnl_fmr *c;
-+	int fmrs = 0;
-+	for (c = t->parms.fmrs; c; c = c->next)
-+		++fmrs;
-+
- 	return
- 		/* IFLA_IPTUN_LINK */
- 		nla_total_size(4) +
-@@ -1693,6 +1907,24 @@ static size_t ip6_tnl_get_size(const str
- 		nla_total_size(4) +
- 		/* IFLA_IPTUN_PROTO */
- 		nla_total_size(1) +
-+		/* IFLA_IPTUN_FMRS */
-+		nla_total_size(0) +
-+		(
-+			/* nest */
-+			nla_total_size(0) +
-+			/* IFLA_IPTUN_FMR_IP6_PREFIX */
-+			nla_total_size(sizeof(struct in6_addr)) +
-+			/* IFLA_IPTUN_FMR_IP4_PREFIX */
-+			nla_total_size(sizeof(struct in_addr)) +
-+			/* IFLA_IPTUN_FMR_EA_LEN */
-+			nla_total_size(1) +
-+			/* IFLA_IPTUN_FMR_IP6_PREFIX_LEN */
-+			nla_total_size(1) +
-+			/* IFLA_IPTUN_FMR_IP4_PREFIX_LEN */
-+			nla_total_size(1) +
-+			/* IFLA_IPTUN_FMR_OFFSET */
-+			nla_total_size(1)
-+		) * fmrs +
- 		0;
- }
- 
-@@ -1700,6 +1932,9 @@ static int ip6_tnl_fill_info(struct sk_b
- {
- 	struct ip6_tnl *tunnel = netdev_priv(dev);
- 	struct __ip6_tnl_parm *parm = &tunnel->parms;
-+	struct __ip6_tnl_fmr *c;
-+	int fmrcnt = 0;
-+	struct nlattr *fmrs;
- 
- 	if (nla_put_u32(skb, IFLA_IPTUN_LINK, parm->link) ||
- 	    nla_put(skb, IFLA_IPTUN_LOCAL, sizeof(struct in6_addr),
-@@ -1710,8 +1945,27 @@ static int ip6_tnl_fill_info(struct sk_b
- 	    nla_put_u8(skb, IFLA_IPTUN_ENCAP_LIMIT, parm->encap_limit) ||
- 	    nla_put_be32(skb, IFLA_IPTUN_FLOWINFO, parm->flowinfo) ||
- 	    nla_put_u32(skb, IFLA_IPTUN_FLAGS, parm->flags) ||
--	    nla_put_u8(skb, IFLA_IPTUN_PROTO, parm->proto))
-+	    nla_put_u8(skb, IFLA_IPTUN_PROTO, parm->proto) ||
-+	    !(fmrs = nla_nest_start(skb, IFLA_IPTUN_FMRS)))
- 		goto nla_put_failure;
-+
-+	for (c = parm->fmrs; c; c = c->next) {
-+		struct nlattr *fmr = nla_nest_start(skb, ++fmrcnt);
-+		if (!fmr ||
-+			nla_put(skb, IFLA_IPTUN_FMR_IP6_PREFIX,
-+				sizeof(c->ip6_prefix), &c->ip6_prefix) ||
-+			nla_put(skb, IFLA_IPTUN_FMR_IP4_PREFIX,
-+				sizeof(c->ip4_prefix), &c->ip4_prefix) ||
-+			nla_put_u8(skb, IFLA_IPTUN_FMR_IP6_PREFIX_LEN, c->ip6_prefix_len) ||
-+			nla_put_u8(skb, IFLA_IPTUN_FMR_IP4_PREFIX_LEN, c->ip4_prefix_len) ||
-+			nla_put_u8(skb, IFLA_IPTUN_FMR_EA_LEN, c->ea_len) ||
-+			nla_put_u8(skb, IFLA_IPTUN_FMR_OFFSET, c->offset))
-+				goto nla_put_failure;
-+
-+		nla_nest_end(skb, fmr);
-+	}
-+	nla_nest_end(skb, fmrs);
-+
- 	return 0;
- 
- nla_put_failure:
-@@ -1727,6 +1981,7 @@ static const struct nla_policy ip6_tnl_p
- 	[IFLA_IPTUN_FLOWINFO]		= { .type = NLA_U32 },
- 	[IFLA_IPTUN_FLAGS]		= { .type = NLA_U32 },
- 	[IFLA_IPTUN_PROTO]		= { .type = NLA_U8 },
-+	[IFLA_IPTUN_FMRS]		= { .type = NLA_NESTED },
- };
- 
- static struct rtnl_link_ops ip6_link_ops __read_mostly = {
--- a/target/linux/generic/pending-3.18/667-ipv6-Fixed-source-specific-default-route-handling.patch	2022-03-22 08:54:47.329464873 +0800
+++ b/target/linux/generic/pending-3.18/667-ipv6-Fixed-source-specific-default-route-handling.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,96 +0,0 @@
-From e16e888b525503be05b3aea64190e8b3bdef44d0 Mon Sep 17 00:00:00 2001
-From: Markus Stenberg <markus.stenberg@iki.fi>
-Date: Tue, 5 May 2015 13:36:59 +0300
-Subject: [PATCH] ipv6: Fixed source specific default route handling.
-
-If there are only IPv6 source specific default routes present, the
-host gets -ENETUNREACH on e.g. connect() because ip6_dst_lookup_tail
-calls ip6_route_output first, and given source address any, it fails,
-and ip6_route_get_saddr is never called.
-
-The change is to use the ip6_route_get_saddr, even if the initial
-ip6_route_output fails, and then doing ip6_route_output _again_ after
-we have appropriate source address available.
-
-Note that this is '99% fix' to the problem; a correct fix would be to
-do route lookups only within addrconf.c when picking a source address,
-and never call ip6_route_output before source address has been
-populated.
-
-Signed-off-by: Markus Stenberg <markus.stenberg@iki.fi>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- net/ipv6/ip6_output.c | 39 +++++++++++++++++++++++++++++++--------
- net/ipv6/route.c      |  5 +++--
- 2 files changed, 34 insertions(+), 10 deletions(-)
-
---- a/net/ipv6/ip6_output.c
-+++ b/net/ipv6/ip6_output.c
-@@ -909,21 +909,45 @@ static int ip6_dst_lookup_tail(struct so
- #endif
- 	int err;
- 
--	if (*dst == NULL)
--		*dst = ip6_route_output(net, sk, fl6);
--
--	if ((err = (*dst)->error))
--		goto out_err_release;
-+	/* The correct way to handle this would be to do
-+	 * ip6_route_get_saddr, and then ip6_route_output; however,
-+	 * the route-specific preferred source forces the
-+	 * ip6_route_output call _before_ ip6_route_get_saddr.
-+	 *
-+	 * In source specific routing (no src=any default route),
-+	 * ip6_route_output will fail given src=any saddr, though, so
-+	 * that's why we try it again later.
-+	 */
-+	if (ipv6_addr_any(&fl6->saddr) && (!*dst || !(*dst)->error)) {
-+		struct rt6_info *rt;
-+		bool had_dst = *dst != NULL;
- 
--	if (ipv6_addr_any(&fl6->saddr)) {
--		struct rt6_info *rt = (struct rt6_info *) *dst;
-+		if (!had_dst)
-+			*dst = ip6_route_output(net, sk, fl6);
-+		rt = (*dst)->error ? NULL : (struct rt6_info *)*dst;
- 		err = ip6_route_get_saddr(net, rt, &fl6->daddr,
- 					  sk ? inet6_sk(sk)->srcprefs : 0,
- 					  &fl6->saddr);
- 		if (err)
- 			goto out_err_release;
-+
-+		/* If we had an erroneous initial result, pretend it
-+		 * never existed and let the SA-enabled version take
-+		 * over.
-+		 */
-+		if (!had_dst && (*dst)->error) {
-+			dst_release(*dst);
-+			*dst = NULL;
-+		}
- 	}
- 
-+	if (!*dst)
-+		*dst = ip6_route_output(net, sk, fl6);
-+
-+	err = (*dst)->error;
-+	if (err)
-+		goto out_err_release;
-+
- #ifdef CONFIG_IPV6_OPTIMISTIC_DAD
- 	/*
- 	 * Here if the dst entry we've looked up
---- a/net/ipv6/route.c
-+++ b/net/ipv6/route.c
-@@ -2185,9 +2185,10 @@ int ip6_route_get_saddr(struct net *net,
- 			unsigned int prefs,
- 			struct in6_addr *saddr)
- {
--	struct inet6_dev *idev = ip6_dst_idev((struct dst_entry *)rt);
-+	struct inet6_dev *idev =
-+		rt ? ip6_dst_idev((struct dst_entry *)rt) : NULL;
- 	int err = 0;
--	if (rt->rt6i_prefsrc.plen)
-+	if (rt && rt->rt6i_prefsrc.plen)
- 		*saddr = rt->rt6i_prefsrc.addr;
- 	else
- 		err = ipv6_dev_get_saddr(net, idev ? idev->dev : NULL,
--- a/target/linux/generic/pending-3.18/670-ipv6-allow-rejecting-with-source-address-failed-policy.patch	2022-03-22 08:54:47.329464873 +0800
+++ b/target/linux/generic/pending-3.18/670-ipv6-allow-rejecting-with-source-address-failed-policy.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,249 +0,0 @@
-From 1b5aaa4b16f6e6471ab1c07b38068197a1b4c395 Mon Sep 17 00:00:00 2001
-From: Jonas Gorski <jogo@openwrt.org>
-Date: Fri, 24 May 2013 14:40:54 +0200
-Subject: [PATCH 1/2] ipv6: allow rejecting with "source address failed policy"
-
-RFC6204 L-14 requires rejecting traffic from invalid addresses with
-ICMPv6 Destination Unreachable, Code 5 (Source address failed ingress/
-egress policy) on the LAN side, so add an appropriate rule for that.
-
-Signed-off-by: Jonas Gorski <jogo@openwrt.org>
----
- include/net/netns/ipv6.h       |  1 +
- include/uapi/linux/fib_rules.h |  4 +++
- include/uapi/linux/rtnetlink.h |  1 +
- net/ipv4/fib_semantics.c       |  4 +++
- net/ipv4/fib_trie.c            |  1 +
- net/ipv4/ipmr.c                |  1 +
- net/ipv6/fib6_rules.c          |  4 +++
- net/ipv6/ip6mr.c               |  2 ++
- net/ipv6/route.c               | 58 +++++++++++++++++++++++++++++++++++++++++-
- 9 files changed, 75 insertions(+), 1 deletion(-)
-
---- a/include/net/netns/ipv6.h
-+++ b/include/net/netns/ipv6.h
-@@ -59,6 +59,7 @@ struct netns_ipv6 {
- 	unsigned long		 ip6_rt_last_gc;
- #ifdef CONFIG_IPV6_MULTIPLE_TABLES
- 	struct rt6_info         *ip6_prohibit_entry;
-+	struct rt6_info		*ip6_policy_failed_entry;
- 	struct rt6_info         *ip6_blk_hole_entry;
- 	struct fib6_table       *fib6_local_tbl;
- 	struct fib_rules_ops    *fib6_rules_ops;
---- a/include/uapi/linux/fib_rules.h
-+++ b/include/uapi/linux/fib_rules.h
-@@ -64,6 +64,10 @@ enum {
- 	FR_ACT_BLACKHOLE,	/* Drop without notification */
- 	FR_ACT_UNREACHABLE,	/* Drop with ENETUNREACH */
- 	FR_ACT_PROHIBIT,	/* Drop with EACCES */
-+	FR_ACT_RES9,
-+	FR_ACT_RES10,
-+	FR_ACT_RES11,
-+	FR_ACT_POLICY_FAILED,	/* Drop with EACCES */
- 	__FR_ACT_MAX,
- };
- 
---- a/include/uapi/linux/rtnetlink.h
-+++ b/include/uapi/linux/rtnetlink.h
-@@ -203,6 +203,7 @@ enum {
- 	RTN_THROW,		/* Not in this table		*/
- 	RTN_NAT,		/* Translate this address	*/
- 	RTN_XRESOLVE,		/* Use external resolver	*/
-+	RTN_POLICY_FAILED,	/* Failed ingress/egress policy */
- 	__RTN_MAX
- };
- 
---- a/net/ipv4/fib_semantics.c
-+++ b/net/ipv4/fib_semantics.c
-@@ -138,6 +138,10 @@ const struct fib_prop fib_props[RTN_MAX
- 		.error	= -EINVAL,
- 		.scope	= RT_SCOPE_NOWHERE,
- 	},
-+	[RTN_POLICY_FAILED] = {
-+		.error	= -EACCES,
-+		.scope	= RT_SCOPE_UNIVERSE,
-+	},
- };
- 
- static void rt_fibinfo_free(struct rtable __rcu **rtp)
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -2236,6 +2236,7 @@ static const char *const rtn_type_names[
- 	[RTN_THROW] = "THROW",
- 	[RTN_NAT] = "NAT",
- 	[RTN_XRESOLVE] = "XRESOLVE",
-+	[RTN_POLICY_FAILED] = "POLICY_FAILED",
- };
- 
- static inline const char *rtn_type(char *buf, size_t len, unsigned int t)
---- a/net/ipv4/ipmr.c
-+++ b/net/ipv4/ipmr.c
-@@ -184,6 +184,7 @@ static int ipmr_rule_action(struct fib_r
- 	case FR_ACT_UNREACHABLE:
- 		return -ENETUNREACH;
- 	case FR_ACT_PROHIBIT:
-+	case FR_ACT_POLICY_FAILED:
- 		return -EACCES;
- 	case FR_ACT_BLACKHOLE:
- 	default:
---- a/net/ipv6/fib6_rules.c
-+++ b/net/ipv6/fib6_rules.c
-@@ -73,6 +73,10 @@ static int fib6_rule_action(struct fib_r
- 		err = -EACCES;
- 		rt = net->ipv6.ip6_prohibit_entry;
- 		goto discard_pkt;
-+	case FR_ACT_POLICY_FAILED:
-+		err = -EACCES;
-+		rt = net->ipv6.ip6_policy_failed_entry;
-+		goto discard_pkt;
- 	}
- 
- 	table = fib6_get_table(net, rule->table);
---- a/net/ipv6/ip6mr.c
-+++ b/net/ipv6/ip6mr.c
-@@ -169,6 +169,8 @@ static int ip6mr_rule_action(struct fib_
- 		return -ENETUNREACH;
- 	case FR_ACT_PROHIBIT:
- 		return -EACCES;
-+	case FR_ACT_POLICY_FAILED:
-+		return -EACCES;
- 	case FR_ACT_BLACKHOLE:
- 	default:
- 		return -EINVAL;
---- a/net/ipv6/route.c
-+++ b/net/ipv6/route.c
-@@ -87,6 +87,8 @@ static int		ip6_pkt_discard(struct sk_bu
- static int		ip6_pkt_discard_out(struct sock *sk, struct sk_buff *skb);
- static int		ip6_pkt_prohibit(struct sk_buff *skb);
- static int		ip6_pkt_prohibit_out(struct sock *sk, struct sk_buff *skb);
-+static int		ip6_pkt_policy_failed(struct sk_buff *skb);
-+static int		ip6_pkt_policy_failed_out(struct sock *sk, struct sk_buff *skb);
- static void		ip6_link_failure(struct sk_buff *skb);
- static void		ip6_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,
- 					   struct sk_buff *skb, u32 mtu);
-@@ -283,6 +285,21 @@ static const struct rt6_info ip6_prohibi
- 	.rt6i_ref	= ATOMIC_INIT(1),
- };
- 
-+static const struct rt6_info ip6_policy_failed_entry_template = {
-+	.dst = {
-+		.__refcnt	= ATOMIC_INIT(1),
-+		.__use		= 1,
-+		.obsolete	= DST_OBSOLETE_FORCE_CHK,
-+		.error		= -EACCES,
-+		.input		= ip6_pkt_policy_failed,
-+		.output		= ip6_pkt_policy_failed_out,
-+	},
-+	.rt6i_flags	= (RTF_REJECT | RTF_NONEXTHOP),
-+	.rt6i_protocol	= RTPROT_KERNEL,
-+	.rt6i_metric	= ~(u32) 0,
-+	.rt6i_ref	= ATOMIC_INIT(1),
-+};
-+
- static const struct rt6_info ip6_blk_hole_entry_template = {
- 	.dst = {
- 		.__refcnt	= ATOMIC_INIT(1),
-@@ -1579,6 +1596,11 @@ int ip6_route_add(struct fib6_config *cf
- 			rt->dst.output = ip6_pkt_prohibit_out;
- 			rt->dst.input = ip6_pkt_prohibit;
- 			break;
-+		case RTN_POLICY_FAILED:
-+			rt->dst.error = -EACCES;
-+			rt->dst.output = ip6_pkt_policy_failed_out;
-+			rt->dst.input = ip6_pkt_policy_failed;
-+			break;
- 		case RTN_THROW:
- 		default:
- 			rt->dst.error = (cfg->fc_type == RTN_THROW) ? -EAGAIN
-@@ -2142,6 +2164,17 @@ static int ip6_pkt_prohibit_out(struct s
- 	return ip6_pkt_drop(skb, ICMPV6_ADM_PROHIBITED, IPSTATS_MIB_OUTNOROUTES);
- }
- 
-+static int ip6_pkt_policy_failed(struct sk_buff *skb)
-+{
-+	return ip6_pkt_drop(skb, ICMPV6_POLICY_FAIL, IPSTATS_MIB_INNOROUTES);
-+}
-+
-+static int ip6_pkt_policy_failed_out(struct sock *sk, struct sk_buff *skb)
-+{
-+	skb->dev = skb_dst(skb)->dev;
-+	return ip6_pkt_drop(skb, ICMPV6_POLICY_FAIL, IPSTATS_MIB_OUTNOROUTES);
-+}
-+
- /*
-  *	Allocate a dst for local (unicast / anycast) address.
-  */
-@@ -2368,7 +2401,8 @@ static int rtm_to_fib6_config(struct sk_
- 	if (rtm->rtm_type == RTN_UNREACHABLE ||
- 	    rtm->rtm_type == RTN_BLACKHOLE ||
- 	    rtm->rtm_type == RTN_PROHIBIT ||
--	    rtm->rtm_type == RTN_THROW)
-+	    rtm->rtm_type == RTN_THROW ||
-+	    rtm->rtm_type == RTN_POLICY_FAILED)
- 		cfg->fc_flags |= RTF_REJECT;
- 
- 	if (rtm->rtm_type == RTN_LOCAL)
-@@ -2570,6 +2604,9 @@ static int rt6_fill_node(struct net *net
- 		case -EACCES:
- 			rtm->rtm_type = RTN_PROHIBIT;
- 			break;
-+		case -EPERM:
-+			rtm->rtm_type = RTN_POLICY_FAILED;
-+			break;
- 		case -EAGAIN:
- 			rtm->rtm_type = RTN_THROW;
- 			break;
-@@ -2828,6 +2865,8 @@ static int ip6_route_dev_notify(struct n
- #ifdef CONFIG_IPV6_MULTIPLE_TABLES
- 		net->ipv6.ip6_prohibit_entry->dst.dev = dev;
- 		net->ipv6.ip6_prohibit_entry->rt6i_idev = in6_dev_get(dev);
-+		net->ipv6.ip6_policy_failed_entry->dst.dev = dev;
-+		net->ipv6.ip6_policy_failed_entry->rt6i_idev = in6_dev_get(dev);
- 		net->ipv6.ip6_blk_hole_entry->dst.dev = dev;
- 		net->ipv6.ip6_blk_hole_entry->rt6i_idev = in6_dev_get(dev);
- #endif
-@@ -3054,6 +3093,17 @@ static int __net_init ip6_route_net_init
- 	net->ipv6.ip6_blk_hole_entry->dst.ops = &net->ipv6.ip6_dst_ops;
- 	dst_init_metrics(&net->ipv6.ip6_blk_hole_entry->dst,
- 			 ip6_template_metrics, true);
-+
-+	net->ipv6.ip6_policy_failed_entry =
-+		kmemdup(&ip6_policy_failed_entry_template,
-+			sizeof(*net->ipv6.ip6_policy_failed_entry), GFP_KERNEL);
-+	if (!net->ipv6.ip6_policy_failed_entry)
-+		goto out_ip6_blk_hole_entry;
-+	net->ipv6.ip6_policy_failed_entry->dst.path =
-+		(struct dst_entry *)net->ipv6.ip6_policy_failed_entry;
-+	net->ipv6.ip6_policy_failed_entry->dst.ops = &net->ipv6.ip6_dst_ops;
-+	dst_init_metrics(&net->ipv6.ip6_policy_failed_entry->dst,
-+			 ip6_template_metrics, true);
- #endif
- 
- 	net->ipv6.sysctl.flush_delay = 0;
-@@ -3072,6 +3122,8 @@ out:
- 	return ret;
- 
- #ifdef CONFIG_IPV6_MULTIPLE_TABLES
-+out_ip6_blk_hole_entry:
-+	kfree(net->ipv6.ip6_blk_hole_entry);
- out_ip6_prohibit_entry:
- 	kfree(net->ipv6.ip6_prohibit_entry);
- out_ip6_null_entry:
-@@ -3089,6 +3141,7 @@ static void __net_exit ip6_route_net_exi
- #ifdef CONFIG_IPV6_MULTIPLE_TABLES
- 	kfree(net->ipv6.ip6_prohibit_entry);
- 	kfree(net->ipv6.ip6_blk_hole_entry);
-+	kfree(net->ipv6.ip6_policy_failed_entry);
- #endif
- 	dst_entries_destroy(&net->ipv6.ip6_dst_ops);
- }
-@@ -3162,6 +3215,9 @@ void __init ip6_route_init_special_entri
- 	init_net.ipv6.ip6_prohibit_entry->rt6i_idev = in6_dev_get(init_net.loopback_dev);
- 	init_net.ipv6.ip6_blk_hole_entry->dst.dev = init_net.loopback_dev;
- 	init_net.ipv6.ip6_blk_hole_entry->rt6i_idev = in6_dev_get(init_net.loopback_dev);
-+	init_net.ipv6.ip6_policy_failed_entry->dst.dev = init_net.loopback_dev;
-+	init_net.ipv6.ip6_policy_failed_entry->rt6i_idev =
-+		in6_dev_get(init_net.loopback_dev);
-   #endif
- }
- 
--- a/target/linux/generic/pending-3.18/671-net-provide-defines-for-_POLICY_FAILED-until-all-cod.patch	2022-03-22 08:54:47.330464874 +0800
+++ b/target/linux/generic/pending-3.18/671-net-provide-defines-for-_POLICY_FAILED-until-all-cod.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,53 +0,0 @@
-From 7749b481ce5d7e232b1f7da5e6b2c44816f51681 Mon Sep 17 00:00:00 2001
-From: Jonas Gorski <jogo@openwrt.org>
-Date: Sun, 19 Jan 2014 20:45:51 +0100
-Subject: [PATCH 2/2] net: provide defines for _POLICY_FAILED until all code is
- updated
-
-Upstream introduced ICMPV6_POLICY_FAIL for code 5 of destination
-unreachable, conflicting with our name.
-
-Add appropriate defines to allow our code to build with the new
-name until we have updated our local patches for older kernels
-and userspace packages.
-
-Signed-off-by: Jonas Gorski <jogo@openwrt.org>
----
- include/uapi/linux/fib_rules.h | 2 ++
- include/uapi/linux/icmpv6.h    | 2 ++
- include/uapi/linux/rtnetlink.h | 2 ++
- 3 files changed, 6 insertions(+)
-
---- a/include/uapi/linux/fib_rules.h
-+++ b/include/uapi/linux/fib_rules.h
-@@ -71,6 +71,8 @@ enum {
- 	__FR_ACT_MAX,
- };
- 
-+#define FR_ACT_FAILED_POLICY FR_ACT_POLICY_FAILED
-+
- #define FR_ACT_MAX (__FR_ACT_MAX - 1)
- 
- #endif
---- a/include/uapi/linux/icmpv6.h
-+++ b/include/uapi/linux/icmpv6.h
-@@ -118,6 +118,8 @@ struct icmp6hdr {
- #define ICMPV6_POLICY_FAIL		5
- #define ICMPV6_REJECT_ROUTE		6
- 
-+#define ICMPV6_FAILED_POLICY		ICMPV6_POLICY_FAIL
-+
- /*
-  *	Codes for Time Exceeded
-  */
---- a/include/uapi/linux/rtnetlink.h
-+++ b/include/uapi/linux/rtnetlink.h
-@@ -207,6 +207,8 @@ enum {
- 	__RTN_MAX
- };
- 
-+#define RTN_FAILED_POLICY RTN_POLICY_FAILED
-+
- #define RTN_MAX (__RTN_MAX - 1)
- 
- 
--- a/target/linux/generic/pending-3.18/680-NET-skip-GRO-for-foreign-MAC-addresses.patch	2022-03-22 08:54:47.330464874 +0800
+++ b/target/linux/generic/pending-3.18/680-NET-skip-GRO-for-foreign-MAC-addresses.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,160 +0,0 @@
-Subject: NET: skip GRO for foreign MAC addresses
-
-For network drivers using napi_gro_receive, packets are run through GRO,
-even when the destination MAC address does not match, and they're supposed
-to be delivered to another host behind a different bridge port.
-
-This can be very expensive, because for drivers without TSO or scatter-
-gather, this can only be undone by copying the skb and checksumming it
-again.
-
-To be able to track foreign MAC addresses in an inexpensive way, create
-a mask of changed bits in MAC addresses of upper devices. This allows
-handling VLANs and bridge devices with different addresses (as long as
-they are not too different).
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
-
---- a/net/core/dev.c
-+++ b/net/core/dev.c
-@@ -4028,6 +4028,9 @@ static enum gro_result dev_gro_receive(s
- 	enum gro_result ret;
- 	int grow;
- 
-+	if (skb->gro_skip)
-+		goto normal;
-+
- 	if (!(skb->dev->features & NETIF_F_GRO))
- 		goto normal;
- 
-@@ -5103,6 +5106,48 @@ static void __netdev_adjacent_dev_unlink
- 					   &upper_dev->adj_list.lower);
- }
- 
-+static void __netdev_addr_mask(unsigned char *mask, const unsigned char *addr,
-+			       struct net_device *dev)
-+{
-+	int i;
-+
-+	for (i = 0; i < dev->addr_len; i++)
-+		mask[i] |= addr[i] ^ dev->dev_addr[i];
-+}
-+
-+static void __netdev_upper_mask(unsigned char *mask, struct net_device *dev,
-+				struct net_device *lower)
-+{
-+	struct net_device *cur;
-+	struct list_head *iter;
-+
-+	netdev_for_each_upper_dev_rcu(dev, cur, iter) {
-+		__netdev_addr_mask(mask, cur->dev_addr, lower);
-+		__netdev_upper_mask(mask, cur, lower);
-+	}
-+}
-+
-+static void __netdev_update_addr_mask(struct net_device *dev)
-+{
-+	unsigned char mask[MAX_ADDR_LEN];
-+	struct net_device *cur;
-+	struct list_head *iter;
-+
-+	memset(mask, 0, sizeof(mask));
-+	__netdev_upper_mask(mask, dev, dev);
-+	memcpy(dev->local_addr_mask, mask, dev->addr_len);
-+
-+	netdev_for_each_lower_dev(dev, cur, iter)
-+		__netdev_update_addr_mask(cur);
-+}
-+
-+static void netdev_update_addr_mask(struct net_device *dev)
-+{
-+	rcu_read_lock();
-+	__netdev_update_addr_mask(dev);
-+	rcu_read_unlock();
-+}
-+
- static int __netdev_upper_dev_link(struct net_device *dev,
- 				   struct net_device *upper_dev, bool master,
- 				   void *private)
-@@ -5163,6 +5208,7 @@ static int __netdev_upper_dev_link(struc
- 			goto rollback_lower_mesh;
- 	}
- 
-+	netdev_update_addr_mask(dev);
- 	call_netdevice_notifiers(NETDEV_CHANGEUPPER, dev);
- 	return 0;
- 
-@@ -5280,6 +5326,7 @@ void netdev_upper_dev_unlink(struct net_
- 	list_for_each_entry(i, &upper_dev->all_adj_list.upper, list)
- 		__netdev_adjacent_dev_unlink(dev, i->dev, i->ref_nr);
- 
-+	netdev_update_addr_mask(dev);
- 	call_netdevice_notifiers(NETDEV_CHANGEUPPER, dev);
- }
- EXPORT_SYMBOL(netdev_upper_dev_unlink);
-@@ -5799,6 +5846,7 @@ int dev_set_mac_address(struct net_devic
- 	if (err)
- 		return err;
- 	dev->addr_assign_type = NET_ADDR_SET;
-+	netdev_update_addr_mask(dev);
- 	call_netdevice_notifiers(NETDEV_CHANGEADDR, dev);
- 	add_device_randomness(dev->dev_addr, dev->addr_len);
- 	return 0;
---- a/include/linux/netdevice.h
-+++ b/include/linux/netdevice.h
-@@ -1556,6 +1556,8 @@ struct net_device {
- 	struct netdev_hw_addr_list	mc;
- 	struct netdev_hw_addr_list	dev_addrs;
- 
-+	unsigned char		local_addr_mask[MAX_ADDR_LEN];
-+
- #ifdef CONFIG_SYSFS
- 	struct kset		*queues_kset;
- #endif
---- a/include/linux/skbuff.h
-+++ b/include/linux/skbuff.h
-@@ -598,7 +598,8 @@ struct sk_buff {
- 	__u8			ipvs_property:1;
- 
- 	__u8			inner_protocol_type:1;
--	/* 4 or 6 bit hole */
-+	__u8			gro_skip:1;
-+	/* 3 or 5 bit hole */
- 
- #ifdef CONFIG_NET_SCHED
- 	__u16			tc_index;	/* traffic control index */
---- a/net/ethernet/eth.c
-+++ b/net/ethernet/eth.c
-@@ -172,6 +172,18 @@ u32 eth_get_headlen(void *data, unsigned
- }
- EXPORT_SYMBOL(eth_get_headlen);
- 
-+static inline bool
-+eth_check_local_mask(const void *addr1, const void *addr2, const void *mask)
-+{
-+	const u16 *a1 = addr1;
-+	const u16 *a2 = addr2;
-+	const u16 *m = mask;
-+
-+	return (((a1[0] ^ a2[0]) & ~m[0]) |
-+		((a1[1] ^ a2[1]) & ~m[1]) |
-+		((a1[2] ^ a2[2]) & ~m[2]));
-+}
-+
- /**
-  * eth_type_trans - determine the packet's protocol ID.
-  * @skb: received socket data
-@@ -199,8 +211,12 @@ __be16 eth_type_trans(struct sk_buff *sk
- 			skb->pkt_type = PACKET_MULTICAST;
- 	}
- 	else if (unlikely(!ether_addr_equal_64bits(eth->h_dest,
--						   dev->dev_addr)))
-+						   dev->dev_addr))) {
- 		skb->pkt_type = PACKET_OTHERHOST;
-+		if (eth_check_local_mask(eth->h_dest, dev->dev_addr,
-+					 dev->local_addr_mask))
-+			skb->gro_skip = 1;
-+	}
- 
- 	/*
- 	 * Some variants of DSA tagging don't have an ethertype field
--- a/target/linux/generic/pending-3.18/681-NET-add-of_get_mac_address_mtd.patch	2022-03-22 08:54:47.331464876 +0800
+++ b/target/linux/generic/pending-3.18/681-NET-add-of_get_mac_address_mtd.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,88 +0,0 @@
-From: John Crispin <blogic@openwrt.org>
-Date: Sun, 27 Jul 2014 09:40:01 +0100
-Subject: NET: add of_get_mac_address_mtd()
-
-Many embedded devices have information such as mac addresses stored inside mtd
-devices. This patch allows us to add a property inside a node describing a
-network interface. The new property points at a mtd partition with an offset
-where the mac address can be found.
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- drivers/of/of_net.c    |   37 +++++++++++++++++++++++++++++++++++++
- include/linux/of_net.h |    1 +
- 2 files changed, 38 insertions(+)
-
---- a/drivers/of/of_net.c
-+++ b/drivers/of/of_net.c
-@@ -10,6 +10,7 @@
- #include <linux/of_net.h>
- #include <linux/phy.h>
- #include <linux/export.h>
-+#include <linux/mtd/mtd.h>
- 
- /**
-  * of_get_phy_mode - Get phy mode for given device_node
-@@ -75,3 +76,45 @@ const void *of_get_mac_address(struct de
- 	return NULL;
- }
- EXPORT_SYMBOL(of_get_mac_address);
-+
-+#ifdef CONFIG_MTD
-+int of_get_mac_address_mtd(struct device_node *np, unsigned char *mac)
-+{
-+	struct device_node *mtd_np = NULL;
-+	size_t retlen;
-+	int size, ret;
-+	struct mtd_info *mtd;
-+	const char *part;
-+	const __be32 *list;
-+	phandle phandle;
-+	u32 mac_inc = 0;
-+
-+	list = of_get_property(np, "mtd-mac-address", &size);
-+	if (!list || (size != (2 * sizeof(*list))))
-+		return -ENOENT;
-+
-+	phandle = be32_to_cpup(list++);
-+	if (phandle)
-+		mtd_np = of_find_node_by_phandle(phandle);
-+
-+	if (!mtd_np)
-+		return -ENOENT;
-+
-+	part = of_get_property(mtd_np, "label", NULL);
-+	if (!part)
-+		part = mtd_np->name;
-+
-+	mtd = get_mtd_device_nm(part);
-+	if (IS_ERR(mtd))
-+		return PTR_ERR(mtd);
-+
-+	ret = mtd_read(mtd, be32_to_cpup(list), 6, &retlen, mac);
-+	put_mtd_device(mtd);
-+
-+	if (!of_property_read_u32(np, "mtd-mac-address-increment", &mac_inc))
-+		mac[5] += mac_inc;
-+
-+	return ret;
-+}
-+EXPORT_SYMBOL_GPL(of_get_mac_address_mtd);
-+#endif
---- a/include/linux/of_net.h
-+++ b/include/linux/of_net.h
-@@ -11,6 +11,14 @@
- #include <linux/of.h>
- extern int of_get_phy_mode(struct device_node *np);
- extern const void *of_get_mac_address(struct device_node *np);
-+#ifdef CONFIG_MTD
-+extern int of_get_mac_address_mtd(struct device_node *np, unsigned char *mac);
-+#else
-+static inline int of_get_mac_address_mtd(struct device_node *np, unsigned char *mac)
-+{
-+	return -ENOENT;
-+}
-+#endif
- #else
- static inline int of_get_phy_mode(struct device_node *np)
- {
--- a/target/linux/generic/pending-3.18/700-swconfig.patch	2022-03-22 08:54:47.331464876 +0800
+++ b/target/linux/generic/pending-3.18/700-swconfig.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,39 +0,0 @@
---- a/drivers/net/phy/Kconfig
-+++ b/drivers/net/phy/Kconfig
-@@ -12,6 +12,16 @@ menuconfig PHYLIB
- 
- if PHYLIB
- 
-+config SWCONFIG
-+	tristate "Switch configuration API"
-+	---help---
-+	  Switch configuration API using netlink. This allows
-+	  you to configure the VLAN features of certain switches.
-+
-+config SWCONFIG_LEDS
-+	bool "Switch LED trigger support"
-+	depends on (SWCONFIG && LEDS_TRIGGERS)
-+
- comment "MII PHY device drivers"
- 
- config AT803X_PHY
---- a/drivers/net/phy/Makefile
-+++ b/drivers/net/phy/Makefile
-@@ -3,6 +3,7 @@
- libphy-objs			:= phy.o phy_device.o mdio_bus.o
- 
- obj-$(CONFIG_PHYLIB)		+= libphy.o
-+obj-$(CONFIG_SWCONFIG)		+= swconfig.o
- obj-$(CONFIG_MARVELL_PHY)	+= marvell.o
- obj-$(CONFIG_DAVICOM_PHY)	+= davicom.o
- obj-$(CONFIG_CICADA_PHY)	+= cicada.o
---- a/include/uapi/linux/Kbuild
-+++ b/include/uapi/linux/Kbuild
-@@ -374,6 +374,7 @@ header-y += stddef.h
- header-y += string.h
- header-y += suspend_ioctls.h
- header-y += swab.h
-+header-y += switch.h
- header-y += synclink.h
- header-y += sysctl.h
- header-y += sysinfo.h
--- a/target/linux/generic/pending-3.18/701-phy_extension.patch	2022-03-22 08:54:47.331464876 +0800
+++ b/target/linux/generic/pending-3.18/701-phy_extension.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,63 +0,0 @@
---- a/drivers/net/phy/phy.c
-+++ b/drivers/net/phy/phy.c
-@@ -363,6 +363,50 @@ int phy_ethtool_gset(struct phy_device *
- }
- EXPORT_SYMBOL(phy_ethtool_gset);
- 
-+int phy_ethtool_ioctl(struct phy_device *phydev, void *useraddr)
-+{
-+	u32 cmd;
-+	int tmp;
-+	struct ethtool_cmd ecmd = { ETHTOOL_GSET };
-+	struct ethtool_value edata = { ETHTOOL_GLINK };
-+
-+	if (get_user(cmd, (u32 *) useraddr))
-+		return -EFAULT;
-+
-+	switch (cmd) {
-+	case ETHTOOL_GSET:
-+		phy_ethtool_gset(phydev, &ecmd);
-+		if (copy_to_user(useraddr, &ecmd, sizeof(ecmd)))
-+			return -EFAULT;
-+		return 0;
-+
-+	case ETHTOOL_SSET:
-+		if (copy_from_user(&ecmd, useraddr, sizeof(ecmd)))
-+			return -EFAULT;
-+		return phy_ethtool_sset(phydev, &ecmd);
-+
-+	case ETHTOOL_NWAY_RST:
-+		/* if autoneg is off, it's an error */
-+		tmp = phy_read(phydev, MII_BMCR);
-+		if (tmp & BMCR_ANENABLE) {
-+			tmp |= (BMCR_ANRESTART);
-+			phy_write(phydev, MII_BMCR, tmp);
-+			return 0;
-+		}
-+		return -EINVAL;
-+
-+	case ETHTOOL_GLINK:
-+		edata.data = (phy_read(phydev,
-+				MII_BMSR) & BMSR_LSTATUS) ? 1 : 0;
-+		if (copy_to_user(useraddr, &edata, sizeof(edata)))
-+			return -EFAULT;
-+		return 0;
-+	}
-+
-+	return -EOPNOTSUPP;
-+}
-+EXPORT_SYMBOL(phy_ethtool_ioctl);
-+
- /**
-  * phy_mii_ioctl - generic PHY MII ioctl interface
-  * @phydev: the phy_device struct
---- a/include/linux/phy.h
-+++ b/include/linux/phy.h
-@@ -759,6 +759,7 @@ void phy_start_machine(struct phy_device
- void phy_stop_machine(struct phy_device *phydev);
- int phy_ethtool_sset(struct phy_device *phydev, struct ethtool_cmd *cmd);
- int phy_ethtool_gset(struct phy_device *phydev, struct ethtool_cmd *cmd);
-+int phy_ethtool_ioctl(struct phy_device *phydev, void *useraddr);
- int phy_mii_ioctl(struct phy_device *phydev, struct ifreq *ifr, int cmd);
- int phy_start_interrupts(struct phy_device *phydev);
- void phy_print_status(struct phy_device *phydev);
--- a/target/linux/generic/pending-3.18/702-phy_add_aneg_done_function.patch	2022-03-22 08:54:47.332464878 +0800
+++ b/target/linux/generic/pending-3.18/702-phy_add_aneg_done_function.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,27 +0,0 @@
---- a/include/linux/phy.h
-+++ b/include/linux/phy.h
-@@ -480,6 +480,12 @@ struct phy_driver {
- 	/* Determines the negotiated speed and duplex */
- 	int (*read_status)(struct phy_device *phydev);
- 
-+	/* 
-+	 * Update the value in phydev->link to reflect the 
-+	 * current link value
-+	 */
-+	int (*update_link)(struct phy_device *phydev);
-+
- 	/* Clears any pending interrupts */
- 	int (*ack_interrupt)(struct phy_device *phydev);
- 
---- a/drivers/net/phy/phy_device.c
-+++ b/drivers/net/phy/phy_device.c
-@@ -915,6 +915,9 @@ int genphy_update_link(struct phy_device
- {
- 	int status;
- 
-+	if (phydev->drv && phydev->drv->update_link)
-+		return phydev->drv->update_link(phydev);
-+
- 	/* Do a fake read */
- 	status = phy_read(phydev, MII_BMSR);
- 	if (status < 0)
--- a/target/linux/generic/pending-3.18/703-phy-add-detach-callback-to-struct-phy_driver.patch	2022-03-22 08:54:47.332464878 +0800
+++ b/target/linux/generic/pending-3.18/703-phy-add-detach-callback-to-struct-phy_driver.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,27 +0,0 @@
---- a/drivers/net/phy/phy_device.c
-+++ b/drivers/net/phy/phy_device.c
-@@ -674,6 +674,9 @@ void phy_detach(struct phy_device *phyde
- {
- 	int i;
- 
-+	if (phydev->drv && phydev->drv->detach)
-+		phydev->drv->detach(phydev);
-+
- 	if (phydev->bus->dev.driver)
- 		module_put(phydev->bus->dev.driver->owner);
- 
---- a/include/linux/phy.h
-+++ b/include/linux/phy.h
-@@ -498,6 +498,12 @@ struct phy_driver {
- 	 */
- 	int (*did_interrupt)(struct phy_device *phydev);
- 
-+	/*
-+	 * Called before an ethernet device is detached
-+	 * from the PHY.
-+	 */
-+	void (*detach)(struct phy_device *phydev);
-+
- 	/* Clears up any memory if needed */
- 	void (*remove)(struct phy_device *phydev);
- 
--- a/target/linux/generic/pending-3.18/710-phy-add-mdio_register_board_info.patch	2022-03-22 08:54:47.332464878 +0800
+++ b/target/linux/generic/pending-3.18/710-phy-add-mdio_register_board_info.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,192 +0,0 @@
---- a/drivers/net/phy/mdio_bus.c
-+++ b/drivers/net/phy/mdio_bus.c
-@@ -38,6 +38,8 @@
- 
- #include <asm/irq.h>
- 
-+#include "mdio-boardinfo.h"
-+
- /**
-  * mdiobus_alloc_size - allocate a mii_bus structure
-  * @size: extra amount of memory to allocate for private storage.
-@@ -335,9 +337,21 @@ void mdiobus_free(struct mii_bus *bus)
- }
- EXPORT_SYMBOL(mdiobus_free);
- 
-+static void mdiobus_setup_phydev_from_boardinfo(struct mii_bus *bus,
-+						struct phy_device *phydev,
-+						struct mdio_board_info *bi)
-+{
-+	if (strcmp(bus->id, bi->bus_id) ||
-+	    bi->phy_addr != phydev->addr)
-+	    return;
-+
-+	phydev->dev.platform_data = (void *) bi->platform_data;
-+}
-+
- struct phy_device *mdiobus_scan(struct mii_bus *bus, int addr)
- {
- 	struct phy_device *phydev;
-+	struct mdio_board_entry *be;
- 	int err;
- 
- 	phydev = get_phy_device(bus, addr, false);
-@@ -350,6 +364,12 @@ struct phy_device *mdiobus_scan(struct m
- 	 */
- 	of_mdiobus_link_phydev(bus, phydev);
- 
-+	mutex_lock(&__mdio_board_lock);
-+	list_for_each_entry(be, &__mdio_board_list, list)
-+		mdiobus_setup_phydev_from_boardinfo(bus, phydev,
-+						    &be->board_info);
-+	mutex_unlock(&__mdio_board_lock);
-+
- 	err = phy_device_register(phydev);
- 	if (err) {
- 		phy_device_free(phydev);
---- a/include/linux/phy.h
-+++ b/include/linux/phy.h
-@@ -796,4 +796,22 @@ int __init mdio_bus_init(void);
- void mdio_bus_exit(void);
- 
- extern struct bus_type mdio_bus_type;
-+
-+struct mdio_board_info {
-+	const char	*bus_id;
-+	int		phy_addr;
-+
-+	const void	*platform_data;
-+};
-+
-+#ifdef CONFIG_MDIO_BOARDINFO
-+int mdiobus_register_board_info(const struct mdio_board_info *info, unsigned n);
-+#else
-+static inline int
-+mdiobus_register_board_info(const struct mdio_board_info *info, unsigned n)
-+{
-+	return 0;
-+}
-+#endif
-+
- #endif /* __PHY_H */
---- a/drivers/net/phy/Kconfig
-+++ b/drivers/net/phy/Kconfig
-@@ -12,6 +12,10 @@ menuconfig PHYLIB
- 
- if PHYLIB
- 
-+config MDIO_BOARDINFO
-+	bool
-+	default y
-+
- config SWCONFIG
- 	tristate "Switch configuration API"
- 	---help---
---- a/drivers/net/phy/Makefile
-+++ b/drivers/net/phy/Makefile
-@@ -2,6 +2,8 @@
- 
- libphy-objs			:= phy.o phy_device.o mdio_bus.o
- 
-+obj-$(CONFIG_MDIO_BOARDINFO)	+= mdio-boardinfo.o
-+
- obj-$(CONFIG_PHYLIB)		+= libphy.o
- obj-$(CONFIG_SWCONFIG)		+= swconfig.o
- obj-$(CONFIG_MARVELL_PHY)	+= marvell.o
---- /dev/null
-+++ b/drivers/net/phy/mdio-boardinfo.c
-@@ -0,0 +1,58 @@
-+/*
-+ * mdio-boardinfo.c - collect pre-declarations of PHY devices
-+ *
-+ * This program is free software; you can redistribute  it and/or modify it
-+ * under  the terms of  the GNU General  Public License as published by the
-+ * Free Software Foundation;  either version 2 of the  License, or (at your
-+ * option) any later version.
-+ *
-+ */
-+
-+#include <linux/kernel.h>
-+#include <linux/phy.h>
-+#include <linux/slab.h>
-+#include <linux/export.h>
-+#include <linux/mutex.h>
-+#include <linux/phy.h>
-+
-+#include "mdio-boardinfo.h"
-+
-+/*
-+ * These symbols are exported ONLY FOR the mdio_bus component.
-+ * No other users will be supported.
-+ */
-+
-+LIST_HEAD(__mdio_board_list);
-+EXPORT_SYMBOL_GPL(__mdio_board_list);
-+
-+DEFINE_MUTEX(__mdio_board_lock);
-+EXPORT_SYMBOL_GPL(__mdio_board_lock);
-+
-+/**
-+ * mdio_register_board_info - register PHY devices for a given board
-+ * @info: array of chip descriptors
-+ * @n: how many descriptors are provided
-+ * Context: can sleep
-+ *
-+ * The board info passed can safely be __initdata ... but be careful of
-+ * any embedded pointers (platform_data, etc), they're copied as-is.
-+ */
-+int __init
-+mdiobus_register_board_info(struct mdio_board_info const *info, unsigned n)
-+{
-+	struct mdio_board_entry *be;
-+	int i;
-+
-+	be = kzalloc(n * sizeof(*be), GFP_KERNEL);
-+	if (!be)
-+		return -ENOMEM;
-+
-+	for (i = 0; i < n; i++, be++, info++) {
-+		memcpy(&be->board_info, info, sizeof(*info));
-+		mutex_lock(&__mdio_board_lock);
-+		list_add_tail(&be->list, &__mdio_board_list);
-+		mutex_unlock(&__mdio_board_lock);
-+	}
-+
-+	return 0;
-+}
---- /dev/null
-+++ b/drivers/net/phy/mdio-boardinfo.h
-@@ -0,0 +1,22 @@
-+/*
-+ * mdio-boardinfo.h - boardinfo interface internal to the mdio_bus component
-+ *
-+ * This program is free software; you can redistribute  it and/or modify it
-+ * under  the terms of  the GNU General  Public License as published by the
-+ * Free Software Foundation;  either version 2 of the  License, or (at your
-+ * option) any later version.
-+ *
-+ */
-+
-+#include <linux/mutex.h>
-+
-+struct mdio_board_entry {
-+	struct list_head	list;
-+	struct mdio_board_info	board_info;
-+};
-+
-+/* __mdio_board_lock protects __mdio_board_list
-+ * only mdio_bus components are allowed to use these symbols.
-+ */
-+extern struct mutex __mdio_board_lock;
-+extern struct list_head __mdio_board_list;
---- a/drivers/net/Makefile
-+++ b/drivers/net/Makefile
-@@ -15,7 +15,7 @@ obj-$(CONFIG_MII) += mii.o
- obj-$(CONFIG_MDIO) += mdio.o
- obj-$(CONFIG_NET) += Space.o loopback.o
- obj-$(CONFIG_NETCONSOLE) += netconsole.o
--obj-$(CONFIG_PHYLIB) += phy/
-+obj-y += phy/
- obj-$(CONFIG_RIONET) += rionet.o
- obj-$(CONFIG_NET_TEAM) += team/
- obj-$(CONFIG_TUN) += tun.o
--- a/target/linux/generic/pending-3.18/720-phy_adm6996.patch	2022-03-22 08:54:47.333464879 +0800
+++ b/target/linux/generic/pending-3.18/720-phy_adm6996.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,26 +0,0 @@
---- a/drivers/net/phy/Kconfig
-+++ b/drivers/net/phy/Kconfig
-@@ -132,6 +132,13 @@ config MICREL_PHY
- 	---help---
- 	  Supports the KSZ9021, VSC8201, KS8001 PHYs.
- 
-+config ADM6996_PHY
-+	tristate "Driver for ADM6996 switches"
-+	select SWCONFIG
-+	---help---
-+	  Currently supports the ADM6996FC and ADM6996M switches.
-+	  Support for FC is very limited.
-+
- config FIXED_PHY
- 	bool "Driver for MDIO Bus/PHY emulation with fixed speed/link PHYs"
- 	depends on PHYLIB=y
---- a/drivers/net/phy/Makefile
-+++ b/drivers/net/phy/Makefile
-@@ -18,6 +18,7 @@ obj-$(CONFIG_BCM63XX_PHY)	+= bcm63xx.o
- obj-$(CONFIG_BCM7XXX_PHY)	+= bcm7xxx.o
- obj-$(CONFIG_BCM87XX_PHY)	+= bcm87xx.o
- obj-$(CONFIG_ICPLUS_PHY)	+= icplus.o
-+obj-$(CONFIG_ADM6996_PHY)	+= adm6996.o
- obj-$(CONFIG_REALTEK_PHY)	+= realtek.o
- obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
- obj-$(CONFIG_FIXED_PHY)		+= fixed.o
--- a/target/linux/generic/pending-3.18/721-phy_packets.patch	2022-03-22 08:54:47.333464879 +0800
+++ b/target/linux/generic/pending-3.18/721-phy_packets.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,161 +0,0 @@
---- a/include/linux/netdevice.h
-+++ b/include/linux/netdevice.h
-@@ -1228,6 +1228,7 @@ enum netdev_priv_flags {
- 	IFF_LIVE_ADDR_CHANGE		= 1<<20,
- 	IFF_MACVLAN			= 1<<21,
- 	IFF_XMIT_DST_RELEASE_PERM	= 1<<22,
-+	IFF_NO_IP_ALIGN			= 1<<23,
- };
- 
- #define IFF_802_1Q_VLAN			IFF_802_1Q_VLAN
-@@ -1253,6 +1254,7 @@ enum netdev_priv_flags {
- #define IFF_LIVE_ADDR_CHANGE		IFF_LIVE_ADDR_CHANGE
- #define IFF_MACVLAN			IFF_MACVLAN
- #define IFF_XMIT_DST_RELEASE_PERM	IFF_XMIT_DST_RELEASE_PERM
-+#define IFF_NO_IP_ALIGN		IFF_NO_IP_ALIGN
- 
- /**
-  *	struct net_device - The DEVICE structure.
-@@ -1523,6 +1525,11 @@ struct net_device {
- 	const struct ethtool_ops *ethtool_ops;
- 	const struct forwarding_accel_ops *fwd_ops;
- 
-+#ifdef CONFIG_ETHERNET_PACKET_MANGLE
-+	void (*eth_mangle_rx)(struct net_device *dev, struct sk_buff *skb);
-+	struct sk_buff *(*eth_mangle_tx)(struct net_device *dev, struct sk_buff *skb);
-+#endif
-+
- 	const struct header_ops *header_ops;
- 
- 	unsigned int		flags;
-@@ -1587,6 +1594,10 @@ struct net_device {
- 	void			*ax25_ptr;
- 	struct wireless_dev	*ieee80211_ptr;
- 
-+#ifdef CONFIG_ETHERNET_PACKET_MANGLE
-+	void			*phy_ptr; /* PHY device specific data */
-+#endif
-+
- /*
-  * Cache lines mostly used on receive path (including eth_type_trans())
-  */
---- a/include/linux/skbuff.h
-+++ b/include/linux/skbuff.h
-@@ -2055,6 +2055,10 @@ static inline int pskb_trim(struct sk_bu
- 	return (len < skb->len) ? __pskb_trim(skb, len) : 0;
- }
- 
-+extern struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
-+		unsigned int length, gfp_t gfp);
-+
-+
- /**
-  *	pskb_trim_unique - remove end from a paged unique (not cloned) buffer
-  *	@skb: buffer to alter
-@@ -2181,16 +2185,6 @@ static inline struct sk_buff *dev_alloc_
- }
- 
- 
--static inline struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
--		unsigned int length, gfp_t gfp)
--{
--	struct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);
--
--	if (NET_IP_ALIGN && skb)
--		skb_reserve(skb, NET_IP_ALIGN);
--	return skb;
--}
--
- static inline struct sk_buff *netdev_alloc_skb_ip_align(struct net_device *dev,
- 		unsigned int length)
- {
---- a/net/Kconfig
-+++ b/net/Kconfig
-@@ -25,6 +25,12 @@ menuconfig NET
- 
- if NET
- 
-+config ETHERNET_PACKET_MANGLE
-+	bool
-+	help
-+	  This option can be selected by phy drivers that need to mangle
-+	  packets going in or out of an ethernet device.
-+
- config WANT_COMPAT_NETLINK_MESSAGES
- 	bool
- 	help
---- a/net/core/dev.c
-+++ b/net/core/dev.c
-@@ -2637,10 +2637,20 @@ static int xmit_one(struct sk_buff *skb,
- 	if (!list_empty(&ptype_all))
- 		dev_queue_xmit_nit(skb, dev);
- 
--	len = skb->len;
--	trace_net_dev_start_xmit(skb, dev);
--	rc = netdev_start_xmit(skb, dev, txq, more);
--	trace_net_dev_xmit(skb, rc, dev, len);
-+#ifdef CONFIG_ETHERNET_PACKET_MANGLE
-+	if (!dev->eth_mangle_tx ||
-+	    (skb = dev->eth_mangle_tx(dev, skb)) != NULL)
-+#else
-+	if (1)
-+#endif
-+	{
-+		len = skb->len;
-+		trace_net_dev_start_xmit(skb, dev);
-+		rc = netdev_start_xmit(skb, dev, txq, more);
-+		trace_net_dev_xmit(skb, rc, dev, len);
-+	} else {
-+		rc = NETDEV_TX_OK;
-+	}
- 
- 	return rc;
- }
---- a/net/core/skbuff.c
-+++ b/net/core/skbuff.c
-@@ -63,6 +63,7 @@
- #include <linux/errqueue.h>
- #include <linux/prefetch.h>
- #include <linux/if_vlan.h>
-+#include <linux/if.h>
- 
- #include <net/protocol.h>
- #include <net/dst.h>
-@@ -471,6 +472,22 @@ struct sk_buff *__netdev_alloc_skb(struc
- }
- EXPORT_SYMBOL(__netdev_alloc_skb);
- 
-+struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
-+		unsigned int length, gfp_t gfp)
-+{
-+	struct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);
-+
-+#ifdef CONFIG_ETHERNET_PACKET_MANGLE
-+	if (dev && (dev->priv_flags & IFF_NO_IP_ALIGN))
-+		return skb;
-+#endif
-+
-+	if (NET_IP_ALIGN && skb)
-+		skb_reserve(skb, NET_IP_ALIGN);
-+	return skb;
-+}
-+EXPORT_SYMBOL(__netdev_alloc_skb_ip_align);
-+
- void skb_add_rx_frag(struct sk_buff *skb, int i, struct page *page, int off,
- 		     int size, unsigned int truesize)
- {
---- a/net/ethernet/eth.c
-+++ b/net/ethernet/eth.c
-@@ -200,6 +200,12 @@ __be16 eth_type_trans(struct sk_buff *sk
- 	const struct ethhdr *eth;
- 
- 	skb->dev = dev;
-+
-+#ifdef CONFIG_ETHERNET_PACKET_MANGLE
-+	if (dev->eth_mangle_rx)
-+		dev->eth_mangle_rx(dev, skb);
-+#endif
-+
- 	skb_reset_mac_header(skb);
- 	skb_pull_inline(skb, ETH_HLEN);
- 	eth = eth_hdr(skb);
--- a/target/linux/generic/pending-3.18/722-phy_mvswitch.patch	2022-03-22 08:54:47.333464879 +0800
+++ b/target/linux/generic/pending-3.18/722-phy_mvswitch.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,23 +0,0 @@
---- a/drivers/net/phy/Kconfig
-+++ b/drivers/net/phy/Kconfig
-@@ -139,6 +139,10 @@ config ADM6996_PHY
- 	  Currently supports the ADM6996FC and ADM6996M switches.
- 	  Support for FC is very limited.
- 
-+config MVSWITCH_PHY
-+	tristate "Driver for Marvell 88E6060 switches"
-+	select ETHERNET_PACKET_MANGLE
-+
- config FIXED_PHY
- 	bool "Driver for MDIO Bus/PHY emulation with fixed speed/link PHYs"
- 	depends on PHYLIB=y
---- a/drivers/net/phy/Makefile
-+++ b/drivers/net/phy/Makefile
-@@ -19,6 +19,7 @@ obj-$(CONFIG_BCM7XXX_PHY)	+= bcm7xxx.o
- obj-$(CONFIG_BCM87XX_PHY)	+= bcm87xx.o
- obj-$(CONFIG_ICPLUS_PHY)	+= icplus.o
- obj-$(CONFIG_ADM6996_PHY)	+= adm6996.o
-+obj-$(CONFIG_MVSWITCH_PHY)	+= mvswitch.o
- obj-$(CONFIG_REALTEK_PHY)	+= realtek.o
- obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
- obj-$(CONFIG_FIXED_PHY)		+= fixed.o
--- a/target/linux/generic/pending-3.18/723-phy_ip175c.patch	2022-03-22 08:54:47.334464881 +0800
+++ b/target/linux/generic/pending-3.18/723-phy_ip175c.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,23 +0,0 @@
---- a/drivers/net/phy/Kconfig
-+++ b/drivers/net/phy/Kconfig
-@@ -143,6 +143,10 @@ config MVSWITCH_PHY
- 	tristate "Driver for Marvell 88E6060 switches"
- 	select ETHERNET_PACKET_MANGLE
- 
-+config IP17XX_PHY
-+	tristate "Driver for IC+ IP17xx switches"
-+	select SWCONFIG
-+
- config FIXED_PHY
- 	bool "Driver for MDIO Bus/PHY emulation with fixed speed/link PHYs"
- 	depends on PHYLIB=y
---- a/drivers/net/phy/Makefile
-+++ b/drivers/net/phy/Makefile
-@@ -20,6 +20,7 @@ obj-$(CONFIG_BCM87XX_PHY)	+= bcm87xx.o
- obj-$(CONFIG_ICPLUS_PHY)	+= icplus.o
- obj-$(CONFIG_ADM6996_PHY)	+= adm6996.o
- obj-$(CONFIG_MVSWITCH_PHY)	+= mvswitch.o
-+obj-$(CONFIG_IP17XX_PHY)	+= ip17xx.o
- obj-$(CONFIG_REALTEK_PHY)	+= realtek.o
- obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
- obj-$(CONFIG_FIXED_PHY)		+= fixed.o
--- a/target/linux/generic/pending-3.18/724-phy_ar8216.patch	2022-03-22 08:54:47.334464881 +0800
+++ b/target/linux/generic/pending-3.18/724-phy_ar8216.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,24 +0,0 @@
---- a/drivers/net/phy/Kconfig
-+++ b/drivers/net/phy/Kconfig
-@@ -147,6 +147,11 @@ config IP17XX_PHY
- 	tristate "Driver for IC+ IP17xx switches"
- 	select SWCONFIG
- 
-+config AR8216_PHY
-+	tristate "Driver for Atheros AR8216 switches"
-+	select ETHERNET_PACKET_MANGLE
-+	select SWCONFIG
-+
- config FIXED_PHY
- 	bool "Driver for MDIO Bus/PHY emulation with fixed speed/link PHYs"
- 	depends on PHYLIB=y
---- a/drivers/net/phy/Makefile
-+++ b/drivers/net/phy/Makefile
-@@ -22,6 +22,7 @@ obj-$(CONFIG_ADM6996_PHY)	+= adm6996.o
- obj-$(CONFIG_MVSWITCH_PHY)	+= mvswitch.o
- obj-$(CONFIG_IP17XX_PHY)	+= ip17xx.o
- obj-$(CONFIG_REALTEK_PHY)	+= realtek.o
-+obj-$(CONFIG_AR8216_PHY)	+= ar8216.o ar8327.o
- obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
- obj-$(CONFIG_FIXED_PHY)		+= fixed.o
- obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
--- a/target/linux/generic/pending-3.18/725-phy_rtl8306.patch	2022-03-22 08:54:47.334464881 +0800
+++ b/target/linux/generic/pending-3.18/725-phy_rtl8306.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,23 +0,0 @@
---- a/drivers/net/phy/Kconfig
-+++ b/drivers/net/phy/Kconfig
-@@ -152,6 +152,10 @@ config AR8216_PHY
- 	select ETHERNET_PACKET_MANGLE
- 	select SWCONFIG
- 
-+config RTL8306_PHY
-+	tristate "Driver for Realtek RTL8306S switches"
-+	select SWCONFIG
-+
- config FIXED_PHY
- 	bool "Driver for MDIO Bus/PHY emulation with fixed speed/link PHYs"
- 	depends on PHYLIB=y
---- a/drivers/net/phy/Makefile
-+++ b/drivers/net/phy/Makefile
-@@ -23,6 +23,7 @@ obj-$(CONFIG_MVSWITCH_PHY)	+= mvswitch.o
- obj-$(CONFIG_IP17XX_PHY)	+= ip17xx.o
- obj-$(CONFIG_REALTEK_PHY)	+= realtek.o
- obj-$(CONFIG_AR8216_PHY)	+= ar8216.o ar8327.o
-+obj-$(CONFIG_RTL8306_PHY)	+= rtl8306.o
- obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
- obj-$(CONFIG_FIXED_PHY)		+= fixed.o
- obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
--- a/target/linux/generic/pending-3.18/726-phy_rtl8366.patch	2022-03-22 08:54:47.335464883 +0800
+++ b/target/linux/generic/pending-3.18/726-phy_rtl8366.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,45 +0,0 @@
---- a/drivers/net/phy/Kconfig
-+++ b/drivers/net/phy/Kconfig
-@@ -250,6 +250,30 @@ config MDIO_BCM_UNIMAC
- 	  controllers as well as some Broadcom Ethernet switches such as the
- 	  Starfighter 2 switches.
- 
-+config RTL8366_SMI
-+	tristate "Driver for the RTL8366 SMI interface"
-+	depends on GPIOLIB
-+	---help---
-+	  This module implements the SMI interface protocol which is used
-+	  by some RTL8366 ethernet switch devices via the generic GPIO API.
-+
-+if RTL8366_SMI
-+
-+config RTL8366_SMI_DEBUG_FS
-+	bool "RTL8366 SMI interface debugfs support"
-+        depends on DEBUG_FS
-+        default n
-+
-+config RTL8366S_PHY
-+	tristate "Driver for the Realtek RTL8366S switch"
-+	select SWCONFIG
-+
-+config RTL8366RB_PHY
-+	tristate "Driver for the Realtek RTL8366RB switch"
-+	select SWCONFIG
-+
-+endif # RTL8366_SMI
-+
- endif # PHYLIB
- 
- config MICREL_KS8995MA
---- a/drivers/net/phy/Makefile
-+++ b/drivers/net/phy/Makefile
-@@ -24,6 +24,9 @@ obj-$(CONFIG_IP17XX_PHY)	+= ip17xx.o
- obj-$(CONFIG_REALTEK_PHY)	+= realtek.o
- obj-$(CONFIG_AR8216_PHY)	+= ar8216.o ar8327.o
- obj-$(CONFIG_RTL8306_PHY)	+= rtl8306.o
-+obj-$(CONFIG_RTL8366_SMI)	+= rtl8366_smi.o
-+obj-$(CONFIG_RTL8366S_PHY)	+= rtl8366s.o
-+obj-$(CONFIG_RTL8366RB_PHY)	+= rtl8366rb.o
- obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
- obj-$(CONFIG_FIXED_PHY)		+= fixed.o
- obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
--- a/target/linux/generic/pending-3.18/727-phy-rtl8367.patch	2022-03-22 08:54:47.335464883 +0800
+++ b/target/linux/generic/pending-3.18/727-phy-rtl8367.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,23 +0,0 @@
---- a/drivers/net/phy/Kconfig
-+++ b/drivers/net/phy/Kconfig
-@@ -272,6 +272,10 @@ config RTL8366RB_PHY
- 	tristate "Driver for the Realtek RTL8366RB switch"
- 	select SWCONFIG
- 
-+config RTL8367_PHY
-+	tristate "Driver for the Realtek RTL8367R/M switches"
-+	select SWCONFIG
-+
- endif # RTL8366_SMI
- 
- endif # PHYLIB
---- a/drivers/net/phy/Makefile
-+++ b/drivers/net/phy/Makefile
-@@ -27,6 +27,7 @@ obj-$(CONFIG_RTL8306_PHY)	+= rtl8306.o
- obj-$(CONFIG_RTL8366_SMI)	+= rtl8366_smi.o
- obj-$(CONFIG_RTL8366S_PHY)	+= rtl8366s.o
- obj-$(CONFIG_RTL8366RB_PHY)	+= rtl8366rb.o
-+obj-$(CONFIG_RTL8367_PHY)	+= rtl8367.o
- obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
- obj-$(CONFIG_FIXED_PHY)		+= fixed.o
- obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
--- a/target/linux/generic/pending-3.18/728-phy-rtl8367b.patch	2022-03-22 08:54:47.335464883 +0800
+++ b/target/linux/generic/pending-3.18/728-phy-rtl8367b.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,23 +0,0 @@
---- a/drivers/net/phy/Kconfig
-+++ b/drivers/net/phy/Kconfig
-@@ -276,6 +276,10 @@ config RTL8367_PHY
- 	tristate "Driver for the Realtek RTL8367R/M switches"
- 	select SWCONFIG
- 
-+config RTL8367B_PHY
-+	tristate "Driver fot the Realtek RTL8367R-VB switch"
-+	select SWCONFIG
-+
- endif # RTL8366_SMI
- 
- endif # PHYLIB
---- a/drivers/net/phy/Makefile
-+++ b/drivers/net/phy/Makefile
-@@ -28,6 +28,7 @@ obj-$(CONFIG_RTL8366_SMI)	+= rtl8366_smi
- obj-$(CONFIG_RTL8366S_PHY)	+= rtl8366s.o
- obj-$(CONFIG_RTL8366RB_PHY)	+= rtl8366rb.o
- obj-$(CONFIG_RTL8367_PHY)	+= rtl8367.o
-+obj-$(CONFIG_RTL8367B_PHY)	+= rtl8367b.o
- obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
- obj-$(CONFIG_FIXED_PHY)		+= fixed.o
- obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
--- a/target/linux/generic/pending-3.18/729-phy-tantos.patch	2022-03-22 08:54:47.335464883 +0800
+++ b/target/linux/generic/pending-3.18/729-phy-tantos.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,21 +0,0 @@
---- a/drivers/net/phy/Kconfig
-+++ b/drivers/net/phy/Kconfig
-@@ -287,3 +287,8 @@ endif # PHYLIB
- config MICREL_KS8995MA
- 	tristate "Micrel KS8995MA 5-ports 10/100 managed Ethernet switch"
- 	depends on SPI
-+
-+config PSB6970_PHY
-+	tristate "Lantiq XWAY Tantos (PSB6970) Ethernet switch"
-+	select SWCONFIG
-+	select ETHERNET_PACKET_MANGLE
---- a/drivers/net/phy/Makefile
-+++ b/drivers/net/phy/Makefile
-@@ -30,6 +30,7 @@ obj-$(CONFIG_RTL8366RB_PHY)	+= rtl8366rb
- obj-$(CONFIG_RTL8367_PHY)	+= rtl8367.o
- obj-$(CONFIG_RTL8367B_PHY)	+= rtl8367b.o
- obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
-+obj-$(CONFIG_PSB6970_PHY)	+= psb6970.o
- obj-$(CONFIG_FIXED_PHY)		+= fixed.o
- obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
- obj-$(CONFIG_MDIO_GPIO)		+= mdio-gpio.o
--- a/target/linux/generic/pending-3.18/730-phy_b53.patch	2022-03-22 08:54:47.336464884 +0800
+++ b/target/linux/generic/pending-3.18/730-phy_b53.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,60 +0,0 @@
---- a/drivers/net/phy/Kconfig
-+++ b/drivers/net/phy/Kconfig
-@@ -282,6 +282,8 @@ config RTL8367B_PHY
- 
- endif # RTL8366_SMI
- 
-+source "drivers/net/phy/b53/Kconfig"
-+
- endif # PHYLIB
- 
- config MICREL_KS8995MA
---- a/drivers/net/phy/Makefile
-+++ b/drivers/net/phy/Makefile
-@@ -31,6 +31,7 @@ obj-$(CONFIG_RTL8367_PHY)	+= rtl8367.o
- obj-$(CONFIG_RTL8367B_PHY)	+= rtl8367b.o
- obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
- obj-$(CONFIG_PSB6970_PHY)	+= psb6970.o
-+obj-$(CONFIG_SWCONFIG_B53)	+= b53/
- obj-$(CONFIG_FIXED_PHY)		+= fixed.o
- obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
- obj-$(CONFIG_MDIO_GPIO)		+= mdio-gpio.o
---- /dev/null
-+++ b/linux/platform_data/b53.h
-@@ -0,0 +1,36 @@
-+/*
-+ * B53 platform data
-+ *
-+ * Copyright (C) 2013 Jonas Gorski <jogo@openwrt.org>
-+ *
-+ * Permission to use, copy, modify, and/or distribute this software for any
-+ * purpose with or without fee is hereby granted, provided that the above
-+ * copyright notice and this permission notice appear in all copies.
-+ *
-+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
-+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
-+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
-+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
-+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-+ */
-+
-+#ifndef __B53_H
-+#define __B53_H
-+
-+#include <linux/kernel.h>
-+
-+struct b53_platform_data {
-+	u32 chip_id;
-+	u16 enabled_ports;
-+
-+	/* allow to specify an ethX alias */
-+	const char *alias;
-+
-+	/* only used by MMAP'd driver */
-+	unsigned big_endian:1;
-+	void __iomem *regs;
-+};
-+
-+#endif
--- a/target/linux/generic/pending-3.18/732-phy-ar8216-led-support.patch	2022-03-22 08:54:47.336464884 +0800
+++ b/target/linux/generic/pending-3.18/732-phy-ar8216-led-support.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,13 +0,0 @@
---- a/drivers/net/phy/Kconfig
-+++ b/drivers/net/phy/Kconfig
-@@ -152,6 +152,10 @@ config AR8216_PHY
- 	select ETHERNET_PACKET_MANGLE
- 	select SWCONFIG
- 
-+config AR8216_PHY_LEDS
-+	bool "Atheros AR8216 switch LED support"
-+	depends on (AR8216_PHY && LEDS_CLASS)
-+
- config RTL8306_PHY
- 	tristate "Driver for Realtek RTL8306S switches"
- 	select SWCONFIG
--- a/target/linux/generic/pending-3.18/733-phy_mvsw61xx.patch	2022-03-22 08:54:47.336464884 +0800
+++ b/target/linux/generic/pending-3.18/733-phy_mvsw61xx.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,23 +0,0 @@
---- a/drivers/net/phy/Kconfig
-+++ b/drivers/net/phy/Kconfig
-@@ -143,6 +143,10 @@ config MVSWITCH_PHY
- 	tristate "Driver for Marvell 88E6060 switches"
- 	select ETHERNET_PACKET_MANGLE
- 
-+config MVSW61XX_PHY
-+	tristate "Driver for Marvell 88E6171/6172 switches"
-+	select SWCONFIG
-+
- config IP17XX_PHY
- 	tristate "Driver for IC+ IP17xx switches"
- 	select SWCONFIG
---- a/drivers/net/phy/Makefile
-+++ b/drivers/net/phy/Makefile
-@@ -20,6 +20,7 @@ obj-$(CONFIG_BCM87XX_PHY)	+= bcm87xx.o
- obj-$(CONFIG_ICPLUS_PHY)	+= icplus.o
- obj-$(CONFIG_ADM6996_PHY)	+= adm6996.o
- obj-$(CONFIG_MVSWITCH_PHY)	+= mvswitch.o
-+obj-$(CONFIG_MVSW61XX_PHY)	+= mvsw61xx.o
- obj-$(CONFIG_IP17XX_PHY)	+= ip17xx.o
- obj-$(CONFIG_REALTEK_PHY)	+= realtek.o
- obj-$(CONFIG_AR8216_PHY)	+= ar8216.o ar8327.o
--- a/target/linux/generic/pending-3.18/734-net-phy-at803x-allow-to-configure-via-pdata.patch	2022-03-22 08:54:47.337464886 +0800
+++ b/target/linux/generic/pending-3.18/734-net-phy-at803x-allow-to-configure-via-pdata.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,180 +0,0 @@
---- a/drivers/net/phy/at803x.c
-+++ b/drivers/net/phy/at803x.c
-@@ -12,12 +12,14 @@
-  */
- 
- #include <linux/phy.h>
-+#include <linux/mdio.h>
- #include <linux/module.h>
- #include <linux/string.h>
- #include <linux/netdevice.h>
- #include <linux/etherdevice.h>
- #include <linux/of_gpio.h>
- #include <linux/gpio/consumer.h>
-+#include <linux/platform_data/phy-at803x.h>
- 
- #define AT803X_INTR_ENABLE			0x12
- #define AT803X_INTR_STATUS			0x13
-@@ -34,8 +36,16 @@
- #define AT803X_INER				0x0012
- #define AT803X_INER_INIT			0xec00
- #define AT803X_INSR				0x0013
-+
-+#define AT803X_PCS_SMART_EEE_CTRL3			0x805D
-+#define AT803X_SMART_EEE_CTRL3_LPI_TX_DELAY_SEL_MASK	0x3
-+#define AT803X_SMART_EEE_CTRL3_LPI_TX_DELAY_SEL_SHIFT	12
-+#define AT803X_SMART_EEE_CTRL3_LPI_EN			BIT(8)
-+
- #define AT803X_DEBUG_ADDR			0x1D
- #define AT803X_DEBUG_DATA			0x1E
-+#define AT803X_DBG0_REG				0x00
-+#define AT803X_DEBUG_RGMII_RX_CLK_DLY		BIT(8)
- #define AT803X_DEBUG_SYSTEM_MODE_CTRL		0x05
- #define AT803X_DEBUG_RGMII_TX_CLK_DLY		BIT(8)
- 
-@@ -50,6 +60,7 @@ MODULE_LICENSE("GPL");
- struct at803x_priv {
- 	bool phy_reset:1;
- 	struct gpio_desc *gpiod_reset;
-+	int prev_speed;
- };
- 
- struct at803x_context {
-@@ -61,6 +72,43 @@ struct at803x_context {
- 	u16 led_control;
- };
- 
-+static u16
-+at803x_dbg_reg_rmw(struct phy_device *phydev, u16 reg, u16 clear, u16 set)
-+{
-+	struct mii_bus *bus = phydev->bus;
-+	int val;
-+
-+	mutex_lock(&bus->mdio_lock);
-+
-+	bus->write(bus, phydev->addr, AT803X_DEBUG_ADDR, reg);
-+	val = bus->read(bus, phydev->addr, AT803X_DEBUG_DATA);
-+	if (val < 0) {
-+		val = 0xffff;
-+		goto out;
-+	}
-+
-+	val &= ~clear;
-+	val |= set;
-+	bus->write(bus, phydev->addr, AT803X_DEBUG_DATA, val);
-+
-+out:
-+	mutex_unlock(&bus->mdio_lock);
-+	return val;
-+}
-+
-+static inline void
-+at803x_dbg_reg_set(struct phy_device *phydev, u16 reg, u16 set)
-+{
-+	at803x_dbg_reg_rmw(phydev, reg, 0, set);
-+}
-+
-+static inline void
-+at803x_dbg_reg_clr(struct phy_device *phydev, u16 reg, u16 clear)
-+{
-+	at803x_dbg_reg_rmw(phydev, reg, clear, 0);
-+}
-+
-+
- /* save relevant PHY registers to private copy */
- static void at803x_context_save(struct phy_device *phydev,
- 				struct at803x_context *context)
-@@ -208,8 +256,16 @@ static int at803x_probe(struct phy_devic
- 	return 0;
- }
- 
-+static void at803x_disable_smarteee(struct phy_device *phydev)
-+{
-+	phy_write_mmd(phydev, MDIO_MMD_PCS, AT803X_PCS_SMART_EEE_CTRL3,
-+		1 << AT803X_SMART_EEE_CTRL3_LPI_TX_DELAY_SEL_SHIFT);
-+	phy_write_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_ADV, 0);
-+}
-+
- static int at803x_config_init(struct phy_device *phydev)
- {
-+	struct at803x_platform_data *pdata;
- 	int ret;
- 
- 	ret = genphy_config_init(phydev);
-@@ -227,6 +283,26 @@ static int at803x_config_init(struct phy
- 			return ret;
- 	}
- 
-+	pdata = dev_get_platdata(&phydev->dev);
-+	if (pdata) {
-+		if (pdata->disable_smarteee)
-+			at803x_disable_smarteee(phydev);
-+
-+		if (pdata->enable_rgmii_rx_delay)
-+			at803x_dbg_reg_set(phydev, AT803X_DBG0_REG,
-+				AT803X_DEBUG_RGMII_RX_CLK_DLY);
-+		else
-+			at803x_dbg_reg_clr(phydev, AT803X_DBG0_REG,
-+				AT803X_DEBUG_RGMII_RX_CLK_DLY);
-+
-+		if (pdata->enable_rgmii_tx_delay)
-+			at803x_dbg_reg_set(phydev, AT803X_DEBUG_SYSTEM_MODE_CTRL,
-+				AT803X_DEBUG_RGMII_TX_CLK_DLY);
-+		else
-+			at803x_dbg_reg_clr(phydev, AT803X_DEBUG_SYSTEM_MODE_CTRL,
-+				AT803X_DEBUG_RGMII_TX_CLK_DLY);
-+	}
-+
- 	return 0;
- }
- 
-@@ -258,6 +334,8 @@ static int at803x_config_intr(struct phy
- static void at803x_link_change_notify(struct phy_device *phydev)
- {
- 	struct at803x_priv *priv = phydev->priv;
-+	struct at803x_platform_data *pdata;
-+	pdata = dev_get_platdata(&phydev->dev);
- 
- 	/*
- 	 * Conduct a hardware reset for AT8030 every time a link loss is
-@@ -288,6 +366,26 @@ static void at803x_link_change_notify(st
- 			priv->phy_reset = false;
- 		}
- 	}
-+	if (pdata && pdata->fixup_rgmii_tx_delay &&
-+	    phydev->speed != priv->prev_speed) {
-+		switch (phydev->speed) {
-+		case SPEED_10:
-+		case SPEED_100:
-+			at803x_dbg_reg_set(phydev,
-+				AT803X_DEBUG_SYSTEM_MODE_CTRL,
-+				AT803X_DEBUG_RGMII_TX_CLK_DLY);
-+			break;
-+		case SPEED_1000:
-+			at803x_dbg_reg_clr(phydev,
-+				AT803X_DEBUG_SYSTEM_MODE_CTRL,
-+				AT803X_DEBUG_RGMII_TX_CLK_DLY);
-+			break;
-+		default:
-+			break;
-+		}
-+
-+		priv->prev_speed = phydev->speed;
-+	}
- }
- 
- static struct phy_driver at803x_driver[] = {
---- /dev/null
-+++ b/include/linux/platform_data/phy-at803x.h
-@@ -0,0 +1,11 @@
-+#ifndef _PHY_AT803X_PDATA_H
-+#define _PHY_AT803X_PDATA_H
-+
-+struct at803x_platform_data {
-+	int disable_smarteee:1;
-+	int enable_rgmii_tx_delay:1;
-+	int enable_rgmii_rx_delay:1;
-+	int fixup_rgmii_tx_delay:1;
-+};
-+
-+#endif /* _PHY_AT803X_PDATA_H */
--- a/target/linux/generic/pending-3.18/735-net-phy-at803x-fix-at8033-sgmii-mode.patch	2022-03-22 08:54:47.337464886 +0800
+++ b/target/linux/generic/pending-3.18/735-net-phy-at803x-fix-at8033-sgmii-mode.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,96 +0,0 @@
---- a/drivers/net/phy/at803x.c
-+++ b/drivers/net/phy/at803x.c
-@@ -36,6 +36,9 @@
- #define AT803X_INER				0x0012
- #define AT803X_INER_INIT			0xec00
- #define AT803X_INSR				0x0013
-+#define AT803X_REG_CHIP_CONFIG			0x1f
-+#define AT803X_BT_BX_REG_SEL			0x8000
-+#define AT803X_SGMII_ANEG_EN			0x1000
- 
- #define AT803X_PCS_SMART_EEE_CTRL3			0x805D
- #define AT803X_SMART_EEE_CTRL3_LPI_TX_DELAY_SEL_MASK	0x3
-@@ -49,9 +52,10 @@
- #define AT803X_DEBUG_SYSTEM_MODE_CTRL		0x05
- #define AT803X_DEBUG_RGMII_TX_CLK_DLY		BIT(8)
- 
--#define ATH8030_PHY_ID 0x004dd076
--#define ATH8031_PHY_ID 0x004dd074
--#define ATH8035_PHY_ID 0x004dd072
-+#define AT803X_PHY_ID_MASK			0xffffffef
-+#define ATH8030_PHY_ID				0x004dd076
-+#define ATH8031_PHY_ID				0x004dd074
-+#define ATH8035_PHY_ID				0x004dd072
- 
- MODULE_DESCRIPTION("Atheros 803x PHY driver");
- MODULE_AUTHOR("Matus Ujhelyi");
-@@ -267,6 +271,27 @@ static int at803x_config_init(struct phy
- {
- 	struct at803x_platform_data *pdata;
- 	int ret;
-+	u32 v;
-+
-+	if (phydev->drv->phy_id == ATH8031_PHY_ID &&
-+		phydev->interface == PHY_INTERFACE_MODE_SGMII)
-+	{
-+		v = phy_read(phydev, AT803X_REG_CHIP_CONFIG);
-+		/* select SGMII/fiber page */
-+		ret = phy_write(phydev, AT803X_REG_CHIP_CONFIG,
-+						v & ~AT803X_BT_BX_REG_SEL);
-+		if (ret)
-+			return ret;
-+		/* enable SGMII autonegotiation */
-+		ret = phy_write(phydev, MII_BMCR, AT803X_SGMII_ANEG_EN);
-+		if (ret)
-+			return ret;
-+		/* select copper page */
-+		ret = phy_write(phydev, AT803X_REG_CHIP_CONFIG,
-+						v | AT803X_BT_BX_REG_SEL);
-+		if (ret)
-+			return ret;
-+	}
- 
- 	ret = genphy_config_init(phydev);
- 	if (ret < 0)
-@@ -393,7 +418,7 @@ static struct phy_driver at803x_driver[]
- 	/* ATHEROS 8035 */
- 	.phy_id			= ATH8035_PHY_ID,
- 	.name			= "Atheros 8035 ethernet",
--	.phy_id_mask		= 0xffffffef,
-+	.phy_id_mask		= AT803X_PHY_ID_MASK,
- 	.probe			= at803x_probe,
- 	.config_init		= at803x_config_init,
- 	.link_change_notify	= at803x_link_change_notify,
-@@ -412,7 +437,7 @@ static struct phy_driver at803x_driver[]
- 	/* ATHEROS 8030 */
- 	.phy_id			= ATH8030_PHY_ID,
- 	.name			= "Atheros 8030 ethernet",
--	.phy_id_mask		= 0xffffffef,
-+	.phy_id_mask		= AT803X_PHY_ID_MASK,
- 	.probe			= at803x_probe,
- 	.config_init		= at803x_config_init,
- 	.link_change_notify	= at803x_link_change_notify,
-@@ -430,8 +455,8 @@ static struct phy_driver at803x_driver[]
- }, {
- 	/* ATHEROS 8031 */
- 	.phy_id			= ATH8031_PHY_ID,
--	.name			= "Atheros 8031 ethernet",
--	.phy_id_mask		= 0xffffffef,
-+	.name			= "Atheros 8031/8033 ethernet",
-+	.phy_id_mask		= AT803X_PHY_ID_MASK,
- 	.probe			= at803x_probe,
- 	.config_init		= at803x_config_init,
- 	.link_change_notify	= at803x_link_change_notify,
-@@ -465,9 +490,9 @@ module_init(atheros_init);
- module_exit(atheros_exit);
- 
- static struct mdio_device_id __maybe_unused atheros_tbl[] = {
--	{ ATH8030_PHY_ID, 0xffffffef },
--	{ ATH8031_PHY_ID, 0xffffffef },
--	{ ATH8035_PHY_ID, 0xffffffef },
-+	{ ATH8030_PHY_ID, AT803X_PHY_ID_MASK },
-+	{ ATH8031_PHY_ID, AT803X_PHY_ID_MASK },
-+	{ ATH8035_PHY_ID, AT803X_PHY_ID_MASK },
- 	{ }
- };
- 
--- a/target/linux/generic/pending-3.18/760-8139cp-fixes-from-4.3.patch	2022-03-22 08:54:47.338464888 +0800
+++ b/target/linux/generic/pending-3.18/760-8139cp-fixes-from-4.3.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,365 +0,0 @@
-commit 41b976414c88016e2c9d9b2f6667ee67a998d388
-Author: David Woodhouse <David.Woodhouse@intel.com>
-Date:   Wed Sep 23 09:45:31 2015 +0100
-
-    8139cp: Dump contents of descriptor ring on TX timeout
-    
-    We are seeing unexplained TX timeouts under heavy load. Let's try to get
-    a better idea of what's going on.
-    
-    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
-    Signed-off-by: David S. Miller <davem@davemloft.net>
-
-commit 7f4c685633e2df9ba10d49a31dda13715745db37
-Author: David Woodhouse <David.Woodhouse@intel.com>
-Date:   Wed Sep 23 09:45:16 2015 +0100
-
-    8139cp: Fix DMA unmapping of transmitted buffers
-    
-    The low 16 bits of the 'opts1' field in the TX descriptor are supposed
-    to still contain the buffer length when the descriptor is handed back to
-    us. In practice, at least on my hardware, they don't. So stash the
-    original value of the opts1 field and get the length to unmap from
-    there.
-    
-    There are other ways we could have worked out the length, but I actually
-    want a stash of the opts1 field anyway so that I can dump it alongside
-    the contents of the descriptor ring when we suffer a TX timeout.
-    
-    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
-    Signed-off-by: David S. Miller <davem@davemloft.net>
-
-commit 0a5aeee0b79fa99d8e04c98dd4e87d4f52aa497b
-Author: David Woodhouse <David.Woodhouse@intel.com>
-Date:   Wed Sep 23 09:44:57 2015 +0100
-
-    8139cp: Reduce duplicate csum/tso code in cp_start_xmit()
-    
-    We calculate the value of the opts1 descriptor field in three different
-    places. With two different behaviours when given an invalid packet to
-    be checksummed  none of them correct. Sort that out.
-    
-    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
-    Signed-off-by: David S. Miller <davem@davemloft.net>
-
-commit a3b804043f490aeec57d8ca5baccdd35e6250857
-Author: David Woodhouse <David.Woodhouse@intel.com>
-Date:   Wed Sep 23 09:44:38 2015 +0100
-
-    8139cp: Fix TSO/scatter-gather descriptor setup
-    
-    When sending a TSO frame in multiple buffers, we were neglecting to set
-    the first descriptor up in TSO mode.
-    
-    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
-    Signed-off-by: David S. Miller <davem@davemloft.net>
-
-commit 26b0bad6ac3a0167792dc4ffb276c29bc597d239
-Author: David Woodhouse <David.Woodhouse@intel.com>
-Date:   Wed Sep 23 09:44:06 2015 +0100
-
-    8139cp: Fix tx_queued debug message to print correct slot numbers
-    
-    After a certain amount of staring at the debug output of this driver, I
-    realised it was lying to me.
-    
-    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
-    Signed-off-by: David S. Miller <davem@davemloft.net>
-
-commit aaa0062ecf4877a26dea66bee1039c6eaf906c94
-Author: David Woodhouse <David.Woodhouse@intel.com>
-Date:   Wed Sep 23 09:43:41 2015 +0100
-
-    8139cp: Do not re-enable RX interrupts in cp_tx_timeout()
-    
-    If an RX interrupt was already received but NAPI has not yet run when
-    the RX timeout happens, we end up in cp_tx_timeout() with RX interrupts
-    already disabled. Blindly re-enabling them will cause an IRQ storm.
-    
-    (This is made particularly horrid by the fact that cp_interrupt() always
-    returns that it's handled the interrupt, even when it hasn't actually
-    done anything. If it didn't do that, the core IRQ code would have
-    detected the storm and handled it, I'd have had a clear smoking gun
-    backtrace instead of just a spontaneously resetting router, and I'd have
-    at *least* two days of my life back. Changing the return value of
-    cp_interrupt() will be argued about under separate cover.)
-    
-    Unconditionally leave RX interrupts disabled after the reset, and
-    schedule NAPI to check the receive ring and re-enable them.
-    
-    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
-    Signed-off-by: David S. Miller <davem@davemloft.net>
-
-commit 7a8a8e75d505147358b225173e890ada43a267e2
-Author: David Woodhouse <dwmw2@infradead.org>
-Date:   Fri Sep 18 00:21:54 2015 +0100
-
-    8139cp: Call __cp_set_rx_mode() from cp_tx_timeout()
-    
-    Unless we reset the RX config, on real hardware I don't seem to receive
-    any packets after a TX timeout.
-    
-    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
-    Signed-off-by: David S. Miller <davem@davemloft.net>
-
-commit fc27bd115b334e3ebdc682a42a47c3aea2566dcc
-Author: David Woodhouse <dwmw2@infradead.org>
-Date:   Fri Sep 18 00:19:08 2015 +0100
-
-    8139cp: Use dev_kfree_skb_any() instead of dev_kfree_skb() in cp_clean_rings()
-    
-    This can be called from cp_tx_timeout() with interrupts disabled.
-    Spotted by Francois Romieu <romieu@fr.zoreil.com>
-    
-    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
-    Signed-off-by: David S. Miller <davem@davemloft.net>
---- a/drivers/net/ethernet/realtek/8139cp.c
-+++ b/drivers/net/ethernet/realtek/8139cp.c
-@@ -157,6 +157,7 @@ enum {
- 	NWayAdvert	= 0x66, /* MII ADVERTISE */
- 	NWayLPAR	= 0x68, /* MII LPA */
- 	NWayExpansion	= 0x6A, /* MII Expansion */
-+	TxDmaOkLowDesc  = 0x82, /* Low 16 bit address of a Tx descriptor. */
- 	Config5		= 0xD8,	/* Config5 */
- 	TxPoll		= 0xD9,	/* Tell chip to check Tx descriptors for work */
- 	RxMaxSize	= 0xDA, /* Max size of an Rx packet (8169 only) */
-@@ -341,6 +342,7 @@ struct cp_private {
- 	unsigned		tx_tail;
- 	struct cp_desc		*tx_ring;
- 	struct sk_buff		*tx_skb[CP_TX_RING_SIZE];
-+	u32			tx_opts[CP_TX_RING_SIZE];
- 
- 	unsigned		rx_buf_sz;
- 	unsigned		wol_enabled : 1; /* Is Wake-on-LAN enabled? */
-@@ -670,7 +672,7 @@ static void cp_tx (struct cp_private *cp
- 		BUG_ON(!skb);
- 
- 		dma_unmap_single(&cp->pdev->dev, le64_to_cpu(txd->addr),
--				 le32_to_cpu(txd->opts1) & 0xffff,
-+				 cp->tx_opts[tx_tail] & 0xffff,
- 				 PCI_DMA_TODEVICE);
- 
- 		if (status & LastFrag) {
-@@ -738,7 +740,7 @@ static netdev_tx_t cp_start_xmit (struct
- {
- 	struct cp_private *cp = netdev_priv(dev);
- 	unsigned entry;
--	u32 eor, flags;
-+	u32 eor, opts1;
- 	unsigned long intr_flags;
- 	__le32 opts2;
- 	int mss = 0;
-@@ -758,6 +760,21 @@ static netdev_tx_t cp_start_xmit (struct
- 	mss = skb_shinfo(skb)->gso_size;
- 
- 	opts2 = cpu_to_le32(cp_tx_vlan_tag(skb));
-+	opts1 = DescOwn;
-+	if (mss)
-+		opts1 |= LargeSend | ((mss & MSSMask) << MSSShift);
-+	else if (skb->ip_summed == CHECKSUM_PARTIAL) {
-+		const struct iphdr *ip = ip_hdr(skb);
-+		if (ip->protocol == IPPROTO_TCP)
-+			opts1 |= IPCS | TCPCS;
-+		else if (ip->protocol == IPPROTO_UDP)
-+			opts1 |= IPCS | UDPCS;
-+		else {
-+			WARN_ONCE(1,
-+				  "Net bug: asked to checksum invalid Legacy IP packet\n");
-+			goto out_dma_error;
-+		}
-+	}
- 
- 	if (skb_shinfo(skb)->nr_frags == 0) {
- 		struct cp_desc *txd = &cp->tx_ring[entry];
-@@ -773,31 +790,20 @@ static netdev_tx_t cp_start_xmit (struct
- 		txd->addr = cpu_to_le64(mapping);
- 		wmb();
- 
--		flags = eor | len | DescOwn | FirstFrag | LastFrag;
--
--		if (mss)
--			flags |= LargeSend | ((mss & MSSMask) << MSSShift);
--		else if (skb->ip_summed == CHECKSUM_PARTIAL) {
--			const struct iphdr *ip = ip_hdr(skb);
--			if (ip->protocol == IPPROTO_TCP)
--				flags |= IPCS | TCPCS;
--			else if (ip->protocol == IPPROTO_UDP)
--				flags |= IPCS | UDPCS;
--			else
--				WARN_ON(1);	/* we need a WARN() */
--		}
-+		opts1 |= eor | len | FirstFrag | LastFrag;
- 
--		txd->opts1 = cpu_to_le32(flags);
-+		txd->opts1 = cpu_to_le32(opts1);
- 		wmb();
- 
- 		cp->tx_skb[entry] = skb;
--		entry = NEXT_TX(entry);
-+		cp->tx_opts[entry] = opts1;
-+		netif_dbg(cp, tx_queued, cp->dev, "tx queued, slot %d, skblen %d\n",
-+			  entry, skb->len);
- 	} else {
- 		struct cp_desc *txd;
--		u32 first_len, first_eor;
-+		u32 first_len, first_eor, ctrl;
- 		dma_addr_t first_mapping;
- 		int frag, first_entry = entry;
--		const struct iphdr *ip = ip_hdr(skb);
- 
- 		/* We must give this initial chunk to the device last.
- 		 * Otherwise we could race with the device.
-@@ -810,14 +816,14 @@ static netdev_tx_t cp_start_xmit (struct
- 			goto out_dma_error;
- 
- 		cp->tx_skb[entry] = skb;
--		entry = NEXT_TX(entry);
- 
- 		for (frag = 0; frag < skb_shinfo(skb)->nr_frags; frag++) {
- 			const skb_frag_t *this_frag = &skb_shinfo(skb)->frags[frag];
- 			u32 len;
--			u32 ctrl;
- 			dma_addr_t mapping;
- 
-+			entry = NEXT_TX(entry);
-+
- 			len = skb_frag_size(this_frag);
- 			mapping = dma_map_single(&cp->pdev->dev,
- 						 skb_frag_address(this_frag),
-@@ -829,19 +835,7 @@ static netdev_tx_t cp_start_xmit (struct
- 
- 			eor = (entry == (CP_TX_RING_SIZE - 1)) ? RingEnd : 0;
- 
--			ctrl = eor | len | DescOwn;
--
--			if (mss)
--				ctrl |= LargeSend |
--					((mss & MSSMask) << MSSShift);
--			else if (skb->ip_summed == CHECKSUM_PARTIAL) {
--				if (ip->protocol == IPPROTO_TCP)
--					ctrl |= IPCS | TCPCS;
--				else if (ip->protocol == IPPROTO_UDP)
--					ctrl |= IPCS | UDPCS;
--				else
--					BUG();
--			}
-+			ctrl = opts1 | eor | len;
- 
- 			if (frag == skb_shinfo(skb)->nr_frags - 1)
- 				ctrl |= LastFrag;
-@@ -854,8 +848,8 @@ static netdev_tx_t cp_start_xmit (struct
- 			txd->opts1 = cpu_to_le32(ctrl);
- 			wmb();
- 
-+			cp->tx_opts[entry] = ctrl;
- 			cp->tx_skb[entry] = skb;
--			entry = NEXT_TX(entry);
- 		}
- 
- 		txd = &cp->tx_ring[first_entry];
-@@ -863,27 +857,17 @@ static netdev_tx_t cp_start_xmit (struct
- 		txd->addr = cpu_to_le64(first_mapping);
- 		wmb();
- 
--		if (skb->ip_summed == CHECKSUM_PARTIAL) {
--			if (ip->protocol == IPPROTO_TCP)
--				txd->opts1 = cpu_to_le32(first_eor | first_len |
--							 FirstFrag | DescOwn |
--							 IPCS | TCPCS);
--			else if (ip->protocol == IPPROTO_UDP)
--				txd->opts1 = cpu_to_le32(first_eor | first_len |
--							 FirstFrag | DescOwn |
--							 IPCS | UDPCS);
--			else
--				BUG();
--		} else
--			txd->opts1 = cpu_to_le32(first_eor | first_len |
--						 FirstFrag | DescOwn);
-+		ctrl = opts1 | first_eor | first_len | FirstFrag;
-+		txd->opts1 = cpu_to_le32(ctrl);
- 		wmb();
-+
-+		cp->tx_opts[first_entry] = ctrl;
-+		netif_dbg(cp, tx_queued, cp->dev, "tx queued, slots %d-%d, skblen %d\n",
-+			  first_entry, entry, skb->len);
- 	}
--	cp->tx_head = entry;
-+	cp->tx_head = NEXT_TX(entry);
- 
- 	netdev_sent_queue(dev, skb->len);
--	netif_dbg(cp, tx_queued, cp->dev, "tx queued, slot %d, skblen %d\n",
--		  entry, skb->len);
- 	if (TX_BUFFS_AVAIL(cp) <= (MAX_SKB_FRAGS + 1))
- 		netif_stop_queue(dev);
- 
-@@ -1120,6 +1104,7 @@ static int cp_init_rings (struct cp_priv
- {
- 	memset(cp->tx_ring, 0, sizeof(struct cp_desc) * CP_TX_RING_SIZE);
- 	cp->tx_ring[CP_TX_RING_SIZE - 1].opts1 = cpu_to_le32(RingEnd);
-+	memset(cp->tx_opts, 0, sizeof(cp->tx_opts));
- 
- 	cp_init_rings_index(cp);
- 
-@@ -1156,7 +1141,7 @@ static void cp_clean_rings (struct cp_pr
- 			desc = cp->rx_ring + i;
- 			dma_unmap_single(&cp->pdev->dev,le64_to_cpu(desc->addr),
- 					 cp->rx_buf_sz, PCI_DMA_FROMDEVICE);
--			dev_kfree_skb(cp->rx_skb[i]);
-+			dev_kfree_skb_any(cp->rx_skb[i]);
- 		}
- 	}
- 
-@@ -1169,7 +1154,7 @@ static void cp_clean_rings (struct cp_pr
- 					 le32_to_cpu(desc->opts1) & 0xffff,
- 					 PCI_DMA_TODEVICE);
- 			if (le32_to_cpu(desc->opts1) & LastFrag)
--				dev_kfree_skb(skb);
-+				dev_kfree_skb_any(skb);
- 			cp->dev->stats.tx_dropped++;
- 		}
- 	}
-@@ -1177,6 +1162,7 @@ static void cp_clean_rings (struct cp_pr
- 
- 	memset(cp->rx_ring, 0, sizeof(struct cp_desc) * CP_RX_RING_SIZE);
- 	memset(cp->tx_ring, 0, sizeof(struct cp_desc) * CP_TX_RING_SIZE);
-+	memset(cp->tx_opts, 0, sizeof(cp->tx_opts));
- 
- 	memset(cp->rx_skb, 0, sizeof(struct sk_buff *) * CP_RX_RING_SIZE);
- 	memset(cp->tx_skb, 0, sizeof(struct sk_buff *) * CP_TX_RING_SIZE);
-@@ -1254,7 +1240,7 @@ static void cp_tx_timeout(struct net_dev
- {
- 	struct cp_private *cp = netdev_priv(dev);
- 	unsigned long flags;
--	int rc;
-+	int rc, i;
- 
- 	netdev_warn(dev, "Transmit timeout, status %2x %4x %4x %4x\n",
- 		    cpr8(Cmd), cpr16(CpCmd),
-@@ -1262,13 +1248,26 @@ static void cp_tx_timeout(struct net_dev
- 
- 	spin_lock_irqsave(&cp->lock, flags);
- 
-+	netif_dbg(cp, tx_err, cp->dev, "TX ring head %d tail %d desc %x\n",
-+		  cp->tx_head, cp->tx_tail, cpr16(TxDmaOkLowDesc));
-+	for (i = 0; i < CP_TX_RING_SIZE; i++) {
-+		netif_dbg(cp, tx_err, cp->dev,
-+			  "TX slot %d @%p: %08x (%08x) %08x %llx %p\n",
-+			  i, &cp->tx_ring[i], le32_to_cpu(cp->tx_ring[i].opts1),
-+			  cp->tx_opts[i], le32_to_cpu(cp->tx_ring[i].opts2),
-+			  le64_to_cpu(cp->tx_ring[i].addr),
-+			  cp->tx_skb[i]);
-+	}
-+
- 	cp_stop_hw(cp);
- 	cp_clean_rings(cp);
- 	rc = cp_init_rings(cp);
- 	cp_start_hw(cp);
--	cp_enable_irq(cp);
-+	__cp_set_rx_mode(dev);
-+	cpw16_f(IntrMask, cp_norx_intr_mask);
- 
- 	netif_wake_queue(dev);
-+	napi_schedule(&cp->napi);
- 
- 	spin_unlock_irqrestore(&cp->lock, flags);
- }
--- a/target/linux/generic/pending-3.18/773-bgmac-add-srab-switch.patch	2022-03-22 08:54:47.338464888 +0800
+++ b/target/linux/generic/pending-3.18/773-bgmac-add-srab-switch.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,72 +0,0 @@
-Register switch connected to srab
-
-Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
-
---- a/drivers/net/ethernet/broadcom/bgmac.c
-+++ b/drivers/net/ethernet/broadcom/bgmac.c
-@@ -17,6 +17,7 @@
- #include <linux/phy_fixed.h>
- #include <linux/interrupt.h>
- #include <linux/dma-mapping.h>
-+#include <linux/platform_data/b53.h>
- #include <bcm47xx_nvram.h>
- 
- static const struct bcma_device_id bgmac_bcma_tbl[] = {
-@@ -1538,6 +1539,17 @@ static void bgmac_mii_unregister(struct
- 	mdiobus_free(mii_bus);
- }
- 
-+static struct b53_platform_data bgmac_b53_pdata = {
-+};
-+
-+static struct platform_device bgmac_b53_dev = {
-+	.name		= "b53-srab-switch",
-+	.id		= -1,
-+	.dev		= {
-+		.platform_data = &bgmac_b53_pdata,
-+	},
-+};
-+
- /**************************************************
-  * BCMA bus ops
-  **************************************************/
-@@ -1671,6 +1683,16 @@ static int bgmac_probe(struct bcma_devic
- 	net_dev->hw_features = net_dev->features;
- 	net_dev->vlan_features = net_dev->features;
- 
-+	if ((ci->id == BCMA_CHIP_ID_BCM4707 ||
-+	     ci->id == BCMA_CHIP_ID_BCM53018) &&
-+	    !bgmac_b53_pdata.regs) {
-+		bgmac_b53_pdata.regs = ioremap_nocache(0x18007000, 0x1000);
-+
-+		err = platform_device_register(&bgmac_b53_dev);
-+		if (!err)
-+			bgmac->b53_device = &bgmac_b53_dev;
-+	}
-+
- 	err = register_netdev(bgmac->net_dev);
- 	if (err) {
- 		bgmac_err(bgmac, "Cannot register net device\n");
-@@ -1697,6 +1719,10 @@ static void bgmac_remove(struct bcma_dev
- {
- 	struct bgmac *bgmac = bcma_get_drvdata(core);
- 
-+	if (bgmac->b53_device)
-+		platform_device_unregister(&bgmac_b53_dev);
-+	bgmac->b53_device = NULL;
-+
- 	unregister_netdev(bgmac->net_dev);
- 	bgmac_mii_unregister(bgmac);
- 	netif_napi_del(&bgmac->napi);
---- a/drivers/net/ethernet/broadcom/bgmac.h
-+++ b/drivers/net/ethernet/broadcom/bgmac.h
-@@ -462,6 +462,9 @@ struct bgmac {
- 	bool has_robosw;
- 
- 	bool loopback;
-+
-+	/* platform device for associated switch */
-+	struct platform_device *b53_device;
- };
- 
- static inline u32 bgmac_read(struct bgmac *bgmac, u16 offset)
--- a/target/linux/generic/pending-3.18/785-hso-support-0af0-9300.patch	2022-03-22 08:54:47.338464888 +0800
+++ b/target/linux/generic/pending-3.18/785-hso-support-0af0-9300.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,25 +0,0 @@
---- a/drivers/net/usb/hso.c
-+++ b/drivers/net/usb/hso.c
-@@ -468,6 +468,7 @@ static const struct usb_device_id hso_id
- 	{USB_DEVICE(0x0af0, 0x8900)},
- 	{USB_DEVICE(0x0af0, 0x9000)},
- 	{USB_DEVICE(0x0af0, 0x9200)},		/* Option GTM671WFS */
-+	{USB_DEVICE(0x0af0, 0x9300)},		/* GTM 66xxWFS */
- 	{USB_DEVICE(0x0af0, 0xd035)},
- 	{USB_DEVICE(0x0af0, 0xd055)},
- 	{USB_DEVICE(0x0af0, 0xd155)},
---- a/drivers/usb/storage/unusual_devs.h
-+++ b/drivers/usb/storage/unusual_devs.h
-@@ -1330,6 +1330,12 @@ UNUSUAL_DEV( 0x0af0, 0x8304, 0x0000, 0x0
- 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
- 		0 ),
- 
-+UNUSUAL_DEV( 0x0af0, 0x9300, 0x0000, 0x0000,
-+		"Option",
-+		"Globetrotter 66xxWFS SD-Card",
-+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
-+		0 ),
-+
- UNUSUAL_DEV( 0x0af0, 0xc100, 0x0000, 0x0000,
- 		"Option",
- 		"GI 070x SD-Card",
--- a/target/linux/generic/pending-3.18/810-pci_disable_common_quirks.patch	2022-03-22 08:54:47.339464889 +0800
+++ b/target/linux/generic/pending-3.18/810-pci_disable_common_quirks.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,51 +0,0 @@
---- a/drivers/pci/Kconfig
-+++ b/drivers/pci/Kconfig
-@@ -58,6 +58,12 @@ config XEN_PCIDEV_FRONTEND
-           The PCI device frontend driver allows the kernel to import arbitrary
-           PCI devices from a PCI backend to support PCI driver domains.
- 
-+config PCI_DISABLE_COMMON_QUIRKS
-+	bool "PCI disable common quirks"
-+	depends on PCI
-+	help
-+	  If you don't know what to do here, say N.
-+
- config HT_IRQ
- 	bool "Interrupts on hypertransport devices"
- 	default y
---- a/drivers/pci/quirks.c
-+++ b/drivers/pci/quirks.c
-@@ -41,6 +41,7 @@ static void quirk_mmio_always_on(struct
- DECLARE_PCI_FIXUP_CLASS_EARLY(PCI_ANY_ID, PCI_ANY_ID,
- 				PCI_CLASS_BRIDGE_HOST, 8, quirk_mmio_always_on);
- 
-+#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
- /* The Mellanox Tavor device gives false positive parity errors
-  * Mark this device with a broken_parity_status, to allow
-  * PCI scanning code to "skip" this now blacklisted device.
-@@ -2929,6 +2930,7 @@ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_I
- DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x65f9, quirk_intel_mc_errata);
- DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x65fa, quirk_intel_mc_errata);
- 
-+#endif /* !CONFIG_PCI_DISABLE_COMMON_QUIRKS */
- 
- /*
-  * Ivytown NTB BAR sizes are misreported by the hardware due to an erratum.  To
-@@ -2985,6 +2987,8 @@ static void fixup_debug_report(struct pc
- 	}
- }
- 
-+#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
-+
- /*
-  * Some BIOS implementations leave the Intel GPU interrupts enabled,
-  * even though no one is handling them (f.e. i915 driver is never loaded).
-@@ -3019,6 +3023,8 @@ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_IN
- DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x010a, disable_igfx_irq);
- DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x0152, disable_igfx_irq);
- 
-+#endif /* !CONFIG_PCI_DISABLE_COMMON_QUIRKS */
-+
- /*
-  * PCI devices which are on Intel chips can skip the 10ms delay
-  * before entering D3 mode.
--- a/target/linux/generic/pending-3.18/811-pci_disable_usb_common_quirks.patch	2022-03-22 08:54:47.339464889 +0800
+++ b/target/linux/generic/pending-3.18/811-pci_disable_usb_common_quirks.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,101 +0,0 @@
-
---- a/drivers/usb/host/pci-quirks.c
-+++ b/drivers/usb/host/pci-quirks.c
-@@ -98,6 +98,8 @@ struct amd_chipset_type {
- 	u8 rev;
- };
- 
-+#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
-+
- static struct amd_chipset_info {
- 	struct pci_dev	*nb_dev;
- 	struct pci_dev	*smbus_dev;
-@@ -462,6 +464,10 @@ void usb_amd_dev_put(void)
- }
- EXPORT_SYMBOL_GPL(usb_amd_dev_put);
- 
-+#endif /* CONFIG_PCI_DISABLE_COMMON_QUIRKS */
-+
-+#if IS_ENABLED(CONFIG_USB_UHCI_HCD)
-+
- /*
-  * Make sure the controller is completely inactive, unable to
-  * generate interrupts or do DMA.
-@@ -541,8 +547,17 @@ reset_needed:
- 	uhci_reset_hc(pdev, base);
- 	return 1;
- }
-+#else
-+int uhci_check_and_reset_hc(struct pci_dev *pdev, unsigned long base)
-+{
-+	return 0;
-+}
-+
-+#endif
- EXPORT_SYMBOL_GPL(uhci_check_and_reset_hc);
- 
-+#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
-+
- static inline int io_type_enabled(struct pci_dev *pdev, unsigned int mask)
- {
- 	u16 cmd;
-@@ -1103,3 +1118,4 @@ static void quirk_usb_early_handoff(stru
- }
- DECLARE_PCI_FIXUP_CLASS_FINAL(PCI_ANY_ID, PCI_ANY_ID,
- 			PCI_CLASS_SERIAL_USB, 8, quirk_usb_early_handoff);
-+#endif
---- a/drivers/usb/host/pci-quirks.h
-+++ b/drivers/usb/host/pci-quirks.h
-@@ -4,6 +4,9 @@
- #ifdef CONFIG_PCI
- void uhci_reset_hc(struct pci_dev *pdev, unsigned long base);
- int uhci_check_and_reset_hc(struct pci_dev *pdev, unsigned long base);
-+#endif  /* CONFIG_PCI */
-+
-+#if defined(CONFIG_PCI) && !defined(CONFIG_PCI_DISABLE_COMMON_QUIRKS)
- int usb_amd_find_chipset_info(void);
- int usb_hcd_amd_remote_wakeup_quirk(struct pci_dev *pdev);
- bool usb_amd_hang_symptom_quirk(void);
-@@ -16,11 +19,24 @@ void usb_disable_xhci_ports(struct pci_d
- void sb800_prefetch(struct device *dev, int on);
- #else
- struct pci_dev;
-+static inline int usb_amd_find_chipset_info(void)
-+{
-+	return 0;
-+}
-+static inline bool usb_amd_hang_symptom_quirk(void)
-+{
-+	return false;
-+}
-+static inline bool usb_amd_prefetch_quirk(void)
-+{
-+	return false;
-+}
- static inline void usb_amd_quirk_pll_disable(void) {}
- static inline void usb_amd_quirk_pll_enable(void) {}
- static inline void usb_amd_dev_put(void) {}
- static inline void usb_disable_xhci_ports(struct pci_dev *xhci_pdev) {}
- static inline void sb800_prefetch(struct device *dev, int on) {}
--#endif  /* CONFIG_PCI */
-+static inline void usb_enable_intel_xhci_ports(struct pci_dev *xhci_pdev) {}
-+#endif
- 
- #endif  /*  __LINUX_USB_PCI_QUIRKS_H  */
---- a/include/linux/usb/hcd.h
-+++ b/include/linux/usb/hcd.h
-@@ -445,7 +445,14 @@ extern int usb_hcd_pci_probe(struct pci_
- extern void usb_hcd_pci_remove(struct pci_dev *dev);
- extern void usb_hcd_pci_shutdown(struct pci_dev *dev);
- 
-+#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
- extern int usb_hcd_amd_remote_wakeup_quirk(struct pci_dev *dev);
-+#else
-+static inline int usb_hcd_amd_remote_wakeup_quirk(struct pci_dev *dev)
-+{
-+	return 0;
-+}
-+#endif
- 
- #ifdef CONFIG_PM
- extern const struct dev_pm_ops usb_hcd_pci_pm_ops;
--- a/target/linux/generic/pending-3.18/821-usb-dwc2-dualrole.patch	2022-03-22 08:54:47.340464891 +0800
+++ b/target/linux/generic/pending-3.18/821-usb-dwc2-dualrole.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,146 +0,0 @@
---- a/drivers/usb/dwc2/Kconfig
-+++ b/drivers/usb/dwc2/Kconfig
-@@ -1,6 +1,6 @@
- config USB_DWC2
--	bool "DesignWare USB2 DRD Core Support"
--	depends on USB
-+	tristate "DesignWare USB2 DRD Core Support"
-+	depends on USB || USB_GADGET
- 	help
- 	  Say Y here if your system has a Dual Role Hi-Speed USB
- 	  controller based on the DesignWare HSOTG IP Core.
-@@ -10,49 +10,61 @@ config USB_DWC2
- 	  bus interface module (if you have a PCI bus system) will be
- 	  called dwc2_pci.ko, and the platform interface module (for
- 	  controllers directly connected to the CPU) will be called
--	  dwc2_platform.ko. For gadget mode, there will be a single
--	  module called dwc2_gadget.ko.
--
--	  NOTE: The s3c-hsotg driver is now renamed to dwc2_gadget. The
--	  host and gadget drivers are still currently separate drivers.
--	  There are plans to merge the dwc2_gadget driver with the dwc2
--	  host driver in the near future to create a dual-role driver.
-+	  dwc2_platform.ko. For all modes(host, gadget and dual-role), there
-+	  will be an additional module named dwc2.ko.
- 
- if USB_DWC2
- 
-+choice
-+	bool "DWC2 Mode Selection"
-+	default USB_DWC2_DUAL_ROLE if (USB && USB_GADGET)
-+	default USB_DWC2_HOST if (USB && !USB_GADGET)
-+	default USB_DWC2_PERIPHERAL if (!USB && USB_GADGET)
-+
- config USB_DWC2_HOST
--	tristate "Host only mode"
-+	bool "Host only mode"
- 	depends on USB
- 	help
- 	  The Designware USB2.0 high-speed host controller
--	  integrated into many SoCs.
-+	  integrated into many SoCs. Select this option if you want the
-+	  driver to operate in Host-only mode.
- 
--config USB_DWC2_PLATFORM
--	bool "DWC2 Platform"
--	depends on USB_DWC2_HOST
--	default USB_DWC2_HOST
-+comment "Gadget/Dual-role mode requires USB Gadget support to be enabled"
-+
-+config USB_DWC2_PERIPHERAL
-+	bool "Gadget only mode"
-+	depends on USB_GADGET=y || USB_GADGET=USB_DWC2
-+	help
-+	  The Designware USB2.0 high-speed gadget controller
-+	  integrated into many SoCs. Select this option if you want the
-+	  driver to operate in Peripheral-only mode. This option requires
-+	  USB_GADGET to be enabled.
-+
-+config USB_DWC2_DUAL_ROLE
-+	bool "Dual Role mode"
-+	depends on (USB=y || USB=USB_DWC2) && (USB_GADGET=y || USB_GADGET=USB_DWC2)
- 	help
--	  The Designware USB2.0 platform interface module for
--	  controllers directly connected to the CPU. This is only
--	  used for host mode.
-+	  Select this option if you want the driver to work in a dual-role
-+	  mode. In this mode both host and gadget features are enabled, and
-+	  the role will be determined by the cable that gets plugged-in. This
-+	  option requires USB_GADGET to be enabled.
-+endchoice
-+
-+config USB_DWC2_PLATFORM
-+	tristate "DWC2 Platform"
-+	default USB_DWC2_HOST || USB_DWC2_PERIPHERAL
-+        help
-+          The Designware USB2.0 platform interface module for
-+          controllers directly connected to the CPU.
- 
- config USB_DWC2_PCI
--	bool "DWC2 PCI"
-+	tristate "DWC2 PCI"
- 	depends on USB_DWC2_HOST && PCI
- 	default USB_DWC2_HOST
- 	help
- 	  The Designware USB2.0 PCI interface module for controllers
- 	  connected to a PCI bus. This is only used for host mode.
- 
--comment "Gadget mode requires USB Gadget support to be enabled"
--
--config USB_DWC2_PERIPHERAL
--	tristate "Gadget only mode"
--	depends on USB_GADGET
--	help
--	  The Designware USB2.0 high-speed gadget controller
--	  integrated into many SoCs.
--
- config USB_DWC2_DEBUG
- 	bool "Enable Debugging Messages"
- 	help
---- a/drivers/usb/dwc2/Makefile
-+++ b/drivers/usb/dwc2/Makefile
-@@ -1,28 +1,28 @@
- ccflags-$(CONFIG_USB_DWC2_DEBUG)	+= -DDEBUG
- ccflags-$(CONFIG_USB_DWC2_VERBOSE)	+= -DVERBOSE_DEBUG
- 
--obj-$(CONFIG_USB_DWC2_HOST)		+= dwc2.o
-+obj-$(CONFIG_USB_DWC2)			+= dwc2.o
- dwc2-y					:= core.o core_intr.o
--dwc2-y					+= hcd.o hcd_intr.o
--dwc2-y					+= hcd_queue.o hcd_ddma.o
-+
-+ifneq ($(filter y,$(CONFIG_USB_DWC2_HOST) $(CONFIG_USB_DWC2_DUAL_ROLE)),)
-+	dwc2-y				+= hcd.o hcd_intr.o
-+	dwc2-y				+= hcd_queue.o hcd_ddma.o
-+endif
-+
-+ifneq ($(filter y,$(CONFIG_USB_DWC2_PERIPHERAL) $(CONFIG_USB_DWC2_DUAL_ROLE)),)
-+	dwc2-y       			+= gadget.o
-+endif
- 
- # NOTE: The previous s3c-hsotg peripheral mode only driver has been moved to
- # this location and renamed gadget.c. When building for dynamically linked
--# modules, dwc2_gadget.ko will get built for peripheral mode. For host mode,
--# the core module will be dwc2.ko, the PCI bus interface module will called
--# dwc2_pci.ko and the platform interface module will be called dwc2_platform.ko.
--# At present the host and gadget driver will be separate drivers, but there
--# are plans in the near future to create a dual-role driver.
-+# modules, dwc2.ko will get built for host mode, peripheral mode, and dual-role
-+# mode. The PCI bus interface module will called dwc2_pci.ko and the platform
-+# interface module will be called dwc2_platform.ko.
- 
- ifneq ($(CONFIG_USB_DWC2_PCI),)
--	obj-$(CONFIG_USB_DWC2_HOST)	+= dwc2_pci.o
-+	obj-$(CONFIG_USB_DWC2)		+= dwc2_pci.o
- 	dwc2_pci-y			:= pci.o
- endif
- 
--ifneq ($(CONFIG_USB_DWC2_PLATFORM),)
--	obj-$(CONFIG_USB_DWC2_HOST)	+= dwc2_platform.o
--	dwc2_platform-y			:= platform.o
--endif
--
--obj-$(CONFIG_USB_DWC2_PERIPHERAL)	+= dwc2_gadget.o
--dwc2_gadget-y				:= gadget.o
-+obj-$(CONFIG_USB_DWC2_PLATFORM)		+= dwc2_platform.o
-+dwc2_platform-y				:= platform.o
--- a/target/linux/generic/pending-3.18/834-ledtrig-libata.patch	2022-03-22 08:54:47.340464891 +0800
+++ b/target/linux/generic/pending-3.18/834-ledtrig-libata.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,153 +0,0 @@
-From 52cfd51cdf6a6e14d4fb270c6343abac3bac00f4 Mon Sep 17 00:00:00 2001
-From: Daniel Golle <daniel@makrotopia.org>
-Date: Fri, 12 Dec 2014 13:38:33 +0100
-Subject: [PATCH] libata: add ledtrig support
-To: linux-ide@vger.kernel.org,
-    Tejun Heo <tj@kernel.org>
-
-This adds a LED trigger for each ATA port indicating disk activity.
-
-As this is needed only on specific platforms (NAS SoCs and such),
-these platforms should define ARCH_WANTS_LIBATA_LEDS if there
-are boards with LED(s) intended to indicate ATA disk activity and
-need the OS to take care of that.
-In that way, if not selected, LED trigger support not will be
-included in libata-core and both, codepaths and structures remain
-untouched.
-
-Signed-off-by: Daniel Golle <daniel@makrotopia.org>
----
- drivers/ata/Kconfig       | 16 ++++++++++++++++
- drivers/ata/libata-core.c | 41 +++++++++++++++++++++++++++++++++++++++++
- include/linux/libata.h    |  9 +++++++++
- 3 files changed, 66 insertions(+)
-
---- a/drivers/ata/Kconfig
-+++ b/drivers/ata/Kconfig
-@@ -46,6 +46,22 @@ config ATA_VERBOSE_ERROR
- 
- 	  If unsure, say Y.
- 
-+config ARCH_WANT_LIBATA_LEDS
-+	bool
-+
-+config ATA_LEDS
-+	bool "support ATA port LED triggers"
-+	depends on ARCH_WANT_LIBATA_LEDS
-+	select NEW_LEDS
-+	select LEDS_CLASS
-+	select LEDS_TRIGGERS
-+	default y
-+	help
-+	  This option adds a LED trigger for each registered ATA port.
-+	  It is used to drive disk activity leds connected via GPIO.
-+
-+	  If unsure, say N.
-+
- config ATA_ACPI
- 	bool "ATA ACPI Support"
- 	depends on ACPI && PCI
---- a/drivers/ata/libata-core.c
-+++ b/drivers/ata/libata-core.c
-@@ -725,6 +725,19 @@ u64 ata_tf_read_block(struct ata_taskfil
- 	return block;
- }
- 
-+#ifdef CONFIG_ATA_LEDS
-+#define LIBATA_BLINK_DELAY 20 /* ms */
-+static inline void ata_led_act(struct ata_port *ap)
-+{
-+	unsigned long led_delay = LIBATA_BLINK_DELAY;
-+
-+	if (unlikely(!ap->ledtrig))
-+		return;
-+
-+	led_trigger_blink_oneshot(ap->ledtrig, &led_delay, &led_delay, 0);
-+}
-+#endif
-+
- /**
-  *	ata_build_rw_tf - Build ATA taskfile for given read/write request
-  *	@tf: Target ATA taskfile
-@@ -4828,6 +4841,9 @@ static struct ata_queued_cmd *ata_qc_new
- 			break;
- 		}
- 	}
-+#ifdef CONFIG_ATA_LEDS
-+	ata_led_act(ap);
-+#endif
- 
- 	return qc;
- }
-@@ -5737,6 +5753,9 @@ struct ata_port *ata_port_alloc(struct a
- 	ap->stats.unhandled_irq = 1;
- 	ap->stats.idle_irq = 1;
- #endif
-+#ifdef CONFIG_ATA_LEDS
-+	ap->ledtrig = kzalloc(sizeof(struct led_trigger), GFP_KERNEL);
-+#endif
- 	ata_sff_port_init(ap);
- 
- 	return ap;
-@@ -5758,6 +5777,12 @@ static void ata_host_release(struct devi
- 
- 		kfree(ap->pmp_link);
- 		kfree(ap->slave_link);
-+#ifdef CONFIG_ATA_LEDS
-+		if (ap->ledtrig) {
-+			led_trigger_unregister(ap->ledtrig);
-+			kfree(ap->ledtrig);
-+		};
-+#endif
- 		kfree(ap);
- 		host->ports[i] = NULL;
- 	}
-@@ -6204,7 +6229,23 @@ int ata_host_register(struct ata_host *h
- 		host->ports[i]->print_id = atomic_inc_return(&ata_print_id);
- 		host->ports[i]->local_port_no = i + 1;
- 	}
-+#ifdef CONFIG_ATA_LEDS
-+	for (i = 0; i < host->n_ports; i++) {
-+		if (unlikely(!host->ports[i]->ledtrig))
-+			continue;
- 
-+		snprintf(host->ports[i]->ledtrig_name,
-+			sizeof(host->ports[i]->ledtrig_name), "ata%u",
-+			host->ports[i]->print_id);
-+
-+		host->ports[i]->ledtrig->name = host->ports[i]->ledtrig_name;
-+
-+		if (led_trigger_register(host->ports[i]->ledtrig)) {
-+			kfree(host->ports[i]->ledtrig);
-+			host->ports[i]->ledtrig = NULL;
-+		}
-+	}
-+#endif
- 	/* Create associated sysfs transport objects  */
- 	for (i = 0; i < host->n_ports; i++) {
- 		rc = ata_tport_add(host->dev,host->ports[i]);
---- a/include/linux/libata.h
-+++ b/include/linux/libata.h
-@@ -38,6 +38,9 @@
- #include <linux/acpi.h>
- #include <linux/cdrom.h>
- #include <linux/sched.h>
-+#ifdef CONFIG_ATA_LEDS
-+#include <linux/leds.h>
-+#endif
- 
- /*
-  * Define if arch has non-standard setup.  This is a _PCI_ standard
-@@ -874,6 +877,12 @@ struct ata_port {
- #ifdef CONFIG_ATA_ACPI
- 	struct ata_acpi_gtm	__acpi_init_gtm; /* use ata_acpi_init_gtm() */
- #endif
-+
-+#ifdef CONFIG_ATA_LEDS
-+	struct led_trigger	*ledtrig;
-+	char			ledtrig_name[8];
-+#endif
-+
- 	/* owned by EH */
- 	u8			sector_buf[ATA_SECT_SIZE] ____cacheline_aligned;
- };
--- a/target/linux/generic/pending-3.18/840-rtc7301.patch	2022-03-22 08:54:47.341464893 +0800
+++ b/target/linux/generic/pending-3.18/840-rtc7301.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,250 +0,0 @@
---- a/drivers/rtc/Kconfig
-+++ b/drivers/rtc/Kconfig
-@@ -979,6 +979,15 @@ config RTC_DRV_NUC900
- 	  If you say yes here you get support for the RTC subsystem of the
- 	  NUC910/NUC920 used in embedded systems.
- 
-+config RTC_DRV_RTC7301
-+	tristate "Epson RTC-7301 SF/DG"
-+	help
-+	  If you say Y here you will get support for the
-+	  Epson RTC-7301 SF/DG RTC chips.
-+
-+	  This driver can also be built as a module. If so, the module
-+	  will be called rtc-7301.
-+
- comment "on-CPU RTC drivers"
- 
- config RTC_DRV_DAVINCI
---- a/drivers/rtc/Makefile
-+++ b/drivers/rtc/Makefile
-@@ -115,6 +115,7 @@ obj-$(CONFIG_RTC_DRV_RP5C01)	+= rtc-rp5c
- obj-$(CONFIG_RTC_DRV_RS5C313)	+= rtc-rs5c313.o
- obj-$(CONFIG_RTC_DRV_RS5C348)	+= rtc-rs5c348.o
- obj-$(CONFIG_RTC_DRV_RS5C372)	+= rtc-rs5c372.o
-+obj-$(CONFIG_RTC_DRV_RTC7301)	+= rtc-rtc7301.o
- obj-$(CONFIG_RTC_DRV_RV3029C2)	+= rtc-rv3029c2.o
- obj-$(CONFIG_RTC_DRV_RX4581)	+= rtc-rx4581.o
- obj-$(CONFIG_RTC_DRV_RX8025)	+= rtc-rx8025.o
---- /dev/null
-+++ b/drivers/rtc/rtc-rtc7301.c
-@@ -0,0 +1,219 @@
-+/*
-+ * Driver for Epson RTC-7301SF/DG
-+ *
-+ * Copyright (C) 2009 Jose Vasconcellos
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License version 2 as
-+ * published by the Free Software Foundation.
-+ */
-+
-+#include <linux/module.h>
-+#include <linux/rtc.h>
-+#include <linux/platform_device.h>
-+#include <linux/io.h>
-+#include <linux/delay.h>
-+#include <linux/bcd.h>
-+
-+#define RTC_NAME "rtc7301"
-+#define RTC_VERSION "0.1"
-+
-+/* Epson RTC-7301 register addresses */
-+#define RTC7301_SEC		0x00
-+#define RTC7301_SEC10		0x01
-+#define RTC7301_MIN		0x02
-+#define RTC7301_MIN10		0x03
-+#define RTC7301_HOUR		0x04
-+#define RTC7301_HOUR10		0x05
-+#define RTC7301_WEEKDAY		0x06
-+#define RTC7301_DAY		0x07
-+#define RTC7301_DAY10		0x08
-+#define RTC7301_MON		0x09
-+#define RTC7301_MON10		0x0A
-+#define RTC7301_YEAR		0x0B
-+#define RTC7301_YEAR10		0x0C
-+#define RTC7301_YEAR100		0x0D
-+#define RTC7301_YEAR1000	0x0E
-+#define RTC7301_CTRLREG		0x0F
-+
-+static uint8_t __iomem *rtc7301_base;
-+
-+#define read_reg(offset) (readb(rtc7301_base + offset) & 0xf)
-+#define write_reg(offset, data) writeb(data, rtc7301_base + (offset))
-+
-+#define rtc7301_isbusy() (read_reg(RTC7301_CTRLREG) & 1)
-+
-+static void rtc7301_init_settings(void)
-+{
-+	int i;
-+
-+	write_reg(RTC7301_CTRLREG, 2);
-+	write_reg(RTC7301_YEAR1000, 2);
-+	udelay(122);
-+
-+	/* bank 1 */
-+	write_reg(RTC7301_CTRLREG, 6);
-+	for (i=0; i<15; i++)
-+		write_reg(i, 0);
-+
-+	/* bank 2 */
-+	write_reg(RTC7301_CTRLREG, 14);
-+	for (i=0; i<15; i++)
-+		write_reg(i, 0);
-+	write_reg(RTC7301_CTRLREG, 0);
-+}
-+
-+static int rtc7301_get_datetime(struct device *dev, struct rtc_time *dt)
-+{
-+	int cnt;
-+	uint8_t buf[16];
-+
-+	cnt = 0;
-+	while (rtc7301_isbusy()) {
-+		udelay(244);
-+		if (cnt++ > 100) {
-+			dev_err(dev, "%s: timeout error %x\n", __func__, rtc7301_base[RTC7301_CTRLREG]);
-+			return -EIO;
-+		}
-+	}
-+
-+	for (cnt=0; cnt<16; cnt++)
-+		buf[cnt] = read_reg(cnt);
-+
-+	if (buf[RTC7301_SEC10] & 8) {
-+		dev_err(dev, "%s: RTC not set\n", __func__);
-+		return -EINVAL;
-+	}
-+
-+	memset(dt, 0, sizeof(*dt));
-+
-+	dt->tm_sec =  buf[RTC7301_SEC] + buf[RTC7301_SEC10]*10;
-+	dt->tm_min =  buf[RTC7301_MIN] + buf[RTC7301_MIN10]*10;
-+	dt->tm_hour = buf[RTC7301_HOUR] + buf[RTC7301_HOUR10]*10;
-+
-+	dt->tm_mday = buf[RTC7301_DAY] + buf[RTC7301_DAY10]*10;
-+	dt->tm_mon =  buf[RTC7301_MON] + buf[RTC7301_MON10]*10 - 1;
-+	dt->tm_year = buf[RTC7301_YEAR] + buf[RTC7301_YEAR10]*10 +
-+		      buf[RTC7301_YEAR100]*100 +
-+		      ((buf[RTC7301_YEAR1000] & 3)*1000) - 1900;
-+
-+	/* the rtc device may contain illegal values on power up
-+	 * according to the data sheet. make sure they are valid.
-+	 */
-+
-+	return rtc_valid_tm(dt);
-+}
-+
-+static int rtc7301_set_datetime(struct device *dev, struct rtc_time *dt)
-+{
-+	int data;
-+
-+	data = dt->tm_year + 1900;
-+	if (data >= 2100 || data < 1900)
-+		return -EINVAL;
-+
-+	write_reg(RTC7301_CTRLREG, 2);
-+       	udelay(122);
-+
-+	data = bin2bcd(dt->tm_sec);
-+	write_reg(RTC7301_SEC, data);
-+	write_reg(RTC7301_SEC10, (data >> 4));
-+
-+	data = bin2bcd(dt->tm_min);
-+	write_reg(RTC7301_MIN, data );
-+	write_reg(RTC7301_MIN10, (data >> 4));
-+
-+	data = bin2bcd(dt->tm_hour);
-+	write_reg(RTC7301_HOUR, data);
-+	write_reg(RTC7301_HOUR10, (data >> 4));
-+
-+	data = bin2bcd(dt->tm_mday);
-+	write_reg(RTC7301_DAY, data);
-+	write_reg(RTC7301_DAY10, (data>> 4));
-+
-+	data = bin2bcd(dt->tm_mon + 1);
-+	write_reg(RTC7301_MON, data);
-+	write_reg(RTC7301_MON10, (data >> 4));
-+
-+	data = bin2bcd(dt->tm_year % 100);
-+	write_reg(RTC7301_YEAR, data);
-+	write_reg(RTC7301_YEAR10, (data >> 4));
-+	data = bin2bcd((1900 + dt->tm_year) / 100);
-+	write_reg(RTC7301_YEAR100, data);
-+
-+	data = bin2bcd(dt->tm_wday);
-+	write_reg(RTC7301_WEEKDAY, data);
-+
-+	write_reg(RTC7301_CTRLREG, 0);
-+
-+	return 0;
-+}
-+
-+static const struct rtc_class_ops rtc7301_rtc_ops = {
-+	.read_time	= rtc7301_get_datetime,
-+	.set_time	= rtc7301_set_datetime,
-+};
-+
-+static int rtc7301_probe(struct platform_device *pdev)
-+{
-+	struct rtc_device *rtc;
-+	struct resource *res;
-+
-+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-+	if (!res)
-+		return -ENOENT;
-+
-+	rtc7301_base = ioremap_nocache(res->start, 0x1000 /*res->end - res->start + 1*/);
-+	if (!rtc7301_base)
-+		return -EINVAL;
-+
-+	rtc = rtc_device_register(RTC_NAME, &pdev->dev,
-+				&rtc7301_rtc_ops, THIS_MODULE);
-+	if (IS_ERR(rtc)) {
-+		iounmap(rtc7301_base);
-+		return PTR_ERR(rtc);
-+	}
-+
-+	platform_set_drvdata(pdev, rtc);
-+
-+	rtc7301_init_settings();
-+	return 0;
-+}
-+
-+static int rtc7301_remove(struct platform_device *pdev)
-+{
-+	struct rtc_device *rtc = platform_get_drvdata(pdev);
-+
-+	if (rtc)
-+		rtc_device_unregister(rtc);
-+	if (rtc7301_base)
-+		iounmap(rtc7301_base);
-+	return 0;
-+}
-+
-+static struct platform_driver rtc7301_driver = {
-+	.driver = {
-+		.name	= RTC_NAME,
-+		.owner	= THIS_MODULE,
-+	},
-+	.probe	= rtc7301_probe,
-+	.remove = rtc7301_remove,
-+};
-+
-+static __init int rtc7301_init(void)
-+{
-+	return platform_driver_register(&rtc7301_driver);
-+}
-+module_init(rtc7301_init);
-+
-+static __exit void rtc7301_exit(void)
-+{
-+	platform_driver_unregister(&rtc7301_driver);
-+}
-+module_exit(rtc7301_exit);
-+
-+MODULE_DESCRIPTION("Epson 7301 RTC driver");
-+MODULE_AUTHOR("Jose Vasconcellos <jvasco@verizon.net>");
-+MODULE_LICENSE("GPL");
-+MODULE_ALIAS("platform:" RTC_NAME);
-+MODULE_VERSION(RTC_VERSION);
--- a/target/linux/generic/pending-3.18/841-rtc_pt7c4338.patch	2022-03-22 08:54:47.341464893 +0800
+++ b/target/linux/generic/pending-3.18/841-rtc_pt7c4338.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,247 +0,0 @@
---- a/drivers/rtc/Kconfig
-+++ b/drivers/rtc/Kconfig
-@@ -567,6 +567,15 @@ config RTC_DRV_S5M
- 	  This driver can also be built as a module. If so, the module
- 	  will be called rtc-s5m.
- 
-+config RTC_DRV_PT7C4338
-+	tristate "Pericom Technology Inc. PT7C4338 RTC"
-+	help
-+	  If you say yes here you get support for the Pericom Technology
-+	  Inc. PT7C4338 RTC chip.
-+
-+	  This driver can also be built as a module. If so, the module
-+	  will be called rtc-pt7c4338.
-+
- endif # I2C
- 
- comment "SPI RTC drivers"
---- a/drivers/rtc/Makefile
-+++ b/drivers/rtc/Makefile
-@@ -106,6 +106,7 @@ obj-$(CONFIG_RTC_DRV_PL030)	+= rtc-pl030
- obj-$(CONFIG_RTC_DRV_PL031)	+= rtc-pl031.o
- obj-$(CONFIG_RTC_DRV_PM8XXX)	+= rtc-pm8xxx.o
- obj-$(CONFIG_RTC_DRV_PS3)	+= rtc-ps3.o
-+obj-$(CONFIG_RTC_DRV_PT7C4338)	+= rtc-pt7c4338.o
- obj-$(CONFIG_RTC_DRV_PUV3)	+= rtc-puv3.o
- obj-$(CONFIG_RTC_DRV_PXA)	+= rtc-pxa.o
- obj-$(CONFIG_RTC_DRV_R9701)	+= rtc-r9701.o
---- /dev/null
-+++ b/drivers/rtc/rtc-pt7c4338.c
-@@ -0,0 +1,216 @@
-+/*
-+ * Copyright 2010 Freescale Semiconductor, Inc.
-+ *
-+ * Author:	Priyanka Jain <Priyanka.Jain@freescale.com>
-+ *
-+ * See file CREDITS for list of people who contributed to this
-+ * project.
-+ *
-+ * This program is free software; you can redistribute it and/or
-+ * modify it under the terms of the GNU General Public License as
-+ * published by the Free Software Foundation; either version 2 of
-+ * the License, or (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful,
-+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
-+ * GNU General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-+ * MA 02111-1307 USA
-+ */
-+
-+/*
-+ * This file provides Date & Time support (no alarms) for PT7C4338 chip.
-+ *
-+ * This file is based on drivers/rtc/rtc-ds1307.c
-+ *
-+ * PT7C4338 chip is manufactured by Pericom Technology Inc.
-+ * It is a serial real-time clock which provides
-+ * 1)Low-power clock/calendar.
-+ * 2)Programmable square-wave output.
-+ * It has 56 bytes of nonvolatile RAM.
-+ */
-+
-+#include <linux/kernel.h>
-+#include <linux/module.h>
-+#include <linux/slab.h>
-+#include <linux/i2c.h>
-+#include <linux/rtc.h>
-+#include <linux/bcd.h>
-+
-+/* RTC register addresses */
-+#define PT7C4338_REG_SECONDS          0x00
-+#define PT7C4338_REG_MINUTES          0x01
-+#define PT7C4338_REG_HOURS            0x02
-+#define PT7C4338_REG_AMPM             0x02
-+#define PT7C4338_REG_DAY              0x03
-+#define PT7C4338_REG_DATE             0x04
-+#define PT7C4338_REG_MONTH            0x05
-+#define PT7C4338_REG_YEAR             0x06
-+#define PT7C4338_REG_CTRL_STAT        0x07
-+
-+/* RTC second register address bit */
-+#define PT7C4338_SEC_BIT_CH           0x80	/*Clock Halt (in Register 0)*/
-+
-+/* RTC control and status register bits */
-+#define PT7C4338_CTRL_STAT_BIT_RS0    0x1	/*Rate select 0*/
-+#define PT7C4338_CTRL_STAT_BIT_RS1    0x2	/*Rate select 1*/
-+#define PT7C4338_CTRL_STAT_BIT_SQWE   0x10	/*Square Wave Enable*/
-+#define PT7C4338_CTRL_STAT_BIT_OSF    0x20	/*Oscillator Stop Flag*/
-+#define PT7C4338_CTRL_STAT_BIT_OUT    0x80	/*Output Level Control*/
-+
-+static const struct i2c_device_id pt7c4338_id[] = {
-+	{ "pt7c4338", 0 },
-+	{ }
-+};
-+MODULE_DEVICE_TABLE(i2c, pt7c4338_id);
-+
-+struct pt7c4338{
-+	struct i2c_client *client;
-+	struct rtc_device *rtc;
-+};
-+
-+static int pt7c4338_read_time(struct device *dev, struct rtc_time *time)
-+{
-+	struct i2c_client *client = to_i2c_client(dev);
-+	int ret;
-+	u8 buf[7];
-+	u8 year, month, day, hour, minute, second;
-+	u8 week, twelve_hr, am_pm;
-+
-+	ret = i2c_smbus_read_i2c_block_data(client,
-+			PT7C4338_REG_SECONDS, 7, buf);
-+	if (ret < 0)
-+		return ret;
-+	if (ret < 7)
-+		return -EIO;
-+
-+	second = buf[0];
-+	minute = buf[1];
-+	hour = buf[2];
-+	week = buf[3];
-+	day = buf[4];
-+	month = buf[5];
-+	year = buf[6];
-+
-+	/* Extract additional information for AM/PM */
-+	twelve_hr = hour & 0x40;
-+	am_pm = hour & 0x20;
-+
-+	/* Write to rtc_time structure */
-+	time->tm_sec = bcd2bin(second & 0x7f);
-+	time->tm_min = bcd2bin(minute & 0x7f);
-+	if (twelve_hr) {
-+		/* Convert to 24 hr */
-+		if (am_pm)
-+			time->tm_hour = bcd2bin(hour & 0x10) + 12;
-+		else
-+			time->tm_hour = bcd2bin(hour & 0xBF);
-+	} else {
-+		time->tm_hour = bcd2bin(hour);
-+	}
-+
-+	time->tm_wday = bcd2bin(week & 0x07) - 1;
-+	time->tm_mday = bcd2bin(day & 0x3f);
-+	time->tm_mon = bcd2bin(month & 0x1F) - 1;
-+	/* assume 20YY not 19YY */
-+	time->tm_year = bcd2bin(year) + 100;
-+
-+	return 0;
-+}
-+
-+static int pt7c4338_set_time(struct device *dev, struct rtc_time *time)
-+{
-+	struct i2c_client *client = to_i2c_client(dev);
-+	u8 buf[7];
-+
-+	/* Extract time from rtc_time and load into pt7c4338*/
-+	buf[0] = bin2bcd(time->tm_sec);
-+	buf[1] = bin2bcd(time->tm_min);
-+	buf[2] = bin2bcd(time->tm_hour);
-+	buf[3] = bin2bcd(time->tm_wday + 1); /* Day of the week */
-+	buf[4] = bin2bcd(time->tm_mday); /* Date */
-+	buf[5] = bin2bcd(time->tm_mon + 1);
-+
-+	/* assume 20YY not 19YY */
-+	if (time->tm_year >= 100)
-+		buf[6] = bin2bcd(time->tm_year - 100);
-+	else
-+		buf[6] = bin2bcd(time->tm_year);
-+
-+	return i2c_smbus_write_i2c_block_data(client,
-+					PT7C4338_REG_SECONDS, 7, buf);
-+}
-+
-+static const struct rtc_class_ops pt7c4338_rtc_ops = {
-+	.read_time = pt7c4338_read_time,
-+	.set_time = pt7c4338_set_time,
-+};
-+
-+static int pt7c4338_probe(struct i2c_client *client,
-+		const struct i2c_device_id *id)
-+{
-+	struct pt7c4338 *pt7c4338;
-+	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
-+	int ret;
-+
-+	pt7c4338 = kzalloc(sizeof(struct pt7c4338), GFP_KERNEL);
-+	if (!pt7c4338)
-+		return -ENOMEM;
-+
-+	pt7c4338->client = client;
-+	i2c_set_clientdata(client, pt7c4338);
-+	pt7c4338->rtc = rtc_device_register(client->name, &client->dev,
-+					&pt7c4338_rtc_ops, THIS_MODULE);
-+	if (IS_ERR(pt7c4338->rtc)) {
-+		ret = PTR_ERR(pt7c4338->rtc);
-+		dev_err(&client->dev, "unable to register the class device\n");
-+		goto out_free;
-+	}
-+
-+	return 0;
-+out_free:
-+	i2c_set_clientdata(client, NULL);
-+	kfree(pt7c4338);
-+	return ret;
-+}
-+
-+static int pt7c4338_remove(struct i2c_client *client)
-+{
-+	struct pt7c4338 *pt7c4338 = i2c_get_clientdata(client);
-+
-+	rtc_device_unregister(pt7c4338->rtc);
-+	i2c_set_clientdata(client, NULL);
-+	kfree(pt7c4338);
-+	return 0;
-+}
-+
-+static struct i2c_driver pt7c4338_driver = {
-+	.driver = {
-+		.name = "rtc-pt7c4338",
-+		.owner = THIS_MODULE,
-+	},
-+	.probe = pt7c4338_probe,
-+	.remove = pt7c4338_remove,
-+	.id_table = pt7c4338_id,
-+};
-+
-+static int __init pt7c4338_init(void)
-+{
-+	return i2c_add_driver(&pt7c4338_driver);
-+}
-+
-+static void __exit pt7c4338_exit(void)
-+{
-+	i2c_del_driver(&pt7c4338_driver);
-+}
-+
-+module_init(pt7c4338_init);
-+module_exit(pt7c4338_exit);
-+
-+MODULE_AUTHOR("Priyanka Jain <Priyanka.Jain@freescale.com>");
-+MODULE_DESCRIPTION("pericom Technology Inc. PT7C4338 RTC Driver");
-+MODULE_LICENSE("GPL");
--- a/target/linux/generic/pending-3.18/861-04_spi_gpio_implement_spi_delay.patch	2022-03-22 08:54:47.342464894 +0800
+++ b/target/linux/generic/pending-3.18/861-04_spi_gpio_implement_spi_delay.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,58 +0,0 @@
-Implement the SPI-GPIO delay function for busses that need speed limitation.
-
---mb
-
-
-
---- a/drivers/spi/spi-gpio.c
-+++ b/drivers/spi/spi-gpio.c
-@@ -21,6 +21,7 @@
- #include <linux/module.h>
- #include <linux/platform_device.h>
- #include <linux/gpio.h>
-+#include <linux/delay.h>
- #include <linux/of.h>
- #include <linux/of_device.h>
- #include <linux/of_gpio.h>
-@@ -73,6 +74,7 @@ struct spi_gpio {
-  *		#define	SPI_MOSI_GPIO	120
-  *		#define	SPI_SCK_GPIO	121
-  *		#define	SPI_N_CHIPSEL	4
-+ *		#undef NEED_SPIDELAY
-  *		#include "spi-gpio.c"
-  */
- 
-@@ -80,6 +82,7 @@ struct spi_gpio {
- #define DRIVER_NAME	"spi_gpio"
- 
- #define GENERIC_BITBANG	/* vs tight inlines */
-+#define NEED_SPIDELAY	1
- 
- /* all functions referencing these symbols must define pdata */
- #define SPI_MISO_GPIO	((pdata)->miso)
-@@ -130,12 +133,20 @@ static inline int getmiso(const struct s
- #undef pdata
- 
- /*
-- * NOTE:  this clocks "as fast as we can".  It "should" be a function of the
-- * requested device clock.  Software overhead means we usually have trouble
-- * reaching even one Mbit/sec (except when we can inline bitops), so for now
-- * we'll just assume we never need additional per-bit slowdowns.
-+ * NOTE:  to clock "as fast as we can", set spi_device.max_speed_hz
-+ * and spi_transfer.speed_hz to 0.
-+ * Otherwise this is a function of the requested device clock.
-+ * Software overhead means we usually have trouble
-+ * reaching even one Mbit/sec (except when we can inline bitops). So on small
-+ * embedded devices with fast SPI slaves you usually don't need a delay.
-  */
--#define spidelay(nsecs)	do {} while (0)
-+static inline void spidelay(unsigned nsecs)
-+{
-+#ifdef NEED_SPIDELAY
-+	if (unlikely(nsecs))
-+		ndelay(nsecs);
-+#endif /* NEED_SPIDELAY */
-+}
- 
- #include "spi-bitbang-txrx.h"
- 
--- a/target/linux/generic/pending-3.18/862-gpio_spi_driver.patch	2022-03-22 08:54:47.342464894 +0800
+++ b/target/linux/generic/pending-3.18/862-gpio_spi_driver.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,373 +0,0 @@
-THIS CODE IS DEPRECATED.
-
-Please use the new mainline SPI-GPIO driver, as of 2.6.29.
-
---mb
-
-
-
----
- drivers/spi/Kconfig              |    9 +
- drivers/spi/Makefile             |    1 
- drivers/spi/spi_gpio_old.c       |  251 +++++++++++++++++++++++++++++++++++++++
- include/linux/spi/spi_gpio_old.h |   73 +++++++++++
- 4 files changed, 334 insertions(+)
-
---- /dev/null
-+++ b/include/linux/spi/spi_gpio_old.h
-@@ -0,0 +1,73 @@
-+/*
-+ * spi_gpio interface to platform code
-+ *
-+ * Copyright (c) 2008 Piotr Skamruk
-+ * Copyright (c) 2008 Michael Buesch
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License version 2 as
-+ * published by the Free Software Foundation.
-+ */
-+#ifndef _LINUX_SPI_SPI_GPIO
-+#define _LINUX_SPI_SPI_GPIO
-+
-+#include <linux/types.h>
-+#include <linux/spi/spi.h>
-+
-+
-+/**
-+ * struct spi_gpio_platform_data - Data definitions for a SPI-GPIO device.
-+ *
-+ * This structure holds information about a GPIO-based SPI device.
-+ *
-+ * @pin_clk: The GPIO pin number of the CLOCK pin.
-+ *
-+ * @pin_miso: The GPIO pin number of the MISO pin.
-+ *
-+ * @pin_mosi: The GPIO pin number of the MOSI pin.
-+ *
-+ * @pin_cs: The GPIO pin number of the CHIPSELECT pin.
-+ *
-+ * @cs_activelow: If true, the chip is selected when the CS line is low.
-+ *
-+ * @no_spi_delay: If true, no delay is done in the lowlevel bitbanging.
-+ *                Note that doing no delay is not standards compliant,
-+ *                but it might be needed to speed up transfers on some
-+ *                slow embedded machines.
-+ *
-+ * @boardinfo_setup: This callback is called after the
-+ *                   SPI master device was registered, but before the
-+ *                   device is registered.
-+ * @boardinfo_setup_data: Data argument passed to boardinfo_setup().
-+ */
-+struct spi_gpio_platform_data {
-+	unsigned int pin_clk;
-+	unsigned int pin_miso;
-+	unsigned int pin_mosi;
-+	unsigned int pin_cs;
-+	bool cs_activelow;
-+	bool no_spi_delay;
-+	int (*boardinfo_setup)(struct spi_board_info *bi,
-+			       struct spi_master *master,
-+			       void *data);
-+	void *boardinfo_setup_data;
-+};
-+
-+/**
-+ * SPI_GPIO_PLATDEV_NAME - The platform device name string.
-+ *
-+ * The name string that has to be used for platform_device_alloc
-+ * when allocating a spi-gpio device.
-+ */
-+#define SPI_GPIO_PLATDEV_NAME	"spi-gpio"
-+
-+/**
-+ * spi_gpio_next_id - Get another platform device ID number.
-+ *
-+ * This returns the next platform device ID number that has to be used
-+ * for platform_device_alloc. The ID is opaque and should not be used for
-+ * anything else.
-+ */
-+int spi_gpio_next_id(void);
-+
-+#endif /* _LINUX_SPI_SPI_GPIO */
---- /dev/null
-+++ b/drivers/spi/spi_gpio_old.c
-@@ -0,0 +1,251 @@
-+/*
-+ * Bitbanging SPI bus driver using GPIO API
-+ *
-+ * Copyright (c) 2008 Piotr Skamruk
-+ * Copyright (c) 2008 Michael Buesch
-+ *
-+ * based on spi_s3c2410_gpio.c
-+ *   Copyright (c) 2006 Ben Dooks
-+ *   Copyright (c) 2006 Simtec Electronics
-+ * and on i2c-gpio.c
-+ *   Copyright (C) 2007 Atmel Corporation
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License version 2 as
-+ * published by the Free Software Foundation.
-+ */
-+
-+#include <linux/kernel.h>
-+#include <linux/init.h>
-+#include <linux/delay.h>
-+#include <linux/spinlock.h>
-+#include <linux/workqueue.h>
-+#include <linux/module.h>
-+#include <linux/platform_device.h>
-+#include <linux/spi/spi.h>
-+#include <linux/spi/spi_bitbang.h>
-+#include <linux/spi/spi_gpio_old.h>
-+#include <linux/gpio.h>
-+#include <asm/atomic.h>
-+
-+
-+struct spi_gpio {
-+	struct spi_bitbang bitbang;
-+	struct spi_gpio_platform_data *info;
-+	struct platform_device *pdev;
-+	struct spi_board_info bi;
-+};
-+
-+
-+static inline struct spi_gpio *spidev_to_sg(struct spi_device *dev)
-+{
-+	return dev->controller_data;
-+}
-+
-+static inline void setsck(struct spi_device *dev, int val)
-+{
-+	struct spi_gpio *sp = spidev_to_sg(dev);
-+	gpio_set_value(sp->info->pin_clk, val ? 1 : 0);
-+}
-+
-+static inline void setmosi(struct spi_device *dev, int val)
-+{
-+	struct spi_gpio *sp = spidev_to_sg(dev);
-+	gpio_set_value(sp->info->pin_mosi, val ? 1 : 0);
-+}
-+
-+static inline u32 getmiso(struct spi_device *dev)
-+{
-+	struct spi_gpio *sp = spidev_to_sg(dev);
-+	return gpio_get_value(sp->info->pin_miso) ? 1 : 0;
-+}
-+
-+static inline void do_spidelay(struct spi_device *dev, unsigned nsecs)
-+{
-+	struct spi_gpio *sp = spidev_to_sg(dev);
-+
-+	if (!sp->info->no_spi_delay)
-+		ndelay(nsecs);
-+}
-+
-+#define spidelay(nsecs) do {					\
-+	/* Steal the spi_device pointer from our caller.	\
-+	 * The bitbang-API should probably get fixed here... */	\
-+	do_spidelay(spi, nsecs);				\
-+  } while (0)
-+
-+#define EXPAND_BITBANG_TXRX
-+#include "spi-bitbang-txrx.h"
-+
-+static u32 spi_gpio_txrx_mode0(struct spi_device *spi,
-+			       unsigned nsecs, u32 word, u8 bits)
-+{
-+	return bitbang_txrx_be_cpha0(spi, nsecs, 0, 0, word, bits);
-+}
-+
-+static u32 spi_gpio_txrx_mode1(struct spi_device *spi,
-+			       unsigned nsecs, u32 word, u8 bits)
-+{
-+	return bitbang_txrx_be_cpha1(spi, nsecs, 0, 0, word, bits);
-+}
-+
-+static u32 spi_gpio_txrx_mode2(struct spi_device *spi,
-+			       unsigned nsecs, u32 word, u8 bits)
-+{
-+	return bitbang_txrx_be_cpha0(spi, nsecs, 1, 0, word, bits);
-+}
-+
-+static u32 spi_gpio_txrx_mode3(struct spi_device *spi,
-+			       unsigned nsecs, u32 word, u8 bits)
-+{
-+	return bitbang_txrx_be_cpha1(spi, nsecs, 1, 0, word, bits);
-+}
-+
-+static void spi_gpio_chipselect(struct spi_device *dev, int on)
-+{
-+	struct spi_gpio *sp = spidev_to_sg(dev);
-+
-+	if (sp->info->cs_activelow)
-+		on = !on;
-+	gpio_set_value(sp->info->pin_cs, on ? 1 : 0);
-+}
-+
-+static int spi_gpio_probe(struct platform_device *pdev)
-+{
-+	struct spi_master *master;
-+	struct spi_gpio_platform_data *pdata;
-+	struct spi_gpio *sp;
-+	struct spi_device *spidev;
-+	int err;
-+
-+	pdata = pdev->dev.platform_data;
-+	if (!pdata)
-+		return -ENXIO;
-+
-+	err = -ENOMEM;
-+	master = spi_alloc_master(&pdev->dev, sizeof(struct spi_gpio));
-+	if (!master)
-+		goto err_alloc_master;
-+
-+	sp = spi_master_get_devdata(master);
-+	platform_set_drvdata(pdev, sp);
-+	sp->info = pdata;
-+
-+	err = gpio_request(pdata->pin_clk, "spi_clock");
-+	if (err)
-+		goto err_request_clk;
-+	err = gpio_request(pdata->pin_mosi, "spi_mosi");
-+	if (err)
-+		goto err_request_mosi;
-+	err = gpio_request(pdata->pin_miso, "spi_miso");
-+	if (err)
-+		goto err_request_miso;
-+	err = gpio_request(pdata->pin_cs, "spi_cs");
-+	if (err)
-+		goto err_request_cs;
-+
-+	sp->bitbang.master = spi_master_get(master);
-+	sp->bitbang.master->bus_num = -1;
-+	sp->bitbang.master->num_chipselect = 1;
-+	sp->bitbang.chipselect = spi_gpio_chipselect;
-+	sp->bitbang.txrx_word[SPI_MODE_0] = spi_gpio_txrx_mode0;
-+	sp->bitbang.txrx_word[SPI_MODE_1] = spi_gpio_txrx_mode1;
-+	sp->bitbang.txrx_word[SPI_MODE_2] = spi_gpio_txrx_mode2;
-+	sp->bitbang.txrx_word[SPI_MODE_3] = spi_gpio_txrx_mode3;
-+
-+	gpio_direction_output(pdata->pin_clk, 0);
-+	gpio_direction_output(pdata->pin_mosi, 0);
-+	gpio_direction_output(pdata->pin_cs,
-+			      pdata->cs_activelow ? 1 : 0);
-+	gpio_direction_input(pdata->pin_miso);
-+
-+	err = spi_bitbang_start(&sp->bitbang);
-+	if (err)
-+		goto err_no_bitbang;
-+	err = pdata->boardinfo_setup(&sp->bi, master,
-+				     pdata->boardinfo_setup_data);
-+	if (err)
-+		goto err_bi_setup;
-+	sp->bi.controller_data = sp;
-+	spidev = spi_new_device(master, &sp->bi);
-+	if (!spidev)
-+		goto err_new_dev;
-+
-+	return 0;
-+
-+err_new_dev:
-+err_bi_setup:
-+	spi_bitbang_stop(&sp->bitbang);
-+err_no_bitbang:
-+	spi_master_put(sp->bitbang.master);
-+	gpio_free(pdata->pin_cs);
-+err_request_cs:
-+	gpio_free(pdata->pin_miso);
-+err_request_miso:
-+	gpio_free(pdata->pin_mosi);
-+err_request_mosi:
-+	gpio_free(pdata->pin_clk);
-+err_request_clk:
-+	kfree(master);
-+
-+err_alloc_master:
-+	return err;
-+}
-+
-+static int spi_gpio_remove(struct platform_device *pdev)
-+{
-+	struct spi_gpio *sp;
-+	struct spi_gpio_platform_data *pdata;
-+
-+	pdata = pdev->dev.platform_data;
-+	sp = platform_get_drvdata(pdev);
-+
-+	gpio_free(pdata->pin_clk);
-+	gpio_free(pdata->pin_mosi);
-+	gpio_free(pdata->pin_miso);
-+	gpio_free(pdata->pin_cs);
-+	spi_bitbang_stop(&sp->bitbang);
-+	spi_master_put(sp->bitbang.master);
-+
-+	return 0;
-+}
-+
-+static struct platform_driver spi_gpio_driver = {
-+	.driver		= {
-+		.name	= SPI_GPIO_PLATDEV_NAME,
-+		.owner	= THIS_MODULE,
-+	},
-+	.probe		= spi_gpio_probe,
-+	.remove		= spi_gpio_remove,
-+};
-+
-+int spi_gpio_next_id(void)
-+{
-+	static atomic_t counter = ATOMIC_INIT(-1);
-+
-+	return atomic_inc_return(&counter);
-+}
-+EXPORT_SYMBOL(spi_gpio_next_id);
-+
-+static int __init spi_gpio_init(void)
-+{
-+	int err;
-+
-+	err = platform_driver_register(&spi_gpio_driver);
-+	if (err)
-+		printk(KERN_ERR "spi-gpio: register failed: %d\n", err);
-+
-+	return err;
-+}
-+module_init(spi_gpio_init);
-+
-+static void __exit spi_gpio_exit(void)
-+{
-+	platform_driver_unregister(&spi_gpio_driver);
-+}
-+module_exit(spi_gpio_exit);
-+
-+MODULE_AUTHOR("Piot Skamruk <piotr.skamruk at gmail.com>");
-+MODULE_AUTHOR("Michael Buesch");
-+MODULE_DESCRIPTION("Platform independent GPIO bitbanging SPI driver");
-+MODULE_LICENSE("GPL v2");
---- a/drivers/spi/Kconfig
-+++ b/drivers/spi/Kconfig
-@@ -225,6 +225,15 @@ config SPI_GPIO
- 	  GPIO operations, you should be able to leverage that for better
- 	  speed with a custom version of this driver; see the source code.
- 
-+config SPI_GPIO_OLD
-+	tristate "Old GPIO API based bitbanging SPI controller (DEPRECATED)"
-+	depends on SPI_MASTER && GPIOLIB
-+	select SPI_BITBANG
-+	help
-+	  This code is deprecated. Please use the new mainline SPI-GPIO driver.
-+
-+	  If unsure, say N.
-+
- config SPI_IMX
- 	tristate "Freescale i.MX SPI controllers"
- 	depends on ARCH_MXC || COMPILE_TEST
---- a/drivers/spi/Makefile
-+++ b/drivers/spi/Makefile
-@@ -40,6 +40,7 @@ obj-$(CONFIG_SPI_FSL_LIB)		+= spi-fsl-li
- obj-$(CONFIG_SPI_FSL_ESPI)		+= spi-fsl-espi.o
- obj-$(CONFIG_SPI_FSL_SPI)		+= spi-fsl-spi.o
- obj-$(CONFIG_SPI_GPIO)			+= spi-gpio.o
-+obj-$(CONFIG_SPI_GPIO_OLD)		+= spi_gpio_old.o
- obj-$(CONFIG_SPI_IMX)			+= spi-imx.o
- obj-$(CONFIG_SPI_LM70_LLP)		+= spi-lm70llp.o
- obj-$(CONFIG_SPI_MPC512x_PSC)		+= spi-mpc512x-psc.o
--- a/target/linux/generic/pending-3.18/870-hifn795x_byteswap.patch	2022-03-22 08:54:47.343464896 +0800
+++ b/target/linux/generic/pending-3.18/870-hifn795x_byteswap.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,17 +0,0 @@
---- a/drivers/crypto/hifn_795x.c
-+++ b/drivers/crypto/hifn_795x.c
-@@ -682,12 +682,12 @@ static inline u32 hifn_read_1(struct hif
- 
- static inline void hifn_write_0(struct hifn_device *dev, u32 reg, u32 val)
- {
--	writel((__force u32)cpu_to_le32(val), dev->bar[0] + reg);
-+	writel(val, dev->bar[0] + reg);
- }
- 
- static inline void hifn_write_1(struct hifn_device *dev, u32 reg, u32 val)
- {
--	writel((__force u32)cpu_to_le32(val), dev->bar[1] + reg);
-+	writel(val, dev->bar[1] + reg);
- }
- 
- static void hifn_wait_puc(struct hifn_device *dev)
--- a/target/linux/generic/pending-3.18/890-8250_optional_sysrq.patch	2022-03-22 08:54:47.343464896 +0800
+++ b/target/linux/generic/pending-3.18/890-8250_optional_sysrq.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,24 +0,0 @@
---- a/drivers/tty/serial/8250/8250_core.c
-+++ b/drivers/tty/serial/8250/8250_core.c
-@@ -16,7 +16,7 @@
-  *  membase is an 'ioremapped' cookie.
-  */
- 
--#if defined(CONFIG_SERIAL_8250_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
-+#if defined(CONFIG_SERIAL_8250_SYSRQ) && defined(CONFIG_MAGIC_SYSRQ)
- #define SUPPORT_SYSRQ
- #endif
- 
---- a/drivers/tty/serial/8250/Kconfig
-+++ b/drivers/tty/serial/8250/Kconfig
-@@ -91,6 +91,10 @@ config SERIAL_8250_CONSOLE
- 
- 	  If unsure, say N.
- 
-+config SERIAL_8250_SYSRQ
-+	bool "Magic sysrq support on 8250/16550 devices"
-+	depends on SERIAL_8250_CONSOLE
-+
- config SERIAL_8250_GSC
- 	tristate
- 	depends on SERIAL_8250 && GSC
--- a/target/linux/generic/pending-3.18/901-debloat_sock_diag.patch	2022-03-22 08:54:47.343464896 +0800
+++ b/target/linux/generic/pending-3.18/901-debloat_sock_diag.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,65 +0,0 @@
---- a/net/Kconfig
-+++ b/net/Kconfig
-@@ -89,6 +89,9 @@ source "net/netlabel/Kconfig"
- 
- endif # if INET
- 
-+config SOCK_DIAG
-+	bool
-+
- config NETWORK_SECMARK
- 	bool "Security Marking"
- 	help
---- a/net/core/Makefile
-+++ b/net/core/Makefile
-@@ -9,8 +9,9 @@ obj-$(CONFIG_SYSCTL) += sysctl_net_core.
- 
- obj-y		     += dev.o ethtool.o dev_addr_lists.o dst.o netevent.o \
- 			neighbour.o rtnetlink.o utils.o link_watch.o filter.o \
--			sock_diag.o dev_ioctl.o tso.o
-+			dev_ioctl.o tso.o
- 
-+obj-$(CONFIG_SOCK_DIAG) += sock_diag.o
- obj-$(CONFIG_XFRM) += flow.o
- obj-y += net-sysfs.o
- obj-$(CONFIG_PROC_FS) += net-procfs.o
---- a/net/ipv4/Kconfig
-+++ b/net/ipv4/Kconfig
-@@ -419,6 +419,7 @@ config INET_LRO
- 
- config INET_DIAG
- 	tristate "INET: socket monitoring interface"
-+	select SOCK_DIAG
- 	default y
- 	---help---
- 	  Support for INET (TCP, DCCP, etc) socket monitoring interface used by
---- a/net/unix/Kconfig
-+++ b/net/unix/Kconfig
-@@ -22,6 +22,7 @@ config UNIX
- config UNIX_DIAG
- 	tristate "UNIX: socket monitoring interface"
- 	depends on UNIX
-+	select SOCK_DIAG
- 	default n
- 	---help---
- 	  Support for UNIX socket monitoring interface used by the ss tool.
---- a/net/netlink/Kconfig
-+++ b/net/netlink/Kconfig
-@@ -4,6 +4,7 @@
- 
- config NETLINK_DIAG
- 	tristate "NETLINK: socket monitoring interface"
-+	select SOCK_DIAG
- 	default n
- 	---help---
- 	  Support for NETLINK socket monitoring interface used by the ss tool.
---- a/net/packet/Kconfig
-+++ b/net/packet/Kconfig
-@@ -18,6 +18,7 @@ config PACKET
- config PACKET_DIAG
- 	tristate "Packet: sockets monitoring interface"
- 	depends on PACKET
-+	select SOCK_DIAG
- 	default n
- 	---help---
- 	  Support for PF_PACKET sockets monitoring interface used by the ss tool.
--- a/target/linux/generic/pending-3.18/902-debloat_proc.patch	2022-03-22 08:54:47.343464896 +0800
+++ b/target/linux/generic/pending-3.18/902-debloat_proc.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,342 +0,0 @@
---- a/fs/locks.c
-+++ b/fs/locks.c
-@@ -2620,6 +2620,8 @@ static const struct file_operations proc
- 
- static int __init proc_locks_init(void)
- {
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return 0;
- 	proc_create("locks", 0, NULL, &proc_locks_operations);
- 	return 0;
- }
---- a/fs/proc/Kconfig
-+++ b/fs/proc/Kconfig
-@@ -71,3 +71,8 @@ config PROC_PAGE_MONITOR
- 	  /proc/pid/smaps, /proc/pid/clear_refs, /proc/pid/pagemap,
- 	  /proc/kpagecount, and /proc/kpageflags. Disabling these
-           interfaces will reduce the size of the kernel by approximately 4kb.
-+
-+config PROC_STRIPPED
-+	default n
-+	depends on EXPERT
-+	bool "Strip non-essential /proc functionality to reduce code size"
---- a/fs/proc/consoles.c
-+++ b/fs/proc/consoles.c
-@@ -106,6 +106,9 @@ static const struct file_operations proc
- 
- static int __init proc_consoles_init(void)
- {
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return 0;
-+
- 	proc_create("consoles", 0, NULL, &proc_consoles_operations);
- 	return 0;
- }
---- a/fs/proc/proc_tty.c
-+++ b/fs/proc/proc_tty.c
-@@ -144,7 +144,10 @@ static const struct file_operations proc
- void proc_tty_register_driver(struct tty_driver *driver)
- {
- 	struct proc_dir_entry *ent;
--		
-+
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return;
-+
- 	if (!driver->driver_name || driver->proc_entry ||
- 	    !driver->ops->proc_fops)
- 		return;
-@@ -161,6 +164,9 @@ void proc_tty_unregister_driver(struct t
- {
- 	struct proc_dir_entry *ent;
- 
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return;
-+
- 	ent = driver->proc_entry;
- 	if (!ent)
- 		return;
-@@ -175,6 +181,9 @@ void proc_tty_unregister_driver(struct t
-  */
- void __init proc_tty_init(void)
- {
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return;
-+
- 	if (!proc_mkdir("tty", NULL))
- 		return;
- 	proc_mkdir("tty/ldisc", NULL);	/* Preserved: it's userspace visible */
---- a/kernel/exec_domain.c
-+++ b/kernel/exec_domain.c
-@@ -176,6 +176,8 @@ static const struct file_operations exec
- 
- static int __init proc_execdomains_init(void)
- {
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return 0;
- 	proc_create("execdomains", 0, NULL, &execdomains_proc_fops);
- 	return 0;
- }
---- a/kernel/irq/proc.c
-+++ b/kernel/irq/proc.c
-@@ -330,6 +330,9 @@ void register_irq_proc(unsigned int irq,
- 	static DEFINE_MUTEX(register_lock);
- 	char name [MAX_NAMELEN];
- 
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED) && !IS_ENABLED(CONFIG_SMP))
-+		return;
-+
- 	if (!root_irq_dir || (desc->irq_data.chip == &no_irq_chip))
- 		return;
- 
-@@ -379,6 +382,9 @@ void unregister_irq_proc(unsigned int ir
- {
- 	char name [MAX_NAMELEN];
- 
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED) && !IS_ENABLED(CONFIG_SMP))
-+		return;
-+
- 	if (!root_irq_dir || !desc->dir)
- 		return;
- #ifdef CONFIG_SMP
-@@ -414,6 +420,9 @@ void init_irq_proc(void)
- 	unsigned int irq;
- 	struct irq_desc *desc;
- 
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED) && !IS_ENABLED(CONFIG_SMP))
-+		return;
-+
- 	/* create /proc/irq */
- 	root_irq_dir = proc_mkdir("irq", NULL);
- 	if (!root_irq_dir)
---- a/kernel/time/timer_list.c
-+++ b/kernel/time/timer_list.c
-@@ -362,6 +362,9 @@ static int __init init_timer_list_procfs
- {
- 	struct proc_dir_entry *pe;
- 
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return 0;
-+
- 	pe = proc_create("timer_list", 0400, NULL, &timer_list_fops);
- 	if (!pe)
- 		return -ENOMEM;
---- a/mm/vmalloc.c
-+++ b/mm/vmalloc.c
-@@ -2663,6 +2663,8 @@ static const struct file_operations proc
- 
- static int __init proc_vmalloc_init(void)
- {
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return 0;
- 	proc_create("vmallocinfo", S_IRUSR, NULL, &proc_vmalloc_operations);
- 	return 0;
- }
---- a/mm/vmstat.c
-+++ b/mm/vmstat.c
-@@ -1424,10 +1424,12 @@ static int __init setup_vmstat(void)
- 	cpu_notifier_register_done();
- #endif
- #ifdef CONFIG_PROC_FS
--	proc_create("buddyinfo", S_IRUGO, NULL, &fragmentation_file_operations);
--	proc_create("pagetypeinfo", S_IRUGO, NULL, &pagetypeinfo_file_ops);
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED)) {
-+		proc_create("buddyinfo", S_IRUGO, NULL, &fragmentation_file_operations);
-+		proc_create("pagetypeinfo", S_IRUGO, NULL, &pagetypeinfo_file_ops);
-+		proc_create("zoneinfo", S_IRUGO, NULL, &proc_zoneinfo_file_operations);
-+	}
- 	proc_create("vmstat", S_IRUGO, NULL, &proc_vmstat_file_operations);
--	proc_create("zoneinfo", S_IRUGO, NULL, &proc_zoneinfo_file_operations);
- #endif
- 	return 0;
- }
---- a/net/8021q/vlanproc.c
-+++ b/net/8021q/vlanproc.c
-@@ -127,6 +127,9 @@ void vlan_proc_cleanup(struct net *net)
- {
- 	struct vlan_net *vn = net_generic(net, vlan_net_id);
- 
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return;
-+
- 	if (vn->proc_vlan_conf)
- 		remove_proc_entry(name_conf, vn->proc_vlan_dir);
- 
-@@ -146,6 +149,9 @@ int __net_init vlan_proc_init(struct net
- {
- 	struct vlan_net *vn = net_generic(net, vlan_net_id);
- 
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return 0;
-+
- 	vn->proc_vlan_dir = proc_net_mkdir(net, name_root, net->proc_net);
- 	if (!vn->proc_vlan_dir)
- 		goto err;
---- a/net/core/sock.c
-+++ b/net/core/sock.c
-@@ -2945,6 +2945,8 @@ static __net_initdata struct pernet_oper
- 
- static int __init proto_init(void)
- {
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return 0;
- 	return register_pernet_subsys(&proto_net_ops);
- }
- 
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -2490,10 +2490,12 @@ static const struct file_operations fib_
- 
- int __net_init fib_proc_init(struct net *net)
- {
--	if (!proc_create("fib_trie", S_IRUGO, net->proc_net, &fib_trie_fops))
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED) &&
-+		!proc_create("fib_trie", S_IRUGO, net->proc_net, &fib_trie_fops))
- 		goto out1;
- 
--	if (!proc_create("fib_triestat", S_IRUGO, net->proc_net,
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED) &&
-+		!proc_create("fib_triestat", S_IRUGO, net->proc_net,
- 			 &fib_triestat_fops))
- 		goto out2;
- 
-@@ -2503,17 +2505,21 @@ int __net_init fib_proc_init(struct net
- 	return 0;
- 
- out3:
--	remove_proc_entry("fib_triestat", net->proc_net);
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		remove_proc_entry("fib_triestat", net->proc_net);
- out2:
--	remove_proc_entry("fib_trie", net->proc_net);
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		remove_proc_entry("fib_trie", net->proc_net);
- out1:
- 	return -ENOMEM;
- }
- 
- void __net_exit fib_proc_exit(struct net *net)
- {
--	remove_proc_entry("fib_trie", net->proc_net);
--	remove_proc_entry("fib_triestat", net->proc_net);
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED)) {
-+		remove_proc_entry("fib_trie", net->proc_net);
-+		remove_proc_entry("fib_triestat", net->proc_net);
-+	}
- 	remove_proc_entry("route", net->proc_net);
- }
- 
---- a/net/ipv4/proc.c
-+++ b/net/ipv4/proc.c
-@@ -524,6 +524,9 @@ static __net_initdata struct pernet_oper
- 
- int __init ip_misc_proc_init(void)
- {
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return 0;
-+
- 	return register_pernet_subsys(&ip_proc_ops);
- }
- 
---- a/net/ipv4/route.c
-+++ b/net/ipv4/route.c
-@@ -418,6 +418,9 @@ static struct pernet_operations ip_rt_pr
- 
- static int __init ip_rt_proc_init(void)
- {
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return 0;
-+
- 	return register_pernet_subsys(&ip_rt_proc_ops);
- }
- 
---- a/ipc/msg.c
-+++ b/ipc/msg.c
-@@ -1075,6 +1075,9 @@ void __init msg_init(void)
- 	printk(KERN_INFO "msgmni has been set to %d\n",
- 		init_ipc_ns.msg_ctlmni);
- 
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return;
-+
- 	ipc_init_proc_interface("sysvipc/msg",
- 				"       key      msqid perms      cbytes       qnum lspid lrpid   uid   gid  cuid  cgid      stime      rtime      ctime\n",
- 				IPC_MSG_IDS, sysvipc_msg_proc_show);
---- a/ipc/sem.c
-+++ b/ipc/sem.c
-@@ -191,6 +191,8 @@ void sem_exit_ns(struct ipc_namespace *n
- void __init sem_init(void)
- {
- 	sem_init_ns(&init_ipc_ns);
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return;
- 	ipc_init_proc_interface("sysvipc/sem",
- 				"       key      semid perms      nsems   uid   gid  cuid  cgid      otime      ctime\n",
- 				IPC_SEM_IDS, sysvipc_sem_proc_show);
---- a/ipc/shm.c
-+++ b/ipc/shm.c
-@@ -118,6 +118,8 @@ pure_initcall(ipc_ns_init);
- 
- void __init shm_init(void)
- {
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return;
- 	ipc_init_proc_interface("sysvipc/shm",
- #if BITS_PER_LONG <= 32
- 				"       key      shmid perms       size  cpid  lpid nattch   uid   gid  cuid  cgid      atime      dtime      ctime        rss       swap\n",
---- a/ipc/util.c
-+++ b/ipc/util.c
-@@ -161,6 +161,9 @@ void __init ipc_init_proc_interface(cons
- 	struct proc_dir_entry *pde;
- 	struct ipc_proc_iface *iface;
- 
-+	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		return;
-+
- 	iface = kmalloc(sizeof(*iface), GFP_KERNEL);
- 	if (!iface)
- 		return;
---- a/net/core/net-procfs.c
-+++ b/net/core/net-procfs.c
-@@ -318,10 +318,12 @@ static int __net_init dev_proc_net_init(
- 
- 	if (!proc_create("dev", S_IRUGO, net->proc_net, &dev_seq_fops))
- 		goto out;
--	if (!proc_create("softnet_stat", S_IRUGO, net->proc_net,
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED) &&
-+		!proc_create("softnet_stat", S_IRUGO, net->proc_net,
- 			 &softnet_seq_fops))
- 		goto out_dev;
--	if (!proc_create("ptype", S_IRUGO, net->proc_net, &ptype_seq_fops))
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED) &&
-+		!proc_create("ptype", S_IRUGO, net->proc_net, &ptype_seq_fops))
- 		goto out_softnet;
- 
- 	if (wext_proc_init(net))
-@@ -330,9 +332,11 @@ static int __net_init dev_proc_net_init(
- out:
- 	return rc;
- out_ptype:
--	remove_proc_entry("ptype", net->proc_net);
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		remove_proc_entry("ptype", net->proc_net);
- out_softnet:
--	remove_proc_entry("softnet_stat", net->proc_net);
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED))
-+		remove_proc_entry("softnet_stat", net->proc_net);
- out_dev:
- 	remove_proc_entry("dev", net->proc_net);
- 	goto out;
-@@ -342,8 +346,10 @@ static void __net_exit dev_proc_net_exit
- {
- 	wext_proc_exit(net);
- 
--	remove_proc_entry("ptype", net->proc_net);
--	remove_proc_entry("softnet_stat", net->proc_net);
-+	if (!IS_ENABLED(CONFIG_PROC_STRIPPED)) {
-+		remove_proc_entry("ptype", net->proc_net);
-+		remove_proc_entry("softnet_stat", net->proc_net);
-+	}
- 	remove_proc_entry("dev", net->proc_net);
- }
- 
--- a/target/linux/generic/pending-3.18/904-debloat_dma_buf.patch	2022-03-22 08:54:47.344464898 +0800
+++ b/target/linux/generic/pending-3.18/904-debloat_dma_buf.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,44 +0,0 @@
---- a/drivers/base/Kconfig
-+++ b/drivers/base/Kconfig
-@@ -229,7 +229,7 @@ config SOC_BUS
- source "drivers/base/regmap/Kconfig"
- 
- config DMA_SHARED_BUFFER
--	bool
-+	tristate
- 	default n
- 	select ANON_INODES
- 	help
---- a/drivers/dma-buf/Makefile
-+++ b/drivers/dma-buf/Makefile
-@@ -1 +1,2 @@
--obj-y := dma-buf.o fence.o reservation.o seqno-fence.o
-+obj-$(CONFIG_DMA_SHARED_BUFFER) := dma-shared-buffer.o
-+dma-shared-buffer-objs := dma-buf.o fence.o reservation.o seqno-fence.o
---- a/drivers/dma-buf/dma-buf.c
-+++ b/drivers/dma-buf/dma-buf.c
-@@ -32,6 +32,7 @@
- #include <linux/seq_file.h>
- #include <linux/poll.h>
- #include <linux/reservation.h>
-+#include <linux/module.h>
- 
- static inline int is_dma_buf_file(struct file *);
- 
-@@ -904,4 +905,5 @@ static void __exit dma_buf_deinit(void)
- {
- 	dma_buf_uninit_debugfs();
- }
--__exitcall(dma_buf_deinit);
-+module_exit(dma_buf_deinit);
-+MODULE_LICENSE("GPL");
---- a/kernel/sched/core.c
-+++ b/kernel/sched/core.c
-@@ -1823,6 +1823,7 @@ int wake_up_state(struct task_struct *p,
- {
- 	return try_to_wake_up(p, state, 0);
- }
-+EXPORT_SYMBOL_GPL(wake_up_state);
- 
- /*
-  * This function clears the sched_dl_entity static params.
--- a/target/linux/generic/pending-3.18/910-kobject_uevent.patch	2022-03-22 08:54:47.344464898 +0800
+++ b/target/linux/generic/pending-3.18/910-kobject_uevent.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,21 +0,0 @@
---- a/lib/kobject_uevent.c
-+++ b/lib/kobject_uevent.c
-@@ -53,6 +53,18 @@ static const char *kobject_actions[] = {
- 	[KOBJ_OFFLINE] =	"offline",
- };
- 
-+u64 uevent_next_seqnum(void)
-+{
-+	u64 seq;
-+
-+	mutex_lock(&uevent_sock_mutex);
-+	seq = ++uevent_seqnum;
-+	mutex_unlock(&uevent_sock_mutex);
-+
-+	return seq;
-+}
-+EXPORT_SYMBOL_GPL(uevent_next_seqnum);
-+
- /**
-  * kobject_action_type - translate action string to numeric type
-  *
--- a/target/linux/generic/pending-3.18/911-kobject_add_broadcast_uevent.patch	2022-03-22 08:54:47.344464898 +0800
+++ b/target/linux/generic/pending-3.18/911-kobject_add_broadcast_uevent.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,65 +0,0 @@
---- a/include/linux/kobject.h
-+++ b/include/linux/kobject.h
-@@ -32,6 +32,8 @@
- #define UEVENT_NUM_ENVP			32	/* number of env pointers */
- #define UEVENT_BUFFER_SIZE		2048	/* buffer for the variables */
- 
-+struct sk_buff;
-+
- #ifdef CONFIG_UEVENT_HELPER
- /* path to the userspace helper executed on an event */
- extern char uevent_helper[];
-@@ -221,4 +223,7 @@ int add_uevent_var(struct kobj_uevent_en
- int kobject_action_type(const char *buf, size_t count,
- 			enum kobject_action *type);
- 
-+int broadcast_uevent(struct sk_buff *skb, __u32 pid, __u32 group,
-+		     gfp_t allocation);
-+
- #endif /* _KOBJECT_H_ */
---- a/lib/kobject_uevent.c
-+++ b/lib/kobject_uevent.c
-@@ -424,6 +424,43 @@ int add_uevent_var(struct kobj_uevent_en
- EXPORT_SYMBOL_GPL(add_uevent_var);
- 
- #if defined(CONFIG_NET)
-+int broadcast_uevent(struct sk_buff *skb, __u32 pid, __u32 group,
-+		     gfp_t allocation)
-+{
-+	struct uevent_sock *ue_sk;
-+	int err = 0;
-+
-+	/* send netlink message */
-+	mutex_lock(&uevent_sock_mutex);
-+	list_for_each_entry(ue_sk, &uevent_sock_list, list) {
-+		struct sock *uevent_sock = ue_sk->sk;
-+		struct sk_buff *skb2;
-+
-+		skb2 = skb_clone(skb, allocation);
-+		if (!skb2)
-+			break;
-+
-+		err = netlink_broadcast(uevent_sock, skb2, pid, group,
-+					allocation);
-+		if (err)
-+			break;
-+	}
-+	mutex_unlock(&uevent_sock_mutex);
-+
-+	kfree_skb(skb);
-+	return err;
-+}
-+#else
-+int broadcast_uevent(struct sk_buff *skb, __u32 pid, __u32 group,
-+		     gfp_t allocation)
-+{
-+	kfree_skb(skb);
-+	return 0;
-+}
-+#endif
-+EXPORT_SYMBOL_GPL(broadcast_uevent);
-+
-+#if defined(CONFIG_NET)
- static int uevent_net_init(struct net *net)
- {
- 	struct uevent_sock *ue_sk;
--- a/target/linux/generic/pending-3.18/921-use_preinit_as_init.patch	2022-03-22 08:54:47.345464899 +0800
+++ b/target/linux/generic/pending-3.18/921-use_preinit_as_init.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,12 +0,0 @@
---- a/init/main.c
-+++ b/init/main.c
-@@ -963,7 +963,8 @@ static int __ref kernel_init(void *unuse
- 		pr_err("Failed to execute %s (error %d).  Attempting defaults...\n",
- 			execute_command, ret);
- 	}
--	if (!try_to_run_init_process("/sbin/init") ||
-+	if (!try_to_run_init_process("/etc/preinit") ||
-+	    !try_to_run_init_process("/sbin/init") ||
- 	    !try_to_run_init_process("/etc/init") ||
- 	    !try_to_run_init_process("/bin/init") ||
- 	    !try_to_run_init_process("/bin/sh"))
--- a/target/linux/generic/pending-3.18/922-always-create-console-node-in-initramfs.patch	2022-03-22 08:54:47.345464899 +0800
+++ b/target/linux/generic/pending-3.18/922-always-create-console-node-in-initramfs.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,30 +0,0 @@
---- a/scripts/gen_initramfs_list.sh
-+++ b/scripts/gen_initramfs_list.sh
-@@ -59,6 +59,18 @@ default_initramfs() {
- 	EOF
- }
- 
-+list_openwrt_initramfs() {
-+	:
-+}
-+
-+openwrt_initramfs() {
-+	# make sure that /dev/console exists
-+	cat <<-EOF >> ${output}
-+		dir /dev 0755 0 0
-+		nod /dev/console 0600 0 0 c 5 1
-+	EOF
-+}
-+
- filetype() {
- 	local argv1="$1"
- 
-@@ -177,6 +189,8 @@ dir_filelist() {
- 	if [  "$(echo "${dirlist}" | wc -l)" -gt 1 ]; then
- 		${dep_list}print_mtime "$1"
- 
-+		${dep_list}openwrt_initramfs
-+
- 		echo "${dirlist}" | \
- 		while read x; do
- 			${dep_list}parse ${x}
--- a/target/linux/generic/pending-3.18/930-crashlog.patch	2022-03-22 08:54:47.345464899 +0800
+++ b/target/linux/generic/pending-3.18/930-crashlog.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,276 +0,0 @@
---- /dev/null
-+++ b/include/linux/crashlog.h
-@@ -0,0 +1,17 @@
-+#ifndef __CRASHLOG_H
-+#define __CRASHLOG_H
-+
-+#ifdef CONFIG_CRASHLOG
-+void crashlog_init_bootmem(struct bootmem_data *bdata);
-+void crashlog_init_memblock(phys_addr_t addr, phys_addr_t size);
-+#else
-+static inline void crashlog_init_bootmem(struct bootmem_data *bdata)
-+{
-+}
-+
-+static inline void crashlog_init_memblock(phys_addr_t addr, phys_addr_t size)
-+{
-+}
-+#endif
-+
-+#endif
---- a/init/Kconfig
-+++ b/init/Kconfig
-@@ -1279,6 +1279,10 @@ config RELAY
- 
- 	  If unsure, say N.
- 
-+config CRASHLOG
-+	bool "Crash logging"
-+	depends on (!NO_BOOTMEM || HAVE_MEMBLOCK) && !(ARM || SPARC || PPC)
-+
- config BLK_DEV_INITRD
- 	bool "Initial RAM filesystem and RAM disk (initramfs/initrd) support"
- 	depends on BROKEN || !FRV
---- a/kernel/Makefile
-+++ b/kernel/Makefile
-@@ -96,6 +96,7 @@ obj-$(CONFIG_CRASH_DUMP) += crash_dump.o
- obj-$(CONFIG_JUMP_LABEL) += jump_label.o
- obj-$(CONFIG_CONTEXT_TRACKING) += context_tracking.o
- obj-$(CONFIG_TORTURE_TEST) += torture.o
-+obj-$(CONFIG_CRASHLOG) += crashlog.o
- 
- $(obj)/configs.o: $(obj)/config_data.h
- 
---- /dev/null
-+++ b/kernel/crashlog.c
-@@ -0,0 +1,181 @@
-+/*
-+ * Crash information logger
-+ * Copyright (C) 2010 Felix Fietkau <nbd@nbd.name>
-+ *
-+ * Based on ramoops.c
-+ *   Copyright (C) 2010 Marco Stornelli <marco.stornelli@gmail.com>
-+ *
-+ * This program is free software; you can redistribute it and/or
-+ * modify it under the terms of the GNU General Public License
-+ * version 2 as published by the Free Software Foundation.
-+ *
-+ * This program is distributed in the hope that it will be useful, but
-+ * WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-+ * General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-+ * 02110-1301 USA
-+ *
-+ */
-+
-+#include <linux/module.h>
-+#include <linux/bootmem.h>
-+#include <linux/memblock.h>
-+#include <linux/debugfs.h>
-+#include <linux/crashlog.h>
-+#include <linux/kmsg_dump.h>
-+#include <linux/module.h>
-+#include <linux/pfn.h>
-+#include <asm/io.h>
-+
-+#define CRASHLOG_PAGES	4
-+#define CRASHLOG_SIZE	(CRASHLOG_PAGES * PAGE_SIZE)
-+#define CRASHLOG_MAGIC	0xa1eedead
-+
-+/*
-+ * Start the log at 1M before the end of RAM, as some boot loaders like
-+ * to use the end of the RAM for stack usage and other things
-+ * If this fails, fall back to using the last part.
-+ */
-+#define CRASHLOG_OFFSET	(1024 * 1024)
-+
-+struct crashlog_data {
-+	u32 magic;
-+	u32 len;
-+	u8 data[];
-+};
-+
-+static struct debugfs_blob_wrapper crashlog_blob;
-+static unsigned long crashlog_addr = 0;
-+static struct crashlog_data *crashlog_buf;
-+static struct kmsg_dumper dump;
-+static bool first = true;
-+
-+extern struct list_head *crashlog_modules;
-+
-+#ifndef CONFIG_NO_BOOTMEM
-+void __init crashlog_init_bootmem(bootmem_data_t *bdata)
-+{
-+	unsigned long addr;
-+
-+	if (crashlog_addr)
-+		return;
-+
-+	addr = PFN_PHYS(bdata->node_low_pfn) - CRASHLOG_OFFSET;
-+	if (reserve_bootmem(addr, CRASHLOG_SIZE, BOOTMEM_EXCLUSIVE) < 0) {
-+		printk("Crashlog failed to allocate RAM at address 0x%lx\n", addr);
-+		bdata->node_low_pfn -= CRASHLOG_PAGES;
-+		addr = PFN_PHYS(bdata->node_low_pfn);
-+	}
-+	crashlog_addr = addr;
-+}
-+#endif
-+
-+#ifdef CONFIG_HAVE_MEMBLOCK
-+void __init_memblock crashlog_init_memblock(phys_addr_t addr, phys_addr_t size)
-+{
-+	if (crashlog_addr)
-+		return;
-+
-+	addr += size - CRASHLOG_OFFSET;
-+	if (memblock_reserve(addr, CRASHLOG_SIZE)) {
-+		printk("Crashlog failed to allocate RAM at address 0x%lx\n", (unsigned long) addr);
-+		return;
-+	}
-+
-+	crashlog_addr = addr;
-+}
-+#endif
-+
-+static void __init crashlog_copy(void)
-+{
-+	if (crashlog_buf->magic != CRASHLOG_MAGIC)
-+		return;
-+
-+	if (!crashlog_buf->len || crashlog_buf->len >
-+	    CRASHLOG_SIZE - sizeof(*crashlog_buf))
-+		return;
-+
-+	crashlog_blob.size = crashlog_buf->len;
-+	crashlog_blob.data = kmemdup(crashlog_buf->data,
-+		crashlog_buf->len, GFP_KERNEL);
-+
-+	debugfs_create_blob("crashlog", 0700, NULL, &crashlog_blob);
-+}
-+
-+static int get_maxlen(void)
-+{
-+	return CRASHLOG_SIZE - sizeof(*crashlog_buf) - crashlog_buf->len;
-+}
-+
-+static void crashlog_printf(const char *fmt, ...)
-+{
-+	va_list args;
-+	int len = get_maxlen();
-+
-+	if (!len)
-+		return;
-+
-+	va_start(args, fmt);
-+	crashlog_buf->len += vscnprintf(
-+		&crashlog_buf->data[crashlog_buf->len],
-+		len, fmt, args);
-+	va_end(args);
-+}
-+
-+static void crashlog_do_dump(struct kmsg_dumper *dumper,
-+		enum kmsg_dump_reason reason)
-+{
-+	struct timeval tv;
-+	struct module *m;
-+	char *buf;
-+	size_t len;
-+
-+	if (!first)
-+		crashlog_printf("\n===================================\n");
-+
-+	do_gettimeofday(&tv);
-+	crashlog_printf("Time: %lu.%lu\n",
-+		(long)tv.tv_sec, (long)tv.tv_usec);
-+
-+	if (first) {
-+		crashlog_printf("Modules:");
-+		list_for_each_entry(m, crashlog_modules, list) {
-+			crashlog_printf("\t%s@%p+%x", m->name,
-+			m->module_core, m->core_size,
-+			m->module_init, m->init_size);
-+		}
-+		crashlog_printf("\n");
-+		first = false;
-+	}
-+
-+	buf = (char *)&crashlog_buf->data[crashlog_buf->len];
-+
-+	kmsg_dump_get_buffer(dumper, true, buf, get_maxlen(), &len);
-+
-+	crashlog_buf->len += len;
-+}
-+
-+
-+int __init crashlog_init_fs(void)
-+{
-+	if (!crashlog_addr)
-+		return -ENOMEM;
-+
-+	crashlog_buf = ioremap(crashlog_addr, CRASHLOG_SIZE);
-+
-+	crashlog_copy();
-+
-+	crashlog_buf->magic = CRASHLOG_MAGIC;
-+	crashlog_buf->len = 0;
-+
-+	dump.max_reason = KMSG_DUMP_OOPS;
-+	dump.dump = crashlog_do_dump;
-+	kmsg_dump_register(&dump);
-+
-+	return 0;
-+}
-+module_init(crashlog_init_fs);
---- a/mm/bootmem.c
-+++ b/mm/bootmem.c
-@@ -15,6 +15,7 @@
- #include <linux/export.h>
- #include <linux/kmemleak.h>
- #include <linux/range.h>
-+#include <linux/crashlog.h>
- #include <linux/memblock.h>
- #include <linux/bug.h>
- #include <linux/io.h>
-@@ -177,6 +178,7 @@ static unsigned long __init free_all_boo
- 	if (!bdata->node_bootmem_map)
- 		return 0;
- 
-+	crashlog_init_bootmem(bdata);
- 	map = bdata->node_bootmem_map;
- 	start = bdata->node_min_pfn;
- 	end = bdata->node_low_pfn;
---- a/kernel/module.c
-+++ b/kernel/module.c
-@@ -105,6 +105,9 @@ static LIST_HEAD(modules);
- #ifdef CONFIG_KGDB_KDB
- struct list_head *kdb_modules = &modules; /* kdb needs the list of modules */
- #endif /* CONFIG_KGDB_KDB */
-+#ifdef CONFIG_CRASHLOG
-+struct list_head *crashlog_modules = &modules;
-+#endif
- 
- #ifdef CONFIG_MODULE_SIG
- #ifdef CONFIG_MODULE_SIG_FORCE
---- a/mm/memblock.c
-+++ b/mm/memblock.c
-@@ -19,6 +19,7 @@
- #include <linux/debugfs.h>
- #include <linux/seq_file.h>
- #include <linux/memblock.h>
-+#include <linux/crashlog.h>
- 
- #include <asm-generic/sections.h>
- #include <linux/io.h>
-@@ -477,6 +478,8 @@ static void __init_memblock memblock_ins
- 	memblock_set_region_node(rgn, nid);
- 	type->cnt++;
- 	type->total_size += size;
-+	if (type == &memblock.memory && idx == 0)
-+		crashlog_init_memblock(base, size);
- }
- 
- /**
--- a/target/linux/generic/pending-3.18/970-remove-unsane-filenames-from-deps_initramfs-list.patch	2022-03-22 08:54:47.346464901 +0800
+++ b/target/linux/generic/pending-3.18/970-remove-unsane-filenames-from-deps_initramfs-list.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,29 +0,0 @@
---- a/usr/Makefile
-+++ b/usr/Makefile
-@@ -53,6 +53,8 @@ ifneq ($(wildcard $(obj)/.initramfs_data
- 	include $(obj)/.initramfs_data.cpio.d
- endif
- 
-+deps_initramfs_sane := $(foreach v,$(deps_initramfs),$(if $(findstring :,$(v)),,$(v)))
-+
- quiet_cmd_initfs = GEN     $@
-       cmd_initfs = $(initramfs) -o $@ $(ramfs-args) $(ramfs-input)
- 
-@@ -61,14 +63,14 @@ targets := initramfs_data.cpio.gz initra
- 	initramfs_data.cpio.lzo initramfs_data.cpio.lz4 \
- 	initramfs_data.cpio
- # do not try to update files included in initramfs
--$(deps_initramfs): ;
-+$(deps_initramfs_sane): ;
- 
--$(deps_initramfs): klibcdirs
-+$(deps_initramfs_sane): klibcdirs
- # We rebuild initramfs_data.cpio if:
- # 1) Any included file is newer then initramfs_data.cpio
- # 2) There are changes in which files are included (added or deleted)
- # 3) If gen_init_cpio are newer than initramfs_data.cpio
- # 4) arguments to gen_initramfs.sh changes
--$(obj)/initramfs_data.cpio$(suffix_y): $(obj)/gen_init_cpio $(deps_initramfs) klibcdirs
-+$(obj)/initramfs_data.cpio$(suffix_y): $(obj)/gen_init_cpio $(deps_initramfs_sane) klibcdirs
- 	$(Q)$(initramfs) -l $(ramfs-input) > $(obj)/.initramfs_data.cpio.d
- 	$(call if_changed,initfs)
--- a/target/linux/generic/pending-3.18/980-arm_openwrt_machtypes.patch	2022-03-22 08:54:47.346464901 +0800
+++ b/target/linux/generic/pending-3.18/980-arm_openwrt_machtypes.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,32 +0,0 @@
---- a/arch/arm/tools/mach-types
-+++ b/arch/arm/tools/mach-types
-@@ -1007,3 +1007,29 @@ eco5_bx2		MACH_ECO5_BX2		ECO5_BX2		4572
- eukrea_cpuimx28sd	MACH_EUKREA_CPUIMX28SD	EUKREA_CPUIMX28SD	4573
- domotab			MACH_DOMOTAB		DOMOTAB			4574
- pfla03			MACH_PFLA03		PFLA03			4575
-+#
-+# Additional mach-types supported by OpenWrt
-+#
-+wg302v1			MACH_WG302V1		WG302V1			889
-+pronghorn		MACH_PRONGHORN		PRONGHORN		928
-+pronghorn_metro		MACH_PRONGHORNMETRO	PRONGHORNMETRO		1040
-+sidewinder		MACH_SIDEWINDER		SIDEWINDER		1041
-+wrt300nv2		MACH_WRT300NV2		WRT300NV2		1077
-+compex42x		MACH_COMPEXWP18		COMPEXWP18		1273
-+goldfish		MACH_GOLDFISH		GOLDFISH		1441
-+cambria			MACH_CAMBRIA		CAMBRIA			1468
-+dt2			MACH_DT2		DT2			1514
-+ap1000			MACH_AP1000		AP1000			1543
-+tw2662			MACH_TW2662		TW2662			1658
-+tw5334			MACH_TW5334		TW5334			1664
-+usr8200			MACH_USR8200		USR8200			1762
-+mi424wr			MACH_MI424WR		MI424WR			1778
-+gw2388			MACH_GW2388		GW2388			2635
-+iconnect		MACH_ICONNECT		ICONNECT		2870
-+nsb3ast			MACH_NSB3AST		NSB3AST			2917
-+goflexnet		MACH_GOFLEXNET		GOFLEXNET		3089
-+nas6210			MACH_NAS6210		NAS6210			3104
-+ns_k330			MACH_NS_K330		NS_K330			3108
-+bcm2708			MACH_BCM2708		BCM2708			3138
-+wn802t			MACH_WN802T		WN802T			3306
-+nsa310			MACH_NSA310		NSA310			4022
--- a/target/linux/generic/pending-3.18/990-gpio_wdt.patch	2022-03-22 08:54:47.346464901 +0800
+++ b/target/linux/generic/pending-3.18/990-gpio_wdt.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,360 +0,0 @@
-This generic GPIO watchdog is used on Huawei E970 (brcm47xx)
-
-Signed-off-by: Mathias Adam <m.adam--openwrt@adamis.de>
-
---- a/drivers/watchdog/Kconfig
-+++ b/drivers/watchdog/Kconfig
-@@ -1139,6 +1139,15 @@ config WDT_MTX1
- 	  Hardware driver for the MTX-1 boards. This is a watchdog timer that
- 	  will reboot the machine after a 100 seconds timer expired.
- 
-+config GPIO_WDT
-+	tristate "GPIO Hardware Watchdog"
-+ 	help
-+	  Hardware driver for GPIO-controlled watchdogs. GPIO pin and
-+	  toggle interval settings are platform-specific. The driver
-+	  will stop toggling the GPIO (i.e. machine reboots) after a
-+	  100 second timer expired and no process has written to
-+	  /dev/watchdog during that time.
-+
- config PNX833X_WDT
- 	tristate "PNX833x Hardware Watchdog"
- 	depends on SOC_PNX8335
---- a/drivers/watchdog/Makefile
-+++ b/drivers/watchdog/Makefile
-@@ -134,6 +134,7 @@ obj-$(CONFIG_RC32434_WDT) += rc32434_wdt
- obj-$(CONFIG_INDYDOG) += indydog.o
- obj-$(CONFIG_JZ4740_WDT) += jz4740_wdt.o
- obj-$(CONFIG_WDT_MTX1) += mtx-1_wdt.o
-+obj-$(CONFIG_GPIO_WDT) += old_gpio_wdt.o
- obj-$(CONFIG_PNX833X_WDT) += pnx833x_wdt.o
- obj-$(CONFIG_SIBYTE_WDOG) += sb_wdog.o
- obj-$(CONFIG_AR7_WDT) += ar7_wdt.o
---- /dev/null
-+++ b/drivers/watchdog/old_gpio_wdt.c
-@@ -0,0 +1,301 @@
-+/*
-+ *      Driver for GPIO-controlled Hardware Watchdogs.
-+ *
-+ *      Copyright (C) 2013 Mathias Adam <m.adam--linux@adamis.de>
-+ *
-+ *      Replaces mtx1_wdt (driver for the MTX-1 Watchdog):
-+ *
-+ *      (C) Copyright 2005 4G Systems <info@4g-systems.biz>,
-+ *                              All Rights Reserved.
-+ *                              http://www.4g-systems.biz
-+ *
-+ *      (C) Copyright 2007 OpenWrt.org, Florian Fainelli <florian@openwrt.org>
-+ *
-+ *      This program is free software; you can redistribute it and/or
-+ *      modify it under the terms of the GNU General Public License
-+ *      as published by the Free Software Foundation; either version
-+ *      2 of the License, or (at your option) any later version.
-+ *
-+ *      Neither Michael Stickel nor 4G Systems admit liability nor provide
-+ *      warranty for any of this software. This material is provided
-+ *      "AS-IS" and at no charge.
-+ *
-+ *      (c) Copyright 2005    4G Systems <info@4g-systems.biz>
-+ *
-+ *      Release 0.01.
-+ *      Author: Michael Stickel  michael.stickel@4g-systems.biz
-+ *
-+ *      Release 0.02.
-+ *      Author: Florian Fainelli florian@openwrt.org
-+ *              use the Linux watchdog/timer APIs
-+ *
-+ *      Release 0.03.
-+ *      Author: Mathias Adam <m.adam--linux@adamis.de>
-+ *              make it a generic gpio watchdog driver
-+ *
-+ *      The Watchdog is configured to reset the MTX-1
-+ *      if it is not triggered for 100 seconds.
-+ *      It should not be triggered more often than 1.6 seconds.
-+ *
-+ *      A timer triggers the watchdog every 5 seconds, until
-+ *      it is opened for the first time. After the first open
-+ *      it MUST be triggered every 2..95 seconds.
-+ */
-+
-+#include <linux/module.h>
-+#include <linux/moduleparam.h>
-+#include <linux/types.h>
-+#include <linux/errno.h>
-+#include <linux/miscdevice.h>
-+#include <linux/fs.h>
-+#include <linux/init.h>
-+#include <linux/ioport.h>
-+#include <linux/timer.h>
-+#include <linux/completion.h>
-+#include <linux/jiffies.h>
-+#include <linux/watchdog.h>
-+#include <linux/platform_device.h>
-+#include <linux/io.h>
-+#include <linux/uaccess.h>
-+#include <linux/gpio.h>
-+#include <linux/old_gpio_wdt.h>
-+
-+static int ticks = 100 * HZ;
-+
-+static struct {
-+	struct completion stop;
-+	spinlock_t lock;
-+	int running;
-+	struct timer_list timer;
-+	int queue;
-+	int default_ticks;
-+	unsigned long inuse;
-+	unsigned gpio;
-+	unsigned int gstate;
-+	int interval;
-+	int first_interval;
-+} gpio_wdt_device;
-+
-+static void gpio_wdt_trigger(unsigned long unused)
-+{
-+	spin_lock(&gpio_wdt_device.lock);
-+	if (gpio_wdt_device.running && ticks > 0)
-+		ticks -= gpio_wdt_device.interval;
-+
-+	/* toggle wdt gpio */
-+	gpio_wdt_device.gstate = !gpio_wdt_device.gstate;
-+	gpio_set_value(gpio_wdt_device.gpio, gpio_wdt_device.gstate);
-+
-+	if (gpio_wdt_device.queue && ticks > 0)
-+		mod_timer(&gpio_wdt_device.timer, jiffies + gpio_wdt_device.interval);
-+	else
-+		complete(&gpio_wdt_device.stop);
-+	spin_unlock(&gpio_wdt_device.lock);
-+}
-+
-+static void gpio_wdt_reset(void)
-+{
-+	ticks = gpio_wdt_device.default_ticks;
-+}
-+
-+
-+static void gpio_wdt_start(void)
-+{
-+	unsigned long flags;
-+
-+	spin_lock_irqsave(&gpio_wdt_device.lock, flags);
-+	if (!gpio_wdt_device.queue) {
-+		gpio_wdt_device.queue = 1;
-+		gpio_wdt_device.gstate = 1;
-+		gpio_set_value(gpio_wdt_device.gpio, 1);
-+		mod_timer(&gpio_wdt_device.timer, jiffies + gpio_wdt_device.first_interval);
-+	}
-+	gpio_wdt_device.running++;
-+	spin_unlock_irqrestore(&gpio_wdt_device.lock, flags);
-+}
-+
-+static int gpio_wdt_stop(void)
-+{
-+	unsigned long flags;
-+
-+	spin_lock_irqsave(&gpio_wdt_device.lock, flags);
-+	if (gpio_wdt_device.queue) {
-+		gpio_wdt_device.queue = 0;
-+		gpio_wdt_device.gstate = 0;
-+		gpio_set_value(gpio_wdt_device.gpio, 0);
-+	}
-+	ticks = gpio_wdt_device.default_ticks;
-+	spin_unlock_irqrestore(&gpio_wdt_device.lock, flags);
-+	return 0;
-+}
-+
-+/* Filesystem functions */
-+
-+static int gpio_wdt_open(struct inode *inode, struct file *file)
-+{
-+	if (test_and_set_bit(0, &gpio_wdt_device.inuse))
-+		return -EBUSY;
-+	return nonseekable_open(inode, file);
-+}
-+
-+
-+static int gpio_wdt_release(struct inode *inode, struct file *file)
-+{
-+	clear_bit(0, &gpio_wdt_device.inuse);
-+	return 0;
-+}
-+
-+static long gpio_wdt_ioctl(struct file *file, unsigned int cmd,
-+							unsigned long arg)
-+{
-+	void __user *argp = (void __user *)arg;
-+	int __user *p = (int __user *)argp;
-+	unsigned int value;
-+	static const struct watchdog_info ident = {
-+		.options = WDIOF_CARDRESET,
-+		.identity = "GPIO WDT",
-+	};
-+
-+	switch (cmd) {
-+	case WDIOC_GETSUPPORT:
-+		if (copy_to_user(argp, &ident, sizeof(ident)))
-+			return -EFAULT;
-+		break;
-+	case WDIOC_GETSTATUS:
-+	case WDIOC_GETBOOTSTATUS:
-+		put_user(0, p);
-+		break;
-+	case WDIOC_SETOPTIONS:
-+		if (get_user(value, p))
-+			return -EFAULT;
-+		if (value & WDIOS_ENABLECARD)
-+			gpio_wdt_start();
-+		else if (value & WDIOS_DISABLECARD)
-+			gpio_wdt_stop();
-+		else
-+			return -EINVAL;
-+		return 0;
-+	case WDIOC_KEEPALIVE:
-+		gpio_wdt_reset();
-+		break;
-+	default:
-+		return -ENOTTY;
-+	}
-+	return 0;
-+}
-+
-+
-+static ssize_t gpio_wdt_write(struct file *file, const char *buf,
-+						size_t count, loff_t *ppos)
-+{
-+	if (!count)
-+		return -EIO;
-+	gpio_wdt_reset();
-+	return count;
-+}
-+
-+static const struct file_operations gpio_wdt_fops = {
-+	.owner		= THIS_MODULE,
-+	.llseek		= no_llseek,
-+	.unlocked_ioctl	= gpio_wdt_ioctl,
-+	.open		= gpio_wdt_open,
-+	.write		= gpio_wdt_write,
-+	.release	= gpio_wdt_release,
-+};
-+
-+
-+static struct miscdevice gpio_wdt_misc = {
-+	.minor	= WATCHDOG_MINOR,
-+	.name	= "watchdog",
-+	.fops	= &gpio_wdt_fops,
-+};
-+
-+
-+static int gpio_wdt_probe(struct platform_device *pdev)
-+{
-+	int ret;
-+	struct gpio_wdt_platform_data *gpio_wdt_data = pdev->dev.platform_data;
-+
-+	gpio_wdt_device.gpio = gpio_wdt_data->gpio;
-+	gpio_wdt_device.interval = gpio_wdt_data->interval;
-+	gpio_wdt_device.first_interval = gpio_wdt_data->first_interval;
-+	if (gpio_wdt_device.first_interval <= 0) {
-+		gpio_wdt_device.first_interval = gpio_wdt_device.interval;
-+	}
-+
-+	ret = gpio_request(gpio_wdt_device.gpio, "gpio-wdt");
-+	if (ret < 0) {
-+		dev_err(&pdev->dev, "failed to request gpio");
-+		return ret;
-+	}
-+
-+	spin_lock_init(&gpio_wdt_device.lock);
-+	init_completion(&gpio_wdt_device.stop);
-+	gpio_wdt_device.queue = 0;
-+	clear_bit(0, &gpio_wdt_device.inuse);
-+	setup_timer(&gpio_wdt_device.timer, gpio_wdt_trigger, 0L);
-+	gpio_wdt_device.default_ticks = ticks;
-+
-+	gpio_wdt_start();
-+	dev_info(&pdev->dev, "GPIO Hardware Watchdog driver (gpio=%i interval=%i/%i)\n",
-+		gpio_wdt_data->gpio, gpio_wdt_data->first_interval, gpio_wdt_data->interval);
-+	return 0;
-+}
-+
-+static int gpio_wdt_remove(struct platform_device *pdev)
-+{
-+	/* FIXME: do we need to lock this test ? */
-+	if (gpio_wdt_device.queue) {
-+		gpio_wdt_device.queue = 0;
-+		wait_for_completion(&gpio_wdt_device.stop);
-+	}
-+
-+	gpio_free(gpio_wdt_device.gpio);
-+	misc_deregister(&gpio_wdt_misc);
-+	return 0;
-+}
-+
-+static struct platform_driver gpio_wdt_driver = {
-+	.probe = gpio_wdt_probe,
-+	.remove = gpio_wdt_remove,
-+	.driver.name = "gpio-wdt",
-+	.driver.owner = THIS_MODULE,
-+};
-+
-+static int __init gpio_wdt_init(void)
-+{
-+	return platform_driver_register(&gpio_wdt_driver);
-+}
-+arch_initcall(gpio_wdt_init);
-+
-+/*
-+ * We do wdt initialization in two steps: arch_initcall probes the wdt
-+ * very early to start pinging the watchdog (misc devices are not yet
-+ * available), and later module_init() just registers the misc device.
-+ */
-+static int gpio_wdt_init_late(void)
-+{
-+	int ret;
-+
-+	ret = misc_register(&gpio_wdt_misc);
-+	if (ret < 0) {
-+		pr_err("GPIO_WDT: failed to register misc device\n");
-+		return ret;
-+	}
-+	return 0;
-+}
-+#ifndef MODULE
-+module_init(gpio_wdt_init_late);
-+#endif
-+
-+static void __exit gpio_wdt_exit(void)
-+{
-+	platform_driver_unregister(&gpio_wdt_driver);
-+}
-+module_exit(gpio_wdt_exit);
-+
-+MODULE_AUTHOR("Michael Stickel, Florian Fainelli, Mathias Adam");
-+MODULE_DESCRIPTION("Driver for GPIO hardware watchdogs");
-+MODULE_LICENSE("GPL");
-+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
-+MODULE_ALIAS("platform:gpio-wdt");
---- /dev/null
-+++ b/include/linux/old_gpio_wdt.h
-@@ -0,0 +1,21 @@
-+/*
-+ *  Definitions for the GPIO watchdog driver
-+ *
-+ *  Copyright (C) 2013 Mathias Adam <m.adam--linux@adamis.de>
-+ *
-+ *  This program is free software; you can redistribute it and/or modify
-+ *  it under the terms of the GNU General Public License version 2 as
-+ *  published by the Free Software Foundation.
-+ *
-+ */
-+
-+#ifndef _GPIO_WDT_H_
-+#define _GPIO_WDT_H_
-+
-+struct gpio_wdt_platform_data {
-+	int	gpio;		/* GPIO line number */
-+	int	interval;	/* watchdog reset interval in system ticks */
-+	int	first_interval;	/* first wd reset interval in system ticks */
-+};
-+
-+#endif /* _GPIO_WDT_H_ */
--- a/target/linux/generic/pending-3.18/995-mangle_bootargs.patch	2022-03-22 08:54:47.347464903 +0800
+++ b/target/linux/generic/pending-3.18/995-mangle_bootargs.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,58 +0,0 @@
---- a/init/main.c
-+++ b/init/main.c
-@@ -362,6 +362,29 @@ static inline void setup_nr_cpu_ids(void
- static inline void smp_prepare_cpus(unsigned int maxcpus) { }
- #endif
- 
-+#ifdef CONFIG_MANGLE_BOOTARGS
-+static void __init mangle_bootargs(char *command_line)
-+{
-+	char *rootdev;
-+	char *rootfs;
-+
-+	rootdev = strstr(command_line, "root=/dev/mtdblock");
-+
-+	if (rootdev)
-+		strncpy(rootdev, "mangled_rootblock=", 18);
-+
-+	rootfs = strstr(command_line, "rootfstype");
-+
-+	if (rootfs)
-+		strncpy(rootfs, "mangled_fs", 10);
-+
-+}
-+#else
-+static void __init mangle_bootargs(char *command_line)
-+{
-+}
-+#endif
-+
- /*
-  * We need to store the untouched command line for future reference.
-  * We also need to store the touched command line since the parameter
-@@ -530,6 +553,7 @@ asmlinkage __visible void __init start_k
- 	pr_notice("%s", linux_banner);
- 	setup_arch(&command_line);
- 	mm_init_cpumask(&init_mm);
-+	mangle_bootargs(command_line);
- 	setup_command_line(command_line);
- 	setup_nr_cpu_ids();
- 	setup_per_cpu_areas();
---- a/init/Kconfig
-+++ b/init/Kconfig
-@@ -1597,6 +1597,15 @@ config EMBEDDED
- 	  an embedded system so certain expert options are available
- 	  for configuration.
- 
-+config MANGLE_BOOTARGS
-+	bool "Rename offending bootargs"
-+	depends on EXPERT
-+	help
-+	  Sometimes the bootloader passed bogus root= and rootfstype=
-+	  parameters to the kernel, and while you want to ignore them,
-+	  you need to know the values f.e. to support dual firmware
-+	  layouts on the flash.
-+
- config HAVE_PERF_EVENTS
- 	bool
- 	help
--- a/target/linux/generic/pending-3.18/997-device_tree_cmdline.patch	2022-03-22 08:54:47.347464903 +0800
+++ b/target/linux/generic/pending-3.18/997-device_tree_cmdline.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,24 +0,0 @@
---- a/drivers/of/fdt.c
-+++ b/drivers/of/fdt.c
-@@ -909,6 +909,9 @@ int __init early_init_dt_scan_chosen(uns
- 	p = of_get_flat_dt_prop(node, "bootargs", &l);
- 	if (p != NULL && l > 0)
- 		strlcpy(data, p, min((int)l, COMMAND_LINE_SIZE));
-+	p = of_get_flat_dt_prop(node, "bootargs-append", &l);
-+	if (p != NULL && l > 0)
-+		strlcat(data, p, min_t(int, strlen(data) + (int)l, COMMAND_LINE_SIZE));
- 
- 	/*
- 	 * CONFIG_CMDLINE is meant to be a default in case nothing else
---- a/arch/mips/kernel/prom.c
-+++ b/arch/mips/kernel/prom.c
-@@ -49,6 +49,9 @@ void * __init early_init_dt_alloc_memory
- 
- void __init __dt_setup_arch(void *bph)
- {
-+	if (boot_command_line[0] == '\0')
-+		strcpy(boot_command_line, arcs_cmdline);
-+
- 	if (!early_init_dt_scan(bph))
- 		return;
- 
--- a/target/linux/generic/pending-3.18/998-enable_wilink_platform_without_drivers.patch	2022-03-22 08:54:47.347464903 +0800
+++ b/target/linux/generic/pending-3.18/998-enable_wilink_platform_without_drivers.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,15 +0,0 @@
-We use backports for driver updates - make sure we can compile in the glue code regardless
-
-Signed-off-by: Imre Kaloz <kaloz@openwrt.org>
-
---- a/drivers/net/wireless/ti/Kconfig
-+++ b/drivers/net/wireless/ti/Kconfig
-@@ -15,7 +15,7 @@ source "drivers/net/wireless/ti/wlcore/K
- 
- config WILINK_PLATFORM_DATA
- 	bool "TI WiLink platform data"
--	depends on WLCORE_SDIO || WL1251_SDIO
-+	depends on WLCORE_SDIO || WL1251_SDIO || ARCH_OMAP2PLUS
- 	default y
- 	---help---
- 	Small platform data bit needed to pass data to the sdio modules.
--- a/target/linux/generic/pending-3.18/999-seccomp_log.patch	2022-03-22 08:54:47.348464904 +0800
+++ b/target/linux/generic/pending-3.18/999-seccomp_log.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,34 +0,0 @@
---- a/kernel/seccomp.c
-+++ b/kernel/seccomp.c
-@@ -614,6 +614,7 @@ int __secure_computing(void)
- #ifdef CONFIG_SECCOMP_FILTER
- static u32 __seccomp_phase1_filter(int this_syscall, struct seccomp_data *sd)
- {
-+	char name[sizeof(current->comm)];
- 	u32 filter_ret, action;
- 	int data;
- 
-@@ -644,6 +645,13 @@ static u32 __seccomp_phase1_filter(int t
- 	case SECCOMP_RET_TRACE:
- 		return filter_ret;  /* Save the rest for phase 2. */
- 
-+	case SECCOMP_RET_LOG:
-+		get_task_comm(name, current);
-+		pr_err_ratelimited("seccomp: %s [%u] tried to call non-whitelisted syscall: %d\n", name, current->pid, this_syscall);
-+		syscall_set_return_value(current, task_pt_regs(current),
-+					 -data, 0);
-+		goto skip;
-+
- 	case SECCOMP_RET_ALLOW:
- 		return SECCOMP_PHASE1_OK;
- 
---- a/include/uapi/linux/seccomp.h
-+++ b/include/uapi/linux/seccomp.h
-@@ -28,6 +28,7 @@
- #define SECCOMP_RET_KILL	0x00000000U /* kill the task immediately */
- #define SECCOMP_RET_TRAP	0x00030000U /* disallow and force a SIGSYS */
- #define SECCOMP_RET_ERRNO	0x00050000U /* returns an errno */
-+#define SECCOMP_RET_LOG		0x00070000U /* allow + logline */
- #define SECCOMP_RET_TRACE	0x7ff00000U /* pass to a tracer or disallow */
- #define SECCOMP_RET_ALLOW	0x7fff0000U /* allow */
- 
--- a/target/linux/generic/pending-4.14/110-ehci_hcd_ignore_oc.patch	2022-03-22 08:54:47.349464906 +0800
+++ b/target/linux/generic/pending-4.14/110-ehci_hcd_ignore_oc.patch	2022-03-22 12:15:54.151428784 +0800
@@ -17,7 +17,7 @@
 
 --- a/drivers/usb/host/ehci-hcd.c
 +++ b/drivers/usb/host/ehci-hcd.c
-@@ -651,7 +651,7 @@ static int ehci_run (struct usb_hcd *hcd
+@@ -664,7 +664,7 @@ static int ehci_run (struct usb_hcd *hcd
  		"USB %x.%x started, EHCI %x.%02x%s\n",
  		((ehci->sbrn & 0xf0)>>4), (ehci->sbrn & 0x0f),
  		temp >> 8, temp & 0xff,
@@ -28,7 +28,7 @@
  		    &ehci->regs->intr_enable); /* Turn On Interrupts */
 --- a/drivers/usb/host/ehci-hub.c
 +++ b/drivers/usb/host/ehci-hub.c
-@@ -646,7 +646,7 @@ ehci_hub_status_data (struct usb_hcd *hc
+@@ -648,7 +648,7 @@ ehci_hub_status_data (struct usb_hcd *hc
  	 * always set, seem to clear PORT_OCC and PORT_CSC when writing to
  	 * PORT_POWER; that's surprising, but maybe within-spec.
  	 */
@@ -37,7 +37,7 @@
  		mask = PORT_CSC | PORT_PEC | PORT_OCC;
  	else
  		mask = PORT_CSC | PORT_PEC;
-@@ -1016,7 +1016,7 @@ int ehci_hub_control(
+@@ -1018,7 +1018,7 @@ int ehci_hub_control(
  		if (temp & PORT_PEC)
  			status |= USB_PORT_STAT_C_ENABLE << 16;
  
--- a/target/linux/generic/pending-4.14/120-Fix-alloc_node_mem_map-with-ARCH_PFN_OFFSET-calcu.patch	2022-03-22 08:54:47.350464908 +0800
+++ b/target/linux/generic/pending-4.14/120-Fix-alloc_node_mem_map-with-ARCH_PFN_OFFSET-calcu.patch	2022-03-22 12:15:54.151428784 +0800
@@ -71,7 +71,7 @@
 
 --- a/mm/page_alloc.c
 +++ b/mm/page_alloc.c
-@@ -6145,7 +6145,7 @@ static void __ref alloc_node_mem_map(str
+@@ -6152,7 +6152,7 @@ static void __ref alloc_node_mem_map(str
  		mem_map = NODE_DATA(0)->node_mem_map;
  #if defined(CONFIG_HAVE_MEMBLOCK_NODE_MAP) || defined(CONFIG_FLATMEM)
  		if (page_to_pfn(mem_map) != pgdat->node_start_pfn)
--- a/target/linux/generic/pending-4.14/130-add-linux-spidev-compatible-si3210.patch	2022-03-22 08:54:47.350464908 +0800
+++ b/target/linux/generic/pending-4.14/130-add-linux-spidev-compatible-si3210.patch	2022-03-22 12:15:54.151428784 +0800
@@ -8,7 +8,7 @@
 
 --- a/drivers/spi/spidev.c
 +++ b/drivers/spi/spidev.c
-@@ -669,6 +669,7 @@ static const struct of_device_id spidev_
+@@ -677,6 +677,7 @@ static const struct of_device_id spidev_
  	{ .compatible = "lineartechnology,ltc2488" },
  	{ .compatible = "ge,achc" },
  	{ .compatible = "semtech,sx1301" },
--- a/target/linux/generic/pending-4.14/131-spi-use-gpio_set_value_cansleep-for-setting-chipsele.patch	2022-03-22 08:54:47.350464908 +0800
+++ b/target/linux/generic/pending-4.14/131-spi-use-gpio_set_value_cansleep-for-setting-chipsele.patch	2022-03-22 12:15:54.152428777 +0800
@@ -9,7 +9,7 @@
 
 --- a/drivers/spi/spi.c
 +++ b/drivers/spi/spi.c
-@@ -729,7 +729,7 @@ static void spi_set_cs(struct spi_device
+@@ -741,7 +741,7 @@ static void spi_set_cs(struct spi_device
  		enable = !enable;
  
  	if (gpio_is_valid(spi->cs_gpio)) {
--- a/target/linux/generic/pending-4.14/140-jffs2-use-.rename2-and-add-RENAME_WHITEOUT-support.patch	2022-03-22 08:54:47.351464909 +0800
+++ b/target/linux/generic/pending-4.14/140-jffs2-use-.rename2-and-add-RENAME_WHITEOUT-support.patch	2022-03-22 12:15:54.152428777 +0800
@@ -8,7 +8,7 @@
 
 --- a/fs/jffs2/dir.c
 +++ b/fs/jffs2/dir.c
-@@ -752,6 +752,24 @@ static int jffs2_mknod (struct inode *di
+@@ -756,6 +756,24 @@ static int jffs2_mknod (struct inode *di
  	return ret;
  }
  
@@ -33,7 +33,7 @@
  static int jffs2_rename (struct inode *old_dir_i, struct dentry *old_dentry,
  			 struct inode *new_dir_i, struct dentry *new_dentry,
  			 unsigned int flags)
-@@ -762,7 +780,7 @@ static int jffs2_rename (struct inode *o
+@@ -766,7 +784,7 @@ static int jffs2_rename (struct inode *o
  	uint8_t type;
  	uint32_t now;
  
@@ -42,7 +42,7 @@
  		return -EINVAL;
  
  	/* The VFS will check for us and prevent trying to rename a
-@@ -828,9 +846,14 @@ static int jffs2_rename (struct inode *o
+@@ -832,9 +850,14 @@ static int jffs2_rename (struct inode *o
  	if (d_is_dir(old_dentry) && !victim_f)
  		inc_nlink(new_dir_i);
  
--- a/target/linux/generic/pending-4.14/141-jffs2-add-RENAME_EXCHANGE-support.patch	2022-03-22 08:54:47.351464909 +0800
+++ b/target/linux/generic/pending-4.14/141-jffs2-add-RENAME_EXCHANGE-support.patch	2022-03-22 12:15:54.152428777 +0800
@@ -6,7 +6,7 @@
 
 --- a/fs/jffs2/dir.c
 +++ b/fs/jffs2/dir.c
-@@ -777,18 +777,31 @@ static int jffs2_rename (struct inode *o
+@@ -781,18 +781,31 @@ static int jffs2_rename (struct inode *o
  	int ret;
  	struct jffs2_sb_info *c = JFFS2_SB_INFO(old_dir_i->i_sb);
  	struct jffs2_inode_info *victim_f = NULL;
@@ -40,7 +40,7 @@
  		victim_f = JFFS2_INODE_INFO(d_inode(new_dentry));
  		if (d_is_dir(new_dentry)) {
  			struct jffs2_full_dirent *fd;
-@@ -823,7 +836,7 @@ static int jffs2_rename (struct inode *o
+@@ -827,7 +840,7 @@ static int jffs2_rename (struct inode *o
  	if (ret)
  		return ret;
  
@@ -49,7 +49,7 @@
  		/* There was a victim. Kill it off nicely */
  		if (d_is_dir(new_dentry))
  			clear_nlink(d_inode(new_dentry));
-@@ -849,6 +862,12 @@ static int jffs2_rename (struct inode *o
+@@ -853,6 +866,12 @@ static int jffs2_rename (struct inode *o
  	if (flags & RENAME_WHITEOUT)
  		/* Replace with whiteout */
  		ret = jffs2_whiteout(old_dir_i, old_dentry);
@@ -62,7 +62,7 @@
  	else
  		/* Unlink the original */
  		ret = jffs2_do_unlink(c, JFFS2_INODE_INFO(old_dir_i),
-@@ -880,7 +899,7 @@ static int jffs2_rename (struct inode *o
+@@ -884,7 +903,7 @@ static int jffs2_rename (struct inode *o
  		return ret;
  	}
  
--- a/target/linux/generic/pending-4.14/150-bridge_allow_receiption_on_disabled_port.patch	2022-03-22 08:54:47.351464909 +0800
+++ b/target/linux/generic/pending-4.14/150-bridge_allow_receiption_on_disabled_port.patch	2022-03-22 12:15:54.153428770 +0800
@@ -27,7 +27,7 @@
  
  	/* return 1 to signal the okfn() was called so it's ok to use the skb */
  	return 1;
-@@ -332,6 +335,15 @@ rx_handler_result_t br_handle_frame(stru
+@@ -332,6 +335,17 @@ rx_handler_result_t br_handle_frame(stru
  
  forward:
  	switch (p->state) {
@@ -35,9 +35,11 @@
 +		if (ether_addr_equal(p->br->dev->dev_addr, dest))
 +			skb->pkt_type = PACKET_HOST;
 +
-+		NF_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING,
++		if (NF_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING,
 +			dev_net(skb->dev), NULL, skb, skb->dev, NULL,
-+			br_handle_local_finish);
++			br_handle_local_finish) == 1) {
++			return RX_HANDLER_PASS;
++		}
 +		break;
 +
  	case BR_STATE_FORWARDING:
--- a/target/linux/generic/pending-4.14/171-usb-dwc2-Fix-inefficient-copy-of-unaligned-buffers.patch	2022-03-22 08:54:47.352464911 +0800
+++ b/target/linux/generic/pending-4.14/171-usb-dwc2-Fix-inefficient-copy-of-unaligned-buffers.patch	2022-03-22 12:15:54.154428764 +0800
@@ -22,7 +22,7 @@
 
 --- a/drivers/usb/dwc2/hcd.c
 +++ b/drivers/usb/dwc2/hcd.c
-@@ -2669,6 +2669,7 @@ static int dwc2_alloc_split_dma_aligned_
+@@ -2670,6 +2670,7 @@ static int dwc2_alloc_split_dma_aligned_
  static void dwc2_free_dma_aligned_buffer(struct urb *urb)
  {
  	void *stored_xfer_buffer;
@@ -30,7 +30,7 @@
  
  	if (!(urb->transfer_flags & URB_ALIGNED_TEMP_BUFFER))
  		return;
-@@ -2679,9 +2680,14 @@ static void dwc2_free_dma_aligned_buffer
+@@ -2680,9 +2681,14 @@ static void dwc2_free_dma_aligned_buffer
  			 dma_get_cache_alignment()),
  	       sizeof(urb->transfer_buffer));
  
--- a/target/linux/generic/pending-4.14/190-2-5-e1000e-Fix-wrong-comment-related-to-link-detection.patch	2022-03-22 08:54:47.353464913 +0800
+++ b/target/linux/generic/pending-4.14/190-2-5-e1000e-Fix-wrong-comment-related-to-link-detection.patch	2022-03-22 12:15:54.154428764 +0800
@@ -23,7 +23,7 @@
 
 --- a/drivers/net/ethernet/intel/e1000e/netdev.c
 +++ b/drivers/net/ethernet/intel/e1000e/netdev.c
-@@ -5082,7 +5082,7 @@ static bool e1000e_has_link(struct e1000
+@@ -5080,7 +5080,7 @@ static bool e1000e_has_link(struct e1000
  
  	/* get_link_status is set on LSC (link status) interrupt or
  	 * Rx sequence error interrupt.  get_link_status will stay
@@ -32,7 +32,7 @@
  	 * for copper adapters ONLY
  	 */
  	switch (hw->phy.media_type) {
-@@ -5100,7 +5100,7 @@ static bool e1000e_has_link(struct e1000
+@@ -5098,7 +5098,7 @@ static bool e1000e_has_link(struct e1000
  		break;
  	case e1000_media_type_internal_serdes:
  		ret_val = hw->mac.ops.check_for_link(hw);
--- a/target/linux/generic/pending-4.14/201-extra_optimization.patch	2022-03-22 08:54:47.353464913 +0800
+++ b/target/linux/generic/pending-4.14/201-extra_optimization.patch	2022-03-22 12:15:54.155428757 +0800
@@ -14,19 +14,15 @@
 
 --- a/Makefile
 +++ b/Makefile
-@@ -656,12 +656,12 @@ KBUILD_CFLAGS	+= $(call cc-disable-warni
+@@ -652,9 +652,9 @@ KBUILD_CFLAGS	+= $(call cc-disable-warni
  KBUILD_CFLAGS	+= $(call cc-disable-warning, attribute-alias)
  
  ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
--KBUILD_CFLAGS	+= -Os $(call cc-disable-warning,maybe-uninitialized,)
-+KBUILD_CFLAGS	+= -Os $(call cc-disable-warning,maybe-uninitialized,) $(EXTRA_OPTIMIZATION)
- else
- ifdef CONFIG_PROFILE_ALL_BRANCHES
--KBUILD_CFLAGS	+= -O2 $(call cc-disable-warning,maybe-uninitialized,)
-+KBUILD_CFLAGS	+= -O2 $(call cc-disable-warning,maybe-uninitialized,) $(EXTRA_OPTIMIZATION)
+-KBUILD_CFLAGS   += -Os
++KBUILD_CFLAGS   += -Os $(EXTRA_OPTIMIZATION)
  else
 -KBUILD_CFLAGS   += -O2
 +KBUILD_CFLAGS   += -O2 -fno-reorder-blocks -fno-tree-ch $(EXTRA_OPTIMIZATION)
  endif
- endif
  
+ # Tell gcc to never replace conditional load with a non-conditional one
--- a/target/linux/generic/pending-4.14/203-kallsyms_uncompressed.patch	2022-03-22 08:54:47.353464913 +0800
+++ b/target/linux/generic/pending-4.14/203-kallsyms_uncompressed.patch	2022-03-22 12:15:54.155428757 +0800
@@ -75,7 +75,7 @@
  	output_label("kallsyms_token_table");
  	off = 0;
  	for (i = 0; i < 256; i++) {
-@@ -519,6 +523,9 @@ static void *find_token(unsigned char *s
+@@ -521,6 +525,9 @@ static void *find_token(unsigned char *s
  {
  	int i;
  
@@ -85,7 +85,7 @@
  	for (i = 0; i < len - 1; i++) {
  		if (str[i] == token[0] && str[i+1] == token[1])
  			return &str[i];
-@@ -591,6 +598,9 @@ static void optimize_result(void)
+@@ -593,6 +600,9 @@ static void optimize_result(void)
  {
  	int i, best;
  
@@ -95,7 +95,7 @@
  	/* using the '\0' symbol last allows compress_symbols to use standard
  	 * fast string functions */
  	for (i = 255; i >= 0; i--) {
-@@ -779,6 +789,8 @@ int main(int argc, char **argv)
+@@ -781,6 +791,8 @@ int main(int argc, char **argv)
  				symbol_prefix_char = *p;
  			} else if (strcmp(argv[i], "--base-relative") == 0)
  				base_relative = 1;
--- a/target/linux/generic/pending-4.14/205-backtrace_module_info.patch	2022-03-22 08:54:47.354464914 +0800
+++ b/target/linux/generic/pending-4.14/205-backtrace_module_info.patch	2022-03-22 12:15:54.155428757 +0800
@@ -11,7 +11,7 @@
 
 --- a/lib/vsprintf.c
 +++ b/lib/vsprintf.c
-@@ -670,8 +670,10 @@ char *symbol_string(char *buf, char *end
+@@ -696,8 +696,10 @@ char *symbol_string(char *buf, char *end
  		    struct printf_spec spec, const char *fmt)
  {
  	unsigned long value;
@@ -23,7 +23,7 @@
  #endif
  
  	if (fmt[1] == 'R')
-@@ -685,11 +687,16 @@ char *symbol_string(char *buf, char *end
+@@ -711,11 +713,16 @@ char *symbol_string(char *buf, char *end
  		sprint_symbol(sym, value);
  	else
  		sprint_symbol_no_offset(sym, value);
--- a/target/linux/generic/pending-4.14/270-platform-mikrotik-build-bits.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-4.14/270-platform-mikrotik-build-bits.patch	2022-03-22 12:15:54.157428743 +0800
@@ -0,0 +1,31 @@
+From c2deb5ef01a0ef09088832744cbace9e239a6ee0 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Thibaut=20VAR=C3=88NE?= <hacks@slashdirt.org>
+Date: Tue, 24 Mar 2020 22:11:50 +0100
+Subject: [PATCH] generic: platform/mikrotik build bits (4.14)
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This patch adds platform/mikrotik kernel build bits
+
+Signed-off-by: Thibaut VARNE <hacks@slashdirt.org>
+---
+ drivers/platform/Kconfig  | 2 ++
+ drivers/platform/Makefile | 1 +
+ 2 files changed, 3 insertions(+)
+
+--- a/drivers/platform/Kconfig
++++ b/drivers/platform/Kconfig
+@@ -8,3 +8,5 @@ endif
+ source "drivers/platform/goldfish/Kconfig"
+ 
+ source "drivers/platform/chrome/Kconfig"
++
++source "drivers/platform/mikrotik/Kconfig"
+--- a/drivers/platform/Makefile
++++ b/drivers/platform/Makefile
+@@ -8,3 +8,4 @@ obj-$(CONFIG_MIPS)		+= mips/
+ obj-$(CONFIG_OLPC)		+= olpc/
+ obj-$(CONFIG_GOLDFISH)		+= goldfish/
+ obj-$(CONFIG_CHROME_PLATFORMS)	+= chrome/
++obj-$(CONFIG_MIKROTIK)		+= mikrotik/
--- a/target/linux/generic/pending-4.14/300-mips_expose_boot_raw.patch	2022-03-22 08:54:47.355464916 +0800
+++ b/target/linux/generic/pending-4.14/300-mips_expose_boot_raw.patch	2022-03-22 12:15:54.157428743 +0800
@@ -9,7 +9,7 @@
 ---
 --- a/arch/mips/Kconfig
 +++ b/arch/mips/Kconfig
-@@ -1067,9 +1067,6 @@ config FW_ARC
+@@ -1069,9 +1069,6 @@ config FW_ARC
  config ARCH_MAY_HAVE_PC_FDC
  	bool
  
@@ -19,7 +19,7 @@
  config CEVT_BCM1480
  	bool
  
-@@ -2967,6 +2964,18 @@ choice
+@@ -2969,6 +2966,18 @@ choice
  		bool "Extend builtin kernel arguments with bootloader arguments"
  endchoice
  
--- a/target/linux/generic/pending-4.14/304-mips_disable_fpu.patch	2022-03-22 08:54:47.355464916 +0800
+++ b/target/linux/generic/pending-4.14/304-mips_disable_fpu.patch	2022-03-22 12:15:54.158428736 +0800
@@ -24,7 +24,7 @@
 
 --- a/arch/mips/Kconfig
 +++ b/arch/mips/Kconfig
-@@ -2891,6 +2891,20 @@ config MIPS_O32_FP64_SUPPORT
+@@ -2893,6 +2893,20 @@ config MIPS_O32_FP64_SUPPORT
  
  	  If unsure, say N.
  
@@ -47,7 +47,7 @@
  	select OF
 --- a/arch/mips/Makefile
 +++ b/arch/mips/Makefile
-@@ -315,7 +315,7 @@ OBJCOPYFLAGS		+= --remove-section=.regin
+@@ -326,7 +326,7 @@ OBJCOPYFLAGS		+= --remove-section=.regin
  head-y := arch/mips/kernel/head.o
  
  libs-y			+= arch/mips/lib/
--- a/target/linux/generic/pending-4.14/332-arc-add-OWRTDTB-section.patch	2022-03-22 08:54:47.358464921 +0800
+++ b/target/linux/generic/pending-4.14/332-arc-add-OWRTDTB-section.patch	2022-03-22 12:15:54.162428708 +0800
@@ -42,7 +42,7 @@
  ;----------------------------------------------------------------
 --- a/arch/arc/kernel/setup.c
 +++ b/arch/arc/kernel/setup.c
-@@ -437,6 +437,8 @@ static inline bool uboot_arg_invalid(uns
+@@ -438,6 +438,8 @@ static inline bool uboot_arg_invalid(uns
  /* We always pass 0 as magic from U-boot */
  #define UBOOT_MAGIC_VALUE	0
  
@@ -51,7 +51,7 @@
  void __init handle_uboot_args(void)
  {
  	bool use_embedded_dtb = true;
-@@ -477,7 +479,7 @@ ignore_uboot_args:
+@@ -478,7 +480,7 @@ ignore_uboot_args:
  #endif
  
  	if (use_embedded_dtb) {
--- a/target/linux/generic/pending-4.14/341-MIPS-mm-remove-no-op-dma_map_ops-where-possible.patch	2022-03-22 08:54:47.359464923 +0800
+++ b/target/linux/generic/pending-4.14/341-MIPS-mm-remove-no-op-dma_map_ops-where-possible.patch	2022-03-22 12:15:54.163428702 +0800
@@ -30,7 +30,7 @@
  	select HAVE_PCSPKR_PLATFORM
  	select IRQ_MIPS_CPU
  	select I8253
-@@ -1128,6 +1130,9 @@ config DMA_NONCOHERENT
+@@ -1130,6 +1132,9 @@ config DMA_NONCOHERENT
  	bool
  	select NEED_DMA_MAP_STATE
  
@@ -40,7 +40,7 @@
  config NEED_DMA_MAP_STATE
  	bool
  
-@@ -1652,6 +1657,7 @@ config CPU_R10000
+@@ -1654,6 +1659,7 @@ config CPU_R10000
  	select CPU_SUPPORTS_64BIT_KERNEL
  	select CPU_SUPPORTS_HIGHMEM
  	select CPU_SUPPORTS_HUGEPAGES
@@ -48,7 +48,7 @@
  	help
  	  MIPS Technologies R10000-series processors.
  
-@@ -1900,9 +1906,11 @@ config SYS_HAS_CPU_MIPS32_R3_5
+@@ -1902,9 +1908,11 @@ config SYS_HAS_CPU_MIPS32_R3_5
  	bool
  
  config SYS_HAS_CPU_MIPS32_R5
@@ -60,7 +60,7 @@
  	bool
  
  config SYS_HAS_CPU_MIPS64_R1
-@@ -1912,6 +1920,7 @@ config SYS_HAS_CPU_MIPS64_R2
+@@ -1914,6 +1922,7 @@ config SYS_HAS_CPU_MIPS64_R2
  	bool
  
  config SYS_HAS_CPU_MIPS64_R6
--- a/target/linux/generic/pending-4.14/342-powerpc-Enable-kernel-XZ-compression-option-on-PPC_8.patch	2022-03-22 08:54:47.359464923 +0800
+++ b/target/linux/generic/pending-4.14/342-powerpc-Enable-kernel-XZ-compression-option-on-PPC_8.patch	2022-03-22 12:15:54.163428702 +0800
@@ -14,7 +14,7 @@
 
 --- a/arch/powerpc/Kconfig
 +++ b/arch/powerpc/Kconfig
-@@ -199,6 +199,7 @@ config PPC
+@@ -200,6 +200,7 @@ config PPC
  	select HAVE_IOREMAP_PROT
  	select HAVE_IRQ_EXIT_ON_IRQ_STACK
  	select HAVE_KERNEL_GZIP
--- a/target/linux/generic/pending-4.14/450-mtd-spi-nor-allow-NOR-driver-to-write-fewer-bytes-th.patch	2022-03-22 08:54:47.364464931 +0800
+++ b/target/linux/generic/pending-4.14/450-mtd-spi-nor-allow-NOR-driver-to-write-fewer-bytes-th.patch	2022-03-22 12:15:54.169428660 +0800
@@ -11,7 +11,7 @@
 
 --- a/drivers/mtd/spi-nor/spi-nor.c
 +++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -1377,7 +1377,7 @@ static int spi_nor_write(struct mtd_info
+@@ -1387,7 +1387,7 @@ static int spi_nor_write(struct mtd_info
  
  		write_enable(nor);
  		ret = nor->write(nor, addr, page_remain, buf + i);
@@ -20,7 +20,7 @@
  			goto write_err;
  		written = ret;
  
-@@ -1386,13 +1386,6 @@ static int spi_nor_write(struct mtd_info
+@@ -1396,13 +1396,6 @@ static int spi_nor_write(struct mtd_info
  			goto write_err;
  		*retlen += written;
  		i += written;
--- a/target/linux/generic/pending-4.14/460-mtd-cfi_cmdset_0002-no-erase_suspend.patch	2022-03-22 08:54:47.365464933 +0800
+++ b/target/linux/generic/pending-4.14/460-mtd-cfi_cmdset_0002-no-erase_suspend.patch	2022-03-22 12:15:54.169428660 +0800
@@ -14,7 +14,7 @@
 
 --- a/drivers/mtd/chips/cfi_cmdset_0002.c
 +++ b/drivers/mtd/chips/cfi_cmdset_0002.c
-@@ -811,7 +811,7 @@ static int get_chip(struct map_info *map
+@@ -810,7 +810,7 @@ static int get_chip(struct map_info *map
  		return 0;
  
  	case FL_ERASING:
--- a/target/linux/generic/pending-4.14/461-mtd-cfi_cmdset_0002-add-buffer-write-cmd-timeout.patch	2022-03-22 08:54:47.365464933 +0800
+++ b/target/linux/generic/pending-4.14/461-mtd-cfi_cmdset_0002-add-buffer-write-cmd-timeout.patch	2022-03-22 12:15:54.169428660 +0800
@@ -7,7 +7,7 @@
  1 file changed, 1 insertion(+)
 --- a/drivers/mtd/chips/cfi_cmdset_0002.c
 +++ b/drivers/mtd/chips/cfi_cmdset_0002.c
-@@ -1839,6 +1839,7 @@ static int __xipram do_write_buffer(stru
+@@ -1838,6 +1838,7 @@ static int __xipram do_write_buffer(stru
  
  	/* Write Buffer Load */
  	map_write(map, CMD(0x25), cmd_adr);
--- a/target/linux/generic/pending-4.14/465-m25p80-mx-disable-software-protection.patch	2022-03-22 08:54:47.365464933 +0800
+++ b/target/linux/generic/pending-4.14/465-m25p80-mx-disable-software-protection.patch	2022-03-22 12:15:54.170428653 +0800
@@ -8,7 +8,7 @@
 
 --- a/drivers/mtd/spi-nor/spi-nor.c
 +++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -2714,6 +2714,7 @@ int spi_nor_scan(struct spi_nor *nor, co
+@@ -2733,6 +2733,7 @@ int spi_nor_scan(struct spi_nor *nor, co
  
  	if (JEDEC_MFR(info) == SNOR_MFR_ATMEL ||
  	    JEDEC_MFR(info) == SNOR_MFR_INTEL ||
--- a/target/linux/generic/pending-4.14/466-Revert-mtd-spi-nor-fix-Spansion-regressions-aliased-.patch	2022-03-22 08:54:47.366464934 +0800
+++ b/target/linux/generic/pending-4.14/466-Revert-mtd-spi-nor-fix-Spansion-regressions-aliased-.patch	2022-03-22 12:15:54.170428653 +0800
@@ -17,7 +17,7 @@
 
 --- a/drivers/mtd/spi-nor/spi-nor.c
 +++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -2716,6 +2716,7 @@ int spi_nor_scan(struct spi_nor *nor, co
+@@ -2735,6 +2735,7 @@ int spi_nor_scan(struct spi_nor *nor, co
  	    JEDEC_MFR(info) == SNOR_MFR_INTEL ||
  	    JEDEC_MFR(info) == SNOR_MFR_MACRONIX ||
  	    JEDEC_MFR(info) == SNOR_MFR_SST ||
@@ -25,7 +25,7 @@
  	    info->flags & SPI_NOR_HAS_LOCK) {
  		write_enable(nor);
  		write_sr(nor, 0);
-@@ -2734,7 +2735,8 @@ int spi_nor_scan(struct spi_nor *nor, co
+@@ -2753,7 +2754,8 @@ int spi_nor_scan(struct spi_nor *nor, co
  
  	/* NOR protection support for STmicro/Micron chips and similar */
  	if (JEDEC_MFR(info) == SNOR_MFR_MICRON ||
--- a/target/linux/generic/pending-4.14/470-mtd-spi-nor-support-limiting-4K-sectors-support-base.patch	2022-03-22 08:54:47.366464934 +0800
+++ b/target/linux/generic/pending-4.14/470-mtd-spi-nor-support-limiting-4K-sectors-support-base.patch	2022-03-22 12:15:54.170428653 +0800
@@ -39,7 +39,7 @@
  	depends on ARCH_AT91 || (ARM && COMPILE_TEST && !ARCH_EBSA110)
 --- a/drivers/mtd/spi-nor/spi-nor.c
 +++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -2561,10 +2561,12 @@ static int spi_nor_select_erase(struct s
+@@ -2580,10 +2580,12 @@ static int spi_nor_select_erase(struct s
  
  #ifdef CONFIG_MTD_SPI_NOR_USE_4K_SECTORS
  	/* prefer "small sector" erase if possible */
--- a/target/linux/generic/pending-4.14/475-mtd-spi-nor-Add-Winbond-w25q128jv-support.patch	2022-03-22 08:54:47.366464934 +0800
+++ b/target/linux/generic/pending-4.14/475-mtd-spi-nor-Add-Winbond-w25q128jv-support.patch	2022-03-22 12:15:54.171428646 +0800
@@ -20,7 +20,7 @@
 
 --- a/drivers/mtd/spi-nor/spi-nor.c
 +++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -1165,6 +1165,11 @@ static const struct flash_info spi_nor_i
+@@ -1175,6 +1175,11 @@ static const struct flash_info spi_nor_i
  			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
  			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
  	},
--- a/target/linux/generic/pending-4.14/476-mtd-spi-nor-add-eon-en25q128.patch	2022-03-22 08:54:47.367464936 +0800
+++ b/target/linux/generic/pending-4.14/476-mtd-spi-nor-add-eon-en25q128.patch	2022-03-22 12:15:54.171428646 +0800
@@ -8,7 +8,7 @@
 
 --- a/drivers/mtd/spi-nor/spi-nor.c
 +++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -954,6 +954,7 @@ static const struct flash_info spi_nor_i
+@@ -958,6 +958,7 @@ static const struct flash_info spi_nor_i
  	{ "en25q32b",   INFO(0x1c3016, 0, 64 * 1024,   64, 0) },
  	{ "en25p64",    INFO(0x1c2017, 0, 64 * 1024,  128, 0) },
  	{ "en25q64",    INFO(0x1c3017, 0, 64 * 1024,  128, SECT_4K) },
--- a/target/linux/generic/pending-4.14/477-mtd-add-spi-nor-add-mx25u3235f.patch	2022-03-22 08:54:47.367464936 +0800
+++ b/target/linux/generic/pending-4.14/477-mtd-add-spi-nor-add-mx25u3235f.patch	2022-03-22 12:15:54.171428646 +0800
@@ -8,7 +8,7 @@
 
 --- a/drivers/mtd/spi-nor/spi-nor.c
 +++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -1022,6 +1022,7 @@ static const struct flash_info spi_nor_i
+@@ -1032,6 +1032,7 @@ static const struct flash_info spi_nor_i
  	{ "mx25l3205d",  INFO(0xc22016, 0, 64 * 1024,  64, SECT_4K) },
  	{ "mx25l3255e",  INFO(0xc29e16, 0, 64 * 1024,  64, SECT_4K) },
  	{ "mx25l6405d",  INFO(0xc22017, 0, 64 * 1024, 128, SECT_4K) },
--- a/target/linux/generic/pending-4.14/478-mtd-spi-nor-Add-support-for-XM25QH64A-and-XM25QH128A.patch	2022-03-22 08:54:47.367464936 +0800
+++ b/target/linux/generic/pending-4.14/478-mtd-spi-nor-Add-support-for-XM25QH64A-and-XM25QH128A.patch	2022-03-22 12:15:54.172428640 +0800
@@ -17,7 +17,7 @@
 
 --- a/drivers/mtd/spi-nor/spi-nor.c
 +++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -1192,6 +1192,10 @@ static const struct flash_info spi_nor_i
+@@ -1202,6 +1202,10 @@ static const struct flash_info spi_nor_i
  	{ "3S400AN", S3AN_INFO(0x1f2400, 256, 264) },
  	{ "3S700AN", S3AN_INFO(0x1f2500, 512, 264) },
  	{ "3S1400AN", S3AN_INFO(0x1f2600, 512, 528) },
--- a/target/linux/generic/pending-4.14/479-mtd-spi-nor-add-eon-en25qh32.patch	2022-03-22 08:54:47.367464936 +0800
+++ b/target/linux/generic/pending-4.14/479-mtd-spi-nor-add-eon-en25qh32.patch	2022-03-22 12:15:54.172428640 +0800
@@ -1,6 +1,6 @@
 --- a/drivers/mtd/spi-nor/spi-nor.c
 +++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -955,6 +955,7 @@ static const struct flash_info spi_nor_i
+@@ -959,6 +959,7 @@ static const struct flash_info spi_nor_i
  	{ "en25p64",    INFO(0x1c2017, 0, 64 * 1024,  128, 0) },
  	{ "en25q64",    INFO(0x1c3017, 0, 64 * 1024,  128, SECT_4K) },
  	{ "en25q128",   INFO(0x1c3018, 0, 64 * 1024,  256, SECT_4K) },
--- a/target/linux/generic/pending-4.14/479-mtd-spi-nor-add-eon-en25qh64.patch	2022-03-22 08:54:47.368464938 +0800
+++ b/target/linux/generic/pending-4.14/479-mtd-spi-nor-add-eon-en25qh64.patch	2022-03-22 12:15:54.172428640 +0800
@@ -1,6 +1,6 @@
 --- a/drivers/mtd/spi-nor/spi-nor.c
 +++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -956,6 +956,7 @@ static const struct flash_info spi_nor_i
+@@ -960,6 +960,7 @@ static const struct flash_info spi_nor_i
  	{ "en25q64",    INFO(0x1c3017, 0, 64 * 1024,  128, SECT_4K) },
  	{ "en25q128",   INFO(0x1c3018, 0, 64 * 1024,  256, SECT_4K) },
  	{ "en25qh32",   INFO(0x1c7016, 0, 64 * 1024,   64, 0) },
--- a/target/linux/generic/pending-4.14/481-mtd-spi-nor-add-support-for-Gigadevice-GD25D05.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-4.14/481-mtd-spi-nor-add-support-for-Gigadevice-GD25D05.patch	2022-03-22 12:15:54.173428633 +0800
@@ -0,0 +1,24 @@
+From d68b4aa22e8c625685bfad642dd7337948dc0ad1 Mon Sep 17 00:00:00 2001
+From: Koen Vandeputte <koen.vandeputte@ncentric.com>
+Date: Mon, 6 Jan 2020 13:07:56 +0100
+Subject: [PATCH] mtd: spi-nor: add support for Gigadevice GD25D05
+
+Signed-off-by: Koen Vandeputte <koen.vandeputte@ncentric.com>
+---
+ drivers/mtd/spi-nor/spi-nor.c | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+--- a/drivers/mtd/spi-nor/spi-nor.c
++++ b/drivers/mtd/spi-nor/spi-nor.c
+@@ -980,6 +980,11 @@ static const struct flash_info spi_nor_i
+ 
+ 	/* GigaDevice */
+ 	{
++		"gd25d05", INFO(0xc84010, 0, 64 * 1024,  1,
++			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
++			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
++	},
++	{
+ 		"gd25q16", INFO(0xc84015, 0, 64 * 1024,  32,
+ 			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
+ 			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
--- a/target/linux/generic/pending-4.14/600-netfilter_conntrack_flush.patch	2022-03-22 08:54:47.374464948 +0800
+++ b/target/linux/generic/pending-4.14/600-netfilter_conntrack_flush.patch	2022-03-22 12:15:54.182428571 +0800
@@ -17,7 +17,7 @@
  #include <net/net_namespace.h>
  #ifdef CONFIG_SYSCTL
  #include <linux/sysctl.h>
-@@ -381,10 +382,66 @@ static int ct_open(struct inode *inode,
+@@ -382,10 +383,66 @@ static int ct_open(struct inode *inode,
  			sizeof(struct ct_iter_state));
  }
  
@@ -84,7 +84,7 @@
  	.llseek  = seq_lseek,
  	.release = seq_release_net,
  };
-@@ -488,7 +545,7 @@ static int nf_conntrack_standalone_init_
+@@ -489,7 +546,7 @@ static int nf_conntrack_standalone_init_
  	kuid_t root_uid;
  	kgid_t root_gid;
  
--- a/target/linux/generic/pending-4.14/630-packet_socket_type.patch	2022-03-22 08:54:47.376464951 +0800
+++ b/target/linux/generic/pending-4.14/630-packet_socket_type.patch	2022-03-22 12:15:54.185428550 +0800
@@ -30,7 +30,7 @@
  #define PACKET_FANOUT_LB		1
 --- a/net/packet/af_packet.c
 +++ b/net/packet/af_packet.c
-@@ -1829,6 +1829,7 @@ static int packet_rcv_spkt(struct sk_buf
+@@ -1838,6 +1838,7 @@ static int packet_rcv_spkt(struct sk_buf
  {
  	struct sock *sk;
  	struct sockaddr_pkt *spkt;
@@ -38,7 +38,7 @@
  
  	/*
  	 *	When we registered the protocol we saved the socket in the data
-@@ -1836,6 +1837,7 @@ static int packet_rcv_spkt(struct sk_buf
+@@ -1845,6 +1846,7 @@ static int packet_rcv_spkt(struct sk_buf
  	 */
  
  	sk = pt->af_packet_priv;
@@ -46,7 +46,7 @@
  
  	/*
  	 *	Yank back the headers [hope the device set this
-@@ -1848,7 +1850,7 @@ static int packet_rcv_spkt(struct sk_buf
+@@ -1857,7 +1859,7 @@ static int packet_rcv_spkt(struct sk_buf
  	 *	so that this procedure is noop.
  	 */
  
@@ -55,7 +55,7 @@
  		goto out;
  
  	if (!net_eq(dev_net(dev), sock_net(sk)))
-@@ -2075,12 +2077,12 @@ static int packet_rcv(struct sk_buff *sk
+@@ -2084,12 +2086,12 @@ static int packet_rcv(struct sk_buff *sk
  	unsigned int snaplen, res;
  	bool is_drop_n_account = false;
  
@@ -71,7 +71,7 @@
  	if (!net_eq(dev_net(dev), sock_net(sk)))
  		goto drop;
  
-@@ -2206,12 +2208,12 @@ static int tpacket_rcv(struct sk_buff *s
+@@ -2217,12 +2219,12 @@ static int tpacket_rcv(struct sk_buff *s
  	BUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h2)) != 32);
  	BUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h3)) != 48);
  
@@ -87,7 +87,7 @@
  	if (!net_eq(dev_net(dev), sock_net(sk)))
  		goto drop;
  
-@@ -3294,6 +3296,7 @@ static int packet_create(struct net *net
+@@ -3325,6 +3327,7 @@ static int packet_create(struct net *net
  	mutex_init(&po->pg_vec_lock);
  	po->rollover = NULL;
  	po->prot_hook.func = packet_rcv;
@@ -95,7 +95,7 @@
  
  	if (sock->type == SOCK_PACKET)
  		po->prot_hook.func = packet_rcv_spkt;
-@@ -3907,6 +3910,16 @@ packet_setsockopt(struct socket *sock, i
+@@ -3949,6 +3952,16 @@ packet_setsockopt(struct socket *sock, i
  		po->xmit = val ? packet_direct_xmit : dev_queue_xmit;
  		return 0;
  	}
@@ -112,7 +112,7 @@
  	default:
  		return -ENOPROTOOPT;
  	}
-@@ -3959,6 +3972,13 @@ static int packet_getsockopt(struct sock
+@@ -4001,6 +4014,13 @@ static int packet_getsockopt(struct sock
  	case PACKET_VNET_HDR:
  		val = po->has_vnet_hdr;
  		break;
@@ -128,7 +128,7 @@
  		break;
 --- a/net/packet/internal.h
 +++ b/net/packet/internal.h
-@@ -132,6 +132,7 @@ struct packet_sock {
+@@ -135,6 +135,7 @@ struct packet_sock {
  	struct net_device __rcu	*cached_dev;
  	int			(*xmit)(struct sk_buff *skb);
  	struct packet_type	prot_hook ____cacheline_aligned_in_smp;
--- a/target/linux/generic/pending-4.14/640-netfilter-nf_flow_table-add-hardware-offload-support.patch	2022-03-22 08:54:47.377464953 +0800
+++ b/target/linux/generic/pending-4.14/640-netfilter-nf_flow_table-add-hardware-offload-support.patch	2022-03-22 12:15:54.186428543 +0800
@@ -23,7 +23,7 @@
 
 --- a/include/linux/netdevice.h
 +++ b/include/linux/netdevice.h
-@@ -826,6 +826,13 @@ struct xfrmdev_ops {
+@@ -827,6 +827,13 @@ struct xfrmdev_ops {
  };
  #endif
  
@@ -37,7 +37,7 @@
  /*
   * This structure defines the management hooks for network devices.
   * The following hooks can be defined; unless noted otherwise, they are
-@@ -1057,6 +1064,10 @@ struct xfrmdev_ops {
+@@ -1058,6 +1065,10 @@ struct xfrmdev_ops {
   * int (*ndo_bridge_dellink)(struct net_device *dev, struct nlmsghdr *nlh,
   *			     u16 flags);
   *
@@ -48,7 +48,7 @@
   * int (*ndo_change_carrier)(struct net_device *dev, bool new_carrier);
   *	Called to change device carrier. Soft-devices (like dummy, team, etc)
   *	which do not represent real hardware may define this to allow their
-@@ -1281,6 +1292,8 @@ struct net_device_ops {
+@@ -1282,6 +1293,8 @@ struct net_device_ops {
  	int			(*ndo_bridge_dellink)(struct net_device *dev,
  						      struct nlmsghdr *nlh,
  						      u16 flags);
@@ -506,7 +506,7 @@
 +MODULE_ALIAS("nf-flow-table-hw");
 --- a/net/netfilter/nf_tables_api.c
 +++ b/net/netfilter/nf_tables_api.c
-@@ -4955,6 +4955,14 @@ static int nf_tables_flowtable_parse_hoo
+@@ -4962,6 +4962,14 @@ static int nf_tables_flowtable_parse_hoo
  	if (err < 0)
  		goto err1;
  
@@ -521,7 +521,7 @@
  	ops = kzalloc(sizeof(struct nf_hook_ops) * n, GFP_KERNEL);
  	if (!ops) {
  		err = -ENOMEM;
-@@ -5085,10 +5093,19 @@ static int nf_tables_newflowtable(struct
+@@ -5092,10 +5100,19 @@ static int nf_tables_newflowtable(struct
  	}
  
  	flowtable->data.type = type;
@@ -541,7 +541,7 @@
  	err = nf_tables_flowtable_parse_hook(&ctx, nla[NFTA_FLOWTABLE_HOOK],
  					     flowtable);
  	if (err < 0)
-@@ -5186,7 +5203,8 @@ static int nf_tables_fill_flowtable_info
+@@ -5193,7 +5210,8 @@ static int nf_tables_fill_flowtable_info
  	    nla_put_string(skb, NFTA_FLOWTABLE_NAME, flowtable->name) ||
  	    nla_put_be32(skb, NFTA_FLOWTABLE_USE, htonl(flowtable->use)) ||
  	    nla_put_be64(skb, NFTA_FLOWTABLE_HANDLE, cpu_to_be64(flowtable->handle),
--- a/target/linux/generic/pending-4.14/641-netfilter-nf_flow_table-support-hw-offload-through-v.patch	2022-03-22 08:54:47.378464954 +0800
+++ b/target/linux/generic/pending-4.14/641-netfilter-nf_flow_table-support-hw-offload-through-v.patch	2022-03-22 12:15:54.187428536 +0800
@@ -15,7 +15,7 @@
 
 --- a/include/linux/netdevice.h
 +++ b/include/linux/netdevice.h
-@@ -827,6 +827,7 @@ struct xfrmdev_ops {
+@@ -828,6 +828,7 @@ struct xfrmdev_ops {
  #endif
  
  struct flow_offload;
@@ -23,7 +23,7 @@
  
  enum flow_offload_type {
  	FLOW_OFFLOAD_ADD	= 0,
-@@ -1064,8 +1065,15 @@ enum flow_offload_type {
+@@ -1065,8 +1066,15 @@ enum flow_offload_type {
   * int (*ndo_bridge_dellink)(struct net_device *dev, struct nlmsghdr *nlh,
   *			     u16 flags);
   *
@@ -40,7 +40,7 @@
   *	Adds/deletes flow entry to/from net device flowtable.
   *
   * int (*ndo_change_carrier)(struct net_device *dev, bool new_carrier);
-@@ -1292,8 +1300,11 @@ struct net_device_ops {
+@@ -1293,8 +1301,11 @@ struct net_device_ops {
  	int			(*ndo_bridge_dellink)(struct net_device *dev,
  						      struct nlmsghdr *nlh,
  						      u16 flags);
@@ -79,7 +79,7 @@
  struct nf_flow_route {
 --- a/net/netfilter/nf_flow_table_hw.c
 +++ b/net/netfilter/nf_flow_table_hw.c
-@@ -19,48 +19,75 @@ struct flow_offload_hw {
+@@ -19,48 +19,77 @@ struct flow_offload_hw {
  	enum flow_offload_type	type;
  	struct flow_offload	*flow;
  	struct nf_conn		*ct;
@@ -92,6 +92,7 @@
 -static int do_flow_offload_hw(struct net *net, struct flow_offload *flow,
 -			      int type)
 +static void flow_offload_check_ethernet(struct flow_offload_tuple *tuple,
++					struct dst_entry *dst,
 +					struct flow_offload_hw_path *path)
  {
 -	struct net_device *indev;
@@ -112,7 +113,7 @@
  
 -	dev_put(indev);
 +	memcpy(path->eth_src, path->dev->dev_addr, ETH_ALEN);
-+	n = dst_neigh_lookup(tuple->dst_cache, &tuple->src_v4);
++	n = dst_neigh_lookup(dst, &tuple->src_v4);
 +	if (!n)
 +		return;
  
@@ -125,6 +126,7 @@
 -static void flow_offload_hw_work_add(struct flow_offload_hw *offload)
 +static int flow_offload_check_path(struct net *net,
 +				   struct flow_offload_tuple *tuple,
++				   struct dst_entry *dst,
 +				   struct flow_offload_hw_path *path)
  {
 -	struct net *net;
@@ -138,7 +140,7 @@
 +		return -ENOENT;
 +
 +	path->dev = dev;
-+	flow_offload_check_ethernet(tuple, path);
++	flow_offload_check_ethernet(tuple, dst, path);
  
 -	net = read_pnet(&offload->flow_hw_net);
 -	ret = do_flow_offload_hw(net, offload->flow, FLOW_OFFLOAD_ADD);
@@ -166,11 +168,11 @@
 +	/* restore devices in case the driver mangled them */
 +	offload->src.dev = src_dev;
 +	offload->dest.dev = dest_dev;
-+
-+	return ret;
-+}
  
 -	do_flow_offload_hw(net, offload->flow, FLOW_OFFLOAD_DEL);
++	return ret;
++}
++
 +static void flow_offload_hw_free(struct flow_offload_hw *offload)
 +{
 +	dev_put(offload->src.dev);
@@ -182,7 +184,7 @@
  }
  
  static void flow_offload_hw_work(struct work_struct *work)
-@@ -73,18 +100,22 @@ static void flow_offload_hw_work(struct
+@@ -73,18 +102,22 @@ static void flow_offload_hw_work(struct
  	spin_unlock_bh(&flow_offload_hw_pending_list_lock);
  
  	list_for_each_entry_safe(offload, next, &hw_offload_pending, list) {
@@ -211,7 +213,7 @@
  	}
  }
  
-@@ -97,20 +128,55 @@ static void flow_offload_queue_work(stru
+@@ -97,20 +130,56 @@ static void flow_offload_queue_work(stru
  	schedule_work(&nf_flow_offload_hw_work);
  }
  
@@ -220,17 +222,18 @@
 +{
 +	struct flow_offload_hw_path src = {};
 +	struct flow_offload_hw_path dest = {};
-+	struct flow_offload_tuple *tuple;
++	struct flow_offload_tuple *tuple_s, *tuple_d;
 +	struct flow_offload_hw *offload = NULL;
 +
 +	rcu_read_lock_bh();
 +
-+	tuple = &flow->tuplehash[FLOW_OFFLOAD_DIR_ORIGINAL].tuple;
-+	if (flow_offload_check_path(net, tuple, &src))
++	tuple_s = &flow->tuplehash[FLOW_OFFLOAD_DIR_ORIGINAL].tuple;
++	tuple_d = &flow->tuplehash[FLOW_OFFLOAD_DIR_REPLY].tuple;
++
++	if (flow_offload_check_path(net, tuple_s, tuple_d->dst_cache, &src))
 +		goto out;
 +
-+	tuple = &flow->tuplehash[FLOW_OFFLOAD_DIR_REPLY].tuple;
-+	if (flow_offload_check_path(net, tuple, &dest))
++	if (flow_offload_check_path(net, tuple_d, tuple_s->dst_cache, &dest))
 +		goto out;
 +
 +	if (!src.dev->netdev_ops->ndo_flow_offload)
@@ -270,7 +273,7 @@
  
  	flow_offload_queue_work(offload);
  }
-@@ -119,14 +185,11 @@ static void flow_offload_hw_del(struct n
+@@ -119,14 +188,11 @@ static void flow_offload_hw_del(struct n
  {
  	struct flow_offload_hw *offload;
  
@@ -286,7 +289,7 @@
  
  	flow_offload_queue_work(offload);
  }
-@@ -153,12 +216,8 @@ static void __exit nf_flow_table_hw_modu
+@@ -153,12 +219,8 @@ static void __exit nf_flow_table_hw_modu
  	nf_flow_table_hw_unregister(&flow_offload_hw);
  	cancel_work_sync(&nf_flow_offload_hw_work);
  
--- a/target/linux/generic/pending-4.14/642-net-8021q-support-hardware-flow-table-offload.patch	2022-03-22 08:54:47.378464954 +0800
+++ b/target/linux/generic/pending-4.14/642-net-8021q-support-hardware-flow-table-offload.patch	2022-03-22 12:15:54.187428536 +0800
@@ -20,7 +20,7 @@
  
  #include "vlan.h"
  #include "vlanproc.h"
-@@ -768,6 +772,27 @@ static int vlan_dev_get_iflink(const str
+@@ -769,6 +773,27 @@ static int vlan_dev_get_iflink(const str
  	return real_dev->ifindex;
  }
  
@@ -48,7 +48,7 @@
  static const struct ethtool_ops vlan_ethtool_ops = {
  	.get_link_ksettings	= vlan_ethtool_get_link_ksettings,
  	.get_drvinfo	        = vlan_ethtool_get_drvinfo,
-@@ -805,6 +830,9 @@ static const struct net_device_ops vlan_
+@@ -806,6 +831,9 @@ static const struct net_device_ops vlan_
  	.ndo_fix_features	= vlan_dev_fix_features,
  	.ndo_get_lock_subclass  = vlan_dev_get_lock_subclass,
  	.ndo_get_iflink		= vlan_dev_get_iflink,
--- a/target/linux/generic/pending-4.14/643-net-bridge-support-hardware-flow-table-offload.patch	2022-03-22 08:54:47.378464954 +0800
+++ b/target/linux/generic/pending-4.14/643-net-bridge-support-hardware-flow-table-offload.patch	2022-03-22 12:15:54.187428536 +0800
@@ -20,7 +20,7 @@
  
  #include <linux/uaccess.h>
  #include "br_private.h"
-@@ -340,6 +344,28 @@ static const struct ethtool_ops br_ethto
+@@ -347,6 +351,28 @@ static const struct ethtool_ops br_ethto
  	.get_link	= ethtool_op_get_link,
  };
  
@@ -49,7 +49,7 @@
  static const struct net_device_ops br_netdev_ops = {
  	.ndo_open		 = br_dev_open,
  	.ndo_stop		 = br_dev_stop,
-@@ -367,6 +393,9 @@ static const struct net_device_ops br_ne
+@@ -374,6 +400,9 @@ static const struct net_device_ops br_ne
  	.ndo_bridge_setlink	 = br_setlink,
  	.ndo_bridge_dellink	 = br_dellink,
  	.ndo_features_check	 = passthru_features_check,
--- a/target/linux/generic/pending-4.14/644-net-pppoe-support-hardware-flow-table-offload.patch	2022-03-22 08:54:47.379464956 +0800
+++ b/target/linux/generic/pending-4.14/644-net-pppoe-support-hardware-flow-table-offload.patch	2022-03-22 12:15:54.188428529 +0800
@@ -73,7 +73,7 @@
  #include <linux/nsproxy.h>
  #include <net/net_namespace.h>
  #include <net/netns/generic.h>
-@@ -978,8 +983,36 @@ static int pppoe_xmit(struct ppp_channel
+@@ -981,8 +986,36 @@ static int pppoe_xmit(struct ppp_channel
  	return __pppoe_xmit(sk, skb);
  }
  
--- a/target/linux/generic/pending-4.14/655-increase_skb_pad.patch	2022-03-22 08:54:47.380464958 +0800
+++ b/target/linux/generic/pending-4.14/655-increase_skb_pad.patch	2022-03-22 12:15:54.189428523 +0800
@@ -9,7 +9,7 @@
 
 --- a/include/linux/skbuff.h
 +++ b/include/linux/skbuff.h
-@@ -2494,7 +2494,7 @@ static inline int pskb_network_may_pull(
+@@ -2524,7 +2524,7 @@ static inline int pskb_network_may_pull(
   * NET_IP_ALIGN(2) + ethernet_header(14) + IP_header(20/40) + ports(8)
   */
  #ifndef NET_SKB_PAD
--- a/target/linux/generic/pending-4.14/666-Add-support-for-MAP-E-FMRs-mesh-mode.patch	2022-03-22 08:54:47.380464958 +0800
+++ b/target/linux/generic/pending-4.14/666-Add-support-for-MAP-E-FMRs-mesh-mode.patch	2022-03-22 12:15:54.189428523 +0800
@@ -143,7 +143,7 @@
  	}
  	return &ip6n->tnls[prio][h];
  }
-@@ -383,6 +394,12 @@ ip6_tnl_dev_uninit(struct net_device *de
+@@ -382,6 +393,12 @@ ip6_tnl_dev_uninit(struct net_device *de
  	struct net *net = t->net;
  	struct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);
  
@@ -156,7 +156,7 @@
  	if (dev == ip6n->fb_tnl_dev)
  		RCU_INIT_POINTER(ip6n->tnls_wc[0], NULL);
  	else
-@@ -779,6 +796,107 @@ int ip6_tnl_rcv_ctl(struct ip6_tnl *t,
+@@ -778,6 +795,107 @@ int ip6_tnl_rcv_ctl(struct ip6_tnl *t,
  }
  EXPORT_SYMBOL_GPL(ip6_tnl_rcv_ctl);
  
@@ -264,7 +264,7 @@
  static int __ip6_tnl_rcv(struct ip6_tnl *tunnel, struct sk_buff *skb,
  			 const struct tnl_ptk_info *tpi,
  			 struct metadata_dst *tun_dst,
-@@ -831,6 +949,27 @@ static int __ip6_tnl_rcv(struct ip6_tnl
+@@ -830,6 +948,27 @@ static int __ip6_tnl_rcv(struct ip6_tnl
  	skb_reset_network_header(skb);
  	memset(skb->cb, 0, sizeof(struct inet6_skb_parm));
  
@@ -292,7 +292,7 @@
  	__skb_tunnel_rx(skb, tunnel->dev, tunnel->net);
  
  	err = dscp_ecn_decapsulate(tunnel, ipv6h, skb);
-@@ -963,6 +1102,7 @@ static void init_tel_txopt(struct ipv6_t
+@@ -970,6 +1109,7 @@ static void init_tel_txopt(struct ipv6_t
  	opt->ops.opt_nflen = 8;
  }
  
@@ -300,7 +300,7 @@
  /**
   * ip6_tnl_addr_conflict - compare packet addresses to tunnel's own
   *   @t: the outgoing tunnel device
-@@ -1305,6 +1445,7 @@ ip6ip6_tnl_xmit(struct sk_buff *skb, str
+@@ -1312,6 +1452,7 @@ ip6ip6_tnl_xmit(struct sk_buff *skb, str
  {
  	struct ip6_tnl *t = netdev_priv(dev);
  	struct ipv6hdr *ipv6h;
@@ -308,7 +308,7 @@
  	int encap_limit = -1;
  	__u16 offset;
  	struct flowi6 fl6;
-@@ -1372,6 +1513,18 @@ ip6ip6_tnl_xmit(struct sk_buff *skb, str
+@@ -1379,6 +1520,18 @@ ip6ip6_tnl_xmit(struct sk_buff *skb, str
  	fl6.flowi6_uid = sock_net_uid(dev_net(dev), NULL);
  	dsfield = INET_ECN_encapsulate(dsfield, ipv6_get_dsfield(ipv6h));
  
@@ -327,7 +327,7 @@
  	if (iptunnel_handle_offloads(skb, SKB_GSO_IPXIP6))
  		return -1;
  
-@@ -1498,6 +1651,14 @@ ip6_tnl_change(struct ip6_tnl *t, const
+@@ -1505,6 +1658,14 @@ ip6_tnl_change(struct ip6_tnl *t, const
  	t->parms.link = p->link;
  	t->parms.proto = p->proto;
  	t->parms.fwmark = p->fwmark;
@@ -342,7 +342,7 @@
  	dst_cache_reset(&t->dst_cache);
  	ip6_tnl_link_config(t);
  	return 0;
-@@ -1536,6 +1697,7 @@ ip6_tnl_parm_from_user(struct __ip6_tnl_
+@@ -1543,6 +1704,7 @@ ip6_tnl_parm_from_user(struct __ip6_tnl_
  	p->flowinfo = u->flowinfo;
  	p->link = u->link;
  	p->proto = u->proto;
@@ -350,7 +350,7 @@
  	memcpy(p->name, u->name, sizeof(u->name));
  }
  
-@@ -1922,6 +2084,15 @@ static int ip6_tnl_validate(struct nlatt
+@@ -1927,6 +2089,15 @@ static int ip6_tnl_validate(struct nlatt
  	return 0;
  }
  
@@ -366,7 +366,7 @@
  static void ip6_tnl_netlink_parms(struct nlattr *data[],
  				  struct __ip6_tnl_parm *parms)
  {
-@@ -1959,6 +2130,46 @@ static void ip6_tnl_netlink_parms(struct
+@@ -1964,6 +2135,46 @@ static void ip6_tnl_netlink_parms(struct
  
  	if (data[IFLA_IPTUN_FWMARK])
  		parms->fwmark = nla_get_u32(data[IFLA_IPTUN_FWMARK]);
@@ -413,7 +413,7 @@
  }
  
  static bool ip6_tnl_netlink_encap_parms(struct nlattr *data[],
-@@ -2074,6 +2285,12 @@ static void ip6_tnl_dellink(struct net_d
+@@ -2079,6 +2290,12 @@ static void ip6_tnl_dellink(struct net_d
  
  static size_t ip6_tnl_get_size(const struct net_device *dev)
  {
@@ -426,7 +426,7 @@
  	return
  		/* IFLA_IPTUN_LINK */
  		nla_total_size(4) +
-@@ -2103,6 +2320,24 @@ static size_t ip6_tnl_get_size(const str
+@@ -2108,6 +2325,24 @@ static size_t ip6_tnl_get_size(const str
  		nla_total_size(0) +
  		/* IFLA_IPTUN_FWMARK */
  		nla_total_size(4) +
@@ -451,7 +451,7 @@
  		0;
  }
  
-@@ -2110,6 +2345,9 @@ static int ip6_tnl_fill_info(struct sk_b
+@@ -2115,6 +2350,9 @@ static int ip6_tnl_fill_info(struct sk_b
  {
  	struct ip6_tnl *tunnel = netdev_priv(dev);
  	struct __ip6_tnl_parm *parm = &tunnel->parms;
@@ -461,7 +461,7 @@
  
  	if (nla_put_u32(skb, IFLA_IPTUN_LINK, parm->link) ||
  	    nla_put_in6_addr(skb, IFLA_IPTUN_LOCAL, &parm->laddr) ||
-@@ -2119,9 +2357,27 @@ static int ip6_tnl_fill_info(struct sk_b
+@@ -2124,9 +2362,27 @@ static int ip6_tnl_fill_info(struct sk_b
  	    nla_put_be32(skb, IFLA_IPTUN_FLOWINFO, parm->flowinfo) ||
  	    nla_put_u32(skb, IFLA_IPTUN_FLAGS, parm->flags) ||
  	    nla_put_u8(skb, IFLA_IPTUN_PROTO, parm->proto) ||
@@ -490,7 +490,7 @@
  	if (nla_put_u16(skb, IFLA_IPTUN_ENCAP_TYPE, tunnel->encap.type) ||
  	    nla_put_be16(skb, IFLA_IPTUN_ENCAP_SPORT, tunnel->encap.sport) ||
  	    nla_put_be16(skb, IFLA_IPTUN_ENCAP_DPORT, tunnel->encap.dport) ||
-@@ -2161,6 +2417,7 @@ static const struct nla_policy ip6_tnl_p
+@@ -2166,6 +2422,7 @@ static const struct nla_policy ip6_tnl_p
  	[IFLA_IPTUN_ENCAP_DPORT]	= { .type = NLA_U16 },
  	[IFLA_IPTUN_COLLECT_METADATA]	= { .type = NLA_FLAG },
  	[IFLA_IPTUN_FWMARK]		= { .type = NLA_U32 },
--- a/target/linux/generic/pending-4.14/670-ipv6-allow-rejecting-with-source-address-failed-policy.patch	2022-03-22 08:54:47.380464958 +0800
+++ b/target/linux/generic/pending-4.14/670-ipv6-allow-rejecting-with-source-address-failed-policy.patch	2022-03-22 12:15:54.190428516 +0800
@@ -66,7 +66,7 @@
  static void rt_fibinfo_free(struct rtable __rcu **rtp)
 --- a/net/ipv4/fib_trie.c
 +++ b/net/ipv4/fib_trie.c
-@@ -2469,6 +2469,7 @@ static const char *const rtn_type_names[
+@@ -2472,6 +2472,7 @@ static const char *const rtn_type_names[
  	[RTN_THROW] = "THROW",
  	[RTN_NAT] = "NAT",
  	[RTN_XRESOLVE] = "XRESOLVE",
@@ -118,8 +118,8 @@
 +static int		ip6_pkt_policy_failed_out(struct net *net, struct sock *sk, struct sk_buff *skb);
  static void		ip6_link_failure(struct sk_buff *skb);
  static void		ip6_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,
- 					   struct sk_buff *skb, u32 mtu);
-@@ -321,6 +323,21 @@ static const struct rt6_info ip6_prohibi
+ 					   struct sk_buff *skb, u32 mtu,
+@@ -323,6 +325,21 @@ static const struct rt6_info ip6_prohibi
  	.rt6i_ref	= ATOMIC_INIT(1),
  };
  
@@ -141,7 +141,7 @@
  static const struct rt6_info ip6_blk_hole_entry_template = {
  	.dst = {
  		.__refcnt	= ATOMIC_INIT(1),
-@@ -2046,6 +2063,11 @@ static struct rt6_info *ip6_route_info_c
+@@ -2056,6 +2073,11 @@ static struct rt6_info *ip6_route_info_c
  			rt->dst.output = ip6_pkt_prohibit_out;
  			rt->dst.input = ip6_pkt_prohibit;
  			break;
@@ -153,7 +153,7 @@
  		case RTN_THROW:
  		case RTN_UNREACHABLE:
  		default:
-@@ -2771,6 +2793,17 @@ static int ip6_pkt_prohibit_out(struct n
+@@ -2781,6 +2803,17 @@ static int ip6_pkt_prohibit_out(struct n
  	return ip6_pkt_drop(skb, ICMPV6_ADM_PROHIBITED, IPSTATS_MIB_OUTNOROUTES);
  }
  
@@ -171,7 +171,7 @@
  /*
   *	Allocate a dst for local (unicast / anycast) address.
   */
-@@ -3007,7 +3040,8 @@ static int rtm_to_fib6_config(struct sk_
+@@ -3017,7 +3050,8 @@ static int rtm_to_fib6_config(struct sk_
  	if (rtm->rtm_type == RTN_UNREACHABLE ||
  	    rtm->rtm_type == RTN_BLACKHOLE ||
  	    rtm->rtm_type == RTN_PROHIBIT ||
@@ -181,7 +181,7 @@
  		cfg->fc_flags |= RTF_REJECT;
  
  	if (rtm->rtm_type == RTN_LOCAL)
-@@ -3506,6 +3540,9 @@ static int rt6_fill_node(struct net *net
+@@ -3519,6 +3553,9 @@ static int rt6_fill_node(struct net *net
  		case -EACCES:
  			rtm->rtm_type = RTN_PROHIBIT;
  			break;
@@ -191,7 +191,7 @@
  		case -EAGAIN:
  			rtm->rtm_type = RTN_THROW;
  			break;
-@@ -3824,6 +3861,8 @@ static int ip6_route_dev_notify(struct n
+@@ -3837,6 +3874,8 @@ static int ip6_route_dev_notify(struct n
  #ifdef CONFIG_IPV6_MULTIPLE_TABLES
  		net->ipv6.ip6_prohibit_entry->dst.dev = dev;
  		net->ipv6.ip6_prohibit_entry->rt6i_idev = in6_dev_get(dev);
@@ -200,7 +200,7 @@
  		net->ipv6.ip6_blk_hole_entry->dst.dev = dev;
  		net->ipv6.ip6_blk_hole_entry->rt6i_idev = in6_dev_get(dev);
  #endif
-@@ -3835,6 +3874,7 @@ static int ip6_route_dev_notify(struct n
+@@ -3848,6 +3887,7 @@ static int ip6_route_dev_notify(struct n
  		in6_dev_put_clear(&net->ipv6.ip6_null_entry->rt6i_idev);
  #ifdef CONFIG_IPV6_MULTIPLE_TABLES
  		in6_dev_put_clear(&net->ipv6.ip6_prohibit_entry->rt6i_idev);
@@ -208,7 +208,7 @@
  		in6_dev_put_clear(&net->ipv6.ip6_blk_hole_entry->rt6i_idev);
  #endif
  	}
-@@ -4051,6 +4091,17 @@ static int __net_init ip6_route_net_init
+@@ -4064,6 +4104,17 @@ static int __net_init ip6_route_net_init
  	net->ipv6.ip6_blk_hole_entry->dst.ops = &net->ipv6.ip6_dst_ops;
  	dst_init_metrics(&net->ipv6.ip6_blk_hole_entry->dst,
  			 ip6_template_metrics, true);
@@ -226,7 +226,7 @@
  #endif
  
  	net->ipv6.sysctl.flush_delay = 0;
-@@ -4069,6 +4120,8 @@ out:
+@@ -4082,6 +4133,8 @@ out:
  	return ret;
  
  #ifdef CONFIG_IPV6_MULTIPLE_TABLES
@@ -235,7 +235,7 @@
  out_ip6_prohibit_entry:
  	kfree(net->ipv6.ip6_prohibit_entry);
  out_ip6_null_entry:
-@@ -4086,6 +4139,7 @@ static void __net_exit ip6_route_net_exi
+@@ -4099,6 +4152,7 @@ static void __net_exit ip6_route_net_exi
  #ifdef CONFIG_IPV6_MULTIPLE_TABLES
  	kfree(net->ipv6.ip6_prohibit_entry);
  	kfree(net->ipv6.ip6_blk_hole_entry);
@@ -243,7 +243,7 @@
  #endif
  	dst_entries_destroy(&net->ipv6.ip6_dst_ops);
  }
-@@ -4159,6 +4213,9 @@ void __init ip6_route_init_special_entri
+@@ -4172,6 +4226,9 @@ void __init ip6_route_init_special_entri
  	init_net.ipv6.ip6_prohibit_entry->rt6i_idev = in6_dev_get(init_net.loopback_dev);
  	init_net.ipv6.ip6_blk_hole_entry->dst.dev = init_net.loopback_dev;
  	init_net.ipv6.ip6_blk_hole_entry->rt6i_idev = in6_dev_get(init_net.loopback_dev);
--- a/target/linux/generic/pending-4.14/680-NET-skip-GRO-for-foreign-MAC-addresses.patch	2022-03-22 08:54:47.381464959 +0800
+++ b/target/linux/generic/pending-4.14/680-NET-skip-GRO-for-foreign-MAC-addresses.patch	2022-03-22 12:15:54.191428509 +0800
@@ -11,7 +11,7 @@
 
 --- a/include/linux/netdevice.h
 +++ b/include/linux/netdevice.h
-@@ -1766,6 +1766,8 @@ struct net_device {
+@@ -1772,6 +1772,8 @@ struct net_device {
  	struct netdev_hw_addr_list	mc;
  	struct netdev_hw_addr_list	dev_addrs;
  
@@ -32,7 +32,7 @@
  	__u16			tc_index;	/* traffic control index */
 --- a/net/core/dev.c
 +++ b/net/core/dev.c
-@@ -4805,6 +4805,9 @@ static enum gro_result dev_gro_receive(s
+@@ -4802,6 +4802,9 @@ static enum gro_result dev_gro_receive(s
  	enum gro_result ret;
  	int grow;
  
@@ -42,7 +42,7 @@
  	if (netif_elide_gro(skb->dev))
  		goto normal;
  
-@@ -6282,6 +6285,48 @@ static void __netdev_adjacent_dev_unlink
+@@ -6287,6 +6290,48 @@ static void __netdev_adjacent_dev_unlink
  					   &upper_dev->adj_list.lower);
  }
  
@@ -91,7 +91,7 @@
  static int __netdev_upper_dev_link(struct net_device *dev,
  				   struct net_device *upper_dev, bool master,
  				   void *upper_priv, void *upper_info)
-@@ -6320,6 +6365,7 @@ static int __netdev_upper_dev_link(struc
+@@ -6325,6 +6370,7 @@ static int __netdev_upper_dev_link(struc
  	if (ret)
  		return ret;
  
@@ -99,7 +99,7 @@
  	ret = call_netdevice_notifiers_info(NETDEV_CHANGEUPPER, dev,
  					    &changeupper_info.info);
  	ret = notifier_to_errno(ret);
-@@ -6397,6 +6443,7 @@ void netdev_upper_dev_unlink(struct net_
+@@ -6402,6 +6448,7 @@ void netdev_upper_dev_unlink(struct net_
  
  	__netdev_adjacent_dev_unlink_neighbour(dev, upper_dev);
  
@@ -107,7 +107,7 @@
  	call_netdevice_notifiers_info(NETDEV_CHANGEUPPER, dev,
  				      &changeupper_info.info);
  }
-@@ -6969,6 +7016,7 @@ int dev_set_mac_address(struct net_devic
+@@ -6966,6 +7013,7 @@ int dev_set_mac_address(struct net_devic
  	if (err)
  		return err;
  	dev->addr_assign_type = NET_ADDR_SET;
--- a/target/linux/generic/pending-4.14/701-phy_extension.patch	2022-03-22 08:54:47.382464961 +0800
+++ b/target/linux/generic/pending-4.14/701-phy_extension.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,95 +0,0 @@
-From: John Crispin <john@phrozen.org>
-Subject: net: phy: add phy_ethtool_ioctl()
-
-Signed-off-by: John Crispin <john@phrozen.org>
----
- drivers/net/phy/phy.c | 44 ++++++++++++++++++++++++++++++++++++++++++++
- include/linux/phy.h   |  1 +
- 2 files changed, 45 insertions(+)
-
---- a/drivers/net/phy/phy.c
-+++ b/drivers/net/phy/phy.c
-@@ -382,6 +382,73 @@ void phy_ethtool_ksettings_get(struct ph
- }
- EXPORT_SYMBOL(phy_ethtool_ksettings_get);
- 
-+static int phy_ethtool_gset(struct phy_device *phydev, struct ethtool_cmd *cmd)
-+{
-+	cmd->supported = phydev->supported;
-+
-+	cmd->advertising = phydev->advertising;
-+	cmd->lp_advertising = phydev->lp_advertising;
-+
-+	ethtool_cmd_speed_set(cmd, phydev->speed);
-+	cmd->duplex = phydev->duplex;
-+	if (phydev->interface == PHY_INTERFACE_MODE_MOCA)
-+		cmd->port = PORT_BNC;
-+	else
-+		cmd->port = PORT_MII;
-+	cmd->phy_address = phydev->mdio.addr;
-+	cmd->transceiver = phy_is_internal(phydev) ?
-+		XCVR_INTERNAL : XCVR_EXTERNAL;
-+	cmd->autoneg = phydev->autoneg;
-+	cmd->eth_tp_mdix_ctrl = phydev->mdix_ctrl;
-+	cmd->eth_tp_mdix = phydev->mdix;
-+
-+	return 0;
-+}
-+
-+int phy_ethtool_ioctl(struct phy_device *phydev, void *useraddr)
-+{
-+	u32 cmd;
-+	int tmp;
-+	struct ethtool_cmd ecmd = { ETHTOOL_GSET };
-+	struct ethtool_value edata = { ETHTOOL_GLINK };
-+
-+	if (get_user(cmd, (u32 *) useraddr))
-+		return -EFAULT;
-+
-+	switch (cmd) {
-+	case ETHTOOL_GSET:
-+		phy_ethtool_gset(phydev, &ecmd);
-+		if (copy_to_user(useraddr, &ecmd, sizeof(ecmd)))
-+			return -EFAULT;
-+		return 0;
-+
-+	case ETHTOOL_SSET:
-+		if (copy_from_user(&ecmd, useraddr, sizeof(ecmd)))
-+			return -EFAULT;
-+		return phy_ethtool_sset(phydev, &ecmd);
-+
-+	case ETHTOOL_NWAY_RST:
-+		/* if autoneg is off, it's an error */
-+		tmp = phy_read(phydev, MII_BMCR);
-+		if (tmp & BMCR_ANENABLE) {
-+			tmp |= (BMCR_ANRESTART);
-+			phy_write(phydev, MII_BMCR, tmp);
-+			return 0;
-+		}
-+		return -EINVAL;
-+
-+	case ETHTOOL_GLINK:
-+		edata.data = (phy_read(phydev,
-+				MII_BMSR) & BMSR_LSTATUS) ? 1 : 0;
-+		if (copy_to_user(useraddr, &edata, sizeof(edata)))
-+			return -EFAULT;
-+		return 0;
-+	}
-+
-+	return -EOPNOTSUPP;
-+}
-+EXPORT_SYMBOL(phy_ethtool_ioctl);
-+
- /**
-  * phy_mii_ioctl - generic PHY MII ioctl interface
-  * @phydev: the phy_device struct
---- a/include/linux/phy.h
-+++ b/include/linux/phy.h
-@@ -909,6 +909,7 @@ void phy_ethtool_ksettings_get(struct ph
- 			       struct ethtool_link_ksettings *cmd);
- int phy_ethtool_ksettings_set(struct phy_device *phydev,
- 			      const struct ethtool_link_ksettings *cmd);
-+int phy_ethtool_ioctl(struct phy_device *phydev, void *useraddr);
- int phy_mii_ioctl(struct phy_device *phydev, struct ifreq *ifr, int cmd);
- int phy_start_interrupts(struct phy_device *phydev);
- void phy_print_status(struct phy_device *phydev);
--- a/target/linux/generic/pending-4.14/703-phy-add-detach-callback-to-struct-phy_driver.patch	2022-03-22 08:54:47.382464961 +0800
+++ b/target/linux/generic/pending-4.14/703-phy-add-detach-callback-to-struct-phy_driver.patch	2022-03-22 12:15:54.192428502 +0800
@@ -11,7 +11,7 @@
 
 --- a/drivers/net/phy/phy_device.c
 +++ b/drivers/net/phy/phy_device.c
-@@ -1105,6 +1105,9 @@ void phy_detach(struct phy_device *phyde
+@@ -1110,6 +1110,9 @@ void phy_detach(struct phy_device *phyde
  	struct module *ndev_owner = dev->dev.parent->driver->owner;
  	struct mii_bus *bus;
  
@@ -23,7 +23,7 @@
  		sysfs_remove_link(&phydev->mdio.dev.kobj, "attached_dev");
 --- a/include/linux/phy.h
 +++ b/include/linux/phy.h
-@@ -559,6 +559,12 @@ struct phy_driver {
+@@ -561,6 +561,12 @@ struct phy_driver {
  	 */
  	int (*did_interrupt)(struct phy_device *phydev);
  
--- a/target/linux/generic/pending-4.14/810-pci_disable_common_quirks.patch	2022-03-22 08:54:47.384464964 +0800
+++ b/target/linux/generic/pending-4.14/810-pci_disable_common_quirks.patch	2022-03-22 12:15:54.194428488 +0800
@@ -24,7 +24,7 @@
  	default y
 --- a/drivers/pci/quirks.c
 +++ b/drivers/pci/quirks.c
-@@ -43,6 +43,7 @@ static void quirk_mmio_always_on(struct
+@@ -44,6 +44,7 @@ static void quirk_mmio_always_on(struct
  DECLARE_PCI_FIXUP_CLASS_EARLY(PCI_ANY_ID, PCI_ANY_ID,
  				PCI_CLASS_BRIDGE_HOST, 8, quirk_mmio_always_on);
  
@@ -32,7 +32,7 @@
  /* The Mellanox Tavor device gives false positive parity errors
   * Mark this device with a broken_parity_status, to allow
   * PCI scanning code to "skip" this now blacklisted device.
-@@ -3094,6 +3095,7 @@ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_I
+@@ -3108,6 +3109,7 @@ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_I
  DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x65f9, quirk_intel_mc_errata);
  DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x65fa, quirk_intel_mc_errata);
  
@@ -40,7 +40,7 @@
  
  /*
   * Ivytown NTB BAR sizes are misreported by the hardware due to an erratum.  To
-@@ -3150,6 +3152,8 @@ static void fixup_debug_report(struct pc
+@@ -3164,6 +3166,8 @@ static void fixup_debug_report(struct pc
  	}
  }
  
@@ -49,7 +49,7 @@
  /*
   * Some BIOS implementations leave the Intel GPU interrupts enabled,
   * even though no one is handling them (f.e. i915 driver is never loaded).
-@@ -3188,6 +3192,8 @@ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_IN
+@@ -3202,6 +3206,8 @@ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_IN
  DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x010a, disable_igfx_irq);
  DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x0152, disable_igfx_irq);
  
--- a/target/linux/generic/pending-4.14/834-ledtrig-libata.patch	2022-03-22 08:54:47.384464964 +0800
+++ b/target/linux/generic/pending-4.14/834-ledtrig-libata.patch	2022-03-22 12:15:54.195428481 +0800
@@ -45,7 +45,7 @@
  	depends on ACPI
 --- a/drivers/ata/libata-core.c
 +++ b/drivers/ata/libata-core.c
-@@ -731,6 +731,19 @@ u64 ata_tf_read_block(const struct ata_t
+@@ -730,6 +730,19 @@ u64 ata_tf_read_block(const struct ata_t
  	return block;
  }
  
@@ -65,7 +65,7 @@
  /**
   *	ata_build_rw_tf - Build ATA taskfile for given read/write request
   *	@tf: Target ATA taskfile
-@@ -5124,6 +5137,9 @@ struct ata_queued_cmd *ata_qc_new_init(s
+@@ -5125,6 +5138,9 @@ struct ata_queued_cmd *ata_qc_new_init(s
  		if (tag < 0)
  			return NULL;
  	}
@@ -75,7 +75,7 @@
  
  	qc = __ata_qc_from_tag(ap, tag);
  	qc->tag = tag;
-@@ -6025,6 +6041,9 @@ struct ata_port *ata_port_alloc(struct a
+@@ -6028,6 +6044,9 @@ struct ata_port *ata_port_alloc(struct a
  	ap->stats.unhandled_irq = 1;
  	ap->stats.idle_irq = 1;
  #endif
@@ -85,7 +85,7 @@
  	ata_sff_port_init(ap);
  
  	return ap;
-@@ -6046,6 +6065,12 @@ static void ata_host_release(struct devi
+@@ -6049,6 +6068,12 @@ static void ata_host_release(struct devi
  
  		kfree(ap->pmp_link);
  		kfree(ap->slave_link);
@@ -98,7 +98,7 @@
  		kfree(ap);
  		host->ports[i] = NULL;
  	}
-@@ -6492,7 +6517,23 @@ int ata_host_register(struct ata_host *h
+@@ -6495,7 +6520,23 @@ int ata_host_register(struct ata_host *h
  		host->ports[i]->print_id = atomic_inc_return(&ata_print_id);
  		host->ports[i]->local_port_no = i + 1;
  	}
@@ -124,17 +124,17 @@
  		rc = ata_tport_add(host->dev,host->ports[i]);
 --- a/include/linux/libata.h
 +++ b/include/linux/libata.h
-@@ -38,6 +38,9 @@
- #include <linux/acpi.h>
+@@ -39,6 +39,9 @@
  #include <linux/cdrom.h>
  #include <linux/sched.h>
+ #include <linux/async.h>
 +#ifdef CONFIG_ATA_LEDS
 +#include <linux/leds.h>
 +#endif
  
  /*
   * Define if arch has non-standard setup.  This is a _PCI_ standard
-@@ -890,6 +893,12 @@ struct ata_port {
+@@ -895,6 +898,12 @@ struct ata_port {
  #ifdef CONFIG_ATA_ACPI
  	struct ata_acpi_gtm	__acpi_init_gtm; /* use ata_acpi_init_gtm() */
  #endif
--- a/target/linux/generic/pending-4.19/0931-w1-gpio-fix-problem-with-platfom-data-in-w1-gpio.patch	2022-03-22 08:54:47.385464966 +0800
+++ b/target/linux/generic/pending-4.19/0931-w1-gpio-fix-problem-with-platfom-data-in-w1-gpio.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,26 +0,0 @@
-From d9c8bc8c1408f3e8529db6e4e04017b4c579c342 Mon Sep 17 00:00:00 2001
-From: Pawel Dembicki <paweldembicki@gmail.com>
-Date: Sun, 18 Feb 2018 17:08:04 +0100
-Subject: [PATCH] w1: gpio: fix problem with platfom data in w1-gpio
-
-In devices, where fdt is used, is impossible to apply platform data
-without proper fdt node.
-
-This patch allow to use platform data in devices with fdt.
-
-Signed-off-by: Pawel Dembicki <paweldembicki@gmail.com>
----
- drivers/w1/masters/w1-gpio.c | 7 +++----
- 1 file changed, 3 insertions(+), 4 deletions(-)
-
---- a/drivers/w1/masters/w1-gpio.c
-+++ b/drivers/w1/masters/w1-gpio.c
-@@ -79,7 +79,7 @@ static int w1_gpio_probe(struct platform
- 	enum gpiod_flags gflags = GPIOD_OUT_LOW_OPEN_DRAIN;
- 	int err;
- 
--	if (of_have_populated_dt()) {
-+	if (of_have_populated_dt() && !dev_get_platdata(&pdev->dev)) {
- 		pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
- 		if (!pdata)
- 			return -ENOMEM;
--- a/target/linux/generic/pending-4.19/102-MIPS-only-process-negative-stack-offsets-on-stack-tr.patch	2022-03-22 08:54:47.386464968 +0800
+++ b/target/linux/generic/pending-4.19/102-MIPS-only-process-negative-stack-offsets-on-stack-tr.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,57 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Wed, 18 Apr 2018 10:50:05 +0200
-Subject: [PATCH] MIPS: only process negative stack offsets on stack traces
-
-Fixes endless back traces in cases where the compiler emits a stack
-pointer increase in a branch delay slot (probably for some form of
-function return).
-
-[    3.475442] BUG: MAX_STACK_TRACE_ENTRIES too low!
-[    3.480070] turning off the locking correctness validator.
-[    3.485521] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.14.34 #0
-[    3.491475] Stack : 00000000 00000000 00000000 00000000 80e0fce2 00000034 00000000 00000000
-[    3.499764]         87c3838c 80696377 8061047c 00000000 00000001 00000001 87c2d850 6534689f
-[    3.508059]         00000000 00000000 80e10000 00000000 00000000 000000cf 0000000f 00000000
-[    3.516353]         00000000 806a0000 00076891 00000000 00000000 00000000 ffffffff 00000000
-[    3.524648]         806c0000 00000004 80e10000 806a0000 00000003 80690000 00000000 80700000
-[    3.532942]         ...
-[    3.535362] Call Trace:
-[    3.537818] [<80010a48>] show_stack+0x58/0x100
-[    3.542207] [<804c2f78>] dump_stack+0xe8/0x170
-[    3.546613] [<80079f90>] save_trace+0xf0/0x110
-[    3.551010] [<8007b1ec>] mark_lock+0x33c/0x78c
-[    3.555413] [<8007bf48>] __lock_acquire+0x2ac/0x1a08
-[    3.560337] [<8007de60>] lock_acquire+0x64/0x8c
-[    3.564846] [<804e1570>] _raw_spin_lock_irqsave+0x54/0x78
-[    3.570186] [<801b618c>] kernfs_notify+0x94/0xac
-[    3.574770] [<801b7b10>] sysfs_notify+0x74/0xa0
-[    3.579257] [<801b618c>] kernfs_notify+0x94/0xac
-[    3.583839] [<801b7b10>] sysfs_notify+0x74/0xa0
-[    3.588329] [<801b618c>] kernfs_notify+0x94/0xac
-[    3.592911] [<801b7b10>] sysfs_notify+0x74/0xa0
-[    3.597401] [<801b618c>] kernfs_notify+0x94/0xac
-[    3.601983] [<801b7b10>] sysfs_notify+0x74/0xa0
-[    3.606473] [<801b618c>] kernfs_notify+0x94/0xac
-[    3.611055] [<801b7b10>] sysfs_notify+0x74/0xa0
-[    3.615545] [<801b618c>] kernfs_notify+0x94/0xac
-[    3.620125] [<801b7b10>] sysfs_notify+0x74/0xa0
-[    3.624619] [<801b618c>] kernfs_notify+0x94/0xac
-[    3.629197] [<801b7b10>] sysfs_notify+0x74/0xa0
-[    3.633691] [<801b618c>] kernfs_notify+0x94/0xac
-[    3.638269] [<801b7b10>] sysfs_notify+0x74/0xa0
-[    3.642763] [<801b618c>] kernfs_notify+0x94/0xac
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/arch/mips/kernel/process.c
-+++ b/arch/mips/kernel/process.c
-@@ -361,6 +361,8 @@ static inline int is_sp_move_ins(union m
- 
- 	if (ip->i_format.opcode == addiu_op ||
- 	    ip->i_format.opcode == daddiu_op) {
-+		if (ip->i_format.simmediate > 0)
-+			return 0;
- 		*frame_size = -ip->i_format.simmediate;
- 		return 1;
- 	}
--- a/target/linux/generic/pending-4.19/103-MIPS-perf-ath79-Fix-perfcount-IRQ-assignment.patch	2022-03-22 08:54:47.386464968 +0800
+++ b/target/linux/generic/pending-4.19/103-MIPS-perf-ath79-Fix-perfcount-IRQ-assignment.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,110 +0,0 @@
-From 852a88f35f4b7e5ebb717fed3c3a3330d5ad4336 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Petr=20=C5=A0tetiar?= <ynezz@true.cz>
-Date: Wed, 10 Apr 2019 16:43:27 +0200
-Subject: [PATCH v2] MIPS: perf: ath79: Fix perfcount IRQ assignment
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Currently it's not possible to use perf on ath79 due to genirq flags
-mismatch happening on static virtual IRQ 13 which is used for
-performance counters hardware IRQ 5.
-
-On TP-Link Archer C7v5:
-
-           CPU0
-  2:          0      MIPS   2  ath9k
-  4:        318      MIPS   4  19000000.eth
-  7:      55034      MIPS   7  timer
-  8:       1236      MISC   3  ttyS0
- 12:          0      INTC   1  ehci_hcd:usb1
- 13:          0  gpio-ath79   2  keys
- 14:          0  gpio-ath79   5  keys
- 15:         31  AR724X PCI    1  ath10k_pci
-
- $ perf top
- genirq: Flags mismatch irq 13. 00014c83 (mips_perf_pmu) vs. 00002003 (keys)
-
-On TP-Link Archer C7v4:
-
-         CPU0
-  4:          0      MIPS   4  19000000.eth
-  5:       7135      MIPS   5  1a000000.eth
-  7:      98379      MIPS   7  timer
-  8:         30      MISC   3  ttyS0
- 12:      90028      INTC   0  ath9k
- 13:       5520      INTC   1  ehci_hcd:usb1
- 14:       4623      INTC   2  ehci_hcd:usb2
- 15:      32844  AR724X PCI    1  ath10k_pci
- 16:          0  gpio-ath79  16  keys
- 23:          0  gpio-ath79  23  keys
-
- $ perf top
- genirq: Flags mismatch irq 13. 00014c80 (mips_perf_pmu) vs. 00000080 (ehci_hcd:usb1)
-
-This problem is happening, because currently statically assigned virtual
-IRQ 13 for performance counters is not claimed during the initialization
-of MIPS PMU during the bootup, so the IRQ subsystem doesn't know, that
-this interrupt isn't available for further use.
-
-So this patch fixes the issue by simply booking hardware IRQ 5 for MIPS PMU.
-
-Tested-by: Kevin 'ldir' Darbyshire-Bryant <ldir@darbyshire-bryant.me.uk>
-Signed-off-by: Petr tetiar <ynezz@true.cz>
----
-
-Changes since v1:
-
- I've incorporated two comments which I've received on IRC from blogic and
- I've also reworded the commit message to match the changes in v2 of this
- patch.
-
-  * use actual hardware perfcount IRQ 5 instead of the virtual IRQ 13
-  * dropped the CONFIG_PERF_EVENTS ifdef around irq_create_mapping
-
- arch/mips/ath79/setup.c          |  6 ------
- drivers/irqchip/irq-ath79-misc.c | 11 +++++++++++
- 2 files changed, 11 insertions(+), 6 deletions(-)
-
---- a/arch/mips/ath79/setup.c
-+++ b/arch/mips/ath79/setup.c
-@@ -211,12 +211,6 @@ const char *get_system_type(void)
- 	return ath79_sys_type;
- }
- 
--int get_c0_perfcount_int(void)
--{
--	return ATH79_MISC_IRQ(5);
--}
--EXPORT_SYMBOL_GPL(get_c0_perfcount_int);
--
- unsigned int get_c0_compare_int(void)
- {
- 	return CP0_LEGACY_COMPARE_IRQ;
---- a/drivers/irqchip/irq-ath79-misc.c
-+++ b/drivers/irqchip/irq-ath79-misc.c
-@@ -22,6 +22,15 @@
- #define AR71XX_RESET_REG_MISC_INT_ENABLE	4
- 
- #define ATH79_MISC_IRQ_COUNT			32
-+#define ATH79_MISC_PERF_IRQ			5
-+
-+static int ath79_perfcount_irq;
-+
-+int get_c0_perfcount_int(void)
-+{
-+	return ath79_perfcount_irq;
-+}
-+EXPORT_SYMBOL_GPL(get_c0_perfcount_int);
- 
- static void ath79_misc_irq_handler(struct irq_desc *desc)
- {
-@@ -113,6 +122,8 @@ static void __init ath79_misc_intc_domai
- {
- 	void __iomem *base = domain->host_data;
- 
-+	ath79_perfcount_irq = irq_create_mapping(domain, ATH79_MISC_PERF_IRQ);
-+
- 	/* Disable and clear all interrupts */
- 	__raw_writel(0, base + AR71XX_RESET_REG_MISC_INT_ENABLE);
- 	__raw_writel(0, base + AR71XX_RESET_REG_MISC_INT_STATUS);
--- a/target/linux/generic/pending-4.19/110-ehci_hcd_ignore_oc.patch	2022-03-22 08:54:47.387464969 +0800
+++ b/target/linux/generic/pending-4.19/110-ehci_hcd_ignore_oc.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,79 +0,0 @@
-From: Florian Fainelli <florian@openwrt.org>
-Subject: USB: EHCI: add ignore_oc flag to disable overcurrent checking
-
-This patch adds an ignore_oc flag which can be set by EHCI controller
-not supporting or wanting to disable overcurrent checking. The EHCI
-platform data in include/linux/usb/ehci_pdriver.h is also augmented to
-take advantage of this new flag.
-
-Signed-off-by: Florian Fainelli <florian@openwrt.org>
----
- drivers/usb/host/ehci-hcd.c      |    2 +-
- drivers/usb/host/ehci-hub.c      |    4 ++--
- drivers/usb/host/ehci-platform.c |    1 +
- drivers/usb/host/ehci.h          |    1 +
- include/linux/usb/ehci_pdriver.h |    1 +
- 5 files changed, 6 insertions(+), 3 deletions(-)
-
---- a/drivers/usb/host/ehci-hcd.c
-+++ b/drivers/usb/host/ehci-hcd.c
-@@ -638,7 +638,7 @@ static int ehci_run (struct usb_hcd *hcd
- 		"USB %x.%x started, EHCI %x.%02x%s\n",
- 		((ehci->sbrn & 0xf0)>>4), (ehci->sbrn & 0x0f),
- 		temp >> 8, temp & 0xff,
--		ignore_oc ? ", overcurrent ignored" : "");
-+		(ignore_oc || ehci->ignore_oc) ? ", overcurrent ignored" : "");
- 
- 	ehci_writel(ehci, INTR_MASK,
- 		    &ehci->regs->intr_enable); /* Turn On Interrupts */
---- a/drivers/usb/host/ehci-hub.c
-+++ b/drivers/usb/host/ehci-hub.c
-@@ -641,7 +641,7 @@ ehci_hub_status_data (struct usb_hcd *hc
- 	 * always set, seem to clear PORT_OCC and PORT_CSC when writing to
- 	 * PORT_POWER; that's surprising, but maybe within-spec.
- 	 */
--	if (!ignore_oc)
-+	if (!ignore_oc && !ehci->ignore_oc)
- 		mask = PORT_CSC | PORT_PEC | PORT_OCC;
- 	else
- 		mask = PORT_CSC | PORT_PEC;
-@@ -1011,7 +1011,7 @@ int ehci_hub_control(
- 		if (temp & PORT_PEC)
- 			status |= USB_PORT_STAT_C_ENABLE << 16;
- 
--		if ((temp & PORT_OCC) && !ignore_oc){
-+		if ((temp & PORT_OCC) && (!ignore_oc && !ehci->ignore_oc)){
- 			status |= USB_PORT_STAT_C_OVERCURRENT << 16;
- 
- 			/*
---- a/drivers/usb/host/ehci-platform.c
-+++ b/drivers/usb/host/ehci-platform.c
-@@ -208,6 +208,8 @@ static int ehci_platform_probe(struct pl
- 		hcd->has_tt = 1;
- 	if (pdata->reset_on_resume)
- 		priv->reset_on_resume = true;
-+	if (pdata->ignore_oc)
-+		ehci->ignore_oc = 1;
- 
- #ifndef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO
- 	if (ehci->big_endian_mmio) {
---- a/drivers/usb/host/ehci.h
-+++ b/drivers/usb/host/ehci.h
-@@ -218,6 +218,7 @@ struct ehci_hcd {			/* one per controlle
- 	unsigned		frame_index_bug:1; /* MosChip (AKA NetMos) */
- 	unsigned		need_oc_pp_cycle:1; /* MPC834X port power */
- 	unsigned		imx28_write_fix:1; /* For Freescale i.MX28 */
-+	unsigned		ignore_oc:1;
- 
- 	/* required for usb32 quirk */
- 	#define OHCI_CTRL_HCFS          (3 << 6)
---- a/include/linux/usb/ehci_pdriver.h
-+++ b/include/linux/usb/ehci_pdriver.h
-@@ -50,6 +50,7 @@ struct usb_ehci_pdata {
- 	unsigned	no_io_watchdog:1;
- 	unsigned	reset_on_resume:1;
- 	unsigned	dma_mask_64:1;
-+	unsigned	ignore_oc:1;
- 
- 	/* Turn on all power and clocks */
- 	int (*power_on)(struct platform_device *pdev);
--- a/target/linux/generic/pending-4.19/120-Fix-alloc_node_mem_map-with-ARCH_PFN_OFFSET-calcu.patch	2022-03-22 08:54:47.387464969 +0800
+++ b/target/linux/generic/pending-4.19/120-Fix-alloc_node_mem_map-with-ARCH_PFN_OFFSET-calcu.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,82 +0,0 @@
-From: Tobias Wolf <dev-NTEO@vplace.de>
-Subject: mm: Fix alloc_node_mem_map with ARCH_PFN_OFFSET calculation
-
-An rt288x (ralink) based router (Belkin F5D8235 v1) does not boot with any
-kernel beyond version 4.3 resulting in:
-
-BUG: Bad page state in process swapper  pfn:086ac
-
-bisect resulted in:
-
-a1c34a3bf00af2cede839879502e12dc68491ad5 is the first bad commit
-commit a1c34a3bf00af2cede839879502e12dc68491ad5
-Author: Laura Abbott <laura@labbott.name>
-Date:   Thu Nov 5 18:48:46 2015 -0800
-
-    mm: Don't offset memmap for flatmem
-
-    Srinivas Kandagatla reported bad page messages when trying to remove the
-    bottom 2MB on an ARM based IFC6410 board
-
-      BUG: Bad page state in process swapper  pfn:fffa8
-      page:ef7fb500 count:0 mapcount:0 mapping:  (null) index:0x0
-      flags: 0x96640253(locked|error|dirty|active|arch_1|reclaim|mlocked)
-      page dumped because: PAGE_FLAGS_CHECK_AT_FREE flag(s) set
-      bad because of flags:
-      flags: 0x200041(locked|active|mlocked)
-      Modules linked in:
-      CPU: 0 PID: 0 Comm: swapper Not tainted 3.19.0-rc3-00007-g412f9ba-dirty
-#816
-      Hardware name: Qualcomm (Flattened Device Tree)
-        unwind_backtrace
-        show_stack
-        dump_stack
-        bad_page
-        free_pages_prepare
-        free_hot_cold_page
-        __free_pages
-        free_highmem_page
-        mem_init
-        start_kernel
-      Disabling lock debugging due to kernel taint
-    [...]
-:040000 040000 2de013c372345fd471cd58f0553c9b38b0ef1cc4
-0a8156f848733dfa21e16c196dfb6c0a76290709 M      mm
-
-This fix for ARM does not account ARCH_PFN_OFFSET for mem_map as later used by
-page_to_pfn anymore.
-
-The following output was generated with two hacked in printk statements:
-
-printk("before %p vs. %p or %p\n", mem_map, mem_map - offset, mem_map -
-(pgdat->node_start_pfn - ARCH_PFN_OFFSET));
-		if (page_to_pfn(mem_map) != pgdat->node_start_pfn)
-			mem_map -= offset + (pgdat->node_start_pfn - ARCH_PFN_OFFSET);
-printk("after %p\n", mem_map);
-
-Output:
-
-[    0.000000] before 8861b280 vs. 8861b280 or 8851b280
-[    0.000000] after 8851b280
-
-As seen in the first line mem_map with subtraction of offset does not equal the
-mem_map after subtraction of ARCH_PFN_OFFSET.
-
-After adding the offset of ARCH_PFN_OFFSET as well to mem_map as the
-previously calculated offset is zero for the named platform it is able to boot
-4.4 and 4.9-rc7 again.
-
-Signed-off-by: Tobias Wolf <dev-NTEO@vplace.de>
----
-
---- a/mm/page_alloc.c
-+++ b/mm/page_alloc.c
-@@ -6400,7 +6400,7 @@ static void __ref alloc_node_mem_map(str
- 		mem_map = NODE_DATA(0)->node_mem_map;
- #if defined(CONFIG_HAVE_MEMBLOCK_NODE_MAP) || defined(CONFIG_FLATMEM)
- 		if (page_to_pfn(mem_map) != pgdat->node_start_pfn)
--			mem_map -= offset;
-+			mem_map -= offset + (pgdat->node_start_pfn - ARCH_PFN_OFFSET);
- #endif /* CONFIG_HAVE_MEMBLOCK_NODE_MAP */
- 	}
- #endif
--- a/target/linux/generic/pending-4.19/130-add-linux-spidev-compatible-si3210.patch	2022-03-22 08:54:47.388464971 +0800
+++ b/target/linux/generic/pending-4.19/130-add-linux-spidev-compatible-si3210.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,18 +0,0 @@
-From: Giuseppe Lippolis <giu.lippolis@gmail.com>
-Subject: Add the linux,spidev compatible in spidev Several device in ramips have this binding in the dts
-
-Signed-off-by: Giuseppe Lippolis <giu.lippolis@gmail.com>
----
- drivers/spi/spidev.c | 1 +
- 1 file changed, 1 insertion(+)
-
---- a/drivers/spi/spidev.c
-+++ b/drivers/spi/spidev.c
-@@ -669,6 +669,7 @@ static const struct of_device_id spidev_
- 	{ .compatible = "lineartechnology,ltc2488" },
- 	{ .compatible = "ge,achc" },
- 	{ .compatible = "semtech,sx1301" },
-+	{ .compatible = "siliconlabs,si3210" },
- 	{},
- };
- MODULE_DEVICE_TABLE(of, spidev_dt_ids);
--- a/target/linux/generic/pending-4.19/131-spi-use-gpio_set_value_cansleep-for-setting-chipsele.patch	2022-03-22 08:54:47.388464971 +0800
+++ b/target/linux/generic/pending-4.19/131-spi-use-gpio_set_value_cansleep-for-setting-chipsele.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,20 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: spi: use gpio_set_value_cansleep for setting chipselect GPIO
-
-Sleeping is safe inside spi_transfer_one_message, and some GPIO chips
-need to sleep for setting values
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/drivers/spi/spi.c
-+++ b/drivers/spi/spi.c
-@@ -733,7 +733,7 @@ static void spi_set_cs(struct spi_device
- 		enable = !enable;
- 
- 	if (gpio_is_valid(spi->cs_gpio)) {
--		gpio_set_value(spi->cs_gpio, !enable);
-+		gpio_set_value_cansleep(spi->cs_gpio, !enable);
- 		/* Some SPI masters need both GPIO CS & slave_select */
- 		if ((spi->controller->flags & SPI_MASTER_GPIO_SS) &&
- 		    spi->controller->set_cs)
--- a/target/linux/generic/pending-4.19/132-spi-spi-gpio-fix-crash-when-num-chipselects-is-0.patch	2022-03-22 08:54:47.388464971 +0800
+++ b/target/linux/generic/pending-4.19/132-spi-spi-gpio-fix-crash-when-num-chipselects-is-0.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,64 +0,0 @@
-From 0f76408d8c1cb0979f4286dd23912e6e59784b35 Mon Sep 17 00:00:00 2001
-From: DENG Qingfang <dqfext@gmail.com>
-Date: Thu, 19 Sep 2019 11:42:55 +0200
-Subject: [PATCH] spi: spi-gpio: fix crash when num-chipselects is 0
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-If an spi-gpio was specified with num-chipselects = <0> in dts, kernel will crash:
-
-Unable to handle kernel paging request at virtual address 32697073
-pgd = (ptrval)
-[32697073] *pgd=00000000
-Internal error: Oops: 5 [# 1] SMP ARM
-Modules linked in:
-CPU: 2 PID: 1 Comm: swapper/0 Not tainted 4.19.72 #0
-Hardware name: Generic DT based system
-PC is at validate_desc+0x28/0x80
-LR is at gpiod_direction_output+0x14/0x128
-...
-[<c0544db4>] (validate_desc) from [<c0545228>] (gpiod_direction_output+0x14/0x128)
-[<c0545228>] (gpiod_direction_output) from [<c05fa714>] (spi_gpio_setup+0x58/0x64)
-[<c05fa714>] (spi_gpio_setup) from [<c05f7258>] (spi_setup+0x12c/0x148)
-[<c05f7258>] (spi_setup) from [<c05f7330>] (spi_add_device+0xbc/0x12c)
-[<c05f7330>] (spi_add_device) from [<c05f7f74>] (spi_register_controller+0x838/0x924)
-[<c05f7f74>] (spi_register_controller) from [<c05fa494>] (spi_bitbang_start+0x108/0x120)
-[<c05fa494>] (spi_bitbang_start) from [<c05faa34>] (spi_gpio_probe+0x314/0x338)
-[<c05faa34>] (spi_gpio_probe) from [<c05a844c>] (platform_drv_probe+0x34/0x70)
-
-The cause is spi_gpio_setup() did not check if the spi-gpio has chipselect pins
-before setting their direction and results in derefing an invalid pointer.
-
-The bug is spotted in kernel 4.19.72 on OpenWrt, and does not occur in 4.14.
-
-There is a similar fix upstream 249e2632dcd0509b8f8f296f5aabf4d48dfd6da8.
-
-Ref: https://patchwork.kernel.org/patch/11150619/
-Cc: Linus Walleij <linus.walleij@linaro.org>
-Cc: stable@vger.kernel.org
-Signed-off-by: DENG Qingfang <dqfext@gmail.com>
-Signed-off-by: Petr tetiar <ynezz@true.cz>
----
- drivers/spi/spi-gpio.c | 10 ++++++----
- 1 file changed, 6 insertions(+), 4 deletions(-)
-
---- a/drivers/spi/spi-gpio.c
-+++ b/drivers/spi/spi-gpio.c
-@@ -242,10 +242,12 @@ static int spi_gpio_setup(struct spi_dev
- 	 * The CS GPIOs have already been
- 	 * initialized from the descriptor lookup.
- 	 */
--	cs = spi_gpio->cs_gpios[spi->chip_select];
--	if (!spi->controller_state && cs)
--		status = gpiod_direction_output(cs,
--						!(spi->mode & SPI_CS_HIGH));
-+	if (spi_gpio->has_cs) {
-+		cs = spi_gpio->cs_gpios[spi->chip_select];
-+		if (!spi->controller_state && cs)
-+			status = gpiod_direction_output(cs,
-+						  !(spi->mode & SPI_CS_HIGH));
-+	}
- 
- 	if (!status)
- 		status = spi_bitbang_setup(spi);
--- a/target/linux/generic/pending-4.19/140-jffs2-use-.rename2-and-add-RENAME_WHITEOUT-support.patch	2022-03-22 08:54:47.388464971 +0800
+++ b/target/linux/generic/pending-4.19/140-jffs2-use-.rename2-and-add-RENAME_WHITEOUT-support.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,62 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: jffs2: use .rename2 and add RENAME_WHITEOUT support
-
-It is required for renames on overlayfs
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/fs/jffs2/dir.c
-+++ b/fs/jffs2/dir.c
-@@ -752,6 +752,24 @@ static int jffs2_mknod (struct inode *di
- 	return ret;
- }
- 
-+static int jffs2_whiteout (struct inode *old_dir, struct dentry *old_dentry)
-+{
-+	struct dentry *wh;
-+	int err;
-+
-+	wh = d_alloc(old_dentry->d_parent, &old_dentry->d_name);
-+	if (!wh)
-+		return -ENOMEM;
-+
-+	err = jffs2_mknod(old_dir, wh, S_IFCHR | WHITEOUT_MODE,
-+			  WHITEOUT_DEV);
-+	if (err)
-+		return err;
-+
-+	d_rehash(wh);
-+	return 0;
-+}
-+
- static int jffs2_rename (struct inode *old_dir_i, struct dentry *old_dentry,
- 			 struct inode *new_dir_i, struct dentry *new_dentry,
- 			 unsigned int flags)
-@@ -762,7 +780,7 @@ static int jffs2_rename (struct inode *o
- 	uint8_t type;
- 	uint32_t now;
- 
--	if (flags & ~RENAME_NOREPLACE)
-+	if (flags & ~(RENAME_NOREPLACE|RENAME_WHITEOUT))
- 		return -EINVAL;
- 
- 	/* The VFS will check for us and prevent trying to rename a
-@@ -828,9 +846,14 @@ static int jffs2_rename (struct inode *o
- 	if (d_is_dir(old_dentry) && !victim_f)
- 		inc_nlink(new_dir_i);
- 
--	/* Unlink the original */
--	ret = jffs2_do_unlink(c, JFFS2_INODE_INFO(old_dir_i),
--			      old_dentry->d_name.name, old_dentry->d_name.len, NULL, now);
-+	if (flags & RENAME_WHITEOUT)
-+		/* Replace with whiteout */
-+		ret = jffs2_whiteout(old_dir_i, old_dentry);
-+	else
-+		/* Unlink the original */
-+		ret = jffs2_do_unlink(c, JFFS2_INODE_INFO(old_dir_i),
-+				      old_dentry->d_name.name,
-+				      old_dentry->d_name.len, NULL, now);
- 
- 	/* We don't touch inode->i_nlink */
- 
--- a/target/linux/generic/pending-4.19/141-jffs2-add-RENAME_EXCHANGE-support.patch	2022-03-22 08:54:47.389464973 +0800
+++ b/target/linux/generic/pending-4.19/141-jffs2-add-RENAME_EXCHANGE-support.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,73 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: jffs2: add RENAME_EXCHANGE support
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/fs/jffs2/dir.c
-+++ b/fs/jffs2/dir.c
-@@ -777,18 +777,31 @@ static int jffs2_rename (struct inode *o
- 	int ret;
- 	struct jffs2_sb_info *c = JFFS2_SB_INFO(old_dir_i->i_sb);
- 	struct jffs2_inode_info *victim_f = NULL;
-+	struct inode *fst_inode = d_inode(old_dentry);
-+	struct inode *snd_inode = d_inode(new_dentry);
- 	uint8_t type;
- 	uint32_t now;
- 
--	if (flags & ~(RENAME_NOREPLACE|RENAME_WHITEOUT))
-+	if (flags & ~(RENAME_NOREPLACE|RENAME_WHITEOUT|RENAME_EXCHANGE))
- 		return -EINVAL;
- 
-+	if ((flags & RENAME_EXCHANGE) && (old_dir_i != new_dir_i)) {
-+		if (S_ISDIR(fst_inode->i_mode) && !S_ISDIR(snd_inode->i_mode)) {
-+			inc_nlink(new_dir_i);
-+			drop_nlink(old_dir_i);
-+		}
-+		else if (!S_ISDIR(fst_inode->i_mode) && S_ISDIR(snd_inode->i_mode)) {
-+			drop_nlink(new_dir_i);
-+			inc_nlink(old_dir_i);
-+		}
-+	}
-+
- 	/* The VFS will check for us and prevent trying to rename a
- 	 * file over a directory and vice versa, but if it's a directory,
- 	 * the VFS can't check whether the victim is empty. The filesystem
- 	 * needs to do that for itself.
- 	 */
--	if (d_really_is_positive(new_dentry)) {
-+	if (d_really_is_positive(new_dentry) && !(flags & RENAME_EXCHANGE)) {
- 		victim_f = JFFS2_INODE_INFO(d_inode(new_dentry));
- 		if (d_is_dir(new_dentry)) {
- 			struct jffs2_full_dirent *fd;
-@@ -823,7 +836,7 @@ static int jffs2_rename (struct inode *o
- 	if (ret)
- 		return ret;
- 
--	if (victim_f) {
-+	if (victim_f && !(flags & RENAME_EXCHANGE)) {
- 		/* There was a victim. Kill it off nicely */
- 		if (d_is_dir(new_dentry))
- 			clear_nlink(d_inode(new_dentry));
-@@ -849,6 +862,12 @@ static int jffs2_rename (struct inode *o
- 	if (flags & RENAME_WHITEOUT)
- 		/* Replace with whiteout */
- 		ret = jffs2_whiteout(old_dir_i, old_dentry);
-+	else if (flags & RENAME_EXCHANGE)
-+		/* Replace the original */
-+		ret = jffs2_do_link(c, JFFS2_INODE_INFO(old_dir_i),
-+				    d_inode(new_dentry)->i_ino, type,
-+				    old_dentry->d_name.name, old_dentry->d_name.len,
-+				    now);
- 	else
- 		/* Unlink the original */
- 		ret = jffs2_do_unlink(c, JFFS2_INODE_INFO(old_dir_i),
-@@ -880,7 +899,7 @@ static int jffs2_rename (struct inode *o
- 		return ret;
- 	}
- 
--	if (d_is_dir(old_dentry))
-+	if (d_is_dir(old_dentry) && !(flags & RENAME_EXCHANGE))
- 		drop_nlink(old_dir_i);
- 
- 	new_dir_i->i_mtime = new_dir_i->i_ctime = old_dir_i->i_mtime = old_dir_i->i_ctime = ITIME(now);
--- a/target/linux/generic/pending-4.19/150-bridge_allow_receiption_on_disabled_port.patch	2022-03-22 08:54:47.389464973 +0800
+++ b/target/linux/generic/pending-4.19/150-bridge_allow_receiption_on_disabled_port.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,45 +0,0 @@
-From: Stephen Hemminger <stephen@networkplumber.org>
-Subject: bridge: allow receiption on disabled port
-
-When an ethernet device is enslaved to a bridge, and the bridge STP
-detects loss of carrier (or operational state down), then normally
-packet receiption is blocked.
-
-This breaks control applications like WPA which maybe expecting to
-receive packets to negotiate to bring link up. The bridge needs to
-block forwarding packets from these disabled ports, but there is no
-hard requirement to not allow local packet delivery.
-
-Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
-
---- a/net/bridge/br_input.c
-+++ b/net/bridge/br_input.c
-@@ -193,6 +193,9 @@ static void __br_handle_local_finish(str
- /* note: already called with rcu_read_lock */
- static int br_handle_local_finish(struct net *net, struct sock *sk, struct sk_buff *skb)
- {
-+	struct net_bridge_port *p = br_port_get_rcu(skb->dev);
-+
-+	if (p->state != BR_STATE_DISABLED)
- 	__br_handle_local_finish(skb);
- 
- 	/* return 1 to signal the okfn() was called so it's ok to use the skb */
-@@ -289,6 +292,17 @@ rx_handler_result_t br_handle_frame(stru
- 
- forward:
- 	switch (p->state) {
-+	case BR_STATE_DISABLED:
-+		if (ether_addr_equal(p->br->dev->dev_addr, dest))
-+			skb->pkt_type = PACKET_HOST;
-+
-+		if (NF_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING,
-+			dev_net(skb->dev), NULL, skb, skb->dev, NULL,
-+			br_handle_local_finish) == 1) {
-+			return RX_HANDLER_PASS;
-+		}
-+		break;
-+
- 	case BR_STATE_FORWARDING:
- 		rhook = rcu_dereference(br_should_route_hook);
- 		if (rhook) {
--- a/target/linux/generic/pending-4.19/180-net-phy-at803x-add-support-for-AT8032.patch	2022-03-22 08:54:47.389464973 +0800
+++ b/target/linux/generic/pending-4.19/180-net-phy-at803x-add-support-for-AT8032.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,63 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: net: phy: at803x: add support for AT8032
-
-Like AT8030, this PHY needs the GPIO reset workaround
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/drivers/net/phy/at803x.c
-+++ b/drivers/net/phy/at803x.c
-@@ -62,8 +62,10 @@
- 
- #define ATH8030_PHY_ID 0x004dd076
- #define ATH8031_PHY_ID 0x004dd074
-+#define ATH8032_PHY_ID 0x004dd023
- #define ATH8035_PHY_ID 0x004dd072
- #define AT803X_PHY_ID_MASK			0xffffffef
-+#define AT8032_PHY_ID_MASK			0xffffffff
- 
- MODULE_DESCRIPTION("Atheros 803x PHY driver");
- MODULE_AUTHOR("Matus Ujhelyi");
-@@ -308,7 +310,7 @@ static void at803x_link_change_notify(st
- 	struct at803x_priv *priv = phydev->priv;
- 
- 	/*
--	 * Conduct a hardware reset for AT8030 every time a link loss is
-+	 * Conduct a hardware reset for AT8030/2 every time a link loss is
- 	 * signalled. This is necessary to circumvent a hardware bug that
- 	 * occurs when the cable is unplugged while TX packets are pending
- 	 * in the FIFO. In such cases, the FIFO enters an error mode it
-@@ -414,6 +416,24 @@ static struct phy_driver at803x_driver[]
- 	.aneg_done		= at803x_aneg_done,
- 	.ack_interrupt		= &at803x_ack_interrupt,
- 	.config_intr		= &at803x_config_intr,
-+}, {
-+	/* ATHEROS 8032 */
-+	.phy_id			= ATH8032_PHY_ID,
-+	.name			= "Atheros 8032 ethernet",
-+	.phy_id_mask		= AT8032_PHY_ID_MASK,
-+	.probe			= at803x_probe,
-+	.config_init		= at803x_config_init,
-+	.link_change_notify	= at803x_link_change_notify,
-+	.set_wol		= at803x_set_wol,
-+	.get_wol		= at803x_get_wol,
-+	.suspend		= at803x_suspend,
-+	.resume			= at803x_resume,
-+	.features		= PHY_BASIC_FEATURES,
-+	.flags			= PHY_HAS_INTERRUPT,
-+	.config_aneg		= genphy_config_aneg,
-+	.read_status		= genphy_read_status,
-+	.ack_interrupt		= at803x_ack_interrupt,
-+	.config_intr		= at803x_config_intr,
- } };
- 
- module_phy_driver(at803x_driver);
-@@ -421,6 +441,7 @@ module_phy_driver(at803x_driver);
- static struct mdio_device_id __maybe_unused atheros_tbl[] = {
- 	{ ATH8030_PHY_ID, AT803X_PHY_ID_MASK },
- 	{ ATH8031_PHY_ID, AT803X_PHY_ID_MASK },
-+	{ ATH8032_PHY_ID, AT8032_PHY_ID_MASK },
- 	{ ATH8035_PHY_ID, AT803X_PHY_ID_MASK },
- 	{ }
- };
--- a/target/linux/generic/pending-4.19/201-extra_optimization.patch	2022-03-22 08:54:47.389464973 +0800
+++ b/target/linux/generic/pending-4.19/201-extra_optimization.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,32 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: Upgrade to Linux 2.6.19
-
-- Includes large parts of the patch from #1021 by dpalffy
-- Includes RB532 NAND driver changes by n0-1
-
-[john@phrozen.org: feix will add this to his upstream queue]
-
-lede-commit: bff468813f78f81e36ebb2a3f4354de7365e640f
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- Makefile | 6 +++---
- 1 file changed, 3 insertions(+), 3 deletions(-)
-
---- a/Makefile
-+++ b/Makefile
-@@ -657,12 +657,12 @@ KBUILD_CFLAGS	+= $(call cc-disable-warni
- KBUILD_CFLAGS	+= $(call cc-disable-warning, address-of-packed-member)
- 
- ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
--KBUILD_CFLAGS	+= -Os $(call cc-disable-warning,maybe-uninitialized,)
-+KBUILD_CFLAGS	+= -Os $(call cc-disable-warning,maybe-uninitialized,) $(EXTRA_OPTIMIZATION)
- else
- ifdef CONFIG_PROFILE_ALL_BRANCHES
--KBUILD_CFLAGS	+= -O2 $(call cc-disable-warning,maybe-uninitialized,)
-+KBUILD_CFLAGS	+= -O2 $(call cc-disable-warning,maybe-uninitialized,) $(EXTRA_OPTIMIZATION)
- else
--KBUILD_CFLAGS   += -O2
-+KBUILD_CFLAGS   += -O2 -fno-reorder-blocks -fno-tree-ch $(EXTRA_OPTIMIZATION)
- endif
- endif
- 
--- a/target/linux/generic/pending-4.19/203-kallsyms_uncompressed.patch	2022-03-22 08:54:47.390464974 +0800
+++ b/target/linux/generic/pending-4.19/203-kallsyms_uncompressed.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,119 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: kernel: add a config option for keeping the kallsyms table uncompressed, saving ~9kb kernel size after lzma on ar71xx
-
-[john@phrozen.org: added to my upstream queue 30.12.2016]
-lede-commit: e0e3509b5ce2ccf93d4d67ea907613f5f7ec2eed
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- init/Kconfig            | 11 +++++++++++
- kernel/kallsyms.c       |  8 ++++++++
- scripts/kallsyms.c      | 12 ++++++++++++
- scripts/link-vmlinux.sh |  4 ++++
- 4 files changed, 35 insertions(+)
-
---- a/init/Kconfig
-+++ b/init/Kconfig
-@@ -1149,6 +1149,17 @@ config SYSCTL_ARCH_UNALIGN_ALLOW
- 	  the unaligned access emulation.
- 	  see arch/parisc/kernel/unaligned.c for reference
- 
-+config KALLSYMS_UNCOMPRESSED
-+	bool "Keep kallsyms uncompressed"
-+	depends on KALLSYMS
-+	help
-+		Normally kallsyms contains compressed symbols (using a token table),
-+		reducing the uncompressed kernel image size. Keeping the symbol table
-+		uncompressed significantly improves the size of this part in compressed
-+		kernel images.
-+
-+		Say N unless you need compressed kernel images to be small.
-+
- config HAVE_PCSPKR_PLATFORM
- 	bool
- 
---- a/kernel/kallsyms.c
-+++ b/kernel/kallsyms.c
-@@ -74,6 +74,11 @@ static unsigned int kallsyms_expand_symb
- 	 * For every byte on the compressed symbol data, copy the table
- 	 * entry for that byte.
- 	 */
-+#ifdef CONFIG_KALLSYMS_UNCOMPRESSED
-+	memcpy(result, data + 1, len - 1);
-+	result += len - 1;
-+	len = 0;
-+#endif
- 	while (len) {
- 		tptr = &kallsyms_token_table[kallsyms_token_index[*data]];
- 		data++;
-@@ -106,6 +111,9 @@ tail:
-  */
- static char kallsyms_get_symbol_type(unsigned int off)
- {
-+#ifdef CONFIG_KALLSYMS_UNCOMPRESSED
-+	return kallsyms_names[off + 1];
-+#endif
- 	/*
- 	 * Get just the first code, look it up in the token table,
- 	 * and return the first char from this token.
---- a/scripts/kallsyms.c
-+++ b/scripts/kallsyms.c
-@@ -61,6 +61,7 @@ static struct addr_range percpu_range =
- static struct sym_entry *table;
- static unsigned int table_size, table_cnt;
- static int all_symbols = 0;
-+static int uncompressed = 0;
- static int absolute_percpu = 0;
- static int base_relative = 0;
- 
-@@ -442,6 +443,9 @@ static void write_src(void)
- 
- 	free(markers);
- 
-+	if (uncompressed)
-+		return;
-+
- 	output_label("kallsyms_token_table");
- 	off = 0;
- 	for (i = 0; i < 256; i++) {
-@@ -500,6 +504,9 @@ static void *find_token(unsigned char *s
- {
- 	int i;
- 
-+	if (uncompressed)
-+		return NULL;
-+
- 	for (i = 0; i < len - 1; i++) {
- 		if (str[i] == token[0] && str[i+1] == token[1])
- 			return &str[i];
-@@ -572,6 +579,9 @@ static void optimize_result(void)
- {
- 	int i, best;
- 
-+	if (uncompressed)
-+		return;
-+
- 	/* using the '\0' symbol last allows compress_symbols to use standard
- 	 * fast string functions */
- 	for (i = 255; i >= 0; i--) {
-@@ -754,6 +764,8 @@ int main(int argc, char **argv)
- 				absolute_percpu = 1;
- 			else if (strcmp(argv[i], "--base-relative") == 0)
- 				base_relative = 1;
-+			else if (strcmp(argv[i], "--uncompressed") == 0)
-+				uncompressed = 1;
- 			else
- 				usage();
- 		}
---- a/scripts/link-vmlinux.sh
-+++ b/scripts/link-vmlinux.sh
-@@ -133,6 +133,10 @@ kallsyms()
- 		kallsymopt="${kallsymopt} --base-relative"
- 	fi
- 
-+	if [ -n "${CONFIG_KALLSYMS_UNCOMPRESSED}" ]; then
-+		kallsymopt="${kallsymopt} --uncompressed"
-+	fi
-+
- 	local aflags="${KBUILD_AFLAGS} ${KBUILD_AFLAGS_KERNEL}               \
- 		      ${NOSTDINC_FLAGS} ${LINUXINCLUDE} ${KBUILD_CPPFLAGS}"
- 
--- a/target/linux/generic/pending-4.19/205-backtrace_module_info.patch	2022-03-22 08:54:47.390464974 +0800
+++ b/target/linux/generic/pending-4.19/205-backtrace_module_info.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,45 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: kernel: when KALLSYMS is disabled, print module address + size for matching backtrace entries
-
-[john@phrozen.org: felix will add this to his upstream queue]
-
-lede-commit 53827cdc824556cda910b23ce5030c363b8f1461
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- lib/vsprintf.c | 15 +++++++++++----
- 1 file changed, 11 insertions(+), 4 deletions(-)
-
---- a/lib/vsprintf.c
-+++ b/lib/vsprintf.c
-@@ -681,8 +681,10 @@ char *symbol_string(char *buf, char *end
- 		    struct printf_spec spec, const char *fmt)
- {
- 	unsigned long value;
--#ifdef CONFIG_KALLSYMS
- 	char sym[KSYM_SYMBOL_LEN];
-+#ifndef CONFIG_KALLSYMS
-+	struct module *mod;
-+	int len;
- #endif
- 
- 	if (fmt[1] == 'R')
-@@ -696,11 +698,16 @@ char *symbol_string(char *buf, char *end
- 		sprint_symbol(sym, value);
- 	else
- 		sprint_symbol_no_offset(sym, value);
--
--	return string(buf, end, sym, spec);
- #else
--	return special_hex_number(buf, end, value, sizeof(void *));
-+	len = snprintf(sym, sizeof(sym), "0x%lx", value);
-+
-+	mod = __module_address(value);
-+	if (mod)
-+		snprintf(sym + len, sizeof(sym) - len, " [%s@%p+0x%x]",
-+			 mod->name, mod->core_layout.base,
-+			 mod->core_layout.size);
- #endif
-+	return string(buf, end, sym, spec);
- }
- 
- static const struct printf_spec default_str_spec = {
--- a/target/linux/generic/pending-4.19/220-optimize_inlining.patch	2022-03-22 08:54:47.390464974 +0800
+++ b/target/linux/generic/pending-4.19/220-optimize_inlining.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,225 +0,0 @@
---- a/arch/arm/kernel/atags.h
-+++ b/arch/arm/kernel/atags.h
-@@ -5,7 +5,7 @@ void convert_to_tag_list(struct tag *tag
- const struct machine_desc *setup_machine_tags(phys_addr_t __atags_pointer,
- 	unsigned int machine_nr);
- #else
--static inline const struct machine_desc *
-+static inline const struct machine_desc * __init __noreturn
- setup_machine_tags(phys_addr_t __atags_pointer, unsigned int machine_nr)
- {
- 	early_print("no ATAGS support: can't continue\n");
---- a/arch/arm64/include/asm/cpufeature.h
-+++ b/arch/arm64/include/asm/cpufeature.h
-@@ -366,7 +366,7 @@ static inline bool cpu_have_feature(unsi
- }
- 
- /* System capability check for constant caps */
--static inline bool __cpus_have_const_cap(int num)
-+static __always_inline bool __cpus_have_const_cap(int num)
- {
- 	if (num >= ARM64_NCAPS)
- 		return false;
-@@ -380,7 +380,7 @@ static inline bool cpus_have_cap(unsigne
- 	return test_bit(num, cpu_hwcaps);
- }
- 
--static inline bool cpus_have_const_cap(int num)
-+static __always_inline bool cpus_have_const_cap(int num)
- {
- 	if (static_branch_likely(&arm64_const_caps_ready))
- 		return __cpus_have_const_cap(num);
---- a/arch/mips/include/asm/bitops.h
-+++ b/arch/mips/include/asm/bitops.h
-@@ -463,7 +463,7 @@ static inline void __clear_bit_unlock(un
-  * Return the bit position (0..63) of the most significant 1 bit in a word
-  * Returns -1 if no 1 bit exists
-  */
--static inline unsigned long __fls(unsigned long word)
-+static __always_inline unsigned long __fls(unsigned long word)
- {
- 	int num;
- 
-@@ -529,7 +529,7 @@ static inline unsigned long __fls(unsign
-  * Returns 0..SZLONG-1
-  * Undefined if no bit exists, so code should check against 0 first.
-  */
--static inline unsigned long __ffs(unsigned long word)
-+static __always_inline unsigned long __ffs(unsigned long word)
- {
- 	return __fls(word & -word);
- }
---- a/arch/mips/kernel/cpu-bugs64.c
-+++ b/arch/mips/kernel/cpu-bugs64.c
-@@ -42,8 +42,8 @@ static inline void align_mod(const int a
- 		: GCC_IMM_ASM() (align), GCC_IMM_ASM() (mod));
- }
- 
--static inline void mult_sh_align_mod(long *v1, long *v2, long *w,
--				     const int align, const int mod)
-+static __always_inline void mult_sh_align_mod(long *v1, long *v2, long *w,
-+					      const int align, const int mod)
- {
- 	unsigned long flags;
- 	int m1, m2;
---- a/arch/powerpc/kernel/prom_init.c
-+++ b/arch/powerpc/kernel/prom_init.c
-@@ -498,14 +498,14 @@ static int __init prom_next_node(phandle
- 	}
- }
- 
--static inline int prom_getprop(phandle node, const char *pname,
--			       void *value, size_t valuelen)
-+static inline int __init prom_getprop(phandle node, const char *pname,
-+				      void *value, size_t valuelen)
- {
- 	return call_prom("getprop", 4, 1, node, ADDR(pname),
- 			 (u32)(unsigned long) value, (u32) valuelen);
- }
- 
--static inline int prom_getproplen(phandle node, const char *pname)
-+static inline int __init prom_getproplen(phandle node, const char *pname)
- {
- 	return call_prom("getproplen", 2, 1, node, ADDR(pname));
- }
---- a/arch/powerpc/mm/tlb-radix.c
-+++ b/arch/powerpc/mm/tlb-radix.c
-@@ -90,8 +90,8 @@ void radix__tlbiel_all(unsigned int acti
- 	asm volatile(PPC_INVALIDATE_ERAT "; isync" : : :"memory");
- }
- 
--static inline void __tlbiel_pid(unsigned long pid, int set,
--				unsigned long ric)
-+static __always_inline void __tlbiel_pid(unsigned long pid, int set,
-+					 unsigned long ric)
- {
- 	unsigned long rb,rs,prs,r;
- 
-@@ -106,7 +106,7 @@ static inline void __tlbiel_pid(unsigned
- 	trace_tlbie(0, 1, rb, rs, ric, prs, r);
- }
- 
--static inline void __tlbie_pid(unsigned long pid, unsigned long ric)
-+static __always_inline void __tlbie_pid(unsigned long pid, unsigned long ric)
- {
- 	unsigned long rb,rs,prs,r;
- 
-@@ -136,7 +136,7 @@ static inline void __tlbiel_lpid(unsigne
- 	trace_tlbie(lpid, 1, rb, rs, ric, prs, r);
- }
- 
--static inline void __tlbie_lpid(unsigned long lpid, unsigned long ric)
-+static __always_inline void __tlbie_lpid(unsigned long lpid, unsigned long ric)
- {
- 	unsigned long rb,rs,prs,r;
- 
-@@ -300,7 +300,7 @@ static inline void fixup_tlbie_lpid(unsi
- /*
-  * We use 128 set in radix mode and 256 set in hpt mode.
-  */
--static inline void _tlbiel_pid(unsigned long pid, unsigned long ric)
-+static __always_inline void _tlbiel_pid(unsigned long pid, unsigned long ric)
- {
- 	int set;
- 
-@@ -983,7 +983,7 @@ void radix__tlb_flush(struct mmu_gather
- 	tlb->need_flush_all = 0;
- }
- 
--static inline void __radix__flush_tlb_range_psize(struct mm_struct *mm,
-+static __always_inline void __radix__flush_tlb_range_psize(struct mm_struct *mm,
- 				unsigned long start, unsigned long end,
- 				int psize, bool also_pwc)
- {
---- a/arch/s390/include/asm/cpacf.h
-+++ b/arch/s390/include/asm/cpacf.h
-@@ -202,7 +202,7 @@ static inline int __cpacf_check_opcode(u
- 	}
- }
- 
--static inline int cpacf_query(unsigned int opcode, cpacf_mask_t *mask)
-+static __always_inline int cpacf_query(unsigned int opcode, cpacf_mask_t *mask)
- {
- 	if (__cpacf_check_opcode(opcode)) {
- 		__cpacf_query(opcode, mask);
---- a/arch/x86/Kconfig.debug
-+++ b/arch/x86/Kconfig.debug
-@@ -276,20 +276,6 @@ config CPA_DEBUG
- 	---help---
- 	  Do change_page_attr() self-tests every 30 seconds.
- 
--config OPTIMIZE_INLINING
--	bool "Allow gcc to uninline functions marked 'inline'"
--	---help---
--	  This option determines if the kernel forces gcc to inline the functions
--	  developers have marked 'inline'. Doing so takes away freedom from gcc to
--	  do what it thinks is best, which is desirable for the gcc 3.x series of
--	  compilers. The gcc 4.x series have a rewritten inlining algorithm and
--	  enabling this option will generate a smaller kernel there. Hopefully
--	  this algorithm is so good that allowing gcc 4.x and above to make the
--	  decision will become the default in the future. Until then this option
--	  is there to test gcc for this.
--
--	  If unsure, say N.
--
- config DEBUG_ENTRY
- 	bool "Debug low-level entry code"
- 	depends on DEBUG_KERNEL
---- a/drivers/mtd/nand/raw/vf610_nfc.c
-+++ b/drivers/mtd/nand/raw/vf610_nfc.c
-@@ -373,7 +373,7 @@ static int vf610_nfc_cmd(struct nand_chi
- {
- 	const struct nand_op_instr *instr;
- 	struct vf610_nfc *nfc = chip_to_nfc(chip);
--	int op_id = -1, trfr_sz = 0, offset;
-+	int op_id = -1, trfr_sz = 0, offset = 0;
- 	u32 col = 0, row = 0, cmd1 = 0, cmd2 = 0, code = 0;
- 	bool force8bit = false;
- 
---- a/lib/Kconfig.debug
-+++ b/lib/Kconfig.debug
-@@ -309,6 +309,20 @@ config HEADERS_CHECK
- 	  exported to $(INSTALL_HDR_PATH) (usually 'usr/include' in
- 	  your build tree), to make sure they're suitable.
- 
-+config OPTIMIZE_INLINING
-+	bool "Allow compiler to uninline functions marked 'inline'"
-+	help
-+	  This option determines if the kernel forces gcc to inline the functions
-+	  developers have marked 'inline'. Doing so takes away freedom from gcc to
-+	  do what it thinks is best, which is desirable for the gcc 3.x series of
-+	  compilers. The gcc 4.x series have a rewritten inlining algorithm and
-+	  enabling this option will generate a smaller kernel there. Hopefully
-+	  this algorithm is so good that allowing gcc 4.x and above to make the
-+	  decision will become the default in the future. Until then this option
-+	  is there to test gcc for this.
-+
-+	  If unsure, say N.
-+
- config DEBUG_SECTION_MISMATCH
- 	bool "Enable full Section mismatch analysis"
- 	help
---- a/arch/x86/Kconfig
-+++ b/arch/x86/Kconfig
-@@ -306,9 +306,6 @@ config ZONE_DMA32
- config AUDIT_ARCH
- 	def_bool y if X86_64
- 
--config ARCH_SUPPORTS_OPTIMIZED_INLINING
--	def_bool y
--
- config ARCH_SUPPORTS_DEBUG_PAGEALLOC
- 	def_bool y
- 
---- a/include/linux/compiler_types.h
-+++ b/include/linux/compiler_types.h
-@@ -268,8 +268,7 @@ struct ftrace_likely_data {
-  * of extern inline functions at link time.
-  * A lot of inline functions can cause havoc with function tracing.
-  */
--#if !defined(CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING) || \
--	!defined(CONFIG_OPTIMIZE_INLINING)
-+#if !defined(CONFIG_OPTIMIZE_INLINING)
- #define inline \
- 	inline __attribute__((always_inline, unused)) notrace __gnu_inline
- #else
--- a/target/linux/generic/pending-4.19/240-remove-unsane-filenames-from-deps_initramfs-list.patch	2022-03-22 08:54:47.390464974 +0800
+++ b/target/linux/generic/pending-4.19/240-remove-unsane-filenames-from-deps_initramfs-list.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,46 +0,0 @@
-From: Gabor Juhos <juhosg@openwrt.org>
-Subject: usr: sanitize deps_initramfs list
-
-If any filename in the intramfs dependency
-list contains a colon, that causes a kernel
-build error like this:
-
-/devel/openwrt/build_dir/linux-ar71xx_generic/linux-3.6.6/usr/Makefile:58: *** multiple target patterns.  Stop.
-make[5]: *** [usr] Error 2
-
-Fix it by removing such filenames from the
-deps_initramfs list.
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- usr/Makefile | 8 +++++---
- 1 file changed, 5 insertions(+), 3 deletions(-)
-
---- a/usr/Makefile
-+++ b/usr/Makefile
-@@ -42,20 +42,22 @@ ifneq ($(wildcard $(obj)/$(datafile_d_y)
- 	include $(obj)/$(datafile_d_y)
- endif
- 
-+deps_initramfs_sane := $(foreach v,$(deps_initramfs),$(if $(findstring :,$(v)),,$(v)))
-+
- quiet_cmd_initfs = GEN     $@
-       cmd_initfs = $(initramfs) -o $@ $(ramfs-args) $(ramfs-input)
- 
- targets := $(datafile_y)
- 
- # do not try to update files included in initramfs
--$(deps_initramfs): ;
-+$(deps_initramfs_sane): ;
- 
--$(deps_initramfs): klibcdirs
-+$(deps_initramfs_sane): klibcdirs
- # We rebuild initramfs_data.cpio if:
- # 1) Any included file is newer then initramfs_data.cpio
- # 2) There are changes in which files are included (added or deleted)
- # 3) If gen_init_cpio are newer than initramfs_data.cpio
- # 4) arguments to gen_initramfs.sh changes
--$(obj)/$(datafile_y): $(obj)/gen_init_cpio $(deps_initramfs) klibcdirs
-+$(obj)/$(datafile_y): $(obj)/gen_init_cpio $(deps_initramfs_sane) klibcdirs
- 	$(Q)$(initramfs) -l $(ramfs-input) > $(obj)/$(datafile_d_y)
- 	$(call if_changed,initfs)
--- a/target/linux/generic/pending-4.19/261-enable_wilink_platform_without_drivers.patch	2022-03-22 08:54:47.391464976 +0800
+++ b/target/linux/generic/pending-4.19/261-enable_wilink_platform_without_drivers.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,20 +0,0 @@
-From: Imre Kaloz <kaloz@openwrt.org>
-Subject: [PATCH] hack: net: wireless: make the wl12xx glue code available with
- compat-wireless, too
-
-Signed-off-by: Imre Kaloz <kaloz@openwrt.org>
----
- drivers/net/wireless/ti/Kconfig | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ti/Kconfig
-+++ b/drivers/net/wireless/ti/Kconfig
-@@ -19,7 +19,7 @@ source "drivers/net/wireless/ti/wlcore/K
- 
- config WILINK_PLATFORM_DATA
- 	bool "TI WiLink platform data"
--	depends on WLCORE_SDIO || WL1251_SDIO
-+	depends on WLCORE_SDIO || WL1251_SDIO || ARCH_OMAP2PLUS
- 	default y
- 	---help---
- 	Small platform data bit needed to pass data to the sdio modules.
--- a/target/linux/generic/pending-4.19/300-mips_expose_boot_raw.patch	2022-03-22 08:54:47.391464976 +0800
+++ b/target/linux/generic/pending-4.19/300-mips_expose_boot_raw.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,40 +0,0 @@
-From: Mark Miller <mark@mirell.org>
-Subject: mips: expose CONFIG_BOOT_RAW
-
-This exposes the CONFIG_BOOT_RAW symbol in Kconfig. This is needed on
-certain Broadcom chipsets running CFE in order to load the kernel.
-
-Signed-off-by: Mark Miller <mark@mirell.org>
-Acked-by: Rob Landley <rob@landley.net>
----
---- a/arch/mips/Kconfig
-+++ b/arch/mips/Kconfig
-@@ -1062,9 +1062,6 @@ config FW_ARC
- config ARCH_MAY_HAVE_PC_FDC
- 	bool
- 
--config BOOT_RAW
--	bool
--
- config CEVT_BCM1480
- 	bool
- 
-@@ -2968,6 +2965,18 @@ choice
- 		bool "Extend builtin kernel arguments with bootloader arguments"
- endchoice
- 
-+config BOOT_RAW
-+	bool "Enable the kernel to be executed from the load address"
-+	default n
-+	help
-+	 Allow the kernel to be executed from the load address for
-+	 bootloaders which cannot read the ELF format. This places
-+	 a jump to start_kernel at the load address.
-+
-+	 If unsure, say N.
-+
-+
-+
- endmenu
- 
- config LOCKDEP_SUPPORT
--- a/target/linux/generic/pending-4.19/302-mips_no_branch_likely.patch	2022-03-22 08:54:47.391464976 +0800
+++ b/target/linux/generic/pending-4.19/302-mips_no_branch_likely.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,22 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: mips: use -mno-branch-likely for kernel and userspace
-
-saves ~11k kernel size after lzma and ~12k squashfs size in the
-
-lede-commit: 41a039f46450ffae9483d6216422098669da2900
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- arch/mips/Makefile | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/arch/mips/Makefile
-+++ b/arch/mips/Makefile
-@@ -91,7 +91,7 @@ all-$(CONFIG_SYS_SUPPORTS_ZBOOT)+= vmlin
- # machines may also.  Since BFD is incredibly buggy with respect to
- # crossformat linking we rely on the elf2ecoff tool for format conversion.
- #
--cflags-y			+= -G 0 -mno-abicalls -fno-pic -pipe
-+cflags-y			+= -G 0 -mno-abicalls -fno-pic -pipe -mno-branch-likely
- cflags-y			+= -msoft-float
- LDFLAGS_vmlinux			+= -G 0 -static -n -nostdlib
- KBUILD_AFLAGS_MODULE		+= -mlong-calls
--- a/target/linux/generic/pending-4.19/304-mips_disable_fpu.patch	2022-03-22 08:54:47.391464976 +0800
+++ b/target/linux/generic/pending-4.19/304-mips_disable_fpu.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,137 +0,0 @@
-From:   Manuel Lauss <manuel.lauss@gmail.com>
-Subject: [RFC PATCH v4 2/2] MIPS: make FPU emulator optional
-
-This small patch makes the MIPS FPU emulator optional. The kernel
-kills float-users on systems without a hardware FPU by sending a SIGILL.
-
-Disabling the emulator shrinks vmlinux by about 54kBytes (32bit,
-optimizing for size).
-
-Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
----
-v4: rediffed because of patch 1/2, should now work with micromips as well
-v3: updated patch description with size savings.
-v2: incorporated changes suggested by Jonas Gorski
-    force the fpu emulator on for micromips: relocating the parts
-    of the mmips code in the emulator to other areas would be a
-    much larger change; I went the cheap route instead with this.
-
- arch/mips/Kbuild                     |  2 +-
- arch/mips/Kconfig                    | 14 ++++++++++++++
- arch/mips/include/asm/fpu.h          |  5 +++--
- arch/mips/include/asm/fpu_emulator.h | 15 +++++++++++++++
- 4 files changed, 33 insertions(+), 3 deletions(-)
-
---- a/arch/mips/Kconfig
-+++ b/arch/mips/Kconfig
-@@ -2892,6 +2892,20 @@ config MIPS_O32_FP64_SUPPORT
- 
- 	  If unsure, say N.
- 
-+config MIPS_FPU_EMULATOR
-+	bool "MIPS FPU Emulator"
-+	default y
-+	help
-+	  This option lets you disable the built-in MIPS FPU (Coprocessor 1)
-+	  emulator, which handles floating-point instructions on processors
-+	  without a hardware FPU.  It is generally a good idea to keep the
-+	  emulator built-in, unless you are perfectly sure you have a
-+	  complete soft-float environment.  With the emulator disabled, all
-+	  users of float operations will be killed with an illegal instr-
-+	  uction exception.
-+
-+	  Say Y, please.
-+
- config USE_OF
- 	bool
- 	select OF
---- a/arch/mips/Makefile
-+++ b/arch/mips/Makefile
-@@ -323,7 +323,7 @@ OBJCOPYFLAGS		+= --remove-section=.regin
- head-y := arch/mips/kernel/head.o
- 
- libs-y			+= arch/mips/lib/
--libs-y			+= arch/mips/math-emu/
-+libs-$(CONFIG_MIPS_FPU_EMULATOR)	+= arch/mips/math-emu/
- 
- # See arch/mips/Kbuild for content of core part of the kernel
- core-y += arch/mips/
---- a/arch/mips/include/asm/fpu.h
-+++ b/arch/mips/include/asm/fpu.h
-@@ -230,8 +230,10 @@ static inline int init_fpu(void)
- 		/* Restore FRE */
- 		write_c0_config5(config5);
- 		enable_fpu_hazard();
--	} else
-+	} else if (IS_ENABLED(CONFIG_MIPS_FPU_EMULATOR))
- 		fpu_emulator_init_fpu();
-+	else
-+		ret = SIGILL;
- 
- 	return ret;
- }
---- a/arch/mips/include/asm/fpu_emulator.h
-+++ b/arch/mips/include/asm/fpu_emulator.h
-@@ -30,6 +30,7 @@
- #include <asm/local.h>
- #include <asm/processor.h>
- 
-+#ifdef CONFIG_MIPS_FPU_EMULATOR
- #ifdef CONFIG_DEBUG_FS
- 
- struct mips_fpu_emulator_stats {
-@@ -179,6 +180,16 @@ do {									\
- extern int fpu_emulator_cop1Handler(struct pt_regs *xcp,
- 				    struct mips_fpu_struct *ctx, int has_fpu,
- 				    void __user **fault_addr);
-+#else	/* no CONFIG_MIPS_FPU_EMULATOR */
-+static inline int fpu_emulator_cop1Handler(struct pt_regs *xcp,
-+				struct mips_fpu_struct *ctx, int has_fpu,
-+				void __user **fault_addr)
-+{
-+	*fault_addr = NULL;
-+	return SIGILL;	/* we don't speak MIPS FPU */
-+}
-+#endif	/* CONFIG_MIPS_FPU_EMULATOR */
-+
- void force_fcr31_sig(unsigned long fcr31, void __user *fault_addr,
- 		     struct task_struct *tsk);
- int process_fpemu_return(int sig, void __user *fault_addr,
---- a/arch/mips/include/asm/dsemul.h
-+++ b/arch/mips/include/asm/dsemul.h
-@@ -41,6 +41,7 @@ struct task_struct;
- extern int mips_dsemul(struct pt_regs *regs, mips_instruction ir,
- 		       unsigned long branch_pc, unsigned long cont_pc);
- 
-+#ifdef CONFIG_MIPS_FPU_EMULATOR
- /**
-  * do_dsemulret() - Return from a delay slot 'emulation' frame
-  * @xcp:	User thread register context.
-@@ -88,5 +89,27 @@ extern bool dsemul_thread_rollback(struc
-  * before @mm is freed in order to avoid memory leaks.
-  */
- extern void dsemul_mm_cleanup(struct mm_struct *mm);
-+#else
-+static inline bool do_dsemulret(struct pt_regs *xcp)
-+{
-+	return false;
-+}
-+
-+static inline bool dsemul_thread_cleanup(struct task_struct *tsk)
-+{
-+	return false;
-+}
-+
-+static inline bool dsemul_thread_rollback(struct pt_regs *regs)
-+{
-+	return false;
-+}
-+
-+static inline void dsemul_mm_cleanup(struct mm_struct *mm)
-+{
-+
-+}
-+
-+#endif
- 
- #endif /* __MIPS_ASM_DSEMUL_H__ */
--- a/target/linux/generic/pending-4.19/305-mips_module_reloc.patch	2022-03-22 08:54:47.392464978 +0800
+++ b/target/linux/generic/pending-4.19/305-mips_module_reloc.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,371 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: mips: replace -mlong-calls with -mno-long-calls to make function calls faster in kernel modules to achieve this, try to
-
-lede-commit: 3b3d64743ba2a874df9d70cd19e242205b0a788c
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- arch/mips/Makefile             |   5 +
- arch/mips/include/asm/module.h |   5 +
- arch/mips/kernel/module.c      | 279 ++++++++++++++++++++++++++++++++++++++++-
- 3 files changed, 284 insertions(+), 5 deletions(-)
-
---- a/arch/mips/Makefile
-+++ b/arch/mips/Makefile
-@@ -94,8 +94,18 @@ all-$(CONFIG_SYS_SUPPORTS_ZBOOT)+= vmlin
- cflags-y			+= -G 0 -mno-abicalls -fno-pic -pipe -mno-branch-likely
- cflags-y			+= -msoft-float
- LDFLAGS_vmlinux			+= -G 0 -static -n -nostdlib
-+ifdef CONFIG_64BIT
- KBUILD_AFLAGS_MODULE		+= -mlong-calls
- KBUILD_CFLAGS_MODULE		+= -mlong-calls
-+else
-+  ifdef CONFIG_DYNAMIC_FTRACE
-+    KBUILD_AFLAGS_MODULE	+= -mlong-calls
-+    KBUILD_CFLAGS_MODULE	+= -mlong-calls
-+  else
-+    KBUILD_AFLAGS_MODULE	+= -mno-long-calls
-+    KBUILD_CFLAGS_MODULE	+= -mno-long-calls
-+  endif
-+endif
- 
- ifeq ($(CONFIG_RELOCATABLE),y)
- LDFLAGS_vmlinux			+= --emit-relocs
---- a/arch/mips/include/asm/module.h
-+++ b/arch/mips/include/asm/module.h
-@@ -12,6 +12,11 @@ struct mod_arch_specific {
- 	const struct exception_table_entry *dbe_start;
- 	const struct exception_table_entry *dbe_end;
- 	struct mips_hi16 *r_mips_hi16_list;
-+
-+	void *phys_plt_tbl;
-+	void *virt_plt_tbl;
-+	unsigned int phys_plt_offset;
-+	unsigned int virt_plt_offset;
- };
- 
- typedef uint8_t Elf64_Byte;		/* Type for a 8-bit quantity.  */
---- a/arch/mips/kernel/module.c
-+++ b/arch/mips/kernel/module.c
-@@ -44,14 +44,221 @@ struct mips_hi16 {
- static LIST_HEAD(dbe_list);
- static DEFINE_SPINLOCK(dbe_lock);
- 
--#ifdef MODULE_START
-+/*
-+ * Get the potential max trampolines size required of the init and
-+ * non-init sections. Only used if we cannot find enough contiguous
-+ * physically mapped memory to put the module into.
-+ */
-+static unsigned int
-+get_plt_size(const Elf_Ehdr *hdr, const Elf_Shdr *sechdrs,
-+             const char *secstrings, unsigned int symindex, bool is_init)
-+{
-+	unsigned long ret = 0;
-+	unsigned int i, j;
-+	Elf_Sym *syms;
-+
-+	/* Everything marked ALLOC (this includes the exported symbols) */
-+	for (i = 1; i < hdr->e_shnum; ++i) {
-+		unsigned int info = sechdrs[i].sh_info;
-+
-+		if (sechdrs[i].sh_type != SHT_REL
-+		    && sechdrs[i].sh_type != SHT_RELA)
-+			continue;
-+
-+		/* Not a valid relocation section? */
-+		if (info >= hdr->e_shnum)
-+			continue;
-+
-+		/* Don't bother with non-allocated sections */
-+		if (!(sechdrs[info].sh_flags & SHF_ALLOC))
-+			continue;
-+
-+		/* If it's called *.init*, and we're not init, we're
-+                   not interested */
-+		if ((strstr(secstrings + sechdrs[i].sh_name, ".init") != 0)
-+		    != is_init)
-+			continue;
-+
-+		syms = (Elf_Sym *) sechdrs[symindex].sh_addr;
-+		if (sechdrs[i].sh_type == SHT_REL) {
-+			Elf_Mips_Rel *rel = (void *) sechdrs[i].sh_addr;
-+			unsigned int size = sechdrs[i].sh_size / sizeof(*rel);
-+
-+			for (j = 0; j < size; ++j) {
-+				Elf_Sym *sym;
-+
-+				if (ELF_MIPS_R_TYPE(rel[j]) != R_MIPS_26)
-+					continue;
-+
-+				sym = syms + ELF_MIPS_R_SYM(rel[j]);
-+				if (!is_init && sym->st_shndx != SHN_UNDEF)
-+					continue;
-+
-+				ret += 4 * sizeof(int);
-+			}
-+		} else {
-+			Elf_Mips_Rela *rela = (void *) sechdrs[i].sh_addr;
-+			unsigned int size = sechdrs[i].sh_size / sizeof(*rela);
-+
-+			for (j = 0; j < size; ++j) {
-+				Elf_Sym *sym;
-+
-+				if (ELF_MIPS_R_TYPE(rela[j]) != R_MIPS_26)
-+					continue;
-+
-+				sym = syms + ELF_MIPS_R_SYM(rela[j]);
-+				if (!is_init && sym->st_shndx != SHN_UNDEF)
-+					continue;
-+
-+				ret += 4 * sizeof(int);
-+			}
-+		}
-+	}
-+
-+	return ret;
-+}
-+
-+#ifndef MODULE_START
-+static void *alloc_phys(unsigned long size)
-+{
-+	unsigned order;
-+	struct page *page;
-+	struct page *p;
-+
-+	size = PAGE_ALIGN(size);
-+	order = get_order(size);
-+
-+	page = alloc_pages(GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN |
-+			__GFP_THISNODE, order);
-+	if (!page)
-+		return NULL;
-+
-+	split_page(page, order);
-+
-+	/* mark all pages except for the last one */
-+	for (p = page; p + 1 < page + (size >> PAGE_SHIFT); ++p)
-+		set_bit(PG_owner_priv_1, &p->flags);
-+
-+	for (p = page + (size >> PAGE_SHIFT); p < page + (1 << order); ++p)
-+		__free_page(p);
-+
-+	return page_address(page);
-+}
-+#endif
-+
-+static void free_phys(void *ptr)
-+{
-+	struct page *page;
-+	bool free;
-+
-+	page = virt_to_page(ptr);
-+	do {
-+		free = test_and_clear_bit(PG_owner_priv_1, &page->flags);
-+		__free_page(page);
-+		page++;
-+	} while (free);
-+}
-+
-+
- void *module_alloc(unsigned long size)
- {
-+#ifdef MODULE_START
- 	return __vmalloc_node_range(size, 1, MODULE_START, MODULE_END,
- 				GFP_KERNEL, PAGE_KERNEL, 0, NUMA_NO_NODE,
- 				__builtin_return_address(0));
-+#else
-+	void *ptr;
-+
-+	if (size == 0)
-+		return NULL;
-+
-+	ptr = alloc_phys(size);
-+
-+	/* If we failed to allocate physically contiguous memory,
-+	 * fall back to regular vmalloc. The module loader code will
-+	 * create jump tables to handle long jumps */
-+	if (!ptr)
-+		return vmalloc(size);
-+
-+	return ptr;
-+#endif
- }
-+
-+static inline bool is_phys_addr(void *ptr)
-+{
-+#ifdef CONFIG_64BIT
-+	return (KSEGX((unsigned long)ptr) == CKSEG0);
-+#else
-+	return (KSEGX(ptr) == KSEG0);
- #endif
-+}
-+
-+/* Free memory returned from module_alloc */
-+void module_memfree(void *module_region)
-+{
-+	if (is_phys_addr(module_region))
-+		free_phys(module_region);
-+	else
-+		vfree(module_region);
-+}
-+
-+static void *__module_alloc(int size, bool phys)
-+{
-+	void *ptr;
-+
-+	if (phys)
-+		ptr = kmalloc(size, GFP_KERNEL);
-+	else
-+		ptr = vmalloc(size);
-+	return ptr;
-+}
-+
-+static void __module_free(void *ptr)
-+{
-+	if (is_phys_addr(ptr))
-+		kfree(ptr);
-+	else
-+		vfree(ptr);
-+}
-+
-+int module_frob_arch_sections(Elf_Ehdr *hdr, Elf_Shdr *sechdrs,
-+			      char *secstrings, struct module *mod)
-+{
-+	unsigned int symindex = 0;
-+	unsigned int core_size, init_size;
-+	int i;
-+
-+	mod->arch.phys_plt_offset = 0;
-+	mod->arch.virt_plt_offset = 0;
-+	mod->arch.phys_plt_tbl = NULL;
-+	mod->arch.virt_plt_tbl = NULL;
-+
-+	if (IS_ENABLED(CONFIG_64BIT))
-+		return 0;
-+
-+	for (i = 1; i < hdr->e_shnum; i++)
-+		if (sechdrs[i].sh_type == SHT_SYMTAB)
-+			symindex = i;
-+
-+	core_size = get_plt_size(hdr, sechdrs, secstrings, symindex, false);
-+	init_size = get_plt_size(hdr, sechdrs, secstrings, symindex, true);
-+
-+	if ((core_size + init_size) == 0)
-+		return 0;
-+
-+	mod->arch.phys_plt_tbl = __module_alloc(core_size + init_size, 1);
-+	if (!mod->arch.phys_plt_tbl)
-+		return -ENOMEM;
-+
-+	mod->arch.virt_plt_tbl = __module_alloc(core_size + init_size, 0);
-+	if (!mod->arch.virt_plt_tbl) {
-+		__module_free(mod->arch.phys_plt_tbl);
-+		mod->arch.phys_plt_tbl = NULL;
-+		return -ENOMEM;
-+	}
-+
-+	return 0;
-+}
- 
- static int apply_r_mips_none(struct module *me, u32 *location,
- 			     u32 base, Elf_Addr v, bool rela)
-@@ -67,9 +274,40 @@ static int apply_r_mips_32(struct module
- 	return 0;
- }
- 
-+static Elf_Addr add_plt_entry_to(unsigned *plt_offset,
-+				 void *start, Elf_Addr v)
-+{
-+	unsigned *tramp = start + *plt_offset;
-+	*plt_offset += 4 * sizeof(int);
-+
-+	/* adjust carry for addiu */
-+	if (v & 0x00008000)
-+		v += 0x10000;
-+
-+	tramp[0] = 0x3c190000 | (v >> 16);      /* lui t9, hi16 */
-+	tramp[1] = 0x27390000 | (v & 0xffff);   /* addiu t9, t9, lo16 */
-+	tramp[2] = 0x03200008;                  /* jr t9 */
-+	tramp[3] = 0x00000000;                  /* nop */
-+
-+	return (Elf_Addr) tramp;
-+}
-+
-+static Elf_Addr add_plt_entry(struct module *me, void *location, Elf_Addr v)
-+{
-+	if (is_phys_addr(location))
-+		return add_plt_entry_to(&me->arch.phys_plt_offset,
-+				me->arch.phys_plt_tbl, v);
-+	else
-+		return add_plt_entry_to(&me->arch.virt_plt_offset,
-+				me->arch.virt_plt_tbl, v);
-+
-+}
-+
- static int apply_r_mips_26(struct module *me, u32 *location,
- 			   u32 base, Elf_Addr v, bool rela)
- {
-+	u32 ofs = base & 0x03ffffff;
-+
- 	if (v % 4) {
- 		pr_err("module %s: dangerous R_MIPS_26 relocation\n",
- 		       me->name);
-@@ -77,13 +315,17 @@ static int apply_r_mips_26(struct module
- 	}
- 
- 	if ((v & 0xf0000000) != (((unsigned long)location + 4) & 0xf0000000)) {
--		pr_err("module %s: relocation overflow\n",
--		       me->name);
--		return -ENOEXEC;
-+		v = add_plt_entry(me, location, v + (ofs << 2));
-+		if (!v) {
-+			pr_err("module %s: relocation overflow\n",
-+			       me->name);
-+			return -ENOEXEC;
-+		}
-+		ofs = 0;
- 	}
- 
- 	*location = (*location & ~0x03ffffff) |
--		    ((base + (v >> 2)) & 0x03ffffff);
-+		    ((ofs + (v >> 2)) & 0x03ffffff);
- 
- 	return 0;
- }
-@@ -459,9 +701,36 @@ int module_finalize(const Elf_Ehdr *hdr,
- 		list_add(&me->arch.dbe_list, &dbe_list);
- 		spin_unlock_irq(&dbe_lock);
- 	}
-+
-+	/* Get rid of the fixup trampoline if we're running the module
-+	 * from physically mapped address space */
-+	if (me->arch.phys_plt_offset == 0) {
-+		__module_free(me->arch.phys_plt_tbl);
-+		me->arch.phys_plt_tbl = NULL;
-+	}
-+	if (me->arch.virt_plt_offset == 0) {
-+		__module_free(me->arch.virt_plt_tbl);
-+		me->arch.virt_plt_tbl = NULL;
-+	}
-+
- 	return 0;
- }
- 
-+void module_arch_freeing_init(struct module *mod)
-+{
-+	if (mod->state == MODULE_STATE_LIVE)
-+		return;
-+
-+	if (mod->arch.phys_plt_tbl) {
-+		__module_free(mod->arch.phys_plt_tbl);
-+		mod->arch.phys_plt_tbl = NULL;
-+	}
-+	if (mod->arch.virt_plt_tbl) {
-+		__module_free(mod->arch.virt_plt_tbl);
-+		mod->arch.virt_plt_tbl = NULL;
-+	}
-+}
-+
- void module_arch_cleanup(struct module *mod)
- {
- 	spin_lock_irq(&dbe_lock);
--- a/target/linux/generic/pending-4.19/306-mips_mem_functions_performance.patch	2022-03-22 08:54:47.392464978 +0800
+++ b/target/linux/generic/pending-4.19/306-mips_mem_functions_performance.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,106 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: [PATCH] mips: allow the compiler to optimize memset, memcmp, memcpy  for better performance and (in some instances) smaller code
-
-lede-commit: 07e59c7bc7f375f792ec9734be42fe4fa391a8bb
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- arch/mips/boot/compressed/Makefile |  3 ++-
- arch/mips/include/asm/string.h     | 38 ++++++++++++++++++++++++++++++++++++++
- arch/mips/lib/Makefile             |  2 +-
- arch/mips/lib/memcmp.c             | 22 ++++++++++++++++++++++
- 4 files changed, 63 insertions(+), 2 deletions(-)
- create mode 100644 arch/mips/lib/memcmp.c
-
---- a/arch/mips/boot/compressed/Makefile
-+++ b/arch/mips/boot/compressed/Makefile
-@@ -23,7 +23,8 @@ KBUILD_CFLAGS := $(filter-out -pg, $(KBU
- KBUILD_CFLAGS := $(filter-out -fstack-protector, $(KBUILD_CFLAGS))
- 
- KBUILD_CFLAGS := $(KBUILD_CFLAGS) -D__KERNEL__ \
--	-DBOOT_HEAP_SIZE=$(BOOT_HEAP_SIZE) -D"VMLINUX_LOAD_ADDRESS_ULL=$(VMLINUX_LOAD_ADDRESS)ull"
-+	-DBOOT_HEAP_SIZE=$(BOOT_HEAP_SIZE) -D"VMLINUX_LOAD_ADDRESS_ULL=$(VMLINUX_LOAD_ADDRESS)ull" \
-+	-D__ZBOOT__
- 
- KBUILD_AFLAGS := $(KBUILD_AFLAGS) -D__ASSEMBLY__ \
- 	-DBOOT_HEAP_SIZE=$(BOOT_HEAP_SIZE) \
---- a/arch/mips/include/asm/string.h
-+++ b/arch/mips/include/asm/string.h
-@@ -140,4 +140,42 @@ extern void *memcpy(void *__to, __const_
- #define __HAVE_ARCH_MEMMOVE
- extern void *memmove(void *__dest, __const__ void *__src, size_t __n);
- 
-+#ifndef __ZBOOT__
-+#define memset(__s, __c, len)					\
-+({								\
-+	size_t __len = (len);					\
-+	void *__ret;						\
-+	if (__builtin_constant_p(len) && __len >= 64)		\
-+		__ret = memset((__s), (__c), __len);		\
-+	else							\
-+		__ret = __builtin_memset((__s), (__c), __len);	\
-+	__ret;							\
-+})
-+
-+#define memcpy(dst, src, len)					\
-+({								\
-+	size_t __len = (len);					\
-+	void *__ret;						\
-+	if (__builtin_constant_p(len) && __len >= 64)		\
-+		__ret = memcpy((dst), (src), __len);		\
-+	else							\
-+		__ret = __builtin_memcpy((dst), (src), __len);	\
-+	__ret;							\
-+})
-+
-+#define memmove(dst, src, len)					\
-+({								\
-+	size_t __len = (len);					\
-+	void *__ret;						\
-+	if (__builtin_constant_p(len) && __len >= 64)		\
-+		__ret = memmove((dst), (src), __len);		\
-+	else							\
-+		__ret = __builtin_memmove((dst), (src), __len);	\
-+	__ret;							\
-+})
-+
-+#define __HAVE_ARCH_MEMCMP
-+#define memcmp(src1, src2, len) __builtin_memcmp((src1), (src2), (len))
-+#endif
-+
- #endif /* _ASM_STRING_H */
---- a/arch/mips/lib/Makefile
-+++ b/arch/mips/lib/Makefile
-@@ -5,7 +5,7 @@
- 
- lib-y	+= bitops.o csum_partial.o delay.o memcpy.o memset.o \
- 	   mips-atomic.o strncpy_user.o \
--	   strnlen_user.o uncached.o
-+	   strnlen_user.o uncached.o memcmp.o
- 
- obj-y			+= iomap.o iomap_copy.o
- obj-$(CONFIG_PCI)	+= iomap-pci.o
---- /dev/null
-+++ b/arch/mips/lib/memcmp.c
-@@ -0,0 +1,22 @@
-+/*
-+ *  copied from linux/lib/string.c
-+ *
-+ *  Copyright (C) 1991, 1992  Linus Torvalds
-+ */
-+
-+#include <linux/module.h>
-+#include <linux/string.h>
-+
-+#undef memcmp
-+int memcmp(const void *cs, const void *ct, size_t count)
-+{
-+	const unsigned char *su1, *su2;
-+	int res = 0;
-+
-+	for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
-+		if ((res = *su1 - *su2) != 0)
-+			break;
-+	return res;
-+}
-+EXPORT_SYMBOL(memcmp);
-+
--- a/target/linux/generic/pending-4.19/307-mips_highmem_offset.patch	2022-03-22 08:54:47.392464978 +0800
+++ b/target/linux/generic/pending-4.19/307-mips_highmem_offset.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,19 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: kernel: adjust mips highmem offset to avoid the need for -mlong-calls on systems with >256M RAM
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- arch/mips/include/asm/mach-generic/spaces.h | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/arch/mips/include/asm/mach-generic/spaces.h
-+++ b/arch/mips/include/asm/mach-generic/spaces.h
-@@ -50,7 +50,7 @@
-  * Memory above this physical address will be considered highmem.
-  */
- #ifndef HIGHMEM_START
--#define HIGHMEM_START		_AC(0x20000000, UL)
-+#define HIGHMEM_START		_AC(0x10000000, UL)
- #endif
- 
- #endif /* CONFIG_32BIT */
--- a/target/linux/generic/pending-4.19/308-mips32r2_tune.patch	2022-03-22 08:54:47.393464979 +0800
+++ b/target/linux/generic/pending-4.19/308-mips32r2_tune.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,22 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: kernel: add -mtune=34kc to MIPS CFLAGS when building for mips32r2
-
-This provides a good tradeoff across at least 24Kc-74Kc, while also
-producing smaller code.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- arch/mips/Makefile | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/arch/mips/Makefile
-+++ b/arch/mips/Makefile
-@@ -177,7 +177,7 @@ cflags-$(CONFIG_CPU_VR41XX)	+= -march=r4
- cflags-$(CONFIG_CPU_R4X00)	+= -march=r4600 -Wa,--trap
- cflags-$(CONFIG_CPU_TX49XX)	+= -march=r4600 -Wa,--trap
- cflags-$(CONFIG_CPU_MIPS32_R1)	+= -march=mips32 -Wa,--trap
--cflags-$(CONFIG_CPU_MIPS32_R2)	+= -march=mips32r2 -Wa,--trap
-+cflags-$(CONFIG_CPU_MIPS32_R2)	+= -march=mips32r2 -mtune=34kc -Wa,--trap
- cflags-$(CONFIG_CPU_MIPS32_R6)	+= -march=mips32r6 -Wa,--trap -modd-spreg
- cflags-$(CONFIG_CPU_MIPS64_R1)	+= -march=mips64 -Wa,--trap
- cflags-$(CONFIG_CPU_MIPS64_R2)	+= -march=mips64r2 -Wa,--trap
--- a/target/linux/generic/pending-4.19/309-MIPS-Add-CPU-option-reporting-to-proc-cpuinfo.patch	2022-03-22 08:54:47.393464979 +0800
+++ b/target/linux/generic/pending-4.19/309-MIPS-Add-CPU-option-reporting-to-proc-cpuinfo.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,142 +0,0 @@
-From 87ec87c2ad615c1a177cd08ef5fa29fc739f6e50 Mon Sep 17 00:00:00 2001
-From: Hauke Mehrtens <hauke@hauke-m.de>
-Date: Sun, 23 Dec 2018 18:06:53 +0100
-Subject: [PATCH] MIPS: Add CPU option reporting to /proc/cpuinfo
-
-Many MIPS CPUs have optional CPU features which are not activates for
-all CPU cores. Print the CPU options which are implemented in the core
-in /proc/cpuinfo. This makes it possible to see what features are
-supported and which are not supported. This should cover all standard
-MIPS extensions, before it only printed information about the main MIPS
-ASEs.
-
-Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
----
- arch/mips/kernel/proc.c | 116 ++++++++++++++++++++++++++++++++++++++++
- 1 file changed, 116 insertions(+)
-
---- a/arch/mips/kernel/proc.c
-+++ b/arch/mips/kernel/proc.c
-@@ -134,6 +134,122 @@ static int show_cpuinfo(struct seq_file
- 		seq_printf(m, "micromips kernel\t: %s\n",
- 		      (read_c0_config3() & MIPS_CONF3_ISA_OE) ?  "yes" : "no");
- 	}
-+
-+	seq_printf(m, "Options implemented\t:");
-+	if (cpu_has_tlb)
-+		seq_printf(m, "%s", " tlb");
-+	if (cpu_has_ftlb)
-+		seq_printf(m, "%s", " ftlb");
-+	if (cpu_has_tlbinv)
-+		seq_printf(m, "%s", " tlbinv");
-+	if (cpu_has_segments)
-+		seq_printf(m, "%s", " segments");
-+	if (cpu_has_rixiex)
-+		seq_printf(m, "%s", " rixiex");
-+	if (cpu_has_ldpte)
-+		seq_printf(m, "%s", " ldpte");
-+	if (cpu_has_maar)
-+		seq_printf(m, "%s", " maar");
-+	if (cpu_has_rw_llb)
-+		seq_printf(m, "%s", " rw_llb");
-+	if (cpu_has_4kex)
-+		seq_printf(m, "%s", " 4kex");
-+	if (cpu_has_3k_cache)
-+		seq_printf(m, "%s", " 3k_cache");
-+	if (cpu_has_4k_cache)
-+		seq_printf(m, "%s", " 4k_cache");
-+	if (cpu_has_6k_cache)
-+		seq_printf(m, "%s", " 6k_cache");
-+	if (cpu_has_8k_cache)
-+		seq_printf(m, "%s", " 8k_cache");
-+	if (cpu_has_tx39_cache)
-+		seq_printf(m, "%s", " tx39_cache");
-+	if (cpu_has_octeon_cache)
-+		seq_printf(m, "%s", " octeon_cache");
-+	if (cpu_has_fpu)
-+		seq_printf(m, "%s", " fpu");
-+	if (cpu_has_32fpr)
-+		seq_printf(m, "%s", " 32fpr");
-+	if (cpu_has_cache_cdex_p)
-+		seq_printf(m, "%s", " cache_cdex_p");
-+	if (cpu_has_cache_cdex_s)
-+		seq_printf(m, "%s", " cache_cdex_s");
-+	if (cpu_has_prefetch)
-+		seq_printf(m, "%s", " prefetch");
-+	if (cpu_has_mcheck)
-+		seq_printf(m, "%s", " mcheck");
-+	if (cpu_has_ejtag)
-+		seq_printf(m, "%s", " ejtag");
-+	if (cpu_has_llsc)
-+		seq_printf(m, "%s", " llsc");
-+	if (cpu_has_bp_ghist)
-+		seq_printf(m, "%s", " bp_ghist");
-+	if (cpu_has_guestctl0ext)
-+		seq_printf(m, "%s", " guestctl0ext");
-+	if (cpu_has_guestctl1)
-+		seq_printf(m, "%s", " guestctl1");
-+	if (cpu_has_guestctl2)
-+		seq_printf(m, "%s", " guestctl2");
-+	if (cpu_has_guestid)
-+		seq_printf(m, "%s", " guestid");
-+	if (cpu_has_drg)
-+		seq_printf(m, "%s", " drg");
-+	if (cpu_has_rixi)
-+		seq_printf(m, "%s", " rixi");
-+	if (cpu_has_lpa)
-+		seq_printf(m, "%s", " lpa");
-+	if (cpu_has_mvh)
-+		seq_printf(m, "%s", " mvh");
-+	if (cpu_has_vtag_icache)
-+		seq_printf(m, "%s", " vtag_icache");
-+	if (cpu_has_dc_aliases)
-+		seq_printf(m, "%s", " dc_aliases");
-+	if (cpu_has_ic_fills_f_dc)
-+		seq_printf(m, "%s", " ic_fills_f_dc");
-+	if (cpu_has_pindexed_dcache)
-+		seq_printf(m, "%s", " pindexed_dcache");
-+	if (cpu_has_userlocal)
-+		seq_printf(m, "%s", " userlocal");
-+	if (cpu_has_nofpuex)
-+		seq_printf(m, "%s", " nofpuex");
-+	if (cpu_has_vint)
-+		seq_printf(m, "%s", " vint");
-+	if (cpu_has_veic)
-+		seq_printf(m, "%s", " veic");
-+	if (cpu_has_inclusive_pcaches)
-+		seq_printf(m, "%s", " inclusive_pcaches");
-+	if (cpu_has_perf_cntr_intr_bit)
-+		seq_printf(m, "%s", " perf_cntr_intr_bit");
-+	if (cpu_has_ufr)
-+		seq_printf(m, "%s", " ufr");
-+	if (cpu_has_fre)
-+		seq_printf(m, "%s", " fre");
-+	if (cpu_has_cdmm)
-+		seq_printf(m, "%s", " cdmm");
-+	if (cpu_has_small_pages)
-+		seq_printf(m, "%s", " small_pages");
-+	if (cpu_has_nan_legacy)
-+		seq_printf(m, "%s", " nan_legacy");
-+	if (cpu_has_nan_2008)
-+		seq_printf(m, "%s", " nan_2008");
-+	if (cpu_has_ebase_wg)
-+		seq_printf(m, "%s", " ebase_wg");
-+	if (cpu_has_badinstr)
-+		seq_printf(m, "%s", " badinstr");
-+	if (cpu_has_badinstrp)
-+		seq_printf(m, "%s", " badinstrp");
-+	if (cpu_has_contextconfig)
-+		seq_printf(m, "%s", " contextconfig");
-+	if (cpu_has_perf)
-+		seq_printf(m, "%s", " perf");
-+	if (cpu_has_shared_ftlb_ram)
-+		seq_printf(m, "%s", " shared_ftlb_ram");
-+	if (cpu_has_shared_ftlb_entries)
-+		seq_printf(m, "%s", " shared_ftlb_entries");
-+	if (cpu_has_mipsmt_pertccounters)
-+		seq_printf(m, "%s", " mipsmt_pertccounters");
-+	seq_printf(m, "\n");
-+
- 	seq_printf(m, "shadow register sets\t: %d\n",
- 		      cpu_data[n].srsets);
- 	seq_printf(m, "kscratch registers\t: %d\n",
--- a/target/linux/generic/pending-4.19/310-arm_module_unresolved_weak_sym.patch	2022-03-22 08:54:47.393464979 +0800
+++ b/target/linux/generic/pending-4.19/310-arm_module_unresolved_weak_sym.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,22 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: fix errors in unresolved weak symbols on arm
-
-lede-commit: 570699d4838a907c3ef9f2819bf19eb72997b32f
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- arch/arm/kernel/module.c | 4 ++++
- 1 file changed, 4 insertions(+)
-
---- a/arch/arm/kernel/module.c
-+++ b/arch/arm/kernel/module.c
-@@ -95,6 +95,10 @@ apply_relocate(Elf32_Shdr *sechdrs, cons
- 			return -ENOEXEC;
- 		}
- 
-+		if ((IS_ERR_VALUE(sym->st_value) || !sym->st_value) &&
-+		    ELF_ST_BIND(sym->st_info) == STB_WEAK)
-+			continue;
-+
- 		loc = dstsec->sh_addr + rel->r_offset;
- 
- 		switch (ELF32_R_TYPE(rel->r_info)) {
--- a/target/linux/generic/pending-4.19/330-MIPS-kexec-Accept-command-line-parameters-from-users.patch	2022-03-22 08:54:47.393464979 +0800
+++ b/target/linux/generic/pending-4.19/330-MIPS-kexec-Accept-command-line-parameters-from-users.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,272 +0,0 @@
-From: Yousong Zhou <yszhou4tech@gmail.com>
-Subject: MIPS: kexec: Accept command line parameters from userspace.
-
-Signed-off-by: Yousong Zhou <yszhou4tech@gmail.com>
----
- arch/mips/kernel/machine_kexec.c   |  153 +++++++++++++++++++++++++++++++-----
- arch/mips/kernel/machine_kexec.h   |   20 +++++
- arch/mips/kernel/relocate_kernel.S |   21 +++--
- 3 files changed, 167 insertions(+), 27 deletions(-)
- create mode 100644 arch/mips/kernel/machine_kexec.h
-
---- a/arch/mips/kernel/machine_kexec.c
-+++ b/arch/mips/kernel/machine_kexec.c
-@@ -10,14 +10,11 @@
- #include <linux/mm.h>
- #include <linux/delay.h>
- 
-+#include <asm/bootinfo.h>
- #include <asm/cacheflush.h>
- #include <asm/page.h>
--
--extern const unsigned char relocate_new_kernel[];
--extern const size_t relocate_new_kernel_size;
--
--extern unsigned long kexec_start_address;
--extern unsigned long kexec_indirection_page;
-+#include <linux/uaccess.h>
-+#include "machine_kexec.h"
- 
- int (*_machine_kexec_prepare)(struct kimage *) = NULL;
- void (*_machine_kexec_shutdown)(void) = NULL;
-@@ -28,6 +25,99 @@ atomic_t kexec_ready_to_reboot = ATOMIC_
- void (*_crash_smp_send_stop)(void) = NULL;
- #endif
- 
-+static void machine_kexec_print_args(void)
-+{
-+	unsigned long argc = (int)kexec_args[0];
-+	int i;
-+
-+	pr_info("kexec_args[0] (argc): %lu\n", argc);
-+	pr_info("kexec_args[1] (argv): %p\n", (void *)kexec_args[1]);
-+	pr_info("kexec_args[2] (env ): %p\n", (void *)kexec_args[2]);
-+	pr_info("kexec_args[3] (desc): %p\n", (void *)kexec_args[3]);
-+
-+	for (i = 0; i < argc; i++) {
-+		pr_info("kexec_argv[%d] = %p, %s\n",
-+				i, kexec_argv[i], kexec_argv[i]);
-+	}
-+}
-+
-+static void machine_kexec_init_argv(struct kimage *image)
-+{
-+	void __user *buf = NULL;
-+	size_t bufsz;
-+	size_t size;
-+	int i;
-+
-+	bufsz = 0;
-+	for (i = 0; i < image->nr_segments; i++) {
-+		struct kexec_segment *seg;
-+
-+		seg = &image->segment[i];
-+		if (seg->bufsz < 6)
-+			continue;
-+
-+		if (strncmp((char *) seg->buf, "kexec ", 6))
-+			continue;
-+
-+		buf = seg->buf;
-+		bufsz = seg->bufsz;
-+		break;
-+	}
-+
-+	if (!buf)
-+		return;
-+
-+	size = KEXEC_COMMAND_LINE_SIZE;
-+	size = min(size, bufsz);
-+	if (size < bufsz)
-+		pr_warn("kexec command line truncated to %zd bytes\n", size);
-+
-+	/* Copy to kernel space */
-+	copy_from_user(kexec_argv_buf, buf, size);
-+	kexec_argv_buf[size - 1] = 0;
-+}
-+
-+static void machine_kexec_parse_argv(struct kimage *image)
-+{
-+	char *reboot_code_buffer;
-+	int reloc_delta;
-+	char *ptr;
-+	int argc;
-+	int i;
-+
-+	ptr = kexec_argv_buf;
-+	argc = 0;
-+
-+	/*
-+	 * convert command line string to array of parameters
-+	 * (as bootloader does).
-+	 */
-+	while (ptr && *ptr && (KEXEC_MAX_ARGC > argc)) {
-+		if (*ptr == ' ') {
-+			*ptr++ = '\0';
-+			continue;
-+		}
-+
-+		kexec_argv[argc++] = ptr;
-+		ptr = strchr(ptr, ' ');
-+	}
-+
-+	if (!argc)
-+		return;
-+
-+	kexec_args[0] = argc;
-+	kexec_args[1] = (unsigned long)kexec_argv;
-+	kexec_args[2] = 0;
-+	kexec_args[3] = 0;
-+
-+	reboot_code_buffer = page_address(image->control_code_page);
-+	reloc_delta = reboot_code_buffer - (char *)kexec_relocate_new_kernel;
-+
-+	kexec_args[1] += reloc_delta;
-+	for (i = 0; i < argc; i++)
-+		kexec_argv[i] += reloc_delta;
-+}
-+
- static void kexec_image_info(const struct kimage *kimage)
- {
- 	unsigned long i;
-@@ -52,6 +142,18 @@ int
- machine_kexec_prepare(struct kimage *kimage)
- {
- 	kexec_image_info(kimage);
-+	/*
-+	 * Whenever arguments passed from kexec-tools, Init the arguments as
-+	 * the original ones to try avoiding booting failure.
-+	 */
-+
-+	kexec_args[0] = fw_arg0;
-+	kexec_args[1] = fw_arg1;
-+	kexec_args[2] = fw_arg2;
-+	kexec_args[3] = fw_arg3;
-+
-+	machine_kexec_init_argv(kimage);
-+	machine_kexec_parse_argv(kimage);
- 
- 	if (_machine_kexec_prepare)
- 		return _machine_kexec_prepare(kimage);
-@@ -89,10 +191,12 @@ machine_kexec(struct kimage *image)
- 	unsigned long *ptr;
- 
- 	reboot_code_buffer =
--	  (unsigned long)page_address(image->control_code_page);
-+		(unsigned long)page_address(image->control_code_page);
-+	pr_info("reboot_code_buffer = %p\n", (void *)reboot_code_buffer);
- 
- 	kexec_start_address =
- 		(unsigned long) phys_to_virt(image->start);
-+	pr_info("kexec_start_address = %p\n", (void *)kexec_start_address);
- 
- 	if (image->type == KEXEC_TYPE_DEFAULT) {
- 		kexec_indirection_page =
-@@ -100,9 +204,19 @@ machine_kexec(struct kimage *image)
- 	} else {
- 		kexec_indirection_page = (unsigned long)&image->head;
- 	}
-+	pr_info("kexec_indirection_page = %p\n", (void *)kexec_indirection_page);
- 
--	memcpy((void*)reboot_code_buffer, relocate_new_kernel,
--	       relocate_new_kernel_size);
-+	pr_info("Where is memcpy: %p\n", memcpy);
-+	pr_info("kexec_relocate_new_kernel = %p, kexec_relocate_new_kernel_end = %p\n",
-+		(void *)kexec_relocate_new_kernel, &kexec_relocate_new_kernel_end);
-+	pr_info("Copy %lu bytes from %p to %p\n", KEXEC_RELOCATE_NEW_KERNEL_SIZE,
-+		(void *)kexec_relocate_new_kernel, (void *)reboot_code_buffer);
-+	memcpy((void*)reboot_code_buffer, kexec_relocate_new_kernel,
-+	       KEXEC_RELOCATE_NEW_KERNEL_SIZE);
-+
-+	pr_info("Before _print_args().\n");
-+	machine_kexec_print_args();
-+	pr_info("Before eval loop.\n");
- 
- 	/*
- 	 * The generic kexec code builds a page list with physical
-@@ -124,15 +238,16 @@ machine_kexec(struct kimage *image)
- 	/*
- 	 * we do not want to be bothered.
- 	 */
-+	pr_info("Before irq_disable.\n");
- 	local_irq_disable();
- 
--	printk("Will call new kernel at %08lx\n", image->start);
--	printk("Bye ...\n");
-+	pr_info("Will call new kernel at %08lx\n", image->start);
-+	pr_info("Bye ...\n");
- 	__flush_cache_all();
- #ifdef CONFIG_SMP
- 	/* All secondary cpus now may jump to kexec_wait cycle */
- 	relocated_kexec_smp_wait = reboot_code_buffer +
--		(void *)(kexec_smp_wait - relocate_new_kernel);
-+		(void *)(kexec_smp_wait - kexec_relocate_new_kernel);
- 	smp_wmb();
- 	atomic_set(&kexec_ready_to_reboot, 1);
- #endif
---- /dev/null
-+++ b/arch/mips/kernel/machine_kexec.h
-@@ -0,0 +1,20 @@
-+#ifndef _MACHINE_KEXEC_H
-+#define _MACHINE_KEXEC_H
-+
-+#ifndef __ASSEMBLY__
-+extern const unsigned char kexec_relocate_new_kernel[];
-+extern unsigned long kexec_relocate_new_kernel_end;
-+extern unsigned long kexec_start_address;
-+extern unsigned long kexec_indirection_page;
-+
-+extern char kexec_argv_buf[];
-+extern char *kexec_argv[];
-+
-+#define KEXEC_RELOCATE_NEW_KERNEL_SIZE	((unsigned long)&kexec_relocate_new_kernel_end - (unsigned long)kexec_relocate_new_kernel)
-+#endif /* !__ASSEMBLY__ */
-+
-+#define KEXEC_COMMAND_LINE_SIZE		256
-+#define KEXEC_ARGV_SIZE			(KEXEC_COMMAND_LINE_SIZE / 16)
-+#define KEXEC_MAX_ARGC			(KEXEC_ARGV_SIZE / sizeof(long))
-+
-+#endif
---- a/arch/mips/kernel/relocate_kernel.S
-+++ b/arch/mips/kernel/relocate_kernel.S
-@@ -12,8 +12,9 @@
- #include <asm/mipsregs.h>
- #include <asm/stackframe.h>
- #include <asm/addrspace.h>
-+#include "machine_kexec.h"
- 
--LEAF(relocate_new_kernel)
-+LEAF(kexec_relocate_new_kernel)
- 	PTR_L a0,	arg0
- 	PTR_L a1,	arg1
- 	PTR_L a2,	arg2
-@@ -98,7 +99,7 @@ done:
- #endif
- 	/* jump to kexec_start_address */
- 	j		s1
--	END(relocate_new_kernel)
-+	END(kexec_relocate_new_kernel)
- 
- #ifdef CONFIG_SMP
- /*
-@@ -184,9 +185,15 @@ kexec_indirection_page:
- 	PTR		0
- 	.size		kexec_indirection_page, PTRSIZE
- 
--relocate_new_kernel_end:
-+kexec_argv_buf:
-+	EXPORT(kexec_argv_buf)
-+	.skip		KEXEC_COMMAND_LINE_SIZE
-+	.size		kexec_argv_buf, KEXEC_COMMAND_LINE_SIZE
-+
-+kexec_argv:
-+	EXPORT(kexec_argv)
-+	.skip		KEXEC_ARGV_SIZE
-+	.size		kexec_argv, KEXEC_ARGV_SIZE
- 
--relocate_new_kernel_size:
--	EXPORT(relocate_new_kernel_size)
--	PTR		relocate_new_kernel_end - relocate_new_kernel
--	.size		relocate_new_kernel_size, PTRSIZE
-+kexec_relocate_new_kernel_end:
-+	EXPORT(kexec_relocate_new_kernel_end)
--- a/target/linux/generic/pending-4.19/332-arc-add-OWRTDTB-section.patch	2022-03-22 08:54:47.394464981 +0800
+++ b/target/linux/generic/pending-4.19/332-arc-add-OWRTDTB-section.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,84 +0,0 @@
-From 34ef04f3845ed2b47d57dd9d3b795b16e1f8185a Mon Sep 17 00:00:00 2001
-From: Evgeniy Didin <Evgeniy.Didin@synopsys.com>
-Date: Fri, 15 Mar 2019 18:53:38 +0300
-Subject: [PATCH] arc add OWRTDTB section
-
-This change allows OpenWRT to patch resulting kernel binary with
-external .dtb.
-
-That allows us to re-use exactky the same vmlinux on different boards
-given its ARC core configurations match (at least cache line sizes etc).
-
-""patch-dtb" searches for ASCII "OWRTDTB:" strign and copies external
-.dtb right after it, keeping the string in place.
-
-Signed-off-by: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
-Signed-off-by: Alexey Brodkin <abrodkin@synopsys.com>
-Signed-off-by: Evgeniy Didin <Evgeniy.Didin@synopsys.com>
----
- arch/arc/kernel/head.S        | 10 ++++++++++
- arch/arc/kernel/setup.c       |  4 +++-
- arch/arc/kernel/vmlinux.lds.S | 13 +++++++++++++
- 3 files changed, 26 insertions(+), 1 deletion(-)
-
---- a/arch/arc/kernel/head.S
-+++ b/arch/arc/kernel/head.S
-@@ -59,6 +59,16 @@
- #endif
- .endm
- 
-+	; Here "patch-dtb" will embed external .dtb
-+	; Note "patch-dtb" searches for ASCII "OWRTDTB:" string
-+	; and pastes .dtb right after it, hense the string precedes
-+	; __image_dtb symbol.
-+	.section .owrt, "aw",@progbits
-+	.ascii  "OWRTDTB:"
-+ENTRY(__image_dtb)
-+	.fill   0x4000
-+END(__image_dtb)
-+
- 	.section .init.text, "ax",@progbits
- 
- ;----------------------------------------------------------------
---- a/arch/arc/kernel/setup.c
-+++ b/arch/arc/kernel/setup.c
-@@ -526,7 +526,7 @@ void __init handle_uboot_args(void)
- ignore_uboot_args:
- 
- 	if (use_embedded_dtb) {
--		machine_desc = setup_machine_fdt(__dtb_start);
-+		machine_desc = setup_machine_fdt(&__image_dtb);
- 		if (!machine_desc)
- 			panic("Embedded DT invalid\n");
- 	}
-@@ -542,6 +542,8 @@ ignore_uboot_args:
- 	}
- }
- 
-+extern struct boot_param_header __image_dtb;
-+
- void __init setup_arch(char **cmdline_p)
- {
- 	handle_uboot_args();
---- a/arch/arc/kernel/vmlinux.lds.S
-+++ b/arch/arc/kernel/vmlinux.lds.S
-@@ -30,6 +30,19 @@ SECTIONS
- 
- 	. = CONFIG_LINUX_LINK_BASE;
- 
-+	/*
-+	* In OpenWRT we want to patch built binary embedding .dtb of choice.
-+	* This is implemented with "patch-dtb" utility which searches for
-+	* "OWRTDTB:" string in first 16k of image and if it is found
-+	* copies .dtb right after mentioned string.
-+	*
-+	* Note: "OWRTDTB:" won't be overwritten with .dtb, .dtb will follow it.
-+	*/
-+ 	.owrt : {
-+		*(.owrt)
-+	. = ALIGN(PAGE_SIZE);
-+	}
-+
- 	_int_vec_base_lds = .;
- 	.vector : {
- 		*(.vector)
--- a/target/linux/generic/pending-4.19/333-arc-enable-unaligned-access-in-kernel-mode.patch	2022-03-22 08:54:47.394464981 +0800
+++ b/target/linux/generic/pending-4.19/333-arc-enable-unaligned-access-in-kernel-mode.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,24 +0,0 @@
-From: Alexey Brodkin <abrodkin@synopsys.com>
-Subject: arc: enable unaligned access in kernel mode
-
-This enables misaligned access handling even in kernel mode.
-Some wireless drivers (ath9k-htc and mt7601u) use misaligned accesses
-here and there and to cope with that without fixing stuff in the drivers
-we're just gracefully handling it on ARC.
-
-Signed-off-by: Alexey Brodkin <abrodkin@synopsys.com>
----
- arch/arc/kernel/unaligned.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/arch/arc/kernel/unaligned.c
-+++ b/arch/arc/kernel/unaligned.c
-@@ -206,7 +206,7 @@ int misaligned_fixup(unsigned long addre
- 	char buf[TASK_COMM_LEN];
- 
- 	/* handle user mode only and only if enabled by sysadmin */
--	if (!user_mode(regs) || !unaligned_enabled)
-+	if (!unaligned_enabled)
- 		return 1;
- 
- 	if (no_unaligned_warning) {
--- a/target/linux/generic/pending-4.19/341-MIPS-mm-remove-no-op-dma_map_ops-where-possible.patch	2022-03-22 08:54:47.394464981 +0800
+++ b/target/linux/generic/pending-4.19/341-MIPS-mm-remove-no-op-dma_map_ops-where-possible.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,82 +0,0 @@
-From 203f17906ff45705fbdaa0430dbbc71142c2640f Mon Sep 17 00:00:00 2001
-From: Hauke Mehrtens <hauke@hauke-m.de>
-Date: Sat, 8 Dec 2018 21:45:53 +0100
-Subject: [PATCH 1/3] MIPS: Compile post DMA flush only when needed
-
-dma_sync_phys() is only called for some CPUs when a mapping is removed.
-Add ARCH_HAS_SYNC_DMA_FOR_CPU only for the CPUs listed in
-cpu_needs_post_dma_flush() which need this extra call and do not compile
-this code in for other CPUs. We need this for R10000, R12000, BMIPS5000
-CPUs and CPUs supporting MAAR which was introduced in MIPS32r5.
-
-This will hopefully improve the performance of the not affected devices.
-
-Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
----
- arch/mips/Kconfig              | 6 +++++-
- arch/mips/mm/dma-noncoherent.c | 2 ++
- 2 files changed, 7 insertions(+), 1 deletion(-)
-
---- a/arch/mips/Kconfig
-+++ b/arch/mips/Kconfig
-@@ -1116,7 +1116,6 @@ config DMA_PERDEV_COHERENT
- config DMA_NONCOHERENT
- 	bool
- 	select ARCH_HAS_SYNC_DMA_FOR_DEVICE
--	select ARCH_HAS_SYNC_DMA_FOR_CPU
- 	select NEED_DMA_MAP_STATE
- 	select DMA_NONCOHERENT_MMAP
- 	select DMA_NONCOHERENT_CACHE_SYNC
-@@ -1897,9 +1896,11 @@ config SYS_HAS_CPU_MIPS32_R3_5
- 
- config SYS_HAS_CPU_MIPS32_R5
- 	bool
-+	select ARCH_HAS_SYNC_DMA_FOR_CPU
- 
- config SYS_HAS_CPU_MIPS32_R6
- 	bool
-+	select ARCH_HAS_SYNC_DMA_FOR_CPU
- 
- config SYS_HAS_CPU_MIPS64_R1
- 	bool
-@@ -1909,6 +1910,7 @@ config SYS_HAS_CPU_MIPS64_R2
- 
- config SYS_HAS_CPU_MIPS64_R6
- 	bool
-+	select ARCH_HAS_SYNC_DMA_FOR_CPU
- 
- config SYS_HAS_CPU_R3000
- 	bool
-@@ -1945,6 +1947,7 @@ config SYS_HAS_CPU_R8000
- 
- config SYS_HAS_CPU_R10000
- 	bool
-+	select ARCH_HAS_SYNC_DMA_FOR_CPU
- 
- config SYS_HAS_CPU_RM7000
- 	bool
-@@ -1973,6 +1976,7 @@ config SYS_HAS_CPU_BMIPS4380
- config SYS_HAS_CPU_BMIPS5000
- 	bool
- 	select SYS_HAS_CPU_BMIPS
-+	select ARCH_HAS_SYNC_DMA_FOR_CPU
- 
- config SYS_HAS_CPU_XLR
- 	bool
---- a/arch/mips/mm/dma-noncoherent.c
-+++ b/arch/mips/mm/dma-noncoherent.c
-@@ -191,12 +191,14 @@ void arch_sync_dma_for_device(struct dev
- 		dma_sync_phys(paddr, size, dir);
- }
- 
-+#ifdef CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU
- void arch_sync_dma_for_cpu(struct device *dev, phys_addr_t paddr,
- 		size_t size, enum dma_data_direction dir)
- {
- 	if (cpu_needs_post_dma_flush(dev))
- 		dma_sync_phys(paddr, size, dir);
- }
-+#endif
- 
- void arch_dma_cache_sync(struct device *dev, void *vaddr, size_t size,
- 		enum dma_data_direction direction)
--- a/target/linux/generic/pending-4.19/342-powerpc-Enable-kernel-XZ-compression-option-on-PPC_8.patch	2022-03-22 08:54:47.395464983 +0800
+++ b/target/linux/generic/pending-4.19/342-powerpc-Enable-kernel-XZ-compression-option-on-PPC_8.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,25 +0,0 @@
-From 66770a004afe10df11d3902e16eaa0c2c39436bb Mon Sep 17 00:00:00 2001
-From: Pawel Dembicki <paweldembicki@gmail.com>
-Date: Fri, 24 May 2019 17:56:19 +0200
-Subject: [PATCH] powerpc: Enable kernel XZ compression option on PPC_85xx
-
-Enable kernel XZ compression option on PPC_85xx. Tested with
-simpleImage on TP-Link TL-WDR4900 (Freescale P1014 processor).
-
-Suggested-by: Christian Lamparter <chunkeey@gmail.com>
-Signed-off-by: Pawel Dembicki <paweldembicki@gmail.com>
----
- arch/powerpc/Kconfig | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/arch/powerpc/Kconfig
-+++ b/arch/powerpc/Kconfig
-@@ -197,7 +197,7 @@ config PPC
- 	select HAVE_IOREMAP_PROT
- 	select HAVE_IRQ_EXIT_ON_IRQ_STACK
- 	select HAVE_KERNEL_GZIP
--	select HAVE_KERNEL_XZ			if PPC_BOOK3S
-+	select HAVE_KERNEL_XZ			if PPC_BOOK3S || PPC_85xx
- 	select HAVE_KPROBES
- 	select HAVE_KPROBES_ON_FTRACE
- 	select HAVE_KRETPROBES
--- a/target/linux/generic/pending-4.19/400-mtd-add-rootfs-split-support.patch	2022-03-22 08:54:47.395464983 +0800
+++ b/target/linux/generic/pending-4.19/400-mtd-add-rootfs-split-support.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,107 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: make rootfs split/detection more generic - patch can be moved to generic-2.6 after testing on other platforms
-
-lede-commit: 328e660b31f0937d52c5ae3d6e7029409918a9df
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- drivers/mtd/Kconfig            | 17 +++++++++++++++++
- drivers/mtd/mtdpart.c          | 35 +++++++++++++++++++++++++++++++++++
- include/linux/mtd/partitions.h |  2 ++
- 3 files changed, 54 insertions(+)
-
---- a/drivers/mtd/Kconfig
-+++ b/drivers/mtd/Kconfig
-@@ -11,6 +11,23 @@ menuconfig MTD
- 
- if MTD
- 
-+menu "OpenWrt specific MTD options"
-+
-+config MTD_ROOTFS_ROOT_DEV
-+	bool "Automatically set 'rootfs' partition to be root filesystem"
-+	default y
-+
-+config MTD_SPLIT_FIRMWARE
-+	bool "Automatically split firmware partition for kernel+rootfs"
-+	default y
-+
-+config MTD_SPLIT_FIRMWARE_NAME
-+	string "Firmware partition name"
-+	depends on MTD_SPLIT_FIRMWARE
-+	default "firmware"
-+
-+endmenu
-+
- config MTD_TESTS
- 	tristate "MTD tests support (DANGEROUS)"
- 	depends on m
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -29,10 +29,12 @@
- #include <linux/kmod.h>
- #include <linux/mtd/mtd.h>
- #include <linux/mtd/partitions.h>
-+#include <linux/magic.h>
- #include <linux/err.h>
- #include <linux/of.h>
- 
- #include "mtdcore.h"
-+#include "mtdsplit/mtdsplit.h"
- 
- /* Our partition linked list */
- static LIST_HEAD(mtd_partitions);
-@@ -52,6 +54,8 @@ struct mtd_part {
- 	struct list_head list;
- };
- 
-+static void mtd_partition_split(struct mtd_info *master, struct mtd_part *part);
-+
- /*
-  * Given a pointer to the MTD object in the mtd_part structure, we can retrieve
-  * the pointer to that structure.
-@@ -626,6 +630,7 @@ int mtd_add_partition(struct mtd_info *p
- 	if (ret)
- 		goto err_remove_part;
- 
-+	mtd_partition_split(parent, new);
- 	mtd_add_partition_attrs(new);
- 
- 	return 0;
-@@ -712,6 +717,29 @@ int mtd_del_partition(struct mtd_info *m
- }
- EXPORT_SYMBOL_GPL(mtd_del_partition);
- 
-+#ifdef CONFIG_MTD_SPLIT_FIRMWARE_NAME
-+#define SPLIT_FIRMWARE_NAME	CONFIG_MTD_SPLIT_FIRMWARE_NAME
-+#else
-+#define SPLIT_FIRMWARE_NAME	"unused"
-+#endif
-+
-+static void split_firmware(struct mtd_info *master, struct mtd_part *part)
-+{
-+}
-+
-+static void mtd_partition_split(struct mtd_info *master, struct mtd_part *part)
-+{
-+	static int rootfs_found = 0;
-+
-+	if (rootfs_found)
-+		return;
-+
-+	if (IS_ENABLED(CONFIG_MTD_SPLIT_FIRMWARE) &&
-+	    !strcmp(part->mtd.name, SPLIT_FIRMWARE_NAME) &&
-+	    !of_find_property(mtd_get_of_node(&part->mtd), "compatible", NULL))
-+		split_firmware(master, part);
-+}
-+
- /*
-  * This function, given a master MTD object and a partition table, creates
-  * and registers slave MTD objects which are bound to the master according to
-@@ -752,6 +780,7 @@ int add_mtd_partitions(struct mtd_info *
- 			goto err_del_partitions;
- 		}
- 
-+		mtd_partition_split(master, slave);
- 		mtd_add_partition_attrs(slave);
- 		/* Look for subpartitions */
- 		parse_mtd_partitions(&slave->mtd, parts[i].types, NULL);
--- a/target/linux/generic/pending-4.19/401-mtd-add-support-for-different-partition-parser-types.patch	2022-03-22 08:54:47.395464983 +0800
+++ b/target/linux/generic/pending-4.19/401-mtd-add-support-for-different-partition-parser-types.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,142 +0,0 @@
-From: Gabor Juhos <juhosg@openwrt.org>
-Subject: mtd: add support for different partition parser types
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/mtd/mtdpart.c          |   56 ++++++++++++++++++++++++++++++++++++++++
- include/linux/mtd/partitions.h |   11 ++++++++
- 2 files changed, 67 insertions(+)
-
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -55,6 +55,10 @@ struct mtd_part {
- };
- 
- static void mtd_partition_split(struct mtd_info *master, struct mtd_part *part);
-+static int parse_mtd_partitions_by_type(struct mtd_info *master,
-+					enum mtd_parser_type type,
-+					const struct mtd_partition **pparts,
-+					struct mtd_part_parser_data *data);
- 
- /*
-  * Given a pointer to the MTD object in the mtd_part structure, we can retrieve
-@@ -717,6 +721,36 @@ int mtd_del_partition(struct mtd_info *m
- }
- EXPORT_SYMBOL_GPL(mtd_del_partition);
- 
-+static int
-+run_parsers_by_type(struct mtd_part *slave, enum mtd_parser_type type)
-+{
-+	struct mtd_partition *parts;
-+	int nr_parts;
-+	int i;
-+
-+	nr_parts = parse_mtd_partitions_by_type(&slave->mtd, type, (const struct mtd_partition **)&parts,
-+						NULL);
-+	if (nr_parts <= 0)
-+		return nr_parts;
-+
-+	if (WARN_ON(!parts))
-+		return 0;
-+
-+	for (i = 0; i < nr_parts; i++) {
-+		/* adjust partition offsets */
-+		parts[i].offset += slave->offset;
-+
-+		mtd_add_partition(slave->parent,
-+				  parts[i].name,
-+				  parts[i].offset,
-+				  parts[i].size);
-+	}
-+
-+	kfree(parts);
-+
-+	return nr_parts;
-+}
-+
- #ifdef CONFIG_MTD_SPLIT_FIRMWARE_NAME
- #define SPLIT_FIRMWARE_NAME	CONFIG_MTD_SPLIT_FIRMWARE_NAME
- #else
-@@ -1066,6 +1100,61 @@ void mtd_part_parser_cleanup(struct mtd_
- 	}
- }
- 
-+static struct mtd_part_parser *
-+get_partition_parser_by_type(enum mtd_parser_type type,
-+			     struct mtd_part_parser *start)
-+{
-+	struct mtd_part_parser *p, *ret = NULL;
-+
-+	spin_lock(&part_parser_lock);
-+
-+	p = list_prepare_entry(start, &part_parsers, list);
-+	if (start)
-+		mtd_part_parser_put(start);
-+
-+	list_for_each_entry_continue(p, &part_parsers, list) {
-+		if (p->type == type && try_module_get(p->owner)) {
-+			ret = p;
-+			break;
-+		}
-+	}
-+
-+	spin_unlock(&part_parser_lock);
-+
-+	return ret;
-+}
-+
-+static int parse_mtd_partitions_by_type(struct mtd_info *master,
-+					enum mtd_parser_type type,
-+					const struct mtd_partition **pparts,
-+					struct mtd_part_parser_data *data)
-+{
-+	struct mtd_part_parser *prev = NULL;
-+	int ret = 0;
-+
-+	while (1) {
-+		struct mtd_part_parser *parser;
-+
-+		parser = get_partition_parser_by_type(type, prev);
-+		if (!parser)
-+			break;
-+
-+		ret = (*parser->parse_fn)(master, pparts, data);
-+
-+		if (ret > 0) {
-+			mtd_part_parser_put(parser);
-+			printk(KERN_NOTICE
-+			       "%d %s partitions found on MTD device %s\n",
-+			       ret, parser->name, master->name);
-+			break;
-+		}
-+
-+		prev = parser;
-+	}
-+
-+	return ret;
-+}
-+
- int mtd_is_partition(const struct mtd_info *mtd)
- {
- 	struct mtd_part *part;
---- a/include/linux/mtd/partitions.h
-+++ b/include/linux/mtd/partitions.h
-@@ -73,6 +73,10 @@ struct mtd_part_parser_data {
-  * Functions dealing with the various ways of partitioning the space
-  */
- 
-+enum mtd_parser_type {
-+	MTD_PARSER_TYPE_DEVICE = 0,
-+};
-+
- struct mtd_part_parser {
- 	struct list_head list;
- 	struct module *owner;
-@@ -81,6 +85,7 @@ struct mtd_part_parser {
- 	int (*parse_fn)(struct mtd_info *, const struct mtd_partition **,
- 			struct mtd_part_parser_data *);
- 	void (*cleanup)(const struct mtd_partition *pparts, int nr_parts);
-+	enum mtd_parser_type type;
- };
- 
- /* Container for passing around a set of parsed partitions */
--- a/target/linux/generic/pending-4.19/402-mtd-use-typed-mtd-parsers-for-rootfs-and-firmware-split.patch	2022-03-22 08:54:47.395464983 +0800
+++ b/target/linux/generic/pending-4.19/402-mtd-use-typed-mtd-parsers-for-rootfs-and-firmware-split.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,44 +0,0 @@
-From: Gabor Juhos <juhosg@openwrt.org>
-Subject: kernel/3.10: allow to use partition parsers for rootfs and firmware split
-
-lede-commit: 3b71cd94bc9517bc25267dccb393b07d4b54564e
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/mtd/mtdpart.c          | 37 +++++++++++++++++++++++++++++++++++++
- include/linux/mtd/partitions.h |  2 ++
- 2 files changed, 39 insertions(+)
-
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -759,6 +759,7 @@ run_parsers_by_type(struct mtd_part *sla
- 
- static void split_firmware(struct mtd_info *master, struct mtd_part *part)
- {
-+	run_parsers_by_type(part, MTD_PARSER_TYPE_FIRMWARE);
- }
- 
- static void mtd_partition_split(struct mtd_info *master, struct mtd_part *part)
-@@ -768,6 +769,12 @@ static void mtd_partition_split(struct m
- 	if (rootfs_found)
- 		return;
- 
-+	if (!strcmp(part->mtd.name, "rootfs")) {
-+		run_parsers_by_type(part, MTD_PARSER_TYPE_ROOTFS);
-+
-+		rootfs_found = 1;
-+	}
-+
- 	if (IS_ENABLED(CONFIG_MTD_SPLIT_FIRMWARE) &&
- 	    !strcmp(part->mtd.name, SPLIT_FIRMWARE_NAME) &&
- 	    !of_find_property(mtd_get_of_node(&part->mtd), "compatible", NULL))
---- a/include/linux/mtd/partitions.h
-+++ b/include/linux/mtd/partitions.h
-@@ -75,6 +75,8 @@ struct mtd_part_parser_data {
- 
- enum mtd_parser_type {
- 	MTD_PARSER_TYPE_DEVICE = 0,
-+	MTD_PARSER_TYPE_ROOTFS,
-+	MTD_PARSER_TYPE_FIRMWARE,
- };
- 
- struct mtd_part_parser {
--- a/target/linux/generic/pending-4.19/403-mtd-hook-mtdsplit-to-Kbuild.patch	2022-03-22 08:54:47.396464984 +0800
+++ b/target/linux/generic/pending-4.19/403-mtd-hook-mtdsplit-to-Kbuild.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,32 +0,0 @@
-From: Gabor Juhos <juhosg@openwrt.org>
-Subject: [PATCH] kernel/3.10: move squashfs check from rootfs split code into a separate file
-
-lede-commit: d89bea92b31b4e157a0fa438e75370f089f73427
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/mtd/Kconfig  | 2 ++
- drivers/mtd/Makefile | 2 ++
- 2 files changed, 4 insertions(+)
-
---- a/drivers/mtd/Kconfig
-+++ b/drivers/mtd/Kconfig
-@@ -26,6 +26,8 @@ config MTD_SPLIT_FIRMWARE_NAME
- 	depends on MTD_SPLIT_FIRMWARE
- 	default "firmware"
- 
-+source "drivers/mtd/mtdsplit/Kconfig"
-+
- endmenu
- 
- config MTD_TESTS
---- a/drivers/mtd/Makefile
-+++ b/drivers/mtd/Makefile
-@@ -7,6 +7,8 @@
- obj-$(CONFIG_MTD)		+= mtd.o
- mtd-y				:= mtdcore.o mtdsuper.o mtdconcat.o mtdpart.o mtdchar.o
- 
-+obj-$(CONFIG_MTD_SPLIT)		+= mtdsplit/
-+
- obj-$(CONFIG_MTD_OF_PARTS)	+= ofpart.o
- obj-$(CONFIG_MTD_REDBOOT_PARTS) += redboot.o
- obj-$(CONFIG_MTD_CMDLINE_PARTS) += cmdlinepart.o
--- a/target/linux/generic/pending-4.19/404-mtd-add-more-helper-functions.patch	2022-03-22 08:54:47.396464984 +0800
+++ b/target/linux/generic/pending-4.19/404-mtd-add-more-helper-functions.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,76 +0,0 @@
-From: Gabor Juhos <juhosg@openwrt.org>
-Subject: kernel/3.10: add separate rootfs partition parser
-
-lede-commit: daec7ad7688415156e2730e401503d09bd3acf91
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/mtd/mtdpart.c          | 29 +++++++++++++++++++++++++++++
- include/linux/mtd/mtd.h        | 18 ++++++++++++++++++
- include/linux/mtd/partitions.h |  2 ++
- 3 files changed, 49 insertions(+)
-
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -1179,6 +1179,24 @@ int mtd_is_partition(const struct mtd_in
- }
- EXPORT_SYMBOL_GPL(mtd_is_partition);
- 
-+struct mtd_info *mtdpart_get_master(const struct mtd_info *mtd)
-+{
-+	if (!mtd_is_partition(mtd))
-+		return (struct mtd_info *)mtd;
-+
-+	return mtd_to_part(mtd)->parent;
-+}
-+EXPORT_SYMBOL_GPL(mtdpart_get_master);
-+
-+uint64_t mtdpart_get_offset(const struct mtd_info *mtd)
-+{
-+	if (!mtd_is_partition(mtd))
-+		return 0;
-+
-+	return mtd_to_part(mtd)->offset;
-+}
-+EXPORT_SYMBOL_GPL(mtdpart_get_offset);
-+
- /* Returns the size of the entire flash chip */
- uint64_t mtd_get_device_size(const struct mtd_info *mtd)
- {
---- a/include/linux/mtd/mtd.h
-+++ b/include/linux/mtd/mtd.h
-@@ -507,6 +507,24 @@ static inline void mtd_align_erase_req(s
- 		req->len += mtd->erasesize - mod;
- }
- 
-+static inline uint64_t mtd_roundup_to_eb(uint64_t sz, struct mtd_info *mtd)
-+{
-+	if (mtd_mod_by_eb(sz, mtd) == 0)
-+		return sz;
-+
-+	/* Round up to next erase block */
-+	return (mtd_div_by_eb(sz, mtd) + 1) * mtd->erasesize;
-+}
-+
-+static inline uint64_t mtd_rounddown_to_eb(uint64_t sz, struct mtd_info *mtd)
-+{
-+	if (mtd_mod_by_eb(sz, mtd) == 0)
-+		return sz;
-+
-+	/* Round down to the start of the current erase block */
-+	return (mtd_div_by_eb(sz, mtd)) * mtd->erasesize;
-+}
-+
- static inline uint32_t mtd_div_by_ws(uint64_t sz, struct mtd_info *mtd)
- {
- 	if (mtd->writesize_shift)
---- a/include/linux/mtd/partitions.h
-+++ b/include/linux/mtd/partitions.h
-@@ -116,6 +116,8 @@ int mtd_is_partition(const struct mtd_in
- int mtd_add_partition(struct mtd_info *master, const char *name,
- 		      long long offset, long long length);
- int mtd_del_partition(struct mtd_info *master, int partno);
-+struct mtd_info *mtdpart_get_master(const struct mtd_info *mtd);
-+uint64_t mtdpart_get_offset(const struct mtd_info *mtd);
- uint64_t mtd_get_device_size(const struct mtd_info *mtd);
- 
- #endif
--- a/target/linux/generic/pending-4.19/411-mtd-partial_eraseblock_write.patch	2022-03-22 08:54:47.396464984 +0800
+++ b/target/linux/generic/pending-4.19/411-mtd-partial_eraseblock_write.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,132 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: mtd: implement write support for partitions covering only a part of an eraseblock (buffer data that would otherwise be erased)
-
-lede-commit: 87a8e8ac1067f58ba831c4aae443f3655c31cd80
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- drivers/mtd/mtdpart.c   | 90 ++++++++++++++++++++++++++++++++++++++++++++-----
- include/linux/mtd/mtd.h |  4 +++
- 2 files changed, 85 insertions(+), 9 deletions(-)
-
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -36,6 +36,8 @@
- #include "mtdcore.h"
- #include "mtdsplit/mtdsplit.h"
- 
-+#define MTD_ERASE_PARTIAL	0x8000 /* partition only covers parts of an erase block */
-+
- /* Our partition linked list */
- static LIST_HEAD(mtd_partitions);
- static DEFINE_MUTEX(mtd_partitions_mutex);
-@@ -220,6 +222,53 @@ static int part_erase(struct mtd_info *m
- {
- 	struct mtd_part *part = mtd_to_part(mtd);
- 	int ret;
-+	size_t wrlen = 0;
-+	u8 *erase_buf = NULL;
-+	u32 erase_buf_ofs = 0;
-+	bool partial_start = false;
-+
-+	if (mtd->flags & MTD_ERASE_PARTIAL) {
-+		size_t readlen = 0;
-+		u64 mtd_ofs;
-+
-+		erase_buf = kmalloc(part->parent->erasesize, GFP_ATOMIC);
-+		if (!erase_buf)
-+			return -ENOMEM;
-+
-+		mtd_ofs = part->offset + instr->addr;
-+		erase_buf_ofs = do_div(mtd_ofs, part->parent->erasesize);
-+
-+		if (erase_buf_ofs > 0) {
-+			instr->addr -= erase_buf_ofs;
-+			ret = mtd_read(part->parent,
-+				instr->addr + part->offset,
-+				part->parent->erasesize,
-+				&readlen, erase_buf);
-+
-+			instr->len += erase_buf_ofs;
-+			partial_start = true;
-+		} else {
-+			mtd_ofs = part->offset + part->mtd.size;
-+			erase_buf_ofs = part->parent->erasesize -
-+				do_div(mtd_ofs, part->parent->erasesize);
-+
-+			if (erase_buf_ofs > 0) {
-+				instr->len += erase_buf_ofs;
-+				ret = mtd_read(part->parent,
-+					part->offset + instr->addr +
-+					instr->len - part->parent->erasesize,
-+					part->parent->erasesize, &readlen,
-+					erase_buf);
-+			} else {
-+				ret = 0;
-+			}
-+		}
-+		if (ret < 0) {
-+			kfree(erase_buf);
-+			return ret;
-+		}
-+
-+	}
- 
- 	instr->addr += part->offset;
- 	ret = part->parent->_erase(part->parent, instr);
-@@ -227,6 +276,24 @@ static int part_erase(struct mtd_info *m
- 		instr->fail_addr -= part->offset;
- 	instr->addr -= part->offset;
- 
-+	if (mtd->flags & MTD_ERASE_PARTIAL) {
-+		if (partial_start) {
-+			part->parent->_write(part->parent,
-+				instr->addr, erase_buf_ofs,
-+				&wrlen, erase_buf);
-+			instr->addr += erase_buf_ofs;
-+		} else {
-+			instr->len -= erase_buf_ofs;
-+			part->parent->_write(part->parent,
-+				instr->addr + instr->len,
-+				erase_buf_ofs, &wrlen,
-+				erase_buf +
-+				part->parent->erasesize -
-+				erase_buf_ofs);
-+		}
-+		kfree(erase_buf);
-+	}
-+
- 	return ret;
- }
- 
-@@ -539,19 +606,22 @@ static struct mtd_part *allocate_partiti
- 	remainder = do_div(tmp, wr_alignment);
- 	if ((slave->mtd.flags & MTD_WRITEABLE) && remainder) {
- 		/* Doesn't start on a boundary of major erase size */
--		/* FIXME: Let it be writable if it is on a boundary of
--		 * _minor_ erase size though */
--		slave->mtd.flags &= ~MTD_WRITEABLE;
--		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase/write block boundary -- force read-only\n",
--			part->name);
-+		slave->mtd.flags |= MTD_ERASE_PARTIAL;
-+		if (((u32)slave->mtd.size) > parent->erasesize)
-+			slave->mtd.flags &= ~MTD_WRITEABLE;
-+		else
-+			slave->mtd.erasesize = slave->mtd.size;
- 	}
- 
--	tmp = part_absolute_offset(parent) + slave->mtd.size;
-+	tmp = part_absolute_offset(parent) + slave->offset + slave->mtd.size;
- 	remainder = do_div(tmp, wr_alignment);
- 	if ((slave->mtd.flags & MTD_WRITEABLE) && remainder) {
--		slave->mtd.flags &= ~MTD_WRITEABLE;
--		printk(KERN_WARNING"mtd: partition \"%s\" doesn't end on an erase/write block -- force read-only\n",
--			part->name);
-+		slave->mtd.flags |= MTD_ERASE_PARTIAL;
-+
-+		if ((u32)slave->mtd.size > parent->erasesize)
-+			slave->mtd.flags &= ~MTD_WRITEABLE;
-+		else
-+			slave->mtd.erasesize = slave->mtd.size;
- 	}
- 
- 	mtd_set_ooblayout(&slave->mtd, &part_ooblayout_ops);
--- a/target/linux/generic/pending-4.19/412-mtd-partial_eraseblock_unlock.patch	2022-03-22 08:54:47.397464986 +0800
+++ b/target/linux/generic/pending-4.19/412-mtd-partial_eraseblock_unlock.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,40 +0,0 @@
-From: Tim Harvey <tharvey@gateworks.com>
-Subject: mtd: allow partial block unlock
-
-This allows sysupgrade for devices such as the Gateworks Avila/Cambria
-product families based on the ixp4xx using the redboot bootloader with
-combined FIS directory and RedBoot config partitions on larger FLASH
-devices with larger eraseblocks.
-
-This second iteration of this patch addresses previous issues:
-- whitespace breakage fixed
-- unlock in all scenarios
-- simplification and fix logic bug
-
-[john@phrozen.org: this should be moved to the ixp4xx folder]
-
-Signed-off-by: Tim Harvey <tharvey@gateworks.com>
----
- drivers/mtd/mtdpart.c | 11 ++++++++++-
- 1 file changed, 10 insertions(+), 1 deletion(-)
-
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -306,7 +306,16 @@ static int part_lock(struct mtd_info *mt
- static int part_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
- {
- 	struct mtd_part *part = mtd_to_part(mtd);
--	return part->parent->_unlock(part->parent, ofs + part->offset, len);
-+
-+	ofs += part->offset;
-+
-+	if (mtd->flags & MTD_ERASE_PARTIAL) {
-+		/* round up len to next erasesize and round down offset to prev block */
-+		len = (mtd_div_by_eb(len, part->parent) + 1) * part->parent->erasesize;
-+		ofs &= ~(part->parent->erasesize - 1);
-+	}
-+
-+	return part->parent->_unlock(part->parent, ofs, len);
- }
- 
- static int part_is_locked(struct mtd_info *mtd, loff_t ofs, uint64_t len)
--- a/target/linux/generic/pending-4.19/419-mtd-redboot-add-of_match_table-with-DT-binding.patch	2022-03-22 08:54:47.397464986 +0800
+++ b/target/linux/generic/pending-4.19/419-mtd-redboot-add-of_match_table-with-DT-binding.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,31 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Subject: [PATCH] mtd: redboot: add of_match_table with DT binding
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-This allows parsing RedBoot compatible partitions for properly described
-flash device in DT.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
----
-
---- a/drivers/mtd/redboot.c
-+++ b/drivers/mtd/redboot.c
-@@ -289,9 +289,16 @@ static int parse_redboot_partitions(stru
- 	return ret;
- }
- 
-+static const struct of_device_id redboot_parser_of_match_table[] = {
-+	{ .compatible = "ecoscentric,redboot-fis-partitions" },
-+	{},
-+};
-+MODULE_DEVICE_TABLE(of, redboot_parser_of_match_table);
-+
- static struct mtd_part_parser redboot_parser = {
- 	.parse_fn = parse_redboot_partitions,
- 	.name = "RedBoot",
-+	.of_match_table = redboot_parser_of_match_table,
- };
- module_mtd_part_parser(redboot_parser);
- 
--- a/target/linux/generic/pending-4.19/420-mtd-redboot_space.patch	2022-03-22 08:54:47.397464986 +0800
+++ b/target/linux/generic/pending-4.19/420-mtd-redboot_space.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,41 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: add patch for including unpartitioned space in the rootfs partition for redboot devices (if applicable)
-
-[john@phrozen.org: used by ixp and others]
-
-lede-commit: 394918851f84e4d00fa16eb900e7700e95091f00
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- drivers/mtd/redboot.c | 19 +++++++++++++------
- 1 file changed, 13 insertions(+), 6 deletions(-)
-
---- a/drivers/mtd/redboot.c
-+++ b/drivers/mtd/redboot.c
-@@ -265,14 +265,21 @@ static int parse_redboot_partitions(stru
- #endif
- 		names += strlen(names)+1;
- 
--#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED
- 		if(fl->next && fl->img->flash_base + fl->img->size + master->erasesize <= fl->next->img->flash_base) {
--			i++;
--			parts[i].offset = parts[i-1].size + parts[i-1].offset;
--			parts[i].size = fl->next->img->flash_base - parts[i].offset;
--			parts[i].name = nullname;
--		}
-+			if (!strcmp(parts[i].name, "rootfs")) {
-+				parts[i].size = fl->next->img->flash_base;
-+				parts[i].size &= ~(master->erasesize - 1);
-+				parts[i].size -= parts[i].offset;
-+#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED
-+				nrparts--;
-+			} else {
-+				i++;
-+				parts[i].offset = parts[i-1].size + parts[i-1].offset;
-+				parts[i].size = fl->next->img->flash_base - parts[i].offset;
-+				parts[i].name = nullname;
- #endif
-+			}
-+		}
- 		tmp_fl = fl;
- 		fl = fl->next;
- 		kfree(tmp_fl);
--- a/target/linux/generic/pending-4.19/430-mtd-add-myloader-partition-parser.patch	2022-03-22 08:54:47.397464986 +0800
+++ b/target/linux/generic/pending-4.19/430-mtd-add-myloader-partition-parser.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,47 +0,0 @@
-From: Florian Fainelli <f.fainelli@gmail.com>
-Subject: Add myloader partition table parser
-
-[john@phozen.org: shoud be upstreamable]
-
-lede-commit: d8bf22859b51faa09d22c056fe221a45d2f7a3b8
-Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
----
- drivers/mtd/Kconfig  | 16 ++++++++++++++++
- drivers/mtd/Makefile |  1 +
- 2 files changed, 17 insertions(+)
-
---- a/drivers/mtd/Kconfig
-+++ b/drivers/mtd/Kconfig
-@@ -177,6 +177,22 @@ menu "Partition parsers"
- source "drivers/mtd/parsers/Kconfig"
- endmenu
- 
-+config MTD_MYLOADER_PARTS
-+	tristate "MyLoader partition parsing"
-+	depends on ADM5120 || ATH25 || ATH79
-+	---help---
-+	  MyLoader is a bootloader which allows the user to define partitions
-+	  in flash devices, by putting a table in the second erase block
-+	  on the device, similar to a partition table. This table gives the 
-+	  offsets and lengths of the user defined partitions.
-+
-+	  If you need code which can detect and parse these tables, and
-+	  register MTD 'partitions' corresponding to each image detected,
-+	  enable this option.
-+
-+	  You will still need the parsing functions to be called by the driver
-+	  for your particular device. It won't happen automatically.
-+
- comment "User Modules And Translation Layers"
- 
- #
---- a/drivers/mtd/Makefile
-+++ b/drivers/mtd/Makefile
-@@ -16,6 +16,7 @@ obj-$(CONFIG_MTD_AFS_PARTS)	+= afs.o
- obj-$(CONFIG_MTD_AR7_PARTS)	+= ar7part.o
- obj-$(CONFIG_MTD_BCM63XX_PARTS)	+= bcm63xxpart.o
- obj-$(CONFIG_MTD_BCM47XX_PARTS)	+= bcm47xxpart.o
-+obj-$(CONFIG_MTD_MYLOADER_PARTS) += myloader.o
- obj-y				+= parsers/
- 
- # 'Users' - code which presents functionality to userspace.
--- a/target/linux/generic/pending-4.19/431-mtd-bcm47xxpart-check-for-bad-blocks-when-calculatin.patch	2022-03-22 08:54:47.398464988 +0800
+++ b/target/linux/generic/pending-4.19/431-mtd-bcm47xxpart-check-for-bad-blocks-when-calculatin.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,68 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
-Subject: [PATCH] mtd: bcm47xxpart: check for bad blocks when calculating offsets
-
-Signed-off-by: Rafa Miecki <zajec5@gmail.com>
----
-
---- a/drivers/mtd/parsers/parser_trx.c
-+++ b/drivers/mtd/parsers/parser_trx.c
-@@ -29,6 +29,33 @@ struct trx_header {
- 	uint32_t offset[3];
- } __packed;
- 
-+/*
-+ * Calculate real end offset (address) for a given amount of data. It checks
-+ * all blocks skipping bad ones.
-+ */
-+static size_t parser_trx_real_offset(struct mtd_info *mtd, size_t bytes)
-+{
-+	size_t real_offset = 0;
-+
-+	if (mtd_block_isbad(mtd, real_offset))
-+		pr_warn("Base offset shouldn't be at bad block");
-+
-+	while (bytes >= mtd->erasesize) {
-+		bytes -= mtd->erasesize;
-+		real_offset += mtd->erasesize;
-+		while (mtd_block_isbad(mtd, real_offset)) {
-+			real_offset += mtd->erasesize;
-+
-+			if (real_offset >= mtd->size)
-+				return real_offset - mtd->erasesize;
-+		}
-+	}
-+
-+	real_offset += bytes;
-+
-+	return real_offset;
-+}
-+
- static const char *parser_trx_data_part_name(struct mtd_info *master,
- 					     size_t offset)
- {
-@@ -83,21 +110,21 @@ static int parser_trx_parse(struct mtd_i
- 	if (trx.offset[2]) {
- 		part = &parts[curr_part++];
- 		part->name = "loader";
--		part->offset = trx.offset[i];
-+		part->offset = parser_trx_real_offset(mtd, trx.offset[i]);
- 		i++;
- 	}
- 
- 	if (trx.offset[i]) {
- 		part = &parts[curr_part++];
- 		part->name = "linux";
--		part->offset = trx.offset[i];
-+		part->offset = parser_trx_real_offset(mtd, trx.offset[i]);
- 		i++;
- 	}
- 
- 	if (trx.offset[i]) {
- 		part = &parts[curr_part++];
--		part->name = parser_trx_data_part_name(mtd, trx.offset[i]);
--		part->offset = trx.offset[i];
-+		part->offset = parser_trx_real_offset(mtd, trx.offset[i]);
-+		part->name = parser_trx_data_part_name(mtd, part->offset);
- 		i++;
- 	}
- 
--- a/target/linux/generic/pending-4.19/432-mtd-bcm47xxpart-detect-T_Meter-partition.patch	2022-03-22 08:54:47.398464988 +0800
+++ b/target/linux/generic/pending-4.19/432-mtd-bcm47xxpart-detect-T_Meter-partition.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,37 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
-Subject: mtd: bcm47xxpart: detect T_Meter partition
-
-It can be found on many Netgear devices. It consists of many 0x30 blocks
-starting with 4D 54.
-
-Signed-off-by: Rafa Miecki <zajec5@gmail.com>
----
- drivers/mtd/bcm47xxpart.c | 10 ++++++++++
- 1 file changed, 10 insertions(+)
-
---- a/drivers/mtd/bcm47xxpart.c
-+++ b/drivers/mtd/bcm47xxpart.c
-@@ -39,6 +39,7 @@
- #define NVRAM_HEADER			0x48534C46	/* FLSH */
- #define POT_MAGIC1			0x54544f50	/* POTT */
- #define POT_MAGIC2			0x504f		/* OP */
-+#define T_METER_MAGIC			0x4D540000	/* MT */
- #define ML_MAGIC1			0x39685a42
- #define ML_MAGIC2			0x26594131
- #define TRX_MAGIC			0x30524448
-@@ -182,6 +183,15 @@ static int bcm47xxpart_parse(struct mtd_
- 					     MTD_WRITEABLE);
- 			continue;
- 		}
-+
-+		/* T_Meter */
-+		if ((le32_to_cpu(buf[0x000 / 4]) & 0xFFFF0000) == T_METER_MAGIC &&
-+		    (le32_to_cpu(buf[0x030 / 4]) & 0xFFFF0000) == T_METER_MAGIC &&
-+		    (le32_to_cpu(buf[0x060 / 4]) & 0xFFFF0000) == T_METER_MAGIC) {
-+			bcm47xxpart_add_part(&parts[curr_part++], "T_Meter", offset,
-+					     MTD_WRITEABLE);
-+			continue;
-+		}
- 
- 		/* TRX */
- 		if (buf[0x000 / 4] == TRX_MAGIC) {
--- a/target/linux/generic/pending-4.19/440-block2mtd_init.patch	2022-03-22 08:54:47.398464988 +0800
+++ b/target/linux/generic/pending-4.19/440-block2mtd_init.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,116 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: block2mtd
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- drivers/mtd/devices/block2mtd.c | 30 ++++++++++++++++++++----------
- 1 file changed, 20 insertions(+), 10 deletions(-)
-
---- a/drivers/mtd/devices/block2mtd.c
-+++ b/drivers/mtd/devices/block2mtd.c
-@@ -26,6 +26,7 @@
- #include <linux/list.h>
- #include <linux/init.h>
- #include <linux/mtd/mtd.h>
-+#include <linux/mtd/partitions.h>
- #include <linux/mutex.h>
- #include <linux/mount.h>
- #include <linux/slab.h>
-@@ -214,7 +215,7 @@ static void block2mtd_free_device(struct
- 
- 
- static struct block2mtd_dev *add_device(char *devname, int erase_size,
--		int timeout)
-+		const char *mtdname, int timeout)
- {
- #ifndef MODULE
- 	int i;
-@@ -222,6 +223,7 @@ static struct block2mtd_dev *add_device(
- 	const fmode_t mode = FMODE_READ | FMODE_WRITE | FMODE_EXCL;
- 	struct block_device *bdev;
- 	struct block2mtd_dev *dev;
-+	struct mtd_partition *part;
- 	char *name;
- 
- 	if (!devname)
-@@ -278,13 +280,16 @@ static struct block2mtd_dev *add_device(
- 
- 	/* Setup the MTD structure */
- 	/* make the name contain the block device in */
--	name = kasprintf(GFP_KERNEL, "block2mtd: %s", devname);
-+	if (!mtdname)
-+		mtdname = devname;
-+	name = kmalloc(strlen(mtdname) + 1, GFP_KERNEL);
- 	if (!name)
- 		goto err_destroy_mutex;
- 
-+	strcpy(name, mtdname);
- 	dev->mtd.name = name;
- 
--	dev->mtd.size = dev->blkdev->bd_inode->i_size & PAGE_MASK;
-+	dev->mtd.size = dev->blkdev->bd_inode->i_size & PAGE_MASK & ~(erase_size - 1);
- 	dev->mtd.erasesize = erase_size;
- 	dev->mtd.writesize = 1;
- 	dev->mtd.writebufsize = PAGE_SIZE;
-@@ -297,7 +302,11 @@ static struct block2mtd_dev *add_device(
- 	dev->mtd.priv = dev;
- 	dev->mtd.owner = THIS_MODULE;
- 
--	if (mtd_device_register(&dev->mtd, NULL, 0)) {
-+	part = kzalloc(sizeof(struct mtd_partition), GFP_KERNEL);
-+	part->name = name;
-+	part->offset = 0;
-+	part->size = dev->mtd.size;
-+	if (mtd_device_register(&dev->mtd, part, 1)) {
- 		/* Device didn't get added, so free the entry */
- 		goto err_destroy_mutex;
- 	}
-@@ -305,8 +314,7 @@ static struct block2mtd_dev *add_device(
- 	list_add(&dev->list, &blkmtd_device_list);
- 	pr_info("mtd%d: [%s] erase_size = %dKiB [%d]\n",
- 		dev->mtd.index,
--		dev->mtd.name + strlen("block2mtd: "),
--		dev->mtd.erasesize >> 10, dev->mtd.erasesize);
-+		mtdname, dev->mtd.erasesize >> 10, dev->mtd.erasesize);
- 	return dev;
- 
- err_destroy_mutex:
-@@ -379,7 +387,7 @@ static int block2mtd_setup2(const char *
- 	/* 80 for device, 12 for erase size, 80 for name, 8 for timeout */
- 	char buf[80 + 12 + 80 + 8];
- 	char *str = buf;
--	char *token[2];
-+	char *token[3];
- 	char *name;
- 	size_t erase_size = PAGE_SIZE;
- 	unsigned long timeout = MTD_DEFAULT_TIMEOUT;
-@@ -393,7 +401,7 @@ static int block2mtd_setup2(const char *
- 	strcpy(str, val);
- 	kill_final_newline(str);
- 
--	for (i = 0; i < 2; i++)
-+	for (i = 0; i < 3; i++)
- 		token[i] = strsep(&str, ",");
- 
- 	if (str) {
-@@ -419,8 +427,10 @@ static int block2mtd_setup2(const char *
- 			return 0;
- 		}
- 	}
-+	if (token[2] && (strlen(token[2]) + 1 > 80))
-+		pr_err("mtd device name too long\n");
- 
--	add_device(name, erase_size, timeout);
-+	add_device(name, erase_size, token[2], timeout);
- 
- 	return 0;
- }
-@@ -454,7 +464,7 @@ static int block2mtd_setup(const char *v
- 
- 
- module_param_call(block2mtd, block2mtd_setup, NULL, NULL, 0200);
--MODULE_PARM_DESC(block2mtd, "Device to use. \"block2mtd=<dev>[,<erasesize>]\"");
-+MODULE_PARM_DESC(block2mtd, "Device to use. \"block2mtd=<dev>[,<erasesize>[,<name>]]\"");
- 
- static int __init block2mtd_init(void)
- {
--- a/target/linux/generic/pending-4.19/441-block2mtd_probe.patch	2022-03-22 08:54:47.398464988 +0800
+++ b/target/linux/generic/pending-4.19/441-block2mtd_probe.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,47 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: block2mtd
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- drivers/mtd/devices/block2mtd.c | 9 ++++++---
- 1 file changed, 6 insertions(+), 3 deletions(-)
-
---- a/drivers/mtd/devices/block2mtd.c
-+++ b/drivers/mtd/devices/block2mtd.c
-@@ -387,7 +387,7 @@ static int block2mtd_setup2(const char *
- 	/* 80 for device, 12 for erase size, 80 for name, 8 for timeout */
- 	char buf[80 + 12 + 80 + 8];
- 	char *str = buf;
--	char *token[3];
-+	char *token[4];
- 	char *name;
- 	size_t erase_size = PAGE_SIZE;
- 	unsigned long timeout = MTD_DEFAULT_TIMEOUT;
-@@ -401,7 +401,7 @@ static int block2mtd_setup2(const char *
- 	strcpy(str, val);
- 	kill_final_newline(str);
- 
--	for (i = 0; i < 3; i++)
-+	for (i = 0; i < 4; i++)
- 		token[i] = strsep(&str, ",");
- 
- 	if (str) {
-@@ -430,6 +430,9 @@ static int block2mtd_setup2(const char *
- 	if (token[2] && (strlen(token[2]) + 1 > 80))
- 		pr_err("mtd device name too long\n");
- 
-+	if (token[3] && kstrtoul(token[3], 0, &timeout))
-+		pr_err("invalid timeout\n");
-+
- 	add_device(name, erase_size, token[2], timeout);
- 
- 	return 0;
-@@ -464,7 +467,7 @@ static int block2mtd_setup(const char *v
- 
- 
- module_param_call(block2mtd, block2mtd_setup, NULL, NULL, 0200);
--MODULE_PARM_DESC(block2mtd, "Device to use. \"block2mtd=<dev>[,<erasesize>[,<name>]]\"");
-+MODULE_PARM_DESC(block2mtd, "Device to use. \"block2mtd=<dev>[,<erasesize>[,<name>[,<timeout>]]]\"");
- 
- static int __init block2mtd_init(void)
- {
--- a/target/linux/generic/pending-4.19/450-mtd-spi-nor-allow-NOR-driver-to-write-fewer-bytes-th.patch	2022-03-22 08:54:47.399464989 +0800
+++ b/target/linux/generic/pending-4.19/450-mtd-spi-nor-allow-NOR-driver-to-write-fewer-bytes-th.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,36 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Thu, 22 Feb 2018 11:11:57 +0100
-Subject: [PATCH] mtd: spi-nor: allow NOR driver to write fewer bytes than
- requested
-
-The write size can be constrained by the maximum message/transfer size
-of the SPI controller. Only check for ret = 0 to avoid an infinite loop.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -1457,7 +1457,7 @@ static int spi_nor_write(struct mtd_info
- 
- 		write_enable(nor);
- 		ret = nor->write(nor, addr, page_remain, buf + i);
--		if (ret < 0)
-+		if (ret <= 0)
- 			goto write_err;
- 		written = ret;
- 
-@@ -1466,13 +1466,6 @@ static int spi_nor_write(struct mtd_info
- 			goto write_err;
- 		*retlen += written;
- 		i += written;
--		if (written != page_remain) {
--			dev_err(nor->dev,
--				"While writing %zu bytes written %zd bytes\n",
--				page_remain, written);
--			ret = -EIO;
--			goto write_err;
--		}
- 	}
- 
- write_err:
--- a/target/linux/generic/pending-4.19/460-mtd-cfi_cmdset_0002-no-erase_suspend.patch	2022-03-22 08:54:47.399464989 +0800
+++ b/target/linux/generic/pending-4.19/460-mtd-cfi_cmdset_0002-no-erase_suspend.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,25 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: kernel: disable cfi cmdset 0002 erase suspend
-
-on some platforms, erase suspend leads to data corruption and lockups when write
-ops collide with erase ops. this has been observed on the buffalo wzr-hp-g300nh.
-rather than play whack-a-mole with a hard to reproduce issue on a variety of devices,
-simply disable erase suspend, as it will usually not produce any useful gain on
-the small filesystems used on embedded hardware.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- drivers/mtd/chips/cfi_cmdset_0002.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/drivers/mtd/chips/cfi_cmdset_0002.c
-+++ b/drivers/mtd/chips/cfi_cmdset_0002.c
-@@ -812,7 +812,7 @@ static int get_chip(struct map_info *map
- 		return 0;
- 
- 	case FL_ERASING:
--		if (!cfip || !(cfip->EraseSuspend & (0x1|0x2)) ||
-+		if (1 /* no suspend */ || !cfip || !(cfip->EraseSuspend & (0x1|0x2)) ||
- 		    !(mode == FL_READY || mode == FL_POINT ||
- 		    (mode == FL_WRITING && (cfip->EraseSuspend & 0x2))))
- 			goto sleep;
--- a/target/linux/generic/pending-4.19/461-mtd-cfi_cmdset_0002-add-buffer-write-cmd-timeout.patch	2022-03-22 08:54:47.399464989 +0800
+++ b/target/linux/generic/pending-4.19/461-mtd-cfi_cmdset_0002-add-buffer-write-cmd-timeout.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,17 +0,0 @@
-From: George Kashperko <george@znau.edu.ua>
-Subject: Issue map read after Write Buffer Load command to ensure chip is ready to receive data.
-
-Signed-off-by: George Kashperko <george@znau.edu.ua>
----
- drivers/mtd/chips/cfi_cmdset_0002.c |    1 +
- 1 file changed, 1 insertion(+)
---- a/drivers/mtd/chips/cfi_cmdset_0002.c
-+++ b/drivers/mtd/chips/cfi_cmdset_0002.c
-@@ -1838,6 +1838,7 @@ static int __xipram do_write_buffer(stru
- 
- 	/* Write Buffer Load */
- 	map_write(map, CMD(0x25), cmd_adr);
-+	(void) map_read(map, cmd_adr);
- 
- 	chip->state = FL_WRITING_TO_BUFFER;
- 
--- a/target/linux/generic/pending-4.19/465-m25p80-mx-disable-software-protection.patch	2022-03-22 08:54:47.400464991 +0800
+++ b/target/linux/generic/pending-4.19/465-m25p80-mx-disable-software-protection.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,18 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: Disable software protection bits for Macronix flashes.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- drivers/mtd/spi-nor/spi-nor.c | 1 +
- 1 file changed, 1 insertion(+)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -2735,6 +2735,7 @@ static int spi_nor_init(struct spi_nor *
- 	 */
- 	if (JEDEC_MFR(nor->info) == SNOR_MFR_ATMEL ||
- 	    JEDEC_MFR(nor->info) == SNOR_MFR_INTEL ||
-+	    JEDEC_MFR(nor->info) == SNOR_MFR_MACRONIX ||
- 	    JEDEC_MFR(nor->info) == SNOR_MFR_SST ||
- 	    nor->info->flags & SPI_NOR_HAS_LOCK) {
- 		write_enable(nor);
--- a/target/linux/generic/pending-4.19/466-Revert-mtd-spi-nor-fix-Spansion-regressions-aliased-.patch	2022-03-22 08:54:47.400464991 +0800
+++ b/target/linux/generic/pending-4.19/466-Revert-mtd-spi-nor-fix-Spansion-regressions-aliased-.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,37 +0,0 @@
-From: Matthias Schiffer <mschiffer@universe-factory.net>
-Date: Tue, 9 Jan 2018 20:41:48 +0100
-Subject: [PATCH] Revert "mtd: spi-nor: fix Spansion regressions (aliased with
- Winbond)"
-
-This reverts commit 67b9bcd36906e12a15ffec19463afbbd6a41660e.
-
-The underlying issue breaking Spansion flash has been fixed with "mtd: spi-nor:
-wait until lock/unlock operations are ready" and "mtd: spi-nor: wait for SR_WIP
-to clear on initial unlock", so we can support unlocking for Winbond flash
-again.
-
-Signed-off-by: Matthias Schiffer <mschiffer@universe-factory.net>
----
- drivers/mtd/spi-nor/spi-nor.c | 4 +++-
- 1 file changed, 3 insertions(+), 1 deletion(-)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -2737,6 +2737,7 @@ static int spi_nor_init(struct spi_nor *
- 	    JEDEC_MFR(nor->info) == SNOR_MFR_INTEL ||
- 	    JEDEC_MFR(nor->info) == SNOR_MFR_MACRONIX ||
- 	    JEDEC_MFR(nor->info) == SNOR_MFR_SST ||
-+	    JEDEC_MFR(nor->info) == SNOR_MFR_WINBOND ||
- 	    nor->info->flags & SPI_NOR_HAS_LOCK) {
- 		write_enable(nor);
- 		write_sr(nor, 0);
-@@ -2873,7 +2874,8 @@ int spi_nor_scan(struct spi_nor *nor, co
- 
- 	/* NOR protection support for STmicro/Micron chips and similar */
- 	if (JEDEC_MFR(info) == SNOR_MFR_MICRON ||
--			info->flags & SPI_NOR_HAS_LOCK) {
-+	    JEDEC_MFR(info) == SNOR_MFR_WINBOND ||
-+	    info->flags & SPI_NOR_HAS_LOCK) {
- 		nor->flash_lock = stm_lock;
- 		nor->flash_unlock = stm_unlock;
- 		nor->flash_is_locked = stm_is_locked;
--- a/target/linux/generic/pending-4.19/470-mtd-spi-nor-support-limiting-4K-sectors-support-base.patch	2022-03-22 08:54:47.400464991 +0800
+++ b/target/linux/generic/pending-4.19/470-mtd-spi-nor-support-limiting-4K-sectors-support-base.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,56 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 4 Nov 2017 07:40:23 +0100
-Subject: [PATCH] mtd: spi-nor: support limiting 4K sectors support based on
- flash size
-
-Some devices need 4K sectors to be able to deal with small flash chips.
-For instance, w25x05 is 64 KiB in size, and without 4K sectors, the
-entire chip is just one erase block.
-On bigger flash chip sizes, using 4K sectors can significantly slow down
-many operations, including using a writable filesystem. There are several
-platforms where it makes sense to use a single kernel on both kinds of
-devices.
-
-To support this properly, allow configuring an upper flash chip size
-limit for 4K sectors support.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/drivers/mtd/spi-nor/Kconfig
-+++ b/drivers/mtd/spi-nor/Kconfig
-@@ -39,6 +39,17 @@ config SPI_ASPEED_SMC
- 	  and support for the SPI flash memory controller (SPI) for
- 	  the host firmware. The implementation only supports SPI NOR.
- 
-+config MTD_SPI_NOR_USE_4K_SECTORS_LIMIT
-+	int "Maximum flash chip size to use 4K sectors on (in KiB)"
-+	depends on MTD_SPI_NOR_USE_4K_SECTORS
-+	default "4096"
-+	help
-+	  There are many flash chips that support 4K sectors, but are so large
-+	  that using them significantly slows down writing large amounts of
-+	  data or using a writable filesystem.
-+	  Any flash chip larger than the size specified in this option will
-+	  not use 4K sectors.
-+
- config SPI_ATMEL_QUADSPI
- 	tristate "Atmel Quad SPI Controller"
- 	depends on ARCH_AT91 || (ARM && COMPILE_TEST && !ARCH_EBSA110)
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -2649,10 +2649,12 @@ static int spi_nor_select_erase(struct s
- 
- #ifdef CONFIG_MTD_SPI_NOR_USE_4K_SECTORS
- 	/* prefer "small sector" erase if possible */
--	if (info->flags & SECT_4K) {
-+	if ((info->flags & SECT_4K) && (mtd->size <=
-+	    CONFIG_MTD_SPI_NOR_USE_4K_SECTORS_LIMIT * 1024)) {
- 		nor->erase_opcode = SPINOR_OP_BE_4K;
- 		mtd->erasesize = 4096;
--	} else if (info->flags & SECT_4K_PMC) {
-+	} else if ((info->flags & SECT_4K_PMC) && (mtd->size <=
-+		   CONFIG_MTD_SPI_NOR_USE_4K_SECTORS_LIMIT * 1024)) {
- 		nor->erase_opcode = SPINOR_OP_BE_4K_PMC;
- 		mtd->erasesize = 4096;
- 	} else
--- a/target/linux/generic/pending-4.19/475-mtd-spi-nor-Add-Winbond-w25q128jv-support.patch	2022-03-22 08:54:47.401464993 +0800
+++ b/target/linux/generic/pending-4.19/475-mtd-spi-nor-Add-Winbond-w25q128jv-support.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,34 +0,0 @@
-From: Robert Marko <robimarko@gmail.com>
-To: linux-mtd@lists.infradead.org
-Subject: mtd: spi-nor: Add Winbond w25q128jv support
-Date: Mon, 25 Jun 2018 13:17:48 +0200
-
-Datasheet:
-http://www.winbond.com/resource-files/w25q128jv%20revf%2003272018%20plus.pdf
-
-Testing done on Mikrotik Routerboard  wAP R board.
-It does not support Dual or Quad modes.
-
-Signed-off-by: Robert Marko <robimarko@gmail.com>
----
-
-Changes in v2:
-	- Correct the title
----
- drivers/mtd/spi-nor/spi-nor.c | 5 +++++
- 1 file changed, 5 insertions(+)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -1241,6 +1241,11 @@ static const struct flash_info spi_nor_i
- 			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
- 			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
- 	},
-+	{
-+		"w25q128jv", INFO(0xef7018, 0, 64 * 1024, 256,
-+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
-+			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
-+	},
- 	{ "w25q80", INFO(0xef5014, 0, 64 * 1024,  16, SECT_4K) },
- 	{ "w25q80bl", INFO(0xef4014, 0, 64 * 1024,  16, SECT_4K) },
- 	{ "w25q128", INFO(0xef4018, 0, 64 * 1024, 256, SECT_4K) },
--- a/target/linux/generic/pending-4.19/476-mtd-spi-nor-add-eon-en25q128.patch	2022-03-22 08:54:47.401464993 +0800
+++ b/target/linux/generic/pending-4.19/476-mtd-spi-nor-add-eon-en25q128.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,18 +0,0 @@
-From: Piotr Dymacz <pepe2k@gmail.com>
-Subject: kernel/mtd: add support for EON EN25Q128
-
-Signed-off-by: Piotr Dymacz <pepe2k@gmail.com>
----
- drivers/mtd/spi-nor/spi-nor.c | 1 +
- 1 file changed, 1 insertion(+)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -994,6 +994,7 @@ static const struct flash_info spi_nor_i
- 	{ "en25q32b",   INFO(0x1c3016, 0, 64 * 1024,   64, 0) },
- 	{ "en25p64",    INFO(0x1c2017, 0, 64 * 1024,  128, 0) },
- 	{ "en25q64",    INFO(0x1c3017, 0, 64 * 1024,  128, SECT_4K) },
-+	{ "en25q128",   INFO(0x1c3018, 0, 64 * 1024,  256, SECT_4K) },
- 	{ "en25qh32",   INFO(0x1c7016, 0, 64 * 1024,   64, 0) },
- 	{ "en25qh128",  INFO(0x1c7018, 0, 64 * 1024,  256, 0) },
- 	{ "en25qh256",  INFO(0x1c7019, 0, 64 * 1024,  512, 0) },
--- a/target/linux/generic/pending-4.19/477-mtd-add-spi-nor-add-mx25u3235f.patch	2022-03-22 08:54:47.401464993 +0800
+++ b/target/linux/generic/pending-4.19/477-mtd-add-spi-nor-add-mx25u3235f.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,18 +0,0 @@
-From: Andr Valentin <avalentin@marcant.net>
-Subject: linux/mtd: add id for mx25u3235f needed by ZyXEL NBG6817
-
-Signed-off-by: Andr Valentin <avalentin@marcant.net>
----
- drivers/mtd/spi-nor/spi-nor.c | 1 +
- 1 file changed, 1 insertion(+)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -1083,6 +1083,7 @@ static const struct flash_info spi_nor_i
- 	{ "mx25l3205d",  INFO(0xc22016, 0, 64 * 1024,  64, SECT_4K) },
- 	{ "mx25l3255e",  INFO(0xc29e16, 0, 64 * 1024,  64, SECT_4K) },
- 	{ "mx25l6405d",  INFO(0xc22017, 0, 64 * 1024, 128, SECT_4K) },
-+	{ "mx25u3235f",	 INFO(0xc22536, 0, 64 * 1024, 64, 0) },
- 	{ "mx25u2033e",  INFO(0xc22532, 0, 64 * 1024,   4, SECT_4K) },
- 	{ "mx25u4035",   INFO(0xc22533, 0, 64 * 1024,   8, SECT_4K) },
- 	{ "mx25u8035",   INFO(0xc22534, 0, 64 * 1024,  16, SECT_4K) },
--- a/target/linux/generic/pending-4.19/479-mtd-spi-nor-add-eon-en25qh64.patch	2022-03-22 08:54:47.402464994 +0800
+++ b/target/linux/generic/pending-4.19/479-mtd-spi-nor-add-eon-en25qh64.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,10 +0,0 @@
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -996,6 +996,7 @@ static const struct flash_info spi_nor_i
- 	{ "en25q64",    INFO(0x1c3017, 0, 64 * 1024,  128, SECT_4K) },
- 	{ "en25q128",   INFO(0x1c3018, 0, 64 * 1024,  256, SECT_4K) },
- 	{ "en25qh32",   INFO(0x1c7016, 0, 64 * 1024,   64, 0) },
-+	{ "en25qh64",   INFO(0x1c7017, 0, 64 * 1024,   128, 0) },
- 	{ "en25qh128",  INFO(0x1c7018, 0, 64 * 1024,  256, 0) },
- 	{ "en25qh256",  INFO(0x1c7019, 0, 64 * 1024,  512, 0) },
- 	{ "en25s64",	INFO(0x1c3817, 0, 64 * 1024,  128, SECT_4K) },
--- a/target/linux/generic/pending-4.19/480-mtd-set-rootfs-to-be-root-dev.patch	2022-03-22 08:54:47.402464994 +0800
+++ b/target/linux/generic/pending-4.19/480-mtd-set-rootfs-to-be-root-dev.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,38 +0,0 @@
-From: Gabor Juhos <juhosg@openwrt.org>
-Subject: kernel/3.1[02]: move MTD root device setup code to mtdcore
-
-The current code only allows to automatically set
-root device on MTD partitions. Move the code to MTD
-core to allow to use it with all MTD devices.
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/mtd/mtdcore.c | 10 ++++++++++
- 1 file changed, 10 insertions(+)
-
---- a/drivers/mtd/mtdcore.c
-+++ b/drivers/mtd/mtdcore.c
-@@ -41,6 +41,7 @@
- #include <linux/reboot.h>
- #include <linux/leds.h>
- #include <linux/debugfs.h>
-+#include <linux/root_dev.h>
- 
- #include <linux/mtd/mtd.h>
- #include <linux/mtd/partitions.h>
-@@ -593,6 +594,15 @@ int add_mtd_device(struct mtd_info *mtd)
- 	   of this try_ nonsense, and no bitching about it
- 	   either. :) */
- 	__module_get(THIS_MODULE);
-+
-+	if (!strcmp(mtd->name, "rootfs") &&
-+	    IS_ENABLED(CONFIG_MTD_ROOTFS_ROOT_DEV) &&
-+	    ROOT_DEV == 0) {
-+		pr_notice("mtd: device %d (%s) set to be root filesystem\n",
-+			  mtd->index, mtd->name);
-+		ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, mtd->index);
-+	}
-+
- 	return 0;
- 
- fail_added:
--- a/target/linux/generic/pending-4.19/490-ubi-auto-attach-mtd-device-named-ubi-or-data-on-boot.patch	2022-03-22 08:54:47.402464994 +0800
+++ b/target/linux/generic/pending-4.19/490-ubi-auto-attach-mtd-device-named-ubi-or-data-on-boot.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,97 +0,0 @@
-From: Daniel Golle <daniel@makrotopia.org>
-Subject: ubi: auto-attach mtd device named "ubi" or "data" on boot
-
-Signed-off-by: Daniel Golle <daniel@makrotopia.org>
----
- drivers/mtd/ubi/build.c | 36 ++++++++++++++++++++++++++++++++++++
- 1 file changed, 36 insertions(+)
-
---- a/drivers/mtd/ubi/build.c
-+++ b/drivers/mtd/ubi/build.c
-@@ -1181,6 +1181,73 @@ static struct mtd_info * __init open_mtd
- 	return mtd;
- }
- 
-+/*
-+ * This function tries attaching mtd partitions named either "ubi" or "data"
-+ * during boot.
-+ */
-+static void __init ubi_auto_attach(void)
-+{
-+	int err;
-+	struct mtd_info *mtd;
-+	loff_t offset = 0;
-+	size_t len;
-+	char magic[4];
-+
-+	/* try attaching mtd device named "ubi" or "data" */
-+	mtd = open_mtd_device("ubi");
-+	if (IS_ERR(mtd))
-+		mtd = open_mtd_device("data");
-+
-+	if (IS_ERR(mtd))
-+		return;
-+
-+	/* get the first not bad block */
-+	if (mtd_can_have_bb(mtd))
-+		while (mtd_block_isbad(mtd, offset)) {
-+			offset += mtd->erasesize;
-+
-+			if (offset > mtd->size) {
-+				pr_err("UBI error: Failed to find a non-bad "
-+				       "block on mtd%d\n", mtd->index);
-+				goto cleanup;
-+			}
-+		}
-+
-+	/* check if the read from flash was successful */
-+	err = mtd_read(mtd, offset, 4, &len, (void *) magic);
-+	if ((err && !mtd_is_bitflip(err)) || len != 4) {
-+		pr_err("UBI error: unable to read from mtd%d\n", mtd->index);
-+		goto cleanup;
-+	}
-+
-+	/* check for a valid ubi magic */
-+	if (strncmp(magic, "UBI#", 4)) {
-+		pr_err("UBI error: no valid UBI magic found inside mtd%d\n", mtd->index);
-+		goto cleanup;
-+	}
-+
-+	/* don't auto-add media types where UBI doesn't makes sense */
-+	if (mtd->type != MTD_NANDFLASH &&
-+	    mtd->type != MTD_NORFLASH &&
-+	    mtd->type != MTD_DATAFLASH &&
-+	    mtd->type != MTD_MLCNANDFLASH)
-+		goto cleanup;
-+
-+	mutex_lock(&ubi_devices_mutex);
-+	pr_notice("UBI: auto-attach mtd%d\n", mtd->index);
-+	err = ubi_attach_mtd_dev(mtd, UBI_DEV_NUM_AUTO, 0, 0);
-+	mutex_unlock(&ubi_devices_mutex);
-+	if (err < 0) {
-+		pr_err("UBI error: cannot attach mtd%d\n", mtd->index);
-+		goto cleanup;
-+	}
-+
-+	return;
-+
-+cleanup:
-+	put_mtd_device(mtd);
-+}
-+
- static int __init ubi_init(void)
- {
- 	int err, i, k;
-@@ -1264,6 +1331,12 @@ static int __init ubi_init(void)
- 		}
- 	}
- 
-+	/* auto-attach mtd devices only if built-in to the kernel and no ubi.mtd
-+	 * parameter was given */
-+	if (IS_ENABLED(CONFIG_MTD_ROOTFS_ROOT_DEV) &&
-+	    !ubi_is_module() && !mtd_devs)
-+		ubi_auto_attach();
-+
- 	err = ubiblock_init();
- 	if (err) {
- 		pr_err("UBI error: block: cannot initialize, error %d\n", err);
--- a/target/linux/generic/pending-4.19/491-ubi-auto-create-ubiblock-device-for-rootfs.patch	2022-03-22 08:54:47.403464996 +0800
+++ b/target/linux/generic/pending-4.19/491-ubi-auto-create-ubiblock-device-for-rootfs.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,66 +0,0 @@
-From: Daniel Golle <daniel@makrotopia.org>
-Subject: ubi: auto-create ubiblock device for rootfs
-
-Signed-off-by: Daniel Golle <daniel@makrotopia.org>
----
- drivers/mtd/ubi/block.c | 42 ++++++++++++++++++++++++++++++++++++++++++
- 1 file changed, 42 insertions(+)
-
---- a/drivers/mtd/ubi/block.c
-+++ b/drivers/mtd/ubi/block.c
-@@ -633,6 +633,44 @@ static void __init ubiblock_create_from_
- 	}
- }
- 
-+#define UBIFS_NODE_MAGIC  0x06101831
-+static inline int ubi_vol_is_ubifs(struct ubi_volume_desc *desc)
-+{
-+	int ret;
-+	uint32_t magic_of, magic;
-+	ret = ubi_read(desc, 0, (char *)&magic_of, 0, 4);
-+	if (ret)
-+		return 0;
-+	magic = le32_to_cpu(magic_of);
-+	return magic == UBIFS_NODE_MAGIC;
-+}
-+
-+static void __init ubiblock_create_auto_rootfs(void)
-+{
-+	int ubi_num, ret, is_ubifs;
-+	struct ubi_volume_desc *desc;
-+	struct ubi_volume_info vi;
-+
-+	for (ubi_num = 0; ubi_num < UBI_MAX_DEVICES; ubi_num++) {
-+		desc = ubi_open_volume_nm(ubi_num, "rootfs", UBI_READONLY);
-+		if (IS_ERR(desc))
-+			continue;
-+
-+		ubi_get_volume_info(desc, &vi);
-+		is_ubifs = ubi_vol_is_ubifs(desc);
-+		ubi_close_volume(desc);
-+		if (is_ubifs)
-+			break;
-+
-+		ret = ubiblock_create(&vi);
-+		if (ret)
-+			pr_err("UBI error: block: can't add '%s' volume, err=%d\n",
-+				vi.name, ret);
-+		/* always break if we get here */
-+		break;
-+	}
-+}
-+
- static void ubiblock_remove_all(void)
- {
- 	struct ubiblock *next;
-@@ -665,6 +703,10 @@ int __init ubiblock_init(void)
- 	 */
- 	ubiblock_create_from_param();
- 
-+	/* auto-attach "rootfs" volume if existing and non-ubifs */
-+	if (IS_ENABLED(CONFIG_MTD_ROOTFS_ROOT_DEV))
-+		ubiblock_create_auto_rootfs();
-+
- 	/*
- 	 * Block devices are only created upon user requests, so we ignore
- 	 * existing volumes.
--- a/target/linux/generic/pending-4.19/492-try-auto-mounting-ubi0-rootfs-in-init-do_mounts.c.patch	2022-03-22 08:54:47.403464996 +0800
+++ b/target/linux/generic/pending-4.19/492-try-auto-mounting-ubi0-rootfs-in-init-do_mounts.c.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,51 +0,0 @@
-From: Daniel Golle <daniel@makrotopia.org>
-Subject: try auto-mounting ubi0:rootfs in init/do_mounts.c
-
-Signed-off-by: Daniel Golle <daniel@makrotopia.org>
----
- init/do_mounts.c | 26 +++++++++++++++++++++++++-
- 1 file changed, 25 insertions(+), 1 deletion(-)
-
---- a/init/do_mounts.c
-+++ b/init/do_mounts.c
-@@ -427,7 +427,28 @@ retry:
- out:
- 	put_page(page);
- }
-- 
-+
-+static int __init mount_ubi_rootfs(void)
-+{
-+	int flags = MS_SILENT;
-+	int err, tried = 0;
-+
-+	while (tried < 2) {
-+		err = do_mount_root("ubi0:rootfs", "ubifs", flags, \
-+					root_mount_data);
-+		switch (err) {
-+			case -EACCES:
-+				flags |= MS_RDONLY;
-+				tried++;
-+				break;
-+			default:
-+				return err;
-+		}
-+	}
-+
-+	return -EINVAL;
-+}
-+
- #ifdef CONFIG_ROOT_NFS
- 
- #define NFSROOT_TIMEOUT_MIN	5
-@@ -521,6 +542,10 @@ void __init mount_root(void)
- 			change_floppy("root floppy");
- 	}
- #endif
-+#ifdef CONFIG_MTD_ROOTFS_ROOT_DEV
-+	if (!mount_ubi_rootfs())
-+		return;
-+#endif
- #ifdef CONFIG_BLOCK
- 	{
- 		int err = create_dev("/dev/root", ROOT_DEV);
--- a/target/linux/generic/pending-4.19/493-ubi-set-ROOT_DEV-to-ubiblock-rootfs-if-unset.patch	2022-03-22 08:54:47.403464996 +0800
+++ b/target/linux/generic/pending-4.19/493-ubi-set-ROOT_DEV-to-ubiblock-rootfs-if-unset.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,34 +0,0 @@
-From: Daniel Golle <daniel@makrotopia.org>
-Subject: ubi: set ROOT_DEV to ubiblock "rootfs" if unset
-
-Signed-off-by: Daniel Golle <daniel@makrotopia.org>
----
- drivers/mtd/ubi/block.c | 10 ++++++++++
- 1 file changed, 10 insertions(+)
-
---- a/drivers/mtd/ubi/block.c
-+++ b/drivers/mtd/ubi/block.c
-@@ -50,6 +50,7 @@
- #include <linux/scatterlist.h>
- #include <linux/idr.h>
- #include <asm/div64.h>
-+#include <linux/root_dev.h>
- 
- #include "ubi-media.h"
- #include "ubi.h"
-@@ -445,6 +446,15 @@ int ubiblock_create(struct ubi_volume_in
- 	dev_info(disk_to_dev(dev->gd), "created from ubi%d:%d(%s)",
- 		 dev->ubi_num, dev->vol_id, vi->name);
- 	mutex_unlock(&devices_mutex);
-+
-+	if (!strcmp(vi->name, "rootfs") &&
-+	    IS_ENABLED(CONFIG_MTD_ROOTFS_ROOT_DEV) &&
-+	    ROOT_DEV == 0) {
-+		pr_notice("ubiblock: device ubiblock%d_%d (%s) set to be root filesystem\n",
-+			  dev->ubi_num, dev->vol_id, vi->name);
-+		ROOT_DEV = MKDEV(gd->major, gd->first_minor);
-+	}
-+
- 	return 0;
- 
- out_free_queue:
--- a/target/linux/generic/pending-4.19/494-mtd-ubi-add-EOF-marker-support.patch	2022-03-22 08:54:47.403464996 +0800
+++ b/target/linux/generic/pending-4.19/494-mtd-ubi-add-EOF-marker-support.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,60 +0,0 @@
-From: Gabor Juhos <juhosg@openwrt.org>
-Subject: mtd: add EOF marker support to the UBI layer
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/mtd/ubi/attach.c | 25 ++++++++++++++++++++++---
- drivers/mtd/ubi/ubi.h    |  1 +
- 2 files changed, 23 insertions(+), 3 deletions(-)
-
---- a/drivers/mtd/ubi/attach.c
-+++ b/drivers/mtd/ubi/attach.c
-@@ -939,6 +939,13 @@ static bool vol_ignored(int vol_id)
- #endif
- }
- 
-+static bool ec_hdr_has_eof(struct ubi_ec_hdr *ech)
-+{
-+	return ech->padding1[0] == 'E' &&
-+	       ech->padding1[1] == 'O' &&
-+	       ech->padding1[2] == 'F';
-+}
-+
- /**
-  * scan_peb - scan and process UBI headers of a PEB.
-  * @ubi: UBI device description object
-@@ -971,9 +978,21 @@ static int scan_peb(struct ubi_device *u
- 		return 0;
- 	}
- 
--	err = ubi_io_read_ec_hdr(ubi, pnum, ech, 0);
--	if (err < 0)
--		return err;
-+	if (!ai->eof_found) {
-+		err = ubi_io_read_ec_hdr(ubi, pnum, ech, 0);
-+		if (err < 0)
-+			return err;
-+
-+		if (ec_hdr_has_eof(ech)) {
-+			pr_notice("UBI: EOF marker found, PEBs from %d will be erased\n",
-+				pnum);
-+			ai->eof_found = true;
-+		}
-+	}
-+
-+	if (ai->eof_found)
-+		err = UBI_IO_FF_BITFLIPS;
-+
- 	switch (err) {
- 	case 0:
- 		break;
---- a/drivers/mtd/ubi/ubi.h
-+++ b/drivers/mtd/ubi/ubi.h
-@@ -789,6 +789,7 @@ struct ubi_attach_info {
- 	int mean_ec;
- 	uint64_t ec_sum;
- 	int ec_count;
-+	bool eof_found;
- 	struct kmem_cache *aeb_slab_cache;
- 	struct ubi_ec_hdr *ech;
- 	struct ubi_vid_io_buf *vidb;
--- a/target/linux/generic/pending-4.19/495-mtd-core-add-get_mtd_device_by_node.patch	2022-03-22 08:54:47.404464998 +0800
+++ b/target/linux/generic/pending-4.19/495-mtd-core-add-get_mtd_device_by_node.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,75 +0,0 @@
-From 1bd1b740f208d1cf4071932cc51860d37266c402 Mon Sep 17 00:00:00 2001
-From: Bernhard Frauendienst <kernel@nospam.obeliks.de>
-Date: Sat, 1 Sep 2018 00:30:11 +0200
-Subject: [PATCH 495/497] mtd: core: add get_mtd_device_by_node
-
-Add function to retrieve a mtd device by its OF node. Since drivers can
-assign arbitrary names to mtd devices in the absence of a label
-property, there is no other reliable way to retrieve a mtd device for a
-given OF node.
-
-Signed-off-by: Bernhard Frauendienst <kernel@nospam.obeliks.de>
-Reviewed-by: Miquel Raynal <miquel.raynal@bootlin.com>
----
- drivers/mtd/mtdcore.c   | 38 ++++++++++++++++++++++++++++++++++++++
- include/linux/mtd/mtd.h |  2 ++
- 2 files changed, 40 insertions(+)
-
---- a/drivers/mtd/mtdcore.c
-+++ b/drivers/mtd/mtdcore.c
-@@ -938,6 +938,44 @@ out_unlock:
- }
- EXPORT_SYMBOL_GPL(get_mtd_device_nm);
- 
-+/**
-+ *	get_mtd_device_by_node - obtain a validated handle for an MTD device
-+ *	by of_node
-+ *	@of_node: OF node of MTD device to open
-+ *
-+ *	This function returns MTD device description structure in case of
-+ *	success and an error code in case of failure.
-+ */
-+struct mtd_info *get_mtd_device_by_node(const struct device_node *of_node)
-+{
-+	int err = -ENODEV;
-+	struct mtd_info *mtd = NULL, *other;
-+
-+	mutex_lock(&mtd_table_mutex);
-+
-+	mtd_for_each_device(other) {
-+		if (of_node == other->dev.of_node) {
-+			mtd = other;
-+			break;
-+		}
-+	}
-+
-+	if (!mtd)
-+		goto out_unlock;
-+
-+	err = __get_mtd_device(mtd);
-+	if (err)
-+		goto out_unlock;
-+
-+	mutex_unlock(&mtd_table_mutex);
-+	return mtd;
-+
-+out_unlock:
-+	mutex_unlock(&mtd_table_mutex);
-+	return ERR_PTR(err);
-+}
-+EXPORT_SYMBOL_GPL(get_mtd_device_by_node);
-+
- void put_mtd_device(struct mtd_info *mtd)
- {
- 	mutex_lock(&mtd_table_mutex);
---- a/include/linux/mtd/mtd.h
-+++ b/include/linux/mtd/mtd.h
-@@ -589,6 +589,8 @@ extern struct mtd_info *get_mtd_device(s
- extern int __get_mtd_device(struct mtd_info *mtd);
- extern void __put_mtd_device(struct mtd_info *mtd);
- extern struct mtd_info *get_mtd_device_nm(const char *name);
-+extern struct mtd_info *get_mtd_device_by_node(
-+		const struct device_node *of_node);
- extern void put_mtd_device(struct mtd_info *mtd);
- 
- 
--- a/target/linux/generic/pending-4.19/496-dt-bindings-add-bindings-for-mtd-concat-devices.patch	2022-03-22 08:54:47.404464998 +0800
+++ b/target/linux/generic/pending-4.19/496-dt-bindings-add-bindings-for-mtd-concat-devices.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,52 +0,0 @@
-From 5734c6669fba7ddb5ef491ccff7159d15dba0b59 Mon Sep 17 00:00:00 2001
-From: Bernhard Frauendienst <kernel@nospam.obeliks.de>
-Date: Wed, 5 Sep 2018 01:32:51 +0200
-Subject: [PATCH 496/497] dt-bindings: add bindings for mtd-concat devices
-
-Document virtual mtd-concat device bindings.
-
-Signed-off-by: Bernhard Frauendienst <kernel@nospam.obeliks.de>
----
- .../devicetree/bindings/mtd/mtd-concat.txt    | 36 +++++++++++++++++++
- 1 file changed, 36 insertions(+)
- create mode 100644 Documentation/devicetree/bindings/mtd/mtd-concat.txt
-
---- /dev/null
-+++ b/Documentation/devicetree/bindings/mtd/mtd-concat.txt
-@@ -0,0 +1,36 @@
-+Virtual MTD concat device
-+
-+Requires properties:
-+- devices: list of phandles to mtd nodes that should be concatenated
-+
-+Example:
-+
-+&spi {
-+	flash0: flash@0 {
-+		...
-+	};
-+	flash1: flash@1 {
-+		...
-+	};
-+};
-+
-+flash {
-+	compatible = "mtd-concat";
-+
-+	devices = <&flash0 &flash1>;
-+
-+	partitions {
-+		compatible = "fixed-partitions";
-+
-+		partition@0 {
-+			label = "boot";
-+			reg = <0x0000000 0x0040000>;
-+			read-only;
-+		};
-+
-+		partition@40000 {
-+			label = "firmware";
-+			reg = <0x0040000 0x1fc0000>;
-+		};
-+	}
-+}
--- a/target/linux/generic/pending-4.19/497-mtd-mtdconcat-add-dt-driver-for-concat-devices.patch	2022-03-22 08:54:47.404464998 +0800
+++ b/target/linux/generic/pending-4.19/497-mtd-mtdconcat-add-dt-driver-for-concat-devices.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,216 +0,0 @@
-From e53f712d8eac71f54399b61038ccf87d2cee99d7 Mon Sep 17 00:00:00 2001
-From: Bernhard Frauendienst <kernel@nospam.obeliks.de>
-Date: Sat, 25 Aug 2018 12:35:22 +0200
-Subject: [PATCH 497/497] mtd: mtdconcat: add dt driver for concat devices
-
-Some mtd drivers like physmap variants have support for concatenating
-multiple mtd devices, but there is no generic way to define such a
-concat device from within the device tree.
-
-This is useful for some SoC boards that use multiple flash chips as
-memory banks of a single mtd device, with partitions spanning chip
-borders.
-
-This commit adds a driver for creating virtual mtd-concat devices. They
-must have a compatible = "mtd-concat" line, and define a list of devices
-to concat in the 'devices' property, for example:
-
-flash {
-  compatible = "mtd-concat";
-
-  devices = <&flash0 &flash1>;
-
-  partitions {
-    ...
-  };
-};
-
-The driver is added to the very end of the mtd Makefile to increase the
-likelyhood of all child devices already being loaded at the time of
-probing, preventing unnecessary deferred probes.
-
-Signed-off-by: Bernhard Frauendienst <kernel@nospam.obeliks.de>
----
- drivers/mtd/Kconfig                 |   2 +
- drivers/mtd/Makefile                |   3 +
- drivers/mtd/composite/Kconfig       |  12 +++
- drivers/mtd/composite/Makefile      |   6 ++
- drivers/mtd/composite/virt_concat.c | 128 ++++++++++++++++++++++++++++
- 5 files changed, 151 insertions(+)
- create mode 100644 drivers/mtd/composite/Kconfig
- create mode 100644 drivers/mtd/composite/Makefile
- create mode 100644 drivers/mtd/composite/virt_concat.c
-
---- a/drivers/mtd/Kconfig
-+++ b/drivers/mtd/Kconfig
-@@ -374,4 +374,6 @@ source "drivers/mtd/spi-nor/Kconfig"
- 
- source "drivers/mtd/ubi/Kconfig"
- 
-+source "drivers/mtd/composite/Kconfig"
-+
- endif # MTD
---- a/drivers/mtd/Makefile
-+++ b/drivers/mtd/Makefile
-@@ -39,3 +39,6 @@ obj-y		+= chips/ lpddr/ maps/ devices/ n
- 
- obj-$(CONFIG_MTD_SPI_NOR)	+= spi-nor/
- obj-$(CONFIG_MTD_UBI)		+= ubi/
-+
-+# Composite drivers must be loaded last
-+obj-y		+= composite/
---- /dev/null
-+++ b/drivers/mtd/composite/Kconfig
-@@ -0,0 +1,12 @@
-+menu "Composite MTD device drivers"
-+	depends on MTD!=n
-+
-+config MTD_VIRT_CONCAT
-+	tristate "Virtual concat MTD device"
-+	help
-+	  This driver allows creation of a virtual MTD concat device, which
-+	  concatenates multiple underlying MTD devices to a single device.
-+	  This is required by some SoC boards where multiple memory banks are
-+	  used as one device with partitions spanning across device boundaries.
-+
-+endmenu
---- /dev/null
-+++ b/drivers/mtd/composite/Makefile
-@@ -0,0 +1,6 @@
-+# SPDX-License-Identifier: GPL-2.0
-+#
-+# linux/drivers/mtd/composite/Makefile
-+#
-+
-+obj-$(CONFIG_MTD_VIRT_CONCAT)   += virt_concat.o
---- /dev/null
-+++ b/drivers/mtd/composite/virt_concat.c
-@@ -0,0 +1,128 @@
-+// SPDX-License-Identifier: GPL-2.0+
-+/*
-+ * Virtual concat MTD device driver
-+ *
-+ * Copyright (C) 2018 Bernhard Frauendienst
-+ * Author: Bernhard Frauendienst, kernel@nospam.obeliks.de
-+ */
-+
-+#include <linux/module.h>
-+#include <linux/device.h>
-+#include <linux/mtd/concat.h>
-+#include <linux/mtd/mtd.h>
-+#include <linux/mtd/partitions.h>
-+#include <linux/of.h>
-+#include <linux/of_platform.h>
-+#include <linux/slab.h>
-+
-+/*
-+ * struct of_virt_concat - platform device driver data.
-+ * @cmtd the final mtd_concat device
-+ * @num_devices the number of devices in @devices
-+ * @devices points to an array of devices already loaded
-+ */
-+struct of_virt_concat {
-+	struct mtd_info	*cmtd;
-+	int num_devices;
-+	struct mtd_info	**devices;
-+};
-+
-+static int virt_concat_remove(struct platform_device *pdev)
-+{
-+	struct of_virt_concat *info;
-+	int i;
-+
-+	info = platform_get_drvdata(pdev);
-+	if (!info)
-+		return 0;
-+
-+	// unset data for when this is called after a probe error
-+	platform_set_drvdata(pdev, NULL);
-+
-+	if (info->cmtd) {
-+		mtd_device_unregister(info->cmtd);
-+		mtd_concat_destroy(info->cmtd);
-+	}
-+
-+	if (info->devices) {
-+		for (i = 0; i < info->num_devices; i++)
-+			put_mtd_device(info->devices[i]);
-+	}
-+
-+	return 0;
-+}
-+
-+static int virt_concat_probe(struct platform_device *pdev)
-+{
-+	struct device_node *node = pdev->dev.of_node;
-+	struct of_phandle_iterator it;
-+	struct of_virt_concat *info;
-+	struct mtd_info *mtd;
-+	int err = 0, count;
-+
-+	count = of_count_phandle_with_args(node, "devices", NULL);
-+	if (count <= 0)
-+		return -EINVAL;
-+
-+	info = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);
-+	if (!info)
-+		return -ENOMEM;
-+	info->devices = devm_kcalloc(&pdev->dev, count,
-+				     sizeof(*(info->devices)), GFP_KERNEL);
-+	if (!info->devices) {
-+		err = -ENOMEM;
-+		goto err_remove;
-+	}
-+
-+	platform_set_drvdata(pdev, info);
-+
-+	of_for_each_phandle(&it, err, node, "devices", NULL, 0) {
-+		mtd = get_mtd_device_by_node(it.node);
-+		if (IS_ERR(mtd)) {
-+			of_node_put(it.node);
-+			err = -EPROBE_DEFER;
-+			goto err_remove;
-+		}
-+
-+		info->devices[info->num_devices++] = mtd;
-+	}
-+
-+	info->cmtd = mtd_concat_create(info->devices, info->num_devices,
-+				       dev_name(&pdev->dev));
-+	if (!info->cmtd) {
-+		err = -ENXIO;
-+		goto err_remove;
-+	}
-+
-+	info->cmtd->dev.parent = &pdev->dev;
-+	mtd_set_of_node(info->cmtd, node);
-+	mtd_device_register(info->cmtd, NULL, 0);
-+
-+	return 0;
-+
-+err_remove:
-+	virt_concat_remove(pdev);
-+
-+	return err;
-+}
-+
-+static const struct of_device_id virt_concat_of_match[] = {
-+	{ .compatible = "mtd-concat", },
-+	{ /* sentinel */ }
-+};
-+MODULE_DEVICE_TABLE(of, virt_concat_of_match);
-+
-+static struct platform_driver virt_concat_driver = {
-+	.probe = virt_concat_probe,
-+	.remove = virt_concat_remove,
-+	.driver	 = {
-+		.name   = "virt-mtdconcat",
-+		.of_match_table = virt_concat_of_match,
-+	},
-+};
-+
-+module_platform_driver(virt_concat_driver);
-+
-+MODULE_LICENSE("GPL v2");
-+MODULE_AUTHOR("Bernhard Frauendienst <kernel@nospam.obeliks.de>");
-+MODULE_DESCRIPTION("Virtual concat MTD device driver");
--- a/target/linux/generic/pending-4.19/530-jffs2_make_lzma_available.patch	2022-03-22 08:54:47.407465003 +0800
+++ b/target/linux/generic/pending-4.19/530-jffs2_make_lzma_available.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,5180 +0,0 @@
-From: Alexandros C. Couloumbis <alex@ozo.com>
-Subject: fs: add jffs2/lzma support (not activated by default yet)
-
-lede-commit: c2c88d315fa0e881f8b19da07b62859b915b11b2
-Signed-off-by: Alexandros C. Couloumbis <alex@ozo.com>
----
- fs/jffs2/Kconfig             |    9 +
- fs/jffs2/Makefile            |    3 +
- fs/jffs2/compr.c             |    6 +
- fs/jffs2/compr.h             |   10 +-
- fs/jffs2/compr_lzma.c        |  128 +++
- fs/jffs2/super.c             |   33 +-
- include/linux/lzma.h         |   62 ++
- include/linux/lzma/LzFind.h  |  115 +++
- include/linux/lzma/LzHash.h  |   54 +
- include/linux/lzma/LzmaDec.h |  231 +++++
- include/linux/lzma/LzmaEnc.h |   80 ++
- include/linux/lzma/Types.h   |  226 +++++
- include/uapi/linux/jffs2.h   |    1 +
- lib/Kconfig                  |    6 +
- lib/Makefile                 |   12 +
- lib/lzma/LzFind.c            |  761 ++++++++++++++
- lib/lzma/LzmaDec.c           |  999 +++++++++++++++++++
- lib/lzma/LzmaEnc.c           | 2271 ++++++++++++++++++++++++++++++++++++++++++
- lib/lzma/Makefile            |    7 +
- 19 files changed, 5008 insertions(+), 6 deletions(-)
- create mode 100644 fs/jffs2/compr_lzma.c
- create mode 100644 include/linux/lzma.h
- create mode 100644 include/linux/lzma/LzFind.h
- create mode 100644 include/linux/lzma/LzHash.h
- create mode 100644 include/linux/lzma/LzmaDec.h
- create mode 100644 include/linux/lzma/LzmaEnc.h
- create mode 100644 include/linux/lzma/Types.h
- create mode 100644 lib/lzma/LzFind.c
- create mode 100644 lib/lzma/LzmaDec.c
- create mode 100644 lib/lzma/LzmaEnc.c
- create mode 100644 lib/lzma/Makefile
-
---- a/fs/jffs2/Kconfig
-+++ b/fs/jffs2/Kconfig
-@@ -135,6 +135,15 @@ config JFFS2_LZO
- 	  This feature was added in July, 2007. Say 'N' if you need
- 	  compatibility with older bootloaders or kernels.
- 
-+config JFFS2_LZMA
-+	bool "JFFS2 LZMA compression support" if JFFS2_COMPRESSION_OPTIONS
-+	select LZMA_COMPRESS
-+	select LZMA_DECOMPRESS
-+	depends on JFFS2_FS
-+	default n
-+	help
-+	  JFFS2 wrapper to the LZMA C SDK
-+
- config JFFS2_RTIME
- 	bool "JFFS2 RTIME compression support" if JFFS2_COMPRESSION_OPTIONS
- 	depends on JFFS2_FS
---- a/fs/jffs2/Makefile
-+++ b/fs/jffs2/Makefile
-@@ -19,4 +19,7 @@ jffs2-$(CONFIG_JFFS2_RUBIN)	+= compr_rub
- jffs2-$(CONFIG_JFFS2_RTIME)	+= compr_rtime.o
- jffs2-$(CONFIG_JFFS2_ZLIB)	+= compr_zlib.o
- jffs2-$(CONFIG_JFFS2_LZO)	+= compr_lzo.o
-+jffs2-$(CONFIG_JFFS2_LZMA)      += compr_lzma.o
- jffs2-$(CONFIG_JFFS2_SUMMARY)   += summary.o
-+
-+CFLAGS_compr_lzma.o += -Iinclude/linux -Ilib/lzma
---- a/fs/jffs2/compr.c
-+++ b/fs/jffs2/compr.c
-@@ -378,6 +378,9 @@ int __init jffs2_compressors_init(void)
- #ifdef CONFIG_JFFS2_LZO
- 	jffs2_lzo_init();
- #endif
-+#ifdef CONFIG_JFFS2_LZMA
-+        jffs2_lzma_init();
-+#endif
- /* Setting default compression mode */
- #ifdef CONFIG_JFFS2_CMODE_NONE
- 	jffs2_compression_mode = JFFS2_COMPR_MODE_NONE;
-@@ -401,6 +404,9 @@ int __init jffs2_compressors_init(void)
- int jffs2_compressors_exit(void)
- {
- /* Unregistering compressors */
-+#ifdef CONFIG_JFFS2_LZMA
-+        jffs2_lzma_exit();
-+#endif
- #ifdef CONFIG_JFFS2_LZO
- 	jffs2_lzo_exit();
- #endif
---- a/fs/jffs2/compr.h
-+++ b/fs/jffs2/compr.h
-@@ -29,9 +29,9 @@
- #define JFFS2_DYNRUBIN_PRIORITY  20
- #define JFFS2_LZARI_PRIORITY     30
- #define JFFS2_RTIME_PRIORITY     50
--#define JFFS2_ZLIB_PRIORITY      60
--#define JFFS2_LZO_PRIORITY       80
--
-+#define JFFS2_LZMA_PRIORITY      70
-+#define JFFS2_ZLIB_PRIORITY      80
-+#define JFFS2_LZO_PRIORITY       90
- 
- #define JFFS2_RUBINMIPS_DISABLED /* RUBINs will be used only */
- #define JFFS2_DYNRUBIN_DISABLED  /*	   for decompression */
-@@ -101,5 +101,9 @@ void jffs2_zlib_exit(void);
- int jffs2_lzo_init(void);
- void jffs2_lzo_exit(void);
- #endif
-+#ifdef CONFIG_JFFS2_LZMA
-+int jffs2_lzma_init(void);
-+void jffs2_lzma_exit(void);
-+#endif
- 
- #endif /* __JFFS2_COMPR_H__ */
---- /dev/null
-+++ b/fs/jffs2/compr_lzma.c
-@@ -0,0 +1,128 @@
-+/*
-+ * JFFS2 -- Journalling Flash File System, Version 2.
-+ *
-+ * For licensing information, see the file 'LICENCE' in this directory.
-+ *
-+ * JFFS2 wrapper to the LZMA C SDK
-+ *
-+ */
-+
-+#include <linux/lzma.h>
-+#include "compr.h"
-+
-+#ifdef __KERNEL__
-+	static DEFINE_MUTEX(deflate_mutex);
-+#endif
-+
-+CLzmaEncHandle *p;
-+Byte propsEncoded[LZMA_PROPS_SIZE];
-+SizeT propsSize = sizeof(propsEncoded);
-+
-+STATIC void lzma_free_workspace(void)
-+{
-+	LzmaEnc_Destroy(p, &lzma_alloc, &lzma_alloc);
-+}
-+
-+STATIC int INIT lzma_alloc_workspace(CLzmaEncProps *props)
-+{
-+	if ((p = (CLzmaEncHandle *)LzmaEnc_Create(&lzma_alloc)) == NULL)
-+	{
-+		PRINT_ERROR("Failed to allocate lzma deflate workspace\n");
-+		return -ENOMEM;
-+	}
-+
-+	if (LzmaEnc_SetProps(p, props) != SZ_OK)
-+	{
-+		lzma_free_workspace();
-+		return -1;
-+	}
-+	
-+	if (LzmaEnc_WriteProperties(p, propsEncoded, &propsSize) != SZ_OK)
-+	{
-+		lzma_free_workspace();
-+		return -1;
-+	}
-+
-+        return 0;
-+}
-+
-+STATIC int jffs2_lzma_compress(unsigned char *data_in, unsigned char *cpage_out,
-+			      uint32_t *sourcelen, uint32_t *dstlen)
-+{
-+	SizeT compress_size = (SizeT)(*dstlen);
-+	int ret;
-+
-+	#ifdef __KERNEL__
-+		mutex_lock(&deflate_mutex);
-+	#endif
-+
-+	ret = LzmaEnc_MemEncode(p, cpage_out, &compress_size, data_in, *sourcelen,
-+		0, NULL, &lzma_alloc, &lzma_alloc);
-+
-+	#ifdef __KERNEL__
-+		mutex_unlock(&deflate_mutex);
-+	#endif
-+
-+	if (ret != SZ_OK)
-+		return -1;
-+
-+	*dstlen = (uint32_t)compress_size;
-+
-+	return 0;
-+}
-+
-+STATIC int jffs2_lzma_decompress(unsigned char *data_in, unsigned char *cpage_out,
-+				 uint32_t srclen, uint32_t destlen)
-+{
-+	int ret;
-+	SizeT dl = (SizeT)destlen;
-+	SizeT sl = (SizeT)srclen;
-+	ELzmaStatus status;
-+	
-+	ret = LzmaDecode(cpage_out, &dl, data_in, &sl, propsEncoded,
-+		propsSize, LZMA_FINISH_ANY, &status, &lzma_alloc);
-+
-+	if (ret != SZ_OK || status == LZMA_STATUS_NOT_FINISHED || dl != (SizeT)destlen)
-+		return -1;
-+
-+	return 0;
-+}
-+
-+static struct jffs2_compressor jffs2_lzma_comp = {
-+	.priority = JFFS2_LZMA_PRIORITY,
-+	.name = "lzma",
-+	.compr = JFFS2_COMPR_LZMA,
-+	.compress = &jffs2_lzma_compress,
-+	.decompress = &jffs2_lzma_decompress,
-+	.disabled = 0,
-+};
-+
-+int INIT jffs2_lzma_init(void)
-+{
-+        int ret;
-+	CLzmaEncProps props;
-+	LzmaEncProps_Init(&props);
-+
-+        props.dictSize = LZMA_BEST_DICT(0x2000);
-+        props.level = LZMA_BEST_LEVEL;
-+        props.lc = LZMA_BEST_LC;
-+        props.lp = LZMA_BEST_LP;
-+        props.pb = LZMA_BEST_PB;
-+        props.fb = LZMA_BEST_FB;
-+
-+	ret = lzma_alloc_workspace(&props);
-+        if (ret < 0)
-+                return ret;
-+
-+	ret = jffs2_register_compressor(&jffs2_lzma_comp);
-+	if (ret)
-+		lzma_free_workspace();
-+	
-+        return ret;
-+}
-+
-+void jffs2_lzma_exit(void)
-+{
-+	jffs2_unregister_compressor(&jffs2_lzma_comp);
-+	lzma_free_workspace();
-+}
---- a/fs/jffs2/super.c
-+++ b/fs/jffs2/super.c
-@@ -374,14 +374,41 @@ static int __init init_jffs2_fs(void)
- 	BUILD_BUG_ON(sizeof(struct jffs2_raw_inode) != 68);
- 	BUILD_BUG_ON(sizeof(struct jffs2_raw_summary) != 32);
- 
--	pr_info("version 2.2."
-+	pr_info("version 2.2"
- #ifdef CONFIG_JFFS2_FS_WRITEBUFFER
- 	       " (NAND)"
- #endif
- #ifdef CONFIG_JFFS2_SUMMARY
--	       " (SUMMARY) "
-+	       " (SUMMARY)"
- #endif
--	       "  2001-2006 Red Hat, Inc.\n");
-+#ifdef CONFIG_JFFS2_ZLIB
-+	       " (ZLIB)"
-+#endif
-+#ifdef CONFIG_JFFS2_LZO
-+	       " (LZO)"
-+#endif
-+#ifdef CONFIG_JFFS2_LZMA
-+	       " (LZMA)"
-+#endif
-+#ifdef CONFIG_JFFS2_RTIME
-+	       " (RTIME)"
-+#endif
-+#ifdef CONFIG_JFFS2_RUBIN
-+	       " (RUBIN)"
-+#endif
-+#ifdef  CONFIG_JFFS2_CMODE_NONE
-+	       " (CMODE_NONE)"
-+#endif
-+#ifdef CONFIG_JFFS2_CMODE_PRIORITY
-+	       " (CMODE_PRIORITY)"
-+#endif
-+#ifdef CONFIG_JFFS2_CMODE_SIZE
-+	       " (CMODE_SIZE)"
-+#endif
-+#ifdef CONFIG_JFFS2_CMODE_FAVOURLZO
-+	       " (CMODE_FAVOURLZO)"
-+#endif
-+	       " (c) 2001-2006 Red Hat, Inc.\n");
- 
- 	jffs2_inode_cachep = kmem_cache_create("jffs2_i",
- 					     sizeof(struct jffs2_inode_info),
---- /dev/null
-+++ b/include/linux/lzma.h
-@@ -0,0 +1,62 @@
-+#ifndef __LZMA_H__
-+#define __LZMA_H__
-+
-+#ifdef __KERNEL__
-+	#include <linux/kernel.h>
-+	#include <linux/sched.h>
-+	#include <linux/slab.h>
-+	#include <linux/vmalloc.h>
-+	#include <linux/init.h>
-+	#define LZMA_MALLOC vmalloc
-+	#define LZMA_FREE vfree
-+	#define PRINT_ERROR(msg) printk(KERN_WARNING #msg)
-+	#define INIT __init
-+	#define STATIC static
-+#else
-+	#include <stdint.h>
-+	#include <stdlib.h>
-+	#include <stdio.h>
-+	#include <unistd.h>
-+	#include <string.h>
-+	#include <asm/types.h>
-+	#include <errno.h>
-+	#include <linux/jffs2.h>
-+	#ifndef PAGE_SIZE
-+		extern int page_size;
-+		#define PAGE_SIZE page_size
-+	#endif
-+	#define LZMA_MALLOC malloc
-+	#define LZMA_FREE free
-+	#define PRINT_ERROR(msg) fprintf(stderr, msg)
-+	#define INIT
-+	#define STATIC
-+#endif
-+
-+#include "lzma/LzmaDec.h"
-+#include "lzma/LzmaEnc.h"
-+
-+#define LZMA_BEST_LEVEL (9)
-+#define LZMA_BEST_LC    (0)
-+#define LZMA_BEST_LP    (0)
-+#define LZMA_BEST_PB    (0)
-+#define LZMA_BEST_FB  (273)
-+
-+#define LZMA_BEST_DICT(n) (((int)((n) / 2)) * 2)
-+
-+static void *p_lzma_malloc(void *p, size_t size)
-+{
-+        if (size == 0)
-+                return NULL;
-+
-+        return LZMA_MALLOC(size);
-+}
-+
-+static void p_lzma_free(void *p, void *address)
-+{
-+        if (address != NULL)
-+                LZMA_FREE(address);
-+}
-+
-+static ISzAlloc lzma_alloc = {p_lzma_malloc, p_lzma_free};
-+
-+#endif
---- /dev/null
-+++ b/include/linux/lzma/LzFind.h
-@@ -0,0 +1,115 @@
-+/* LzFind.h -- Match finder for LZ algorithms
-+2009-04-22 : Igor Pavlov : Public domain */
-+
-+#ifndef __LZ_FIND_H
-+#define __LZ_FIND_H
-+
-+#include "Types.h"
-+
-+#ifdef __cplusplus
-+extern "C" {
-+#endif
-+
-+typedef UInt32 CLzRef;
-+
-+typedef struct _CMatchFinder
-+{
-+  Byte *buffer;
-+  UInt32 pos;
-+  UInt32 posLimit;
-+  UInt32 streamPos;
-+  UInt32 lenLimit;
-+
-+  UInt32 cyclicBufferPos;
-+  UInt32 cyclicBufferSize; /* it must be = (historySize + 1) */
-+
-+  UInt32 matchMaxLen;
-+  CLzRef *hash;
-+  CLzRef *son;
-+  UInt32 hashMask;
-+  UInt32 cutValue;
-+
-+  Byte *bufferBase;
-+  ISeqInStream *stream;
-+  int streamEndWasReached;
-+
-+  UInt32 blockSize;
-+  UInt32 keepSizeBefore;
-+  UInt32 keepSizeAfter;
-+
-+  UInt32 numHashBytes;
-+  int directInput;
-+  size_t directInputRem;
-+  int btMode;
-+  int bigHash;
-+  UInt32 historySize;
-+  UInt32 fixedHashSize;
-+  UInt32 hashSizeSum;
-+  UInt32 numSons;
-+  SRes result;
-+  UInt32 crc[256];
-+} CMatchFinder;
-+
-+#define Inline_MatchFinder_GetPointerToCurrentPos(p) ((p)->buffer)
-+#define Inline_MatchFinder_GetIndexByte(p, index) ((p)->buffer[(Int32)(index)])
-+
-+#define Inline_MatchFinder_GetNumAvailableBytes(p) ((p)->streamPos - (p)->pos)
-+
-+int MatchFinder_NeedMove(CMatchFinder *p);
-+Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p);
-+void MatchFinder_MoveBlock(CMatchFinder *p);
-+void MatchFinder_ReadIfRequired(CMatchFinder *p);
-+
-+void MatchFinder_Construct(CMatchFinder *p);
-+
-+/* Conditions:
-+     historySize <= 3 GB
-+     keepAddBufferBefore + matchMaxLen + keepAddBufferAfter < 511MB
-+*/
-+int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
-+    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
-+    ISzAlloc *alloc);
-+void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc);
-+void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems);
-+void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue);
-+
-+UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *buffer, CLzRef *son,
-+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
-+    UInt32 *distances, UInt32 maxLen);
-+
-+/*
-+Conditions:
-+  Mf_GetNumAvailableBytes_Func must be called before each Mf_GetMatchLen_Func.
-+  Mf_GetPointerToCurrentPos_Func's result must be used only before any other function
-+*/
-+
-+typedef void (*Mf_Init_Func)(void *object);
-+typedef Byte (*Mf_GetIndexByte_Func)(void *object, Int32 index);
-+typedef UInt32 (*Mf_GetNumAvailableBytes_Func)(void *object);
-+typedef const Byte * (*Mf_GetPointerToCurrentPos_Func)(void *object);
-+typedef UInt32 (*Mf_GetMatches_Func)(void *object, UInt32 *distances);
-+typedef void (*Mf_Skip_Func)(void *object, UInt32);
-+
-+typedef struct _IMatchFinder
-+{
-+  Mf_Init_Func Init;
-+  Mf_GetIndexByte_Func GetIndexByte;
-+  Mf_GetNumAvailableBytes_Func GetNumAvailableBytes;
-+  Mf_GetPointerToCurrentPos_Func GetPointerToCurrentPos;
-+  Mf_GetMatches_Func GetMatches;
-+  Mf_Skip_Func Skip;
-+} IMatchFinder;
-+
-+void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable);
-+
-+void MatchFinder_Init(CMatchFinder *p);
-+UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
-+UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
-+void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
-+void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
-+
-+#ifdef __cplusplus
-+}
-+#endif
-+
-+#endif
---- /dev/null
-+++ b/include/linux/lzma/LzHash.h
-@@ -0,0 +1,54 @@
-+/* LzHash.h -- HASH functions for LZ algorithms
-+2009-02-07 : Igor Pavlov : Public domain */
-+
-+#ifndef __LZ_HASH_H
-+#define __LZ_HASH_H
-+
-+#define kHash2Size (1 << 10)
-+#define kHash3Size (1 << 16)
-+#define kHash4Size (1 << 20)
-+
-+#define kFix3HashSize (kHash2Size)
-+#define kFix4HashSize (kHash2Size + kHash3Size)
-+#define kFix5HashSize (kHash2Size + kHash3Size + kHash4Size)
-+
-+#define HASH2_CALC hashValue = cur[0] | ((UInt32)cur[1] << 8);
-+
-+#define HASH3_CALC { \
-+  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
-+  hash2Value = temp & (kHash2Size - 1); \
-+  hashValue = (temp ^ ((UInt32)cur[2] << 8)) & p->hashMask; }
-+
-+#define HASH4_CALC { \
-+  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
-+  hash2Value = temp & (kHash2Size - 1); \
-+  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
-+  hashValue = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)) & p->hashMask; }
-+
-+#define HASH5_CALC { \
-+  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
-+  hash2Value = temp & (kHash2Size - 1); \
-+  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
-+  hash4Value = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)); \
-+  hashValue = (hash4Value ^ (p->crc[cur[4]] << 3)) & p->hashMask; \
-+  hash4Value &= (kHash4Size - 1); }
-+
-+/* #define HASH_ZIP_CALC hashValue = ((cur[0] | ((UInt32)cur[1] << 8)) ^ p->crc[cur[2]]) & 0xFFFF; */
-+#define HASH_ZIP_CALC hashValue = ((cur[2] | ((UInt32)cur[0] << 8)) ^ p->crc[cur[1]]) & 0xFFFF;
-+
-+
-+#define MT_HASH2_CALC \
-+  hash2Value = (p->crc[cur[0]] ^ cur[1]) & (kHash2Size - 1);
-+
-+#define MT_HASH3_CALC { \
-+  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
-+  hash2Value = temp & (kHash2Size - 1); \
-+  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); }
-+
-+#define MT_HASH4_CALC { \
-+  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
-+  hash2Value = temp & (kHash2Size - 1); \
-+  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
-+  hash4Value = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)) & (kHash4Size - 1); }
-+
-+#endif
---- /dev/null
-+++ b/include/linux/lzma/LzmaDec.h
-@@ -0,0 +1,231 @@
-+/* LzmaDec.h -- LZMA Decoder
-+2009-02-07 : Igor Pavlov : Public domain */
-+
-+#ifndef __LZMA_DEC_H
-+#define __LZMA_DEC_H
-+
-+#include "Types.h"
-+
-+#ifdef __cplusplus
-+extern "C" {
-+#endif
-+
-+/* #define _LZMA_PROB32 */
-+/* _LZMA_PROB32 can increase the speed on some CPUs,
-+   but memory usage for CLzmaDec::probs will be doubled in that case */
-+
-+#ifdef _LZMA_PROB32
-+#define CLzmaProb UInt32
-+#else
-+#define CLzmaProb UInt16
-+#endif
-+
-+
-+/* ---------- LZMA Properties ---------- */
-+
-+#define LZMA_PROPS_SIZE 5
-+
-+typedef struct _CLzmaProps
-+{
-+  unsigned lc, lp, pb;
-+  UInt32 dicSize;
-+} CLzmaProps;
-+
-+/* LzmaProps_Decode - decodes properties
-+Returns:
-+  SZ_OK
-+  SZ_ERROR_UNSUPPORTED - Unsupported properties
-+*/
-+
-+SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size);
-+
-+
-+/* ---------- LZMA Decoder state ---------- */
-+
-+/* LZMA_REQUIRED_INPUT_MAX = number of required input bytes for worst case.
-+   Num bits = log2((2^11 / 31) ^ 22) + 26 < 134 + 26 = 160; */
-+
-+#define LZMA_REQUIRED_INPUT_MAX 20
-+
-+typedef struct
-+{
-+  CLzmaProps prop;
-+  CLzmaProb *probs;
-+  Byte *dic;
-+  const Byte *buf;
-+  UInt32 range, code;
-+  SizeT dicPos;
-+  SizeT dicBufSize;
-+  UInt32 processedPos;
-+  UInt32 checkDicSize;
-+  unsigned state;
-+  UInt32 reps[4];
-+  unsigned remainLen;
-+  int needFlush;
-+  int needInitState;
-+  UInt32 numProbs;
-+  unsigned tempBufSize;
-+  Byte tempBuf[LZMA_REQUIRED_INPUT_MAX];
-+} CLzmaDec;
-+
-+#define LzmaDec_Construct(p) { (p)->dic = 0; (p)->probs = 0; }
-+
-+void LzmaDec_Init(CLzmaDec *p);
-+
-+/* There are two types of LZMA streams:
-+     0) Stream with end mark. That end mark adds about 6 bytes to compressed size.
-+     1) Stream without end mark. You must know exact uncompressed size to decompress such stream. */
-+
-+typedef enum
-+{
-+  LZMA_FINISH_ANY,   /* finish at any point */
-+  LZMA_FINISH_END    /* block must be finished at the end */
-+} ELzmaFinishMode;
-+
-+/* ELzmaFinishMode has meaning only if the decoding reaches output limit !!!
-+
-+   You must use LZMA_FINISH_END, when you know that current output buffer
-+   covers last bytes of block. In other cases you must use LZMA_FINISH_ANY.
-+
-+   If LZMA decoder sees end marker before reaching output limit, it returns SZ_OK,
-+   and output value of destLen will be less than output buffer size limit.
-+   You can check status result also.
-+
-+   You can use multiple checks to test data integrity after full decompression:
-+     1) Check Result and "status" variable.
-+     2) Check that output(destLen) = uncompressedSize, if you know real uncompressedSize.
-+     3) Check that output(srcLen) = compressedSize, if you know real compressedSize.
-+        You must use correct finish mode in that case. */
-+
-+typedef enum
-+{
-+  LZMA_STATUS_NOT_SPECIFIED,               /* use main error code instead */
-+  LZMA_STATUS_FINISHED_WITH_MARK,          /* stream was finished with end mark. */
-+  LZMA_STATUS_NOT_FINISHED,                /* stream was not finished */
-+  LZMA_STATUS_NEEDS_MORE_INPUT,            /* you must provide more input bytes */
-+  LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK  /* there is probability that stream was finished without end mark */
-+} ELzmaStatus;
-+
-+/* ELzmaStatus is used only as output value for function call */
-+
-+
-+/* ---------- Interfaces ---------- */
-+
-+/* There are 3 levels of interfaces:
-+     1) Dictionary Interface
-+     2) Buffer Interface
-+     3) One Call Interface
-+   You can select any of these interfaces, but don't mix functions from different
-+   groups for same object. */
-+
-+
-+/* There are two variants to allocate state for Dictionary Interface:
-+     1) LzmaDec_Allocate / LzmaDec_Free
-+     2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs
-+   You can use variant 2, if you set dictionary buffer manually.
-+   For Buffer Interface you must always use variant 1.
-+
-+LzmaDec_Allocate* can return:
-+  SZ_OK
-+  SZ_ERROR_MEM         - Memory allocation error
-+  SZ_ERROR_UNSUPPORTED - Unsupported properties
-+*/
-+   
-+SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc);
-+void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc);
-+
-+SRes LzmaDec_Allocate(CLzmaDec *state, const Byte *prop, unsigned propsSize, ISzAlloc *alloc);
-+void LzmaDec_Free(CLzmaDec *state, ISzAlloc *alloc);
-+
-+/* ---------- Dictionary Interface ---------- */
-+
-+/* You can use it, if you want to eliminate the overhead for data copying from
-+   dictionary to some other external buffer.
-+   You must work with CLzmaDec variables directly in this interface.
-+
-+   STEPS:
-+     LzmaDec_Constr()
-+     LzmaDec_Allocate()
-+     for (each new stream)
-+     {
-+       LzmaDec_Init()
-+       while (it needs more decompression)
-+       {
-+         LzmaDec_DecodeToDic()
-+         use data from CLzmaDec::dic and update CLzmaDec::dicPos
-+       }
-+     }
-+     LzmaDec_Free()
-+*/
-+
-+/* LzmaDec_DecodeToDic
-+   
-+   The decoding to internal dictionary buffer (CLzmaDec::dic).
-+   You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!
-+
-+finishMode:
-+  It has meaning only if the decoding reaches output limit (dicLimit).
-+  LZMA_FINISH_ANY - Decode just dicLimit bytes.
-+  LZMA_FINISH_END - Stream must be finished after dicLimit.
-+
-+Returns:
-+  SZ_OK
-+    status:
-+      LZMA_STATUS_FINISHED_WITH_MARK
-+      LZMA_STATUS_NOT_FINISHED
-+      LZMA_STATUS_NEEDS_MORE_INPUT
-+      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
-+  SZ_ERROR_DATA - Data error
-+*/
-+
-+SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit,
-+    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
-+
-+
-+/* ---------- Buffer Interface ---------- */
-+
-+/* It's zlib-like interface.
-+   See LzmaDec_DecodeToDic description for information about STEPS and return results,
-+   but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need
-+   to work with CLzmaDec variables manually.
-+
-+finishMode:
-+  It has meaning only if the decoding reaches output limit (*destLen).
-+  LZMA_FINISH_ANY - Decode just destLen bytes.
-+  LZMA_FINISH_END - Stream must be finished after (*destLen).
-+*/
-+
-+SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen,
-+    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
-+
-+
-+/* ---------- One Call Interface ---------- */
-+
-+/* LzmaDecode
-+
-+finishMode:
-+  It has meaning only if the decoding reaches output limit (*destLen).
-+  LZMA_FINISH_ANY - Decode just destLen bytes.
-+  LZMA_FINISH_END - Stream must be finished after (*destLen).
-+
-+Returns:
-+  SZ_OK
-+    status:
-+      LZMA_STATUS_FINISHED_WITH_MARK
-+      LZMA_STATUS_NOT_FINISHED
-+      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
-+  SZ_ERROR_DATA - Data error
-+  SZ_ERROR_MEM  - Memory allocation error
-+  SZ_ERROR_UNSUPPORTED - Unsupported properties
-+  SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
-+*/
-+
-+SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
-+    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
-+    ELzmaStatus *status, ISzAlloc *alloc);
-+
-+#ifdef __cplusplus
-+}
-+#endif
-+
-+#endif
---- /dev/null
-+++ b/include/linux/lzma/LzmaEnc.h
-@@ -0,0 +1,80 @@
-+/*  LzmaEnc.h -- LZMA Encoder
-+2009-02-07 : Igor Pavlov : Public domain */
-+
-+#ifndef __LZMA_ENC_H
-+#define __LZMA_ENC_H
-+
-+#include "Types.h"
-+
-+#ifdef __cplusplus
-+extern "C" {
-+#endif
-+
-+#define LZMA_PROPS_SIZE 5
-+
-+typedef struct _CLzmaEncProps
-+{
-+  int level;       /*  0 <= level <= 9 */
-+  UInt32 dictSize; /* (1 << 12) <= dictSize <= (1 << 27) for 32-bit version
-+                      (1 << 12) <= dictSize <= (1 << 30) for 64-bit version
-+                       default = (1 << 24) */
-+  int lc;          /* 0 <= lc <= 8, default = 3 */
-+  int lp;          /* 0 <= lp <= 4, default = 0 */
-+  int pb;          /* 0 <= pb <= 4, default = 2 */
-+  int algo;        /* 0 - fast, 1 - normal, default = 1 */
-+  int fb;          /* 5 <= fb <= 273, default = 32 */
-+  int btMode;      /* 0 - hashChain Mode, 1 - binTree mode - normal, default = 1 */
-+  int numHashBytes; /* 2, 3 or 4, default = 4 */
-+  UInt32 mc;        /* 1 <= mc <= (1 << 30), default = 32 */
-+  unsigned writeEndMark;  /* 0 - do not write EOPM, 1 - write EOPM, default = 0 */
-+  int numThreads;  /* 1 or 2, default = 2 */
-+} CLzmaEncProps;
-+
-+void LzmaEncProps_Init(CLzmaEncProps *p);
-+void LzmaEncProps_Normalize(CLzmaEncProps *p);
-+UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2);
-+
-+
-+/* ---------- CLzmaEncHandle Interface ---------- */
-+
-+/* LzmaEnc_* functions can return the following exit codes:
-+Returns:
-+  SZ_OK           - OK
-+  SZ_ERROR_MEM    - Memory allocation error
-+  SZ_ERROR_PARAM  - Incorrect paramater in props
-+  SZ_ERROR_WRITE  - Write callback error.
-+  SZ_ERROR_PROGRESS - some break from progress callback
-+  SZ_ERROR_THREAD - errors in multithreading functions (only for Mt version)
-+*/
-+
-+typedef void * CLzmaEncHandle;
-+
-+CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc);
-+void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig);
-+SRes LzmaEnc_SetProps(CLzmaEncHandle p, const CLzmaEncProps *props);
-+SRes LzmaEnc_WriteProperties(CLzmaEncHandle p, Byte *properties, SizeT *size);
-+SRes LzmaEnc_Encode(CLzmaEncHandle p, ISeqOutStream *outStream, ISeqInStream *inStream,
-+    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
-+SRes LzmaEnc_MemEncode(CLzmaEncHandle p, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-+    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
-+
-+/* ---------- One Call Interface ---------- */
-+
-+/* LzmaEncode
-+Return code:
-+  SZ_OK               - OK
-+  SZ_ERROR_MEM        - Memory allocation error
-+  SZ_ERROR_PARAM      - Incorrect paramater
-+  SZ_ERROR_OUTPUT_EOF - output buffer overflow
-+  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
-+*/
-+
-+SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-+    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
-+    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
-+
-+#ifdef __cplusplus
-+}
-+#endif
-+
-+#endif
---- /dev/null
-+++ b/include/linux/lzma/Types.h
-@@ -0,0 +1,226 @@
-+/* Types.h -- Basic types
-+2009-11-23 : Igor Pavlov : Public domain */
-+
-+#ifndef __7Z_TYPES_H
-+#define __7Z_TYPES_H
-+
-+#include <stddef.h>
-+
-+#ifdef _WIN32
-+#include <windows.h>
-+#endif
-+
-+#ifndef EXTERN_C_BEGIN
-+#ifdef __cplusplus
-+#define EXTERN_C_BEGIN extern "C" {
-+#define EXTERN_C_END }
-+#else
-+#define EXTERN_C_BEGIN
-+#define EXTERN_C_END
-+#endif
-+#endif
-+
-+EXTERN_C_BEGIN
-+
-+#define SZ_OK 0
-+
-+#define SZ_ERROR_DATA 1
-+#define SZ_ERROR_MEM 2
-+#define SZ_ERROR_CRC 3
-+#define SZ_ERROR_UNSUPPORTED 4
-+#define SZ_ERROR_PARAM 5
-+#define SZ_ERROR_INPUT_EOF 6
-+#define SZ_ERROR_OUTPUT_EOF 7
-+#define SZ_ERROR_READ 8
-+#define SZ_ERROR_WRITE 9
-+#define SZ_ERROR_PROGRESS 10
-+#define SZ_ERROR_FAIL 11
-+#define SZ_ERROR_THREAD 12
-+
-+#define SZ_ERROR_ARCHIVE 16
-+#define SZ_ERROR_NO_ARCHIVE 17
-+
-+typedef int SRes;
-+
-+#ifdef _WIN32
-+typedef DWORD WRes;
-+#else
-+typedef int WRes;
-+#endif
-+
-+#ifndef RINOK
-+#define RINOK(x) { int __result__ = (x); if (__result__ != 0) return __result__; }
-+#endif
-+
-+typedef unsigned char Byte;
-+typedef short Int16;
-+typedef unsigned short UInt16;
-+
-+#ifdef _LZMA_UINT32_IS_ULONG
-+typedef long Int32;
-+typedef unsigned long UInt32;
-+#else
-+typedef int Int32;
-+typedef unsigned int UInt32;
-+#endif
-+
-+#ifdef _SZ_NO_INT_64
-+
-+/* define _SZ_NO_INT_64, if your compiler doesn't support 64-bit integers.
-+   NOTES: Some code will work incorrectly in that case! */
-+
-+typedef long Int64;
-+typedef unsigned long UInt64;
-+
-+#else
-+
-+#if defined(_MSC_VER) || defined(__BORLANDC__)
-+typedef __int64 Int64;
-+typedef unsigned __int64 UInt64;
-+#else
-+typedef long long int Int64;
-+typedef unsigned long long int UInt64;
-+#endif
-+
-+#endif
-+
-+#ifdef _LZMA_NO_SYSTEM_SIZE_T
-+typedef UInt32 SizeT;
-+#else
-+typedef size_t SizeT;
-+#endif
-+
-+typedef int Bool;
-+#define True 1
-+#define False 0
-+
-+
-+#ifdef _WIN32
-+#define MY_STD_CALL __stdcall
-+#else
-+#define MY_STD_CALL
-+#endif
-+
-+#ifdef _MSC_VER
-+
-+#if _MSC_VER >= 1300
-+#define MY_NO_INLINE __declspec(noinline)
-+#else
-+#define MY_NO_INLINE
-+#endif
-+
-+#define MY_CDECL __cdecl
-+#define MY_FAST_CALL __fastcall
-+
-+#else
-+
-+#define MY_CDECL
-+#define MY_FAST_CALL
-+
-+#endif
-+
-+
-+/* The following interfaces use first parameter as pointer to structure */
-+
-+typedef struct
-+{
-+  SRes (*Read)(void *p, void *buf, size_t *size);
-+    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
-+       (output(*size) < input(*size)) is allowed */
-+} ISeqInStream;
-+
-+/* it can return SZ_ERROR_INPUT_EOF */
-+SRes SeqInStream_Read(ISeqInStream *stream, void *buf, size_t size);
-+SRes SeqInStream_Read2(ISeqInStream *stream, void *buf, size_t size, SRes errorType);
-+SRes SeqInStream_ReadByte(ISeqInStream *stream, Byte *buf);
-+
-+typedef struct
-+{
-+  size_t (*Write)(void *p, const void *buf, size_t size);
-+    /* Returns: result - the number of actually written bytes.
-+       (result < size) means error */
-+} ISeqOutStream;
-+
-+typedef enum
-+{
-+  SZ_SEEK_SET = 0,
-+  SZ_SEEK_CUR = 1,
-+  SZ_SEEK_END = 2
-+} ESzSeek;
-+
-+typedef struct
-+{
-+  SRes (*Read)(void *p, void *buf, size_t *size);  /* same as ISeqInStream::Read */
-+  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
-+} ISeekInStream;
-+
-+typedef struct
-+{
-+  SRes (*Look)(void *p, void **buf, size_t *size);
-+    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
-+       (output(*size) > input(*size)) is not allowed
-+       (output(*size) < input(*size)) is allowed */
-+  SRes (*Skip)(void *p, size_t offset);
-+    /* offset must be <= output(*size) of Look */
-+
-+  SRes (*Read)(void *p, void *buf, size_t *size);
-+    /* reads directly (without buffer). It's same as ISeqInStream::Read */
-+  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
-+} ILookInStream;
-+
-+SRes LookInStream_LookRead(ILookInStream *stream, void *buf, size_t *size);
-+SRes LookInStream_SeekTo(ILookInStream *stream, UInt64 offset);
-+
-+/* reads via ILookInStream::Read */
-+SRes LookInStream_Read2(ILookInStream *stream, void *buf, size_t size, SRes errorType);
-+SRes LookInStream_Read(ILookInStream *stream, void *buf, size_t size);
-+
-+#define LookToRead_BUF_SIZE (1 << 14)
-+
-+typedef struct
-+{
-+  ILookInStream s;
-+  ISeekInStream *realStream;
-+  size_t pos;
-+  size_t size;
-+  Byte buf[LookToRead_BUF_SIZE];
-+} CLookToRead;
-+
-+void LookToRead_CreateVTable(CLookToRead *p, int lookahead);
-+void LookToRead_Init(CLookToRead *p);
-+
-+typedef struct
-+{
-+  ISeqInStream s;
-+  ILookInStream *realStream;
-+} CSecToLook;
-+
-+void SecToLook_CreateVTable(CSecToLook *p);
-+
-+typedef struct
-+{
-+  ISeqInStream s;
-+  ILookInStream *realStream;
-+} CSecToRead;
-+
-+void SecToRead_CreateVTable(CSecToRead *p);
-+
-+typedef struct
-+{
-+  SRes (*Progress)(void *p, UInt64 inSize, UInt64 outSize);
-+    /* Returns: result. (result != SZ_OK) means break.
-+       Value (UInt64)(Int64)-1 for size means unknown value. */
-+} ICompressProgress;
-+
-+typedef struct
-+{
-+  void *(*Alloc)(void *p, size_t size);
-+  void (*Free)(void *p, void *address); /* address can be 0 */
-+} ISzAlloc;
-+
-+#define IAlloc_Alloc(p, size) (p)->Alloc((p), size)
-+#define IAlloc_Free(p, a) (p)->Free((p), a)
-+
-+EXTERN_C_END
-+
-+#endif
---- a/include/uapi/linux/jffs2.h
-+++ b/include/uapi/linux/jffs2.h
-@@ -46,6 +46,7 @@
- #define JFFS2_COMPR_DYNRUBIN	0x05
- #define JFFS2_COMPR_ZLIB	0x06
- #define JFFS2_COMPR_LZO		0x07
-+#define JFFS2_COMPR_LZMA	0x08
- /* Compatibility flags. */
- #define JFFS2_COMPAT_MASK 0xc000      /* What do to if an unknown nodetype is found */
- #define JFFS2_NODE_ACCURATE 0x2000
---- a/lib/Kconfig
-+++ b/lib/Kconfig
-@@ -278,6 +278,12 @@ config ZSTD_DECOMPRESS
- 
- source "lib/xz/Kconfig"
- 
-+config LZMA_COMPRESS
-+    tristate
-+
-+config LZMA_DECOMPRESS
-+    tristate
-+
- #
- # These all provide a common interface (hence the apparent duplication with
- # ZLIB_INFLATE; DECOMPRESS_GZIP is just a wrapper.)
---- a/lib/Makefile
-+++ b/lib/Makefile
-@@ -3,6 +3,16 @@
- # Makefile for some libs needed in the kernel.
- #
- 
-+ifdef CONFIG_JFFS2_ZLIB
-+	CONFIG_ZLIB_INFLATE:=y
-+	CONFIG_ZLIB_DEFLATE:=y
-+endif
-+
-+ifdef CONFIG_JFFS2_LZMA
-+	CONFIG_LZMA_DECOMPRESS:=y
-+	CONFIG_LZMA_COMPRESS:=y
-+endif
-+
- ifdef CONFIG_FUNCTION_TRACER
- ORIG_CFLAGS := $(KBUILD_CFLAGS)
- KBUILD_CFLAGS = $(subst $(CC_FLAGS_FTRACE),,$(ORIG_CFLAGS))
-@@ -139,6 +149,8 @@ obj-$(CONFIG_ZSTD_COMPRESS) += zstd/
- obj-$(CONFIG_ZSTD_DECOMPRESS) += zstd/
- obj-$(CONFIG_XZ_DEC) += xz/
- obj-$(CONFIG_RAID6_PQ) += raid6/
-+obj-$(CONFIG_LZMA_COMPRESS) += lzma/
-+obj-$(CONFIG_LZMA_DECOMPRESS) += lzma/
- 
- lib-$(CONFIG_DECOMPRESS_GZIP) += decompress_inflate.o
- lib-$(CONFIG_DECOMPRESS_BZIP2) += decompress_bunzip2.o
---- /dev/null
-+++ b/lib/lzma/LzFind.c
-@@ -0,0 +1,761 @@
-+/* LzFind.c -- Match finder for LZ algorithms
-+2009-04-22 : Igor Pavlov : Public domain */
-+
-+#include <string.h>
-+
-+#include "LzFind.h"
-+#include "LzHash.h"
-+
-+#define kEmptyHashValue 0
-+#define kMaxValForNormalize ((UInt32)0xFFFFFFFF)
-+#define kNormalizeStepMin (1 << 10) /* it must be power of 2 */
-+#define kNormalizeMask (~(kNormalizeStepMin - 1))
-+#define kMaxHistorySize ((UInt32)3 << 30)
-+
-+#define kStartMaxLen 3
-+
-+static void LzInWindow_Free(CMatchFinder *p, ISzAlloc *alloc)
-+{
-+  if (!p->directInput)
-+  {
-+    alloc->Free(alloc, p->bufferBase);
-+    p->bufferBase = 0;
-+  }
-+}
-+
-+/* keepSizeBefore + keepSizeAfter + keepSizeReserv must be < 4G) */
-+
-+static int LzInWindow_Create(CMatchFinder *p, UInt32 keepSizeReserv, ISzAlloc *alloc)
-+{
-+  UInt32 blockSize = p->keepSizeBefore + p->keepSizeAfter + keepSizeReserv;
-+  if (p->directInput)
-+  {
-+    p->blockSize = blockSize;
-+    return 1;
-+  }
-+  if (p->bufferBase == 0 || p->blockSize != blockSize)
-+  {
-+    LzInWindow_Free(p, alloc);
-+    p->blockSize = blockSize;
-+    p->bufferBase = (Byte *)alloc->Alloc(alloc, (size_t)blockSize);
-+  }
-+  return (p->bufferBase != 0);
-+}
-+
-+Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }
-+Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p->buffer[index]; }
-+
-+UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }
-+
-+void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
-+{
-+  p->posLimit -= subValue;
-+  p->pos -= subValue;
-+  p->streamPos -= subValue;
-+}
-+
-+static void MatchFinder_ReadBlock(CMatchFinder *p)
-+{
-+  if (p->streamEndWasReached || p->result != SZ_OK)
-+    return;
-+  if (p->directInput)
-+  {
-+    UInt32 curSize = 0xFFFFFFFF - p->streamPos;
-+    if (curSize > p->directInputRem)
-+      curSize = (UInt32)p->directInputRem;
-+    p->directInputRem -= curSize;
-+    p->streamPos += curSize;
-+    if (p->directInputRem == 0)
-+      p->streamEndWasReached = 1;
-+    return;
-+  }
-+  for (;;)
-+  {
-+    Byte *dest = p->buffer + (p->streamPos - p->pos);
-+    size_t size = (p->bufferBase + p->blockSize - dest);
-+    if (size == 0)
-+      return;
-+    p->result = p->stream->Read(p->stream, dest, &size);
-+    if (p->result != SZ_OK)
-+      return;
-+    if (size == 0)
-+    {
-+      p->streamEndWasReached = 1;
-+      return;
-+    }
-+    p->streamPos += (UInt32)size;
-+    if (p->streamPos - p->pos > p->keepSizeAfter)
-+      return;
-+  }
-+}
-+
-+void MatchFinder_MoveBlock(CMatchFinder *p)
-+{
-+  memmove(p->bufferBase,
-+    p->buffer - p->keepSizeBefore,
-+    (size_t)(p->streamPos - p->pos + p->keepSizeBefore));
-+  p->buffer = p->bufferBase + p->keepSizeBefore;
-+}
-+
-+int MatchFinder_NeedMove(CMatchFinder *p)
-+{
-+  if (p->directInput)
-+    return 0;
-+  /* if (p->streamEndWasReached) return 0; */
-+  return ((size_t)(p->bufferBase + p->blockSize - p->buffer) <= p->keepSizeAfter);
-+}
-+
-+void MatchFinder_ReadIfRequired(CMatchFinder *p)
-+{
-+  if (p->streamEndWasReached)
-+    return;
-+  if (p->keepSizeAfter >= p->streamPos - p->pos)
-+    MatchFinder_ReadBlock(p);
-+}
-+
-+static void MatchFinder_CheckAndMoveAndRead(CMatchFinder *p)
-+{
-+  if (MatchFinder_NeedMove(p))
-+    MatchFinder_MoveBlock(p);
-+  MatchFinder_ReadBlock(p);
-+}
-+
-+static void MatchFinder_SetDefaultSettings(CMatchFinder *p)
-+{
-+  p->cutValue = 32;
-+  p->btMode = 1;
-+  p->numHashBytes = 4;
-+  p->bigHash = 0;
-+}
-+
-+#define kCrcPoly 0xEDB88320
-+
-+void MatchFinder_Construct(CMatchFinder *p)
-+{
-+  UInt32 i;
-+  p->bufferBase = 0;
-+  p->directInput = 0;
-+  p->hash = 0;
-+  MatchFinder_SetDefaultSettings(p);
-+
-+  for (i = 0; i < 256; i++)
-+  {
-+    UInt32 r = i;
-+    int j;
-+    for (j = 0; j < 8; j++)
-+      r = (r >> 1) ^ (kCrcPoly & ~((r & 1) - 1));
-+    p->crc[i] = r;
-+  }
-+}
-+
-+static void MatchFinder_FreeThisClassMemory(CMatchFinder *p, ISzAlloc *alloc)
-+{
-+  alloc->Free(alloc, p->hash);
-+  p->hash = 0;
-+}
-+
-+void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc)
-+{
-+  MatchFinder_FreeThisClassMemory(p, alloc);
-+  LzInWindow_Free(p, alloc);
-+}
-+
-+static CLzRef* AllocRefs(UInt32 num, ISzAlloc *alloc)
-+{
-+  size_t sizeInBytes = (size_t)num * sizeof(CLzRef);
-+  if (sizeInBytes / sizeof(CLzRef) != num)
-+    return 0;
-+  return (CLzRef *)alloc->Alloc(alloc, sizeInBytes);
-+}
-+
-+int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
-+    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
-+    ISzAlloc *alloc)
-+{
-+  UInt32 sizeReserv;
-+  if (historySize > kMaxHistorySize)
-+  {
-+    MatchFinder_Free(p, alloc);
-+    return 0;
-+  }
-+  sizeReserv = historySize >> 1;
-+  if (historySize > ((UInt32)2 << 30))
-+    sizeReserv = historySize >> 2;
-+  sizeReserv += (keepAddBufferBefore + matchMaxLen + keepAddBufferAfter) / 2 + (1 << 19);
-+
-+  p->keepSizeBefore = historySize + keepAddBufferBefore + 1;
-+  p->keepSizeAfter = matchMaxLen + keepAddBufferAfter;
-+  /* we need one additional byte, since we use MoveBlock after pos++ and before dictionary using */
-+  if (LzInWindow_Create(p, sizeReserv, alloc))
-+  {
-+    UInt32 newCyclicBufferSize = historySize + 1;
-+    UInt32 hs;
-+    p->matchMaxLen = matchMaxLen;
-+    {
-+      p->fixedHashSize = 0;
-+      if (p->numHashBytes == 2)
-+        hs = (1 << 16) - 1;
-+      else
-+      {
-+        hs = historySize - 1;
-+        hs |= (hs >> 1);
-+        hs |= (hs >> 2);
-+        hs |= (hs >> 4);
-+        hs |= (hs >> 8);
-+        hs >>= 1;
-+        hs |= 0xFFFF; /* don't change it! It's required for Deflate */
-+        if (hs > (1 << 24))
-+        {
-+          if (p->numHashBytes == 3)
-+            hs = (1 << 24) - 1;
-+          else
-+            hs >>= 1;
-+        }
-+      }
-+      p->hashMask = hs;
-+      hs++;
-+      if (p->numHashBytes > 2) p->fixedHashSize += kHash2Size;
-+      if (p->numHashBytes > 3) p->fixedHashSize += kHash3Size;
-+      if (p->numHashBytes > 4) p->fixedHashSize += kHash4Size;
-+      hs += p->fixedHashSize;
-+    }
-+
-+    {
-+      UInt32 prevSize = p->hashSizeSum + p->numSons;
-+      UInt32 newSize;
-+      p->historySize = historySize;
-+      p->hashSizeSum = hs;
-+      p->cyclicBufferSize = newCyclicBufferSize;
-+      p->numSons = (p->btMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);
-+      newSize = p->hashSizeSum + p->numSons;
-+      if (p->hash != 0 && prevSize == newSize)
-+        return 1;
-+      MatchFinder_FreeThisClassMemory(p, alloc);
-+      p->hash = AllocRefs(newSize, alloc);
-+      if (p->hash != 0)
-+      {
-+        p->son = p->hash + p->hashSizeSum;
-+        return 1;
-+      }
-+    }
-+  }
-+  MatchFinder_Free(p, alloc);
-+  return 0;
-+}
-+
-+static void MatchFinder_SetLimits(CMatchFinder *p)
-+{
-+  UInt32 limit = kMaxValForNormalize - p->pos;
-+  UInt32 limit2 = p->cyclicBufferSize - p->cyclicBufferPos;
-+  if (limit2 < limit)
-+    limit = limit2;
-+  limit2 = p->streamPos - p->pos;
-+  if (limit2 <= p->keepSizeAfter)
-+  {
-+    if (limit2 > 0)
-+      limit2 = 1;
-+  }
-+  else
-+    limit2 -= p->keepSizeAfter;
-+  if (limit2 < limit)
-+    limit = limit2;
-+  {
-+    UInt32 lenLimit = p->streamPos - p->pos;
-+    if (lenLimit > p->matchMaxLen)
-+      lenLimit = p->matchMaxLen;
-+    p->lenLimit = lenLimit;
-+  }
-+  p->posLimit = p->pos + limit;
-+}
-+
-+void MatchFinder_Init(CMatchFinder *p)
-+{
-+  UInt32 i;
-+  for (i = 0; i < p->hashSizeSum; i++)
-+    p->hash[i] = kEmptyHashValue;
-+  p->cyclicBufferPos = 0;
-+  p->buffer = p->bufferBase;
-+  p->pos = p->streamPos = p->cyclicBufferSize;
-+  p->result = SZ_OK;
-+  p->streamEndWasReached = 0;
-+  MatchFinder_ReadBlock(p);
-+  MatchFinder_SetLimits(p);
-+}
-+
-+static UInt32 MatchFinder_GetSubValue(CMatchFinder *p)
-+{
-+  return (p->pos - p->historySize - 1) & kNormalizeMask;
-+}
-+
-+void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems)
-+{
-+  UInt32 i;
-+  for (i = 0; i < numItems; i++)
-+  {
-+    UInt32 value = items[i];
-+    if (value <= subValue)
-+      value = kEmptyHashValue;
-+    else
-+      value -= subValue;
-+    items[i] = value;
-+  }
-+}
-+
-+static void MatchFinder_Normalize(CMatchFinder *p)
-+{
-+  UInt32 subValue = MatchFinder_GetSubValue(p);
-+  MatchFinder_Normalize3(subValue, p->hash, p->hashSizeSum + p->numSons);
-+  MatchFinder_ReduceOffsets(p, subValue);
-+}
-+
-+static void MatchFinder_CheckLimits(CMatchFinder *p)
-+{
-+  if (p->pos == kMaxValForNormalize)
-+    MatchFinder_Normalize(p);
-+  if (!p->streamEndWasReached && p->keepSizeAfter == p->streamPos - p->pos)
-+    MatchFinder_CheckAndMoveAndRead(p);
-+  if (p->cyclicBufferPos == p->cyclicBufferSize)
-+    p->cyclicBufferPos = 0;
-+  MatchFinder_SetLimits(p);
-+}
-+
-+static UInt32 * Hc_GetMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
-+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
-+    UInt32 *distances, UInt32 maxLen)
-+{
-+  son[_cyclicBufferPos] = curMatch;
-+  for (;;)
-+  {
-+    UInt32 delta = pos - curMatch;
-+    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
-+      return distances;
-+    {
-+      const Byte *pb = cur - delta;
-+      curMatch = son[_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)];
-+      if (pb[maxLen] == cur[maxLen] && *pb == *cur)
-+      {
-+        UInt32 len = 0;
-+        while (++len != lenLimit)
-+          if (pb[len] != cur[len])
-+            break;
-+        if (maxLen < len)
-+        {
-+          *distances++ = maxLen = len;
-+          *distances++ = delta - 1;
-+          if (len == lenLimit)
-+            return distances;
-+        }
-+      }
-+    }
-+  }
-+}
-+
-+UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
-+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
-+    UInt32 *distances, UInt32 maxLen)
-+{
-+  CLzRef *ptr0 = son + (_cyclicBufferPos << 1) + 1;
-+  CLzRef *ptr1 = son + (_cyclicBufferPos << 1);
-+  UInt32 len0 = 0, len1 = 0;
-+  for (;;)
-+  {
-+    UInt32 delta = pos - curMatch;
-+    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
-+    {
-+      *ptr0 = *ptr1 = kEmptyHashValue;
-+      return distances;
-+    }
-+    {
-+      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
-+      const Byte *pb = cur - delta;
-+      UInt32 len = (len0 < len1 ? len0 : len1);
-+      if (pb[len] == cur[len])
-+      {
-+        if (++len != lenLimit && pb[len] == cur[len])
-+          while (++len != lenLimit)
-+            if (pb[len] != cur[len])
-+              break;
-+        if (maxLen < len)
-+        {
-+          *distances++ = maxLen = len;
-+          *distances++ = delta - 1;
-+          if (len == lenLimit)
-+          {
-+            *ptr1 = pair[0];
-+            *ptr0 = pair[1];
-+            return distances;
-+          }
-+        }
-+      }
-+      if (pb[len] < cur[len])
-+      {
-+        *ptr1 = curMatch;
-+        ptr1 = pair + 1;
-+        curMatch = *ptr1;
-+        len1 = len;
-+      }
-+      else
-+      {
-+        *ptr0 = curMatch;
-+        ptr0 = pair;
-+        curMatch = *ptr0;
-+        len0 = len;
-+      }
-+    }
-+  }
-+}
-+
-+static void SkipMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
-+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue)
-+{
-+  CLzRef *ptr0 = son + (_cyclicBufferPos << 1) + 1;
-+  CLzRef *ptr1 = son + (_cyclicBufferPos << 1);
-+  UInt32 len0 = 0, len1 = 0;
-+  for (;;)
-+  {
-+    UInt32 delta = pos - curMatch;
-+    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
-+    {
-+      *ptr0 = *ptr1 = kEmptyHashValue;
-+      return;
-+    }
-+    {
-+      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
-+      const Byte *pb = cur - delta;
-+      UInt32 len = (len0 < len1 ? len0 : len1);
-+      if (pb[len] == cur[len])
-+      {
-+        while (++len != lenLimit)
-+          if (pb[len] != cur[len])
-+            break;
-+        {
-+          if (len == lenLimit)
-+          {
-+            *ptr1 = pair[0];
-+            *ptr0 = pair[1];
-+            return;
-+          }
-+        }
-+      }
-+      if (pb[len] < cur[len])
-+      {
-+        *ptr1 = curMatch;
-+        ptr1 = pair + 1;
-+        curMatch = *ptr1;
-+        len1 = len;
-+      }
-+      else
-+      {
-+        *ptr0 = curMatch;
-+        ptr0 = pair;
-+        curMatch = *ptr0;
-+        len0 = len;
-+      }
-+    }
-+  }
-+}
-+
-+#define MOVE_POS \
-+  ++p->cyclicBufferPos; \
-+  p->buffer++; \
-+  if (++p->pos == p->posLimit) MatchFinder_CheckLimits(p);
-+
-+#define MOVE_POS_RET MOVE_POS return offset;
-+
-+static void MatchFinder_MovePos(CMatchFinder *p) { MOVE_POS; }
-+
-+#define GET_MATCHES_HEADER2(minLen, ret_op) \
-+  UInt32 lenLimit; UInt32 hashValue; const Byte *cur; UInt32 curMatch; \
-+  lenLimit = p->lenLimit; { if (lenLimit < minLen) { MatchFinder_MovePos(p); ret_op; }} \
-+  cur = p->buffer;
-+
-+#define GET_MATCHES_HEADER(minLen) GET_MATCHES_HEADER2(minLen, return 0)
-+#define SKIP_HEADER(minLen)        GET_MATCHES_HEADER2(minLen, continue)
-+
-+#define MF_PARAMS(p) p->pos, p->buffer, p->son, p->cyclicBufferPos, p->cyclicBufferSize, p->cutValue
-+
-+#define GET_MATCHES_FOOTER(offset, maxLen) \
-+  offset = (UInt32)(GetMatchesSpec1(lenLimit, curMatch, MF_PARAMS(p), \
-+  distances + offset, maxLen) - distances); MOVE_POS_RET;
-+
-+#define SKIP_FOOTER \
-+  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MOVE_POS;
-+
-+static UInt32 Bt2_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-+{
-+  UInt32 offset;
-+  GET_MATCHES_HEADER(2)
-+  HASH2_CALC;
-+  curMatch = p->hash[hashValue];
-+  p->hash[hashValue] = p->pos;
-+  offset = 0;
-+  GET_MATCHES_FOOTER(offset, 1)
-+}
-+
-+UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-+{
-+  UInt32 offset;
-+  GET_MATCHES_HEADER(3)
-+  HASH_ZIP_CALC;
-+  curMatch = p->hash[hashValue];
-+  p->hash[hashValue] = p->pos;
-+  offset = 0;
-+  GET_MATCHES_FOOTER(offset, 2)
-+}
-+
-+static UInt32 Bt3_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-+{
-+  UInt32 hash2Value, delta2, maxLen, offset;
-+  GET_MATCHES_HEADER(3)
-+
-+  HASH3_CALC;
-+
-+  delta2 = p->pos - p->hash[hash2Value];
-+  curMatch = p->hash[kFix3HashSize + hashValue];
-+  
-+  p->hash[hash2Value] =
-+  p->hash[kFix3HashSize + hashValue] = p->pos;
-+
-+
-+  maxLen = 2;
-+  offset = 0;
-+  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
-+  {
-+    for (; maxLen != lenLimit; maxLen++)
-+      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
-+        break;
-+    distances[0] = maxLen;
-+    distances[1] = delta2 - 1;
-+    offset = 2;
-+    if (maxLen == lenLimit)
-+    {
-+      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
-+      MOVE_POS_RET;
-+    }
-+  }
-+  GET_MATCHES_FOOTER(offset, maxLen)
-+}
-+
-+static UInt32 Bt4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-+{
-+  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
-+  GET_MATCHES_HEADER(4)
-+
-+  HASH4_CALC;
-+
-+  delta2 = p->pos - p->hash[                hash2Value];
-+  delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
-+  curMatch = p->hash[kFix4HashSize + hashValue];
-+  
-+  p->hash[                hash2Value] =
-+  p->hash[kFix3HashSize + hash3Value] =
-+  p->hash[kFix4HashSize + hashValue] = p->pos;
-+
-+  maxLen = 1;
-+  offset = 0;
-+  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
-+  {
-+    distances[0] = maxLen = 2;
-+    distances[1] = delta2 - 1;
-+    offset = 2;
-+  }
-+  if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
-+  {
-+    maxLen = 3;
-+    distances[offset + 1] = delta3 - 1;
-+    offset += 2;
-+    delta2 = delta3;
-+  }
-+  if (offset != 0)
-+  {
-+    for (; maxLen != lenLimit; maxLen++)
-+      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
-+        break;
-+    distances[offset - 2] = maxLen;
-+    if (maxLen == lenLimit)
-+    {
-+      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
-+      MOVE_POS_RET;
-+    }
-+  }
-+  if (maxLen < 3)
-+    maxLen = 3;
-+  GET_MATCHES_FOOTER(offset, maxLen)
-+}
-+
-+static UInt32 Hc4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-+{
-+  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
-+  GET_MATCHES_HEADER(4)
-+
-+  HASH4_CALC;
-+
-+  delta2 = p->pos - p->hash[                hash2Value];
-+  delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
-+  curMatch = p->hash[kFix4HashSize + hashValue];
-+
-+  p->hash[                hash2Value] =
-+  p->hash[kFix3HashSize + hash3Value] =
-+  p->hash[kFix4HashSize + hashValue] = p->pos;
-+
-+  maxLen = 1;
-+  offset = 0;
-+  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
-+  {
-+    distances[0] = maxLen = 2;
-+    distances[1] = delta2 - 1;
-+    offset = 2;
-+  }
-+  if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
-+  {
-+    maxLen = 3;
-+    distances[offset + 1] = delta3 - 1;
-+    offset += 2;
-+    delta2 = delta3;
-+  }
-+  if (offset != 0)
-+  {
-+    for (; maxLen != lenLimit; maxLen++)
-+      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
-+        break;
-+    distances[offset - 2] = maxLen;
-+    if (maxLen == lenLimit)
-+    {
-+      p->son[p->cyclicBufferPos] = curMatch;
-+      MOVE_POS_RET;
-+    }
-+  }
-+  if (maxLen < 3)
-+    maxLen = 3;
-+  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
-+    distances + offset, maxLen) - (distances));
-+  MOVE_POS_RET
-+}
-+
-+UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-+{
-+  UInt32 offset;
-+  GET_MATCHES_HEADER(3)
-+  HASH_ZIP_CALC;
-+  curMatch = p->hash[hashValue];
-+  p->hash[hashValue] = p->pos;
-+  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
-+    distances, 2) - (distances));
-+  MOVE_POS_RET
-+}
-+
-+static void Bt2_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-+{
-+  do
-+  {
-+    SKIP_HEADER(2)
-+    HASH2_CALC;
-+    curMatch = p->hash[hashValue];
-+    p->hash[hashValue] = p->pos;
-+    SKIP_FOOTER
-+  }
-+  while (--num != 0);
-+}
-+
-+void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-+{
-+  do
-+  {
-+    SKIP_HEADER(3)
-+    HASH_ZIP_CALC;
-+    curMatch = p->hash[hashValue];
-+    p->hash[hashValue] = p->pos;
-+    SKIP_FOOTER
-+  }
-+  while (--num != 0);
-+}
-+
-+static void Bt3_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-+{
-+  do
-+  {
-+    UInt32 hash2Value;
-+    SKIP_HEADER(3)
-+    HASH3_CALC;
-+    curMatch = p->hash[kFix3HashSize + hashValue];
-+    p->hash[hash2Value] =
-+    p->hash[kFix3HashSize + hashValue] = p->pos;
-+    SKIP_FOOTER
-+  }
-+  while (--num != 0);
-+}
-+
-+static void Bt4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-+{
-+  do
-+  {
-+    UInt32 hash2Value, hash3Value;
-+    SKIP_HEADER(4)
-+    HASH4_CALC;
-+    curMatch = p->hash[kFix4HashSize + hashValue];
-+    p->hash[                hash2Value] =
-+    p->hash[kFix3HashSize + hash3Value] = p->pos;
-+    p->hash[kFix4HashSize + hashValue] = p->pos;
-+    SKIP_FOOTER
-+  }
-+  while (--num != 0);
-+}
-+
-+static void Hc4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-+{
-+  do
-+  {
-+    UInt32 hash2Value, hash3Value;
-+    SKIP_HEADER(4)
-+    HASH4_CALC;
-+    curMatch = p->hash[kFix4HashSize + hashValue];
-+    p->hash[                hash2Value] =
-+    p->hash[kFix3HashSize + hash3Value] =
-+    p->hash[kFix4HashSize + hashValue] = p->pos;
-+    p->son[p->cyclicBufferPos] = curMatch;
-+    MOVE_POS
-+  }
-+  while (--num != 0);
-+}
-+
-+void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-+{
-+  do
-+  {
-+    SKIP_HEADER(3)
-+    HASH_ZIP_CALC;
-+    curMatch = p->hash[hashValue];
-+    p->hash[hashValue] = p->pos;
-+    p->son[p->cyclicBufferPos] = curMatch;
-+    MOVE_POS
-+  }
-+  while (--num != 0);
-+}
-+
-+void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable)
-+{
-+  vTable->Init = (Mf_Init_Func)MatchFinder_Init;
-+  vTable->GetIndexByte = (Mf_GetIndexByte_Func)MatchFinder_GetIndexByte;
-+  vTable->GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinder_GetNumAvailableBytes;
-+  vTable->GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinder_GetPointerToCurrentPos;
-+  if (!p->btMode)
-+  {
-+    vTable->GetMatches = (Mf_GetMatches_Func)Hc4_MatchFinder_GetMatches;
-+    vTable->Skip = (Mf_Skip_Func)Hc4_MatchFinder_Skip;
-+  }
-+  else if (p->numHashBytes == 2)
-+  {
-+    vTable->GetMatches = (Mf_GetMatches_Func)Bt2_MatchFinder_GetMatches;
-+    vTable->Skip = (Mf_Skip_Func)Bt2_MatchFinder_Skip;
-+  }
-+  else if (p->numHashBytes == 3)
-+  {
-+    vTable->GetMatches = (Mf_GetMatches_Func)Bt3_MatchFinder_GetMatches;
-+    vTable->Skip = (Mf_Skip_Func)Bt3_MatchFinder_Skip;
-+  }
-+  else
-+  {
-+    vTable->GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
-+    vTable->Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
-+  }
-+}
---- /dev/null
-+++ b/lib/lzma/LzmaDec.c
-@@ -0,0 +1,999 @@
-+/* LzmaDec.c -- LZMA Decoder
-+2009-09-20 : Igor Pavlov : Public domain */
-+
-+#include "LzmaDec.h"
-+
-+#include <string.h>
-+
-+#define kNumTopBits 24
-+#define kTopValue ((UInt32)1 << kNumTopBits)
-+
-+#define kNumBitModelTotalBits 11
-+#define kBitModelTotal (1 << kNumBitModelTotalBits)
-+#define kNumMoveBits 5
-+
-+#define RC_INIT_SIZE 5
-+
-+#define NORMALIZE if (range < kTopValue) { range <<= 8; code = (code << 8) | (*buf++); }
-+
-+#define IF_BIT_0(p) ttt = *(p); NORMALIZE; bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)
-+#define UPDATE_0(p) range = bound; *(p) = (CLzmaProb)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits));
-+#define UPDATE_1(p) range -= bound; code -= bound; *(p) = (CLzmaProb)(ttt - (ttt >> kNumMoveBits));
-+#define GET_BIT2(p, i, A0, A1) IF_BIT_0(p) \
-+  { UPDATE_0(p); i = (i + i); A0; } else \
-+  { UPDATE_1(p); i = (i + i) + 1; A1; }
-+#define GET_BIT(p, i) GET_BIT2(p, i, ; , ;)
-+
-+#define TREE_GET_BIT(probs, i) { GET_BIT((probs + i), i); }
-+#define TREE_DECODE(probs, limit, i) \
-+  { i = 1; do { TREE_GET_BIT(probs, i); } while (i < limit); i -= limit; }
-+
-+/* #define _LZMA_SIZE_OPT */
-+
-+#ifdef _LZMA_SIZE_OPT
-+#define TREE_6_DECODE(probs, i) TREE_DECODE(probs, (1 << 6), i)
-+#else
-+#define TREE_6_DECODE(probs, i) \
-+  { i = 1; \
-+  TREE_GET_BIT(probs, i); \
-+  TREE_GET_BIT(probs, i); \
-+  TREE_GET_BIT(probs, i); \
-+  TREE_GET_BIT(probs, i); \
-+  TREE_GET_BIT(probs, i); \
-+  TREE_GET_BIT(probs, i); \
-+  i -= 0x40; }
-+#endif
-+
-+#define NORMALIZE_CHECK if (range < kTopValue) { if (buf >= bufLimit) return DUMMY_ERROR; range <<= 8; code = (code << 8) | (*buf++); }
-+
-+#define IF_BIT_0_CHECK(p) ttt = *(p); NORMALIZE_CHECK; bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)
-+#define UPDATE_0_CHECK range = bound;
-+#define UPDATE_1_CHECK range -= bound; code -= bound;
-+#define GET_BIT2_CHECK(p, i, A0, A1) IF_BIT_0_CHECK(p) \
-+  { UPDATE_0_CHECK; i = (i + i); A0; } else \
-+  { UPDATE_1_CHECK; i = (i + i) + 1; A1; }
-+#define GET_BIT_CHECK(p, i) GET_BIT2_CHECK(p, i, ; , ;)
-+#define TREE_DECODE_CHECK(probs, limit, i) \
-+  { i = 1; do { GET_BIT_CHECK(probs + i, i) } while (i < limit); i -= limit; }
-+
-+
-+#define kNumPosBitsMax 4
-+#define kNumPosStatesMax (1 << kNumPosBitsMax)
-+
-+#define kLenNumLowBits 3
-+#define kLenNumLowSymbols (1 << kLenNumLowBits)
-+#define kLenNumMidBits 3
-+#define kLenNumMidSymbols (1 << kLenNumMidBits)
-+#define kLenNumHighBits 8
-+#define kLenNumHighSymbols (1 << kLenNumHighBits)
-+
-+#define LenChoice 0
-+#define LenChoice2 (LenChoice + 1)
-+#define LenLow (LenChoice2 + 1)
-+#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
-+#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
-+#define kNumLenProbs (LenHigh + kLenNumHighSymbols)
-+
-+
-+#define kNumStates 12
-+#define kNumLitStates 7
-+
-+#define kStartPosModelIndex 4
-+#define kEndPosModelIndex 14
-+#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
-+
-+#define kNumPosSlotBits 6
-+#define kNumLenToPosStates 4
-+
-+#define kNumAlignBits 4
-+#define kAlignTableSize (1 << kNumAlignBits)
-+
-+#define kMatchMinLen 2
-+#define kMatchSpecLenStart (kMatchMinLen + kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)
-+
-+#define IsMatch 0
-+#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
-+#define IsRepG0 (IsRep + kNumStates)
-+#define IsRepG1 (IsRepG0 + kNumStates)
-+#define IsRepG2 (IsRepG1 + kNumStates)
-+#define IsRep0Long (IsRepG2 + kNumStates)
-+#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
-+#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
-+#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
-+#define LenCoder (Align + kAlignTableSize)
-+#define RepLenCoder (LenCoder + kNumLenProbs)
-+#define Literal (RepLenCoder + kNumLenProbs)
-+
-+#define LZMA_BASE_SIZE 1846
-+#define LZMA_LIT_SIZE 768
-+
-+#define LzmaProps_GetNumProbs(p) ((UInt32)LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((p)->lc + (p)->lp)))
-+
-+#if Literal != LZMA_BASE_SIZE
-+StopCompilingDueBUG
-+#endif
-+
-+#define LZMA_DIC_MIN (1 << 12)
-+
-+/* First LZMA-symbol is always decoded.
-+And it decodes new LZMA-symbols while (buf < bufLimit), but "buf" is without last normalization
-+Out:
-+  Result:
-+    SZ_OK - OK
-+    SZ_ERROR_DATA - Error
-+  p->remainLen:
-+    < kMatchSpecLenStart : normal remain
-+    = kMatchSpecLenStart : finished
-+    = kMatchSpecLenStart + 1 : Flush marker
-+    = kMatchSpecLenStart + 2 : State Init Marker
-+*/
-+
-+static int MY_FAST_CALL LzmaDec_DecodeReal(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
-+{
-+  CLzmaProb *probs = p->probs;
-+
-+  unsigned state = p->state;
-+  UInt32 rep0 = p->reps[0], rep1 = p->reps[1], rep2 = p->reps[2], rep3 = p->reps[3];
-+  unsigned pbMask = ((unsigned)1 << (p->prop.pb)) - 1;
-+  unsigned lpMask = ((unsigned)1 << (p->prop.lp)) - 1;
-+  unsigned lc = p->prop.lc;
-+
-+  Byte *dic = p->dic;
-+  SizeT dicBufSize = p->dicBufSize;
-+  SizeT dicPos = p->dicPos;
-+  
-+  UInt32 processedPos = p->processedPos;
-+  UInt32 checkDicSize = p->checkDicSize;
-+  unsigned len = 0;
-+
-+  const Byte *buf = p->buf;
-+  UInt32 range = p->range;
-+  UInt32 code = p->code;
-+
-+  do
-+  {
-+    CLzmaProb *prob;
-+    UInt32 bound;
-+    unsigned ttt;
-+    unsigned posState = processedPos & pbMask;
-+
-+    prob = probs + IsMatch + (state << kNumPosBitsMax) + posState;
-+    IF_BIT_0(prob)
-+    {
-+      unsigned symbol;
-+      UPDATE_0(prob);
-+      prob = probs + Literal;
-+      if (checkDicSize != 0 || processedPos != 0)
-+        prob += (LZMA_LIT_SIZE * (((processedPos & lpMask) << lc) +
-+        (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] >> (8 - lc))));
-+
-+      if (state < kNumLitStates)
-+      {
-+        state -= (state < 4) ? state : 3;
-+        symbol = 1;
-+        do { GET_BIT(prob + symbol, symbol) } while (symbol < 0x100);
-+      }
-+      else
-+      {
-+        unsigned matchByte = p->dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
-+        unsigned offs = 0x100;
-+        state -= (state < 10) ? 3 : 6;
-+        symbol = 1;
-+        do
-+        {
-+          unsigned bit;
-+          CLzmaProb *probLit;
-+          matchByte <<= 1;
-+          bit = (matchByte & offs);
-+          probLit = prob + offs + bit + symbol;
-+          GET_BIT2(probLit, symbol, offs &= ~bit, offs &= bit)
-+        }
-+        while (symbol < 0x100);
-+      }
-+      dic[dicPos++] = (Byte)symbol;
-+      processedPos++;
-+      continue;
-+    }
-+    else
-+    {
-+      UPDATE_1(prob);
-+      prob = probs + IsRep + state;
-+      IF_BIT_0(prob)
-+      {
-+        UPDATE_0(prob);
-+        state += kNumStates;
-+        prob = probs + LenCoder;
-+      }
-+      else
-+      {
-+        UPDATE_1(prob);
-+        if (checkDicSize == 0 && processedPos == 0)
-+          return SZ_ERROR_DATA;
-+        prob = probs + IsRepG0 + state;
-+        IF_BIT_0(prob)
-+        {
-+          UPDATE_0(prob);
-+          prob = probs + IsRep0Long + (state << kNumPosBitsMax) + posState;
-+          IF_BIT_0(prob)
-+          {
-+            UPDATE_0(prob);
-+            dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
-+            dicPos++;
-+            processedPos++;
-+            state = state < kNumLitStates ? 9 : 11;
-+            continue;
-+          }
-+          UPDATE_1(prob);
-+        }
-+        else
-+        {
-+          UInt32 distance;
-+          UPDATE_1(prob);
-+          prob = probs + IsRepG1 + state;
-+          IF_BIT_0(prob)
-+          {
-+            UPDATE_0(prob);
-+            distance = rep1;
-+          }
-+          else
-+          {
-+            UPDATE_1(prob);
-+            prob = probs + IsRepG2 + state;
-+            IF_BIT_0(prob)
-+            {
-+              UPDATE_0(prob);
-+              distance = rep2;
-+            }
-+            else
-+            {
-+              UPDATE_1(prob);
-+              distance = rep3;
-+              rep3 = rep2;
-+            }
-+            rep2 = rep1;
-+          }
-+          rep1 = rep0;
-+          rep0 = distance;
-+        }
-+        state = state < kNumLitStates ? 8 : 11;
-+        prob = probs + RepLenCoder;
-+      }
-+      {
-+        unsigned limit, offset;
-+        CLzmaProb *probLen = prob + LenChoice;
-+        IF_BIT_0(probLen)
-+        {
-+          UPDATE_0(probLen);
-+          probLen = prob + LenLow + (posState << kLenNumLowBits);
-+          offset = 0;
-+          limit = (1 << kLenNumLowBits);
-+        }
-+        else
-+        {
-+          UPDATE_1(probLen);
-+          probLen = prob + LenChoice2;
-+          IF_BIT_0(probLen)
-+          {
-+            UPDATE_0(probLen);
-+            probLen = prob + LenMid + (posState << kLenNumMidBits);
-+            offset = kLenNumLowSymbols;
-+            limit = (1 << kLenNumMidBits);
-+          }
-+          else
-+          {
-+            UPDATE_1(probLen);
-+            probLen = prob + LenHigh;
-+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
-+            limit = (1 << kLenNumHighBits);
-+          }
-+        }
-+        TREE_DECODE(probLen, limit, len);
-+        len += offset;
-+      }
-+
-+      if (state >= kNumStates)
-+      {
-+        UInt32 distance;
-+        prob = probs + PosSlot +
-+            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);
-+        TREE_6_DECODE(prob, distance);
-+        if (distance >= kStartPosModelIndex)
-+        {
-+          unsigned posSlot = (unsigned)distance;
-+          int numDirectBits = (int)(((distance >> 1) - 1));
-+          distance = (2 | (distance & 1));
-+          if (posSlot < kEndPosModelIndex)
-+          {
-+            distance <<= numDirectBits;
-+            prob = probs + SpecPos + distance - posSlot - 1;
-+            {
-+              UInt32 mask = 1;
-+              unsigned i = 1;
-+              do
-+              {
-+                GET_BIT2(prob + i, i, ; , distance |= mask);
-+                mask <<= 1;
-+              }
-+              while (--numDirectBits != 0);
-+            }
-+          }
-+          else
-+          {
-+            numDirectBits -= kNumAlignBits;
-+            do
-+            {
-+              NORMALIZE
-+              range >>= 1;
-+              
-+              {
-+                UInt32 t;
-+                code -= range;
-+                t = (0 - ((UInt32)code >> 31)); /* (UInt32)((Int32)code >> 31) */
-+                distance = (distance << 1) + (t + 1);
-+                code += range & t;
-+              }
-+              /*
-+              distance <<= 1;
-+              if (code >= range)
-+              {
-+                code -= range;
-+                distance |= 1;
-+              }
-+              */
-+            }
-+            while (--numDirectBits != 0);
-+            prob = probs + Align;
-+            distance <<= kNumAlignBits;
-+            {
-+              unsigned i = 1;
-+              GET_BIT2(prob + i, i, ; , distance |= 1);
-+              GET_BIT2(prob + i, i, ; , distance |= 2);
-+              GET_BIT2(prob + i, i, ; , distance |= 4);
-+              GET_BIT2(prob + i, i, ; , distance |= 8);
-+            }
-+            if (distance == (UInt32)0xFFFFFFFF)
-+            {
-+              len += kMatchSpecLenStart;
-+              state -= kNumStates;
-+              break;
-+            }
-+          }
-+        }
-+        rep3 = rep2;
-+        rep2 = rep1;
-+        rep1 = rep0;
-+        rep0 = distance + 1;
-+        if (checkDicSize == 0)
-+        {
-+          if (distance >= processedPos)
-+            return SZ_ERROR_DATA;
-+        }
-+        else if (distance >= checkDicSize)
-+          return SZ_ERROR_DATA;
-+        state = (state < kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3;
-+      }
-+
-+      len += kMatchMinLen;
-+
-+      if (limit == dicPos)
-+        return SZ_ERROR_DATA;
-+      {
-+        SizeT rem = limit - dicPos;
-+        unsigned curLen = ((rem < len) ? (unsigned)rem : len);
-+        SizeT pos = (dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0);
-+
-+        processedPos += curLen;
-+
-+        len -= curLen;
-+        if (pos + curLen <= dicBufSize)
-+        {
-+          Byte *dest = dic + dicPos;
-+          ptrdiff_t src = (ptrdiff_t)pos - (ptrdiff_t)dicPos;
-+          const Byte *lim = dest + curLen;
-+          dicPos += curLen;
-+          do
-+            *(dest) = (Byte)*(dest + src);
-+          while (++dest != lim);
-+        }
-+        else
-+        {
-+          do
-+          {
-+            dic[dicPos++] = dic[pos];
-+            if (++pos == dicBufSize)
-+              pos = 0;
-+          }
-+          while (--curLen != 0);
-+        }
-+      }
-+    }
-+  }
-+  while (dicPos < limit && buf < bufLimit);
-+  NORMALIZE;
-+  p->buf = buf;
-+  p->range = range;
-+  p->code = code;
-+  p->remainLen = len;
-+  p->dicPos = dicPos;
-+  p->processedPos = processedPos;
-+  p->reps[0] = rep0;
-+  p->reps[1] = rep1;
-+  p->reps[2] = rep2;
-+  p->reps[3] = rep3;
-+  p->state = state;
-+
-+  return SZ_OK;
-+}
-+
-+static void MY_FAST_CALL LzmaDec_WriteRem(CLzmaDec *p, SizeT limit)
-+{
-+  if (p->remainLen != 0 && p->remainLen < kMatchSpecLenStart)
-+  {
-+    Byte *dic = p->dic;
-+    SizeT dicPos = p->dicPos;
-+    SizeT dicBufSize = p->dicBufSize;
-+    unsigned len = p->remainLen;
-+    UInt32 rep0 = p->reps[0];
-+    if (limit - dicPos < len)
-+      len = (unsigned)(limit - dicPos);
-+
-+    if (p->checkDicSize == 0 && p->prop.dicSize - p->processedPos <= len)
-+      p->checkDicSize = p->prop.dicSize;
-+
-+    p->processedPos += len;
-+    p->remainLen -= len;
-+    while (len-- != 0)
-+    {
-+      dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
-+      dicPos++;
-+    }
-+    p->dicPos = dicPos;
-+  }
-+}
-+
-+static int MY_FAST_CALL LzmaDec_DecodeReal2(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
-+{
-+  do
-+  {
-+    SizeT limit2 = limit;
-+    if (p->checkDicSize == 0)
-+    {
-+      UInt32 rem = p->prop.dicSize - p->processedPos;
-+      if (limit - p->dicPos > rem)
-+        limit2 = p->dicPos + rem;
-+    }
-+    RINOK(LzmaDec_DecodeReal(p, limit2, bufLimit));
-+    if (p->processedPos >= p->prop.dicSize)
-+      p->checkDicSize = p->prop.dicSize;
-+    LzmaDec_WriteRem(p, limit);
-+  }
-+  while (p->dicPos < limit && p->buf < bufLimit && p->remainLen < kMatchSpecLenStart);
-+
-+  if (p->remainLen > kMatchSpecLenStart)
-+  {
-+    p->remainLen = kMatchSpecLenStart;
-+  }
-+  return 0;
-+}
-+
-+typedef enum
-+{
-+  DUMMY_ERROR, /* unexpected end of input stream */
-+  DUMMY_LIT,
-+  DUMMY_MATCH,
-+  DUMMY_REP
-+} ELzmaDummy;
-+
-+static ELzmaDummy LzmaDec_TryDummy(const CLzmaDec *p, const Byte *buf, SizeT inSize)
-+{
-+  UInt32 range = p->range;
-+  UInt32 code = p->code;
-+  const Byte *bufLimit = buf + inSize;
-+  CLzmaProb *probs = p->probs;
-+  unsigned state = p->state;
-+  ELzmaDummy res;
-+
-+  {
-+    CLzmaProb *prob;
-+    UInt32 bound;
-+    unsigned ttt;
-+    unsigned posState = (p->processedPos) & ((1 << p->prop.pb) - 1);
-+
-+    prob = probs + IsMatch + (state << kNumPosBitsMax) + posState;
-+    IF_BIT_0_CHECK(prob)
-+    {
-+      UPDATE_0_CHECK
-+
-+      /* if (bufLimit - buf >= 7) return DUMMY_LIT; */
-+
-+      prob = probs + Literal;
-+      if (p->checkDicSize != 0 || p->processedPos != 0)
-+        prob += (LZMA_LIT_SIZE *
-+          ((((p->processedPos) & ((1 << (p->prop.lp)) - 1)) << p->prop.lc) +
-+          (p->dic[(p->dicPos == 0 ? p->dicBufSize : p->dicPos) - 1] >> (8 - p->prop.lc))));
-+
-+      if (state < kNumLitStates)
-+      {
-+        unsigned symbol = 1;
-+        do { GET_BIT_CHECK(prob + symbol, symbol) } while (symbol < 0x100);
-+      }
-+      else
-+      {
-+        unsigned matchByte = p->dic[p->dicPos - p->reps[0] +
-+            ((p->dicPos < p->reps[0]) ? p->dicBufSize : 0)];
-+        unsigned offs = 0x100;
-+        unsigned symbol = 1;
-+        do
-+        {
-+          unsigned bit;
-+          CLzmaProb *probLit;
-+          matchByte <<= 1;
-+          bit = (matchByte & offs);
-+          probLit = prob + offs + bit + symbol;
-+          GET_BIT2_CHECK(probLit, symbol, offs &= ~bit, offs &= bit)
-+        }
-+        while (symbol < 0x100);
-+      }
-+      res = DUMMY_LIT;
-+    }
-+    else
-+    {
-+      unsigned len;
-+      UPDATE_1_CHECK;
-+
-+      prob = probs + IsRep + state;
-+      IF_BIT_0_CHECK(prob)
-+      {
-+        UPDATE_0_CHECK;
-+        state = 0;
-+        prob = probs + LenCoder;
-+        res = DUMMY_MATCH;
-+      }
-+      else
-+      {
-+        UPDATE_1_CHECK;
-+        res = DUMMY_REP;
-+        prob = probs + IsRepG0 + state;
-+        IF_BIT_0_CHECK(prob)
-+        {
-+          UPDATE_0_CHECK;
-+          prob = probs + IsRep0Long + (state << kNumPosBitsMax) + posState;
-+          IF_BIT_0_CHECK(prob)
-+          {
-+            UPDATE_0_CHECK;
-+            NORMALIZE_CHECK;
-+            return DUMMY_REP;
-+          }
-+          else
-+          {
-+            UPDATE_1_CHECK;
-+          }
-+        }
-+        else
-+        {
-+          UPDATE_1_CHECK;
-+          prob = probs + IsRepG1 + state;
-+          IF_BIT_0_CHECK(prob)
-+          {
-+            UPDATE_0_CHECK;
-+          }
-+          else
-+          {
-+            UPDATE_1_CHECK;
-+            prob = probs + IsRepG2 + state;
-+            IF_BIT_0_CHECK(prob)
-+            {
-+              UPDATE_0_CHECK;
-+            }
-+            else
-+            {
-+              UPDATE_1_CHECK;
-+            }
-+          }
-+        }
-+        state = kNumStates;
-+        prob = probs + RepLenCoder;
-+      }
-+      {
-+        unsigned limit, offset;
-+        CLzmaProb *probLen = prob + LenChoice;
-+        IF_BIT_0_CHECK(probLen)
-+        {
-+          UPDATE_0_CHECK;
-+          probLen = prob + LenLow + (posState << kLenNumLowBits);
-+          offset = 0;
-+          limit = 1 << kLenNumLowBits;
-+        }
-+        else
-+        {
-+          UPDATE_1_CHECK;
-+          probLen = prob + LenChoice2;
-+          IF_BIT_0_CHECK(probLen)
-+          {
-+            UPDATE_0_CHECK;
-+            probLen = prob + LenMid + (posState << kLenNumMidBits);
-+            offset = kLenNumLowSymbols;
-+            limit = 1 << kLenNumMidBits;
-+          }
-+          else
-+          {
-+            UPDATE_1_CHECK;
-+            probLen = prob + LenHigh;
-+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
-+            limit = 1 << kLenNumHighBits;
-+          }
-+        }
-+        TREE_DECODE_CHECK(probLen, limit, len);
-+        len += offset;
-+      }
-+
-+      if (state < 4)
-+      {
-+        unsigned posSlot;
-+        prob = probs + PosSlot +
-+            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) <<
-+            kNumPosSlotBits);
-+        TREE_DECODE_CHECK(prob, 1 << kNumPosSlotBits, posSlot);
-+        if (posSlot >= kStartPosModelIndex)
-+        {
-+          int numDirectBits = ((posSlot >> 1) - 1);
-+
-+          /* if (bufLimit - buf >= 8) return DUMMY_MATCH; */
-+
-+          if (posSlot < kEndPosModelIndex)
-+          {
-+            prob = probs + SpecPos + ((2 | (posSlot & 1)) << numDirectBits) - posSlot - 1;
-+          }
-+          else
-+          {
-+            numDirectBits -= kNumAlignBits;
-+            do
-+            {
-+              NORMALIZE_CHECK
-+              range >>= 1;
-+              code -= range & (((code - range) >> 31) - 1);
-+              /* if (code >= range) code -= range; */
-+            }
-+            while (--numDirectBits != 0);
-+            prob = probs + Align;
-+            numDirectBits = kNumAlignBits;
-+          }
-+          {
-+            unsigned i = 1;
-+            do
-+            {
-+              GET_BIT_CHECK(prob + i, i);
-+            }
-+            while (--numDirectBits != 0);
-+          }
-+        }
-+      }
-+    }
-+  }
-+  NORMALIZE_CHECK;
-+  return res;
-+}
-+
-+
-+static void LzmaDec_InitRc(CLzmaDec *p, const Byte *data)
-+{
-+  p->code = ((UInt32)data[1] << 24) | ((UInt32)data[2] << 16) | ((UInt32)data[3] << 8) | ((UInt32)data[4]);
-+  p->range = 0xFFFFFFFF;
-+  p->needFlush = 0;
-+}
-+
-+void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
-+{
-+  p->needFlush = 1;
-+  p->remainLen = 0;
-+  p->tempBufSize = 0;
-+
-+  if (initDic)
-+  {
-+    p->processedPos = 0;
-+    p->checkDicSize = 0;
-+    p->needInitState = 1;
-+  }
-+  if (initState)
-+    p->needInitState = 1;
-+}
-+
-+void LzmaDec_Init(CLzmaDec *p)
-+{
-+  p->dicPos = 0;
-+  LzmaDec_InitDicAndState(p, True, True);
-+}
-+
-+static void LzmaDec_InitStateReal(CLzmaDec *p)
-+{
-+  UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (p->prop.lc + p->prop.lp));
-+  UInt32 i;
-+  CLzmaProb *probs = p->probs;
-+  for (i = 0; i < numProbs; i++)
-+    probs[i] = kBitModelTotal >> 1;
-+  p->reps[0] = p->reps[1] = p->reps[2] = p->reps[3] = 1;
-+  p->state = 0;
-+  p->needInitState = 0;
-+}
-+
-+SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
-+    ELzmaFinishMode finishMode, ELzmaStatus *status)
-+{
-+  SizeT inSize = *srcLen;
-+  (*srcLen) = 0;
-+  LzmaDec_WriteRem(p, dicLimit);
-+  
-+  *status = LZMA_STATUS_NOT_SPECIFIED;
-+
-+  while (p->remainLen != kMatchSpecLenStart)
-+  {
-+      int checkEndMarkNow;
-+
-+      if (p->needFlush != 0)
-+      {
-+        for (; inSize > 0 && p->tempBufSize < RC_INIT_SIZE; (*srcLen)++, inSize--)
-+          p->tempBuf[p->tempBufSize++] = *src++;
-+        if (p->tempBufSize < RC_INIT_SIZE)
-+        {
-+          *status = LZMA_STATUS_NEEDS_MORE_INPUT;
-+          return SZ_OK;
-+        }
-+        if (p->tempBuf[0] != 0)
-+          return SZ_ERROR_DATA;
-+
-+        LzmaDec_InitRc(p, p->tempBuf);
-+        p->tempBufSize = 0;
-+      }
-+
-+      checkEndMarkNow = 0;
-+      if (p->dicPos >= dicLimit)
-+      {
-+        if (p->remainLen == 0 && p->code == 0)
-+        {
-+          *status = LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK;
-+          return SZ_OK;
-+        }
-+        if (finishMode == LZMA_FINISH_ANY)
-+        {
-+          *status = LZMA_STATUS_NOT_FINISHED;
-+          return SZ_OK;
-+        }
-+        if (p->remainLen != 0)
-+        {
-+          *status = LZMA_STATUS_NOT_FINISHED;
-+          return SZ_ERROR_DATA;
-+        }
-+        checkEndMarkNow = 1;
-+      }
-+
-+      if (p->needInitState)
-+        LzmaDec_InitStateReal(p);
-+  
-+      if (p->tempBufSize == 0)
-+      {
-+        SizeT processed;
-+        const Byte *bufLimit;
-+        if (inSize < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
-+        {
-+          int dummyRes = LzmaDec_TryDummy(p, src, inSize);
-+          if (dummyRes == DUMMY_ERROR)
-+          {
-+            memcpy(p->tempBuf, src, inSize);
-+            p->tempBufSize = (unsigned)inSize;
-+            (*srcLen) += inSize;
-+            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
-+            return SZ_OK;
-+          }
-+          if (checkEndMarkNow && dummyRes != DUMMY_MATCH)
-+          {
-+            *status = LZMA_STATUS_NOT_FINISHED;
-+            return SZ_ERROR_DATA;
-+          }
-+          bufLimit = src;
-+        }
-+        else
-+          bufLimit = src + inSize - LZMA_REQUIRED_INPUT_MAX;
-+        p->buf = src;
-+        if (LzmaDec_DecodeReal2(p, dicLimit, bufLimit) != 0)
-+          return SZ_ERROR_DATA;
-+        processed = (SizeT)(p->buf - src);
-+        (*srcLen) += processed;
-+        src += processed;
-+        inSize -= processed;
-+      }
-+      else
-+      {
-+        unsigned rem = p->tempBufSize, lookAhead = 0;
-+        while (rem < LZMA_REQUIRED_INPUT_MAX && lookAhead < inSize)
-+          p->tempBuf[rem++] = src[lookAhead++];
-+        p->tempBufSize = rem;
-+        if (rem < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
-+        {
-+          int dummyRes = LzmaDec_TryDummy(p, p->tempBuf, rem);
-+          if (dummyRes == DUMMY_ERROR)
-+          {
-+            (*srcLen) += lookAhead;
-+            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
-+            return SZ_OK;
-+          }
-+          if (checkEndMarkNow && dummyRes != DUMMY_MATCH)
-+          {
-+            *status = LZMA_STATUS_NOT_FINISHED;
-+            return SZ_ERROR_DATA;
-+          }
-+        }
-+        p->buf = p->tempBuf;
-+        if (LzmaDec_DecodeReal2(p, dicLimit, p->buf) != 0)
-+          return SZ_ERROR_DATA;
-+        lookAhead -= (rem - (unsigned)(p->buf - p->tempBuf));
-+        (*srcLen) += lookAhead;
-+        src += lookAhead;
-+        inSize -= lookAhead;
-+        p->tempBufSize = 0;
-+      }
-+  }
-+  if (p->code == 0)
-+    *status = LZMA_STATUS_FINISHED_WITH_MARK;
-+  return (p->code == 0) ? SZ_OK : SZ_ERROR_DATA;
-+}
-+
-+SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
-+{
-+  SizeT outSize = *destLen;
-+  SizeT inSize = *srcLen;
-+  *srcLen = *destLen = 0;
-+  for (;;)
-+  {
-+    SizeT inSizeCur = inSize, outSizeCur, dicPos;
-+    ELzmaFinishMode curFinishMode;
-+    SRes res;
-+    if (p->dicPos == p->dicBufSize)
-+      p->dicPos = 0;
-+    dicPos = p->dicPos;
-+    if (outSize > p->dicBufSize - dicPos)
-+    {
-+      outSizeCur = p->dicBufSize;
-+      curFinishMode = LZMA_FINISH_ANY;
-+    }
-+    else
-+    {
-+      outSizeCur = dicPos + outSize;
-+      curFinishMode = finishMode;
-+    }
-+
-+    res = LzmaDec_DecodeToDic(p, outSizeCur, src, &inSizeCur, curFinishMode, status);
-+    src += inSizeCur;
-+    inSize -= inSizeCur;
-+    *srcLen += inSizeCur;
-+    outSizeCur = p->dicPos - dicPos;
-+    memcpy(dest, p->dic + dicPos, outSizeCur);
-+    dest += outSizeCur;
-+    outSize -= outSizeCur;
-+    *destLen += outSizeCur;
-+    if (res != 0)
-+      return res;
-+    if (outSizeCur == 0 || outSize == 0)
-+      return SZ_OK;
-+  }
-+}
-+
-+void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
-+{
-+  alloc->Free(alloc, p->probs);
-+  p->probs = 0;
-+}
-+
-+static void LzmaDec_FreeDict(CLzmaDec *p, ISzAlloc *alloc)
-+{
-+  alloc->Free(alloc, p->dic);
-+  p->dic = 0;
-+}
-+
-+void LzmaDec_Free(CLzmaDec *p, ISzAlloc *alloc)
-+{
-+  LzmaDec_FreeProbs(p, alloc);
-+  LzmaDec_FreeDict(p, alloc);
-+}
-+
-+SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
-+{
-+  UInt32 dicSize;
-+  Byte d;
-+  
-+  if (size < LZMA_PROPS_SIZE)
-+    return SZ_ERROR_UNSUPPORTED;
-+  else
-+    dicSize = data[1] | ((UInt32)data[2] << 8) | ((UInt32)data[3] << 16) | ((UInt32)data[4] << 24);
-+ 
-+  if (dicSize < LZMA_DIC_MIN)
-+    dicSize = LZMA_DIC_MIN;
-+  p->dicSize = dicSize;
-+
-+  d = data[0];
-+  if (d >= (9 * 5 * 5))
-+    return SZ_ERROR_UNSUPPORTED;
-+
-+  p->lc = d % 9;
-+  d /= 9;
-+  p->pb = d / 5;
-+  p->lp = d % 5;
-+
-+  return SZ_OK;
-+}
-+
-+static SRes LzmaDec_AllocateProbs2(CLzmaDec *p, const CLzmaProps *propNew, ISzAlloc *alloc)
-+{
-+  UInt32 numProbs = LzmaProps_GetNumProbs(propNew);
-+  if (p->probs == 0 || numProbs != p->numProbs)
-+  {
-+    LzmaDec_FreeProbs(p, alloc);
-+    p->probs = (CLzmaProb *)alloc->Alloc(alloc, numProbs * sizeof(CLzmaProb));
-+    p->numProbs = numProbs;
-+    if (p->probs == 0)
-+      return SZ_ERROR_MEM;
-+  }
-+  return SZ_OK;
-+}
-+
-+SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
-+{
-+  CLzmaProps propNew;
-+  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
-+  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
-+  p->prop = propNew;
-+  return SZ_OK;
-+}
-+
-+SRes LzmaDec_Allocate(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
-+{
-+  CLzmaProps propNew;
-+  SizeT dicBufSize;
-+  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
-+  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
-+  dicBufSize = propNew.dicSize;
-+  if (p->dic == 0 || dicBufSize != p->dicBufSize)
-+  {
-+    LzmaDec_FreeDict(p, alloc);
-+    p->dic = (Byte *)alloc->Alloc(alloc, dicBufSize);
-+    if (p->dic == 0)
-+    {
-+      LzmaDec_FreeProbs(p, alloc);
-+      return SZ_ERROR_MEM;
-+    }
-+  }
-+  p->dicBufSize = dicBufSize;
-+  p->prop = propNew;
-+  return SZ_OK;
-+}
-+
-+SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
-+    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
-+    ELzmaStatus *status, ISzAlloc *alloc)
-+{
-+  CLzmaDec p;
-+  SRes res;
-+  SizeT inSize = *srcLen;
-+  SizeT outSize = *destLen;
-+  *srcLen = *destLen = 0;
-+  if (inSize < RC_INIT_SIZE)
-+    return SZ_ERROR_INPUT_EOF;
-+
-+  LzmaDec_Construct(&p);
-+  res = LzmaDec_AllocateProbs(&p, propData, propSize, alloc);
-+  if (res != 0)
-+    return res;
-+  p.dic = dest;
-+  p.dicBufSize = outSize;
-+
-+  LzmaDec_Init(&p);
-+  
-+  *srcLen = inSize;
-+  res = LzmaDec_DecodeToDic(&p, outSize, src, srcLen, finishMode, status);
-+
-+  if (res == SZ_OK && *status == LZMA_STATUS_NEEDS_MORE_INPUT)
-+    res = SZ_ERROR_INPUT_EOF;
-+
-+  (*destLen) = p.dicPos;
-+  LzmaDec_FreeProbs(&p, alloc);
-+  return res;
-+}
---- /dev/null
-+++ b/lib/lzma/LzmaEnc.c
-@@ -0,0 +1,2271 @@
-+/* LzmaEnc.c -- LZMA Encoder
-+2009-11-24 : Igor Pavlov : Public domain */
-+
-+#include <string.h>
-+
-+/* #define SHOW_STAT */
-+/* #define SHOW_STAT2 */
-+
-+#if defined(SHOW_STAT) || defined(SHOW_STAT2)
-+#include <stdio.h>
-+#endif
-+
-+#include "LzmaEnc.h"
-+
-+/* disable MT */
-+#define _7ZIP_ST
-+
-+#include "LzFind.h"
-+#ifndef _7ZIP_ST
-+#include "LzFindMt.h"
-+#endif
-+
-+#ifdef SHOW_STAT
-+static int ttt = 0;
-+#endif
-+
-+#define kBlockSizeMax ((1 << LZMA_NUM_BLOCK_SIZE_BITS) - 1)
-+
-+#define kBlockSize (9 << 10)
-+#define kUnpackBlockSize (1 << 18)
-+#define kMatchArraySize (1 << 21)
-+#define kMatchRecordMaxSize ((LZMA_MATCH_LEN_MAX * 2 + 3) * LZMA_MATCH_LEN_MAX)
-+
-+#define kNumMaxDirectBits (31)
-+
-+#define kNumTopBits 24
-+#define kTopValue ((UInt32)1 << kNumTopBits)
-+
-+#define kNumBitModelTotalBits 11
-+#define kBitModelTotal (1 << kNumBitModelTotalBits)
-+#define kNumMoveBits 5
-+#define kProbInitValue (kBitModelTotal >> 1)
-+
-+#define kNumMoveReducingBits 4
-+#define kNumBitPriceShiftBits 4
-+#define kBitPrice (1 << kNumBitPriceShiftBits)
-+
-+void LzmaEncProps_Init(CLzmaEncProps *p)
-+{
-+  p->level = 5;
-+  p->dictSize = p->mc = 0;
-+  p->lc = p->lp = p->pb = p->algo = p->fb = p->btMode = p->numHashBytes = p->numThreads = -1;
-+  p->writeEndMark = 0;
-+}
-+
-+void LzmaEncProps_Normalize(CLzmaEncProps *p)
-+{
-+  int level = p->level;
-+  if (level < 0) level = 5;
-+  p->level = level;
-+  if (p->dictSize == 0) p->dictSize = (level <= 5 ? (1 << (level * 2 + 14)) : (level == 6 ? (1 << 25) : (1 << 26)));
-+  if (p->lc < 0) p->lc = 3;
-+  if (p->lp < 0) p->lp = 0;
-+  if (p->pb < 0) p->pb = 2;
-+  if (p->algo < 0) p->algo = (level < 5 ? 0 : 1);
-+  if (p->fb < 0) p->fb = (level < 7 ? 32 : 64);
-+  if (p->btMode < 0) p->btMode = (p->algo == 0 ? 0 : 1);
-+  if (p->numHashBytes < 0) p->numHashBytes = 4;
-+  if (p->mc == 0)  p->mc = (16 + (p->fb >> 1)) >> (p->btMode ? 0 : 1);
-+  if (p->numThreads < 0)
-+    p->numThreads =
-+      #ifndef _7ZIP_ST
-+      ((p->btMode && p->algo) ? 2 : 1);
-+      #else
-+      1;
-+      #endif
-+}
-+
-+UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
-+{
-+  CLzmaEncProps props = *props2;
-+  LzmaEncProps_Normalize(&props);
-+  return props.dictSize;
-+}
-+
-+/* #define LZMA_LOG_BSR */
-+/* Define it for Intel's CPU */
-+
-+
-+#ifdef LZMA_LOG_BSR
-+
-+#define kDicLogSizeMaxCompress 30
-+
-+#define BSR2_RET(pos, res) { unsigned long i; _BitScanReverse(&i, (pos)); res = (i + i) + ((pos >> (i - 1)) & 1); }
-+
-+UInt32 GetPosSlot1(UInt32 pos)
-+{
-+  UInt32 res;
-+  BSR2_RET(pos, res);
-+  return res;
-+}
-+#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
-+#define GetPosSlot(pos, res) { if (pos < 2) res = pos; else BSR2_RET(pos, res); }
-+
-+#else
-+
-+#define kNumLogBits (9 + (int)sizeof(size_t) / 2)
-+#define kDicLogSizeMaxCompress ((kNumLogBits - 1) * 2 + 7)
-+
-+void LzmaEnc_FastPosInit(Byte *g_FastPos)
-+{
-+  int c = 2, slotFast;
-+  g_FastPos[0] = 0;
-+  g_FastPos[1] = 1;
-+  
-+  for (slotFast = 2; slotFast < kNumLogBits * 2; slotFast++)
-+  {
-+    UInt32 k = (1 << ((slotFast >> 1) - 1));
-+    UInt32 j;
-+    for (j = 0; j < k; j++, c++)
-+      g_FastPos[c] = (Byte)slotFast;
-+  }
-+}
-+
-+#define BSR2_RET(pos, res) { UInt32 i = 6 + ((kNumLogBits - 1) & \
-+  (0 - (((((UInt32)1 << (kNumLogBits + 6)) - 1) - pos) >> 31))); \
-+  res = p->g_FastPos[pos >> i] + (i * 2); }
-+/*
-+#define BSR2_RET(pos, res) { res = (pos < (1 << (kNumLogBits + 6))) ? \
-+  p->g_FastPos[pos >> 6] + 12 : \
-+  p->g_FastPos[pos >> (6 + kNumLogBits - 1)] + (6 + (kNumLogBits - 1)) * 2; }
-+*/
-+
-+#define GetPosSlot1(pos) p->g_FastPos[pos]
-+#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
-+#define GetPosSlot(pos, res) { if (pos < kNumFullDistances) res = p->g_FastPos[pos]; else BSR2_RET(pos, res); }
-+
-+#endif
-+
-+
-+#define LZMA_NUM_REPS 4
-+
-+typedef unsigned CState;
-+
-+typedef struct
-+{
-+  UInt32 price;
-+
-+  CState state;
-+  int prev1IsChar;
-+  int prev2;
-+
-+  UInt32 posPrev2;
-+  UInt32 backPrev2;
-+
-+  UInt32 posPrev;
-+  UInt32 backPrev;
-+  UInt32 backs[LZMA_NUM_REPS];
-+} COptimal;
-+
-+#define kNumOpts (1 << 12)
-+
-+#define kNumLenToPosStates 4
-+#define kNumPosSlotBits 6
-+#define kDicLogSizeMin 0
-+#define kDicLogSizeMax 32
-+#define kDistTableSizeMax (kDicLogSizeMax * 2)
-+
-+
-+#define kNumAlignBits 4
-+#define kAlignTableSize (1 << kNumAlignBits)
-+#define kAlignMask (kAlignTableSize - 1)
-+
-+#define kStartPosModelIndex 4
-+#define kEndPosModelIndex 14
-+#define kNumPosModels (kEndPosModelIndex - kStartPosModelIndex)
-+
-+#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
-+
-+#ifdef _LZMA_PROB32
-+#define CLzmaProb UInt32
-+#else
-+#define CLzmaProb UInt16
-+#endif
-+
-+#define LZMA_PB_MAX 4
-+#define LZMA_LC_MAX 8
-+#define LZMA_LP_MAX 4
-+
-+#define LZMA_NUM_PB_STATES_MAX (1 << LZMA_PB_MAX)
-+
-+
-+#define kLenNumLowBits 3
-+#define kLenNumLowSymbols (1 << kLenNumLowBits)
-+#define kLenNumMidBits 3
-+#define kLenNumMidSymbols (1 << kLenNumMidBits)
-+#define kLenNumHighBits 8
-+#define kLenNumHighSymbols (1 << kLenNumHighBits)
-+
-+#define kLenNumSymbolsTotal (kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)
-+
-+#define LZMA_MATCH_LEN_MIN 2
-+#define LZMA_MATCH_LEN_MAX (LZMA_MATCH_LEN_MIN + kLenNumSymbolsTotal - 1)
-+
-+#define kNumStates 12
-+
-+typedef struct
-+{
-+  CLzmaProb choice;
-+  CLzmaProb choice2;
-+  CLzmaProb low[LZMA_NUM_PB_STATES_MAX << kLenNumLowBits];
-+  CLzmaProb mid[LZMA_NUM_PB_STATES_MAX << kLenNumMidBits];
-+  CLzmaProb high[kLenNumHighSymbols];
-+} CLenEnc;
-+
-+typedef struct
-+{
-+  CLenEnc p;
-+  UInt32 prices[LZMA_NUM_PB_STATES_MAX][kLenNumSymbolsTotal];
-+  UInt32 tableSize;
-+  UInt32 counters[LZMA_NUM_PB_STATES_MAX];
-+} CLenPriceEnc;
-+
-+typedef struct
-+{
-+  UInt32 range;
-+  Byte cache;
-+  UInt64 low;
-+  UInt64 cacheSize;
-+  Byte *buf;
-+  Byte *bufLim;
-+  Byte *bufBase;
-+  ISeqOutStream *outStream;
-+  UInt64 processed;
-+  SRes res;
-+} CRangeEnc;
-+
-+typedef struct
-+{
-+  CLzmaProb *litProbs;
-+
-+  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
-+  CLzmaProb isRep[kNumStates];
-+  CLzmaProb isRepG0[kNumStates];
-+  CLzmaProb isRepG1[kNumStates];
-+  CLzmaProb isRepG2[kNumStates];
-+  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];
-+
-+  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 << kNumPosSlotBits];
-+  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
-+  CLzmaProb posAlignEncoder[1 << kNumAlignBits];
-+  
-+  CLenPriceEnc lenEnc;
-+  CLenPriceEnc repLenEnc;
-+
-+  UInt32 reps[LZMA_NUM_REPS];
-+  UInt32 state;
-+} CSaveState;
-+
-+typedef struct
-+{
-+  IMatchFinder matchFinder;
-+  void *matchFinderObj;
-+
-+  #ifndef _7ZIP_ST
-+  Bool mtMode;
-+  CMatchFinderMt matchFinderMt;
-+  #endif
-+
-+  CMatchFinder matchFinderBase;
-+
-+  #ifndef _7ZIP_ST
-+  Byte pad[128];
-+  #endif
-+  
-+  UInt32 optimumEndIndex;
-+  UInt32 optimumCurrentIndex;
-+
-+  UInt32 longestMatchLength;
-+  UInt32 numPairs;
-+  UInt32 numAvail;
-+  COptimal opt[kNumOpts];
-+  
-+  #ifndef LZMA_LOG_BSR
-+  Byte g_FastPos[1 << kNumLogBits];
-+  #endif
-+
-+  UInt32 ProbPrices[kBitModelTotal >> kNumMoveReducingBits];
-+  UInt32 matches[LZMA_MATCH_LEN_MAX * 2 + 2 + 1];
-+  UInt32 numFastBytes;
-+  UInt32 additionalOffset;
-+  UInt32 reps[LZMA_NUM_REPS];
-+  UInt32 state;
-+
-+  UInt32 posSlotPrices[kNumLenToPosStates][kDistTableSizeMax];
-+  UInt32 distancesPrices[kNumLenToPosStates][kNumFullDistances];
-+  UInt32 alignPrices[kAlignTableSize];
-+  UInt32 alignPriceCount;
-+
-+  UInt32 distTableSize;
-+
-+  unsigned lc, lp, pb;
-+  unsigned lpMask, pbMask;
-+
-+  CLzmaProb *litProbs;
-+
-+  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
-+  CLzmaProb isRep[kNumStates];
-+  CLzmaProb isRepG0[kNumStates];
-+  CLzmaProb isRepG1[kNumStates];
-+  CLzmaProb isRepG2[kNumStates];
-+  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];
-+
-+  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 << kNumPosSlotBits];
-+  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
-+  CLzmaProb posAlignEncoder[1 << kNumAlignBits];
-+  
-+  CLenPriceEnc lenEnc;
-+  CLenPriceEnc repLenEnc;
-+
-+  unsigned lclp;
-+
-+  Bool fastMode;
-+  
-+  CRangeEnc rc;
-+
-+  Bool writeEndMark;
-+  UInt64 nowPos64;
-+  UInt32 matchPriceCount;
-+  Bool finished;
-+  Bool multiThread;
-+
-+  SRes result;
-+  UInt32 dictSize;
-+  UInt32 matchFinderCycles;
-+
-+  int needInit;
-+
-+  CSaveState saveState;
-+} CLzmaEnc;
-+
-+void LzmaEnc_SaveState(CLzmaEncHandle pp)
-+{
-+  CLzmaEnc *p = (CLzmaEnc *)pp;
-+  CSaveState *dest = &p->saveState;
-+  int i;
-+  dest->lenEnc = p->lenEnc;
-+  dest->repLenEnc = p->repLenEnc;
-+  dest->state = p->state;
-+
-+  for (i = 0; i < kNumStates; i++)
-+  {
-+    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
-+    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
-+  }
-+  for (i = 0; i < kNumLenToPosStates; i++)
-+    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
-+  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
-+  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
-+  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
-+  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
-+  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
-+  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
-+  memcpy(dest->reps, p->reps, sizeof(p->reps));
-+  memcpy(dest->litProbs, p->litProbs, (0x300 << p->lclp) * sizeof(CLzmaProb));
-+}
-+
-+void LzmaEnc_RestoreState(CLzmaEncHandle pp)
-+{
-+  CLzmaEnc *dest = (CLzmaEnc *)pp;
-+  const CSaveState *p = &dest->saveState;
-+  int i;
-+  dest->lenEnc = p->lenEnc;
-+  dest->repLenEnc = p->repLenEnc;
-+  dest->state = p->state;
-+
-+  for (i = 0; i < kNumStates; i++)
-+  {
-+    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
-+    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
-+  }
-+  for (i = 0; i < kNumLenToPosStates; i++)
-+    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
-+  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
-+  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
-+  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
-+  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
-+  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
-+  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
-+  memcpy(dest->reps, p->reps, sizeof(p->reps));
-+  memcpy(dest->litProbs, p->litProbs, (0x300 << dest->lclp) * sizeof(CLzmaProb));
-+}
-+
-+SRes LzmaEnc_SetProps(CLzmaEncHandle pp, const CLzmaEncProps *props2)
-+{
-+  CLzmaEnc *p = (CLzmaEnc *)pp;
-+  CLzmaEncProps props = *props2;
-+  LzmaEncProps_Normalize(&props);
-+
-+  if (props.lc > LZMA_LC_MAX || props.lp > LZMA_LP_MAX || props.pb > LZMA_PB_MAX ||
-+      props.dictSize > (1 << kDicLogSizeMaxCompress) || props.dictSize > (1 << 30))
-+    return SZ_ERROR_PARAM;
-+  p->dictSize = props.dictSize;
-+  p->matchFinderCycles = props.mc;
-+  {
-+    unsigned fb = props.fb;
-+    if (fb < 5)
-+      fb = 5;
-+    if (fb > LZMA_MATCH_LEN_MAX)
-+      fb = LZMA_MATCH_LEN_MAX;
-+    p->numFastBytes = fb;
-+  }
-+  p->lc = props.lc;
-+  p->lp = props.lp;
-+  p->pb = props.pb;
-+  p->fastMode = (props.algo == 0);
-+  p->matchFinderBase.btMode = props.btMode;
-+  {
-+    UInt32 numHashBytes = 4;
-+    if (props.btMode)
-+    {
-+      if (props.numHashBytes < 2)
-+        numHashBytes = 2;
-+      else if (props.numHashBytes < 4)
-+        numHashBytes = props.numHashBytes;
-+    }
-+    p->matchFinderBase.numHashBytes = numHashBytes;
-+  }
-+
-+  p->matchFinderBase.cutValue = props.mc;
-+
-+  p->writeEndMark = props.writeEndMark;
-+
-+  #ifndef _7ZIP_ST
-+  /*
-+  if (newMultiThread != _multiThread)
-+  {
-+    ReleaseMatchFinder();
-+    _multiThread = newMultiThread;
-+  }
-+  */
-+  p->multiThread = (props.numThreads > 1);
-+  #endif
-+
-+  return SZ_OK;
-+}
-+
-+static const int kLiteralNextStates[kNumStates] = {0, 0, 0, 0, 1, 2, 3, 4,  5,  6,   4, 5};
-+static const int kMatchNextStates[kNumStates]   = {7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10};
-+static const int kRepNextStates[kNumStates]     = {8, 8, 8, 8, 8, 8, 8, 11, 11, 11, 11, 11};
-+static const int kShortRepNextStates[kNumStates]= {9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11};
-+
-+#define IsCharState(s) ((s) < 7)
-+
-+#define GetLenToPosState(len) (((len) < kNumLenToPosStates + 1) ? (len) - 2 : kNumLenToPosStates - 1)
-+
-+#define kInfinityPrice (1 << 30)
-+
-+static void RangeEnc_Construct(CRangeEnc *p)
-+{
-+  p->outStream = 0;
-+  p->bufBase = 0;
-+}
-+
-+#define RangeEnc_GetProcessed(p) ((p)->processed + ((p)->buf - (p)->bufBase) + (p)->cacheSize)
-+
-+#define RC_BUF_SIZE (1 << 16)
-+static int RangeEnc_Alloc(CRangeEnc *p, ISzAlloc *alloc)
-+{
-+  if (p->bufBase == 0)
-+  {
-+    p->bufBase = (Byte *)alloc->Alloc(alloc, RC_BUF_SIZE);
-+    if (p->bufBase == 0)
-+      return 0;
-+    p->bufLim = p->bufBase + RC_BUF_SIZE;
-+  }
-+  return 1;
-+}
-+
-+static void RangeEnc_Free(CRangeEnc *p, ISzAlloc *alloc)
-+{
-+  alloc->Free(alloc, p->bufBase);
-+  p->bufBase = 0;
-+}
-+
-+static void RangeEnc_Init(CRangeEnc *p)
-+{
-+  /* Stream.Init(); */
-+  p->low = 0;
-+  p->range = 0xFFFFFFFF;
-+  p->cacheSize = 1;
-+  p->cache = 0;
-+
-+  p->buf = p->bufBase;
-+
-+  p->processed = 0;
-+  p->res = SZ_OK;
-+}
-+
-+static void RangeEnc_FlushStream(CRangeEnc *p)
-+{
-+  size_t num;
-+  if (p->res != SZ_OK)
-+    return;
-+  num = p->buf - p->bufBase;
-+  if (num != p->outStream->Write(p->outStream, p->bufBase, num))
-+    p->res = SZ_ERROR_WRITE;
-+  p->processed += num;
-+  p->buf = p->bufBase;
-+}
-+
-+static void MY_FAST_CALL RangeEnc_ShiftLow(CRangeEnc *p)
-+{
-+  if ((UInt32)p->low < (UInt32)0xFF000000 || (int)(p->low >> 32) != 0)
-+  {
-+    Byte temp = p->cache;
-+    do
-+    {
-+      Byte *buf = p->buf;
-+      *buf++ = (Byte)(temp + (Byte)(p->low >> 32));
-+      p->buf = buf;
-+      if (buf == p->bufLim)
-+        RangeEnc_FlushStream(p);
-+      temp = 0xFF;
-+    }
-+    while (--p->cacheSize != 0);
-+    p->cache = (Byte)((UInt32)p->low >> 24);
-+  }
-+  p->cacheSize++;
-+  p->low = (UInt32)p->low << 8;
-+}
-+
-+static void RangeEnc_FlushData(CRangeEnc *p)
-+{
-+  int i;
-+  for (i = 0; i < 5; i++)
-+    RangeEnc_ShiftLow(p);
-+}
-+
-+static void RangeEnc_EncodeDirectBits(CRangeEnc *p, UInt32 value, int numBits)
-+{
-+  do
-+  {
-+    p->range >>= 1;
-+    p->low += p->range & (0 - ((value >> --numBits) & 1));
-+    if (p->range < kTopValue)
-+    {
-+      p->range <<= 8;
-+      RangeEnc_ShiftLow(p);
-+    }
-+  }
-+  while (numBits != 0);
-+}
-+
-+static void RangeEnc_EncodeBit(CRangeEnc *p, CLzmaProb *prob, UInt32 symbol)
-+{
-+  UInt32 ttt = *prob;
-+  UInt32 newBound = (p->range >> kNumBitModelTotalBits) * ttt;
-+  if (symbol == 0)
-+  {
-+    p->range = newBound;
-+    ttt += (kBitModelTotal - ttt) >> kNumMoveBits;
-+  }
-+  else
-+  {
-+    p->low += newBound;
-+    p->range -= newBound;
-+    ttt -= ttt >> kNumMoveBits;
-+  }
-+  *prob = (CLzmaProb)ttt;
-+  if (p->range < kTopValue)
-+  {
-+    p->range <<= 8;
-+    RangeEnc_ShiftLow(p);
-+  }
-+}
-+
-+static void LitEnc_Encode(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol)
-+{
-+  symbol |= 0x100;
-+  do
-+  {
-+    RangeEnc_EncodeBit(p, probs + (symbol >> 8), (symbol >> 7) & 1);
-+    symbol <<= 1;
-+  }
-+  while (symbol < 0x10000);
-+}
-+
-+static void LitEnc_EncodeMatched(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol, UInt32 matchByte)
-+{
-+  UInt32 offs = 0x100;
-+  symbol |= 0x100;
-+  do
-+  {
-+    matchByte <<= 1;
-+    RangeEnc_EncodeBit(p, probs + (offs + (matchByte & offs) + (symbol >> 8)), (symbol >> 7) & 1);
-+    symbol <<= 1;
-+    offs &= ~(matchByte ^ symbol);
-+  }
-+  while (symbol < 0x10000);
-+}
-+
-+void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
-+{
-+  UInt32 i;
-+  for (i = (1 << kNumMoveReducingBits) / 2; i < kBitModelTotal; i += (1 << kNumMoveReducingBits))
-+  {
-+    const int kCyclesBits = kNumBitPriceShiftBits;
-+    UInt32 w = i;
-+    UInt32 bitCount = 0;
-+    int j;
-+    for (j = 0; j < kCyclesBits; j++)
-+    {
-+      w = w * w;
-+      bitCount <<= 1;
-+      while (w >= ((UInt32)1 << 16))
-+      {
-+        w >>= 1;
-+        bitCount++;
-+      }
-+    }
-+    ProbPrices[i >> kNumMoveReducingBits] = ((kNumBitModelTotalBits << kCyclesBits) - 15 - bitCount);
-+  }
-+}
-+
-+
-+#define GET_PRICE(prob, symbol) \
-+  p->ProbPrices[((prob) ^ (((-(int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];
-+
-+#define GET_PRICEa(prob, symbol) \
-+  ProbPrices[((prob) ^ ((-((int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];
-+
-+#define GET_PRICE_0(prob) p->ProbPrices[(prob) >> kNumMoveReducingBits]
-+#define GET_PRICE_1(prob) p->ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]
-+
-+#define GET_PRICE_0a(prob) ProbPrices[(prob) >> kNumMoveReducingBits]
-+#define GET_PRICE_1a(prob) ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]
-+
-+static UInt32 LitEnc_GetPrice(const CLzmaProb *probs, UInt32 symbol, UInt32 *ProbPrices)
-+{
-+  UInt32 price = 0;
-+  symbol |= 0x100;
-+  do
-+  {
-+    price += GET_PRICEa(probs[symbol >> 8], (symbol >> 7) & 1);
-+    symbol <<= 1;
-+  }
-+  while (symbol < 0x10000);
-+  return price;
-+}
-+
-+static UInt32 LitEnc_GetPriceMatched(const CLzmaProb *probs, UInt32 symbol, UInt32 matchByte, UInt32 *ProbPrices)
-+{
-+  UInt32 price = 0;
-+  UInt32 offs = 0x100;
-+  symbol |= 0x100;
-+  do
-+  {
-+    matchByte <<= 1;
-+    price += GET_PRICEa(probs[offs + (matchByte & offs) + (symbol >> 8)], (symbol >> 7) & 1);
-+    symbol <<= 1;
-+    offs &= ~(matchByte ^ symbol);
-+  }
-+  while (symbol < 0x10000);
-+  return price;
-+}
-+
-+
-+static void RcTree_Encode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
-+{
-+  UInt32 m = 1;
-+  int i;
-+  for (i = numBitLevels; i != 0;)
-+  {
-+    UInt32 bit;
-+    i--;
-+    bit = (symbol >> i) & 1;
-+    RangeEnc_EncodeBit(rc, probs + m, bit);
-+    m = (m << 1) | bit;
-+  }
-+}
-+
-+static void RcTree_ReverseEncode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
-+{
-+  UInt32 m = 1;
-+  int i;
-+  for (i = 0; i < numBitLevels; i++)
-+  {
-+    UInt32 bit = symbol & 1;
-+    RangeEnc_EncodeBit(rc, probs + m, bit);
-+    m = (m << 1) | bit;
-+    symbol >>= 1;
-+  }
-+}
-+
-+static UInt32 RcTree_GetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
-+{
-+  UInt32 price = 0;
-+  symbol |= (1 << numBitLevels);
-+  while (symbol != 1)
-+  {
-+    price += GET_PRICEa(probs[symbol >> 1], symbol & 1);
-+    symbol >>= 1;
-+  }
-+  return price;
-+}
-+
-+static UInt32 RcTree_ReverseGetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
-+{
-+  UInt32 price = 0;
-+  UInt32 m = 1;
-+  int i;
-+  for (i = numBitLevels; i != 0; i--)
-+  {
-+    UInt32 bit = symbol & 1;
-+    symbol >>= 1;
-+    price += GET_PRICEa(probs[m], bit);
-+    m = (m << 1) | bit;
-+  }
-+  return price;
-+}
-+
-+
-+static void LenEnc_Init(CLenEnc *p)
-+{
-+  unsigned i;
-+  p->choice = p->choice2 = kProbInitValue;
-+  for (i = 0; i < (LZMA_NUM_PB_STATES_MAX << kLenNumLowBits); i++)
-+    p->low[i] = kProbInitValue;
-+  for (i = 0; i < (LZMA_NUM_PB_STATES_MAX << kLenNumMidBits); i++)
-+    p->mid[i] = kProbInitValue;
-+  for (i = 0; i < kLenNumHighSymbols; i++)
-+    p->high[i] = kProbInitValue;
-+}
-+
-+static void LenEnc_Encode(CLenEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState)
-+{
-+  if (symbol < kLenNumLowSymbols)
-+  {
-+    RangeEnc_EncodeBit(rc, &p->choice, 0);
-+    RcTree_Encode(rc, p->low + (posState << kLenNumLowBits), kLenNumLowBits, symbol);
-+  }
-+  else
-+  {
-+    RangeEnc_EncodeBit(rc, &p->choice, 1);
-+    if (symbol < kLenNumLowSymbols + kLenNumMidSymbols)
-+    {
-+      RangeEnc_EncodeBit(rc, &p->choice2, 0);
-+      RcTree_Encode(rc, p->mid + (posState << kLenNumMidBits), kLenNumMidBits, symbol - kLenNumLowSymbols);
-+    }
-+    else
-+    {
-+      RangeEnc_EncodeBit(rc, &p->choice2, 1);
-+      RcTree_Encode(rc, p->high, kLenNumHighBits, symbol - kLenNumLowSymbols - kLenNumMidSymbols);
-+    }
-+  }
-+}
-+
-+static void LenEnc_SetPrices(CLenEnc *p, UInt32 posState, UInt32 numSymbols, UInt32 *prices, UInt32 *ProbPrices)
-+{
-+  UInt32 a0 = GET_PRICE_0a(p->choice);
-+  UInt32 a1 = GET_PRICE_1a(p->choice);
-+  UInt32 b0 = a1 + GET_PRICE_0a(p->choice2);
-+  UInt32 b1 = a1 + GET_PRICE_1a(p->choice2);
-+  UInt32 i = 0;
-+  for (i = 0; i < kLenNumLowSymbols; i++)
-+  {
-+    if (i >= numSymbols)
-+      return;
-+    prices[i] = a0 + RcTree_GetPrice(p->low + (posState << kLenNumLowBits), kLenNumLowBits, i, ProbPrices);
-+  }
-+  for (; i < kLenNumLowSymbols + kLenNumMidSymbols; i++)
-+  {
-+    if (i >= numSymbols)
-+      return;
-+    prices[i] = b0 + RcTree_GetPrice(p->mid + (posState << kLenNumMidBits), kLenNumMidBits, i - kLenNumLowSymbols, ProbPrices);
-+  }
-+  for (; i < numSymbols; i++)
-+    prices[i] = b1 + RcTree_GetPrice(p->high, kLenNumHighBits, i - kLenNumLowSymbols - kLenNumMidSymbols, ProbPrices);
-+}
-+
-+static void MY_FAST_CALL LenPriceEnc_UpdateTable(CLenPriceEnc *p, UInt32 posState, UInt32 *ProbPrices)
-+{
-+  LenEnc_SetPrices(&p->p, posState, p->tableSize, p->prices[posState], ProbPrices);
-+  p->counters[posState] = p->tableSize;
-+}
-+
-+static void LenPriceEnc_UpdateTables(CLenPriceEnc *p, UInt32 numPosStates, UInt32 *ProbPrices)
-+{
-+  UInt32 posState;
-+  for (posState = 0; posState < numPosStates; posState++)
-+    LenPriceEnc_UpdateTable(p, posState, ProbPrices);
-+}
-+
-+static void LenEnc_Encode2(CLenPriceEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState, Bool updatePrice, UInt32 *ProbPrices)
-+{
-+  LenEnc_Encode(&p->p, rc, symbol, posState);
-+  if (updatePrice)
-+    if (--p->counters[posState] == 0)
-+      LenPriceEnc_UpdateTable(p, posState, ProbPrices);
-+}
-+
-+
-+
-+
-+static void MovePos(CLzmaEnc *p, UInt32 num)
-+{
-+  #ifdef SHOW_STAT
-+  ttt += num;
-+  printf("\n MovePos %d", num);
-+  #endif
-+  if (num != 0)
-+  {
-+    p->additionalOffset += num;
-+    p->matchFinder.Skip(p->matchFinderObj, num);
-+  }
-+}
-+
-+static UInt32 ReadMatchDistances(CLzmaEnc *p, UInt32 *numDistancePairsRes)
-+{
-+  UInt32 lenRes = 0, numPairs;
-+  p->numAvail = p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
-+  numPairs = p->matchFinder.GetMatches(p->matchFinderObj, p->matches);
-+  #ifdef SHOW_STAT
-+  printf("\n i = %d numPairs = %d    ", ttt, numPairs / 2);
-+  ttt++;
-+  {
-+    UInt32 i;
-+    for (i = 0; i < numPairs; i += 2)
-+      printf("%2d %6d   | ", p->matches[i], p->matches[i + 1]);
-+  }
-+  #endif
-+  if (numPairs > 0)
-+  {
-+    lenRes = p->matches[numPairs - 2];
-+    if (lenRes == p->numFastBytes)
-+    {
-+      const Byte *pby = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
-+      UInt32 distance = p->matches[numPairs - 1] + 1;
-+      UInt32 numAvail = p->numAvail;
-+      if (numAvail > LZMA_MATCH_LEN_MAX)
-+        numAvail = LZMA_MATCH_LEN_MAX;
-+      {
-+        const Byte *pby2 = pby - distance;
-+        for (; lenRes < numAvail && pby[lenRes] == pby2[lenRes]; lenRes++);
-+      }
-+    }
-+  }
-+  p->additionalOffset++;
-+  *numDistancePairsRes = numPairs;
-+  return lenRes;
-+}
-+
-+
-+#define MakeAsChar(p) (p)->backPrev = (UInt32)(-1); (p)->prev1IsChar = False;
-+#define MakeAsShortRep(p) (p)->backPrev = 0; (p)->prev1IsChar = False;
-+#define IsShortRep(p) ((p)->backPrev == 0)
-+
-+static UInt32 GetRepLen1Price(CLzmaEnc *p, UInt32 state, UInt32 posState)
-+{
-+  return
-+    GET_PRICE_0(p->isRepG0[state]) +
-+    GET_PRICE_0(p->isRep0Long[state][posState]);
-+}
-+
-+static UInt32 GetPureRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 state, UInt32 posState)
-+{
-+  UInt32 price;
-+  if (repIndex == 0)
-+  {
-+    price = GET_PRICE_0(p->isRepG0[state]);
-+    price += GET_PRICE_1(p->isRep0Long[state][posState]);
-+  }
-+  else
-+  {
-+    price = GET_PRICE_1(p->isRepG0[state]);
-+    if (repIndex == 1)
-+      price += GET_PRICE_0(p->isRepG1[state]);
-+    else
-+    {
-+      price += GET_PRICE_1(p->isRepG1[state]);
-+      price += GET_PRICE(p->isRepG2[state], repIndex - 2);
-+    }
-+  }
-+  return price;
-+}
-+
-+static UInt32 GetRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 len, UInt32 state, UInt32 posState)
-+{
-+  return p->repLenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN] +
-+    GetPureRepPrice(p, repIndex, state, posState);
-+}
-+
-+static UInt32 Backward(CLzmaEnc *p, UInt32 *backRes, UInt32 cur)
-+{
-+  UInt32 posMem = p->opt[cur].posPrev;
-+  UInt32 backMem = p->opt[cur].backPrev;
-+  p->optimumEndIndex = cur;
-+  do
-+  {
-+    if (p->opt[cur].prev1IsChar)
-+    {
-+      MakeAsChar(&p->opt[posMem])
-+      p->opt[posMem].posPrev = posMem - 1;
-+      if (p->opt[cur].prev2)
-+      {
-+        p->opt[posMem - 1].prev1IsChar = False;
-+        p->opt[posMem - 1].posPrev = p->opt[cur].posPrev2;
-+        p->opt[posMem - 1].backPrev = p->opt[cur].backPrev2;
-+      }
-+    }
-+    {
-+      UInt32 posPrev = posMem;
-+      UInt32 backCur = backMem;
-+      
-+      backMem = p->opt[posPrev].backPrev;
-+      posMem = p->opt[posPrev].posPrev;
-+      
-+      p->opt[posPrev].backPrev = backCur;
-+      p->opt[posPrev].posPrev = cur;
-+      cur = posPrev;
-+    }
-+  }
-+  while (cur != 0);
-+  *backRes = p->opt[0].backPrev;
-+  p->optimumCurrentIndex  = p->opt[0].posPrev;
-+  return p->optimumCurrentIndex;
-+}
-+
-+#define LIT_PROBS(pos, prevByte) (p->litProbs + ((((pos) & p->lpMask) << p->lc) + ((prevByte) >> (8 - p->lc))) * 0x300)
-+
-+static UInt32 GetOptimum(CLzmaEnc *p, UInt32 position, UInt32 *backRes)
-+{
-+  UInt32 numAvail, mainLen, numPairs, repMaxIndex, i, posState, lenEnd, len, cur;
-+  UInt32 matchPrice, repMatchPrice, normalMatchPrice;
-+  UInt32 reps[LZMA_NUM_REPS], repLens[LZMA_NUM_REPS];
-+  UInt32 *matches;
-+  const Byte *data;
-+  Byte curByte, matchByte;
-+  if (p->optimumEndIndex != p->optimumCurrentIndex)
-+  {
-+    const COptimal *opt = &p->opt[p->optimumCurrentIndex];
-+    UInt32 lenRes = opt->posPrev - p->optimumCurrentIndex;
-+    *backRes = opt->backPrev;
-+    p->optimumCurrentIndex = opt->posPrev;
-+    return lenRes;
-+  }
-+  p->optimumCurrentIndex = p->optimumEndIndex = 0;
-+  
-+  if (p->additionalOffset == 0)
-+    mainLen = ReadMatchDistances(p, &numPairs);
-+  else
-+  {
-+    mainLen = p->longestMatchLength;
-+    numPairs = p->numPairs;
-+  }
-+
-+  numAvail = p->numAvail;
-+  if (numAvail < 2)
-+  {
-+    *backRes = (UInt32)(-1);
-+    return 1;
-+  }
-+  if (numAvail > LZMA_MATCH_LEN_MAX)
-+    numAvail = LZMA_MATCH_LEN_MAX;
-+
-+  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
-+  repMaxIndex = 0;
-+  for (i = 0; i < LZMA_NUM_REPS; i++)
-+  {
-+    UInt32 lenTest;
-+    const Byte *data2;
-+    reps[i] = p->reps[i];
-+    data2 = data - (reps[i] + 1);
-+    if (data[0] != data2[0] || data[1] != data2[1])
-+    {
-+      repLens[i] = 0;
-+      continue;
-+    }
-+    for (lenTest = 2; lenTest < numAvail && data[lenTest] == data2[lenTest]; lenTest++);
-+    repLens[i] = lenTest;
-+    if (lenTest > repLens[repMaxIndex])
-+      repMaxIndex = i;
-+  }
-+  if (repLens[repMaxIndex] >= p->numFastBytes)
-+  {
-+    UInt32 lenRes;
-+    *backRes = repMaxIndex;
-+    lenRes = repLens[repMaxIndex];
-+    MovePos(p, lenRes - 1);
-+    return lenRes;
-+  }
-+
-+  matches = p->matches;
-+  if (mainLen >= p->numFastBytes)
-+  {
-+    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
-+    MovePos(p, mainLen - 1);
-+    return mainLen;
-+  }
-+  curByte = *data;
-+  matchByte = *(data - (reps[0] + 1));
-+
-+  if (mainLen < 2 && curByte != matchByte && repLens[repMaxIndex] < 2)
-+  {
-+    *backRes = (UInt32)-1;
-+    return 1;
-+  }
-+
-+  p->opt[0].state = (CState)p->state;
-+
-+  posState = (position & p->pbMask);
-+
-+  {
-+    const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
-+    p->opt[1].price = GET_PRICE_0(p->isMatch[p->state][posState]) +
-+        (!IsCharState(p->state) ?
-+          LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
-+          LitEnc_GetPrice(probs, curByte, p->ProbPrices));
-+  }
-+
-+  MakeAsChar(&p->opt[1]);
-+
-+  matchPrice = GET_PRICE_1(p->isMatch[p->state][posState]);
-+  repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[p->state]);
-+
-+  if (matchByte == curByte)
-+  {
-+    UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, p->state, posState);
-+    if (shortRepPrice < p->opt[1].price)
-+    {
-+      p->opt[1].price = shortRepPrice;
-+      MakeAsShortRep(&p->opt[1]);
-+    }
-+  }
-+  lenEnd = ((mainLen >= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);
-+
-+  if (lenEnd < 2)
-+  {
-+    *backRes = p->opt[1].backPrev;
-+    return 1;
-+  }
-+
-+  p->opt[1].posPrev = 0;
-+  for (i = 0; i < LZMA_NUM_REPS; i++)
-+    p->opt[0].backs[i] = reps[i];
-+
-+  len = lenEnd;
-+  do
-+    p->opt[len--].price = kInfinityPrice;
-+  while (len >= 2);
-+
-+  for (i = 0; i < LZMA_NUM_REPS; i++)
-+  {
-+    UInt32 repLen = repLens[i];
-+    UInt32 price;
-+    if (repLen < 2)
-+      continue;
-+    price = repMatchPrice + GetPureRepPrice(p, i, p->state, posState);
-+    do
-+    {
-+      UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][repLen - 2];
-+      COptimal *opt = &p->opt[repLen];
-+      if (curAndLenPrice < opt->price)
-+      {
-+        opt->price = curAndLenPrice;
-+        opt->posPrev = 0;
-+        opt->backPrev = i;
-+        opt->prev1IsChar = False;
-+      }
-+    }
-+    while (--repLen >= 2);
-+  }
-+
-+  normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[p->state]);
-+
-+  len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
-+  if (len <= mainLen)
-+  {
-+    UInt32 offs = 0;
-+    while (len > matches[offs])
-+      offs += 2;
-+    for (; ; len++)
-+    {
-+      COptimal *opt;
-+      UInt32 distance = matches[offs + 1];
-+
-+      UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN];
-+      UInt32 lenToPosState = GetLenToPosState(len);
-+      if (distance < kNumFullDistances)
-+        curAndLenPrice += p->distancesPrices[lenToPosState][distance];
-+      else
-+      {
-+        UInt32 slot;
-+        GetPosSlot2(distance, slot);
-+        curAndLenPrice += p->alignPrices[distance & kAlignMask] + p->posSlotPrices[lenToPosState][slot];
-+      }
-+      opt = &p->opt[len];
-+      if (curAndLenPrice < opt->price)
-+      {
-+        opt->price = curAndLenPrice;
-+        opt->posPrev = 0;
-+        opt->backPrev = distance + LZMA_NUM_REPS;
-+        opt->prev1IsChar = False;
-+      }
-+      if (len == matches[offs])
-+      {
-+        offs += 2;
-+        if (offs == numPairs)
-+          break;
-+      }
-+    }
-+  }
-+
-+  cur = 0;
-+
-+    #ifdef SHOW_STAT2
-+    if (position >= 0)
-+    {
-+      unsigned i;
-+      printf("\n pos = %4X", position);
-+      for (i = cur; i <= lenEnd; i++)
-+      printf("\nprice[%4X] = %d", position - cur + i, p->opt[i].price);
-+    }
-+    #endif
-+
-+  for (;;)
-+  {
-+    UInt32 numAvailFull, newLen, numPairs, posPrev, state, posState, startLen;
-+    UInt32 curPrice, curAnd1Price, matchPrice, repMatchPrice;
-+    Bool nextIsChar;
-+    Byte curByte, matchByte;
-+    const Byte *data;
-+    COptimal *curOpt;
-+    COptimal *nextOpt;
-+
-+    cur++;
-+    if (cur == lenEnd)
-+      return Backward(p, backRes, cur);
-+
-+    newLen = ReadMatchDistances(p, &numPairs);
-+    if (newLen >= p->numFastBytes)
-+    {
-+      p->numPairs = numPairs;
-+      p->longestMatchLength = newLen;
-+      return Backward(p, backRes, cur);
-+    }
-+    position++;
-+    curOpt = &p->opt[cur];
-+    posPrev = curOpt->posPrev;
-+    if (curOpt->prev1IsChar)
-+    {
-+      posPrev--;
-+      if (curOpt->prev2)
-+      {
-+        state = p->opt[curOpt->posPrev2].state;
-+        if (curOpt->backPrev2 < LZMA_NUM_REPS)
-+          state = kRepNextStates[state];
-+        else
-+          state = kMatchNextStates[state];
-+      }
-+      else
-+        state = p->opt[posPrev].state;
-+      state = kLiteralNextStates[state];
-+    }
-+    else
-+      state = p->opt[posPrev].state;
-+    if (posPrev == cur - 1)
-+    {
-+      if (IsShortRep(curOpt))
-+        state = kShortRepNextStates[state];
-+      else
-+        state = kLiteralNextStates[state];
-+    }
-+    else
-+    {
-+      UInt32 pos;
-+      const COptimal *prevOpt;
-+      if (curOpt->prev1IsChar && curOpt->prev2)
-+      {
-+        posPrev = curOpt->posPrev2;
-+        pos = curOpt->backPrev2;
-+        state = kRepNextStates[state];
-+      }
-+      else
-+      {
-+        pos = curOpt->backPrev;
-+        if (pos < LZMA_NUM_REPS)
-+          state = kRepNextStates[state];
-+        else
-+          state = kMatchNextStates[state];
-+      }
-+      prevOpt = &p->opt[posPrev];
-+      if (pos < LZMA_NUM_REPS)
-+      {
-+        UInt32 i;
-+        reps[0] = prevOpt->backs[pos];
-+        for (i = 1; i <= pos; i++)
-+          reps[i] = prevOpt->backs[i - 1];
-+        for (; i < LZMA_NUM_REPS; i++)
-+          reps[i] = prevOpt->backs[i];
-+      }
-+      else
-+      {
-+        UInt32 i;
-+        reps[0] = (pos - LZMA_NUM_REPS);
-+        for (i = 1; i < LZMA_NUM_REPS; i++)
-+          reps[i] = prevOpt->backs[i - 1];
-+      }
-+    }
-+    curOpt->state = (CState)state;
-+
-+    curOpt->backs[0] = reps[0];
-+    curOpt->backs[1] = reps[1];
-+    curOpt->backs[2] = reps[2];
-+    curOpt->backs[3] = reps[3];
-+
-+    curPrice = curOpt->price;
-+    nextIsChar = False;
-+    data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
-+    curByte = *data;
-+    matchByte = *(data - (reps[0] + 1));
-+
-+    posState = (position & p->pbMask);
-+
-+    curAnd1Price = curPrice + GET_PRICE_0(p->isMatch[state][posState]);
-+    {
-+      const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
-+      curAnd1Price +=
-+        (!IsCharState(state) ?
-+          LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
-+          LitEnc_GetPrice(probs, curByte, p->ProbPrices));
-+    }
-+
-+    nextOpt = &p->opt[cur + 1];
-+
-+    if (curAnd1Price < nextOpt->price)
-+    {
-+      nextOpt->price = curAnd1Price;
-+      nextOpt->posPrev = cur;
-+      MakeAsChar(nextOpt);
-+      nextIsChar = True;
-+    }
-+
-+    matchPrice = curPrice + GET_PRICE_1(p->isMatch[state][posState]);
-+    repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[state]);
-+    
-+    if (matchByte == curByte && !(nextOpt->posPrev < cur && nextOpt->backPrev == 0))
-+    {
-+      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, state, posState);
-+      if (shortRepPrice <= nextOpt->price)
-+      {
-+        nextOpt->price = shortRepPrice;
-+        nextOpt->posPrev = cur;
-+        MakeAsShortRep(nextOpt);
-+        nextIsChar = True;
-+      }
-+    }
-+    numAvailFull = p->numAvail;
-+    {
-+      UInt32 temp = kNumOpts - 1 - cur;
-+      if (temp < numAvailFull)
-+        numAvailFull = temp;
-+    }
-+
-+    if (numAvailFull < 2)
-+      continue;
-+    numAvail = (numAvailFull <= p->numFastBytes ? numAvailFull : p->numFastBytes);
-+
-+    if (!nextIsChar && matchByte != curByte) /* speed optimization */
-+    {
-+      /* try Literal + rep0 */
-+      UInt32 temp;
-+      UInt32 lenTest2;
-+      const Byte *data2 = data - (reps[0] + 1);
-+      UInt32 limit = p->numFastBytes + 1;
-+      if (limit > numAvailFull)
-+        limit = numAvailFull;
-+
-+      for (temp = 1; temp < limit && data[temp] == data2[temp]; temp++);
-+      lenTest2 = temp - 1;
-+      if (lenTest2 >= 2)
-+      {
-+        UInt32 state2 = kLiteralNextStates[state];
-+        UInt32 posStateNext = (position + 1) & p->pbMask;
-+        UInt32 nextRepMatchPrice = curAnd1Price +
-+            GET_PRICE_1(p->isMatch[state2][posStateNext]) +
-+            GET_PRICE_1(p->isRep[state2]);
-+        /* for (; lenTest2 >= 2; lenTest2--) */
-+        {
-+          UInt32 curAndLenPrice;
-+          COptimal *opt;
-+          UInt32 offset = cur + 1 + lenTest2;
-+          while (lenEnd < offset)
-+            p->opt[++lenEnd].price = kInfinityPrice;
-+          curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
-+          opt = &p->opt[offset];
-+          if (curAndLenPrice < opt->price)
-+          {
-+            opt->price = curAndLenPrice;
-+            opt->posPrev = cur + 1;
-+            opt->backPrev = 0;
-+            opt->prev1IsChar = True;
-+            opt->prev2 = False;
-+          }
-+        }
-+      }
-+    }
-+    
-+    startLen = 2; /* speed optimization */
-+    {
-+    UInt32 repIndex;
-+    for (repIndex = 0; repIndex < LZMA_NUM_REPS; repIndex++)
-+    {
-+      UInt32 lenTest;
-+      UInt32 lenTestTemp;
-+      UInt32 price;
-+      const Byte *data2 = data - (reps[repIndex] + 1);
-+      if (data[0] != data2[0] || data[1] != data2[1])
-+        continue;
-+      for (lenTest = 2; lenTest < numAvail && data[lenTest] == data2[lenTest]; lenTest++);
-+      while (lenEnd < cur + lenTest)
-+        p->opt[++lenEnd].price = kInfinityPrice;
-+      lenTestTemp = lenTest;
-+      price = repMatchPrice + GetPureRepPrice(p, repIndex, state, posState);
-+      do
-+      {
-+        UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][lenTest - 2];
-+        COptimal *opt = &p->opt[cur + lenTest];
-+        if (curAndLenPrice < opt->price)
-+        {
-+          opt->price = curAndLenPrice;
-+          opt->posPrev = cur;
-+          opt->backPrev = repIndex;
-+          opt->prev1IsChar = False;
-+        }
-+      }
-+      while (--lenTest >= 2);
-+      lenTest = lenTestTemp;
-+      
-+      if (repIndex == 0)
-+        startLen = lenTest + 1;
-+        
-+      /* if (_maxMode) */
-+        {
-+          UInt32 lenTest2 = lenTest + 1;
-+          UInt32 limit = lenTest2 + p->numFastBytes;
-+          UInt32 nextRepMatchPrice;
-+          if (limit > numAvailFull)
-+            limit = numAvailFull;
-+          for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
-+          lenTest2 -= lenTest + 1;
-+          if (lenTest2 >= 2)
-+          {
-+            UInt32 state2 = kRepNextStates[state];
-+            UInt32 posStateNext = (position + lenTest) & p->pbMask;
-+            UInt32 curAndLenCharPrice =
-+                price + p->repLenEnc.prices[posState][lenTest - 2] +
-+                GET_PRICE_0(p->isMatch[state2][posStateNext]) +
-+                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
-+                    data[lenTest], data2[lenTest], p->ProbPrices);
-+            state2 = kLiteralNextStates[state2];
-+            posStateNext = (position + lenTest + 1) & p->pbMask;
-+            nextRepMatchPrice = curAndLenCharPrice +
-+                GET_PRICE_1(p->isMatch[state2][posStateNext]) +
-+                GET_PRICE_1(p->isRep[state2]);
-+            
-+            /* for (; lenTest2 >= 2; lenTest2--) */
-+            {
-+              UInt32 curAndLenPrice;
-+              COptimal *opt;
-+              UInt32 offset = cur + lenTest + 1 + lenTest2;
-+              while (lenEnd < offset)
-+                p->opt[++lenEnd].price = kInfinityPrice;
-+              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
-+              opt = &p->opt[offset];
-+              if (curAndLenPrice < opt->price)
-+              {
-+                opt->price = curAndLenPrice;
-+                opt->posPrev = cur + lenTest + 1;
-+                opt->backPrev = 0;
-+                opt->prev1IsChar = True;
-+                opt->prev2 = True;
-+                opt->posPrev2 = cur;
-+                opt->backPrev2 = repIndex;
-+              }
-+            }
-+          }
-+        }
-+    }
-+    }
-+    /* for (UInt32 lenTest = 2; lenTest <= newLen; lenTest++) */
-+    if (newLen > numAvail)
-+    {
-+      newLen = numAvail;
-+      for (numPairs = 0; newLen > matches[numPairs]; numPairs += 2);
-+      matches[numPairs] = newLen;
-+      numPairs += 2;
-+    }
-+    if (newLen >= startLen)
-+    {
-+      UInt32 normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[state]);
-+      UInt32 offs, curBack, posSlot;
-+      UInt32 lenTest;
-+      while (lenEnd < cur + newLen)
-+        p->opt[++lenEnd].price = kInfinityPrice;
-+
-+      offs = 0;
-+      while (startLen > matches[offs])
-+        offs += 2;
-+      curBack = matches[offs + 1];
-+      GetPosSlot2(curBack, posSlot);
-+      for (lenTest = /*2*/ startLen; ; lenTest++)
-+      {
-+        UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][lenTest - LZMA_MATCH_LEN_MIN];
-+        UInt32 lenToPosState = GetLenToPosState(lenTest);
-+        COptimal *opt;
-+        if (curBack < kNumFullDistances)
-+          curAndLenPrice += p->distancesPrices[lenToPosState][curBack];
-+        else
-+          curAndLenPrice += p->posSlotPrices[lenToPosState][posSlot] + p->alignPrices[curBack & kAlignMask];
-+        
-+        opt = &p->opt[cur + lenTest];
-+        if (curAndLenPrice < opt->price)
-+        {
-+          opt->price = curAndLenPrice;
-+          opt->posPrev = cur;
-+          opt->backPrev = curBack + LZMA_NUM_REPS;
-+          opt->prev1IsChar = False;
-+        }
-+
-+        if (/*_maxMode && */lenTest == matches[offs])
-+        {
-+          /* Try Match + Literal + Rep0 */
-+          const Byte *data2 = data - (curBack + 1);
-+          UInt32 lenTest2 = lenTest + 1;
-+          UInt32 limit = lenTest2 + p->numFastBytes;
-+          UInt32 nextRepMatchPrice;
-+          if (limit > numAvailFull)
-+            limit = numAvailFull;
-+          for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
-+          lenTest2 -= lenTest + 1;
-+          if (lenTest2 >= 2)
-+          {
-+            UInt32 state2 = kMatchNextStates[state];
-+            UInt32 posStateNext = (position + lenTest) & p->pbMask;
-+            UInt32 curAndLenCharPrice = curAndLenPrice +
-+                GET_PRICE_0(p->isMatch[state2][posStateNext]) +
-+                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
-+                    data[lenTest], data2[lenTest], p->ProbPrices);
-+            state2 = kLiteralNextStates[state2];
-+            posStateNext = (posStateNext + 1) & p->pbMask;
-+            nextRepMatchPrice = curAndLenCharPrice +
-+                GET_PRICE_1(p->isMatch[state2][posStateNext]) +
-+                GET_PRICE_1(p->isRep[state2]);
-+            
-+            /* for (; lenTest2 >= 2; lenTest2--) */
-+            {
-+              UInt32 offset = cur + lenTest + 1 + lenTest2;
-+              UInt32 curAndLenPrice;
-+              COptimal *opt;
-+              while (lenEnd < offset)
-+                p->opt[++lenEnd].price = kInfinityPrice;
-+              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
-+              opt = &p->opt[offset];
-+              if (curAndLenPrice < opt->price)
-+              {
-+                opt->price = curAndLenPrice;
-+                opt->posPrev = cur + lenTest + 1;
-+                opt->backPrev = 0;
-+                opt->prev1IsChar = True;
-+                opt->prev2 = True;
-+                opt->posPrev2 = cur;
-+                opt->backPrev2 = curBack + LZMA_NUM_REPS;
-+              }
-+            }
-+          }
-+          offs += 2;
-+          if (offs == numPairs)
-+            break;
-+          curBack = matches[offs + 1];
-+          if (curBack >= kNumFullDistances)
-+            GetPosSlot2(curBack, posSlot);
-+        }
-+      }
-+    }
-+  }
-+}
-+
-+#define ChangePair(smallDist, bigDist) (((bigDist) >> 7) > (smallDist))
-+
-+static UInt32 GetOptimumFast(CLzmaEnc *p, UInt32 *backRes)
-+{
-+  UInt32 numAvail, mainLen, mainDist, numPairs, repIndex, repLen, i;
-+  const Byte *data;
-+  const UInt32 *matches;
-+
-+  if (p->additionalOffset == 0)
-+    mainLen = ReadMatchDistances(p, &numPairs);
-+  else
-+  {
-+    mainLen = p->longestMatchLength;
-+    numPairs = p->numPairs;
-+  }
-+
-+  numAvail = p->numAvail;
-+  *backRes = (UInt32)-1;
-+  if (numAvail < 2)
-+    return 1;
-+  if (numAvail > LZMA_MATCH_LEN_MAX)
-+    numAvail = LZMA_MATCH_LEN_MAX;
-+  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
-+
-+  repLen = repIndex = 0;
-+  for (i = 0; i < LZMA_NUM_REPS; i++)
-+  {
-+    UInt32 len;
-+    const Byte *data2 = data - (p->reps[i] + 1);
-+    if (data[0] != data2[0] || data[1] != data2[1])
-+      continue;
-+    for (len = 2; len < numAvail && data[len] == data2[len]; len++);
-+    if (len >= p->numFastBytes)
-+    {
-+      *backRes = i;
-+      MovePos(p, len - 1);
-+      return len;
-+    }
-+    if (len > repLen)
-+    {
-+      repIndex = i;
-+      repLen = len;
-+    }
-+  }
-+
-+  matches = p->matches;
-+  if (mainLen >= p->numFastBytes)
-+  {
-+    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
-+    MovePos(p, mainLen - 1);
-+    return mainLen;
-+  }
-+
-+  mainDist = 0; /* for GCC */
-+  if (mainLen >= 2)
-+  {
-+    mainDist = matches[numPairs - 1];
-+    while (numPairs > 2 && mainLen == matches[numPairs - 4] + 1)
-+    {
-+      if (!ChangePair(matches[numPairs - 3], mainDist))
-+        break;
-+      numPairs -= 2;
-+      mainLen = matches[numPairs - 2];
-+      mainDist = matches[numPairs - 1];
-+    }
-+    if (mainLen == 2 && mainDist >= 0x80)
-+      mainLen = 1;
-+  }
-+
-+  if (repLen >= 2 && (
-+        (repLen + 1 >= mainLen) ||
-+        (repLen + 2 >= mainLen && mainDist >= (1 << 9)) ||
-+        (repLen + 3 >= mainLen && mainDist >= (1 << 15))))
-+  {
-+    *backRes = repIndex;
-+    MovePos(p, repLen - 1);
-+    return repLen;
-+  }
-+  
-+  if (mainLen < 2 || numAvail <= 2)
-+    return 1;
-+
-+  p->longestMatchLength = ReadMatchDistances(p, &p->numPairs);
-+  if (p->longestMatchLength >= 2)
-+  {
-+    UInt32 newDistance = matches[p->numPairs - 1];
-+    if ((p->longestMatchLength >= mainLen && newDistance < mainDist) ||
-+        (p->longestMatchLength == mainLen + 1 && !ChangePair(mainDist, newDistance)) ||
-+        (p->longestMatchLength > mainLen + 1) ||
-+        (p->longestMatchLength + 1 >= mainLen && mainLen >= 3 && ChangePair(newDistance, mainDist)))
-+      return 1;
-+  }
-+  
-+  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
-+  for (i = 0; i < LZMA_NUM_REPS; i++)
-+  {
-+    UInt32 len, limit;
-+    const Byte *data2 = data - (p->reps[i] + 1);
-+    if (data[0] != data2[0] || data[1] != data2[1])
-+      continue;
-+    limit = mainLen - 1;
-+    for (len = 2; len < limit && data[len] == data2[len]; len++);
-+    if (len >= limit)
-+      return 1;
-+  }
-+  *backRes = mainDist + LZMA_NUM_REPS;
-+  MovePos(p, mainLen - 2);
-+  return mainLen;
-+}
-+
-+static void WriteEndMarker(CLzmaEnc *p, UInt32 posState)
-+{
-+  UInt32 len;
-+  RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 1);
-+  RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 0);
-+  p->state = kMatchNextStates[p->state];
-+  len = LZMA_MATCH_LEN_MIN;
-+  LenEnc_Encode2(&p->lenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
-+  RcTree_Encode(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, (1 << kNumPosSlotBits) - 1);
-+  RangeEnc_EncodeDirectBits(&p->rc, (((UInt32)1 << 30) - 1) >> kNumAlignBits, 30 - kNumAlignBits);
-+  RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, kAlignMask);
-+}
-+
-+static SRes CheckErrors(CLzmaEnc *p)
-+{
-+  if (p->result != SZ_OK)
-+    return p->result;
-+  if (p->rc.res != SZ_OK)
-+    p->result = SZ_ERROR_WRITE;
-+  if (p->matchFinderBase.result != SZ_OK)
-+    p->result = SZ_ERROR_READ;
-+  if (p->result != SZ_OK)
-+    p->finished = True;
-+  return p->result;
-+}
-+
-+static SRes Flush(CLzmaEnc *p, UInt32 nowPos)
-+{
-+  /* ReleaseMFStream(); */
-+  p->finished = True;
-+  if (p->writeEndMark)
-+    WriteEndMarker(p, nowPos & p->pbMask);
-+  RangeEnc_FlushData(&p->rc);
-+  RangeEnc_FlushStream(&p->rc);
-+  return CheckErrors(p);
-+}
-+
-+static void FillAlignPrices(CLzmaEnc *p)
-+{
-+  UInt32 i;
-+  for (i = 0; i < kAlignTableSize; i++)
-+    p->alignPrices[i] = RcTree_ReverseGetPrice(p->posAlignEncoder, kNumAlignBits, i, p->ProbPrices);
-+  p->alignPriceCount = 0;
-+}
-+
-+static void FillDistancesPrices(CLzmaEnc *p)
-+{
-+  UInt32 tempPrices[kNumFullDistances];
-+  UInt32 i, lenToPosState;
-+  for (i = kStartPosModelIndex; i < kNumFullDistances; i++)
-+  {
-+    UInt32 posSlot = GetPosSlot1(i);
-+    UInt32 footerBits = ((posSlot >> 1) - 1);
-+    UInt32 base = ((2 | (posSlot & 1)) << footerBits);
-+    tempPrices[i] = RcTree_ReverseGetPrice(p->posEncoders + base - posSlot - 1, footerBits, i - base, p->ProbPrices);
-+  }
-+
-+  for (lenToPosState = 0; lenToPosState < kNumLenToPosStates; lenToPosState++)
-+  {
-+    UInt32 posSlot;
-+    const CLzmaProb *encoder = p->posSlotEncoder[lenToPosState];
-+    UInt32 *posSlotPrices = p->posSlotPrices[lenToPosState];
-+    for (posSlot = 0; posSlot < p->distTableSize; posSlot++)
-+      posSlotPrices[posSlot] = RcTree_GetPrice(encoder, kNumPosSlotBits, posSlot, p->ProbPrices);
-+    for (posSlot = kEndPosModelIndex; posSlot < p->distTableSize; posSlot++)
-+      posSlotPrices[posSlot] += ((((posSlot >> 1) - 1) - kNumAlignBits) << kNumBitPriceShiftBits);
-+
-+    {
-+      UInt32 *distancesPrices = p->distancesPrices[lenToPosState];
-+      UInt32 i;
-+      for (i = 0; i < kStartPosModelIndex; i++)
-+        distancesPrices[i] = posSlotPrices[i];
-+      for (; i < kNumFullDistances; i++)
-+        distancesPrices[i] = posSlotPrices[GetPosSlot1(i)] + tempPrices[i];
-+    }
-+  }
-+  p->matchPriceCount = 0;
-+}
-+
-+void LzmaEnc_Construct(CLzmaEnc *p)
-+{
-+  RangeEnc_Construct(&p->rc);
-+  MatchFinder_Construct(&p->matchFinderBase);
-+  #ifndef _7ZIP_ST
-+  MatchFinderMt_Construct(&p->matchFinderMt);
-+  p->matchFinderMt.MatchFinder = &p->matchFinderBase;
-+  #endif
-+
-+  {
-+    CLzmaEncProps props;
-+    LzmaEncProps_Init(&props);
-+    LzmaEnc_SetProps(p, &props);
-+  }
-+
-+  #ifndef LZMA_LOG_BSR
-+  LzmaEnc_FastPosInit(p->g_FastPos);
-+  #endif
-+
-+  LzmaEnc_InitPriceTables(p->ProbPrices);
-+  p->litProbs = 0;
-+  p->saveState.litProbs = 0;
-+}
-+
-+CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc)
-+{
-+  void *p;
-+  p = alloc->Alloc(alloc, sizeof(CLzmaEnc));
-+  if (p != 0)
-+    LzmaEnc_Construct((CLzmaEnc *)p);
-+  return p;
-+}
-+
-+void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
-+{
-+  alloc->Free(alloc, p->litProbs);
-+  alloc->Free(alloc, p->saveState.litProbs);
-+  p->litProbs = 0;
-+  p->saveState.litProbs = 0;
-+}
-+
-+void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  #ifndef _7ZIP_ST
-+  MatchFinderMt_Destruct(&p->matchFinderMt, allocBig);
-+  #endif
-+  MatchFinder_Free(&p->matchFinderBase, allocBig);
-+  LzmaEnc_FreeLits(p, alloc);
-+  RangeEnc_Free(&p->rc, alloc);
-+}
-+
-+void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  LzmaEnc_Destruct((CLzmaEnc *)p, alloc, allocBig);
-+  alloc->Free(alloc, p);
-+}
-+
-+static SRes LzmaEnc_CodeOneBlock(CLzmaEnc *p, Bool useLimits, UInt32 maxPackSize, UInt32 maxUnpackSize)
-+{
-+  UInt32 nowPos32, startPos32;
-+  if (p->needInit)
-+  {
-+    p->matchFinder.Init(p->matchFinderObj);
-+    p->needInit = 0;
-+  }
-+
-+  if (p->finished)
-+    return p->result;
-+  RINOK(CheckErrors(p));
-+
-+  nowPos32 = (UInt32)p->nowPos64;
-+  startPos32 = nowPos32;
-+
-+  if (p->nowPos64 == 0)
-+  {
-+    UInt32 numPairs;
-+    Byte curByte;
-+    if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
-+      return Flush(p, nowPos32);
-+    ReadMatchDistances(p, &numPairs);
-+    RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][0], 0);
-+    p->state = kLiteralNextStates[p->state];
-+    curByte = p->matchFinder.GetIndexByte(p->matchFinderObj, 0 - p->additionalOffset);
-+    LitEnc_Encode(&p->rc, p->litProbs, curByte);
-+    p->additionalOffset--;
-+    nowPos32++;
-+  }
-+
-+  if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) != 0)
-+  for (;;)
-+  {
-+    UInt32 pos, len, posState;
-+
-+    if (p->fastMode)
-+      len = GetOptimumFast(p, &pos);
-+    else
-+      len = GetOptimum(p, nowPos32, &pos);
-+
-+    #ifdef SHOW_STAT2
-+    printf("\n pos = %4X,   len = %d   pos = %d", nowPos32, len, pos);
-+    #endif
-+
-+    posState = nowPos32 & p->pbMask;
-+    if (len == 1 && pos == (UInt32)-1)
-+    {
-+      Byte curByte;
-+      CLzmaProb *probs;
-+      const Byte *data;
-+
-+      RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 0);
-+      data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
-+      curByte = *data;
-+      probs = LIT_PROBS(nowPos32, *(data - 1));
-+      if (IsCharState(p->state))
-+        LitEnc_Encode(&p->rc, probs, curByte);
-+      else
-+        LitEnc_EncodeMatched(&p->rc, probs, curByte, *(data - p->reps[0] - 1));
-+      p->state = kLiteralNextStates[p->state];
-+    }
-+    else
-+    {
-+      RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 1);
-+      if (pos < LZMA_NUM_REPS)
-+      {
-+        RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 1);
-+        if (pos == 0)
-+        {
-+          RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 0);
-+          RangeEnc_EncodeBit(&p->rc, &p->isRep0Long[p->state][posState], ((len == 1) ? 0 : 1));
-+        }
-+        else
-+        {
-+          UInt32 distance = p->reps[pos];
-+          RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 1);
-+          if (pos == 1)
-+            RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 0);
-+          else
-+          {
-+            RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 1);
-+            RangeEnc_EncodeBit(&p->rc, &p->isRepG2[p->state], pos - 2);
-+            if (pos == 3)
-+              p->reps[3] = p->reps[2];
-+            p->reps[2] = p->reps[1];
-+          }
-+          p->reps[1] = p->reps[0];
-+          p->reps[0] = distance;
-+        }
-+        if (len == 1)
-+          p->state = kShortRepNextStates[p->state];
-+        else
-+        {
-+          LenEnc_Encode2(&p->repLenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
-+          p->state = kRepNextStates[p->state];
-+        }
-+      }
-+      else
-+      {
-+        UInt32 posSlot;
-+        RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 0);
-+        p->state = kMatchNextStates[p->state];
-+        LenEnc_Encode2(&p->lenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
-+        pos -= LZMA_NUM_REPS;
-+        GetPosSlot(pos, posSlot);
-+        RcTree_Encode(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, posSlot);
-+        
-+        if (posSlot >= kStartPosModelIndex)
-+        {
-+          UInt32 footerBits = ((posSlot >> 1) - 1);
-+          UInt32 base = ((2 | (posSlot & 1)) << footerBits);
-+          UInt32 posReduced = pos - base;
-+
-+          if (posSlot < kEndPosModelIndex)
-+            RcTree_ReverseEncode(&p->rc, p->posEncoders + base - posSlot - 1, footerBits, posReduced);
-+          else
-+          {
-+            RangeEnc_EncodeDirectBits(&p->rc, posReduced >> kNumAlignBits, footerBits - kNumAlignBits);
-+            RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, posReduced & kAlignMask);
-+            p->alignPriceCount++;
-+          }
-+        }
-+        p->reps[3] = p->reps[2];
-+        p->reps[2] = p->reps[1];
-+        p->reps[1] = p->reps[0];
-+        p->reps[0] = pos;
-+        p->matchPriceCount++;
-+      }
-+    }
-+    p->additionalOffset -= len;
-+    nowPos32 += len;
-+    if (p->additionalOffset == 0)
-+    {
-+      UInt32 processed;
-+      if (!p->fastMode)
-+      {
-+        if (p->matchPriceCount >= (1 << 7))
-+          FillDistancesPrices(p);
-+        if (p->alignPriceCount >= kAlignTableSize)
-+          FillAlignPrices(p);
-+      }
-+      if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
-+        break;
-+      processed = nowPos32 - startPos32;
-+      if (useLimits)
-+      {
-+        if (processed + kNumOpts + 300 >= maxUnpackSize ||
-+            RangeEnc_GetProcessed(&p->rc) + kNumOpts * 2 >= maxPackSize)
-+          break;
-+      }
-+      else if (processed >= (1 << 15))
-+      {
-+        p->nowPos64 += nowPos32 - startPos32;
-+        return CheckErrors(p);
-+      }
-+    }
-+  }
-+  p->nowPos64 += nowPos32 - startPos32;
-+  return Flush(p, nowPos32);
-+}
-+
-+#define kBigHashDicLimit ((UInt32)1 << 24)
-+
-+static SRes LzmaEnc_Alloc(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  UInt32 beforeSize = kNumOpts;
-+  Bool btMode;
-+  if (!RangeEnc_Alloc(&p->rc, alloc))
-+    return SZ_ERROR_MEM;
-+  btMode = (p->matchFinderBase.btMode != 0);
-+  #ifndef _7ZIP_ST
-+  p->mtMode = (p->multiThread && !p->fastMode && btMode);
-+  #endif
-+
-+  {
-+    unsigned lclp = p->lc + p->lp;
-+    if (p->litProbs == 0 || p->saveState.litProbs == 0 || p->lclp != lclp)
-+    {
-+      LzmaEnc_FreeLits(p, alloc);
-+      p->litProbs = (CLzmaProb *)alloc->Alloc(alloc, (0x300 << lclp) * sizeof(CLzmaProb));
-+      p->saveState.litProbs = (CLzmaProb *)alloc->Alloc(alloc, (0x300 << lclp) * sizeof(CLzmaProb));
-+      if (p->litProbs == 0 || p->saveState.litProbs == 0)
-+      {
-+        LzmaEnc_FreeLits(p, alloc);
-+        return SZ_ERROR_MEM;
-+      }
-+      p->lclp = lclp;
-+    }
-+  }
-+
-+  p->matchFinderBase.bigHash = (p->dictSize > kBigHashDicLimit);
-+
-+  if (beforeSize + p->dictSize < keepWindowSize)
-+    beforeSize = keepWindowSize - p->dictSize;
-+
-+  #ifndef _7ZIP_ST
-+  if (p->mtMode)
-+  {
-+    RINOK(MatchFinderMt_Create(&p->matchFinderMt, p->dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX, allocBig));
-+    p->matchFinderObj = &p->matchFinderMt;
-+    MatchFinderMt_CreateVTable(&p->matchFinderMt, &p->matchFinder);
-+  }
-+  else
-+  #endif
-+  {
-+    if (!MatchFinder_Create(&p->matchFinderBase, p->dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX, allocBig))
-+      return SZ_ERROR_MEM;
-+    p->matchFinderObj = &p->matchFinderBase;
-+    MatchFinder_CreateVTable(&p->matchFinderBase, &p->matchFinder);
-+  }
-+  return SZ_OK;
-+}
-+
-+void LzmaEnc_Init(CLzmaEnc *p)
-+{
-+  UInt32 i;
-+  p->state = 0;
-+  for (i = 0 ; i < LZMA_NUM_REPS; i++)
-+    p->reps[i] = 0;
-+
-+  RangeEnc_Init(&p->rc);
-+
-+
-+  for (i = 0; i < kNumStates; i++)
-+  {
-+    UInt32 j;
-+    for (j = 0; j < LZMA_NUM_PB_STATES_MAX; j++)
-+    {
-+      p->isMatch[i][j] = kProbInitValue;
-+      p->isRep0Long[i][j] = kProbInitValue;
-+    }
-+    p->isRep[i] = kProbInitValue;
-+    p->isRepG0[i] = kProbInitValue;
-+    p->isRepG1[i] = kProbInitValue;
-+    p->isRepG2[i] = kProbInitValue;
-+  }
-+
-+  {
-+    UInt32 num = 0x300 << (p->lp + p->lc);
-+    for (i = 0; i < num; i++)
-+      p->litProbs[i] = kProbInitValue;
-+  }
-+
-+  {
-+    for (i = 0; i < kNumLenToPosStates; i++)
-+    {
-+      CLzmaProb *probs = p->posSlotEncoder[i];
-+      UInt32 j;
-+      for (j = 0; j < (1 << kNumPosSlotBits); j++)
-+        probs[j] = kProbInitValue;
-+    }
-+  }
-+  {
-+    for (i = 0; i < kNumFullDistances - kEndPosModelIndex; i++)
-+      p->posEncoders[i] = kProbInitValue;
-+  }
-+
-+  LenEnc_Init(&p->lenEnc.p);
-+  LenEnc_Init(&p->repLenEnc.p);
-+
-+  for (i = 0; i < (1 << kNumAlignBits); i++)
-+    p->posAlignEncoder[i] = kProbInitValue;
-+
-+  p->optimumEndIndex = 0;
-+  p->optimumCurrentIndex = 0;
-+  p->additionalOffset = 0;
-+
-+  p->pbMask = (1 << p->pb) - 1;
-+  p->lpMask = (1 << p->lp) - 1;
-+}
-+
-+void LzmaEnc_InitPrices(CLzmaEnc *p)
-+{
-+  if (!p->fastMode)
-+  {
-+    FillDistancesPrices(p);
-+    FillAlignPrices(p);
-+  }
-+
-+  p->lenEnc.tableSize =
-+  p->repLenEnc.tableSize =
-+      p->numFastBytes + 1 - LZMA_MATCH_LEN_MIN;
-+  LenPriceEnc_UpdateTables(&p->lenEnc, 1 << p->pb, p->ProbPrices);
-+  LenPriceEnc_UpdateTables(&p->repLenEnc, 1 << p->pb, p->ProbPrices);
-+}
-+
-+static SRes LzmaEnc_AllocAndInit(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  UInt32 i;
-+  for (i = 0; i < (UInt32)kDicLogSizeMaxCompress; i++)
-+    if (p->dictSize <= ((UInt32)1 << i))
-+      break;
-+  p->distTableSize = i * 2;
-+
-+  p->finished = False;
-+  p->result = SZ_OK;
-+  RINOK(LzmaEnc_Alloc(p, keepWindowSize, alloc, allocBig));
-+  LzmaEnc_Init(p);
-+  LzmaEnc_InitPrices(p);
-+  p->nowPos64 = 0;
-+  return SZ_OK;
-+}
-+
-+static SRes LzmaEnc_Prepare(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream,
-+    ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  CLzmaEnc *p = (CLzmaEnc *)pp;
-+  p->matchFinderBase.stream = inStream;
-+  p->needInit = 1;
-+  p->rc.outStream = outStream;
-+  return LzmaEnc_AllocAndInit(p, 0, alloc, allocBig);
-+}
-+
-+SRes LzmaEnc_PrepareForLzma2(CLzmaEncHandle pp,
-+    ISeqInStream *inStream, UInt32 keepWindowSize,
-+    ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  CLzmaEnc *p = (CLzmaEnc *)pp;
-+  p->matchFinderBase.stream = inStream;
-+  p->needInit = 1;
-+  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
-+}
-+
-+static void LzmaEnc_SetInputBuf(CLzmaEnc *p, const Byte *src, SizeT srcLen)
-+{
-+  p->matchFinderBase.directInput = 1;
-+  p->matchFinderBase.bufferBase = (Byte *)src;
-+  p->matchFinderBase.directInputRem = srcLen;
-+}
-+
-+SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
-+    UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  CLzmaEnc *p = (CLzmaEnc *)pp;
-+  LzmaEnc_SetInputBuf(p, src, srcLen);
-+  p->needInit = 1;
-+
-+  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
-+}
-+
-+void LzmaEnc_Finish(CLzmaEncHandle pp)
-+{
-+  #ifndef _7ZIP_ST
-+  CLzmaEnc *p = (CLzmaEnc *)pp;
-+  if (p->mtMode)
-+    MatchFinderMt_ReleaseStream(&p->matchFinderMt);
-+  #else
-+  pp = pp;
-+  #endif
-+}
-+
-+typedef struct
-+{
-+  ISeqOutStream funcTable;
-+  Byte *data;
-+  SizeT rem;
-+  Bool overflow;
-+} CSeqOutStreamBuf;
-+
-+static size_t MyWrite(void *pp, const void *data, size_t size)
-+{
-+  CSeqOutStreamBuf *p = (CSeqOutStreamBuf *)pp;
-+  if (p->rem < size)
-+  {
-+    size = p->rem;
-+    p->overflow = True;
-+  }
-+  memcpy(p->data, data, size);
-+  p->rem -= size;
-+  p->data += size;
-+  return size;
-+}
-+
-+
-+UInt32 LzmaEnc_GetNumAvailableBytes(CLzmaEncHandle pp)
-+{
-+  const CLzmaEnc *p = (CLzmaEnc *)pp;
-+  return p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
-+}
-+
-+const Byte *LzmaEnc_GetCurBuf(CLzmaEncHandle pp)
-+{
-+  const CLzmaEnc *p = (CLzmaEnc *)pp;
-+  return p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
-+}
-+
-+SRes LzmaEnc_CodeOneMemBlock(CLzmaEncHandle pp, Bool reInit,
-+    Byte *dest, size_t *destLen, UInt32 desiredPackSize, UInt32 *unpackSize)
-+{
-+  CLzmaEnc *p = (CLzmaEnc *)pp;
-+  UInt64 nowPos64;
-+  SRes res;
-+  CSeqOutStreamBuf outStream;
-+
-+  outStream.funcTable.Write = MyWrite;
-+  outStream.data = dest;
-+  outStream.rem = *destLen;
-+  outStream.overflow = False;
-+
-+  p->writeEndMark = False;
-+  p->finished = False;
-+  p->result = SZ_OK;
-+
-+  if (reInit)
-+    LzmaEnc_Init(p);
-+  LzmaEnc_InitPrices(p);
-+  nowPos64 = p->nowPos64;
-+  RangeEnc_Init(&p->rc);
-+  p->rc.outStream = &outStream.funcTable;
-+
-+  res = LzmaEnc_CodeOneBlock(p, True, desiredPackSize, *unpackSize);
-+  
-+  *unpackSize = (UInt32)(p->nowPos64 - nowPos64);
-+  *destLen -= outStream.rem;
-+  if (outStream.overflow)
-+    return SZ_ERROR_OUTPUT_EOF;
-+
-+  return res;
-+}
-+
-+static SRes LzmaEnc_Encode2(CLzmaEnc *p, ICompressProgress *progress)
-+{
-+  SRes res = SZ_OK;
-+
-+  #ifndef _7ZIP_ST
-+  Byte allocaDummy[0x300];
-+  int i = 0;
-+  for (i = 0; i < 16; i++)
-+    allocaDummy[i] = (Byte)i;
-+  #endif
-+
-+  for (;;)
-+  {
-+    res = LzmaEnc_CodeOneBlock(p, False, 0, 0);
-+    if (res != SZ_OK || p->finished != 0)
-+      break;
-+    if (progress != 0)
-+    {
-+      res = progress->Progress(progress, p->nowPos64, RangeEnc_GetProcessed(&p->rc));
-+      if (res != SZ_OK)
-+      {
-+        res = SZ_ERROR_PROGRESS;
-+        break;
-+      }
-+    }
-+  }
-+  LzmaEnc_Finish(p);
-+  return res;
-+}
-+
-+SRes LzmaEnc_Encode(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress,
-+    ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  RINOK(LzmaEnc_Prepare(pp, outStream, inStream, alloc, allocBig));
-+  return LzmaEnc_Encode2((CLzmaEnc *)pp, progress);
-+}
-+
-+SRes LzmaEnc_WriteProperties(CLzmaEncHandle pp, Byte *props, SizeT *size)
-+{
-+  CLzmaEnc *p = (CLzmaEnc *)pp;
-+  int i;
-+  UInt32 dictSize = p->dictSize;
-+  if (*size < LZMA_PROPS_SIZE)
-+    return SZ_ERROR_PARAM;
-+  *size = LZMA_PROPS_SIZE;
-+  props[0] = (Byte)((p->pb * 5 + p->lp) * 9 + p->lc);
-+
-+  for (i = 11; i <= 30; i++)
-+  {
-+    if (dictSize <= ((UInt32)2 << i))
-+    {
-+      dictSize = (2 << i);
-+      break;
-+    }
-+    if (dictSize <= ((UInt32)3 << i))
-+    {
-+      dictSize = (3 << i);
-+      break;
-+    }
-+  }
-+
-+  for (i = 0; i < 4; i++)
-+    props[1 + i] = (Byte)(dictSize >> (8 * i));
-+  return SZ_OK;
-+}
-+
-+SRes LzmaEnc_MemEncode(CLzmaEncHandle pp, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-+    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  SRes res;
-+  CLzmaEnc *p = (CLzmaEnc *)pp;
-+
-+  CSeqOutStreamBuf outStream;
-+
-+  LzmaEnc_SetInputBuf(p, src, srcLen);
-+
-+  outStream.funcTable.Write = MyWrite;
-+  outStream.data = dest;
-+  outStream.rem = *destLen;
-+  outStream.overflow = False;
-+
-+  p->writeEndMark = writeEndMark;
-+
-+  p->rc.outStream = &outStream.funcTable;
-+  res = LzmaEnc_MemPrepare(pp, src, srcLen, 0, alloc, allocBig);
-+  if (res == SZ_OK)
-+    res = LzmaEnc_Encode2(p, progress);
-+
-+  *destLen -= outStream.rem;
-+  if (outStream.overflow)
-+    return SZ_ERROR_OUTPUT_EOF;
-+  return res;
-+}
-+
-+SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-+    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
-+    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  CLzmaEnc *p = (CLzmaEnc *)LzmaEnc_Create(alloc);
-+  SRes res;
-+  if (p == 0)
-+    return SZ_ERROR_MEM;
-+
-+  res = LzmaEnc_SetProps(p, props);
-+  if (res == SZ_OK)
-+  {
-+    res = LzmaEnc_WriteProperties(p, propsEncoded, propsSize);
-+    if (res == SZ_OK)
-+      res = LzmaEnc_MemEncode(p, dest, destLen, src, srcLen,
-+          writeEndMark, progress, alloc, allocBig);
-+  }
-+
-+  LzmaEnc_Destroy(p, alloc, allocBig);
-+  return res;
-+}
---- /dev/null
-+++ b/lib/lzma/Makefile
-@@ -0,0 +1,7 @@
-+lzma_compress-objs := LzFind.o LzmaEnc.o
-+lzma_decompress-objs := LzmaDec.o
-+
-+obj-$(CONFIG_LZMA_COMPRESS) += lzma_compress.o
-+obj-$(CONFIG_LZMA_DECOMPRESS) += lzma_decompress.o
-+
-+EXTRA_CFLAGS += -Iinclude/linux -Iinclude/linux/lzma -include types.h
--- a/target/linux/generic/pending-4.19/532-jffs2_eofdetect.patch	2022-03-22 08:54:47.407465003 +0800
+++ b/target/linux/generic/pending-4.19/532-jffs2_eofdetect.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,65 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: fs: jffs2: EOF marker
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- fs/jffs2/build.c | 10 ++++++++++
- fs/jffs2/scan.c  | 21 +++++++++++++++++++--
- 2 files changed, 29 insertions(+), 2 deletions(-)
-
---- a/fs/jffs2/build.c
-+++ b/fs/jffs2/build.c
-@@ -117,6 +117,16 @@ static int jffs2_build_filesystem(struct
- 	dbg_fsbuild("scanned flash completely\n");
- 	jffs2_dbg_dump_block_lists_nolock(c);
- 
-+	if (c->flags & (1 << 7)) {
-+		printk("%s(): unlocking the mtd device... ", __func__);
-+		mtd_unlock(c->mtd, 0, c->mtd->size);
-+		printk("done.\n");
-+
-+		printk("%s(): erasing all blocks after the end marker... ", __func__);
-+		jffs2_erase_pending_blocks(c, -1);
-+		printk("done.\n");
-+	}
-+
- 	dbg_fsbuild("pass 1 starting\n");
- 	c->flags |= JFFS2_SB_FLAG_BUILDING;
- 	/* Now scan the directory tree, increasing nlink according to every dirent found. */
---- a/fs/jffs2/scan.c
-+++ b/fs/jffs2/scan.c
-@@ -148,8 +148,14 @@ int jffs2_scan_medium(struct jffs2_sb_in
- 		/* reset summary info for next eraseblock scan */
- 		jffs2_sum_reset_collected(s);
- 
--		ret = jffs2_scan_eraseblock(c, jeb, buf_size?flashbuf:(flashbuf+jeb->offset),
--						buf_size, s);
-+		if (c->flags & (1 << 7)) {
-+			if (mtd_block_isbad(c->mtd, jeb->offset))
-+				ret = BLK_STATE_BADBLOCK;
-+			else
-+				ret = BLK_STATE_ALLFF;
-+		} else
-+			ret = jffs2_scan_eraseblock(c, jeb, buf_size?flashbuf:(flashbuf+jeb->offset),
-+							buf_size, s);
- 
- 		if (ret < 0)
- 			goto out;
-@@ -561,6 +567,17 @@ full_scan:
- 			return err;
- 	}
- 
-+	if ((buf[0] == 0xde) &&
-+		(buf[1] == 0xad) &&
-+		(buf[2] == 0xc0) &&
-+		(buf[3] == 0xde)) {
-+		/* end of filesystem. erase everything after this point */
-+		printk("%s(): End of filesystem marker found at 0x%x\n", __func__, jeb->offset);
-+		c->flags |= (1 << 7);
-+
-+		return BLK_STATE_ALLFF;
-+	}
-+
- 	/* We temporarily use 'ofs' as a pointer into the buffer/jeb */
- 	ofs = 0;
- 	max_ofs = EMPTY_SCAN_SIZE(c->sector_size);
--- a/target/linux/generic/pending-4.19/553-ubifs-Add-option-to-create-UBI-FS-version-4-on-empty.patch	2022-03-22 08:54:47.408465004 +0800
+++ b/target/linux/generic/pending-4.19/553-ubifs-Add-option-to-create-UBI-FS-version-4-on-empty.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,63 +0,0 @@
-From 93c33e6a7f3b0aef99d02252e6232a3d8b80f2d5 Mon Sep 17 00:00:00 2001
-From: Hauke Mehrtens <hauke@hauke-m.de>
-Date: Sun, 21 Jan 2018 15:47:50 +0100
-Subject: ubifs: Add option to create UBI FS version 4 on empty UBI volume
-
-Instead of creating an ubifs file system with format version 5 by
-default on empty UBI volumes add a compile option to create an older ubi
-with file system format version 4 instated. This allows it to be mount
-as a volume on kernel versions < 4.10, which does not support format
-version 5.
-We saw that some people can not access their older data when they
-downgraded from kernel 4.14 to kernel 4.9 to prevent this this option
-would help.
-
-Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
----
- fs/ubifs/Kconfig | 13 +++++++++++++
- fs/ubifs/sb.c    |  6 ++++++
- 2 files changed, 19 insertions(+)
-
---- a/fs/ubifs/Kconfig
-+++ b/fs/ubifs/Kconfig
-@@ -85,3 +85,16 @@ config UBIFS_FS_SECURITY
- 	  the extended attribute support in advance.
- 
- 	  If you are not using a security module, say N.
-+
-+config UBIFS_FS_FORMAT4
-+	bool "Use file system format version 4 for new file systems"
-+	depends on UBIFS_FS
-+	help
-+	  Instead of creating new file systems with the new ubifs file
-+	  system version 5, use the old format version 4 for implicitly
-+	  by the driver created file systems on an empty UBI volume. This
-+	  makes it possible to  mount these file systems also with kernel
-+	  versions before 4.10. The driver will still support file system
-+	  format version 5 for ubifs file systems created with version 5.
-+
-+	  If you are unsure, say N.
---- a/fs/ubifs/sb.c
-+++ b/fs/ubifs/sb.c
-@@ -176,7 +176,9 @@ static int create_default_filesystem(str
- 	tmp64 = (long long)max_buds * c->leb_size;
- 	if (big_lpt)
- 		sup_flags |= UBIFS_FLG_BIGLPT;
-+#ifndef CONFIG_UBIFS_FS_FORMAT4
- 	sup_flags |= UBIFS_FLG_DOUBLE_HASH;
-+#endif
- 
- 	sup->ch.node_type  = UBIFS_SB_NODE;
- 	sup->key_hash      = UBIFS_KEY_HASH_R5;
-@@ -192,7 +194,11 @@ static int create_default_filesystem(str
- 	sup->jhead_cnt     = cpu_to_le32(DEFAULT_JHEADS_CNT);
- 	sup->fanout        = cpu_to_le32(DEFAULT_FANOUT);
- 	sup->lsave_cnt     = cpu_to_le32(c->lsave_cnt);
-+#ifdef CONFIG_UBIFS_FS_FORMAT4
-+	sup->fmt_version   = cpu_to_le32(4);
-+#else
- 	sup->fmt_version   = cpu_to_le32(UBIFS_FORMAT_VERSION);
-+#endif
- 	sup->time_gran     = cpu_to_le32(DEFAULT_TIME_GRAN);
- 	if (c->mount_opts.override_compr)
- 		sup->default_compr = cpu_to_le16(c->mount_opts.compr_type);
--- a/target/linux/generic/pending-4.19/600-netfilter_conntrack_flush.patch	2022-03-22 08:54:47.408465004 +0800
+++ b/target/linux/generic/pending-4.19/600-netfilter_conntrack_flush.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,88 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: netfilter: add support for flushing conntrack via /proc
-
-lede-commit 8193bbe59a74d34d6a26d4a8cb857b1952905314
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- net/netfilter/nf_conntrack_standalone.c | 59 ++++++++++++++++++++++++++++++++-
- 1 file changed, 58 insertions(+), 1 deletion(-)
-
---- a/net/netfilter/nf_conntrack_standalone.c
-+++ b/net/netfilter/nf_conntrack_standalone.c
-@@ -9,6 +9,7 @@
- #include <linux/percpu.h>
- #include <linux/netdevice.h>
- #include <linux/security.h>
-+#include <linux/inet.h>
- #include <net/net_namespace.h>
- #ifdef CONFIG_SYSCTL
- #include <linux/sysctl.h>
-@@ -433,6 +434,56 @@ static int ct_cpu_seq_show(struct seq_fi
- 	return 0;
- }
- 
-+struct kill_request {
-+	u16 family;
-+	union nf_inet_addr addr;
-+};
-+
-+static int kill_matching(struct nf_conn *i, void *data)
-+{
-+	struct kill_request *kr = data;
-+	struct nf_conntrack_tuple *t1 = &i->tuplehash[IP_CT_DIR_ORIGINAL].tuple;
-+	struct nf_conntrack_tuple *t2 = &i->tuplehash[IP_CT_DIR_REPLY].tuple;
-+
-+	if (!kr->family)
-+		return 1;
-+
-+	if (t1->src.l3num != kr->family)
-+		return 0;
-+
-+	return (nf_inet_addr_cmp(&kr->addr, &t1->src.u3) ||
-+	        nf_inet_addr_cmp(&kr->addr, &t1->dst.u3) ||
-+	        nf_inet_addr_cmp(&kr->addr, &t2->src.u3) ||
-+	        nf_inet_addr_cmp(&kr->addr, &t2->dst.u3));
-+}
-+
-+static int ct_file_write(struct file *file, char *buf, size_t count)
-+{
-+	struct seq_file *seq = file->private_data;
-+	struct net *net = seq_file_net(seq);
-+	struct kill_request kr = { };
-+
-+	if (count == 0)
-+		return 0;
-+
-+	if (count >= INET6_ADDRSTRLEN)
-+		count = INET6_ADDRSTRLEN - 1;
-+
-+	if (strnchr(buf, count, ':')) {
-+		kr.family = AF_INET6;
-+		if (!in6_pton(buf, count, (void *)&kr.addr, '\n', NULL))
-+			return -EINVAL;
-+	} else if (strnchr(buf, count, '.')) {
-+		kr.family = AF_INET;
-+		if (!in4_pton(buf, count, (void *)&kr.addr, '\n', NULL))
-+			return -EINVAL;
-+	}
-+
-+	nf_ct_iterate_cleanup_net(net, kill_matching, &kr, 0, 0);
-+
-+	return 0;
-+}
-+
- static const struct seq_operations ct_cpu_seq_ops = {
- 	.start	= ct_cpu_seq_start,
- 	.next	= ct_cpu_seq_next,
-@@ -446,8 +497,9 @@ static int nf_conntrack_standalone_init_
- 	kuid_t root_uid;
- 	kgid_t root_gid;
- 
--	pde = proc_create_net("nf_conntrack", 0440, net->proc_net, &ct_seq_ops,
--			sizeof(struct ct_iter_state));
-+	pde = proc_create_net_data_write("nf_conntrack", 0440, net->proc_net,
-+					 &ct_seq_ops, &ct_file_write,
-+					 sizeof(struct ct_iter_state), NULL);
- 	if (!pde)
- 		goto out_nf_conntrack;
- 
--- a/target/linux/generic/pending-4.19/610-netfilter_match_bypass_default_checks.patch	2022-03-22 08:54:47.408465004 +0800
+++ b/target/linux/generic/pending-4.19/610-netfilter_match_bypass_default_checks.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,110 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: kernel: add a new version of my netfilter speedup patches for linux 2.6.39 and 3.0
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/uapi/linux/netfilter_ipv4/ip_tables.h |  1 +
- net/ipv4/netfilter/ip_tables.c                | 37 +++++++++++++++++++++++++++
- 2 files changed, 38 insertions(+)
-
---- a/include/uapi/linux/netfilter_ipv4/ip_tables.h
-+++ b/include/uapi/linux/netfilter_ipv4/ip_tables.h
-@@ -89,6 +89,7 @@ struct ipt_ip {
- #define IPT_F_FRAG		0x01	/* Set if rule is a fragment rule */
- #define IPT_F_GOTO		0x02	/* Set if jump is a goto */
- #define IPT_F_MASK		0x03	/* All possible flag bits mask. */
-+#define IPT_F_NO_DEF_MATCH	0x80	/* Internal: no default match rules present */
- 
- /* Values for "inv" field in struct ipt_ip. */
- #define IPT_INV_VIA_IN		0x01	/* Invert the sense of IN IFACE. */
---- a/net/ipv4/netfilter/ip_tables.c
-+++ b/net/ipv4/netfilter/ip_tables.c
-@@ -53,6 +53,9 @@ ip_packet_match(const struct iphdr *ip,
- {
- 	unsigned long ret;
- 
-+	if (ipinfo->flags & IPT_F_NO_DEF_MATCH)
-+		return true;
-+
- 	if (NF_INVF(ipinfo, IPT_INV_SRCIP,
- 		    (ip->saddr & ipinfo->smsk.s_addr) != ipinfo->src.s_addr) ||
- 	    NF_INVF(ipinfo, IPT_INV_DSTIP,
-@@ -83,6 +86,29 @@ ip_packet_match(const struct iphdr *ip,
- 	return true;
- }
- 
-+static void
-+ip_checkdefault(struct ipt_ip *ip)
-+{
-+	static const char iface_mask[IFNAMSIZ] = {};
-+
-+	if (ip->invflags || ip->flags & IPT_F_FRAG)
-+		return;
-+
-+	if (memcmp(ip->iniface_mask, iface_mask, IFNAMSIZ) != 0)
-+		return;
-+
-+	if (memcmp(ip->outiface_mask, iface_mask, IFNAMSIZ) != 0)
-+		return;
-+
-+	if (ip->smsk.s_addr || ip->dmsk.s_addr)
-+		return;
-+
-+	if (ip->proto)
-+		return;
-+
-+	ip->flags |= IPT_F_NO_DEF_MATCH;
-+}
-+
- static bool
- ip_checkentry(const struct ipt_ip *ip)
- {
-@@ -527,6 +553,8 @@ find_check_entry(struct ipt_entry *e, st
- 	struct xt_mtchk_param mtpar;
- 	struct xt_entry_match *ematch;
- 
-+	ip_checkdefault(&e->ip);
-+
- 	if (!xt_percpu_counter_alloc(alloc_state, &e->counters))
- 		return -ENOMEM;
- 
-@@ -821,6 +849,7 @@ copy_entries_to_user(unsigned int total_
- 	const struct xt_table_info *private = table->private;
- 	int ret = 0;
- 	const void *loc_cpu_entry;
-+	u8 flags;
- 
- 	counters = alloc_counters(table);
- 	if (IS_ERR(counters))
-@@ -848,6 +877,14 @@ copy_entries_to_user(unsigned int total_
- 			goto free_counters;
- 		}
- 
-+		flags = e->ip.flags & IPT_F_MASK;
-+		if (copy_to_user(userptr + off
-+				 + offsetof(struct ipt_entry, ip.flags),
-+				 &flags, sizeof(flags)) != 0) {
-+			ret = -EFAULT;
-+			goto free_counters;
-+		}
-+
- 		for (i = sizeof(struct ipt_entry);
- 		     i < e->target_offset;
- 		     i += m->u.match_size) {
-@@ -1228,12 +1265,15 @@ compat_copy_entry_to_user(struct ipt_ent
- 	compat_uint_t origsize;
- 	const struct xt_entry_match *ematch;
- 	int ret = 0;
-+	u8 flags = e->ip.flags & IPT_F_MASK;
- 
- 	origsize = *size;
- 	ce = *dstptr;
- 	if (copy_to_user(ce, e, sizeof(struct ipt_entry)) != 0 ||
- 	    copy_to_user(&ce->counters, &counters[i],
--	    sizeof(counters[i])) != 0)
-+	    sizeof(counters[i])) != 0 ||
-+	    copy_to_user(&ce->ip.flags, &flags,
-+	    sizeof(flags)) != 0)
- 		return -EFAULT;
- 
- 	*dstptr += sizeof(struct compat_ipt_entry);
--- a/target/linux/generic/pending-4.19/611-netfilter_match_bypass_default_table.patch	2022-03-22 08:54:47.409465006 +0800
+++ b/target/linux/generic/pending-4.19/611-netfilter_match_bypass_default_table.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,106 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: netfilter: match bypass default table
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- net/ipv4/netfilter/ip_tables.c | 79 +++++++++++++++++++++++++++++++-----------
- 1 file changed, 58 insertions(+), 21 deletions(-)
-
---- a/net/ipv4/netfilter/ip_tables.c
-+++ b/net/ipv4/netfilter/ip_tables.c
-@@ -249,6 +249,33 @@ struct ipt_entry *ipt_next_entry(const s
- 	return (void *)entry + entry->next_offset;
- }
- 
-+static bool
-+ipt_handle_default_rule(struct ipt_entry *e, unsigned int *verdict)
-+{
-+	struct xt_entry_target *t;
-+	struct xt_standard_target *st;
-+
-+	if (e->target_offset != sizeof(struct ipt_entry))
-+		return false;
-+
-+	if (!(e->ip.flags & IPT_F_NO_DEF_MATCH))
-+		return false;
-+
-+	t = ipt_get_target(e);
-+	if (t->u.kernel.target->target)
-+		return false;
-+
-+	st = (struct xt_standard_target *) t;
-+	if (st->verdict == XT_RETURN)
-+		return false;
-+
-+	if (st->verdict >= 0)
-+		return false;
-+
-+	*verdict = (unsigned)(-st->verdict) - 1;
-+	return true;
-+}
-+
- /* Returns one of the generic firewall policies, like NF_ACCEPT. */
- unsigned int
- ipt_do_table(struct sk_buff *skb,
-@@ -269,27 +296,28 @@ ipt_do_table(struct sk_buff *skb,
- 	unsigned int addend;
- 
- 	/* Initialization */
-+	WARN_ON(!(table->valid_hooks & (1 << hook)));
-+	local_bh_disable();
-+	private = READ_ONCE(table->private); /* Address dependency. */
-+	cpu        = smp_processor_id();
-+	table_base = private->entries;
-+
-+	e = get_entry(table_base, private->hook_entry[hook]);
-+	if (ipt_handle_default_rule(e, &verdict)) {
-+		struct xt_counters *counter;
-+
-+		counter = xt_get_this_cpu_counter(&e->counters);
-+		ADD_COUNTER(*counter, skb->len, 1);
-+		local_bh_enable();
-+		return verdict;
-+	}
-+
- 	stackidx = 0;
- 	ip = ip_hdr(skb);
- 	indev = state->in ? state->in->name : nulldevname;
- 	outdev = state->out ? state->out->name : nulldevname;
--	/* We handle fragments by dealing with the first fragment as
--	 * if it was a normal packet.  All other fragments are treated
--	 * normally, except that they will NEVER match rules that ask
--	 * things we don't know, ie. tcp syn flag or ports).  If the
--	 * rule is also a fragment-specific rule, non-fragments won't
--	 * match it. */
--	acpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;
--	acpar.thoff   = ip_hdrlen(skb);
--	acpar.hotdrop = false;
--	acpar.state   = state;
- 
--	WARN_ON(!(table->valid_hooks & (1 << hook)));
--	local_bh_disable();
- 	addend = xt_write_recseq_begin();
--	private = READ_ONCE(table->private); /* Address dependency. */
--	cpu        = smp_processor_id();
--	table_base = private->entries;
- 	jumpstack  = (struct ipt_entry **)private->jumpstack[cpu];
- 
- 	/* Switch to alternate jumpstack if we're being invoked via TEE.
-@@ -302,7 +330,16 @@ ipt_do_table(struct sk_buff *skb,
- 	if (static_key_false(&xt_tee_enabled))
- 		jumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);
- 
--	e = get_entry(table_base, private->hook_entry[hook]);
-+	/* We handle fragments by dealing with the first fragment as
-+	 * if it was a normal packet.  All other fragments are treated
-+	 * normally, except that they will NEVER match rules that ask
-+	 * things we don't know, ie. tcp syn flag or ports).  If the
-+	 * rule is also a fragment-specific rule, non-fragments won't
-+	 * match it. */
-+	acpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;
-+	acpar.thoff   = ip_hdrlen(skb);
-+	acpar.hotdrop = false;
-+	acpar.state   = state;
- 
- 	do {
- 		const struct xt_entry_target *t;
--- a/target/linux/generic/pending-4.19/612-netfilter_match_reduce_memory_access.patch	2022-03-22 08:54:47.409465006 +0800
+++ b/target/linux/generic/pending-4.19/612-netfilter_match_reduce_memory_access.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,22 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: netfilter: reduce match memory access
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- net/ipv4/netfilter/ip_tables.c | 4 ++--
- 1 file changed, 2 insertions(+), 2 deletions(-)
-
---- a/net/ipv4/netfilter/ip_tables.c
-+++ b/net/ipv4/netfilter/ip_tables.c
-@@ -56,9 +56,9 @@ ip_packet_match(const struct iphdr *ip,
- 	if (ipinfo->flags & IPT_F_NO_DEF_MATCH)
- 		return true;
- 
--	if (NF_INVF(ipinfo, IPT_INV_SRCIP,
-+	if (NF_INVF(ipinfo, IPT_INV_SRCIP, ipinfo->smsk.s_addr &&
- 		    (ip->saddr & ipinfo->smsk.s_addr) != ipinfo->src.s_addr) ||
--	    NF_INVF(ipinfo, IPT_INV_DSTIP,
-+	    NF_INVF(ipinfo, IPT_INV_DSTIP, ipinfo->dmsk.s_addr &&
- 		    (ip->daddr & ipinfo->dmsk.s_addr) != ipinfo->dst.s_addr))
- 		return false;
- 
--- a/target/linux/generic/pending-4.19/613-netfilter_optional_tcp_window_check.patch	2022-03-22 08:54:47.409465006 +0800
+++ b/target/linux/generic/pending-4.19/613-netfilter_optional_tcp_window_check.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,53 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: netfilter: optional tcp window check
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- net/netfilter/nf_conntrack_proto_tcp.c | 13 +++++++++++++
- 1 file changed, 13 insertions(+)
-
---- a/net/netfilter/nf_conntrack_proto_tcp.c
-+++ b/net/netfilter/nf_conntrack_proto_tcp.c
-@@ -34,6 +34,9 @@
- #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
- #include <net/netfilter/ipv6/nf_conntrack_ipv6.h>
- 
-+/* Do not check the TCP window for incoming packets  */
-+static int nf_ct_tcp_no_window_check __read_mostly = 1;
-+
- /* "Be conservative in what you do,
-     be liberal in what you accept from others."
-     If it's non-zero, we mark only out of window RST segments as INVALID. */
-@@ -484,6 +487,9 @@ static bool tcp_in_window(const struct n
- 	s32 receiver_offset;
- 	bool res, in_recv_win;
- 
-+	if (nf_ct_tcp_no_window_check)
-+		return true;
-+
- 	/*
- 	 * Get the required data from the packet.
- 	 */
-@@ -1059,7 +1065,7 @@ static int tcp_packet(struct nf_conn *ct
- 		 IP_CT_TCP_FLAG_DATA_UNACKNOWLEDGED &&
- 		 timeouts[new_state] > timeouts[TCP_CONNTRACK_UNACK])
- 		timeout = timeouts[TCP_CONNTRACK_UNACK];
--	else if (ct->proto.tcp.last_win == 0 &&
-+	else if (!nf_ct_tcp_no_window_check && ct->proto.tcp.last_win == 0 &&
- 		 timeouts[new_state] > timeouts[TCP_CONNTRACK_RETRANS])
- 		timeout = timeouts[TCP_CONNTRACK_RETRANS];
- 	else
-@@ -1508,6 +1514,13 @@ static struct ctl_table tcp_sysctl_table
- 		.mode		= 0644,
- 		.proc_handler	= proc_dointvec,
- 	},
-+	{
-+		.procname       = "nf_conntrack_tcp_no_window_check",
-+		.data           = &nf_ct_tcp_no_window_check,
-+		.maxlen         = sizeof(unsigned int),
-+		.mode           = 0644,
-+		.proc_handler   = proc_dointvec,
-+	},
- 	{ }
- };
- #endif /* CONFIG_SYSCTL */
--- a/target/linux/generic/pending-4.19/616-net_optimize_xfrm_calls.patch	2022-03-22 08:54:47.410465008 +0800
+++ b/target/linux/generic/pending-4.19/616-net_optimize_xfrm_calls.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,20 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: kernel: add a small xfrm related performance optimization
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- net/netfilter/nf_nat_core.c | 3 +++
- 1 file changed, 3 insertions(+)
-
---- a/net/netfilter/nf_nat_core.c
-+++ b/net/netfilter/nf_nat_core.c
-@@ -110,6 +110,9 @@ int nf_xfrm_me_harder(struct net *net, s
- 	struct sock *sk = skb->sk;
- 	int err;
- 
-+	if (skb->dev && !dev_net(skb->dev)->xfrm.policy_count[XFRM_POLICY_OUT])
-+		return 0;
-+
- 	err = xfrm_decode_session(skb, &fl, family);
- 	if (err < 0)
- 		return err;
--- a/target/linux/generic/pending-4.19/620-net_sched-codel-do-not-defer-queue-length-update.patch	2022-03-22 08:54:47.410465008 +0800
+++ b/target/linux/generic/pending-4.19/620-net_sched-codel-do-not-defer-queue-length-update.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,86 +0,0 @@
-From: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
-Date: Mon, 21 Aug 2017 11:14:14 +0300
-Subject: [PATCH] net_sched/codel: do not defer queue length update
-
-When codel wants to drop last packet in ->dequeue() it cannot call
-qdisc_tree_reduce_backlog() right away - it will notify parent qdisc
-about zero qlen and HTB/HFSC will deactivate class. The same class will
-be deactivated second time by caller of ->dequeue(). Currently codel and
-fq_codel defer update. This triggers warning in HFSC when it's qlen != 0
-but there is no active classes.
-
-This patch update parent queue length immediately: just temporary increase
-qlen around qdisc_tree_reduce_backlog() to prevent first class deactivation
-if we have skb to return.
-
-This might open another problem in HFSC - now operation peek could fail and
-deactivate parent class.
-
-Signed-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
-Link: https://bugzilla.kernel.org/show_bug.cgi?id=109581
----
-
---- a/net/sched/sch_codel.c
-+++ b/net/sched/sch_codel.c
-@@ -95,11 +95,17 @@ static struct sk_buff *codel_qdisc_deque
- 			    &q->stats, qdisc_pkt_len, codel_get_enqueue_time,
- 			    drop_func, dequeue_func);
- 
--	/* We cant call qdisc_tree_reduce_backlog() if our qlen is 0,
--	 * or HTB crashes. Defer it for next round.
-+	/* If our qlen is 0 qdisc_tree_reduce_backlog() will deactivate
-+	 * parent class, dequeue in parent qdisc will do the same if we
-+	 * return skb. Temporary increment qlen if we have skb.
- 	 */
--	if (q->stats.drop_count && sch->q.qlen) {
--		qdisc_tree_reduce_backlog(sch, q->stats.drop_count, q->stats.drop_len);
-+	if (q->stats.drop_count) {
-+		if (skb)
-+			sch->q.qlen++;
-+		qdisc_tree_reduce_backlog(sch, q->stats.drop_count,
-+					  q->stats.drop_len);
-+		if (skb)
-+			sch->q.qlen--;
- 		q->stats.drop_count = 0;
- 		q->stats.drop_len = 0;
- 	}
---- a/net/sched/sch_fq_codel.c
-+++ b/net/sched/sch_fq_codel.c
-@@ -317,6 +317,21 @@ begin:
- 	flow->dropped += q->cstats.drop_count - prev_drop_count;
- 	flow->dropped += q->cstats.ecn_mark - prev_ecn_mark;
- 
-+	/* If our qlen is 0 qdisc_tree_reduce_backlog() will deactivate
-+	 * parent class, dequeue in parent qdisc will do the same if we
-+	 * return skb. Temporary increment qlen if we have skb.
-+	 */
-+	if (q->cstats.drop_count) {
-+		if (skb)
-+			sch->q.qlen++;
-+		qdisc_tree_reduce_backlog(sch, q->cstats.drop_count,
-+					  q->cstats.drop_len);
-+		if (skb)
-+			sch->q.qlen--;
-+		q->cstats.drop_count = 0;
-+		q->cstats.drop_len = 0;
-+	}
-+
- 	if (!skb) {
- 		/* force a pass through old_flows to prevent starvation */
- 		if ((head == &q->new_flows) && !list_empty(&q->old_flows))
-@@ -327,15 +342,6 @@ begin:
- 	}
- 	qdisc_bstats_update(sch, skb);
- 	flow->deficit -= qdisc_pkt_len(skb);
--	/* We cant call qdisc_tree_reduce_backlog() if our qlen is 0,
--	 * or HTB crashes. Defer it for next round.
--	 */
--	if (q->cstats.drop_count && sch->q.qlen) {
--		qdisc_tree_reduce_backlog(sch, q->cstats.drop_count,
--					  q->cstats.drop_len);
--		q->cstats.drop_count = 0;
--		q->cstats.drop_len = 0;
--	}
- 	return skb;
- }
- 
--- a/target/linux/generic/pending-4.19/630-packet_socket_type.patch	2022-03-22 08:54:47.411465009 +0800
+++ b/target/linux/generic/pending-4.19/630-packet_socket_type.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,138 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: net: add an optimization for dealing with raw sockets
-
-lede-commit: 4898039703d7315f0f3431c860123338ec3be0f6
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/uapi/linux/if_packet.h |  3 +++
- net/packet/af_packet.c         | 34 +++++++++++++++++++++++++++-------
- net/packet/internal.h          |  1 +
- 3 files changed, 31 insertions(+), 7 deletions(-)
-
---- a/include/uapi/linux/if_packet.h
-+++ b/include/uapi/linux/if_packet.h
-@@ -32,6 +32,8 @@ struct sockaddr_ll {
- #define PACKET_KERNEL		7		/* To kernel space	*/
- /* Unused, PACKET_FASTROUTE and PACKET_LOOPBACK are invisible to user space */
- #define PACKET_FASTROUTE	6		/* Fastrouted frame	*/
-+#define PACKET_MASK_ANY		0xffffffff	/* mask for packet type bits */
-+
- 
- /* Packet socket options */
- 
-@@ -57,6 +59,7 @@ struct sockaddr_ll {
- #define PACKET_QDISC_BYPASS		20
- #define PACKET_ROLLOVER_STATS		21
- #define PACKET_FANOUT_DATA		22
-+#define PACKET_RECV_TYPE		23
- 
- #define PACKET_FANOUT_HASH		0
- #define PACKET_FANOUT_LB		1
---- a/net/packet/af_packet.c
-+++ b/net/packet/af_packet.c
-@@ -1789,6 +1789,7 @@ static int packet_rcv_spkt(struct sk_buf
- {
- 	struct sock *sk;
- 	struct sockaddr_pkt *spkt;
-+	struct packet_sock *po;
- 
- 	/*
- 	 *	When we registered the protocol we saved the socket in the data
-@@ -1796,6 +1797,7 @@ static int packet_rcv_spkt(struct sk_buf
- 	 */
- 
- 	sk = pt->af_packet_priv;
-+	po = pkt_sk(sk);
- 
- 	/*
- 	 *	Yank back the headers [hope the device set this
-@@ -1808,7 +1810,7 @@ static int packet_rcv_spkt(struct sk_buf
- 	 *	so that this procedure is noop.
- 	 */
- 
--	if (skb->pkt_type == PACKET_LOOPBACK)
-+	if (!(po->pkt_type & (1 << skb->pkt_type)))
- 		goto out;
- 
- 	if (!net_eq(dev_net(dev), sock_net(sk)))
-@@ -2036,12 +2038,12 @@ static int packet_rcv(struct sk_buff *sk
- 	unsigned int snaplen, res;
- 	bool is_drop_n_account = false;
- 
--	if (skb->pkt_type == PACKET_LOOPBACK)
--		goto drop;
--
- 	sk = pt->af_packet_priv;
- 	po = pkt_sk(sk);
- 
-+	if (!(po->pkt_type & (1 << skb->pkt_type)))
-+		goto drop;
-+
- 	if (!net_eq(dev_net(dev), sock_net(sk)))
- 		goto drop;
- 
-@@ -2167,12 +2169,12 @@ static int tpacket_rcv(struct sk_buff *s
- 	BUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h2)) != 32);
- 	BUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h3)) != 48);
- 
--	if (skb->pkt_type == PACKET_LOOPBACK)
--		goto drop;
--
- 	sk = pt->af_packet_priv;
- 	po = pkt_sk(sk);
- 
-+	if (!(po->pkt_type & (1 << skb->pkt_type)))
-+		goto drop;
-+
- 	if (!net_eq(dev_net(dev), sock_net(sk)))
- 		goto drop;
- 
-@@ -3258,6 +3260,7 @@ static int packet_create(struct net *net
- 	mutex_init(&po->pg_vec_lock);
- 	po->rollover = NULL;
- 	po->prot_hook.func = packet_rcv;
-+	po->pkt_type = PACKET_MASK_ANY & ~(1 << PACKET_LOOPBACK);
- 
- 	if (sock->type == SOCK_PACKET)
- 		po->prot_hook.func = packet_rcv_spkt;
-@@ -3869,6 +3872,16 @@ packet_setsockopt(struct socket *sock, i
- 		po->xmit = val ? packet_direct_xmit : dev_queue_xmit;
- 		return 0;
- 	}
-+        case PACKET_RECV_TYPE:
-+        {
-+                unsigned int val;
-+                if (optlen != sizeof(val))
-+                        return -EINVAL;
-+                if (copy_from_user(&val, optval, sizeof(val)))
-+                        return -EFAULT;
-+                po->pkt_type = val & ~BIT(PACKET_LOOPBACK);
-+                return 0;
-+        }
- 	default:
- 		return -ENOPROTOOPT;
- 	}
-@@ -3921,6 +3934,13 @@ static int packet_getsockopt(struct sock
- 	case PACKET_VNET_HDR:
- 		val = po->has_vnet_hdr;
- 		break;
-+	case PACKET_RECV_TYPE:
-+		if (len > sizeof(unsigned int))
-+			len = sizeof(unsigned int);
-+		val = po->pkt_type;
-+
-+		data = &val;
-+		break;
- 	case PACKET_VERSION:
- 		val = po->tp_version;
- 		break;
---- a/net/packet/internal.h
-+++ b/net/packet/internal.h
-@@ -132,6 +132,7 @@ struct packet_sock {
- 	struct net_device __rcu	*cached_dev;
- 	int			(*xmit)(struct sk_buff *skb);
- 	struct packet_type	prot_hook ____cacheline_aligned_in_smp;
-+	unsigned int		pkt_type;
- };
- 
- static struct packet_sock *pkt_sk(struct sock *sk)
--- a/target/linux/generic/pending-4.19/640-netfilter-nf_flow_table-add-hardware-offload-support.patch	2022-03-22 08:54:47.411465009 +0800
+++ b/target/linux/generic/pending-4.19/640-netfilter-nf_flow_table-add-hardware-offload-support.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,564 +0,0 @@
-From: Pablo Neira Ayuso <pablo@netfilter.org>
-Date: Thu, 11 Jan 2018 16:32:00 +0100
-Subject: [PATCH] netfilter: nf_flow_table: add hardware offload support
-
-This patch adds the infrastructure to offload flows to hardware, in case
-the nic/switch comes with built-in flow tables capabilities.
-
-If the hardware comes with no hardware flow tables or they have
-limitations in terms of features, the existing infrastructure falls back
-to the software flow table implementation.
-
-The software flow table garbage collector skips entries that resides in
-the hardware, so the hardware will be responsible for releasing this
-flow table entry too via flow_offload_dead().
-
-Hardware configuration, either to add or to delete entries, is done from
-the hardware offload workqueue, to ensure this is done from user context
-given that we may sleep when grabbing the mdio mutex.
-
-Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
----
- create mode 100644 net/netfilter/nf_flow_table_hw.c
-
---- a/include/linux/netdevice.h
-+++ b/include/linux/netdevice.h
-@@ -918,6 +918,13 @@ struct dev_ifalias {
- 	char ifalias[];
- };
- 
-+struct flow_offload;
-+
-+enum flow_offload_type {
-+	FLOW_OFFLOAD_ADD	= 0,
-+	FLOW_OFFLOAD_DEL,
-+};
-+
- /*
-  * This structure defines the management hooks for network devices.
-  * The following hooks can be defined; unless noted otherwise, they are
-@@ -1150,6 +1157,10 @@ struct dev_ifalias {
-  * int (*ndo_bridge_dellink)(struct net_device *dev, struct nlmsghdr *nlh,
-  *			     u16 flags);
-  *
-+ * int (*ndo_flow_offload)(enum flow_offload_type type,
-+ *			   struct flow_offload *flow);
-+ *	Adds/deletes flow entry to/from net device flowtable.
-+ *
-  * int (*ndo_change_carrier)(struct net_device *dev, bool new_carrier);
-  *	Called to change device carrier. Soft-devices (like dummy, team, etc)
-  *	which do not represent real hardware may define this to allow their
-@@ -1377,6 +1388,8 @@ struct net_device_ops {
- 	int			(*ndo_bridge_dellink)(struct net_device *dev,
- 						      struct nlmsghdr *nlh,
- 						      u16 flags);
-+	int			(*ndo_flow_offload)(enum flow_offload_type type,
-+						    struct flow_offload *flow);
- 	int			(*ndo_change_carrier)(struct net_device *dev,
- 						      bool new_carrier);
- 	int			(*ndo_get_phys_port_id)(struct net_device *dev,
---- a/include/net/netfilter/nf_flow_table.h
-+++ b/include/net/netfilter/nf_flow_table.h
-@@ -20,11 +20,17 @@ struct nf_flowtable_type {
- 	struct module			*owner;
- };
- 
-+enum nf_flowtable_flags {
-+	NF_FLOWTABLE_F_HW		= 0x1,
-+};
-+
- struct nf_flowtable {
- 	struct list_head		list;
- 	struct rhashtable		rhashtable;
- 	const struct nf_flowtable_type	*type;
-+	u32				flags;
- 	struct delayed_work		gc_work;
-+	possible_net_t			ft_net;
- };
- 
- enum flow_offload_tuple_dir {
-@@ -69,6 +75,7 @@ struct flow_offload_tuple_rhash {
- #define FLOW_OFFLOAD_DNAT	0x2
- #define FLOW_OFFLOAD_DYING	0x4
- #define FLOW_OFFLOAD_TEARDOWN	0x8
-+#define FLOW_OFFLOAD_HW		0x10
- 
- struct flow_offload {
- 	struct flow_offload_tuple_rhash		tuplehash[FLOW_OFFLOAD_DIR_MAX];
-@@ -125,6 +132,22 @@ unsigned int nf_flow_offload_ip_hook(voi
- unsigned int nf_flow_offload_ipv6_hook(void *priv, struct sk_buff *skb,
- 				       const struct nf_hook_state *state);
- 
-+void nf_flow_offload_hw_add(struct net *net, struct flow_offload *flow,
-+			    struct nf_conn *ct);
-+void nf_flow_offload_hw_del(struct net *net, struct flow_offload *flow);
-+
-+struct nf_flow_table_hw {
-+	struct module	*owner;
-+	void		(*add)(struct net *net, struct flow_offload *flow,
-+			       struct nf_conn *ct);
-+	void		(*del)(struct net *net, struct flow_offload *flow);
-+};
-+
-+int nf_flow_table_hw_register(const struct nf_flow_table_hw *offload);
-+void nf_flow_table_hw_unregister(const struct nf_flow_table_hw *offload);
-+
-+extern struct work_struct nf_flow_offload_hw_work;
-+
- #define MODULE_ALIAS_NF_FLOWTABLE(family)	\
- 	MODULE_ALIAS("nf-flowtable-" __stringify(family))
- 
---- a/include/uapi/linux/netfilter/nf_tables.h
-+++ b/include/uapi/linux/netfilter/nf_tables.h
-@@ -1464,6 +1464,7 @@ enum nft_object_attributes {
-  * @NFTA_FLOWTABLE_HOOK: netfilter hook configuration(NLA_U32)
-  * @NFTA_FLOWTABLE_USE: number of references to this flow table (NLA_U32)
-  * @NFTA_FLOWTABLE_HANDLE: object handle (NLA_U64)
-+ * @NFTA_FLOWTABLE_FLAGS: flags (NLA_U32)
-  */
- enum nft_flowtable_attributes {
- 	NFTA_FLOWTABLE_UNSPEC,
-@@ -1473,6 +1474,7 @@ enum nft_flowtable_attributes {
- 	NFTA_FLOWTABLE_USE,
- 	NFTA_FLOWTABLE_HANDLE,
- 	NFTA_FLOWTABLE_PAD,
-+	NFTA_FLOWTABLE_FLAGS,
- 	__NFTA_FLOWTABLE_MAX
- };
- #define NFTA_FLOWTABLE_MAX	(__NFTA_FLOWTABLE_MAX - 1)
---- a/net/netfilter/Kconfig
-+++ b/net/netfilter/Kconfig
-@@ -714,6 +714,15 @@ config NF_FLOW_TABLE
- 
- 	  To compile it as a module, choose M here.
- 
-+config NF_FLOW_TABLE_HW
-+	tristate "Netfilter flow table hardware offload module"
-+	depends on NF_FLOW_TABLE
-+	help
-+	  This option adds hardware offload support for the flow table core
-+	  infrastructure.
-+
-+	  To compile it as a module, choose M here.
-+
- config NETFILTER_XTABLES
- 	tristate "Netfilter Xtables support (required for ip_tables)"
- 	default m if NETFILTER_ADVANCED=n
---- a/net/netfilter/Makefile
-+++ b/net/netfilter/Makefile
-@@ -126,6 +126,7 @@ obj-$(CONFIG_NF_FLOW_TABLE)	+= nf_flow_t
- nf_flow_table-objs := nf_flow_table_core.o nf_flow_table_ip.o
- 
- obj-$(CONFIG_NF_FLOW_TABLE_INET) += nf_flow_table_inet.o
-+obj-$(CONFIG_NF_FLOW_TABLE_HW)	+= nf_flow_table_hw.o
- 
- # generic X tables 
- obj-$(CONFIG_NETFILTER_XTABLES) += x_tables.o xt_tcpudp.o
---- a/net/netfilter/nf_flow_table_core.c
-+++ b/net/netfilter/nf_flow_table_core.c
-@@ -228,10 +228,16 @@ int flow_offload_add(struct nf_flowtable
- }
- EXPORT_SYMBOL_GPL(flow_offload_add);
- 
-+static inline bool nf_flow_in_hw(const struct flow_offload *flow)
-+{
-+	return flow->flags & FLOW_OFFLOAD_HW;
-+}
-+
- static void flow_offload_del(struct nf_flowtable *flow_table,
- 			     struct flow_offload *flow)
- {
- 	struct flow_offload_entry *e;
-+	struct net *net = read_pnet(&flow_table->ft_net);
- 
- 	rhashtable_remove_fast(&flow_table->rhashtable,
- 			       &flow->tuplehash[FLOW_OFFLOAD_DIR_ORIGINAL].node,
-@@ -246,6 +252,9 @@ static void flow_offload_del(struct nf_f
- 	if (!(flow->flags & FLOW_OFFLOAD_TEARDOWN))
- 		flow_offload_fixup_ct_state(e->ct);
- 
-+	if (nf_flow_in_hw(flow))
-+		nf_flow_offload_hw_del(net, flow);
-+
- 	flow_offload_free(flow);
- }
- 
-@@ -359,6 +368,9 @@ static int nf_flow_offload_gc_step(struc
- 		if (!teardown)
- 			nf_ct_offload_timeout(flow);
- 
-+		if (nf_flow_in_hw(flow) && !teardown)
-+			continue;
-+
- 		if (nf_flow_has_expired(flow) || teardown)
- 			flow_offload_del(flow_table, flow);
- 	}
-@@ -494,10 +506,43 @@ int nf_flow_dnat_port(const struct flow_
- }
- EXPORT_SYMBOL_GPL(nf_flow_dnat_port);
- 
-+static const struct nf_flow_table_hw __rcu *nf_flow_table_hw_hook __read_mostly;
-+
-+static int nf_flow_offload_hw_init(struct nf_flowtable *flow_table)
-+{
-+	const struct nf_flow_table_hw *offload;
-+
-+	if (!rcu_access_pointer(nf_flow_table_hw_hook))
-+		request_module("nf-flow-table-hw");
-+
-+	rcu_read_lock();
-+	offload = rcu_dereference(nf_flow_table_hw_hook);
-+	if (!offload)
-+		goto err_no_hw_offload;
-+
-+	if (!try_module_get(offload->owner))
-+		goto err_no_hw_offload;
-+
-+	rcu_read_unlock();
-+
-+	return 0;
-+
-+err_no_hw_offload:
-+	rcu_read_unlock();
-+
-+	return -EOPNOTSUPP;
-+}
-+
- int nf_flow_table_init(struct nf_flowtable *flowtable)
- {
- 	int err;
- 
-+	if (flowtable->flags & NF_FLOWTABLE_F_HW) {
-+		err = nf_flow_offload_hw_init(flowtable);
-+		if (err)
-+			return err;
-+	}
-+
- 	INIT_DEFERRABLE_WORK(&flowtable->gc_work, nf_flow_offload_work_gc);
- 
- 	err = rhashtable_init(&flowtable->rhashtable,
-@@ -535,6 +580,8 @@ static void nf_flow_table_iterate_cleanu
- {
- 	nf_flow_table_iterate(flowtable, nf_flow_table_do_cleanup, dev);
- 	flush_delayed_work(&flowtable->gc_work);
-+	if (flowtable->flags & NF_FLOWTABLE_F_HW)
-+		flush_work(&nf_flow_offload_hw_work);
- }
- 
- void nf_flow_table_cleanup(struct net *net, struct net_device *dev)
-@@ -548,6 +595,26 @@ void nf_flow_table_cleanup(struct net *n
- }
- EXPORT_SYMBOL_GPL(nf_flow_table_cleanup);
- 
-+struct work_struct nf_flow_offload_hw_work;
-+EXPORT_SYMBOL_GPL(nf_flow_offload_hw_work);
-+
-+/* Give the hardware workqueue the chance to remove entries from hardware.*/
-+static void nf_flow_offload_hw_free(struct nf_flowtable *flowtable)
-+{
-+	const struct nf_flow_table_hw *offload;
-+
-+	flush_work(&nf_flow_offload_hw_work);
-+
-+	rcu_read_lock();
-+	offload = rcu_dereference(nf_flow_table_hw_hook);
-+	if (!offload) {
-+		rcu_read_unlock();
-+		return;
-+	}
-+	module_put(offload->owner);
-+	rcu_read_unlock();
-+}
-+
- void nf_flow_table_free(struct nf_flowtable *flow_table)
- {
- 	mutex_lock(&flowtable_lock);
-@@ -557,9 +624,58 @@ void nf_flow_table_free(struct nf_flowta
- 	nf_flow_table_iterate(flow_table, nf_flow_table_do_cleanup, NULL);
- 	WARN_ON(!nf_flow_offload_gc_step(flow_table));
- 	rhashtable_destroy(&flow_table->rhashtable);
-+	if (flow_table->flags & NF_FLOWTABLE_F_HW)
-+		nf_flow_offload_hw_free(flow_table);
- }
- EXPORT_SYMBOL_GPL(nf_flow_table_free);
- 
-+/* Must be called from user context. */
-+void nf_flow_offload_hw_add(struct net *net, struct flow_offload *flow,
-+			    struct nf_conn *ct)
-+{
-+	const struct nf_flow_table_hw *offload;
-+
-+	rcu_read_lock();
-+	offload = rcu_dereference(nf_flow_table_hw_hook);
-+	if (offload)
-+		offload->add(net, flow, ct);
-+	rcu_read_unlock();
-+}
-+EXPORT_SYMBOL_GPL(nf_flow_offload_hw_add);
-+
-+/* Must be called from user context. */
-+void nf_flow_offload_hw_del(struct net *net, struct flow_offload *flow)
-+{
-+	const struct nf_flow_table_hw *offload;
-+
-+	rcu_read_lock();
-+	offload = rcu_dereference(nf_flow_table_hw_hook);
-+	if (offload)
-+		offload->del(net, flow);
-+	rcu_read_unlock();
-+}
-+EXPORT_SYMBOL_GPL(nf_flow_offload_hw_del);
-+
-+int nf_flow_table_hw_register(const struct nf_flow_table_hw *offload)
-+{
-+	if (rcu_access_pointer(nf_flow_table_hw_hook))
-+		return -EBUSY;
-+
-+	rcu_assign_pointer(nf_flow_table_hw_hook, offload);
-+
-+	return 0;
-+}
-+EXPORT_SYMBOL_GPL(nf_flow_table_hw_register);
-+
-+void nf_flow_table_hw_unregister(const struct nf_flow_table_hw *offload)
-+{
-+	WARN_ON(rcu_access_pointer(nf_flow_table_hw_hook) != offload);
-+	rcu_assign_pointer(nf_flow_table_hw_hook, NULL);
-+
-+	synchronize_rcu();
-+}
-+EXPORT_SYMBOL_GPL(nf_flow_table_hw_unregister);
-+
- static int nf_flow_table_netdev_event(struct notifier_block *this,
- 				      unsigned long event, void *ptr)
- {
---- /dev/null
-+++ b/net/netfilter/nf_flow_table_hw.c
-@@ -0,0 +1,169 @@
-+#include <linux/kernel.h>
-+#include <linux/init.h>
-+#include <linux/module.h>
-+#include <linux/netfilter.h>
-+#include <linux/rhashtable.h>
-+#include <linux/netdevice.h>
-+#include <net/netfilter/nf_flow_table.h>
-+#include <net/netfilter/nf_conntrack.h>
-+#include <net/netfilter/nf_conntrack_core.h>
-+#include <net/netfilter/nf_conntrack_tuple.h>
-+
-+static DEFINE_SPINLOCK(flow_offload_hw_pending_list_lock);
-+static LIST_HEAD(flow_offload_hw_pending_list);
-+
-+static DEFINE_MUTEX(nf_flow_offload_hw_mutex);
-+
-+struct flow_offload_hw {
-+	struct list_head	list;
-+	enum flow_offload_type	type;
-+	struct flow_offload	*flow;
-+	struct nf_conn		*ct;
-+	possible_net_t		flow_hw_net;
-+};
-+
-+static int do_flow_offload_hw(struct net *net, struct flow_offload *flow,
-+			      int type)
-+{
-+	struct net_device *indev;
-+	int ret, ifindex;
-+
-+	ifindex = flow->tuplehash[FLOW_OFFLOAD_DIR_ORIGINAL].tuple.iifidx;
-+	indev = dev_get_by_index(net, ifindex);
-+	if (WARN_ON(!indev))
-+		return 0;
-+
-+	mutex_lock(&nf_flow_offload_hw_mutex);
-+	ret = indev->netdev_ops->ndo_flow_offload(type, flow);
-+	mutex_unlock(&nf_flow_offload_hw_mutex);
-+
-+	dev_put(indev);
-+
-+	return ret;
-+}
-+
-+static void flow_offload_hw_work_add(struct flow_offload_hw *offload)
-+{
-+	struct net *net;
-+	int ret;
-+
-+	if (nf_ct_is_dying(offload->ct))
-+		return;
-+
-+	net = read_pnet(&offload->flow_hw_net);
-+	ret = do_flow_offload_hw(net, offload->flow, FLOW_OFFLOAD_ADD);
-+	if (ret >= 0)
-+		offload->flow->flags |= FLOW_OFFLOAD_HW;
-+}
-+
-+static void flow_offload_hw_work_del(struct flow_offload_hw *offload)
-+{
-+	struct net *net = read_pnet(&offload->flow_hw_net);
-+
-+	do_flow_offload_hw(net, offload->flow, FLOW_OFFLOAD_DEL);
-+}
-+
-+static void flow_offload_hw_work(struct work_struct *work)
-+{
-+	struct flow_offload_hw *offload, *next;
-+	LIST_HEAD(hw_offload_pending);
-+
-+	spin_lock_bh(&flow_offload_hw_pending_list_lock);
-+	list_replace_init(&flow_offload_hw_pending_list, &hw_offload_pending);
-+	spin_unlock_bh(&flow_offload_hw_pending_list_lock);
-+
-+	list_for_each_entry_safe(offload, next, &hw_offload_pending, list) {
-+		switch (offload->type) {
-+		case FLOW_OFFLOAD_ADD:
-+			flow_offload_hw_work_add(offload);
-+			break;
-+		case FLOW_OFFLOAD_DEL:
-+			flow_offload_hw_work_del(offload);
-+			break;
-+		}
-+		if (offload->ct)
-+			nf_conntrack_put(&offload->ct->ct_general);
-+		list_del(&offload->list);
-+		kfree(offload);
-+	}
-+}
-+
-+static void flow_offload_queue_work(struct flow_offload_hw *offload)
-+{
-+	spin_lock_bh(&flow_offload_hw_pending_list_lock);
-+	list_add_tail(&offload->list, &flow_offload_hw_pending_list);
-+	spin_unlock_bh(&flow_offload_hw_pending_list_lock);
-+
-+	schedule_work(&nf_flow_offload_hw_work);
-+}
-+
-+static void flow_offload_hw_add(struct net *net, struct flow_offload *flow,
-+				struct nf_conn *ct)
-+{
-+	struct flow_offload_hw *offload;
-+
-+	offload = kmalloc(sizeof(struct flow_offload_hw), GFP_ATOMIC);
-+	if (!offload)
-+		return;
-+
-+	nf_conntrack_get(&ct->ct_general);
-+	offload->type = FLOW_OFFLOAD_ADD;
-+	offload->ct = ct;
-+	offload->flow = flow;
-+	write_pnet(&offload->flow_hw_net, net);
-+
-+	flow_offload_queue_work(offload);
-+}
-+
-+static void flow_offload_hw_del(struct net *net, struct flow_offload *flow)
-+{
-+	struct flow_offload_hw *offload;
-+
-+	offload = kmalloc(sizeof(struct flow_offload_hw), GFP_ATOMIC);
-+	if (!offload)
-+		return;
-+
-+	offload->type = FLOW_OFFLOAD_DEL;
-+	offload->ct = NULL;
-+	offload->flow = flow;
-+	write_pnet(&offload->flow_hw_net, net);
-+
-+	flow_offload_queue_work(offload);
-+}
-+
-+static const struct nf_flow_table_hw flow_offload_hw = {
-+	.add	= flow_offload_hw_add,
-+	.del	= flow_offload_hw_del,
-+	.owner	= THIS_MODULE,
-+};
-+
-+static int __init nf_flow_table_hw_module_init(void)
-+{
-+	INIT_WORK(&nf_flow_offload_hw_work, flow_offload_hw_work);
-+	nf_flow_table_hw_register(&flow_offload_hw);
-+
-+	return 0;
-+}
-+
-+static void __exit nf_flow_table_hw_module_exit(void)
-+{
-+	struct flow_offload_hw *offload, *next;
-+	LIST_HEAD(hw_offload_pending);
-+
-+	nf_flow_table_hw_unregister(&flow_offload_hw);
-+	cancel_work_sync(&nf_flow_offload_hw_work);
-+
-+	list_for_each_entry_safe(offload, next, &hw_offload_pending, list) {
-+		if (offload->ct)
-+			nf_conntrack_put(&offload->ct->ct_general);
-+		list_del(&offload->list);
-+		kfree(offload);
-+	}
-+}
-+
-+module_init(nf_flow_table_hw_module_init);
-+module_exit(nf_flow_table_hw_module_exit);
-+
-+MODULE_LICENSE("GPL");
-+MODULE_AUTHOR("Pablo Neira Ayuso <pablo@netfilter.org>");
-+MODULE_ALIAS("nf-flow-table-hw");
---- a/net/netfilter/nf_tables_api.c
-+++ b/net/netfilter/nf_tables_api.c
-@@ -5473,6 +5473,13 @@ static int nf_tables_flowtable_parse_hoo
- 	if (err < 0)
- 		return err;
- 
-+	for (i = 0; i < n; i++) {
-+		if (flowtable->data.flags & NF_FLOWTABLE_F_HW &&
-+		    !dev_array[i]->netdev_ops->ndo_flow_offload) {
-+			return -EOPNOTSUPP;
-+		}
-+	}
-+
- 	ops = kcalloc(n, sizeof(struct nf_hook_ops), GFP_KERNEL);
- 	if (!ops)
- 		return -ENOMEM;
-@@ -5604,10 +5611,19 @@ static int nf_tables_newflowtable(struct
- 	}
- 
- 	flowtable->data.type = type;
-+	write_pnet(&flowtable->data.ft_net, net);
-+
- 	err = type->init(&flowtable->data);
- 	if (err < 0)
- 		goto err3;
- 
-+	if (nla[NFTA_FLOWTABLE_FLAGS]) {
-+		flowtable->data.flags =
-+			ntohl(nla_get_be32(nla[NFTA_FLOWTABLE_FLAGS]));
-+		if (flowtable->data.flags & ~NF_FLOWTABLE_F_HW)
-+			goto err4;
-+	}
-+
- 	err = nf_tables_flowtable_parse_hook(&ctx, nla[NFTA_FLOWTABLE_HOOK],
- 					     flowtable);
- 	if (err < 0)
-@@ -5733,7 +5749,8 @@ static int nf_tables_fill_flowtable_info
- 	    nla_put_string(skb, NFTA_FLOWTABLE_NAME, flowtable->name) ||
- 	    nla_put_be32(skb, NFTA_FLOWTABLE_USE, htonl(flowtable->use)) ||
- 	    nla_put_be64(skb, NFTA_FLOWTABLE_HANDLE, cpu_to_be64(flowtable->handle),
--			 NFTA_FLOWTABLE_PAD))
-+			 NFTA_FLOWTABLE_PAD) ||
-+	    nla_put_be32(skb, NFTA_FLOWTABLE_FLAGS, htonl(flowtable->data.flags)))
- 		goto nla_put_failure;
- 
- 	nest = nla_nest_start(skb, NFTA_FLOWTABLE_HOOK);
---- a/net/netfilter/nft_flow_offload.c
-+++ b/net/netfilter/nft_flow_offload.c
-@@ -127,6 +127,9 @@ static void nft_flow_offload_eval(const
- 	if (ret < 0)
- 		goto err_flow_add;
- 
-+	if (flowtable->flags & NF_FLOWTABLE_F_HW)
-+		nf_flow_offload_hw_add(nft_net(pkt), flow, ct);
-+
- 	dst_release(route.tuple[!dir].dst);
- 	return;
- 
--- a/target/linux/generic/pending-4.19/641-netfilter-nf_flow_table-support-hw-offload-through-v.patch	2022-03-22 08:54:47.412465011 +0800
+++ b/target/linux/generic/pending-4.19/641-netfilter-nf_flow_table-support-hw-offload-through-v.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,303 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Thu, 15 Mar 2018 20:46:31 +0100
-Subject: [PATCH] netfilter: nf_flow_table: support hw offload through
- virtual interfaces
-
-There are hardware offload devices that support offloading VLANs and
-PPPoE devices. Additionally, it is useful to be able to offload packets
-routed through bridge interfaces as well.
-Add support for finding the path to the offload device through these
-virtual interfaces, while collecting useful parameters for the offload
-device, like VLAN ID/protocol, PPPoE session and Ethernet MAC address.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/include/linux/netdevice.h
-+++ b/include/linux/netdevice.h
-@@ -919,6 +919,7 @@ struct dev_ifalias {
- };
- 
- struct flow_offload;
-+struct flow_offload_hw_path;
- 
- enum flow_offload_type {
- 	FLOW_OFFLOAD_ADD	= 0,
-@@ -1157,8 +1158,15 @@ enum flow_offload_type {
-  * int (*ndo_bridge_dellink)(struct net_device *dev, struct nlmsghdr *nlh,
-  *			     u16 flags);
-  *
-+ * int (*ndo_flow_offload_check)(struct flow_offload_hw_path *path);
-+ *	For virtual devices like bridges, vlan, and pppoe, fill in the
-+ *	underlying network device that can be used for offloading connections.
-+ *	Return an error if offloading is not supported.
-+ *
-  * int (*ndo_flow_offload)(enum flow_offload_type type,
-- *			   struct flow_offload *flow);
-+ *			   struct flow_offload *flow,
-+ *			   struct flow_offload_hw_path *src,
-+ *			   struct flow_offload_hw_path *dest);
-  *	Adds/deletes flow entry to/from net device flowtable.
-  *
-  * int (*ndo_change_carrier)(struct net_device *dev, bool new_carrier);
-@@ -1388,8 +1396,11 @@ struct net_device_ops {
- 	int			(*ndo_bridge_dellink)(struct net_device *dev,
- 						      struct nlmsghdr *nlh,
- 						      u16 flags);
-+	int			(*ndo_flow_offload_check)(struct flow_offload_hw_path *path);
- 	int			(*ndo_flow_offload)(enum flow_offload_type type,
--						    struct flow_offload *flow);
-+						    struct flow_offload *flow,
-+						    struct flow_offload_hw_path *src,
-+						    struct flow_offload_hw_path *dest);
- 	int			(*ndo_change_carrier)(struct net_device *dev,
- 						      bool new_carrier);
- 	int			(*ndo_get_phys_port_id)(struct net_device *dev,
---- a/include/net/netfilter/nf_flow_table.h
-+++ b/include/net/netfilter/nf_flow_table.h
-@@ -86,6 +86,21 @@ struct flow_offload {
- 	};
- };
- 
-+#define FLOW_OFFLOAD_PATH_ETHERNET	BIT(0)
-+#define FLOW_OFFLOAD_PATH_VLAN		BIT(1)
-+#define FLOW_OFFLOAD_PATH_PPPOE		BIT(2)
-+
-+struct flow_offload_hw_path {
-+	struct net_device *dev;
-+	u32 flags;
-+
-+	u8 eth_src[ETH_ALEN];
-+	u8 eth_dest[ETH_ALEN];
-+	u16 vlan_proto;
-+	u16 vlan_id;
-+	u16 pppoe_sid;
-+};
-+
- #define NF_FLOW_TIMEOUT (30 * HZ)
- 
- struct nf_flow_route {
---- a/net/netfilter/nf_flow_table_hw.c
-+++ b/net/netfilter/nf_flow_table_hw.c
-@@ -19,48 +19,75 @@ struct flow_offload_hw {
- 	enum flow_offload_type	type;
- 	struct flow_offload	*flow;
- 	struct nf_conn		*ct;
--	possible_net_t		flow_hw_net;
-+
-+	struct flow_offload_hw_path src;
-+	struct flow_offload_hw_path dest;
- };
- 
--static int do_flow_offload_hw(struct net *net, struct flow_offload *flow,
--			      int type)
-+static void flow_offload_check_ethernet(struct flow_offload_tuple *tuple,
-+					struct flow_offload_hw_path *path)
- {
--	struct net_device *indev;
--	int ret, ifindex;
-+	struct net_device *dev = path->dev;
-+	struct neighbour *n;
- 
--	ifindex = flow->tuplehash[FLOW_OFFLOAD_DIR_ORIGINAL].tuple.iifidx;
--	indev = dev_get_by_index(net, ifindex);
--	if (WARN_ON(!indev))
--		return 0;
--
--	mutex_lock(&nf_flow_offload_hw_mutex);
--	ret = indev->netdev_ops->ndo_flow_offload(type, flow);
--	mutex_unlock(&nf_flow_offload_hw_mutex);
-+	if (dev->type != ARPHRD_ETHER)
-+		return;
- 
--	dev_put(indev);
-+	memcpy(path->eth_src, path->dev->dev_addr, ETH_ALEN);
-+	n = dst_neigh_lookup(tuple->dst_cache, &tuple->src_v4);
-+	if (!n)
-+		return;
- 
--	return ret;
-+	memcpy(path->eth_dest, n->ha, ETH_ALEN);
-+	path->flags |= FLOW_OFFLOAD_PATH_ETHERNET;
-+	neigh_release(n);
- }
- 
--static void flow_offload_hw_work_add(struct flow_offload_hw *offload)
-+static int flow_offload_check_path(struct net *net,
-+				   struct flow_offload_tuple *tuple,
-+				   struct flow_offload_hw_path *path)
- {
--	struct net *net;
--	int ret;
-+	struct net_device *dev;
- 
--	if (nf_ct_is_dying(offload->ct))
--		return;
-+	dev = dev_get_by_index_rcu(net, tuple->iifidx);
-+	if (!dev)
-+		return -ENOENT;
-+
-+	path->dev = dev;
-+	flow_offload_check_ethernet(tuple, path);
- 
--	net = read_pnet(&offload->flow_hw_net);
--	ret = do_flow_offload_hw(net, offload->flow, FLOW_OFFLOAD_ADD);
--	if (ret >= 0)
--		offload->flow->flags |= FLOW_OFFLOAD_HW;
-+	if (dev->netdev_ops->ndo_flow_offload_check)
-+		return dev->netdev_ops->ndo_flow_offload_check(path);
-+
-+	return 0;
- }
- 
--static void flow_offload_hw_work_del(struct flow_offload_hw *offload)
-+static int do_flow_offload_hw(struct flow_offload_hw *offload)
- {
--	struct net *net = read_pnet(&offload->flow_hw_net);
-+	struct net_device *src_dev = offload->src.dev;
-+	struct net_device *dest_dev = offload->dest.dev;
-+	int ret;
-+
-+	ret = src_dev->netdev_ops->ndo_flow_offload(offload->type,
-+						    offload->flow,
-+						    &offload->src,
-+						    &offload->dest);
-+
-+	/* restore devices in case the driver mangled them */
-+	offload->src.dev = src_dev;
-+	offload->dest.dev = dest_dev;
-+
-+	return ret;
-+}
- 
--	do_flow_offload_hw(net, offload->flow, FLOW_OFFLOAD_DEL);
-+static void flow_offload_hw_free(struct flow_offload_hw *offload)
-+{
-+	dev_put(offload->src.dev);
-+	dev_put(offload->dest.dev);
-+	if (offload->ct)
-+		nf_conntrack_put(&offload->ct->ct_general);
-+	list_del(&offload->list);
-+	kfree(offload);
- }
- 
- static void flow_offload_hw_work(struct work_struct *work)
-@@ -73,18 +100,22 @@ static void flow_offload_hw_work(struct
- 	spin_unlock_bh(&flow_offload_hw_pending_list_lock);
- 
- 	list_for_each_entry_safe(offload, next, &hw_offload_pending, list) {
-+		mutex_lock(&nf_flow_offload_hw_mutex);
- 		switch (offload->type) {
- 		case FLOW_OFFLOAD_ADD:
--			flow_offload_hw_work_add(offload);
-+			if (nf_ct_is_dying(offload->ct))
-+				break;
-+
-+			if (do_flow_offload_hw(offload) >= 0)
-+				offload->flow->flags |= FLOW_OFFLOAD_HW;
- 			break;
- 		case FLOW_OFFLOAD_DEL:
--			flow_offload_hw_work_del(offload);
-+			do_flow_offload_hw(offload);
- 			break;
- 		}
--		if (offload->ct)
--			nf_conntrack_put(&offload->ct->ct_general);
--		list_del(&offload->list);
--		kfree(offload);
-+		mutex_unlock(&nf_flow_offload_hw_mutex);
-+
-+		flow_offload_hw_free(offload);
- 	}
- }
- 
-@@ -97,20 +128,55 @@ static void flow_offload_queue_work(stru
- 	schedule_work(&nf_flow_offload_hw_work);
- }
- 
-+static struct flow_offload_hw *
-+flow_offload_hw_prepare(struct net *net, struct flow_offload *flow)
-+{
-+	struct flow_offload_hw_path src = {};
-+	struct flow_offload_hw_path dest = {};
-+	struct flow_offload_tuple *tuple;
-+	struct flow_offload_hw *offload = NULL;
-+
-+	rcu_read_lock_bh();
-+
-+	tuple = &flow->tuplehash[FLOW_OFFLOAD_DIR_ORIGINAL].tuple;
-+	if (flow_offload_check_path(net, tuple, &src))
-+		goto out;
-+
-+	tuple = &flow->tuplehash[FLOW_OFFLOAD_DIR_REPLY].tuple;
-+	if (flow_offload_check_path(net, tuple, &dest))
-+		goto out;
-+
-+	if (!src.dev->netdev_ops->ndo_flow_offload)
-+		goto out;
-+
-+	offload = kzalloc(sizeof(struct flow_offload_hw), GFP_ATOMIC);
-+	if (!offload)
-+		goto out;
-+
-+	dev_hold(src.dev);
-+	dev_hold(dest.dev);
-+	offload->src = src;
-+	offload->dest = dest;
-+	offload->flow = flow;
-+
-+out:
-+	rcu_read_unlock_bh();
-+
-+	return offload;
-+}
-+
- static void flow_offload_hw_add(struct net *net, struct flow_offload *flow,
- 				struct nf_conn *ct)
- {
- 	struct flow_offload_hw *offload;
- 
--	offload = kmalloc(sizeof(struct flow_offload_hw), GFP_ATOMIC);
-+	offload = flow_offload_hw_prepare(net, flow);
- 	if (!offload)
- 		return;
- 
- 	nf_conntrack_get(&ct->ct_general);
- 	offload->type = FLOW_OFFLOAD_ADD;
- 	offload->ct = ct;
--	offload->flow = flow;
--	write_pnet(&offload->flow_hw_net, net);
- 
- 	flow_offload_queue_work(offload);
- }
-@@ -119,14 +185,11 @@ static void flow_offload_hw_del(struct n
- {
- 	struct flow_offload_hw *offload;
- 
--	offload = kmalloc(sizeof(struct flow_offload_hw), GFP_ATOMIC);
-+	offload = flow_offload_hw_prepare(net, flow);
- 	if (!offload)
- 		return;
- 
- 	offload->type = FLOW_OFFLOAD_DEL;
--	offload->ct = NULL;
--	offload->flow = flow;
--	write_pnet(&offload->flow_hw_net, net);
- 
- 	flow_offload_queue_work(offload);
- }
-@@ -153,12 +216,8 @@ static void __exit nf_flow_table_hw_modu
- 	nf_flow_table_hw_unregister(&flow_offload_hw);
- 	cancel_work_sync(&nf_flow_offload_hw_work);
- 
--	list_for_each_entry_safe(offload, next, &hw_offload_pending, list) {
--		if (offload->ct)
--			nf_conntrack_put(&offload->ct->ct_general);
--		list_del(&offload->list);
--		kfree(offload);
--	}
-+	list_for_each_entry_safe(offload, next, &hw_offload_pending, list)
-+		flow_offload_hw_free(offload);
- }
- 
- module_init(nf_flow_table_hw_module_init);
--- a/target/linux/generic/pending-4.19/642-net-8021q-support-hardware-flow-table-offload.patch	2022-03-22 08:54:47.412465011 +0800
+++ b/target/linux/generic/pending-4.19/642-net-8021q-support-hardware-flow-table-offload.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,60 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Thu, 15 Mar 2018 20:49:58 +0100
-Subject: [PATCH] net: 8021q: support hardware flow table offload
-
-Add the VLAN ID and protocol information
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/8021q/vlan_dev.c
-+++ b/net/8021q/vlan_dev.c
-@@ -32,6 +32,10 @@
- #include <linux/phy.h>
- #include <net/arp.h>
- #include <net/switchdev.h>
-+#if IS_ENABLED(CONFIG_NF_FLOW_TABLE)
-+#include <linux/netfilter.h>
-+#include <net/netfilter/nf_flow_table.h>
-+#endif
- 
- #include "vlan.h"
- #include "vlanproc.h"
-@@ -770,6 +774,27 @@ static int vlan_dev_get_iflink(const str
- 	return real_dev->ifindex;
- }
- 
-+#if IS_ENABLED(CONFIG_NF_FLOW_TABLE)
-+static int vlan_dev_flow_offload_check(struct flow_offload_hw_path *path)
-+{
-+	struct net_device *dev = path->dev;
-+	struct vlan_dev_priv *vlan = vlan_dev_priv(dev);
-+
-+	if (path->flags & FLOW_OFFLOAD_PATH_VLAN)
-+		return -EEXIST;
-+
-+	path->flags |= FLOW_OFFLOAD_PATH_VLAN;
-+	path->vlan_proto = vlan->vlan_proto;
-+	path->vlan_id = vlan->vlan_id;
-+	path->dev = vlan->real_dev;
-+
-+	if (vlan->real_dev->netdev_ops->ndo_flow_offload_check)
-+		return vlan->real_dev->netdev_ops->ndo_flow_offload_check(path);
-+
-+	return 0;
-+}
-+#endif /* CONFIG_NF_FLOW_TABLE */
-+
- static const struct ethtool_ops vlan_ethtool_ops = {
- 	.get_link_ksettings	= vlan_ethtool_get_link_ksettings,
- 	.get_drvinfo	        = vlan_ethtool_get_drvinfo,
-@@ -807,6 +832,9 @@ static const struct net_device_ops vlan_
- 	.ndo_fix_features	= vlan_dev_fix_features,
- 	.ndo_get_lock_subclass  = vlan_dev_get_lock_subclass,
- 	.ndo_get_iflink		= vlan_dev_get_iflink,
-+#if IS_ENABLED(CONFIG_NF_FLOW_TABLE)
-+	.ndo_flow_offload_check = vlan_dev_flow_offload_check,
-+#endif
- };
- 
- static void vlan_dev_free(struct net_device *dev)
--- a/target/linux/generic/pending-4.19/643-net-bridge-support-hardware-flow-table-offload.patch	2022-03-22 08:54:47.412465011 +0800
+++ b/target/linux/generic/pending-4.19/643-net-bridge-support-hardware-flow-table-offload.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,61 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Thu, 15 Mar 2018 20:50:37 +0100
-Subject: [PATCH] net: bridge: support hardware flow table offload
-
-Look up the real device and pass it on
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/bridge/br_device.c
-+++ b/net/bridge/br_device.c
-@@ -18,6 +18,10 @@
- #include <linux/ethtool.h>
- #include <linux/list.h>
- #include <linux/netfilter_bridge.h>
-+#if IS_ENABLED(CONFIG_NF_FLOW_TABLE)
-+#include <linux/netfilter.h>
-+#include <net/netfilter/nf_flow_table.h>
-+#endif
- 
- #include <linux/uaccess.h>
- #include "br_private.h"
-@@ -370,6 +374,28 @@ static const struct ethtool_ops br_ethto
- 	.get_link	= ethtool_op_get_link,
- };
- 
-+#if IS_ENABLED(CONFIG_NF_FLOW_TABLE)
-+static int br_flow_offload_check(struct flow_offload_hw_path *path)
-+{
-+	struct net_device *dev = path->dev;
-+	struct net_bridge *br = netdev_priv(dev);
-+	struct net_bridge_fdb_entry *dst;
-+
-+	if (!(path->flags & FLOW_OFFLOAD_PATH_ETHERNET))
-+		return -EINVAL;
-+
-+	dst = br_fdb_find_rcu(br, path->eth_dest, path->vlan_id);
-+	if (!dst || !dst->dst)
-+		return -ENOENT;
-+
-+	path->dev = dst->dst->dev;
-+	if (path->dev->netdev_ops->ndo_flow_offload_check)
-+		return path->dev->netdev_ops->ndo_flow_offload_check(path);
-+
-+	return 0;
-+}
-+#endif /* CONFIG_NF_FLOW_TABLE */
-+
- static const struct net_device_ops br_netdev_ops = {
- 	.ndo_open		 = br_dev_open,
- 	.ndo_stop		 = br_dev_stop,
-@@ -397,6 +423,9 @@ static const struct net_device_ops br_ne
- 	.ndo_bridge_setlink	 = br_setlink,
- 	.ndo_bridge_dellink	 = br_dellink,
- 	.ndo_features_check	 = passthru_features_check,
-+#if IS_ENABLED(CONFIG_NF_FLOW_TABLE)
-+	.ndo_flow_offload_check	 = br_flow_offload_check,
-+#endif
- };
- 
- static struct device_type br_type = {
--- a/target/linux/generic/pending-4.19/644-net-pppoe-support-hardware-flow-table-offload.patch	2022-03-22 08:54:47.413465013 +0800
+++ b/target/linux/generic/pending-4.19/644-net-pppoe-support-hardware-flow-table-offload.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,125 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Thu, 15 Mar 2018 21:15:00 +0100
-Subject: [PATCH] net: pppoe: support hardware flow table offload
-
-Pass on the PPPoE session ID and the remote MAC address
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/drivers/net/ppp/ppp_generic.c
-+++ b/drivers/net/ppp/ppp_generic.c
-@@ -57,6 +57,11 @@
- #include <net/net_namespace.h>
- #include <net/netns/generic.h>
- 
-+#if IS_ENABLED(CONFIG_NF_FLOW_TABLE)
-+#include <linux/netfilter.h>
-+#include <net/netfilter/nf_flow_table.h>
-+#endif
-+
- #define PPP_VERSION	"2.4.2"
- 
- /*
-@@ -1368,12 +1373,37 @@ static void ppp_dev_priv_destructor(stru
- 		ppp_destroy_interface(ppp);
- }
- 
-+#if IS_ENABLED(CONFIG_NF_FLOW_TABLE)
-+static int ppp_flow_offload_check(struct flow_offload_hw_path *path)
-+{
-+	struct ppp *ppp = netdev_priv(path->dev);
-+	struct ppp_channel *chan;
-+	struct channel *pch;
-+
-+	if (ppp->flags & SC_MULTILINK)
-+		return -EOPNOTSUPP;
-+
-+	if (list_empty(&ppp->channels))
-+		return -ENODEV;
-+
-+	pch = list_first_entry(&ppp->channels, struct channel, clist);
-+	chan = pch->chan;
-+	if (!chan->ops->flow_offload_check)
-+		return -EOPNOTSUPP;
-+
-+	return chan->ops->flow_offload_check(chan, path);
-+}
-+#endif /* CONFIG_NF_FLOW_TABLE */
-+
- static const struct net_device_ops ppp_netdev_ops = {
- 	.ndo_init	 = ppp_dev_init,
- 	.ndo_uninit      = ppp_dev_uninit,
- 	.ndo_start_xmit  = ppp_start_xmit,
- 	.ndo_do_ioctl    = ppp_net_ioctl,
- 	.ndo_get_stats64 = ppp_get_stats64,
-+#if IS_ENABLED(CONFIG_NF_FLOW_TABLE)
-+	.ndo_flow_offload_check = ppp_flow_offload_check,
-+#endif
- };
- 
- static struct device_type ppp_type = {
---- a/drivers/net/ppp/pppoe.c
-+++ b/drivers/net/ppp/pppoe.c
-@@ -78,6 +78,11 @@
- #include <linux/proc_fs.h>
- #include <linux/seq_file.h>
- 
-+#if IS_ENABLED(CONFIG_NF_FLOW_TABLE)
-+#include <linux/netfilter.h>
-+#include <net/netfilter/nf_flow_table.h>
-+#endif
-+
- #include <linux/nsproxy.h>
- #include <net/net_namespace.h>
- #include <net/netns/generic.h>
-@@ -976,8 +981,36 @@ static int pppoe_xmit(struct ppp_channel
- 	return __pppoe_xmit(sk, skb);
- }
- 
-+#if IS_ENABLED(CONFIG_NF_FLOW_TABLE)
-+static int pppoe_flow_offload_check(struct ppp_channel *chan,
-+				    struct flow_offload_hw_path *path)
-+{
-+	struct sock *sk = (struct sock *)chan->private;
-+	struct pppox_sock *po = pppox_sk(sk);
-+	struct net_device *dev = po->pppoe_dev;
-+
-+	if (sock_flag(sk, SOCK_DEAD) ||
-+	    !(sk->sk_state & PPPOX_CONNECTED) || !dev)
-+		return -ENODEV;
-+
-+	path->dev = po->pppoe_dev;
-+	path->flags |= FLOW_OFFLOAD_PATH_PPPOE;
-+	memcpy(path->eth_src, po->pppoe_dev->dev_addr, ETH_ALEN);
-+	memcpy(path->eth_dest, po->pppoe_pa.remote, ETH_ALEN);
-+	path->pppoe_sid = be16_to_cpu(po->num);
-+
-+	if (path->dev->netdev_ops->ndo_flow_offload_check)
-+		return path->dev->netdev_ops->ndo_flow_offload_check(path);
-+
-+	return 0;
-+}
-+#endif /* CONFIG_NF_FLOW_TABLE */
-+
- static const struct ppp_channel_ops pppoe_chan_ops = {
- 	.start_xmit = pppoe_xmit,
-+#if IS_ENABLED(CONFIG_NF_FLOW_TABLE)
-+	.flow_offload_check = pppoe_flow_offload_check,
-+#endif
- };
- 
- static int pppoe_recvmsg(struct socket *sock, struct msghdr *m,
---- a/include/linux/ppp_channel.h
-+++ b/include/linux/ppp_channel.h
-@@ -32,6 +32,10 @@ struct ppp_channel_ops {
- 	int	(*start_xmit)(struct ppp_channel *, struct sk_buff *);
- 	/* Handle an ioctl call that has come in via /dev/ppp. */
- 	int	(*ioctl)(struct ppp_channel *, unsigned int, unsigned long);
-+
-+#if IS_ENABLED(CONFIG_NF_FLOW_TABLE)
-+	int	(*flow_offload_check)(struct ppp_channel *, struct flow_offload_hw_path *);
-+#endif
- };
- 
- struct ppp_channel {
--- a/target/linux/generic/pending-4.19/645-netfilter-nf_flow_table-rework-hardware-offload-time.patch	2022-03-22 08:54:47.413465013 +0800
+++ b/target/linux/generic/pending-4.19/645-netfilter-nf_flow_table-rework-hardware-offload-time.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,37 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sun, 25 Mar 2018 21:10:55 +0200
-Subject: [PATCH] netfilter: nf_flow_table: rework hardware offload timeout
- handling
-
-Some offload implementations send keepalive packets + explicit
-notifications of TCP FIN/RST packets. In this case it is more convenient
-to simply let the driver update flow->timeout handling and use the
-regular flow offload gc step.
-
-For drivers that manage their own lifetime, a separate flag can be set
-to avoid gc timeouts.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/include/net/netfilter/nf_flow_table.h
-+++ b/include/net/netfilter/nf_flow_table.h
-@@ -76,6 +76,7 @@ struct flow_offload_tuple_rhash {
- #define FLOW_OFFLOAD_DYING	0x4
- #define FLOW_OFFLOAD_TEARDOWN	0x8
- #define FLOW_OFFLOAD_HW		0x10
-+#define FLOW_OFFLOAD_KEEP	0x20
- 
- struct flow_offload {
- 	struct flow_offload_tuple_rhash		tuplehash[FLOW_OFFLOAD_DIR_MAX];
---- a/net/netfilter/nf_flow_table_core.c
-+++ b/net/netfilter/nf_flow_table_core.c
-@@ -368,7 +368,7 @@ static int nf_flow_offload_gc_step(struc
- 		if (!teardown)
- 			nf_ct_offload_timeout(flow);
- 
--		if (nf_flow_in_hw(flow) && !teardown)
-+		if ((flow->flags & FLOW_OFFLOAD_KEEP) && !teardown)
- 			continue;
- 
- 		if (nf_flow_has_expired(flow) || teardown)
--- a/target/linux/generic/pending-4.19/646-netfilter-nf_flow_table-rework-private-driver-data.patch	2022-03-22 08:54:47.414465014 +0800
+++ b/target/linux/generic/pending-4.19/646-netfilter-nf_flow_table-rework-private-driver-data.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,25 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 27 Apr 2018 14:42:14 +0200
-Subject: [PATCH] netfilter: nf_flow_table: rework private driver data
-
-Move the timeout out of the union, since it can be shared between the
-driver and the stack. Add a private pointer that the driver can use to
-point to its own data structures
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/include/net/netfilter/nf_flow_table.h
-+++ b/include/net/netfilter/nf_flow_table.h
-@@ -81,9 +81,10 @@ struct flow_offload_tuple_rhash {
- struct flow_offload {
- 	struct flow_offload_tuple_rhash		tuplehash[FLOW_OFFLOAD_DIR_MAX];
- 	u32					flags;
-+	u32					timeout;
- 	union {
- 		/* Your private driver data here. */
--		u32		timeout;
-+		void *priv;
- 	};
- };
- 
--- a/target/linux/generic/pending-4.19/655-increase_skb_pad.patch	2022-03-22 08:54:47.414465014 +0800
+++ b/target/linux/generic/pending-4.19/655-increase_skb_pad.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,20 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: kernel: add a few patches for avoiding unnecessary skb reallocations - significantly improves ethernet<->wireless performance
-
-lede-commit: 6f89cffc9add6939d44a6b54cf9a5e77849aa7fd
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/linux/skbuff.h | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/include/linux/skbuff.h
-+++ b/include/linux/skbuff.h
-@@ -2509,7 +2509,7 @@ static inline int pskb_network_may_pull(
-  * NET_IP_ALIGN(2) + ethernet_header(14) + IP_header(20/40) + ports(8)
-  */
- #ifndef NET_SKB_PAD
--#define NET_SKB_PAD	max(32, L1_CACHE_BYTES)
-+#define NET_SKB_PAD	max(64, L1_CACHE_BYTES)
- #endif
- 
- int ___pskb_trim(struct sk_buff *skb, unsigned int len);
--- a/target/linux/generic/pending-4.19/666-Add-support-for-MAP-E-FMRs-mesh-mode.patch	2022-03-22 08:54:47.414465014 +0800
+++ b/target/linux/generic/pending-4.19/666-Add-support-for-MAP-E-FMRs-mesh-mode.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,500 +0,0 @@
-From: Steven Barth <steven@midlink.org>
-Subject: Add support for MAP-E FMRs (mesh mode)
-
-MAP-E FMRs (draft-ietf-softwire-map-10) are rules for IPv4-communication
-between MAP CEs (mesh mode) without the need to forward such data to a
-border relay. This is similar to how 6rd works but for IPv4 over IPv6.
-
-Signed-off-by: Steven Barth <cyrus@openwrt.org>
----
- include/net/ip6_tunnel.h       |  13 ++
- include/uapi/linux/if_tunnel.h |  13 ++
- net/ipv6/ip6_tunnel.c          | 276 +++++++++++++++++++++++++++++++++++++++--
- 3 files changed, 291 insertions(+), 11 deletions(-)
-
---- a/include/net/ip6_tunnel.h
-+++ b/include/net/ip6_tunnel.h
-@@ -18,6 +18,18 @@
- /* determine capability on a per-packet basis */
- #define IP6_TNL_F_CAP_PER_PACKET 0x40000
- 
-+/* IPv6 tunnel FMR */
-+struct __ip6_tnl_fmr {
-+	struct __ip6_tnl_fmr *next; /* next fmr in list */
-+	struct in6_addr ip6_prefix;
-+	struct in_addr ip4_prefix;
-+
-+	__u8 ip6_prefix_len;
-+	__u8 ip4_prefix_len;
-+	__u8 ea_len;
-+	__u8 offset;
-+};
-+
- struct __ip6_tnl_parm {
- 	char name[IFNAMSIZ];	/* name of tunnel device */
- 	int link;		/* ifindex of underlying L2 interface */
-@@ -29,6 +41,7 @@ struct __ip6_tnl_parm {
- 	__u32 flags;		/* tunnel flags */
- 	struct in6_addr laddr;	/* local tunnel end-point address */
- 	struct in6_addr raddr;	/* remote tunnel end-point address */
-+	struct __ip6_tnl_fmr *fmrs;	/* FMRs */
- 
- 	__be16			i_flags;
- 	__be16			o_flags;
---- a/include/uapi/linux/if_tunnel.h
-+++ b/include/uapi/linux/if_tunnel.h
-@@ -77,10 +77,23 @@ enum {
- 	IFLA_IPTUN_ENCAP_DPORT,
- 	IFLA_IPTUN_COLLECT_METADATA,
- 	IFLA_IPTUN_FWMARK,
-+	IFLA_IPTUN_FMRS,
- 	__IFLA_IPTUN_MAX,
- };
- #define IFLA_IPTUN_MAX	(__IFLA_IPTUN_MAX - 1)
- 
-+enum {
-+	IFLA_IPTUN_FMR_UNSPEC,
-+	IFLA_IPTUN_FMR_IP6_PREFIX,
-+	IFLA_IPTUN_FMR_IP4_PREFIX,
-+	IFLA_IPTUN_FMR_IP6_PREFIX_LEN,
-+	IFLA_IPTUN_FMR_IP4_PREFIX_LEN,
-+	IFLA_IPTUN_FMR_EA_LEN,
-+	IFLA_IPTUN_FMR_OFFSET,
-+	__IFLA_IPTUN_FMR_MAX,
-+};
-+#define IFLA_IPTUN_FMR_MAX (__IFLA_IPTUN_FMR_MAX - 1)
-+
- enum tunnel_encap_types {
- 	TUNNEL_ENCAP_NONE,
- 	TUNNEL_ENCAP_FOU,
---- a/net/ipv6/ip6_tunnel.c
-+++ b/net/ipv6/ip6_tunnel.c
-@@ -16,6 +16,8 @@
-  *      as published by the Free Software Foundation; either version
-  *      2 of the License, or (at your option) any later version.
-  *
-+ *	Changes:
-+ * Steven Barth <cyrus@openwrt.org>:		MAP-E FMR support
-  */
- 
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-@@ -72,9 +74,9 @@ static bool log_ecn_error = true;
- module_param(log_ecn_error, bool, 0644);
- MODULE_PARM_DESC(log_ecn_error, "Log packets received with corrupted ECN");
- 
--static u32 HASH(const struct in6_addr *addr1, const struct in6_addr *addr2)
-+static u32 HASH(const struct in6_addr *addr)
- {
--	u32 hash = ipv6_addr_hash(addr1) ^ ipv6_addr_hash(addr2);
-+	u32 hash = ipv6_addr_hash(addr);
- 
- 	return hash_32(hash, IP6_TUNNEL_HASH_SIZE_SHIFT);
- }
-@@ -141,20 +143,29 @@ static struct net_device_stats *ip6_get_
- static struct ip6_tnl *
- ip6_tnl_lookup(struct net *net, const struct in6_addr *remote, const struct in6_addr *local)
- {
--	unsigned int hash = HASH(remote, local);
-+	unsigned int hash = HASH(local);
- 	struct ip6_tnl *t;
- 	struct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);
- 	struct in6_addr any;
-+	struct __ip6_tnl_fmr *fmr;
- 
- 	for_each_ip6_tunnel_rcu(ip6n->tnls_r_l[hash]) {
--		if (ipv6_addr_equal(local, &t->parms.laddr) &&
--		    ipv6_addr_equal(remote, &t->parms.raddr) &&
--		    (t->dev->flags & IFF_UP))
-+		if (!ipv6_addr_equal(local, &t->parms.laddr) ||
-+				!(t->dev->flags & IFF_UP))
-+			continue;
-+
-+		if (ipv6_addr_equal(remote, &t->parms.raddr))
- 			return t;
-+
-+		for (fmr = t->parms.fmrs; fmr; fmr = fmr->next) {
-+			if (ipv6_prefix_equal(remote, &fmr->ip6_prefix,
-+					fmr->ip6_prefix_len))
-+				return t;
-+		}
- 	}
- 
- 	memset(&any, 0, sizeof(any));
--	hash = HASH(&any, local);
-+	hash = HASH(local);
- 	for_each_ip6_tunnel_rcu(ip6n->tnls_r_l[hash]) {
- 		if (ipv6_addr_equal(local, &t->parms.laddr) &&
- 		    ipv6_addr_any(&t->parms.raddr) &&
-@@ -162,7 +173,7 @@ ip6_tnl_lookup(struct net *net, const st
- 			return t;
- 	}
- 
--	hash = HASH(remote, &any);
-+	hash = HASH(&any);
- 	for_each_ip6_tunnel_rcu(ip6n->tnls_r_l[hash]) {
- 		if (ipv6_addr_equal(remote, &t->parms.raddr) &&
- 		    ipv6_addr_any(&t->parms.laddr) &&
-@@ -202,7 +213,7 @@ ip6_tnl_bucket(struct ip6_tnl_net *ip6n,
- 
- 	if (!ipv6_addr_any(remote) || !ipv6_addr_any(local)) {
- 		prio = 1;
--		h = HASH(remote, local);
-+		h = HASH(local);
- 	}
- 	return &ip6n->tnls[prio][h];
- }
-@@ -383,6 +394,12 @@ ip6_tnl_dev_uninit(struct net_device *de
- 	struct net *net = t->net;
- 	struct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);
- 
-+	while (t->parms.fmrs) {
-+		struct __ip6_tnl_fmr *next = t->parms.fmrs->next;
-+		kfree(t->parms.fmrs);
-+		t->parms.fmrs = next;
-+	}
-+
- 	if (dev == ip6n->fb_tnl_dev)
- 		RCU_INIT_POINTER(ip6n->tnls_wc[0], NULL);
- 	else
-@@ -772,6 +789,107 @@ int ip6_tnl_rcv_ctl(struct ip6_tnl *t,
- }
- EXPORT_SYMBOL_GPL(ip6_tnl_rcv_ctl);
- 
-+/**
-+ * ip4ip6_fmr_calc - calculate target / source IPv6-address based on FMR
-+ *   @dest: destination IPv6 address buffer
-+ *   @skb: received socket buffer
-+ *   @fmr: MAP FMR
-+ *   @xmit: Calculate for xmit or rcv
-+ **/
-+static void ip4ip6_fmr_calc(struct in6_addr *dest,
-+		const struct iphdr *iph, const uint8_t *end,
-+		const struct __ip6_tnl_fmr *fmr, bool xmit)
-+{
-+	int psidlen = fmr->ea_len - (32 - fmr->ip4_prefix_len);
-+	u8 *portp = NULL;
-+	bool use_dest_addr;
-+	const struct iphdr *dsth = iph;
-+
-+	if ((u8*)dsth >= end)
-+		return;
-+
-+	/* find significant IP header */
-+	if (iph->protocol == IPPROTO_ICMP) {
-+		struct icmphdr *ih = (struct icmphdr*)(((u8*)dsth) + dsth->ihl * 4);
-+		if (ih && ((u8*)&ih[1]) <= end && (
-+			ih->type == ICMP_DEST_UNREACH ||
-+			ih->type == ICMP_SOURCE_QUENCH ||
-+			ih->type == ICMP_TIME_EXCEEDED ||
-+			ih->type == ICMP_PARAMETERPROB ||
-+			ih->type == ICMP_REDIRECT))
-+				dsth = (const struct iphdr*)&ih[1];
-+	}
-+
-+	/* in xmit-path use dest port by default and source port only if
-+		this is an ICMP reply to something else; vice versa in rcv-path */
-+	use_dest_addr = (xmit && dsth == iph) || (!xmit && dsth != iph);
-+
-+	/* get dst port */
-+	if (((u8*)&dsth[1]) <= end && (
-+		dsth->protocol == IPPROTO_UDP ||
-+		dsth->protocol == IPPROTO_TCP ||
-+		dsth->protocol == IPPROTO_SCTP ||
-+		dsth->protocol == IPPROTO_DCCP)) {
-+			/* for UDP, TCP, SCTP and DCCP source and dest port
-+			follow IPv4 header directly */
-+			portp = ((u8*)dsth) + dsth->ihl * 4;
-+
-+			if (use_dest_addr)
-+				portp += sizeof(u16);
-+	} else if (iph->protocol == IPPROTO_ICMP) {
-+		struct icmphdr *ih = (struct icmphdr*)(((u8*)dsth) + dsth->ihl * 4);
-+
-+		/* use icmp identifier as port */
-+		if (((u8*)&ih) <= end && (
-+		    (use_dest_addr && (
-+		    ih->type == ICMP_ECHOREPLY ||
-+			ih->type == ICMP_TIMESTAMPREPLY ||
-+			ih->type == ICMP_INFO_REPLY ||
-+			ih->type == ICMP_ADDRESSREPLY)) ||
-+			(!use_dest_addr && (
-+			ih->type == ICMP_ECHO ||
-+			ih->type == ICMP_TIMESTAMP ||
-+			ih->type == ICMP_INFO_REQUEST ||
-+			ih->type == ICMP_ADDRESS)
-+			)))
-+				portp = (u8*)&ih->un.echo.id;
-+	}
-+
-+	if ((portp && &portp[2] <= end) || psidlen == 0) {
-+		int frombyte = fmr->ip6_prefix_len / 8;
-+		int fromrem = fmr->ip6_prefix_len % 8;
-+		int bytes = sizeof(struct in6_addr) - frombyte;
-+		const u32 *addr = (use_dest_addr) ? &iph->daddr : &iph->saddr;
-+		u64 eabits = ((u64)ntohl(*addr)) << (32 + fmr->ip4_prefix_len);
-+		u64 t = 0;
-+
-+		/* extract PSID from port and add it to eabits */
-+		u16 psidbits = 0;
-+		if (psidlen > 0) {
-+			psidbits = ((u16)portp[0]) << 8 | ((u16)portp[1]);
-+			psidbits >>= 16 - psidlen - fmr->offset;
-+			psidbits = (u16)(psidbits << (16 - psidlen));
-+			eabits |= ((u64)psidbits) << (48 - (fmr->ea_len - psidlen));
-+		}
-+
-+		/* rewrite destination address */
-+		*dest = fmr->ip6_prefix;
-+		memcpy(&dest->s6_addr[10], addr, sizeof(*addr));
-+		dest->s6_addr16[7] = htons(psidbits >> (16 - psidlen));
-+
-+		if (bytes > sizeof(u64))
-+			bytes = sizeof(u64);
-+
-+		/* insert eabits */
-+		memcpy(&t, &dest->s6_addr[frombyte], bytes);
-+		t = be64_to_cpu(t) & ~(((((u64)1) << fmr->ea_len) - 1)
-+			<< (64 - fmr->ea_len - fromrem));
-+		t = cpu_to_be64(t | (eabits >> fromrem));
-+		memcpy(&dest->s6_addr[frombyte], &t, bytes);
-+	}
-+}
-+
-+
- static int __ip6_tnl_rcv(struct ip6_tnl *tunnel, struct sk_buff *skb,
- 			 const struct tnl_ptk_info *tpi,
- 			 struct metadata_dst *tun_dst,
-@@ -824,6 +942,27 @@ static int __ip6_tnl_rcv(struct ip6_tnl
- 	skb_reset_network_header(skb);
- 	memset(skb->cb, 0, sizeof(struct inet6_skb_parm));
- 
-+	if (tpi->proto == htons(ETH_P_IP) && tunnel->parms.fmrs &&
-+		!ipv6_addr_equal(&ipv6h->saddr, &tunnel->parms.raddr)) {
-+			/* Packet didn't come from BR, so lookup FMR */
-+			struct __ip6_tnl_fmr *fmr;
-+			struct in6_addr expected = tunnel->parms.raddr;
-+			for (fmr = tunnel->parms.fmrs; fmr; fmr = fmr->next)
-+				if (ipv6_prefix_equal(&ipv6h->saddr,
-+					&fmr->ip6_prefix, fmr->ip6_prefix_len))
-+						break;
-+
-+			/* Check that IPv6 matches IPv4 source to prevent spoofing */
-+			if (fmr)
-+				ip4ip6_fmr_calc(&expected, ip_hdr(skb),
-+						skb_tail_pointer(skb), fmr, false);
-+
-+			if (!ipv6_addr_equal(&ipv6h->saddr, &expected)) {
-+				rcu_read_unlock();
-+				goto drop;
-+			}
-+	}
-+
- 	__skb_tunnel_rx(skb, tunnel->dev, tunnel->net);
- 
- 	err = dscp_ecn_decapsulate(tunnel, ipv6h, skb);
-@@ -956,6 +1095,7 @@ static void init_tel_txopt(struct ipv6_t
- 	opt->ops.opt_nflen = 8;
- }
- 
-+
- /**
-  * ip6_tnl_addr_conflict - compare packet addresses to tunnel's own
-  *   @t: the outgoing tunnel device
-@@ -1308,6 +1448,7 @@ ip6ip6_tnl_xmit(struct sk_buff *skb, str
- {
- 	struct ip6_tnl *t = netdev_priv(dev);
- 	struct ipv6hdr *ipv6h;
-+	struct __ip6_tnl_fmr *fmr;
- 	int encap_limit = -1;
- 	__u16 offset;
- 	struct flowi6 fl6;
-@@ -1373,6 +1514,18 @@ ip6ip6_tnl_xmit(struct sk_buff *skb, str
- 	fl6.flowi6_uid = sock_net_uid(dev_net(dev), NULL);
- 	dsfield = INET_ECN_encapsulate(dsfield, ipv6_get_dsfield(ipv6h));
- 
-+	/* try to find matching FMR */
-+	for (fmr = t->parms.fmrs; fmr; fmr = fmr->next) {
-+		unsigned mshift = 32 - fmr->ip4_prefix_len;
-+		if (ntohl(fmr->ip4_prefix.s_addr) >> mshift ==
-+				ntohl(ip_hdr(skb)->daddr) >> mshift)
-+			break;
-+	}
-+
-+	/* change dstaddr according to FMR */
-+	if (fmr)
-+		ip4ip6_fmr_calc(&fl6.daddr, ip_hdr(skb), skb_tail_pointer(skb), fmr, true);
-+
- 	if (iptunnel_handle_offloads(skb, SKB_GSO_IPXIP6))
- 		return -1;
- 
-@@ -1502,6 +1655,14 @@ ip6_tnl_change(struct ip6_tnl *t, const
- 	t->parms.link = p->link;
- 	t->parms.proto = p->proto;
- 	t->parms.fwmark = p->fwmark;
-+
-+	while (t->parms.fmrs) {
-+		struct __ip6_tnl_fmr *next = t->parms.fmrs->next;
-+		kfree(t->parms.fmrs);
-+		t->parms.fmrs = next;
-+	}
-+	t->parms.fmrs = p->fmrs;
-+
- 	dst_cache_reset(&t->dst_cache);
- 	ip6_tnl_link_config(t);
- 	return 0;
-@@ -1540,6 +1701,7 @@ ip6_tnl_parm_from_user(struct __ip6_tnl_
- 	p->flowinfo = u->flowinfo;
- 	p->link = u->link;
- 	p->proto = u->proto;
-+	p->fmrs = NULL;
- 	memcpy(p->name, u->name, sizeof(u->name));
- }
- 
-@@ -1926,6 +2088,15 @@ static int ip6_tnl_validate(struct nlatt
- 	return 0;
- }
- 
-+static const struct nla_policy ip6_tnl_fmr_policy[IFLA_IPTUN_FMR_MAX + 1] = {
-+	[IFLA_IPTUN_FMR_IP6_PREFIX] = { .len = sizeof(struct in6_addr) },
-+	[IFLA_IPTUN_FMR_IP4_PREFIX] = { .len = sizeof(struct in_addr) },
-+	[IFLA_IPTUN_FMR_IP6_PREFIX_LEN] = { .type = NLA_U8 },
-+	[IFLA_IPTUN_FMR_IP4_PREFIX_LEN] = { .type = NLA_U8 },
-+	[IFLA_IPTUN_FMR_EA_LEN] = { .type = NLA_U8 },
-+	[IFLA_IPTUN_FMR_OFFSET] = { .type = NLA_U8 }
-+};
-+
- static void ip6_tnl_netlink_parms(struct nlattr *data[],
- 				  struct __ip6_tnl_parm *parms)
- {
-@@ -1963,6 +2134,46 @@ static void ip6_tnl_netlink_parms(struct
- 
- 	if (data[IFLA_IPTUN_FWMARK])
- 		parms->fwmark = nla_get_u32(data[IFLA_IPTUN_FWMARK]);
-+
-+	if (data[IFLA_IPTUN_FMRS]) {
-+		unsigned rem;
-+		struct nlattr *fmr;
-+		nla_for_each_nested(fmr, data[IFLA_IPTUN_FMRS], rem) {
-+			struct nlattr *fmrd[IFLA_IPTUN_FMR_MAX + 1], *c;
-+			struct __ip6_tnl_fmr *nfmr;
-+
-+			nla_parse_nested(fmrd, IFLA_IPTUN_FMR_MAX,
-+				fmr, ip6_tnl_fmr_policy, NULL);
-+
-+			if (!(nfmr = kzalloc(sizeof(*nfmr), GFP_KERNEL)))
-+				continue;
-+
-+			nfmr->offset = 6;
-+
-+			if ((c = fmrd[IFLA_IPTUN_FMR_IP6_PREFIX]))
-+				nla_memcpy(&nfmr->ip6_prefix, fmrd[IFLA_IPTUN_FMR_IP6_PREFIX],
-+					sizeof(nfmr->ip6_prefix));
-+
-+			if ((c = fmrd[IFLA_IPTUN_FMR_IP4_PREFIX]))
-+				nla_memcpy(&nfmr->ip4_prefix, fmrd[IFLA_IPTUN_FMR_IP4_PREFIX],
-+					sizeof(nfmr->ip4_prefix));
-+
-+			if ((c = fmrd[IFLA_IPTUN_FMR_IP6_PREFIX_LEN]))
-+				nfmr->ip6_prefix_len = nla_get_u8(c);
-+
-+			if ((c = fmrd[IFLA_IPTUN_FMR_IP4_PREFIX_LEN]))
-+				nfmr->ip4_prefix_len = nla_get_u8(c);
-+
-+			if ((c = fmrd[IFLA_IPTUN_FMR_EA_LEN]))
-+				nfmr->ea_len = nla_get_u8(c);
-+
-+			if ((c = fmrd[IFLA_IPTUN_FMR_OFFSET]))
-+				nfmr->offset = nla_get_u8(c);
-+
-+			nfmr->next = parms->fmrs;
-+			parms->fmrs = nfmr;
-+		}
-+	}
- }
- 
- static bool ip6_tnl_netlink_encap_parms(struct nlattr *data[],
-@@ -2078,6 +2289,12 @@ static void ip6_tnl_dellink(struct net_d
- 
- static size_t ip6_tnl_get_size(const struct net_device *dev)
- {
-+	const struct ip6_tnl *t = netdev_priv(dev);
-+	struct __ip6_tnl_fmr *c;
-+	int fmrs = 0;
-+	for (c = t->parms.fmrs; c; c = c->next)
-+		++fmrs;
-+
- 	return
- 		/* IFLA_IPTUN_LINK */
- 		nla_total_size(4) +
-@@ -2107,6 +2324,24 @@ static size_t ip6_tnl_get_size(const str
- 		nla_total_size(0) +
- 		/* IFLA_IPTUN_FWMARK */
- 		nla_total_size(4) +
-+		/* IFLA_IPTUN_FMRS */
-+		nla_total_size(0) +
-+		(
-+			/* nest */
-+			nla_total_size(0) +
-+			/* IFLA_IPTUN_FMR_IP6_PREFIX */
-+			nla_total_size(sizeof(struct in6_addr)) +
-+			/* IFLA_IPTUN_FMR_IP4_PREFIX */
-+			nla_total_size(sizeof(struct in_addr)) +
-+			/* IFLA_IPTUN_FMR_EA_LEN */
-+			nla_total_size(1) +
-+			/* IFLA_IPTUN_FMR_IP6_PREFIX_LEN */
-+			nla_total_size(1) +
-+			/* IFLA_IPTUN_FMR_IP4_PREFIX_LEN */
-+			nla_total_size(1) +
-+			/* IFLA_IPTUN_FMR_OFFSET */
-+			nla_total_size(1)
-+		) * fmrs +
- 		0;
- }
- 
-@@ -2114,6 +2349,9 @@ static int ip6_tnl_fill_info(struct sk_b
- {
- 	struct ip6_tnl *tunnel = netdev_priv(dev);
- 	struct __ip6_tnl_parm *parm = &tunnel->parms;
-+	struct __ip6_tnl_fmr *c;
-+	int fmrcnt = 0;
-+	struct nlattr *fmrs;
- 
- 	if (nla_put_u32(skb, IFLA_IPTUN_LINK, parm->link) ||
- 	    nla_put_in6_addr(skb, IFLA_IPTUN_LOCAL, &parm->laddr) ||
-@@ -2123,9 +2361,27 @@ static int ip6_tnl_fill_info(struct sk_b
- 	    nla_put_be32(skb, IFLA_IPTUN_FLOWINFO, parm->flowinfo) ||
- 	    nla_put_u32(skb, IFLA_IPTUN_FLAGS, parm->flags) ||
- 	    nla_put_u8(skb, IFLA_IPTUN_PROTO, parm->proto) ||
--	    nla_put_u32(skb, IFLA_IPTUN_FWMARK, parm->fwmark))
-+	    nla_put_u32(skb, IFLA_IPTUN_FWMARK, parm->fwmark) ||
-+	    !(fmrs = nla_nest_start(skb, IFLA_IPTUN_FMRS)))
- 		goto nla_put_failure;
- 
-+	for (c = parm->fmrs; c; c = c->next) {
-+		struct nlattr *fmr = nla_nest_start(skb, ++fmrcnt);
-+		if (!fmr ||
-+			nla_put(skb, IFLA_IPTUN_FMR_IP6_PREFIX,
-+				sizeof(c->ip6_prefix), &c->ip6_prefix) ||
-+			nla_put(skb, IFLA_IPTUN_FMR_IP4_PREFIX,
-+				sizeof(c->ip4_prefix), &c->ip4_prefix) ||
-+			nla_put_u8(skb, IFLA_IPTUN_FMR_IP6_PREFIX_LEN, c->ip6_prefix_len) ||
-+			nla_put_u8(skb, IFLA_IPTUN_FMR_IP4_PREFIX_LEN, c->ip4_prefix_len) ||
-+			nla_put_u8(skb, IFLA_IPTUN_FMR_EA_LEN, c->ea_len) ||
-+			nla_put_u8(skb, IFLA_IPTUN_FMR_OFFSET, c->offset))
-+				goto nla_put_failure;
-+
-+		nla_nest_end(skb, fmr);
-+	}
-+	nla_nest_end(skb, fmrs);
-+
- 	if (nla_put_u16(skb, IFLA_IPTUN_ENCAP_TYPE, tunnel->encap.type) ||
- 	    nla_put_be16(skb, IFLA_IPTUN_ENCAP_SPORT, tunnel->encap.sport) ||
- 	    nla_put_be16(skb, IFLA_IPTUN_ENCAP_DPORT, tunnel->encap.dport) ||
-@@ -2165,6 +2421,7 @@ static const struct nla_policy ip6_tnl_p
- 	[IFLA_IPTUN_ENCAP_DPORT]	= { .type = NLA_U16 },
- 	[IFLA_IPTUN_COLLECT_METADATA]	= { .type = NLA_FLAG },
- 	[IFLA_IPTUN_FWMARK]		= { .type = NLA_U32 },
-+	[IFLA_IPTUN_FMRS]		= { .type = NLA_NESTED },
- };
- 
- static struct rtnl_link_ops ip6_link_ops __read_mostly = {
--- a/target/linux/generic/pending-4.19/670-ipv6-allow-rejecting-with-source-address-failed-policy.patch	2022-03-22 08:54:47.415465016 +0800
+++ b/target/linux/generic/pending-4.19/670-ipv6-allow-rejecting-with-source-address-failed-policy.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,247 +0,0 @@
-From: Jonas Gorski <jogo@openwrt.org>
-Subject: ipv6: allow rejecting with "source address failed policy"
-
-RFC6204 L-14 requires rejecting traffic from invalid addresses with
-ICMPv6 Destination Unreachable, Code 5 (Source address failed ingress/
-egress policy) on the LAN side, so add an appropriate rule for that.
-
-Signed-off-by: Jonas Gorski <jogo@openwrt.org>
----
- include/net/netns/ipv6.h       |  1 +
- include/uapi/linux/fib_rules.h |  4 +++
- include/uapi/linux/rtnetlink.h |  1 +
- net/ipv4/fib_semantics.c       |  4 +++
- net/ipv4/fib_trie.c            |  1 +
- net/ipv4/ipmr.c                |  1 +
- net/ipv6/fib6_rules.c          |  4 +++
- net/ipv6/ip6mr.c               |  2 ++
- net/ipv6/route.c               | 58 +++++++++++++++++++++++++++++++++++++++++-
- 9 files changed, 75 insertions(+), 1 deletion(-)
-
---- a/include/net/netns/ipv6.h
-+++ b/include/net/netns/ipv6.h
-@@ -78,6 +78,7 @@ struct netns_ipv6 {
- 	unsigned int		fib6_rules_require_fldissect;
- 	bool			fib6_has_custom_rules;
- 	struct rt6_info         *ip6_prohibit_entry;
-+	struct rt6_info		*ip6_policy_failed_entry;
- 	struct rt6_info         *ip6_blk_hole_entry;
- 	struct fib6_table       *fib6_local_tbl;
- 	struct fib_rules_ops    *fib6_rules_ops;
---- a/include/uapi/linux/fib_rules.h
-+++ b/include/uapi/linux/fib_rules.h
-@@ -82,6 +82,10 @@ enum {
- 	FR_ACT_BLACKHOLE,	/* Drop without notification */
- 	FR_ACT_UNREACHABLE,	/* Drop with ENETUNREACH */
- 	FR_ACT_PROHIBIT,	/* Drop with EACCES */
-+	FR_ACT_RES9,
-+	FR_ACT_RES10,
-+	FR_ACT_RES11,
-+	FR_ACT_POLICY_FAILED,	/* Drop with EACCES */
- 	__FR_ACT_MAX,
- };
- 
---- a/include/uapi/linux/rtnetlink.h
-+++ b/include/uapi/linux/rtnetlink.h
-@@ -228,6 +228,7 @@ enum {
- 	RTN_THROW,		/* Not in this table		*/
- 	RTN_NAT,		/* Translate this address	*/
- 	RTN_XRESOLVE,		/* Use external resolver	*/
-+	RTN_POLICY_FAILED,	/* Failed ingress/egress policy */
- 	__RTN_MAX
- };
- 
---- a/net/ipv4/fib_semantics.c
-+++ b/net/ipv4/fib_semantics.c
-@@ -139,6 +139,10 @@ const struct fib_prop fib_props[RTN_MAX
- 		.error	= -EINVAL,
- 		.scope	= RT_SCOPE_NOWHERE,
- 	},
-+	[RTN_POLICY_FAILED] = {
-+		.error	= -EACCES,
-+		.scope	= RT_SCOPE_UNIVERSE,
-+	},
- };
- 
- static void rt_fibinfo_free(struct rtable __rcu **rtp)
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -2474,6 +2474,7 @@ static const char *const rtn_type_names[
- 	[RTN_THROW] = "THROW",
- 	[RTN_NAT] = "NAT",
- 	[RTN_XRESOLVE] = "XRESOLVE",
-+	[RTN_POLICY_FAILED] = "POLICY_FAILED",
- };
- 
- static inline const char *rtn_type(char *buf, size_t len, unsigned int t)
---- a/net/ipv4/ipmr.c
-+++ b/net/ipv4/ipmr.c
-@@ -179,6 +179,7 @@ static int ipmr_rule_action(struct fib_r
- 	case FR_ACT_UNREACHABLE:
- 		return -ENETUNREACH;
- 	case FR_ACT_PROHIBIT:
-+	case FR_ACT_POLICY_FAILED:
- 		return -EACCES;
- 	case FR_ACT_BLACKHOLE:
- 	default:
---- a/net/ipv6/fib6_rules.c
-+++ b/net/ipv6/fib6_rules.c
-@@ -221,6 +221,10 @@ static int __fib6_rule_action(struct fib
- 		err = -EACCES;
- 		rt = net->ipv6.ip6_prohibit_entry;
- 		goto discard_pkt;
-+	case FR_ACT_POLICY_FAILED:
-+		err = -EACCES;
-+		rt = net->ipv6.ip6_policy_failed_entry;
-+		goto discard_pkt;
- 	}
- 
- 	tb_id = fib_rule_get_table(rule, arg);
---- a/net/ipv6/ip6mr.c
-+++ b/net/ipv6/ip6mr.c
-@@ -162,6 +162,8 @@ static int ip6mr_rule_action(struct fib_
- 		return -ENETUNREACH;
- 	case FR_ACT_PROHIBIT:
- 		return -EACCES;
-+	case FR_ACT_POLICY_FAILED:
-+		return -EACCES;
- 	case FR_ACT_BLACKHOLE:
- 	default:
- 		return -EINVAL;
---- a/net/ipv6/route.c
-+++ b/net/ipv6/route.c
-@@ -97,6 +97,8 @@ static int		ip6_pkt_discard(struct sk_bu
- static int		ip6_pkt_discard_out(struct net *net, struct sock *sk, struct sk_buff *skb);
- static int		ip6_pkt_prohibit(struct sk_buff *skb);
- static int		ip6_pkt_prohibit_out(struct net *net, struct sock *sk, struct sk_buff *skb);
-+static int		ip6_pkt_policy_failed(struct sk_buff *skb);
-+static int		ip6_pkt_policy_failed_out(struct net *net, struct sock *sk, struct sk_buff *skb);
- static void		ip6_link_failure(struct sk_buff *skb);
- static void		ip6_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,
- 					   struct sk_buff *skb, u32 mtu);
-@@ -326,6 +328,18 @@ static const struct rt6_info ip6_prohibi
- 	.rt6i_flags	= (RTF_REJECT | RTF_NONEXTHOP),
- };
- 
-+static const struct rt6_info ip6_policy_failed_entry_template = {
-+	.dst = {
-+		.__refcnt	= ATOMIC_INIT(1),
-+		.__use		= 1,
-+		.obsolete	= DST_OBSOLETE_FORCE_CHK,
-+		.error		= -EACCES,
-+		.input		= ip6_pkt_policy_failed,
-+		.output		= ip6_pkt_policy_failed_out,
-+	},
-+	.rt6i_flags	= (RTF_REJECT | RTF_NONEXTHOP),
-+};
-+
- static const struct rt6_info ip6_blk_hole_entry_template = {
- 	.dst = {
- 		.__refcnt	= ATOMIC_INIT(1),
-@@ -904,6 +918,7 @@ static const int fib6_prop[RTN_MAX + 1]
- 	[RTN_BLACKHOLE]	= -EINVAL,
- 	[RTN_UNREACHABLE] = -EHOSTUNREACH,
- 	[RTN_PROHIBIT]	= -EACCES,
-+	[RTN_POLICY_FAILED] = -EACCES,
- 	[RTN_THROW]	= -EAGAIN,
- 	[RTN_NAT]	= -EINVAL,
- 	[RTN_XRESOLVE]	= -EINVAL,
-@@ -941,6 +956,10 @@ static void ip6_rt_init_dst_reject(struc
- 		rt->dst.output = ip6_pkt_prohibit_out;
- 		rt->dst.input = ip6_pkt_prohibit;
- 		break;
-+	case RTN_POLICY_FAILED:
-+		rt->dst.output = ip6_pkt_policy_failed_out;
-+		rt->dst.input = ip6_pkt_policy_failed;
-+		break;
- 	case RTN_THROW:
- 	case RTN_UNREACHABLE:
- 	default:
-@@ -3781,6 +3800,17 @@ static int ip6_pkt_prohibit_out(struct n
- 	return ip6_pkt_drop(skb, ICMPV6_ADM_PROHIBITED, IPSTATS_MIB_OUTNOROUTES);
- }
- 
-+static int ip6_pkt_policy_failed(struct sk_buff *skb)
-+{
-+	return ip6_pkt_drop(skb, ICMPV6_POLICY_FAIL, IPSTATS_MIB_INNOROUTES);
-+}
-+
-+static int ip6_pkt_policy_failed_out(struct net *net, struct sock *sk, struct sk_buff *skb)
-+{
-+	skb->dev = skb_dst(skb)->dev;
-+	return ip6_pkt_drop(skb, ICMPV6_POLICY_FAIL, IPSTATS_MIB_OUTNOROUTES);
-+}
-+
- /*
-  *	Allocate a dst for local (unicast / anycast) address.
-  */
-@@ -4228,7 +4258,8 @@ static int rtm_to_fib6_config(struct sk_
- 	if (rtm->rtm_type == RTN_UNREACHABLE ||
- 	    rtm->rtm_type == RTN_BLACKHOLE ||
- 	    rtm->rtm_type == RTN_PROHIBIT ||
--	    rtm->rtm_type == RTN_THROW)
-+	    rtm->rtm_type == RTN_THROW ||
-+	    rtm->rtm_type == RTN_POLICY_FAILED)
- 		cfg->fc_flags |= RTF_REJECT;
- 
- 	if (rtm->rtm_type == RTN_LOCAL)
-@@ -5076,6 +5107,8 @@ static int ip6_route_dev_notify(struct n
- #ifdef CONFIG_IPV6_MULTIPLE_TABLES
- 		net->ipv6.ip6_prohibit_entry->dst.dev = dev;
- 		net->ipv6.ip6_prohibit_entry->rt6i_idev = in6_dev_get(dev);
-+		net->ipv6.ip6_policy_failed_entry->dst.dev = dev;
-+		net->ipv6.ip6_policy_failed_entry->rt6i_idev = in6_dev_get(dev);
- 		net->ipv6.ip6_blk_hole_entry->dst.dev = dev;
- 		net->ipv6.ip6_blk_hole_entry->rt6i_idev = in6_dev_get(dev);
- #endif
-@@ -5087,6 +5120,7 @@ static int ip6_route_dev_notify(struct n
- 		in6_dev_put_clear(&net->ipv6.ip6_null_entry->rt6i_idev);
- #ifdef CONFIG_IPV6_MULTIPLE_TABLES
- 		in6_dev_put_clear(&net->ipv6.ip6_prohibit_entry->rt6i_idev);
-+		in6_dev_put_clear(&net->ipv6.ip6_policy_failed_entry->rt6i_idev);
- 		in6_dev_put_clear(&net->ipv6.ip6_blk_hole_entry->rt6i_idev);
- #endif
- 	}
-@@ -5281,6 +5315,15 @@ static int __net_init ip6_route_net_init
- 	net->ipv6.ip6_blk_hole_entry->dst.ops = &net->ipv6.ip6_dst_ops;
- 	dst_init_metrics(&net->ipv6.ip6_blk_hole_entry->dst,
- 			 ip6_template_metrics, true);
-+
-+	net->ipv6.ip6_policy_failed_entry =
-+		kmemdup(&ip6_policy_failed_entry_template,
-+			sizeof(*net->ipv6.ip6_policy_failed_entry), GFP_KERNEL);
-+	if (!net->ipv6.ip6_policy_failed_entry)
-+		goto out_ip6_blk_hole_entry;
-+	net->ipv6.ip6_policy_failed_entry->dst.ops = &net->ipv6.ip6_dst_ops;
-+	dst_init_metrics(&net->ipv6.ip6_policy_failed_entry->dst,
-+			 ip6_template_metrics, true);
- #endif
- 
- 	net->ipv6.sysctl.flush_delay = 0;
-@@ -5299,6 +5342,8 @@ out:
- 	return ret;
- 
- #ifdef CONFIG_IPV6_MULTIPLE_TABLES
-+out_ip6_blk_hole_entry:
-+	kfree(net->ipv6.ip6_blk_hole_entry);
- out_ip6_prohibit_entry:
- 	kfree(net->ipv6.ip6_prohibit_entry);
- out_ip6_null_entry:
-@@ -5319,6 +5364,7 @@ static void __net_exit ip6_route_net_exi
- #ifdef CONFIG_IPV6_MULTIPLE_TABLES
- 	kfree(net->ipv6.ip6_prohibit_entry);
- 	kfree(net->ipv6.ip6_blk_hole_entry);
-+	kfree(net->ipv6.ip6_policy_failed_entry);
- #endif
- 	dst_entries_destroy(&net->ipv6.ip6_dst_ops);
- }
-@@ -5395,6 +5441,9 @@ void __init ip6_route_init_special_entri
- 	init_net.ipv6.ip6_prohibit_entry->rt6i_idev = in6_dev_get(init_net.loopback_dev);
- 	init_net.ipv6.ip6_blk_hole_entry->dst.dev = init_net.loopback_dev;
- 	init_net.ipv6.ip6_blk_hole_entry->rt6i_idev = in6_dev_get(init_net.loopback_dev);
-+	init_net.ipv6.ip6_policy_failed_entry->dst.dev = init_net.loopback_dev;
-+	init_net.ipv6.ip6_policy_failed_entry->rt6i_idev =
-+		in6_dev_get(init_net.loopback_dev);
-   #endif
- }
- 
--- a/target/linux/generic/pending-4.19/671-net-provide-defines-for-_POLICY_FAILED-until-all-cod.patch	2022-03-22 08:54:47.415465016 +0800
+++ b/target/linux/generic/pending-4.19/671-net-provide-defines-for-_POLICY_FAILED-until-all-cod.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,50 +0,0 @@
-From: Jonas Gorski <jogo@openwrt.org>
-Subject: net: provide defines for _POLICY_FAILED until all code is updated
-
-Upstream introduced ICMPV6_POLICY_FAIL for code 5 of destination
-unreachable, conflicting with our name.
-
-Add appropriate defines to allow our code to build with the new
-name until we have updated our local patches for older kernels
-and userspace packages.
-
-Signed-off-by: Jonas Gorski <jogo@openwrt.org>
----
- include/uapi/linux/fib_rules.h | 2 ++
- include/uapi/linux/icmpv6.h    | 2 ++
- include/uapi/linux/rtnetlink.h | 2 ++
- 3 files changed, 6 insertions(+)
-
---- a/include/uapi/linux/fib_rules.h
-+++ b/include/uapi/linux/fib_rules.h
-@@ -89,6 +89,8 @@ enum {
- 	__FR_ACT_MAX,
- };
- 
-+#define FR_ACT_FAILED_POLICY FR_ACT_POLICY_FAILED
-+
- #define FR_ACT_MAX (__FR_ACT_MAX - 1)
- 
- #endif
---- a/include/uapi/linux/icmpv6.h
-+++ b/include/uapi/linux/icmpv6.h
-@@ -119,6 +119,8 @@ struct icmp6hdr {
- #define ICMPV6_POLICY_FAIL		5
- #define ICMPV6_REJECT_ROUTE		6
- 
-+#define ICMPV6_FAILED_POLICY		ICMPV6_POLICY_FAIL
-+
- /*
-  *	Codes for Time Exceeded
-  */
---- a/include/uapi/linux/rtnetlink.h
-+++ b/include/uapi/linux/rtnetlink.h
-@@ -232,6 +232,8 @@ enum {
- 	__RTN_MAX
- };
- 
-+#define RTN_FAILED_POLICY RTN_POLICY_FAILED
-+
- #define RTN_MAX (__RTN_MAX - 1)
- 
- 
--- a/target/linux/generic/pending-4.19/680-NET-skip-GRO-for-foreign-MAC-addresses.patch	2022-03-22 08:54:47.416465018 +0800
+++ b/target/linux/generic/pending-4.19/680-NET-skip-GRO-for-foreign-MAC-addresses.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,152 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: net: replace GRO optimization patch with a new one that supports VLANs/bridges with different MAC addresses
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/linux/netdevice.h |  2 ++
- include/linux/skbuff.h    |  3 ++-
- net/core/dev.c            | 48 +++++++++++++++++++++++++++++++++++++++++++++++
- net/ethernet/eth.c        | 18 +++++++++++++++++-
- 4 files changed, 69 insertions(+), 2 deletions(-)
-
---- a/include/linux/netdevice.h
-+++ b/include/linux/netdevice.h
-@@ -1882,6 +1882,8 @@ struct net_device {
- 	struct netdev_hw_addr_list	mc;
- 	struct netdev_hw_addr_list	dev_addrs;
- 
-+	unsigned char		local_addr_mask[MAX_ADDR_LEN];
-+
- #ifdef CONFIG_SYSFS
- 	struct kset		*queues_kset;
- #endif
---- a/include/linux/skbuff.h
-+++ b/include/linux/skbuff.h
-@@ -799,6 +799,7 @@ struct sk_buff {
- #ifdef CONFIG_TLS_DEVICE
- 	__u8			decrypted:1;
- #endif
-+	__u8			gro_skip:1;
- 
- #ifdef CONFIG_NET_SCHED
- 	__u16			tc_index;	/* traffic control index */
---- a/net/core/dev.c
-+++ b/net/core/dev.c
-@@ -5482,6 +5482,9 @@ static enum gro_result dev_gro_receive(s
- 	int same_flow;
- 	int grow;
- 
-+	if (skb->gro_skip)
-+		goto normal;
-+
- 	if (netif_elide_gro(skb->dev))
- 		goto normal;
- 
-@@ -6976,6 +6979,48 @@ static void __netdev_adjacent_dev_unlink
- 					   &upper_dev->adj_list.lower);
- }
- 
-+static void __netdev_addr_mask(unsigned char *mask, const unsigned char *addr,
-+			       struct net_device *dev)
-+{
-+	int i;
-+
-+	for (i = 0; i < dev->addr_len; i++)
-+		mask[i] |= addr[i] ^ dev->dev_addr[i];
-+}
-+
-+static void __netdev_upper_mask(unsigned char *mask, struct net_device *dev,
-+				struct net_device *lower)
-+{
-+	struct net_device *cur;
-+	struct list_head *iter;
-+
-+	netdev_for_each_upper_dev_rcu(dev, cur, iter) {
-+		__netdev_addr_mask(mask, cur->dev_addr, lower);
-+		__netdev_upper_mask(mask, cur, lower);
-+	}
-+}
-+
-+static void __netdev_update_addr_mask(struct net_device *dev)
-+{
-+	unsigned char mask[MAX_ADDR_LEN];
-+	struct net_device *cur;
-+	struct list_head *iter;
-+
-+	memset(mask, 0, sizeof(mask));
-+	__netdev_upper_mask(mask, dev, dev);
-+	memcpy(dev->local_addr_mask, mask, dev->addr_len);
-+
-+	netdev_for_each_lower_dev(dev, cur, iter)
-+		__netdev_update_addr_mask(cur);
-+}
-+
-+static void netdev_update_addr_mask(struct net_device *dev)
-+{
-+	rcu_read_lock();
-+	__netdev_update_addr_mask(dev);
-+	rcu_read_unlock();
-+}
-+
- static int __netdev_upper_dev_link(struct net_device *dev,
- 				   struct net_device *upper_dev, bool master,
- 				   void *upper_priv, void *upper_info,
-@@ -7023,6 +7068,7 @@ static int __netdev_upper_dev_link(struc
- 	if (ret)
- 		return ret;
- 
-+	netdev_update_addr_mask(dev);
- 	ret = call_netdevice_notifiers_info(NETDEV_CHANGEUPPER,
- 					    &changeupper_info.info);
- 	ret = notifier_to_errno(ret);
-@@ -7109,6 +7155,7 @@ void netdev_upper_dev_unlink(struct net_
- 
- 	__netdev_adjacent_dev_unlink_neighbour(dev, upper_dev);
- 
-+	netdev_update_addr_mask(dev);
- 	call_netdevice_notifiers_info(NETDEV_CHANGEUPPER,
- 				      &changeupper_info.info);
- }
-@@ -7732,6 +7779,7 @@ int dev_set_mac_address(struct net_devic
- 	if (err)
- 		return err;
- 	dev->addr_assign_type = NET_ADDR_SET;
-+	netdev_update_addr_mask(dev);
- 	call_netdevice_notifiers(NETDEV_CHANGEADDR, dev);
- 	add_device_randomness(dev->dev_addr, dev->addr_len);
- 	return 0;
---- a/net/ethernet/eth.c
-+++ b/net/ethernet/eth.c
-@@ -144,6 +144,18 @@ u32 eth_get_headlen(void *data, unsigned
- }
- EXPORT_SYMBOL(eth_get_headlen);
- 
-+static inline bool
-+eth_check_local_mask(const void *addr1, const void *addr2, const void *mask)
-+{
-+	const u16 *a1 = addr1;
-+	const u16 *a2 = addr2;
-+	const u16 *m = mask;
-+
-+	return (((a1[0] ^ a2[0]) & ~m[0]) |
-+		((a1[1] ^ a2[1]) & ~m[1]) |
-+		((a1[2] ^ a2[2]) & ~m[2]));
-+}
-+
- /**
-  * eth_type_trans - determine the packet's protocol ID.
-  * @skb: received socket data
-@@ -172,8 +184,12 @@ __be16 eth_type_trans(struct sk_buff *sk
- 			skb->pkt_type = PACKET_MULTICAST;
- 	}
- 	else if (unlikely(!ether_addr_equal_64bits(eth->h_dest,
--						   dev->dev_addr)))
-+						   dev->dev_addr))) {
- 		skb->pkt_type = PACKET_OTHERHOST;
-+		if (eth_check_local_mask(eth->h_dest, dev->dev_addr,
-+					 dev->local_addr_mask))
-+			skb->gro_skip = 1;
-+	}
- 
- 	/*
- 	 * Some variants of DSA tagging don't have an ethertype field
--- a/target/linux/generic/pending-4.19/681-NET-add-of_get_mac_address_mtd.patch	2022-03-22 08:54:47.416465018 +0800
+++ b/target/linux/generic/pending-4.19/681-NET-add-of_get_mac_address_mtd.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,133 +0,0 @@
-From: John Crispin <blogic@openwrt.org>
-Subject: NET: add mtd-mac-address support to of_get_mac_address()
-
-Many embedded devices have information such as mac addresses stored inside mtd
-devices. This patch allows us to add a property inside a node describing a
-network interface. The new property points at a mtd partition with an offset
-where the mac address can be found.
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- drivers/of/of_net.c    |   37 +++++++++++++++++++++++++++++++++++++
- include/linux/of_net.h |    1 +
- 2 files changed, 38 insertions(+)
-
---- a/drivers/of/of_net.c
-+++ b/drivers/of/of_net.c
-@@ -11,6 +11,7 @@
- #include <linux/of_net.h>
- #include <linux/phy.h>
- #include <linux/export.h>
-+#include <linux/mtd/mtd.h>
- 
- /**
-  * of_get_phy_mode - Get phy mode for given device_node
-@@ -39,7 +40,7 @@ int of_get_phy_mode(struct device_node *
- }
- EXPORT_SYMBOL_GPL(of_get_phy_mode);
- 
--static const void *of_get_mac_addr(struct device_node *np, const char *name)
-+static void *of_get_mac_addr(struct device_node *np, const char *name)
- {
- 	struct property *pp = of_find_property(np, name, NULL);
- 
-@@ -48,6 +49,79 @@ static const void *of_get_mac_addr(struc
- 	return NULL;
- }
- 
-+static const void *of_get_mac_address_mtd(struct device_node *np)
-+{
-+#ifdef CONFIG_MTD
-+	struct device_node *mtd_np = NULL;
-+	struct property *prop;
-+	size_t retlen;
-+	int size, ret;
-+	struct mtd_info *mtd;
-+	const char *part;
-+	const __be32 *list;
-+	phandle phandle;
-+	u32 mac_inc = 0;
-+	u8 mac[ETH_ALEN];
-+	void *addr;
-+	u32 inc_idx;
-+
-+	list = of_get_property(np, "mtd-mac-address", &size);
-+	if (!list || (size != (2 * sizeof(*list))))
-+		return NULL;
-+
-+	phandle = be32_to_cpup(list++);
-+	if (phandle)
-+		mtd_np = of_find_node_by_phandle(phandle);
-+
-+	if (!mtd_np)
-+		return NULL;
-+
-+	part = of_get_property(mtd_np, "label", NULL);
-+	if (!part)
-+		part = mtd_np->name;
-+
-+	mtd = get_mtd_device_nm(part);
-+	if (IS_ERR(mtd))
-+		return NULL;
-+
-+	ret = mtd_read(mtd, be32_to_cpup(list), 6, &retlen, mac);
-+	put_mtd_device(mtd);
-+
-+	if (of_property_read_u32(np, "mtd-mac-address-increment-byte", &inc_idx))
-+		inc_idx = 5;
-+	if (inc_idx > 5)
-+		return NULL;
-+
-+	if (!of_property_read_u32(np, "mtd-mac-address-increment", &mac_inc))
-+		mac[inc_idx] += mac_inc;
-+
-+	if (!is_valid_ether_addr(mac))
-+		return NULL;
-+
-+	addr = of_get_mac_addr(np, "mac-address");
-+	if (addr) {
-+		memcpy(addr, mac, ETH_ALEN);
-+		return addr;
-+	}
-+
-+	prop = kzalloc(sizeof(*prop), GFP_KERNEL);
-+	if (!prop)
-+		return NULL;
-+
-+	prop->name = "mac-address";
-+	prop->length = ETH_ALEN;
-+	prop->value = kmemdup(mac, ETH_ALEN, GFP_KERNEL);
-+	if (!prop->value || of_add_property(np, prop))
-+		goto free;
-+
-+	return prop->value;
-+free:
-+	kfree(prop->value);
-+	kfree(prop);
-+#endif
-+	return NULL;
-+}
-+
- /**
-  * Search the device tree for the best MAC address to use.  'mac-address' is
-  * checked first, because that is supposed to contain to "most recent" MAC
-@@ -65,11 +139,18 @@ static const void *of_get_mac_addr(struc
-  * addresses.  Some older U-Boots only initialized 'local-mac-address'.  In
-  * this case, the real MAC is in 'local-mac-address', and 'mac-address' exists
-  * but is all zeros.
-+ *
-+ * If a mtd-mac-address property exists, try to fetch the MAC address from the
-+ * specified mtd device, and store it as a 'mac-address' property
- */
- const void *of_get_mac_address(struct device_node *np)
- {
- 	const void *addr;
- 
-+	addr = of_get_mac_address_mtd(np);
-+	if (addr)
-+		return addr;
-+
- 	addr = of_get_mac_addr(np, "mac-address");
- 	if (addr)
- 		return addr;
--- a/target/linux/generic/pending-4.19/703-phy-add-detach-callback-to-struct-phy_driver.patch	2022-03-22 08:54:47.416465018 +0800
+++ b/target/linux/generic/pending-4.19/703-phy-add-detach-callback-to-struct-phy_driver.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,38 +0,0 @@
-From: Gabor Juhos <juhosg@openwrt.org>
-Subject: generic: add detach callback to struct phy_driver
-
-lede-commit: fe61fc2d7d0b3fb348b502f68f98243b3ddf5867
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/phy/phy_device.c | 3 +++
- include/linux/phy.h          | 6 ++++++
- 2 files changed, 9 insertions(+)
-
---- a/drivers/net/phy/phy_device.c
-+++ b/drivers/net/phy/phy_device.c
-@@ -1136,6 +1136,9 @@ void phy_detach(struct phy_device *phyde
- 	struct module *ndev_owner = dev->dev.parent->driver->owner;
- 	struct mii_bus *bus;
- 
-+	if (phydev->drv && phydev->drv->detach)
-+		phydev->drv->detach(phydev);
-+
- 	if (phydev->sysfs_links) {
- 		sysfs_remove_link(&dev->dev.kobj, "phydev");
- 		sysfs_remove_link(&phydev->mdio.dev.kobj, "attached_dev");
---- a/include/linux/phy.h
-+++ b/include/linux/phy.h
-@@ -560,6 +560,12 @@ struct phy_driver {
- 	 */
- 	int (*did_interrupt)(struct phy_device *phydev);
- 
-+	/*
-+	 * Called before an ethernet device is detached
-+	 * from the PHY.
-+	 */
-+	void (*detach)(struct phy_device *phydev);
-+
- 	/* Clears up any memory if needed */
- 	void (*remove)(struct phy_device *phydev);
- 
--- a/target/linux/generic/pending-4.19/734-net-phy-at803x-allow-to-configure-via-pdata.patch	2022-03-22 08:54:47.417465019 +0800
+++ b/target/linux/generic/pending-4.19/734-net-phy-at803x-allow-to-configure-via-pdata.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,142 +0,0 @@
-From: Gabor Juhos <juhosg@openwrt.org>
-Subject: net: phy: allow to configure AR803x PHYs via platform data
-
-Add a patch for the at803x phy driver, in order to be able
-to configure some register settings via platform data.
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/phy/at803x.c                 | 56 ++++++++++++++++++++++++++++++++
- include/linux/platform_data/phy-at803x.h | 11 +++++++
- 2 files changed, 67 insertions(+)
- create mode 100644 include/linux/platform_data/phy-at803x.h
-
---- a/drivers/net/phy/at803x.c
-+++ b/drivers/net/phy/at803x.c
-@@ -12,12 +12,14 @@
-  */
- 
- #include <linux/phy.h>
-+#include <linux/mdio.h>
- #include <linux/module.h>
- #include <linux/string.h>
- #include <linux/netdevice.h>
- #include <linux/etherdevice.h>
- #include <linux/of_gpio.h>
- #include <linux/gpio/consumer.h>
-+#include <linux/platform_data/phy-at803x.h>
- 
- #define AT803X_INTR_ENABLE			0x12
- #define AT803X_INTR_ENABLE_AUTONEG_ERR		BIT(15)
-@@ -45,6 +47,11 @@
- #define AT803X_REG_CHIP_CONFIG			0x1f
- #define AT803X_BT_BX_REG_SEL			0x8000
- 
-+#define AT803X_PCS_SMART_EEE_CTRL3			0x805D
-+#define AT803X_SMART_EEE_CTRL3_LPI_TX_DELAY_SEL_MASK	0x3
-+#define AT803X_SMART_EEE_CTRL3_LPI_TX_DELAY_SEL_SHIFT	12
-+#define AT803X_SMART_EEE_CTRL3_LPI_EN			BIT(8)
-+
- #define AT803X_DEBUG_ADDR			0x1D
- #define AT803X_DEBUG_DATA			0x1E
- 
-@@ -73,6 +80,7 @@ MODULE_LICENSE("GPL");
- 
- struct at803x_priv {
- 	bool phy_reset:1;
-+	int prev_speed;
- };
- 
- struct at803x_context {
-@@ -249,8 +257,16 @@ static int at803x_probe(struct phy_devic
- 	return 0;
- }
- 
-+static void at803x_disable_smarteee(struct phy_device *phydev)
-+{
-+	phy_write_mmd(phydev, MDIO_MMD_PCS, AT803X_PCS_SMART_EEE_CTRL3,
-+		1 << AT803X_SMART_EEE_CTRL3_LPI_TX_DELAY_SEL_SHIFT);
-+	phy_write_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_ADV, 0);
-+}
-+
- static int at803x_config_init(struct phy_device *phydev)
- {
-+	struct at803x_platform_data *pdata;
- 	int ret;
- 
- 	ret = genphy_config_init(phydev);
-@@ -271,6 +287,26 @@ static int at803x_config_init(struct phy
- 			return ret;
- 	}
- 
-+	pdata = dev_get_platdata(&phydev->mdio.dev);
-+	if (pdata) {
-+		if (pdata->disable_smarteee)
-+			at803x_disable_smarteee(phydev);
-+
-+		if (pdata->enable_rgmii_rx_delay)
-+			at803x_debug_reg_mask(phydev, AT803X_DEBUG_REG_0, 0,
-+				AT803X_DEBUG_RX_CLK_DLY_EN);
-+		else
-+			at803x_debug_reg_mask(phydev, AT803X_DEBUG_REG_0,
-+				AT803X_DEBUG_RX_CLK_DLY_EN, 0);
-+
-+		if (pdata->enable_rgmii_tx_delay)
-+			at803x_debug_reg_mask(phydev, AT803X_DEBUG_REG_5, 0,
-+				AT803X_DEBUG_TX_CLK_DLY_EN);
-+		else
-+			at803x_debug_reg_mask(phydev, AT803X_DEBUG_REG_5,
-+				AT803X_DEBUG_TX_CLK_DLY_EN, 0);
-+	}
-+
- 	return 0;
- }
- 
-@@ -308,6 +344,8 @@ static int at803x_config_intr(struct phy
- static void at803x_link_change_notify(struct phy_device *phydev)
- {
- 	struct at803x_priv *priv = phydev->priv;
-+	struct at803x_platform_data *pdata;
-+	pdata = dev_get_platdata(&phydev->mdio.dev);
- 
- 	/*
- 	 * Conduct a hardware reset for AT8030/2 every time a link loss is
-@@ -336,6 +374,24 @@ static void at803x_link_change_notify(st
- 	} else {
- 		priv->phy_reset = false;
- 	}
-+	if (pdata && pdata->fixup_rgmii_tx_delay &&
-+	    phydev->speed != priv->prev_speed) {
-+		switch (phydev->speed) {
-+		case SPEED_10:
-+		case SPEED_100:
-+			at803x_debug_reg_mask(phydev, AT803X_DEBUG_REG_5, 0,
-+				AT803X_DEBUG_TX_CLK_DLY_EN);
-+			break;
-+		case SPEED_1000:
-+			at803x_debug_reg_mask(phydev, AT803X_DEBUG_REG_5,
-+				AT803X_DEBUG_TX_CLK_DLY_EN, 0);
-+			break;
-+		default:
-+			break;
-+		}
-+
-+		priv->prev_speed = phydev->speed;
-+	}
- }
- 
- static int at803x_aneg_done(struct phy_device *phydev)
---- /dev/null
-+++ b/include/linux/platform_data/phy-at803x.h
-@@ -0,0 +1,11 @@
-+#ifndef _PHY_AT803X_PDATA_H
-+#define _PHY_AT803X_PDATA_H
-+
-+struct at803x_platform_data {
-+	int disable_smarteee:1;
-+	int enable_rgmii_tx_delay:1;
-+	int enable_rgmii_rx_delay:1;
-+	int fixup_rgmii_tx_delay:1;
-+};
-+
-+#endif /* _PHY_AT803X_PDATA_H */
--- a/target/linux/generic/pending-4.19/735-net-phy-at803x-fix-at8033-sgmii-mode.patch	2022-03-22 08:54:47.417465019 +0800
+++ b/target/linux/generic/pending-4.19/735-net-phy-at803x-fix-at8033-sgmii-mode.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,51 +0,0 @@
-From: Roman Yeryomin <roman@advem.lv>
-Subject: kernel: add at803x fix for sgmii mode
-
-Some (possibly broken) bootloaders incorreclty initialize at8033
-phy. This patch enables sgmii autonegotiation mode.
-
-[john@phrozen.org: felix added this to his upstream queue]
-
-Signed-off-by: Roman Yeryomin <roman@advem.lv>
----
- drivers/net/phy/at803x.c | 25 +++++++++++++++++++++++++
- 1 file changed, 25 insertions(+)
-
---- a/drivers/net/phy/at803x.c
-+++ b/drivers/net/phy/at803x.c
-@@ -46,6 +46,7 @@
- #define AT803X_FUNC_DATA			0x4003
- #define AT803X_REG_CHIP_CONFIG			0x1f
- #define AT803X_BT_BX_REG_SEL			0x8000
-+#define AT803X_SGMII_ANEG_EN			0x1000
- 
- #define AT803X_PCS_SMART_EEE_CTRL3			0x805D
- #define AT803X_SMART_EEE_CTRL3_LPI_TX_DELAY_SEL_MASK	0x3
-@@ -268,6 +269,27 @@ static int at803x_config_init(struct phy
- {
- 	struct at803x_platform_data *pdata;
- 	int ret;
-+	u32 v;
-+
-+	if (phydev->drv->phy_id == ATH8031_PHY_ID &&
-+		phydev->interface == PHY_INTERFACE_MODE_SGMII)
-+	{
-+		v = phy_read(phydev, AT803X_REG_CHIP_CONFIG);
-+		/* select SGMII/fiber page */
-+		ret = phy_write(phydev, AT803X_REG_CHIP_CONFIG,
-+						v & ~AT803X_BT_BX_REG_SEL);
-+		if (ret)
-+			return ret;
-+		/* enable SGMII autonegotiation */
-+		ret = phy_write(phydev, MII_BMCR, AT803X_SGMII_ANEG_EN);
-+		if (ret)
-+			return ret;
-+		/* select copper page */
-+		ret = phy_write(phydev, AT803X_REG_CHIP_CONFIG,
-+						v | AT803X_BT_BX_REG_SEL);
-+		if (ret)
-+			return ret;
-+	}
- 
- 	ret = genphy_config_init(phydev);
- 	if (ret < 0)
--- a/target/linux/generic/pending-4.19/736-net-phy-at803x-allow-to-configure-via-dt.patch	2022-03-22 08:54:47.417465019 +0800
+++ b/target/linux/generic/pending-4.19/736-net-phy-at803x-allow-to-configure-via-dt.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,47 +0,0 @@
---- a/drivers/net/phy/at803x.c
-+++ b/drivers/net/phy/at803x.c
-@@ -329,6 +329,14 @@ static int at803x_config_init(struct phy
- 				AT803X_DEBUG_TX_CLK_DLY_EN, 0);
- 	}
- 
-+#ifdef CONFIG_OF_MDIO
-+	if (phydev->mdio.dev.of_node &&
-+		of_property_read_bool(phydev->mdio.dev.of_node,
-+				      "at803x-disable-smarteee")) {
-+		at803x_disable_smarteee(phydev);
-+	}
-+#endif
-+
- 	return 0;
- }
- 
-@@ -367,6 +375,7 @@ static void at803x_link_change_notify(st
- {
- 	struct at803x_priv *priv = phydev->priv;
- 	struct at803x_platform_data *pdata;
-+	u8 fixup_rgmii_tx_delay = 0;
- 	pdata = dev_get_platdata(&phydev->mdio.dev);
- 
- 	/*
-@@ -396,8 +405,19 @@ static void at803x_link_change_notify(st
- 	} else {
- 		priv->phy_reset = false;
- 	}
--	if (pdata && pdata->fixup_rgmii_tx_delay &&
--	    phydev->speed != priv->prev_speed) {
-+
-+	if (pdata && pdata->fixup_rgmii_tx_delay)
-+		fixup_rgmii_tx_delay = 1;
-+
-+#ifdef CONFIG_OF_MDIO
-+	if (phydev->mdio.dev.of_node &&
-+		of_property_read_bool(phydev->mdio.dev.of_node,
-+				      "at803x-fixup-rgmii-tx-delay")) {
-+			fixup_rgmii_tx_delay = 1;
-+	}
-+#endif
-+
-+	if (fixup_rgmii_tx_delay && phydev->speed != priv->prev_speed) {
- 		switch (phydev->speed) {
- 		case SPEED_10:
- 		case SPEED_100:
--- a/target/linux/generic/pending-4.19/800-bcma-get-SoC-device-struct-copy-its-DMA-params-to-th.patch	2022-03-22 08:54:47.418465021 +0800
+++ b/target/linux/generic/pending-4.19/800-bcma-get-SoC-device-struct-copy-its-DMA-params-to-th.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,70 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Subject: [PATCH] bcma: get SoC device struct & copy its DMA params to the
- subdevices
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-For bus devices to be fully usable it's required to set their DMA
-parameters.
-
-For years it has been missing and remained unnoticed because of
-mips_dma_alloc_coherent() silently handling the empty coherent_dma_mask.
-Kernel 4.19 came with a lot of DMA changes and caused a regression on
-the bcm47xx. Starting with the commit f8c55dc6e828 ("MIPS: use generic
-dma noncoherent ops for simple noncoherent platforms") DMA coherent
-allocations just fail. Example:
-[    1.114914] bgmac_bcma bcma0:2: Allocation of TX ring 0x200 failed
-[    1.121215] bgmac_bcma bcma0:2: Unable to alloc memory for DMA
-[    1.127626] bgmac_bcma: probe of bcma0:2 failed with error -12
-[    1.133838] bgmac_bcma: Broadcom 47xx GBit MAC driver loaded
-
-This change fixes above regression in addition to the MIPS bcm47xx
-commit 321c46b91550 ("MIPS: BCM47XX: Setup struct device for the SoC").
-
-It also fixes another *old* GPIO regression caused by a parent pointing
-to the NULL:
-[    0.157054] missing gpiochip .dev parent pointer
-[    0.157287] bcma: bus0: Error registering GPIO driver: -22
-introduced by the commit 74f4e0cc6108 ("bcma: switch GPIO portions to
-use GPIOLIB_IRQCHIP").
-
-Fixes: f8c55dc6e828 ("MIPS: use generic dma noncoherent ops for simple noncoherent platforms")
-Fixes: 74f4e0cc6108 ("bcma: switch GPIO portions to use GPIOLIB_IRQCHIP")
-Cc: linux-mips@linux-mips.org
-Cc: Christoph Hellwig <hch@lst.de>
-Cc: Linus Walleij <linus.walleij@linaro.org>
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
----
-
---- a/drivers/bcma/host_soc.c
-+++ b/drivers/bcma/host_soc.c
-@@ -191,6 +191,8 @@ int __init bcma_host_soc_init(struct bcm
- 	struct bcma_bus *bus = &soc->bus;
- 	int err;
- 
-+	bus->dev = soc->dev;
-+
- 	/* Scan bus and initialize it */
- 	err = bcma_bus_early_register(bus);
- 	if (err)
---- a/drivers/bcma/main.c
-+++ b/drivers/bcma/main.c
-@@ -236,12 +236,16 @@ EXPORT_SYMBOL(bcma_core_irq);
- 
- void bcma_prepare_core(struct bcma_bus *bus, struct bcma_device *core)
- {
-+	struct device *dev = &core->dev;
-+
- 	core->dev.release = bcma_release_core_dev;
- 	core->dev.bus = &bcma_bus_type;
- 	dev_set_name(&core->dev, "bcma%d:%d", bus->num, core->core_index);
- 	core->dev.parent = bus->dev;
--	if (bus->dev)
-+	if (bus->dev) {
- 		bcma_of_fill_device(bus->dev, core);
-+		dma_coerce_mask_and_coherent(dev, bus->dev->coherent_dma_mask);
-+	}
- 
- 	switch (bus->hosttype) {
- 	case BCMA_HOSTTYPE_PCI:
--- a/target/linux/generic/pending-4.19/810-pci_disable_common_quirks.patch	2022-03-22 08:54:47.418465021 +0800
+++ b/target/linux/generic/pending-4.19/810-pci_disable_common_quirks.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,62 +0,0 @@
-From: Gabor Juhos <juhosg@openwrt.org>
-Subject: debloat: add kernel config option to disabling common PCI quirks
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/pci/Kconfig  | 6 ++++++
- drivers/pci/quirks.c | 6 ++++++
- 2 files changed, 12 insertions(+)
-
---- a/drivers/pci/Kconfig
-+++ b/drivers/pci/Kconfig
-@@ -89,6 +89,13 @@ config XEN_PCIDEV_FRONTEND
-           The PCI device frontend driver allows the kernel to import arbitrary
-           PCI devices from a PCI backend to support PCI driver domains.
- 
-+config PCI_DISABLE_COMMON_QUIRKS
-+	bool "PCI disable common quirks"
-+	depends on PCI
-+	help
-+	  If you don't know what to do here, say N.
-+
-+
- config PCI_ATS
- 	bool
- 
---- a/drivers/pci/quirks.c
-+++ b/drivers/pci/quirks.c
-@@ -207,6 +207,7 @@ static void quirk_mmio_always_on(struct
- DECLARE_PCI_FIXUP_CLASS_EARLY(PCI_ANY_ID, PCI_ANY_ID,
- 				PCI_CLASS_BRIDGE_HOST, 8, quirk_mmio_always_on);
- 
-+#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
- /*
-  * The Mellanox Tavor device gives false positive parity errors.  Mark this
-  * device with a broken_parity_status to allow PCI scanning code to "skip"
-@@ -3152,6 +3153,8 @@ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_I
- DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x65f9, quirk_intel_mc_errata);
- DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x65fa, quirk_intel_mc_errata);
- 
-+#endif /* !CONFIG_PCI_DISABLE_COMMON_QUIRKS */
-+
- /*
-  * Ivytown NTB BAR sizes are misreported by the hardware due to an erratum.
-  * To work around this, query the size it should be configured to by the
-@@ -3177,6 +3180,8 @@ static void quirk_intel_ntb(struct pci_d
- DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x0e08, quirk_intel_ntb);
- DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x0e0d, quirk_intel_ntb);
- 
-+#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
-+
- /*
-  * Some BIOS implementations leave the Intel GPU interrupts enabled, even
-  * though no one is handling them (e.g., if the i915 driver is never
-@@ -3215,6 +3220,8 @@ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_IN
- DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x010a, disable_igfx_irq);
- DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x0152, disable_igfx_irq);
- 
-+#endif /* !CONFIG_PCI_DISABLE_COMMON_QUIRKS */
-+
- /*
-  * PCI devices which are on Intel chips can skip the 10ms delay
-  * before entering D3 mode.
--- a/target/linux/generic/pending-4.19/811-pci_disable_usb_common_quirks.patch	2022-03-22 08:54:47.418465021 +0800
+++ b/target/linux/generic/pending-4.19/811-pci_disable_usb_common_quirks.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,115 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: debloat: disable common USB quirks
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- drivers/usb/host/pci-quirks.c | 16 ++++++++++++++++
- drivers/usb/host/pci-quirks.h | 18 +++++++++++++++++-
- include/linux/usb/hcd.h       |  7 +++++++
- 3 files changed, 40 insertions(+), 1 deletion(-)
-
---- a/drivers/usb/host/pci-quirks.c
-+++ b/drivers/usb/host/pci-quirks.c
-@@ -125,6 +125,8 @@ struct amd_chipset_type {
- 	u8 rev;
- };
- 
-+#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
-+
- static struct amd_chipset_info {
- 	struct pci_dev	*nb_dev;
- 	struct pci_dev	*smbus_dev;
-@@ -628,6 +630,10 @@ bool usb_amd_pt_check_port(struct device
- }
- EXPORT_SYMBOL_GPL(usb_amd_pt_check_port);
- 
-+#endif /* CONFIG_PCI_DISABLE_COMMON_QUIRKS */
-+
-+#if IS_ENABLED(CONFIG_USB_UHCI_HCD)
-+
- /*
-  * Make sure the controller is completely inactive, unable to
-  * generate interrupts or do DMA.
-@@ -707,8 +713,17 @@ reset_needed:
- 	uhci_reset_hc(pdev, base);
- 	return 1;
- }
-+#else
-+int uhci_check_and_reset_hc(struct pci_dev *pdev, unsigned long base)
-+{
-+	return 0;
-+}
-+
-+#endif
- EXPORT_SYMBOL_GPL(uhci_check_and_reset_hc);
- 
-+#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
-+
- static inline int io_type_enabled(struct pci_dev *pdev, unsigned int mask)
- {
- 	u16 cmd;
-@@ -1275,3 +1290,4 @@ static void quirk_usb_early_handoff(stru
- }
- DECLARE_PCI_FIXUP_CLASS_FINAL(PCI_ANY_ID, PCI_ANY_ID,
- 			PCI_CLASS_SERIAL_USB, 8, quirk_usb_early_handoff);
-+#endif
---- a/drivers/usb/host/pci-quirks.h
-+++ b/drivers/usb/host/pci-quirks.h
-@@ -5,6 +5,9 @@
- #ifdef CONFIG_USB_PCI
- void uhci_reset_hc(struct pci_dev *pdev, unsigned long base);
- int uhci_check_and_reset_hc(struct pci_dev *pdev, unsigned long base);
-+#endif  /* CONFIG_USB_PCI */
-+
-+#if defined(CONFIG_USB_PCI) && !defined(CONFIG_PCI_DISABLE_COMMON_QUIRKS)
- int usb_amd_find_chipset_info(void);
- int usb_hcd_amd_remote_wakeup_quirk(struct pci_dev *pdev);
- bool usb_amd_hang_symptom_quirk(void);
-@@ -19,6 +22,18 @@ void sb800_prefetch(struct device *dev,
- bool usb_amd_pt_check_port(struct device *device, int port);
- #else
- struct pci_dev;
-+static inline int usb_amd_find_chipset_info(void)
-+{
-+	return 0;
-+}
-+static inline bool usb_amd_hang_symptom_quirk(void)
-+{
-+	return false;
-+}
-+static inline bool usb_amd_prefetch_quirk(void)
-+{
-+	return false;
-+}
- static inline void usb_amd_quirk_pll_disable(void) {}
- static inline void usb_amd_quirk_pll_enable(void) {}
- static inline void usb_asmedia_modifyflowcontrol(struct pci_dev *pdev) {}
-@@ -29,6 +44,11 @@ static inline bool usb_amd_pt_check_port
- {
- 	return false;
- }
-+static inline void usb_enable_intel_xhci_ports(struct pci_dev *xhci_pdev) {}
-+static inline bool usb_xhci_needs_pci_reset(struct pci_dev *pdev)
-+{
-+	return false;
-+}
- #endif  /* CONFIG_USB_PCI */
- 
- #endif  /*  __LINUX_USB_PCI_QUIRKS_H  */
---- a/include/linux/usb/hcd.h
-+++ b/include/linux/usb/hcd.h
-@@ -473,7 +473,14 @@ extern int usb_hcd_pci_probe(struct pci_
- extern void usb_hcd_pci_remove(struct pci_dev *dev);
- extern void usb_hcd_pci_shutdown(struct pci_dev *dev);
- 
-+#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
- extern int usb_hcd_amd_remote_wakeup_quirk(struct pci_dev *dev);
-+#else
-+static inline int usb_hcd_amd_remote_wakeup_quirk(struct pci_dev *dev)
-+{
-+	return 0;
-+}
-+#endif
- 
- #ifdef CONFIG_PM
- extern const struct dev_pm_ops usb_hcd_pci_pm_ops;
--- a/target/linux/generic/pending-4.19/834-ledtrig-libata.patch	2022-03-22 08:54:47.419465023 +0800
+++ b/target/linux/generic/pending-4.19/834-ledtrig-libata.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,149 +0,0 @@
-From: Daniel Golle <daniel@makrotopia.org>
-Subject: libata: add ledtrig support
-
-This adds a LED trigger for each ATA port indicating disk activity.
-
-As this is needed only on specific platforms (NAS SoCs and such),
-these platforms should define ARCH_WANTS_LIBATA_LEDS if there
-are boards with LED(s) intended to indicate ATA disk activity and
-need the OS to take care of that.
-In that way, if not selected, LED trigger support not will be
-included in libata-core and both, codepaths and structures remain
-untouched.
-
-Signed-off-by: Daniel Golle <daniel@makrotopia.org>
----
- drivers/ata/Kconfig       | 16 ++++++++++++++++
- drivers/ata/libata-core.c | 41 +++++++++++++++++++++++++++++++++++++++++
- include/linux/libata.h    |  9 +++++++++
- 3 files changed, 66 insertions(+)
-
---- a/drivers/ata/Kconfig
-+++ b/drivers/ata/Kconfig
-@@ -46,6 +46,22 @@ config ATA_VERBOSE_ERROR
- 
- 	  If unsure, say Y.
- 
-+config ARCH_WANT_LIBATA_LEDS
-+	bool
-+
-+config ATA_LEDS
-+	bool "support ATA port LED triggers"
-+	depends on ARCH_WANT_LIBATA_LEDS
-+	select NEW_LEDS
-+	select LEDS_CLASS
-+	select LEDS_TRIGGERS
-+	default y
-+	help
-+	  This option adds a LED trigger for each registered ATA port.
-+	  It is used to drive disk activity leds connected via GPIO.
-+
-+	  If unsure, say N.
-+
- config ATA_ACPI
- 	bool "ATA ACPI Support"
- 	depends on ACPI
---- a/drivers/ata/libata-core.c
-+++ b/drivers/ata/libata-core.c
-@@ -731,6 +731,19 @@ u64 ata_tf_read_block(const struct ata_t
- 	return block;
- }
- 
-+#ifdef CONFIG_ATA_LEDS
-+#define LIBATA_BLINK_DELAY 20 /* ms */
-+static inline void ata_led_act(struct ata_port *ap)
-+{
-+	unsigned long led_delay = LIBATA_BLINK_DELAY;
-+
-+	if (unlikely(!ap->ledtrig))
-+		return;
-+
-+	led_trigger_blink_oneshot(ap->ledtrig, &led_delay, &led_delay, 0);
-+}
-+#endif
-+
- /**
-  *	ata_build_rw_tf - Build ATA taskfile for given read/write request
-  *	@tf: Target ATA taskfile
-@@ -5134,6 +5147,9 @@ struct ata_queued_cmd *ata_qc_new_init(s
- 		if (tag < 0)
- 			return NULL;
- 	}
-+#ifdef CONFIG_ATA_LEDS
-+	ata_led_act(ap);
-+#endif
- 
- 	qc = __ata_qc_from_tag(ap, tag);
- 	qc->tag = qc->hw_tag = tag;
-@@ -6044,6 +6060,9 @@ struct ata_port *ata_port_alloc(struct a
- 	ap->stats.unhandled_irq = 1;
- 	ap->stats.idle_irq = 1;
- #endif
-+#ifdef CONFIG_ATA_LEDS
-+	ap->ledtrig = kzalloc(sizeof(struct led_trigger), GFP_KERNEL);
-+#endif
- 	ata_sff_port_init(ap);
- 
- 	return ap;
-@@ -6079,6 +6098,12 @@ static void ata_host_release(struct kref
- 
- 		kfree(ap->pmp_link);
- 		kfree(ap->slave_link);
-+#ifdef CONFIG_ATA_LEDS
-+		if (ap->ledtrig) {
-+			led_trigger_unregister(ap->ledtrig);
-+			kfree(ap->ledtrig);
-+		};
-+#endif
- 		kfree(ap);
- 		host->ports[i] = NULL;
- 	}
-@@ -6542,7 +6567,23 @@ int ata_host_register(struct ata_host *h
- 		host->ports[i]->print_id = atomic_inc_return(&ata_print_id);
- 		host->ports[i]->local_port_no = i + 1;
- 	}
-+#ifdef CONFIG_ATA_LEDS
-+	for (i = 0; i < host->n_ports; i++) {
-+		if (unlikely(!host->ports[i]->ledtrig))
-+			continue;
- 
-+		snprintf(host->ports[i]->ledtrig_name,
-+			sizeof(host->ports[i]->ledtrig_name), "ata%u",
-+			host->ports[i]->print_id);
-+
-+		host->ports[i]->ledtrig->name = host->ports[i]->ledtrig_name;
-+
-+		if (led_trigger_register(host->ports[i]->ledtrig)) {
-+			kfree(host->ports[i]->ledtrig);
-+			host->ports[i]->ledtrig = NULL;
-+		}
-+	}
-+#endif
- 	/* Create associated sysfs transport objects  */
- 	for (i = 0; i < host->n_ports; i++) {
- 		rc = ata_tport_add(host->dev,host->ports[i]);
---- a/include/linux/libata.h
-+++ b/include/linux/libata.h
-@@ -38,6 +38,9 @@
- #include <linux/acpi.h>
- #include <linux/cdrom.h>
- #include <linux/sched.h>
-+#ifdef CONFIG_ATA_LEDS
-+#include <linux/leds.h>
-+#endif
- 
- /*
-  * Define if arch has non-standard setup.  This is a _PCI_ standard
-@@ -893,6 +896,12 @@ struct ata_port {
- #ifdef CONFIG_ATA_ACPI
- 	struct ata_acpi_gtm	__acpi_init_gtm; /* use ata_acpi_init_gtm() */
- #endif
-+
-+#ifdef CONFIG_ATA_LEDS
-+	struct led_trigger	*ledtrig;
-+	char			ledtrig_name[8];
-+#endif
-+
- 	/* owned by EH */
- 	u8			sector_buf[ATA_SECT_SIZE] ____cacheline_aligned;
- };
--- a/target/linux/generic/pending-4.19/920-mangle_bootargs.patch	2022-03-22 08:54:47.419465023 +0800
+++ b/target/linux/generic/pending-4.19/920-mangle_bootargs.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,71 +0,0 @@
-From: Imre Kaloz <kaloz@openwrt.org>
-Subject: init: add CONFIG_MANGLE_BOOTARGS and disable it by default
-
-Enabling this option renames the bootloader supplied root=
-and rootfstype= variables, which might have to be know but
-would break the automatisms OpenWrt uses.
-
-Signed-off-by: Imre Kaloz <kaloz@openwrt.org>
----
- init/Kconfig |  9 +++++++++
- init/main.c  | 24 ++++++++++++++++++++++++
- 2 files changed, 33 insertions(+)
-
---- a/init/Kconfig
-+++ b/init/Kconfig
-@@ -1531,6 +1531,15 @@ config EMBEDDED
- 	  an embedded system so certain expert options are available
- 	  for configuration.
- 
-+config MANGLE_BOOTARGS
-+	bool "Rename offending bootargs"
-+	depends on EXPERT
-+	help
-+	  Sometimes the bootloader passed bogus root= and rootfstype=
-+	  parameters to the kernel, and while you want to ignore them,
-+	  you need to know the values f.e. to support dual firmware
-+	  layouts on the flash.
-+
- config HAVE_PERF_EVENTS
- 	bool
- 	help
---- a/init/main.c
-+++ b/init/main.c
-@@ -365,6 +365,29 @@ static inline void setup_nr_cpu_ids(void
- static inline void smp_prepare_cpus(unsigned int maxcpus) { }
- #endif
- 
-+#ifdef CONFIG_MANGLE_BOOTARGS
-+static void __init mangle_bootargs(char *command_line)
-+{
-+	char *rootdev;
-+	char *rootfs;
-+
-+	rootdev = strstr(command_line, "root=/dev/mtdblock");
-+
-+	if (rootdev)
-+		strncpy(rootdev, "mangled_rootblock=", 18);
-+
-+	rootfs = strstr(command_line, "rootfstype");
-+
-+	if (rootfs)
-+		strncpy(rootfs, "mangled_fs", 10);
-+
-+}
-+#else
-+static void __init mangle_bootargs(char *command_line)
-+{
-+}
-+#endif
-+
- /*
-  * We need to store the untouched command line for future reference.
-  * We also need to store the touched command line since the parameter
-@@ -557,6 +580,7 @@ asmlinkage __visible void __init start_k
- 	add_device_randomness(command_line, strlen(command_line));
- 	boot_init_stack_canary();
- 	mm_init_cpumask(&init_mm);
-+	mangle_bootargs(command_line);
- 	setup_command_line(command_line);
- 	setup_nr_cpu_ids();
- 	setup_per_cpu_areas();
--- a/target/linux/generic/pending-4.9/0931-w1-gpio-fix-problem-with-platfom-data-in-w1-gpio.patch	2022-03-22 08:54:47.420465024 +0800
+++ b/target/linux/generic/pending-4.9/0931-w1-gpio-fix-problem-with-platfom-data-in-w1-gpio.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,38 +0,0 @@
-From d9c8bc8c1408f3e8529db6e4e04017b4c579c342 Mon Sep 17 00:00:00 2001
-From: Pawel Dembicki <paweldembicki@gmail.com>
-Date: Sun, 18 Feb 2018 17:08:04 +0100
-Subject: [PATCH] w1: gpio: fix problem with platfom data in w1-gpio
-
-In devices, where fdt is used, is impossible to apply platform data
-without proper fdt node.
-
-This patch allow to use platform data in devices with fdt.
-
-Signed-off-by: Pawel Dembicki <paweldembicki@gmail.com>
----
- drivers/w1/masters/w1-gpio.c | 7 +++----
- 1 file changed, 3 insertions(+), 4 deletions(-)
-
---- a/drivers/w1/masters/w1-gpio.c
-+++ b/drivers/w1/masters/w1-gpio.c
-@@ -113,17 +113,16 @@ static int w1_gpio_probe_dt(struct platf
- static int w1_gpio_probe(struct platform_device *pdev)
- {
- 	struct w1_bus_master *master;
--	struct w1_gpio_platform_data *pdata;
-+	struct w1_gpio_platform_data *pdata = dev_get_platdata(&pdev->dev);
- 	int err;
- 
--	if (of_have_populated_dt()) {
-+	if (of_have_populated_dt() && !pdata) {
- 		err = w1_gpio_probe_dt(pdev);
- 		if (err < 0)
- 			return err;
-+		pdata = dev_get_platdata(&pdev->dev);
- 	}
- 
--	pdata = dev_get_platdata(&pdev->dev);
--
- 	if (!pdata) {
- 		dev_err(&pdev->dev, "No configuration data\n");
- 		return -ENXIO;
--- a/target/linux/generic/pending-4.9/100-MIPS-fix-cache-flushing-for-highmem-pages.patch	2022-03-22 08:54:47.420465024 +0800
+++ b/target/linux/generic/pending-4.9/100-MIPS-fix-cache-flushing-for-highmem-pages.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,30 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: MIPS: fix cache flushing for highmem pages
-
-Most cache flush ops were no-op for highmem pages. This led to nasty
-segfaults and (in the case of page_address(page) == NULL) kernel
-crashes.
-
-Fix this by always flushing highmem pages using kmap/kunmap_atomic
-around the actual cache flush. This might be a bit inefficient, but at
-least it's stable.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/arch/mips/mm/cache.c
-+++ b/arch/mips/mm/cache.c
-@@ -115,6 +115,13 @@ void __flush_anon_page(struct page *page
- {
- 	unsigned long addr = (unsigned long) page_address(page);
- 
-+	if (PageHighMem(page)) {
-+		addr = (unsigned long)kmap_atomic(page);
-+		flush_data_cache_page(addr);
-+		__kunmap_atomic((void *)addr);
-+		return;
-+	}
-+
- 	if (pages_do_alias(addr, vmaddr)) {
- 		if (page_mapcount(page) && !Page_dcache_dirty(page)) {
- 			void *kaddr;
--- a/target/linux/generic/pending-4.9/110-ehci_hcd_ignore_oc.patch	2022-03-22 08:54:47.420465024 +0800
+++ b/target/linux/generic/pending-4.9/110-ehci_hcd_ignore_oc.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,79 +0,0 @@
-From: Florian Fainelli <florian@openwrt.org>
-Subject: USB: EHCI: add ignore_oc flag to disable overcurrent checking
-
-This patch adds an ignore_oc flag which can be set by EHCI controller
-not supporting or wanting to disable overcurrent checking. The EHCI
-platform data in include/linux/usb/ehci_pdriver.h is also augmented to
-take advantage of this new flag.
-
-Signed-off-by: Florian Fainelli <florian@openwrt.org>
----
- drivers/usb/host/ehci-hcd.c      |    2 +-
- drivers/usb/host/ehci-hub.c      |    4 ++--
- drivers/usb/host/ehci-platform.c |    1 +
- drivers/usb/host/ehci.h          |    1 +
- include/linux/usb/ehci_pdriver.h |    1 +
- 5 files changed, 6 insertions(+), 3 deletions(-)
-
---- a/drivers/usb/host/ehci-hcd.c
-+++ b/drivers/usb/host/ehci-hcd.c
-@@ -651,7 +651,7 @@ static int ehci_run (struct usb_hcd *hcd
- 		"USB %x.%x started, EHCI %x.%02x%s\n",
- 		((ehci->sbrn & 0xf0)>>4), (ehci->sbrn & 0x0f),
- 		temp >> 8, temp & 0xff,
--		ignore_oc ? ", overcurrent ignored" : "");
-+		(ignore_oc || ehci->ignore_oc) ? ", overcurrent ignored" : "");
- 
- 	ehci_writel(ehci, INTR_MASK,
- 		    &ehci->regs->intr_enable); /* Turn On Interrupts */
---- a/drivers/usb/host/ehci-hub.c
-+++ b/drivers/usb/host/ehci-hub.c
-@@ -638,7 +638,7 @@ ehci_hub_status_data (struct usb_hcd *hc
- 	 * always set, seem to clear PORT_OCC and PORT_CSC when writing to
- 	 * PORT_POWER; that's surprising, but maybe within-spec.
- 	 */
--	if (!ignore_oc)
-+	if (!ignore_oc && !ehci->ignore_oc)
- 		mask = PORT_CSC | PORT_PEC | PORT_OCC;
- 	else
- 		mask = PORT_CSC | PORT_PEC;
-@@ -1008,7 +1008,7 @@ int ehci_hub_control(
- 		if (temp & PORT_PEC)
- 			status |= USB_PORT_STAT_C_ENABLE << 16;
- 
--		if ((temp & PORT_OCC) && !ignore_oc){
-+		if ((temp & PORT_OCC) && (!ignore_oc && !ehci->ignore_oc)){
- 			status |= USB_PORT_STAT_C_OVERCURRENT << 16;
- 
- 			/*
---- a/drivers/usb/host/ehci-platform.c
-+++ b/drivers/usb/host/ehci-platform.c
-@@ -259,6 +259,8 @@ static int ehci_platform_probe(struct pl
- 		hcd->has_tt = 1;
- 	if (pdata->reset_on_resume)
- 		priv->reset_on_resume = true;
-+	if (pdata->ignore_oc)
-+		ehci->ignore_oc = 1;
- 
- #ifndef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO
- 	if (ehci->big_endian_mmio) {
---- a/drivers/usb/host/ehci.h
-+++ b/drivers/usb/host/ehci.h
-@@ -230,6 +230,7 @@ struct ehci_hcd {			/* one per controlle
- 	unsigned		frame_index_bug:1; /* MosChip (AKA NetMos) */
- 	unsigned		need_oc_pp_cycle:1; /* MPC834X port power */
- 	unsigned		imx28_write_fix:1; /* For Freescale i.MX28 */
-+	unsigned		ignore_oc:1;
- 
- 	/* required for usb32 quirk */
- 	#define OHCI_CTRL_HCFS          (3 << 6)
---- a/include/linux/usb/ehci_pdriver.h
-+++ b/include/linux/usb/ehci_pdriver.h
-@@ -49,6 +49,7 @@ struct usb_ehci_pdata {
- 	unsigned	no_io_watchdog:1;
- 	unsigned	reset_on_resume:1;
- 	unsigned	dma_mask_64:1;
-+	unsigned	ignore_oc:1;
- 
- 	/* Turn on all power and clocks */
- 	int (*power_on)(struct platform_device *pdev);
--- a/target/linux/generic/pending-4.9/120-Fix-alloc_node_mem_map-with-ARCH_PFN_OFFSET-calcu.patch	2022-03-22 08:54:47.421465026 +0800
+++ b/target/linux/generic/pending-4.9/120-Fix-alloc_node_mem_map-with-ARCH_PFN_OFFSET-calcu.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,82 +0,0 @@
-From: Tobias Wolf <dev-NTEO@vplace.de>
-Subject: mm: Fix alloc_node_mem_map with ARCH_PFN_OFFSET calculation
-
-An rt288x (ralink) based router (Belkin F5D8235 v1) does not boot with any
-kernel beyond version 4.3 resulting in:
-
-BUG: Bad page state in process swapper  pfn:086ac
-
-bisect resulted in:
-
-a1c34a3bf00af2cede839879502e12dc68491ad5 is the first bad commit
-commit a1c34a3bf00af2cede839879502e12dc68491ad5
-Author: Laura Abbott <laura@labbott.name>
-Date:   Thu Nov 5 18:48:46 2015 -0800
-
-    mm: Don't offset memmap for flatmem
-
-    Srinivas Kandagatla reported bad page messages when trying to remove the
-    bottom 2MB on an ARM based IFC6410 board
-
-      BUG: Bad page state in process swapper  pfn:fffa8
-      page:ef7fb500 count:0 mapcount:0 mapping:  (null) index:0x0
-      flags: 0x96640253(locked|error|dirty|active|arch_1|reclaim|mlocked)
-      page dumped because: PAGE_FLAGS_CHECK_AT_FREE flag(s) set
-      bad because of flags:
-      flags: 0x200041(locked|active|mlocked)
-      Modules linked in:
-      CPU: 0 PID: 0 Comm: swapper Not tainted 3.19.0-rc3-00007-g412f9ba-dirty
-#816
-      Hardware name: Qualcomm (Flattened Device Tree)
-        unwind_backtrace
-        show_stack
-        dump_stack
-        bad_page
-        free_pages_prepare
-        free_hot_cold_page
-        __free_pages
-        free_highmem_page
-        mem_init
-        start_kernel
-      Disabling lock debugging due to kernel taint
-    [...]
-:040000 040000 2de013c372345fd471cd58f0553c9b38b0ef1cc4
-0a8156f848733dfa21e16c196dfb6c0a76290709 M      mm
-
-This fix for ARM does not account ARCH_PFN_OFFSET for mem_map as later used by
-page_to_pfn anymore.
-
-The following output was generated with two hacked in printk statements:
-
-printk("before %p vs. %p or %p\n", mem_map, mem_map - offset, mem_map -
-(pgdat->node_start_pfn - ARCH_PFN_OFFSET));
-		if (page_to_pfn(mem_map) != pgdat->node_start_pfn)
-			mem_map -= offset + (pgdat->node_start_pfn - ARCH_PFN_OFFSET);
-printk("after %p\n", mem_map);
-
-Output:
-
-[    0.000000] before 8861b280 vs. 8861b280 or 8851b280
-[    0.000000] after 8851b280
-
-As seen in the first line mem_map with subtraction of offset does not equal the
-mem_map after subtraction of ARCH_PFN_OFFSET.
-
-After adding the offset of ARCH_PFN_OFFSET as well to mem_map as the
-previously calculated offset is zero for the named platform it is able to boot
-4.4 and 4.9-rc7 again.
-
-Signed-off-by: Tobias Wolf <dev-NTEO@vplace.de>
----
-
---- a/mm/page_alloc.c
-+++ b/mm/page_alloc.c
-@@ -5923,7 +5923,7 @@ static void __ref alloc_node_mem_map(str
- 		mem_map = NODE_DATA(0)->node_mem_map;
- #if defined(CONFIG_HAVE_MEMBLOCK_NODE_MAP) || defined(CONFIG_FLATMEM)
- 		if (page_to_pfn(mem_map) != pgdat->node_start_pfn)
--			mem_map -= offset;
-+			mem_map -= offset + (pgdat->node_start_pfn - ARCH_PFN_OFFSET);
- #endif /* CONFIG_HAVE_MEMBLOCK_NODE_MAP */
- 	}
- #endif
--- a/target/linux/generic/pending-4.9/130-add-linux-spidev-compatible-si3210.patch	2022-03-22 08:54:47.421465026 +0800
+++ b/target/linux/generic/pending-4.9/130-add-linux-spidev-compatible-si3210.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,18 +0,0 @@
-From: Giuseppe Lippolis <giu.lippolis@gmail.com>
-Subject: Add the linux,spidev compatible in spidev Several device in ramips have this binding in the dts
-
-Signed-off-by: Giuseppe Lippolis <giu.lippolis@gmail.com>
----
- drivers/spi/spidev.c | 1 +
- 1 file changed, 1 insertion(+)
-
---- a/drivers/spi/spidev.c
-+++ b/drivers/spi/spidev.c
-@@ -696,6 +696,7 @@ static struct class *spidev_class;
- static const struct of_device_id spidev_dt_ids[] = {
- 	{ .compatible = "rohm,dh2228fv" },
- 	{ .compatible = "lineartechnology,ltc2488" },
-+	{ .compatible = "siliconlabs,si3210" },
- 	{},
- };
- MODULE_DEVICE_TABLE(of, spidev_dt_ids);
--- a/target/linux/generic/pending-4.9/131-spi-use-gpio_set_value_cansleep-for-setting-chipsele.patch	2022-03-22 08:54:47.421465026 +0800
+++ b/target/linux/generic/pending-4.9/131-spi-use-gpio_set_value_cansleep-for-setting-chipsele.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,20 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: spi: use gpio_set_value_cansleep for setting chipselect GPIO
-
-Sleeping is safe inside spi_transfer_one_message, and some GPIO chips
-need to sleep for setting values
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/drivers/spi/spi.c
-+++ b/drivers/spi/spi.c
-@@ -700,7 +700,7 @@ static void spi_set_cs(struct spi_device
- 		enable = !enable;
- 
- 	if (gpio_is_valid(spi->cs_gpio))
--		gpio_set_value(spi->cs_gpio, !enable);
-+		gpio_set_value_cansleep(spi->cs_gpio, !enable);
- 	else if (spi->master->set_cs)
- 		spi->master->set_cs(spi, !enable);
- }
--- a/target/linux/generic/pending-4.9/140-jffs2-use-.rename2-and-add-RENAME_WHITEOUT-support.patch	2022-03-22 08:54:47.421465026 +0800
+++ b/target/linux/generic/pending-4.9/140-jffs2-use-.rename2-and-add-RENAME_WHITEOUT-support.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,62 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: jffs2: use .rename2 and add RENAME_WHITEOUT support
-
-It is required for renames on overlayfs
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/fs/jffs2/dir.c
-+++ b/fs/jffs2/dir.c
-@@ -752,6 +752,24 @@ static int jffs2_mknod (struct inode *di
- 	return ret;
- }
- 
-+static int jffs2_whiteout (struct inode *old_dir, struct dentry *old_dentry)
-+{
-+	struct dentry *wh;
-+	int err;
-+
-+	wh = d_alloc(old_dentry->d_parent, &old_dentry->d_name);
-+	if (!wh)
-+		return -ENOMEM;
-+
-+	err = jffs2_mknod(old_dir, wh, S_IFCHR | WHITEOUT_MODE,
-+			  WHITEOUT_DEV);
-+	if (err)
-+		return err;
-+
-+	d_rehash(wh);
-+	return 0;
-+}
-+
- static int jffs2_rename (struct inode *old_dir_i, struct dentry *old_dentry,
- 			 struct inode *new_dir_i, struct dentry *new_dentry,
- 			 unsigned int flags)
-@@ -762,7 +780,7 @@ static int jffs2_rename (struct inode *o
- 	uint8_t type;
- 	uint32_t now;
- 
--	if (flags & ~RENAME_NOREPLACE)
-+	if (flags & ~(RENAME_NOREPLACE|RENAME_WHITEOUT))
- 		return -EINVAL;
- 
- 	/* The VFS will check for us and prevent trying to rename a
-@@ -828,9 +846,14 @@ static int jffs2_rename (struct inode *o
- 	if (d_is_dir(old_dentry) && !victim_f)
- 		inc_nlink(new_dir_i);
- 
--	/* Unlink the original */
--	ret = jffs2_do_unlink(c, JFFS2_INODE_INFO(old_dir_i),
--			      old_dentry->d_name.name, old_dentry->d_name.len, NULL, now);
-+	if (flags & RENAME_WHITEOUT)
-+		/* Replace with whiteout */
-+		ret = jffs2_whiteout(old_dir_i, old_dentry);
-+	else
-+		/* Unlink the original */
-+		ret = jffs2_do_unlink(c, JFFS2_INODE_INFO(old_dir_i),
-+				      old_dentry->d_name.name,
-+				      old_dentry->d_name.len, NULL, now);
- 
- 	/* We don't touch inode->i_nlink */
- 
--- a/target/linux/generic/pending-4.9/141-jffs2-add-RENAME_EXCHANGE-support.patch	2022-03-22 08:54:47.422465028 +0800
+++ b/target/linux/generic/pending-4.9/141-jffs2-add-RENAME_EXCHANGE-support.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,73 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: jffs2: add RENAME_EXCHANGE support
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/fs/jffs2/dir.c
-+++ b/fs/jffs2/dir.c
-@@ -777,18 +777,31 @@ static int jffs2_rename (struct inode *o
- 	int ret;
- 	struct jffs2_sb_info *c = JFFS2_SB_INFO(old_dir_i->i_sb);
- 	struct jffs2_inode_info *victim_f = NULL;
-+	struct inode *fst_inode = d_inode(old_dentry);
-+	struct inode *snd_inode = d_inode(new_dentry);
- 	uint8_t type;
- 	uint32_t now;
- 
--	if (flags & ~(RENAME_NOREPLACE|RENAME_WHITEOUT))
-+	if (flags & ~(RENAME_NOREPLACE|RENAME_WHITEOUT|RENAME_EXCHANGE))
- 		return -EINVAL;
- 
-+	if ((flags & RENAME_EXCHANGE) && (old_dir_i != new_dir_i)) {
-+		if (S_ISDIR(fst_inode->i_mode) && !S_ISDIR(snd_inode->i_mode)) {
-+			inc_nlink(new_dir_i);
-+			drop_nlink(old_dir_i);
-+		}
-+		else if (!S_ISDIR(fst_inode->i_mode) && S_ISDIR(snd_inode->i_mode)) {
-+			drop_nlink(new_dir_i);
-+			inc_nlink(old_dir_i);
-+		}
-+	}
-+
- 	/* The VFS will check for us and prevent trying to rename a
- 	 * file over a directory and vice versa, but if it's a directory,
- 	 * the VFS can't check whether the victim is empty. The filesystem
- 	 * needs to do that for itself.
- 	 */
--	if (d_really_is_positive(new_dentry)) {
-+	if (d_really_is_positive(new_dentry) && !(flags & RENAME_EXCHANGE)) {
- 		victim_f = JFFS2_INODE_INFO(d_inode(new_dentry));
- 		if (d_is_dir(new_dentry)) {
- 			struct jffs2_full_dirent *fd;
-@@ -823,7 +836,7 @@ static int jffs2_rename (struct inode *o
- 	if (ret)
- 		return ret;
- 
--	if (victim_f) {
-+	if (victim_f && !(flags & RENAME_EXCHANGE)) {
- 		/* There was a victim. Kill it off nicely */
- 		if (d_is_dir(new_dentry))
- 			clear_nlink(d_inode(new_dentry));
-@@ -849,6 +862,12 @@ static int jffs2_rename (struct inode *o
- 	if (flags & RENAME_WHITEOUT)
- 		/* Replace with whiteout */
- 		ret = jffs2_whiteout(old_dir_i, old_dentry);
-+	else if (flags & RENAME_EXCHANGE)
-+		/* Replace the original */
-+		ret = jffs2_do_link(c, JFFS2_INODE_INFO(old_dir_i),
-+				    d_inode(new_dentry)->i_ino, type,
-+				    old_dentry->d_name.name, old_dentry->d_name.len,
-+				    now);
- 	else
- 		/* Unlink the original */
- 		ret = jffs2_do_unlink(c, JFFS2_INODE_INFO(old_dir_i),
-@@ -880,7 +899,7 @@ static int jffs2_rename (struct inode *o
- 		return ret;
- 	}
- 
--	if (d_is_dir(old_dentry))
-+	if (d_is_dir(old_dentry) && !(flags & RENAME_EXCHANGE))
- 		drop_nlink(old_dir_i);
- 
- 	new_dir_i->i_mtime = new_dir_i->i_ctime = old_dir_i->i_mtime = old_dir_i->i_ctime = ITIME(now);
--- a/target/linux/generic/pending-4.9/150-bridge_allow_receiption_on_disabled_port.patch	2022-03-22 08:54:47.422465028 +0800
+++ b/target/linux/generic/pending-4.9/150-bridge_allow_receiption_on_disabled_port.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,47 +0,0 @@
-From: Stephen Hemminger <stephen@networkplumber.org>
-Subject: bridge: allow receiption on disabled port
-
-When an ethernet device is enslaved to a bridge, and the bridge STP
-detects loss of carrier (or operational state down), then normally
-packet receiption is blocked.
-
-This breaks control applications like WPA which maybe expecting to
-receive packets to negotiate to bring link up. The bridge needs to
-block forwarding packets from these disabled ports, but there is no
-hard requirement to not allow local packet delivery.
-
-Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
-
---- a/net/bridge/br_input.c
-+++ b/net/bridge/br_input.c
-@@ -231,7 +231,10 @@ static void __br_handle_local_finish(str
- /* note: already called with rcu_read_lock */
- static int br_handle_local_finish(struct net *net, struct sock *sk, struct sk_buff *skb)
- {
--	__br_handle_local_finish(skb);
-+	struct net_bridge_port *p = br_port_get_rcu(skb->dev);
-+
-+	if (p->state != BR_STATE_DISABLED)
-+		__br_handle_local_finish(skb);
- 
- 	/* return 1 to signal the okfn() was called so it's ok to use the skb */
- 	return 1;
-@@ -321,6 +324,17 @@ rx_handler_result_t br_handle_frame(stru
- 
- forward:
- 	switch (p->state) {
-+	case BR_STATE_DISABLED:
-+		if (ether_addr_equal(p->br->dev->dev_addr, dest))
-+			skb->pkt_type = PACKET_HOST;
-+
-+		if (NF_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING,
-+			dev_net(skb->dev), NULL, skb, skb->dev, NULL,
-+			br_handle_local_finish) == 1) {
-+			return RX_HANDLER_PASS;
-+		}
-+		break;
-+
- 	case BR_STATE_FORWARDING:
- 		rhook = rcu_dereference(br_should_route_hook);
- 		if (rhook) {
--- a/target/linux/generic/pending-4.9/161-mtd-part-add-generic-parsing-of-linux-part-probe.patch	2022-03-22 08:54:47.422465028 +0800
+++ b/target/linux/generic/pending-4.9/161-mtd-part-add-generic-parsing-of-linux-part-probe.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,181 +0,0 @@
-From: Hauke Mehrtens <hauke@hauke-m.de>
-Subject: mtd: part: add generic parsing of linux,part-probe
-
-This moves the linux,part-probe device tree parsing code from
-physmap_of.c to mtdpart.c. Now all drivers can use this feature by just
-providing a reference to their device tree node in struct
-mtd_part_parser_data.
-
-Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
----
- Documentation/devicetree/bindings/mtd/nand.txt | 16 +++++++++
- drivers/mtd/maps/physmap_of.c                  | 46 +-------------------------
- drivers/mtd/mtdpart.c                          | 45 +++++++++++++++++++++++++
- 3 files changed, 62 insertions(+), 45 deletions(-)
-
---- a/Documentation/devicetree/bindings/mtd/nand.txt
-+++ b/Documentation/devicetree/bindings/mtd/nand.txt
-@@ -44,6 +44,22 @@ Optional NAND chip properties:
- 		     used by the upper layers, and you want to make your NAND
- 		     as reliable as possible.
- 
-+- linux,part-probe: list of name as strings of the partition parser
-+		    which should be used to parse the partition table.
-+		    They will be tried in the specified ordering and
-+		    the next one will be used if the previous one
-+		    failed.
-+
-+		    Example: linux,part-probe = "cmdlinepart", "ofpart";
-+
-+		    This is also the default value, which will be used
-+		    if this attribute is not specified. It could be
-+		    that the flash driver in use overwrote the default
-+		    value and uses some other default.
-+
-+		    Possible values are: bcm47xxpart, afs, ar7part,
-+		    ofoldpart, ofpart, bcm63xxpart, RedBoot, cmdlinepart
-+
- The ECC strength and ECC step size properties define the correction capability
- of a controller. Together, they say a controller can correct "{strength} bit
- errors per {size} bytes".
---- a/drivers/mtd/maps/physmap_of.c
-+++ b/drivers/mtd/maps/physmap_of.c
-@@ -104,47 +104,9 @@ static struct mtd_info *obsolete_probe(s
- static const char * const part_probe_types_def[] = {
- 	"cmdlinepart", "RedBoot", "ofpart", "ofoldpart", NULL };
- 
--static const char * const *of_get_probes(struct device_node *dp)
--{
--	const char *cp;
--	int cplen;
--	unsigned int l;
--	unsigned int count;
--	const char **res;
--
--	cp = of_get_property(dp, "linux,part-probe", &cplen);
--	if (cp == NULL)
--		return part_probe_types_def;
--
--	count = 0;
--	for (l = 0; l != cplen; l++)
--		if (cp[l] == 0)
--			count++;
--
--	res = kzalloc((count + 1)*sizeof(*res), GFP_KERNEL);
--	if (!res)
--		return NULL;
--	count = 0;
--	while (cplen > 0) {
--		res[count] = cp;
--		l = strlen(cp) + 1;
--		cp += l;
--		cplen -= l;
--		count++;
--	}
--	return res;
--}
--
--static void of_free_probes(const char * const *probes)
--{
--	if (probes != part_probe_types_def)
--		kfree(probes);
--}
--
- static const struct of_device_id of_flash_match[];
- static int of_flash_probe(struct platform_device *dev)
- {
--	const char * const *part_probe_types;
- 	const struct of_device_id *match;
- 	struct device_node *dp = dev->dev.of_node;
- 	struct resource res;
-@@ -300,14 +262,8 @@ static int of_flash_probe(struct platfor
- 
- 	info->cmtd->dev.parent = &dev->dev;
- 	mtd_set_of_node(info->cmtd, dp);
--	part_probe_types = of_get_probes(dp);
--	if (!part_probe_types) {
--		err = -ENOMEM;
--		goto err_out;
--	}
--	mtd_device_parse_register(info->cmtd, part_probe_types, NULL,
-+	mtd_device_parse_register(info->cmtd, part_probe_types_def, NULL,
- 			NULL, 0);
--	of_free_probes(part_probe_types);
- 
- 	kfree(mtd_list);
- 
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -29,6 +29,7 @@
- #include <linux/kmod.h>
- #include <linux/mtd/mtd.h>
- #include <linux/mtd/partitions.h>
-+#include <linux/of.h>
- #include <linux/err.h>
- #include <linux/of.h>
- 
-@@ -852,6 +853,42 @@ void deregister_mtd_parser(struct mtd_pa
- EXPORT_SYMBOL_GPL(deregister_mtd_parser);
- 
- /*
-+ * Parses the linux,part-probe device tree property.
-+ * When a non null value is returned it has to be freed with kfree() by
-+ * the caller.
-+ */
-+static const char * const *of_get_probes(struct device_node *dp)
-+{
-+	const char *cp;
-+	int cplen;
-+	unsigned int l;
-+	unsigned int count;
-+	const char **res;
-+
-+	cp = of_get_property(dp, "linux,part-probe", &cplen);
-+	if (cp == NULL)
-+		return NULL;
-+
-+	count = 0;
-+	for (l = 0; l != cplen; l++)
-+		if (cp[l] == 0)
-+			count++;
-+
-+	res = kzalloc((count + 1) * sizeof(*res), GFP_KERNEL);
-+	if (!res)
-+		return NULL;
-+	count = 0;
-+	while (cplen > 0) {
-+		res[count] = cp;
-+		l = strlen(cp) + 1;
-+		cp += l;
-+		cplen -= l;
-+		count++;
-+	}
-+	return res;
-+}
-+
-+/*
-  * Do not forget to update 'parse_mtd_partitions()' kerneldoc comment if you
-  * are changing this array!
-  */
-@@ -1000,6 +1037,13 @@ int parse_mtd_partitions(struct mtd_info
- 	struct mtd_partitions pparts = { };
- 	struct mtd_part_parser *parser;
- 	int ret, err = 0;
-+	const char *const *types_of = NULL;
-+
-+	if (mtd_get_of_node(master)) {
-+		types_of = of_get_probes(mtd_get_of_node(master));
-+		if (types_of != NULL)
-+			types = types_of;
-+	}
- 
- 	if (!types)
- 		types = mtd_is_partition(master) ? default_subpartition_types :
-@@ -1041,6 +1085,7 @@ int parse_mtd_partitions(struct mtd_info
- 		if (ret < 0 && !err)
- 			err = ret;
- 	}
-+	kfree(types_of);
- 	return err;
- }
- 
--- a/target/linux/generic/pending-4.9/170-MIPS-PCI-add-controllers-before-the-specified-head.patch	2022-03-22 08:54:47.423465029 +0800
+++ b/target/linux/generic/pending-4.9/170-MIPS-PCI-add-controllers-before-the-specified-head.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,30 +0,0 @@
-From: Mathias Kresin <dev@kresin.me>
-Subject: MIPS: PCI: add controllers before the specified head
-
-With commit 23dac14d058f ("MIPS: PCI: Use struct list_head lists") new
-controllers are added after the specified head where they were added
-before the specified head previously.
-
-Use list_add_tail to restore the former order.
-
-This patches fixes the following PCI error on lantiq:
-
-  pci 0000:01:00.0: BAR 0: error updating (0x1c000004 != 0x000000)
-
-Fixes: 23dac14d058f ("MIPS: PCI: Use struct list_head lists")
-Signed-off-by: Mathias Kresin <dev@kresin.me>
----
- arch/mips/pci/pci-legacy.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/arch/mips/pci/pci-legacy.c
-+++ b/arch/mips/pci/pci-legacy.c
-@@ -194,7 +194,7 @@ void register_pci_controller(struct pci_
- 	}
- 
- 	INIT_LIST_HEAD(&hose->list);
--	list_add(&hose->list, &controllers);
-+	list_add_tail(&hose->list, &controllers);
- 
- 	/*
- 	 * Do not panic here but later - this might happen before console init.
--- a/target/linux/generic/pending-4.9/180-net-phy-at803x-add-support-for-AT8032.patch	2022-03-22 08:54:47.423465029 +0800
+++ b/target/linux/generic/pending-4.9/180-net-phy-at803x-add-support-for-AT8032.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,70 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: net: phy: at803x: add support for AT8032
-
-Like AT8030, this PHY needs the GPIO reset workaround
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/drivers/net/phy/at803x.c
-+++ b/drivers/net/phy/at803x.c
-@@ -62,6 +62,7 @@
- 
- #define ATH8030_PHY_ID 0x004dd076
- #define ATH8031_PHY_ID 0x004dd074
-+#define ATH8032_PHY_ID 0x004dd023
- #define ATH8035_PHY_ID 0x004dd072
- 
- MODULE_DESCRIPTION("Atheros 803x PHY driver");
-@@ -259,7 +260,8 @@ static int at803x_probe(struct phy_devic
- 	if (!priv)
- 		return -ENOMEM;
- 
--	if (phydev->drv->phy_id != ATH8030_PHY_ID)
-+	if (phydev->drv->phy_id != ATH8030_PHY_ID &&
-+	    phydev->drv->phy_id != ATH8032_PHY_ID)
- 		goto does_not_require_reset_workaround;
- 
- 	gpiod_reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
-@@ -335,7 +337,7 @@ static void at803x_link_change_notify(st
- 	struct at803x_priv *priv = phydev->priv;
- 
- 	/*
--	 * Conduct a hardware reset for AT8030 every time a link loss is
-+	 * Conduct a hardware reset for AT8030/2 every time a link loss is
- 	 * signalled. This is necessary to circumvent a hardware bug that
- 	 * occurs when the cable is unplugged while TX packets are pending
- 	 * in the FIFO. In such cases, the FIFO enters an error mode it
-@@ -447,6 +449,24 @@ static struct phy_driver at803x_driver[]
- 	.aneg_done		= at803x_aneg_done,
- 	.ack_interrupt		= &at803x_ack_interrupt,
- 	.config_intr		= &at803x_config_intr,
-+}, {
-+	/* ATHEROS 8032 */
-+	.phy_id			= ATH8032_PHY_ID,
-+	.name			= "Atheros 8032 ethernet",
-+	.phy_id_mask		= 0xffffffef,
-+	.probe			= at803x_probe,
-+	.config_init		= at803x_config_init,
-+	.link_change_notify	= at803x_link_change_notify,
-+	.set_wol		= at803x_set_wol,
-+	.get_wol		= at803x_get_wol,
-+	.suspend		= at803x_suspend,
-+	.resume			= at803x_resume,
-+	.features		= PHY_BASIC_FEATURES,
-+	.flags			= PHY_HAS_INTERRUPT,
-+	.config_aneg		= genphy_config_aneg,
-+	.read_status		= genphy_read_status,
-+	.ack_interrupt		= at803x_ack_interrupt,
-+	.config_intr		= at803x_config_intr,
- } };
- 
- module_phy_driver(at803x_driver);
-@@ -454,6 +474,7 @@ module_phy_driver(at803x_driver);
- static struct mdio_device_id __maybe_unused atheros_tbl[] = {
- 	{ ATH8030_PHY_ID, 0xffffffef },
- 	{ ATH8031_PHY_ID, 0xffffffef },
-+	{ ATH8032_PHY_ID, 0xffffffef },
- 	{ ATH8035_PHY_ID, 0xffffffef },
- 	{ }
- };
--- a/target/linux/generic/pending-4.9/190-2-5-e1000e-Fix-wrong-comment-related-to-link-detection.patch	2022-03-22 08:54:47.423465029 +0800
+++ b/target/linux/generic/pending-4.9/190-2-5-e1000e-Fix-wrong-comment-related-to-link-detection.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,43 +0,0 @@
-From patchwork Fri Jul 21 18:36:24 2017
-Content-Type: text/plain; charset="utf-8"
-MIME-Version: 1.0
-Content-Transfer-Encoding: 7bit
-Subject: [2/5] e1000e: Fix wrong comment related to link detection
-From: Benjamin Poirier <bpoirier@suse.com>
-X-Patchwork-Id: 9857489
-Message-Id: <20170721183627.13373-2-bpoirier@suse.com>
-To: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
-Cc: Lennart Sorensen <lsorense@csclub.uwaterloo.ca>,
- intel-wired-lan@lists.osuosl.org, netdev@vger.kernel.org,
- linux-kernel@vger.kernel.org
-Date: Fri, 21 Jul 2017 11:36:24 -0700
-
-Reading e1000e_check_for_copper_link() shows that get_link_status is set to
-false after link has been detected. Therefore, it stays TRUE until then.
-
-Signed-off-by: Benjamin Poirier <bpoirier@suse.com>
-Tested-by: Aaron Brown <aaron.f.brown@intel.com>
----
- drivers/net/ethernet/intel/e1000e/netdev.c | 4 ++--
- 1 file changed, 2 insertions(+), 2 deletions(-)
-
---- a/drivers/net/ethernet/intel/e1000e/netdev.c
-+++ b/drivers/net/ethernet/intel/e1000e/netdev.c
-@@ -5067,7 +5067,7 @@ static bool e1000e_has_link(struct e1000
- 
- 	/* get_link_status is set on LSC (link status) interrupt or
- 	 * Rx sequence error interrupt.  get_link_status will stay
--	 * false until the check_for_link establishes link
-+	 * true until the check_for_link establishes link
- 	 * for copper adapters ONLY
- 	 */
- 	switch (hw->phy.media_type) {
-@@ -5085,7 +5085,7 @@ static bool e1000e_has_link(struct e1000
- 		break;
- 	case e1000_media_type_internal_serdes:
- 		ret_val = hw->mac.ops.check_for_link(hw);
--		link_active = adapter->hw.mac.serdes_has_link;
-+		link_active = hw->mac.serdes_has_link;
- 		break;
- 	default:
- 	case e1000_media_type_unknown:
--- a/target/linux/generic/pending-4.9/201-extra_optimization.patch	2022-03-22 08:54:47.423465029 +0800
+++ b/target/linux/generic/pending-4.9/201-extra_optimization.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,32 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: Upgrade to Linux 2.6.19
-
-- Includes large parts of the patch from #1021 by dpalffy
-- Includes RB532 NAND driver changes by n0-1
-
-[john@phrozen.org: feix will add this to his upstream queue]
-
-lede-commit: bff468813f78f81e36ebb2a3f4354de7365e640f
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- Makefile | 6 +++---
- 1 file changed, 3 insertions(+), 3 deletions(-)
-
---- a/Makefile
-+++ b/Makefile
-@@ -658,12 +658,12 @@ KBUILD_CFLAGS	+= $(call cc-option,-fdata
- endif
- 
- ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
--KBUILD_CFLAGS	+= -Os $(call cc-disable-warning,maybe-uninitialized,)
-+KBUILD_CFLAGS	+= -Os $(call cc-disable-warning,maybe-uninitialized,) $(EXTRA_OPTIMIZATION)
- else
- ifdef CONFIG_PROFILE_ALL_BRANCHES
--KBUILD_CFLAGS	+= -O2 $(call cc-disable-warning,maybe-uninitialized,)
-+KBUILD_CFLAGS	+= -O2 $(call cc-disable-warning,maybe-uninitialized,) $(EXTRA_OPTIMIZATION)
- else
--KBUILD_CFLAGS   += -O2
-+KBUILD_CFLAGS   += -O2 -fno-reorder-blocks -fno-tree-ch $(EXTRA_OPTIMIZATION)
- endif
- endif
- 
--- a/target/linux/generic/pending-4.9/203-kallsyms_uncompressed.patch	2022-03-22 08:54:47.424465031 +0800
+++ b/target/linux/generic/pending-4.9/203-kallsyms_uncompressed.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,119 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: kernel: add a config option for keeping the kallsyms table uncompressed, saving ~9kb kernel size after lzma on ar71xx
-
-[john@phrozen.org: added to my upstream queue 30.12.2016]
-lede-commit: e0e3509b5ce2ccf93d4d67ea907613f5f7ec2eed
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- init/Kconfig            | 11 +++++++++++
- kernel/kallsyms.c       |  8 ++++++++
- scripts/kallsyms.c      | 12 ++++++++++++
- scripts/link-vmlinux.sh |  4 ++++
- 4 files changed, 35 insertions(+)
-
---- a/init/Kconfig
-+++ b/init/Kconfig
-@@ -1370,6 +1370,17 @@ config SYSCTL_ARCH_UNALIGN_ALLOW
- 	  the unaligned access emulation.
- 	  see arch/parisc/kernel/unaligned.c for reference
- 
-+config KALLSYMS_UNCOMPRESSED
-+	bool "Keep kallsyms uncompressed"
-+	depends on KALLSYMS
-+	help
-+		Normally kallsyms contains compressed symbols (using a token table),
-+		reducing the uncompressed kernel image size. Keeping the symbol table
-+		uncompressed significantly improves the size of this part in compressed
-+		kernel images.
-+
-+		Say N unless you need compressed kernel images to be small.
-+
- config HAVE_PCSPKR_PLATFORM
- 	bool
- 
---- a/kernel/kallsyms.c
-+++ b/kernel/kallsyms.c
-@@ -113,6 +113,11 @@ static unsigned int kallsyms_expand_symb
- 	 * For every byte on the compressed symbol data, copy the table
- 	 * entry for that byte.
- 	 */
-+#ifdef CONFIG_KALLSYMS_UNCOMPRESSED
-+	memcpy(result, data + 1, len - 1);
-+	result += len - 1;
-+	len = 0;
-+#endif
- 	while (len) {
- 		tptr = &kallsyms_token_table[kallsyms_token_index[*data]];
- 		data++;
-@@ -145,6 +150,9 @@ tail:
-  */
- static char kallsyms_get_symbol_type(unsigned int off)
- {
-+#ifdef CONFIG_KALLSYMS_UNCOMPRESSED
-+	return kallsyms_names[off + 1];
-+#endif
- 	/*
- 	 * Get just the first code, look it up in the token table,
- 	 * and return the first char from this token.
---- a/scripts/kallsyms.c
-+++ b/scripts/kallsyms.c
-@@ -61,6 +61,7 @@ static struct addr_range percpu_range =
- static struct sym_entry *table;
- static unsigned int table_size, table_cnt;
- static int all_symbols = 0;
-+static int uncompressed = 0;
- static int absolute_percpu = 0;
- static char symbol_prefix_char = '\0';
- static int base_relative = 0;
-@@ -449,6 +450,9 @@ static void write_src(void)
- 
- 	free(markers);
- 
-+	if (uncompressed)
-+		return;
-+
- 	output_label("kallsyms_token_table");
- 	off = 0;
- 	for (i = 0; i < 256; i++) {
-@@ -507,6 +511,9 @@ static void *find_token(unsigned char *s
- {
- 	int i;
- 
-+	if (uncompressed)
-+		return NULL;
-+
- 	for (i = 0; i < len - 1; i++) {
- 		if (str[i] == token[0] && str[i+1] == token[1])
- 			return &str[i];
-@@ -579,6 +586,9 @@ static void optimize_result(void)
- {
- 	int i, best;
- 
-+	if (uncompressed)
-+		return;
-+
- 	/* using the '\0' symbol last allows compress_symbols to use standard
- 	 * fast string functions */
- 	for (i = 255; i >= 0; i--) {
-@@ -767,6 +777,8 @@ int main(int argc, char **argv)
- 				symbol_prefix_char = *p;
- 			} else if (strcmp(argv[i], "--base-relative") == 0)
- 				base_relative = 1;
-+			else if (strcmp(argv[i], "--uncompressed") == 0)
-+				uncompressed = 1;
- 			else
- 				usage();
- 		}
---- a/scripts/link-vmlinux.sh
-+++ b/scripts/link-vmlinux.sh
-@@ -136,6 +136,10 @@ kallsyms()
- 		kallsymopt="${kallsymopt} --base-relative"
- 	fi
- 
-+	if [ -n "${CONFIG_KALLSYMS_UNCOMPRESSED}" ]; then
-+		kallsymopt="${kallsymopt} --uncompressed"
-+	fi
-+
- 	local aflags="${KBUILD_AFLAGS} ${KBUILD_AFLAGS_KERNEL}               \
- 		      ${NOSTDINC_FLAGS} ${LINUXINCLUDE} ${KBUILD_CPPFLAGS}"
- 
--- a/target/linux/generic/pending-4.9/205-backtrace_module_info.patch	2022-03-22 08:54:47.424465031 +0800
+++ b/target/linux/generic/pending-4.9/205-backtrace_module_info.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,45 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: kernel: when KALLSYMS is disabled, print module address + size for matching backtrace entries
-
-[john@phrozen.org: felix will add this to his upstream queue]
-
-lede-commit 53827cdc824556cda910b23ce5030c363b8f1461
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- lib/vsprintf.c | 15 +++++++++++----
- 1 file changed, 11 insertions(+), 4 deletions(-)
-
---- a/lib/vsprintf.c
-+++ b/lib/vsprintf.c
-@@ -669,8 +669,10 @@ char *symbol_string(char *buf, char *end
- 		    struct printf_spec spec, const char *fmt)
- {
- 	unsigned long value;
--#ifdef CONFIG_KALLSYMS
- 	char sym[KSYM_SYMBOL_LEN];
-+#ifndef CONFIG_KALLSYMS
-+	struct module *mod;
-+	int len;
- #endif
- 
- 	if (fmt[1] == 'R')
-@@ -684,11 +686,16 @@ char *symbol_string(char *buf, char *end
- 		sprint_symbol(sym, value);
- 	else
- 		sprint_symbol_no_offset(sym, value);
--
--	return string(buf, end, sym, spec);
- #else
--	return special_hex_number(buf, end, value, sizeof(void *));
-+	len = snprintf(sym, sizeof(sym), "0x%lx", value);
-+
-+	mod = __module_address(value);
-+	if (mod)
-+		snprintf(sym + len, sizeof(sym) - len, " [%s@%p+0x%x]",
-+			 mod->name, mod->core_layout.base,
-+			 mod->core_layout.size);
- #endif
-+	return string(buf, end, sym, spec);
- }
- 
- static noinline_for_stack
--- a/target/linux/generic/pending-4.9/220-optimize_inlining.patch	2022-03-22 08:54:47.424465031 +0800
+++ b/target/linux/generic/pending-4.9/220-optimize_inlining.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,70 +0,0 @@
---- a/arch/x86/Kconfig.debug
-+++ b/arch/x86/Kconfig.debug
-@@ -287,20 +287,6 @@ config CPA_DEBUG
- 	---help---
- 	  Do change_page_attr() self-tests every 30 seconds.
- 
--config OPTIMIZE_INLINING
--	bool "Allow gcc to uninline functions marked 'inline'"
--	---help---
--	  This option determines if the kernel forces gcc to inline the functions
--	  developers have marked 'inline'. Doing so takes away freedom from gcc to
--	  do what it thinks is best, which is desirable for the gcc 3.x series of
--	  compilers. The gcc 4.x series have a rewritten inlining algorithm and
--	  enabling this option will generate a smaller kernel there. Hopefully
--	  this algorithm is so good that allowing gcc 4.x and above to make the
--	  decision will become the default in the future. Until then this option
--	  is there to test gcc for this.
--
--	  If unsure, say N.
--
- config DEBUG_ENTRY
- 	bool "Debug low-level entry code"
- 	depends on DEBUG_KERNEL
---- a/lib/Kconfig.debug
-+++ b/lib/Kconfig.debug
-@@ -117,6 +117,20 @@ endmenu # "printk and dmesg options"
- 
- menu "Compile-time checks and compiler options"
- 
-+config OPTIMIZE_INLINING
-+	bool "Allow gcc to uninline functions marked 'inline'"
-+	---help---
-+	  This option determines if the kernel forces gcc to inline the functions
-+	  developers have marked 'inline'. Doing so takes away freedom from gcc to
-+	  do what it thinks is best, which is desirable for the gcc 3.x series of
-+	  compilers. The gcc 4.x series have a rewritten inlining algorithm and
-+	  enabling this option will generate a smaller kernel there. Hopefully
-+	  this algorithm is so good that allowing gcc 4.x and above to make the
-+	  decision will become the default in the future. Until then this option
-+	  is there to test gcc for this.
-+
-+	  If unsure, say N.
-+
- config DEBUG_INFO
- 	bool "Compile the kernel with debug info"
- 	depends on DEBUG_KERNEL && !COMPILE_TEST
---- a/arch/x86/Kconfig
-+++ b/arch/x86/Kconfig
-@@ -273,9 +273,6 @@ config ZONE_DMA32
- config AUDIT_ARCH
- 	def_bool y if X86_64
- 
--config ARCH_SUPPORTS_OPTIMIZED_INLINING
--	def_bool y
--
- config ARCH_SUPPORTS_DEBUG_PAGEALLOC
- 	def_bool y
- 
---- a/include/linux/compiler-gcc.h
-+++ b/include/linux/compiler-gcc.h
-@@ -89,8 +89,7 @@
-  * of extern inline functions at link time.
-  * A lot of inline functions can cause havoc with function tracing.
-  */
--#if !defined(CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING) ||		\
--    !defined(CONFIG_OPTIMIZE_INLINING) || (__GNUC__ < 4)
-+#if !defined(CONFIG_OPTIMIZE_INLINING) || (__GNUC__ < 4)
- #define inline \
- 	inline __attribute__((always_inline, unused)) notrace __gnu_inline
- #else
--- a/target/linux/generic/pending-4.9/240-remove-unsane-filenames-from-deps_initramfs-list.patch	2022-03-22 08:54:47.424465031 +0800
+++ b/target/linux/generic/pending-4.9/240-remove-unsane-filenames-from-deps_initramfs-list.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,47 +0,0 @@
-From: Gabor Juhos <juhosg@openwrt.org>
-Subject: usr: sanitize deps_initramfs list
-
-If any filename in the intramfs dependency
-list contains a colon, that causes a kernel
-build error like this:
-
-/devel/openwrt/build_dir/linux-ar71xx_generic/linux-3.6.6/usr/Makefile:58: *** multiple target patterns.  Stop.
-make[5]: *** [usr] Error 2
-
-Fix it by removing such filenames from the
-deps_initramfs list.
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- usr/Makefile | 8 +++++---
- 1 file changed, 5 insertions(+), 3 deletions(-)
-
---- a/usr/Makefile
-+++ b/usr/Makefile
-@@ -53,6 +53,8 @@ ifneq ($(wildcard $(obj)/.initramfs_data
- 	include $(obj)/.initramfs_data.cpio.d
- endif
- 
-+deps_initramfs_sane := $(foreach v,$(deps_initramfs),$(if $(findstring :,$(v)),,$(v)))
-+
- quiet_cmd_initfs = GEN     $@
-       cmd_initfs = $(initramfs) -o $@ $(ramfs-args) $(ramfs-input)
- 
-@@ -61,14 +63,14 @@ targets := initramfs_data.cpio.gz initra
- 	initramfs_data.cpio.lzo initramfs_data.cpio.lz4 \
- 	initramfs_data.cpio
- # do not try to update files included in initramfs
--$(deps_initramfs): ;
-+$(deps_initramfs_sane): ;
- 
--$(deps_initramfs): klibcdirs
-+$(deps_initramfs_sane): klibcdirs
- # We rebuild initramfs_data.cpio if:
- # 1) Any included file is newer then initramfs_data.cpio
- # 2) There are changes in which files are included (added or deleted)
- # 3) If gen_init_cpio are newer than initramfs_data.cpio
- # 4) arguments to gen_initramfs.sh changes
--$(obj)/initramfs_data.cpio$(suffix_y): $(obj)/gen_init_cpio $(deps_initramfs) klibcdirs
-+$(obj)/initramfs_data.cpio$(suffix_y): $(obj)/gen_init_cpio $(deps_initramfs_sane) klibcdirs
- 	$(Q)$(initramfs) -l $(ramfs-input) > $(obj)/.initramfs_data.cpio.d
- 	$(call if_changed,initfs)
--- a/target/linux/generic/pending-4.9/261-enable_wilink_platform_without_drivers.patch	2022-03-22 08:54:47.425465033 +0800
+++ b/target/linux/generic/pending-4.9/261-enable_wilink_platform_without_drivers.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,20 +0,0 @@
-From: Imre Kaloz <kaloz@openwrt.org>
-Subject: [PATCH] hack: net: wireless: make the wl12xx glue code available with
- compat-wireless, too
-
-Signed-off-by: Imre Kaloz <kaloz@openwrt.org>
----
- drivers/net/wireless/ti/Kconfig | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ti/Kconfig
-+++ b/drivers/net/wireless/ti/Kconfig
-@@ -19,7 +19,7 @@ source "drivers/net/wireless/ti/wlcore/K
- 
- config WILINK_PLATFORM_DATA
- 	bool "TI WiLink platform data"
--	depends on WLCORE_SDIO || WL1251_SDIO
-+	depends on WLCORE_SDIO || WL1251_SDIO || ARCH_OMAP2PLUS
- 	default y
- 	---help---
- 	Small platform data bit needed to pass data to the sdio modules.
--- a/target/linux/generic/pending-4.9/300-mips_expose_boot_raw.patch	2022-03-22 08:54:47.425465033 +0800
+++ b/target/linux/generic/pending-4.9/300-mips_expose_boot_raw.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,40 +0,0 @@
-From: Mark Miller <mark@mirell.org>
-Subject: mips: expose CONFIG_BOOT_RAW
-
-This exposes the CONFIG_BOOT_RAW symbol in Kconfig. This is needed on
-certain Broadcom chipsets running CFE in order to load the kernel.
-
-Signed-off-by: Mark Miller <mark@mirell.org>
-Acked-by: Rob Landley <rob@landley.net>
----
---- a/arch/mips/Kconfig
-+++ b/arch/mips/Kconfig
-@@ -1066,9 +1066,6 @@ config FW_ARC
- config ARCH_MAY_HAVE_PC_FDC
- 	bool
- 
--config BOOT_RAW
--	bool
--
- config CEVT_BCM1480
- 	bool
- 
-@@ -2965,6 +2962,18 @@ choice
- 		bool "Extend builtin kernel arguments with bootloader arguments"
- endchoice
- 
-+config BOOT_RAW
-+	bool "Enable the kernel to be executed from the load address"
-+	default n
-+	help
-+	 Allow the kernel to be executed from the load address for
-+	 bootloaders which cannot read the ELF format. This places
-+	 a jump to start_kernel at the load address.
-+
-+	 If unsure, say N.
-+
-+
-+
- endmenu
- 
- config LOCKDEP_SUPPORT
--- a/target/linux/generic/pending-4.9/302-mips_no_branch_likely.patch	2022-03-22 08:54:47.425465033 +0800
+++ b/target/linux/generic/pending-4.9/302-mips_no_branch_likely.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,22 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: mips: use -mno-branch-likely for kernel and userspace
-
-saves ~11k kernel size after lzma and ~12k squashfs size in the
-
-lede-commit: 41a039f46450ffae9483d6216422098669da2900
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- arch/mips/Makefile | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/arch/mips/Makefile
-+++ b/arch/mips/Makefile
-@@ -90,7 +90,7 @@ all-$(CONFIG_SYS_SUPPORTS_ZBOOT)+= vmlin
- # machines may also.  Since BFD is incredibly buggy with respect to
- # crossformat linking we rely on the elf2ecoff tool for format conversion.
- #
--cflags-y			+= -G 0 -mno-abicalls -fno-pic -pipe
-+cflags-y			+= -G 0 -mno-abicalls -fno-pic -pipe -mno-branch-likely
- cflags-y			+= -msoft-float
- LDFLAGS_vmlinux			+= -G 0 -static -n -nostdlib
- KBUILD_AFLAGS_MODULE		+= -mlong-calls
--- a/target/linux/generic/pending-4.9/304-mips_disable_fpu.patch	2022-03-22 08:54:47.425465033 +0800
+++ b/target/linux/generic/pending-4.9/304-mips_disable_fpu.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,137 +0,0 @@
-From:   Manuel Lauss <manuel.lauss@gmail.com>
-Subject: [RFC PATCH v4 2/2] MIPS: make FPU emulator optional
-
-This small patch makes the MIPS FPU emulator optional. The kernel
-kills float-users on systems without a hardware FPU by sending a SIGILL.
-
-Disabling the emulator shrinks vmlinux by about 54kBytes (32bit,
-optimizing for size).
-
-Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
----
-v4: rediffed because of patch 1/2, should now work with micromips as well
-v3: updated patch description with size savings.
-v2: incorporated changes suggested by Jonas Gorski
-    force the fpu emulator on for micromips: relocating the parts
-    of the mmips code in the emulator to other areas would be a
-    much larger change; I went the cheap route instead with this.
-
- arch/mips/Kbuild                     |  2 +-
- arch/mips/Kconfig                    | 14 ++++++++++++++
- arch/mips/include/asm/fpu.h          |  5 +++--
- arch/mips/include/asm/fpu_emulator.h | 15 +++++++++++++++
- 4 files changed, 33 insertions(+), 3 deletions(-)
-
---- a/arch/mips/Kconfig
-+++ b/arch/mips/Kconfig
-@@ -2889,6 +2889,20 @@ config MIPS_O32_FP64_SUPPORT
- 
- 	  If unsure, say N.
- 
-+config MIPS_FPU_EMULATOR
-+	bool "MIPS FPU Emulator"
-+	default y
-+	help
-+	  This option lets you disable the built-in MIPS FPU (Coprocessor 1)
-+	  emulator, which handles floating-point instructions on processors
-+	  without a hardware FPU.  It is generally a good idea to keep the
-+	  emulator built-in, unless you are perfectly sure you have a
-+	  complete soft-float environment.  With the emulator disabled, all
-+	  users of float operations will be killed with an illegal instr-
-+	  uction exception.
-+
-+	  Say Y, please.
-+
- config USE_OF
- 	bool
- 	select OF
---- a/arch/mips/Makefile
-+++ b/arch/mips/Makefile
-@@ -287,7 +287,7 @@ OBJCOPYFLAGS		+= --remove-section=.regin
- head-y := arch/mips/kernel/head.o
- 
- libs-y			+= arch/mips/lib/
--libs-y			+= arch/mips/math-emu/
-+libs-$(CONFIG_MIPS_FPU_EMULATOR)	+= arch/mips/math-emu/
- 
- # See arch/mips/Kbuild for content of core part of the kernel
- core-y += arch/mips/
---- a/arch/mips/include/asm/fpu.h
-+++ b/arch/mips/include/asm/fpu.h
-@@ -227,8 +227,10 @@ static inline int init_fpu(void)
- 		/* Restore FRE */
- 		write_c0_config5(config5);
- 		enable_fpu_hazard();
--	} else
-+	} else if (IS_ENABLED(CONFIG_MIPS_FPU_EMULATOR))
- 		fpu_emulator_init_fpu();
-+	else
-+		ret = SIGILL;
- 
- 	return ret;
- }
---- a/arch/mips/include/asm/fpu_emulator.h
-+++ b/arch/mips/include/asm/fpu_emulator.h
-@@ -30,6 +30,7 @@
- #include <asm/local.h>
- #include <asm/processor.h>
- 
-+#ifdef CONFIG_MIPS_FPU_EMULATOR
- #ifdef CONFIG_DEBUG_FS
- 
- struct mips_fpu_emulator_stats {
-@@ -63,6 +64,16 @@ do {									\
- extern int fpu_emulator_cop1Handler(struct pt_regs *xcp,
- 				    struct mips_fpu_struct *ctx, int has_fpu,
- 				    void *__user *fault_addr);
-+#else	/* no CONFIG_MIPS_FPU_EMULATOR */
-+static inline int fpu_emulator_cop1Handler(struct pt_regs *xcp,
-+				struct mips_fpu_struct *ctx, int has_fpu,
-+				void *__user *fault_addr)
-+{
-+	*fault_addr = NULL;
-+	return SIGILL;	/* we don't speak MIPS FPU */
-+}
-+#endif	/* CONFIG_MIPS_FPU_EMULATOR */
-+
- void force_fcr31_sig(unsigned long fcr31, void __user *fault_addr,
- 		     struct task_struct *tsk);
- int process_fpemu_return(int sig, void __user *fault_addr,
---- a/arch/mips/include/asm/dsemul.h
-+++ b/arch/mips/include/asm/dsemul.h
-@@ -41,6 +41,7 @@ struct task_struct;
- extern int mips_dsemul(struct pt_regs *regs, mips_instruction ir,
- 		       unsigned long branch_pc, unsigned long cont_pc);
- 
-+#ifdef CONFIG_MIPS_FPU_EMULATOR
- /**
-  * do_dsemulret() - Return from a delay slot 'emulation' frame
-  * @xcp:	User thread register context.
-@@ -88,5 +89,27 @@ extern bool dsemul_thread_rollback(struc
-  * before @mm is freed in order to avoid memory leaks.
-  */
- extern void dsemul_mm_cleanup(struct mm_struct *mm);
-+#else
-+static inline bool do_dsemulret(struct pt_regs *xcp)
-+{
-+	return false;
-+}
-+
-+static inline bool dsemul_thread_cleanup(struct task_struct *tsk)
-+{
-+	return false;
-+}
-+
-+static inline bool dsemul_thread_rollback(struct pt_regs *regs)
-+{
-+	return false;
-+}
-+
-+static inline void dsemul_mm_cleanup(struct mm_struct *mm)
-+{
-+
-+}
-+
-+#endif
- 
- #endif /* __MIPS_ASM_DSEMUL_H__ */
--- a/target/linux/generic/pending-4.9/305-mips_module_reloc.patch	2022-03-22 08:54:47.426465034 +0800
+++ b/target/linux/generic/pending-4.9/305-mips_module_reloc.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,370 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: mips: replace -mlong-calls with -mno-long-calls to make function calls faster in kernel modules to achieve this, try to
-
-lede-commit: 3b3d64743ba2a874df9d70cd19e242205b0a788c
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- arch/mips/Makefile             |   5 +
- arch/mips/include/asm/module.h |   5 +
- arch/mips/kernel/module.c      | 279 ++++++++++++++++++++++++++++++++++++++++-
- 3 files changed, 284 insertions(+), 5 deletions(-)
-
---- a/arch/mips/Makefile
-+++ b/arch/mips/Makefile
-@@ -93,8 +93,18 @@ all-$(CONFIG_SYS_SUPPORTS_ZBOOT)+= vmlin
- cflags-y			+= -G 0 -mno-abicalls -fno-pic -pipe -mno-branch-likely
- cflags-y			+= -msoft-float
- LDFLAGS_vmlinux			+= -G 0 -static -n -nostdlib
-+ifdef CONFIG_64BIT
- KBUILD_AFLAGS_MODULE		+= -mlong-calls
- KBUILD_CFLAGS_MODULE		+= -mlong-calls
-+else
-+  ifdef CONFIG_DYNAMIC_FTRACE
-+    KBUILD_AFLAGS_MODULE	+= -mlong-calls
-+    KBUILD_CFLAGS_MODULE	+= -mlong-calls
-+  else
-+    KBUILD_AFLAGS_MODULE	+= -mno-long-calls
-+    KBUILD_CFLAGS_MODULE	+= -mno-long-calls
-+  endif
-+endif
- 
- ifeq ($(CONFIG_RELOCATABLE),y)
- LDFLAGS_vmlinux			+= --emit-relocs
---- a/arch/mips/include/asm/module.h
-+++ b/arch/mips/include/asm/module.h
-@@ -11,6 +11,11 @@ struct mod_arch_specific {
- 	const struct exception_table_entry *dbe_start;
- 	const struct exception_table_entry *dbe_end;
- 	struct mips_hi16 *r_mips_hi16_list;
-+
-+	void *phys_plt_tbl;
-+	void *virt_plt_tbl;
-+	unsigned int phys_plt_offset;
-+	unsigned int virt_plt_offset;
- };
- 
- typedef uint8_t Elf64_Byte;		/* Type for a 8-bit quantity.  */
---- a/arch/mips/kernel/module.c
-+++ b/arch/mips/kernel/module.c
-@@ -44,14 +44,221 @@ struct mips_hi16 {
- static LIST_HEAD(dbe_list);
- static DEFINE_SPINLOCK(dbe_lock);
- 
--#ifdef MODULE_START
-+/*
-+ * Get the potential max trampolines size required of the init and
-+ * non-init sections. Only used if we cannot find enough contiguous
-+ * physically mapped memory to put the module into.
-+ */
-+static unsigned int
-+get_plt_size(const Elf_Ehdr *hdr, const Elf_Shdr *sechdrs,
-+             const char *secstrings, unsigned int symindex, bool is_init)
-+{
-+	unsigned long ret = 0;
-+	unsigned int i, j;
-+	Elf_Sym *syms;
-+
-+	/* Everything marked ALLOC (this includes the exported symbols) */
-+	for (i = 1; i < hdr->e_shnum; ++i) {
-+		unsigned int info = sechdrs[i].sh_info;
-+
-+		if (sechdrs[i].sh_type != SHT_REL
-+		    && sechdrs[i].sh_type != SHT_RELA)
-+			continue;
-+
-+		/* Not a valid relocation section? */
-+		if (info >= hdr->e_shnum)
-+			continue;
-+
-+		/* Don't bother with non-allocated sections */
-+		if (!(sechdrs[info].sh_flags & SHF_ALLOC))
-+			continue;
-+
-+		/* If it's called *.init*, and we're not init, we're
-+                   not interested */
-+		if ((strstr(secstrings + sechdrs[i].sh_name, ".init") != 0)
-+		    != is_init)
-+			continue;
-+
-+		syms = (Elf_Sym *) sechdrs[symindex].sh_addr;
-+		if (sechdrs[i].sh_type == SHT_REL) {
-+			Elf_Mips_Rel *rel = (void *) sechdrs[i].sh_addr;
-+			unsigned int size = sechdrs[i].sh_size / sizeof(*rel);
-+
-+			for (j = 0; j < size; ++j) {
-+				Elf_Sym *sym;
-+
-+				if (ELF_MIPS_R_TYPE(rel[j]) != R_MIPS_26)
-+					continue;
-+
-+				sym = syms + ELF_MIPS_R_SYM(rel[j]);
-+				if (!is_init && sym->st_shndx != SHN_UNDEF)
-+					continue;
-+
-+				ret += 4 * sizeof(int);
-+			}
-+		} else {
-+			Elf_Mips_Rela *rela = (void *) sechdrs[i].sh_addr;
-+			unsigned int size = sechdrs[i].sh_size / sizeof(*rela);
-+
-+			for (j = 0; j < size; ++j) {
-+				Elf_Sym *sym;
-+
-+				if (ELF_MIPS_R_TYPE(rela[j]) != R_MIPS_26)
-+					continue;
-+
-+				sym = syms + ELF_MIPS_R_SYM(rela[j]);
-+				if (!is_init && sym->st_shndx != SHN_UNDEF)
-+					continue;
-+
-+				ret += 4 * sizeof(int);
-+			}
-+		}
-+	}
-+
-+	return ret;
-+}
-+
-+#ifndef MODULE_START
-+static void *alloc_phys(unsigned long size)
-+{
-+	unsigned order;
-+	struct page *page;
-+	struct page *p;
-+
-+	size = PAGE_ALIGN(size);
-+	order = get_order(size);
-+
-+	page = alloc_pages(GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN |
-+			__GFP_THISNODE, order);
-+	if (!page)
-+		return NULL;
-+
-+	split_page(page, order);
-+
-+	/* mark all pages except for the last one */
-+	for (p = page; p + 1 < page + (size >> PAGE_SHIFT); ++p)
-+		set_bit(PG_owner_priv_1, &p->flags);
-+
-+	for (p = page + (size >> PAGE_SHIFT); p < page + (1 << order); ++p)
-+		__free_page(p);
-+
-+	return page_address(page);
-+}
-+#endif
-+
-+static void free_phys(void *ptr)
-+{
-+	struct page *page;
-+	bool free;
-+
-+	page = virt_to_page(ptr);
-+	do {
-+		free = test_and_clear_bit(PG_owner_priv_1, &page->flags);
-+		__free_page(page);
-+		page++;
-+	} while (free);
-+}
-+
-+
- void *module_alloc(unsigned long size)
- {
-+#ifdef MODULE_START
- 	return __vmalloc_node_range(size, 1, MODULE_START, MODULE_END,
- 				GFP_KERNEL, PAGE_KERNEL, 0, NUMA_NO_NODE,
- 				__builtin_return_address(0));
-+#else
-+	void *ptr;
-+
-+	if (size == 0)
-+		return NULL;
-+
-+	ptr = alloc_phys(size);
-+
-+	/* If we failed to allocate physically contiguous memory,
-+	 * fall back to regular vmalloc. The module loader code will
-+	 * create jump tables to handle long jumps */
-+	if (!ptr)
-+		return vmalloc(size);
-+
-+	return ptr;
-+#endif
- }
-+
-+static inline bool is_phys_addr(void *ptr)
-+{
-+#ifdef CONFIG_64BIT
-+	return (KSEGX((unsigned long)ptr) == CKSEG0);
-+#else
-+	return (KSEGX(ptr) == KSEG0);
- #endif
-+}
-+
-+/* Free memory returned from module_alloc */
-+void module_memfree(void *module_region)
-+{
-+	if (is_phys_addr(module_region))
-+		free_phys(module_region);
-+	else
-+		vfree(module_region);
-+}
-+
-+static void *__module_alloc(int size, bool phys)
-+{
-+	void *ptr;
-+
-+	if (phys)
-+		ptr = kmalloc(size, GFP_KERNEL);
-+	else
-+		ptr = vmalloc(size);
-+	return ptr;
-+}
-+
-+static void __module_free(void *ptr)
-+{
-+	if (is_phys_addr(ptr))
-+		kfree(ptr);
-+	else
-+		vfree(ptr);
-+}
-+
-+int module_frob_arch_sections(Elf_Ehdr *hdr, Elf_Shdr *sechdrs,
-+			      char *secstrings, struct module *mod)
-+{
-+	unsigned int symindex = 0;
-+	unsigned int core_size, init_size;
-+	int i;
-+
-+	mod->arch.phys_plt_offset = 0;
-+	mod->arch.virt_plt_offset = 0;
-+	mod->arch.phys_plt_tbl = NULL;
-+	mod->arch.virt_plt_tbl = NULL;
-+
-+	if (IS_ENABLED(CONFIG_64BIT))
-+		return 0;
-+
-+	for (i = 1; i < hdr->e_shnum; i++)
-+		if (sechdrs[i].sh_type == SHT_SYMTAB)
-+			symindex = i;
-+
-+	core_size = get_plt_size(hdr, sechdrs, secstrings, symindex, false);
-+	init_size = get_plt_size(hdr, sechdrs, secstrings, symindex, true);
-+
-+	if ((core_size + init_size) == 0)
-+		return 0;
-+
-+	mod->arch.phys_plt_tbl = __module_alloc(core_size + init_size, 1);
-+	if (!mod->arch.phys_plt_tbl)
-+		return -ENOMEM;
-+
-+	mod->arch.virt_plt_tbl = __module_alloc(core_size + init_size, 0);
-+	if (!mod->arch.virt_plt_tbl) {
-+		__module_free(mod->arch.phys_plt_tbl);
-+		mod->arch.phys_plt_tbl = NULL;
-+		return -ENOMEM;
-+	}
-+
-+	return 0;
-+}
- 
- int apply_r_mips_none(struct module *me, u32 *location, Elf_Addr v)
- {
-@@ -65,8 +272,39 @@ static int apply_r_mips_32_rel(struct mo
- 	return 0;
- }
- 
-+static Elf_Addr add_plt_entry_to(unsigned *plt_offset,
-+				 void *start, Elf_Addr v)
-+{
-+	unsigned *tramp = start + *plt_offset;
-+	*plt_offset += 4 * sizeof(int);
-+
-+	/* adjust carry for addiu */
-+	if (v & 0x00008000)
-+		v += 0x10000;
-+
-+	tramp[0] = 0x3c190000 | (v >> 16);      /* lui t9, hi16 */
-+	tramp[1] = 0x27390000 | (v & 0xffff);   /* addiu t9, t9, lo16 */
-+	tramp[2] = 0x03200008;                  /* jr t9 */
-+	tramp[3] = 0x00000000;                  /* nop */
-+
-+	return (Elf_Addr) tramp;
-+}
-+
-+static Elf_Addr add_plt_entry(struct module *me, void *location, Elf_Addr v)
-+{
-+	if (is_phys_addr(location))
-+		return add_plt_entry_to(&me->arch.phys_plt_offset,
-+				me->arch.phys_plt_tbl, v);
-+	else
-+		return add_plt_entry_to(&me->arch.virt_plt_offset,
-+				me->arch.virt_plt_tbl, v);
-+
-+}
-+
- static int apply_r_mips_26_rel(struct module *me, u32 *location, Elf_Addr v)
- {
-+	u32 ofs = *location & 0x03ffffff;
-+
- 	if (v % 4) {
- 		pr_err("module %s: dangerous R_MIPS_26 REL relocation\n",
- 		       me->name);
-@@ -74,13 +312,17 @@ static int apply_r_mips_26_rel(struct mo
- 	}
- 
- 	if ((v & 0xf0000000) != (((unsigned long)location + 4) & 0xf0000000)) {
--		pr_err("module %s: relocation overflow\n",
--		       me->name);
--		return -ENOEXEC;
-+		v = add_plt_entry(me, location, v + (ofs << 2));
-+		if (!v) {
-+			pr_err("module %s: relocation overflow\n",
-+			       me->name);
-+			return -ENOEXEC;
-+		}
-+		ofs = 0;
- 	}
- 
- 	*location = (*location & ~0x03ffffff) |
--		    ((*location + (v >> 2)) & 0x03ffffff);
-+		    ((ofs + (v >> 2)) & 0x03ffffff);
- 
- 	return 0;
- }
-@@ -349,9 +591,36 @@ int module_finalize(const Elf_Ehdr *hdr,
- 		list_add(&me->arch.dbe_list, &dbe_list);
- 		spin_unlock_irq(&dbe_lock);
- 	}
-+
-+	/* Get rid of the fixup trampoline if we're running the module
-+	 * from physically mapped address space */
-+	if (me->arch.phys_plt_offset == 0) {
-+		__module_free(me->arch.phys_plt_tbl);
-+		me->arch.phys_plt_tbl = NULL;
-+	}
-+	if (me->arch.virt_plt_offset == 0) {
-+		__module_free(me->arch.virt_plt_tbl);
-+		me->arch.virt_plt_tbl = NULL;
-+	}
-+
- 	return 0;
- }
- 
-+void module_arch_freeing_init(struct module *mod)
-+{
-+	if (mod->state == MODULE_STATE_LIVE)
-+		return;
-+
-+	if (mod->arch.phys_plt_tbl) {
-+		__module_free(mod->arch.phys_plt_tbl);
-+		mod->arch.phys_plt_tbl = NULL;
-+	}
-+	if (mod->arch.virt_plt_tbl) {
-+		__module_free(mod->arch.virt_plt_tbl);
-+		mod->arch.virt_plt_tbl = NULL;
-+	}
-+}
-+
- void module_arch_cleanup(struct module *mod)
- {
- 	spin_lock_irq(&dbe_lock);
--- a/target/linux/generic/pending-4.9/306-mips_mem_functions_performance.patch	2022-03-22 08:54:47.426465034 +0800
+++ b/target/linux/generic/pending-4.9/306-mips_mem_functions_performance.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,106 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: [PATCH] mips: allow the compiler to optimize memset, memcmp, memcpy  for better performance and (in some instances) smaller code
-
-lede-commit: 07e59c7bc7f375f792ec9734be42fe4fa391a8bb
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- arch/mips/boot/compressed/Makefile |  3 ++-
- arch/mips/include/asm/string.h     | 38 ++++++++++++++++++++++++++++++++++++++
- arch/mips/lib/Makefile             |  2 +-
- arch/mips/lib/memcmp.c             | 22 ++++++++++++++++++++++
- 4 files changed, 63 insertions(+), 2 deletions(-)
- create mode 100644 arch/mips/lib/memcmp.c
-
---- a/arch/mips/boot/compressed/Makefile
-+++ b/arch/mips/boot/compressed/Makefile
-@@ -23,7 +23,8 @@ KBUILD_CFLAGS := $(shell echo $(KBUILD_C
- KBUILD_CFLAGS := $(filter-out -fstack-protector, $(KBUILD_CFLAGS))
- 
- KBUILD_CFLAGS := $(LINUXINCLUDE) $(KBUILD_CFLAGS) -D__KERNEL__ \
--	-DBOOT_HEAP_SIZE=$(BOOT_HEAP_SIZE) -D"VMLINUX_LOAD_ADDRESS_ULL=$(VMLINUX_LOAD_ADDRESS)ull"
-+	-DBOOT_HEAP_SIZE=$(BOOT_HEAP_SIZE) -D"VMLINUX_LOAD_ADDRESS_ULL=$(VMLINUX_LOAD_ADDRESS)ull" \
-+	-D__ZBOOT__
- 
- KBUILD_AFLAGS := $(LINUXINCLUDE) $(KBUILD_AFLAGS) -D__ASSEMBLY__ \
- 	-DBOOT_HEAP_SIZE=$(BOOT_HEAP_SIZE) \
---- a/arch/mips/include/asm/string.h
-+++ b/arch/mips/include/asm/string.h
-@@ -140,4 +140,42 @@ extern void *memcpy(void *__to, __const_
- #define __HAVE_ARCH_MEMMOVE
- extern void *memmove(void *__dest, __const__ void *__src, size_t __n);
- 
-+#ifndef __ZBOOT__
-+#define memset(__s, __c, len)					\
-+({								\
-+	size_t __len = (len);					\
-+	void *__ret;						\
-+	if (__builtin_constant_p(len) && __len >= 64)		\
-+		__ret = memset((__s), (__c), __len);		\
-+	else							\
-+		__ret = __builtin_memset((__s), (__c), __len);	\
-+	__ret;							\
-+})
-+
-+#define memcpy(dst, src, len)					\
-+({								\
-+	size_t __len = (len);					\
-+	void *__ret;						\
-+	if (__builtin_constant_p(len) && __len >= 64)		\
-+		__ret = memcpy((dst), (src), __len);		\
-+	else							\
-+		__ret = __builtin_memcpy((dst), (src), __len);	\
-+	__ret;							\
-+})
-+
-+#define memmove(dst, src, len)					\
-+({								\
-+	size_t __len = (len);					\
-+	void *__ret;						\
-+	if (__builtin_constant_p(len) && __len >= 64)		\
-+		__ret = memmove((dst), (src), __len);		\
-+	else							\
-+		__ret = __builtin_memmove((dst), (src), __len);	\
-+	__ret;							\
-+})
-+
-+#define __HAVE_ARCH_MEMCMP
-+#define memcmp(src1, src2, len) __builtin_memcmp((src1), (src2), (len))
-+#endif
-+
- #endif /* _ASM_STRING_H */
---- a/arch/mips/lib/Makefile
-+++ b/arch/mips/lib/Makefile
-@@ -4,7 +4,7 @@
- 
- lib-y	+= bitops.o csum_partial.o delay.o memcpy.o memset.o \
- 	   mips-atomic.o strlen_user.o strncpy_user.o \
--	   strnlen_user.o uncached.o
-+	   strnlen_user.o uncached.o memcmp.o
- 
- obj-y			+= iomap.o
- obj-$(CONFIG_PCI)	+= iomap-pci.o
---- /dev/null
-+++ b/arch/mips/lib/memcmp.c
-@@ -0,0 +1,22 @@
-+/*
-+ *  copied from linux/lib/string.c
-+ *
-+ *  Copyright (C) 1991, 1992  Linus Torvalds
-+ */
-+
-+#include <linux/module.h>
-+#include <linux/string.h>
-+
-+#undef memcmp
-+int memcmp(const void *cs, const void *ct, size_t count)
-+{
-+	const unsigned char *su1, *su2;
-+	int res = 0;
-+
-+	for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
-+		if ((res = *su1 - *su2) != 0)
-+			break;
-+	return res;
-+}
-+EXPORT_SYMBOL(memcmp);
-+
--- a/target/linux/generic/pending-4.9/307-mips_highmem_offset.patch	2022-03-22 08:54:47.426465034 +0800
+++ b/target/linux/generic/pending-4.9/307-mips_highmem_offset.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,19 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: kernel: adjust mips highmem offset to avoid the need for -mlong-calls on systems with >256M RAM
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- arch/mips/include/asm/mach-generic/spaces.h | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/arch/mips/include/asm/mach-generic/spaces.h
-+++ b/arch/mips/include/asm/mach-generic/spaces.h
-@@ -46,7 +46,7 @@
-  * Memory above this physical address will be considered highmem.
-  */
- #ifndef HIGHMEM_START
--#define HIGHMEM_START		_AC(0x20000000, UL)
-+#define HIGHMEM_START		_AC(0x10000000, UL)
- #endif
- 
- #endif /* CONFIG_32BIT */
--- a/target/linux/generic/pending-4.9/308-mips32r2_tune.patch	2022-03-22 08:54:47.426465034 +0800
+++ b/target/linux/generic/pending-4.9/308-mips32r2_tune.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,22 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: kernel: add -mtune=34kc to MIPS CFLAGS when building for mips32r2
-
-This provides a good tradeoff across at least 24Kc-74Kc, while also
-producing smaller code.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- arch/mips/Makefile | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/arch/mips/Makefile
-+++ b/arch/mips/Makefile
-@@ -153,7 +153,7 @@ cflags-$(CONFIG_CPU_R4X00)	+= -march=r46
- cflags-$(CONFIG_CPU_TX49XX)	+= -march=r4600 -Wa,--trap
- cflags-$(CONFIG_CPU_MIPS32_R1)	+= $(call cc-option,-march=mips32,-mips32 -U_MIPS_ISA -D_MIPS_ISA=_MIPS_ISA_MIPS32) \
- 			-Wa,-mips32 -Wa,--trap
--cflags-$(CONFIG_CPU_MIPS32_R2)	+= $(call cc-option,-march=mips32r2,-mips32r2 -U_MIPS_ISA -D_MIPS_ISA=_MIPS_ISA_MIPS32) \
-+cflags-$(CONFIG_CPU_MIPS32_R2)	+= $(call cc-option,-march=mips32r2 -mtune=34kc,-mips32r2 -U_MIPS_ISA -D_MIPS_ISA=_MIPS_ISA_MIPS32) \
- 			-Wa,-mips32r2 -Wa,--trap
- cflags-$(CONFIG_CPU_MIPS32_R6)	+= -march=mips32r6 -Wa,--trap
- cflags-$(CONFIG_CPU_MIPS64_R1)	+= $(call cc-option,-march=mips64,-mips64 -U_MIPS_ISA -D_MIPS_ISA=_MIPS_ISA_MIPS64) \
--- a/target/linux/generic/pending-4.9/309-MIPS-Add-CPU-option-reporting-to-proc-cpuinfo.patch	2022-03-22 08:54:47.427465036 +0800
+++ b/target/linux/generic/pending-4.9/309-MIPS-Add-CPU-option-reporting-to-proc-cpuinfo.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,134 +0,0 @@
-From 87ec87c2ad615c1a177cd08ef5fa29fc739f6e50 Mon Sep 17 00:00:00 2001
-From: Hauke Mehrtens <hauke@hauke-m.de>
-Date: Sun, 23 Dec 2018 18:06:53 +0100
-Subject: [PATCH] MIPS: Add CPU option reporting to /proc/cpuinfo
-
-Many MIPS CPUs have optional CPU features which are not activates for
-all CPU cores. Print the CPU options which are implemented in the core
-in /proc/cpuinfo. This makes it possible to see what features are
-supported and which are not supported. This should cover all standard
-MIPS extensions, before it only printed information about the main MIPS
-ASEs.
-
-Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
----
- arch/mips/kernel/proc.c | 116 ++++++++++++++++++++++++++++++++++++++++
- 1 file changed, 116 insertions(+)
-
---- a/arch/mips/kernel/proc.c
-+++ b/arch/mips/kernel/proc.c
-@@ -128,6 +128,114 @@ static int show_cpuinfo(struct seq_file
- 		seq_printf(m, "micromips kernel\t: %s\n",
- 		      (read_c0_config3() & MIPS_CONF3_ISA_OE) ?  "yes" : "no");
- 	}
-+
-+	seq_printf(m, "Options implemented\t:");
-+	if (cpu_has_tlb)
-+		seq_printf(m, "%s", " tlb");
-+	if (cpu_has_ftlb)
-+		seq_printf(m, "%s", " ftlb");
-+	if (cpu_has_tlbinv)
-+		seq_printf(m, "%s", " tlbinv");
-+	if (cpu_has_segments)
-+		seq_printf(m, "%s", " segments");
-+	if (cpu_has_rixiex)
-+		seq_printf(m, "%s", " rixiex");
-+	if (cpu_has_ldpte)
-+		seq_printf(m, "%s", " ldpte");
-+	if (cpu_has_maar)
-+		seq_printf(m, "%s", " maar");
-+	if (cpu_has_rw_llb)
-+		seq_printf(m, "%s", " rw_llb");
-+	if (cpu_has_4kex)
-+		seq_printf(m, "%s", " 4kex");
-+	if (cpu_has_3k_cache)
-+		seq_printf(m, "%s", " 3k_cache");
-+	if (cpu_has_4k_cache)
-+		seq_printf(m, "%s", " 4k_cache");
-+	if (cpu_has_6k_cache)
-+		seq_printf(m, "%s", " 6k_cache");
-+	if (cpu_has_8k_cache)
-+		seq_printf(m, "%s", " 8k_cache");
-+	if (cpu_has_tx39_cache)
-+		seq_printf(m, "%s", " tx39_cache");
-+	if (cpu_has_octeon_cache)
-+		seq_printf(m, "%s", " octeon_cache");
-+	if (cpu_has_fpu)
-+		seq_printf(m, "%s", " fpu");
-+	if (cpu_has_32fpr)
-+		seq_printf(m, "%s", " 32fpr");
-+	if (cpu_has_cache_cdex_p)
-+		seq_printf(m, "%s", " cache_cdex_p");
-+	if (cpu_has_cache_cdex_s)
-+		seq_printf(m, "%s", " cache_cdex_s");
-+	if (cpu_has_prefetch)
-+		seq_printf(m, "%s", " prefetch");
-+	if (cpu_has_mcheck)
-+		seq_printf(m, "%s", " mcheck");
-+	if (cpu_has_ejtag)
-+		seq_printf(m, "%s", " ejtag");
-+	if (cpu_has_llsc)
-+		seq_printf(m, "%s", " llsc");
-+	if (cpu_has_bp_ghist)
-+		seq_printf(m, "%s", " bp_ghist");
-+	if (cpu_has_guestctl0ext)
-+		seq_printf(m, "%s", " guestctl0ext");
-+	if (cpu_has_guestctl1)
-+		seq_printf(m, "%s", " guestctl1");
-+	if (cpu_has_guestctl2)
-+		seq_printf(m, "%s", " guestctl2");
-+	if (cpu_has_guestid)
-+		seq_printf(m, "%s", " guestid");
-+	if (cpu_has_drg)
-+		seq_printf(m, "%s", " drg");
-+	if (cpu_has_rixi)
-+		seq_printf(m, "%s", " rixi");
-+	if (cpu_has_lpa)
-+		seq_printf(m, "%s", " lpa");
-+	if (cpu_has_mvh)
-+		seq_printf(m, "%s", " mvh");
-+	if (cpu_has_vtag_icache)
-+		seq_printf(m, "%s", " vtag_icache");
-+	if (cpu_has_dc_aliases)
-+		seq_printf(m, "%s", " dc_aliases");
-+	if (cpu_has_ic_fills_f_dc)
-+		seq_printf(m, "%s", " ic_fills_f_dc");
-+	if (cpu_has_pindexed_dcache)
-+		seq_printf(m, "%s", " pindexed_dcache");
-+	if (cpu_has_userlocal)
-+		seq_printf(m, "%s", " userlocal");
-+	if (cpu_has_nofpuex)
-+		seq_printf(m, "%s", " nofpuex");
-+	if (cpu_has_vint)
-+		seq_printf(m, "%s", " vint");
-+	if (cpu_has_veic)
-+		seq_printf(m, "%s", " veic");
-+	if (cpu_has_inclusive_pcaches)
-+		seq_printf(m, "%s", " inclusive_pcaches");
-+	if (cpu_has_perf_cntr_intr_bit)
-+		seq_printf(m, "%s", " perf_cntr_intr_bit");
-+	if (cpu_has_fre)
-+		seq_printf(m, "%s", " fre");
-+	if (cpu_has_cdmm)
-+		seq_printf(m, "%s", " cdmm");
-+	if (cpu_has_small_pages)
-+		seq_printf(m, "%s", " small_pages");
-+	if (cpu_has_nan_legacy)
-+		seq_printf(m, "%s", " nan_legacy");
-+	if (cpu_has_nan_2008)
-+		seq_printf(m, "%s", " nan_2008");
-+	if (cpu_has_ebase_wg)
-+		seq_printf(m, "%s", " ebase_wg");
-+	if (cpu_has_badinstr)
-+		seq_printf(m, "%s", " badinstr");
-+	if (cpu_has_badinstrp)
-+		seq_printf(m, "%s", " badinstrp");
-+	if (cpu_has_contextconfig)
-+		seq_printf(m, "%s", " contextconfig");
-+	if (cpu_has_perf)
-+		seq_printf(m, "%s", " perf");
-+	seq_printf(m, "\n");
-+
- 	seq_printf(m, "shadow register sets\t: %d\n",
- 		      cpu_data[n].srsets);
- 	seq_printf(m, "kscratch registers\t: %d\n",
--- a/target/linux/generic/pending-4.9/310-arm_module_unresolved_weak_sym.patch	2022-03-22 08:54:47.427465036 +0800
+++ b/target/linux/generic/pending-4.9/310-arm_module_unresolved_weak_sym.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,22 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: fix errors in unresolved weak symbols on arm
-
-lede-commit: 570699d4838a907c3ef9f2819bf19eb72997b32f
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- arch/arm/kernel/module.c | 4 ++++
- 1 file changed, 4 insertions(+)
-
---- a/arch/arm/kernel/module.c
-+++ b/arch/arm/kernel/module.c
-@@ -88,6 +88,10 @@ apply_relocate(Elf32_Shdr *sechdrs, cons
- 			return -ENOEXEC;
- 		}
- 
-+		if ((IS_ERR_VALUE(sym->st_value) || !sym->st_value) &&
-+		    ELF_ST_BIND(sym->st_info) == STB_WEAK)
-+			continue;
-+
- 		loc = dstsec->sh_addr + rel->r_offset;
- 
- 		switch (ELF32_R_TYPE(rel->r_info)) {
--- a/target/linux/generic/pending-4.9/330-MIPS-kexec-Accept-command-line-parameters-from-users.patch	2022-03-22 08:54:47.427465036 +0800
+++ b/target/linux/generic/pending-4.9/330-MIPS-kexec-Accept-command-line-parameters-from-users.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,269 +0,0 @@
-From: Yousong Zhou <yszhou4tech@gmail.com>
-Subject: MIPS: kexec: Accept command line parameters from userspace.
-
-Signed-off-by: Yousong Zhou <yszhou4tech@gmail.com>
----
- arch/mips/kernel/machine_kexec.c   |  153 +++++++++++++++++++++++++++++++-----
- arch/mips/kernel/machine_kexec.h   |   20 +++++
- arch/mips/kernel/relocate_kernel.S |   21 +++--
- 3 files changed, 167 insertions(+), 27 deletions(-)
- create mode 100644 arch/mips/kernel/machine_kexec.h
-
---- a/arch/mips/kernel/machine_kexec.c
-+++ b/arch/mips/kernel/machine_kexec.c
-@@ -10,14 +10,11 @@
- #include <linux/mm.h>
- #include <linux/delay.h>
- 
-+#include <asm/bootinfo.h>
- #include <asm/cacheflush.h>
- #include <asm/page.h>
--
--extern const unsigned char relocate_new_kernel[];
--extern const size_t relocate_new_kernel_size;
--
--extern unsigned long kexec_start_address;
--extern unsigned long kexec_indirection_page;
-+#include <asm/uaccess.h>
-+#include "machine_kexec.h"
- 
- int (*_machine_kexec_prepare)(struct kimage *) = NULL;
- void (*_machine_kexec_shutdown)(void) = NULL;
-@@ -28,9 +25,115 @@ atomic_t kexec_ready_to_reboot = ATOMIC_
- void (*_crash_smp_send_stop)(void) = NULL;
- #endif
- 
-+static void machine_kexec_print_args(void)
-+{
-+	unsigned long argc = (int)kexec_args[0];
-+	int i;
-+
-+	pr_info("kexec_args[0] (argc): %lu\n", argc);
-+	pr_info("kexec_args[1] (argv): %p\n", (void *)kexec_args[1]);
-+	pr_info("kexec_args[2] (env ): %p\n", (void *)kexec_args[2]);
-+	pr_info("kexec_args[3] (desc): %p\n", (void *)kexec_args[3]);
-+
-+	for (i = 0; i < argc; i++) {
-+		pr_info("kexec_argv[%d] = %p, %s\n",
-+				i, kexec_argv[i], kexec_argv[i]);
-+	}
-+}
-+
-+static void machine_kexec_init_argv(struct kimage *image)
-+{
-+	void __user *buf = NULL;
-+	size_t bufsz;
-+	size_t size;
-+	int i;
-+
-+	bufsz = 0;
-+	for (i = 0; i < image->nr_segments; i++) {
-+		struct kexec_segment *seg;
-+
-+		seg = &image->segment[i];
-+		if (seg->bufsz < 6)
-+			continue;
-+
-+		if (strncmp((char *) seg->buf, "kexec ", 6))
-+			continue;
-+
-+		buf = seg->buf;
-+		bufsz = seg->bufsz;
-+		break;
-+	}
-+
-+	if (!buf)
-+		return;
-+
-+	size = KEXEC_COMMAND_LINE_SIZE;
-+	size = min(size, bufsz);
-+	if (size < bufsz)
-+		pr_warn("kexec command line truncated to %zd bytes\n", size);
-+
-+	/* Copy to kernel space */
-+	copy_from_user(kexec_argv_buf, buf, size);
-+	kexec_argv_buf[size - 1] = 0;
-+}
-+
-+static void machine_kexec_parse_argv(struct kimage *image)
-+{
-+	char *reboot_code_buffer;
-+	int reloc_delta;
-+	char *ptr;
-+	int argc;
-+	int i;
-+
-+	ptr = kexec_argv_buf;
-+	argc = 0;
-+
-+	/*
-+	 * convert command line string to array of parameters
-+	 * (as bootloader does).
-+	 */
-+	while (ptr && *ptr && (KEXEC_MAX_ARGC > argc)) {
-+		if (*ptr == ' ') {
-+			*ptr++ = '\0';
-+			continue;
-+		}
-+
-+		kexec_argv[argc++] = ptr;
-+		ptr = strchr(ptr, ' ');
-+	}
-+
-+	if (!argc)
-+		return;
-+
-+	kexec_args[0] = argc;
-+	kexec_args[1] = (unsigned long)kexec_argv;
-+	kexec_args[2] = 0;
-+	kexec_args[3] = 0;
-+
-+	reboot_code_buffer = page_address(image->control_code_page);
-+	reloc_delta = reboot_code_buffer - (char *)kexec_relocate_new_kernel;
-+
-+	kexec_args[1] += reloc_delta;
-+	for (i = 0; i < argc; i++)
-+		kexec_argv[i] += reloc_delta;
-+}
-+
- int
- machine_kexec_prepare(struct kimage *kimage)
- {
-+	/*
-+	 * Whenever arguments passed from kexec-tools, Init the arguments as
-+	 * the original ones to try avoiding booting failure.
-+	 */
-+
-+	kexec_args[0] = fw_arg0;
-+	kexec_args[1] = fw_arg1;
-+	kexec_args[2] = fw_arg2;
-+	kexec_args[3] = fw_arg3;
-+
-+	machine_kexec_init_argv(kimage);
-+	machine_kexec_parse_argv(kimage);
-+
- 	if (_machine_kexec_prepare)
- 		return _machine_kexec_prepare(kimage);
- 	return 0;
-@@ -67,10 +170,12 @@ machine_kexec(struct kimage *image)
- 	unsigned long *ptr;
- 
- 	reboot_code_buffer =
--	  (unsigned long)page_address(image->control_code_page);
-+		(unsigned long)page_address(image->control_code_page);
-+	pr_info("reboot_code_buffer = %p\n", (void *)reboot_code_buffer);
- 
- 	kexec_start_address =
- 		(unsigned long) phys_to_virt(image->start);
-+	pr_info("kexec_start_address = %p\n", (void *)kexec_start_address);
- 
- 	if (image->type == KEXEC_TYPE_DEFAULT) {
- 		kexec_indirection_page =
-@@ -78,9 +183,19 @@ machine_kexec(struct kimage *image)
- 	} else {
- 		kexec_indirection_page = (unsigned long)&image->head;
- 	}
-+	pr_info("kexec_indirection_page = %p\n", (void *)kexec_indirection_page);
- 
--	memcpy((void*)reboot_code_buffer, relocate_new_kernel,
--	       relocate_new_kernel_size);
-+	pr_info("Where is memcpy: %p\n", memcpy);
-+	pr_info("kexec_relocate_new_kernel = %p, kexec_relocate_new_kernel_end = %p\n",
-+		(void *)kexec_relocate_new_kernel, &kexec_relocate_new_kernel_end);
-+	pr_info("Copy %lu bytes from %p to %p\n", KEXEC_RELOCATE_NEW_KERNEL_SIZE,
-+		(void *)kexec_relocate_new_kernel, (void *)reboot_code_buffer);
-+	memcpy((void*)reboot_code_buffer, kexec_relocate_new_kernel,
-+	       KEXEC_RELOCATE_NEW_KERNEL_SIZE);
-+
-+	pr_info("Before _print_args().\n");
-+	machine_kexec_print_args();
-+	pr_info("Before eval loop.\n");
- 
- 	/*
- 	 * The generic kexec code builds a page list with physical
-@@ -102,15 +217,16 @@ machine_kexec(struct kimage *image)
- 	/*
- 	 * we do not want to be bothered.
- 	 */
-+	pr_info("Before irq_disable.\n");
- 	local_irq_disable();
- 
--	printk("Will call new kernel at %08lx\n", image->start);
--	printk("Bye ...\n");
-+	pr_info("Will call new kernel at %08lx\n", image->start);
-+	pr_info("Bye ...\n");
- 	__flush_cache_all();
- #ifdef CONFIG_SMP
- 	/* All secondary cpus now may jump to kexec_wait cycle */
- 	relocated_kexec_smp_wait = reboot_code_buffer +
--		(void *)(kexec_smp_wait - relocate_new_kernel);
-+		(void *)(kexec_smp_wait - kexec_relocate_new_kernel);
- 	smp_wmb();
- 	atomic_set(&kexec_ready_to_reboot, 1);
- #endif
---- /dev/null
-+++ b/arch/mips/kernel/machine_kexec.h
-@@ -0,0 +1,20 @@
-+#ifndef _MACHINE_KEXEC_H
-+#define _MACHINE_KEXEC_H
-+
-+#ifndef __ASSEMBLY__
-+extern const unsigned char kexec_relocate_new_kernel[];
-+extern unsigned long kexec_relocate_new_kernel_end;
-+extern unsigned long kexec_start_address;
-+extern unsigned long kexec_indirection_page;
-+
-+extern char kexec_argv_buf[];
-+extern char *kexec_argv[];
-+
-+#define KEXEC_RELOCATE_NEW_KERNEL_SIZE	((unsigned long)&kexec_relocate_new_kernel_end - (unsigned long)kexec_relocate_new_kernel)
-+#endif /* !__ASSEMBLY__ */
-+
-+#define KEXEC_COMMAND_LINE_SIZE		256
-+#define KEXEC_ARGV_SIZE			(KEXEC_COMMAND_LINE_SIZE / 16)
-+#define KEXEC_MAX_ARGC			(KEXEC_ARGV_SIZE / sizeof(long))
-+
-+#endif
---- a/arch/mips/kernel/relocate_kernel.S
-+++ b/arch/mips/kernel/relocate_kernel.S
-@@ -12,8 +12,9 @@
- #include <asm/mipsregs.h>
- #include <asm/stackframe.h>
- #include <asm/addrspace.h>
-+#include "machine_kexec.h"
- 
--LEAF(relocate_new_kernel)
-+LEAF(kexec_relocate_new_kernel)
- 	PTR_L a0,	arg0
- 	PTR_L a1,	arg1
- 	PTR_L a2,	arg2
-@@ -98,7 +99,7 @@ done:
- #endif
- 	/* jump to kexec_start_address */
- 	j		s1
--	END(relocate_new_kernel)
-+	END(kexec_relocate_new_kernel)
- 
- #ifdef CONFIG_SMP
- /*
-@@ -184,9 +185,15 @@ kexec_indirection_page:
- 	PTR		0
- 	.size		kexec_indirection_page, PTRSIZE
- 
--relocate_new_kernel_end:
-+kexec_argv_buf:
-+	EXPORT(kexec_argv_buf)
-+	.skip		KEXEC_COMMAND_LINE_SIZE
-+	.size		kexec_argv_buf, KEXEC_COMMAND_LINE_SIZE
-+
-+kexec_argv:
-+	EXPORT(kexec_argv)
-+	.skip		KEXEC_ARGV_SIZE
-+	.size		kexec_argv, KEXEC_ARGV_SIZE
- 
--relocate_new_kernel_size:
--	EXPORT(relocate_new_kernel_size)
--	PTR		relocate_new_kernel_end - relocate_new_kernel
--	.size		relocate_new_kernel_size, PTRSIZE
-+kexec_relocate_new_kernel_end:
-+	EXPORT(kexec_relocate_new_kernel_end)
--- a/target/linux/generic/pending-4.9/332-arc-add-OWRTDTB-section.patch	2022-03-22 08:54:47.428465038 +0800
+++ b/target/linux/generic/pending-4.9/332-arc-add-OWRTDTB-section.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,80 +0,0 @@
-From: Alexey Brodkin <abrodkin@synopsys.com>
-Subject: openwrt: arc - add OWRTDTB section
-
-This change allows OpenWRT to patch resulting kernel binary with
-external .dtb.
-
-That allows us to re-use exactky the same vmlinux on different boards
-given its ARC core configurations match (at least cache line sizes etc).
-
-""patch-dtb" searches for ASCII "OWRTDTB:" strign and copies external
-.dtb right after it, keeping the string in place.
-
-Signed-off-by: Alexey Brodkin <abrodkin@synopsys.com>
----
- arch/arc/kernel/head.S        | 10 ++++++++++
- arch/arc/kernel/setup.c       |  4 +++-
- arch/arc/kernel/vmlinux.lds.S | 13 +++++++++++++
- 3 files changed, 26 insertions(+), 1 deletion(-)
-
---- a/arch/arc/kernel/head.S
-+++ b/arch/arc/kernel/head.S
-@@ -59,6 +59,16 @@
- #endif
- .endm
- 
-+; Here "patch-dtb" will embed external .dtb
-+; Note "patch-dtb" searches for ASCII "OWRTDTB:" string
-+; and pastes .dtb right after it, hense the string precedes
-+; __image_dtb symbol.
-+	.section .owrt, "aw",@progbits
-+	.ascii	"OWRTDTB:"
-+ENTRY(__image_dtb)
-+	.fill	0x4000
-+END(__image_dtb)
-+
- 	.section .init.text, "ax",@progbits
- 
- ;----------------------------------------------------------------
---- a/arch/arc/kernel/setup.c
-+++ b/arch/arc/kernel/setup.c
-@@ -444,7 +444,7 @@ ignore_uboot_args:
- #endif
- 
- 	if (use_embedded_dtb) {
--		machine_desc = setup_machine_fdt(__dtb_start);
-+		machine_desc = setup_machine_fdt(&__image_dtb);
- 		if (!machine_desc)
- 			panic("Embedded DT invalid\n");
- 	}
-@@ -460,6 +460,8 @@ ignore_uboot_args:
- 	}
- }
- 
-+extern struct boot_param_header __image_dtb;
-+
- void __init setup_arch(char **cmdline_p)
- {
- 	handle_uboot_args();
---- a/arch/arc/kernel/vmlinux.lds.S
-+++ b/arch/arc/kernel/vmlinux.lds.S
-@@ -30,6 +30,19 @@ SECTIONS
- 
- 	. = CONFIG_LINUX_LINK_BASE;
- 
-+	/*
-+	 * In OpenWRT we want to patch built binary embedding .dtb of choice.
-+	 * This is implemented with "patch-dtb" utility which searches for
-+	 * "OWRTDTB:" string in first 16k of image and if it is found
-+	 * copies .dtb right after mentioned string.
-+	 *
-+	 * Note: "OWRTDTB:" won't be overwritten with .dtb, .dtb will follow it.
-+	 */
-+	.owrt : {
-+		*(.owrt)
-+		. = ALIGN(PAGE_SIZE);
-+	}
-+
- 	_int_vec_base_lds = .;
- 	.vector : {
- 		*(.vector)
--- a/target/linux/generic/pending-4.9/333-arc-enable-unaligned-access-in-kernel-mode.patch	2022-03-22 08:54:47.428465038 +0800
+++ b/target/linux/generic/pending-4.9/333-arc-enable-unaligned-access-in-kernel-mode.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,24 +0,0 @@
-From: Alexey Brodkin <abrodkin@synopsys.com>
-Subject: arc: enable unaligned access in kernel mode
-
-This enables misaligned access handling even in kernel mode.
-Some wireless drivers (ath9k-htc and mt7601u) use misaligned accesses
-here and there and to cope with that without fixing stuff in the drivers
-we're just gracefully handling it on ARC.
-
-Signed-off-by: Alexey Brodkin <abrodkin@synopsys.com>
----
- arch/arc/kernel/unaligned.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/arch/arc/kernel/unaligned.c
-+++ b/arch/arc/kernel/unaligned.c
-@@ -206,7 +206,7 @@ int misaligned_fixup(unsigned long addre
- 	char buf[TASK_COMM_LEN];
- 
- 	/* handle user mode only and only if enabled by sysadmin */
--	if (!user_mode(regs) || !unaligned_enabled)
-+	if (!unaligned_enabled)
- 		return 1;
- 
- 	if (no_unaligned_warning) {
--- a/target/linux/generic/pending-4.9/340-MIPS-mm-remove-mips_dma_mapping_error.patch	2022-03-22 08:54:47.428465038 +0800
+++ b/target/linux/generic/pending-4.9/340-MIPS-mm-remove-mips_dma_mapping_error.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,32 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Tue, 5 Dec 2017 12:34:31 +0100
-Subject: [PATCH] MIPS: mm: remove mips_dma_mapping_error
-
-dma_mapping_error() already checks if ops->mapping_error is a null
-pointer
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/arch/mips/mm/dma-default.c
-+++ b/arch/mips/mm/dma-default.c
-@@ -394,11 +394,6 @@ static void mips_dma_sync_sg_for_device(
- 	}
- }
- 
--int mips_dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
--{
--	return 0;
--}
--
- int mips_dma_supported(struct device *dev, u64 mask)
- {
- 	return plat_dma_supported(dev, mask);
-@@ -427,7 +422,6 @@ static struct dma_map_ops mips_default_d
- 	.sync_single_for_device = mips_dma_sync_single_for_device,
- 	.sync_sg_for_cpu = mips_dma_sync_sg_for_cpu,
- 	.sync_sg_for_device = mips_dma_sync_sg_for_device,
--	.mapping_error = mips_dma_mapping_error,
- 	.dma_supported = mips_dma_supported
- };
- 
--- a/target/linux/generic/pending-4.9/341-MIPS-mm-remove-no-op-dma_map_ops-where-possible.patch	2022-03-22 08:54:47.429465039 +0800
+++ b/target/linux/generic/pending-4.9/341-MIPS-mm-remove-no-op-dma_map_ops-where-possible.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,140 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Tue, 5 Dec 2017 12:46:01 +0100
-Subject: [PATCH] MIPS: mm: remove no-op dma_map_ops where possible
-
-If no post-DMA flush is required, and the platform does not provide
-plat_unmap_dma_mem(), there is no need to include unmap or sync_for_cpu
-ops.
-
-With this patch they are compiled out to improve icache footprint
-on devices that handle lots of DMA traffic (especially network routers).
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/arch/mips/Kconfig
-+++ b/arch/mips/Kconfig
-@@ -215,6 +215,7 @@ config BMIPS_GENERIC
- 	select BRCMSTB_L2_IRQ
- 	select IRQ_MIPS_CPU
- 	select DMA_NONCOHERENT
-+	select DMA_UNMAP_POST_FLUSH
- 	select SYS_SUPPORTS_32BIT_KERNEL
- 	select SYS_SUPPORTS_LITTLE_ENDIAN
- 	select SYS_SUPPORTS_BIG_ENDIAN
-@@ -340,6 +341,7 @@ config MACH_JAZZ
- 	select CSRC_R4K
- 	select DEFAULT_SGI_PARTITION if CPU_BIG_ENDIAN
- 	select GENERIC_ISA_DMA
-+	select DMA_UNMAP_POST_FLUSH
- 	select HAVE_PCSPKR_PLATFORM
- 	select IRQ_MIPS_CPU
- 	select I8253
-@@ -1127,6 +1129,9 @@ config DMA_NONCOHERENT
- 	bool
- 	select NEED_DMA_MAP_STATE
- 
-+config DMA_UNMAP_POST_FLUSH
-+	bool
-+
- config NEED_DMA_MAP_STATE
- 	bool
- 
-@@ -1651,6 +1656,7 @@ config CPU_R10000
- 	select CPU_SUPPORTS_64BIT_KERNEL
- 	select CPU_SUPPORTS_HIGHMEM
- 	select CPU_SUPPORTS_HUGEPAGES
-+	select DMA_UNMAP_POST_FLUSH
- 	help
- 	  MIPS Technologies R10000-series processors.
- 
-@@ -1896,9 +1902,11 @@ config SYS_HAS_CPU_MIPS32_R3_5
- 	bool
- 
- config SYS_HAS_CPU_MIPS32_R5
-+	select DMA_UNMAP_POST_FLUSH
- 	bool
- 
- config SYS_HAS_CPU_MIPS32_R6
-+	select DMA_UNMAP_POST_FLUSH
- 	bool
- 
- config SYS_HAS_CPU_MIPS64_R1
-@@ -1908,6 +1916,7 @@ config SYS_HAS_CPU_MIPS64_R2
- 	bool
- 
- config SYS_HAS_CPU_MIPS64_R6
-+	select DMA_UNMAP_POST_FLUSH
- 	bool
- 
- config SYS_HAS_CPU_R3000
---- a/arch/mips/mm/dma-default.c
-+++ b/arch/mips/mm/dma-default.c
-@@ -290,8 +290,9 @@ static inline void __dma_sync(struct pag
- 	} while (left);
- }
- 
--static void mips_dma_unmap_page(struct device *dev, dma_addr_t dma_addr,
--	size_t size, enum dma_data_direction direction, unsigned long attrs)
-+static void __maybe_unused
-+mips_dma_unmap_page(struct device *dev, dma_addr_t dma_addr, size_t size,
-+		    enum dma_data_direction direction, unsigned long attrs)
- {
- 	if (cpu_needs_post_dma_flush(dev))
- 		__dma_sync(dma_addr_to_page(dev, dma_addr),
-@@ -330,9 +331,10 @@ static dma_addr_t mips_dma_map_page(stru
- 	return plat_map_dma_mem_page(dev, page) + offset;
- }
- 
--static void mips_dma_unmap_sg(struct device *dev, struct scatterlist *sglist,
--	int nhwentries, enum dma_data_direction direction,
--	unsigned long attrs)
-+static void __maybe_unused
-+mips_dma_unmap_sg(struct device *dev, struct scatterlist *sglist,
-+		  int nhwentries, enum dma_data_direction direction,
-+		  unsigned long attrs)
- {
- 	int i;
- 	struct scatterlist *sg;
-@@ -346,8 +348,9 @@ static void mips_dma_unmap_sg(struct dev
- 	}
- }
- 
--static void mips_dma_sync_single_for_cpu(struct device *dev,
--	dma_addr_t dma_handle, size_t size, enum dma_data_direction direction)
-+static void __maybe_unused
-+mips_dma_sync_single_for_cpu(struct device *dev, dma_addr_t dma_handle,
-+			     size_t size, enum dma_data_direction direction)
- {
- 	if (cpu_needs_post_dma_flush(dev))
- 		__dma_sync(dma_addr_to_page(dev, dma_handle),
-@@ -363,9 +366,9 @@ static void mips_dma_sync_single_for_dev
- 			   dma_handle & ~PAGE_MASK, size, direction);
- }
- 
--static void mips_dma_sync_sg_for_cpu(struct device *dev,
--	struct scatterlist *sglist, int nelems,
--	enum dma_data_direction direction)
-+static void __maybe_unused
-+mips_dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sglist,
-+			 int nelems, enum dma_data_direction direction)
- {
- 	int i;
- 	struct scatterlist *sg;
-@@ -415,12 +418,14 @@ static struct dma_map_ops mips_default_d
- 	.free = mips_dma_free_coherent,
- 	.mmap = mips_dma_mmap,
- 	.map_page = mips_dma_map_page,
--	.unmap_page = mips_dma_unmap_page,
- 	.map_sg = mips_dma_map_sg,
-+#ifdef CONFIG_DMA_UNMAP_POST_FLUSH
-+	.unmap_page = mips_dma_unmap_page,
- 	.unmap_sg = mips_dma_unmap_sg,
- 	.sync_single_for_cpu = mips_dma_sync_single_for_cpu,
--	.sync_single_for_device = mips_dma_sync_single_for_device,
- 	.sync_sg_for_cpu = mips_dma_sync_sg_for_cpu,
-+#endif
-+	.sync_single_for_device = mips_dma_sync_single_for_device,
- 	.sync_sg_for_device = mips_dma_sync_sg_for_device,
- 	.dma_supported = mips_dma_supported
- };
--- a/target/linux/generic/pending-4.9/400-mtd-add-rootfs-split-support.patch	2022-03-22 08:54:47.429465039 +0800
+++ b/target/linux/generic/pending-4.9/400-mtd-add-rootfs-split-support.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,108 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: make rootfs split/detection more generic - patch can be moved to generic-2.6 after testing on other platforms
-
-lede-commit: 328e660b31f0937d52c5ae3d6e7029409918a9df
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- drivers/mtd/Kconfig            | 17 +++++++++++++++++
- drivers/mtd/mtdpart.c          | 35 +++++++++++++++++++++++++++++++++++
- include/linux/mtd/partitions.h |  2 ++
- 3 files changed, 54 insertions(+)
-
---- a/drivers/mtd/Kconfig
-+++ b/drivers/mtd/Kconfig
-@@ -12,6 +12,23 @@ menuconfig MTD
- 
- if MTD
- 
-+menu "OpenWrt specific MTD options"
-+
-+config MTD_ROOTFS_ROOT_DEV
-+	bool "Automatically set 'rootfs' partition to be root filesystem"
-+	default y
-+
-+config MTD_SPLIT_FIRMWARE
-+	bool "Automatically split firmware partition for kernel+rootfs"
-+	default y
-+
-+config MTD_SPLIT_FIRMWARE_NAME
-+	string "Firmware partition name"
-+	depends on MTD_SPLIT_FIRMWARE
-+	default "firmware"
-+
-+endmenu
-+
- config MTD_TESTS
- 	tristate "MTD tests support (DANGEROUS)"
- 	depends on m
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -29,11 +29,13 @@
- #include <linux/kmod.h>
- #include <linux/mtd/mtd.h>
- #include <linux/mtd/partitions.h>
-+#include <linux/magic.h>
- #include <linux/of.h>
- #include <linux/err.h>
- #include <linux/of.h>
- 
- #include "mtdcore.h"
-+#include "mtdsplit/mtdsplit.h"
- 
- /* Our partition linked list */
- static LIST_HEAD(mtd_partitions);
-@@ -53,6 +55,8 @@ struct mtd_part {
- 	struct list_head list;
- };
- 
-+static void mtd_partition_split(struct mtd_info *master, struct mtd_part *part);
-+
- /*
-  * Given a pointer to the MTD object in the mtd_part structure, we can retrieve
-  * the pointer to that structure.
-@@ -653,6 +657,7 @@ int mtd_add_partition(struct mtd_info *p
- 	if (ret)
- 		goto err_remove_part;
- 
-+	mtd_partition_split(parent, new);
- 	mtd_add_partition_attrs(new);
- 
- 	return 0;
-@@ -739,6 +744,29 @@ int mtd_del_partition(struct mtd_info *m
- }
- EXPORT_SYMBOL_GPL(mtd_del_partition);
- 
-+#ifdef CONFIG_MTD_SPLIT_FIRMWARE_NAME
-+#define SPLIT_FIRMWARE_NAME	CONFIG_MTD_SPLIT_FIRMWARE_NAME
-+#else
-+#define SPLIT_FIRMWARE_NAME	"unused"
-+#endif
-+
-+static void split_firmware(struct mtd_info *master, struct mtd_part *part)
-+{
-+}
-+
-+static void mtd_partition_split(struct mtd_info *master, struct mtd_part *part)
-+{
-+	static int rootfs_found = 0;
-+
-+	if (rootfs_found)
-+		return;
-+
-+	if (IS_ENABLED(CONFIG_MTD_SPLIT_FIRMWARE) &&
-+	    !strcmp(part->mtd.name, SPLIT_FIRMWARE_NAME) &&
-+	    !of_find_property(mtd_get_of_node(&part->mtd), "compatible", NULL))
-+		split_firmware(master, part);
-+}
-+
- /*
-  * This function, given a master MTD object and a partition table, creates
-  * and registers slave MTD objects which are bound to the master according to
-@@ -779,6 +807,7 @@ int add_mtd_partitions(struct mtd_info *
- 			goto err_del_partitions;
- 		}
- 
-+		mtd_partition_split(master, slave);
- 		mtd_add_partition_attrs(slave);
- 		/* Look for subpartitions */
- 		parse_mtd_partitions(&slave->mtd, parts[i].types, NULL);
--- a/target/linux/generic/pending-4.9/401-mtd-add-support-for-different-partition-parser-types.patch	2022-03-22 08:54:47.429465039 +0800
+++ b/target/linux/generic/pending-4.9/401-mtd-add-support-for-different-partition-parser-types.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,142 +0,0 @@
-From: Gabor Juhos <juhosg@openwrt.org>
-Subject: mtd: add support for different partition parser types
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/mtd/mtdpart.c          |   56 ++++++++++++++++++++++++++++++++++++++++
- include/linux/mtd/partitions.h |   11 ++++++++
- 2 files changed, 67 insertions(+)
-
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -56,6 +56,10 @@ struct mtd_part {
- };
- 
- static void mtd_partition_split(struct mtd_info *master, struct mtd_part *part);
-+static int parse_mtd_partitions_by_type(struct mtd_info *master,
-+					enum mtd_parser_type type,
-+					const struct mtd_partition **pparts,
-+					struct mtd_part_parser_data *data);
- 
- /*
-  * Given a pointer to the MTD object in the mtd_part structure, we can retrieve
-@@ -744,6 +748,36 @@ int mtd_del_partition(struct mtd_info *m
- }
- EXPORT_SYMBOL_GPL(mtd_del_partition);
- 
-+static int
-+run_parsers_by_type(struct mtd_part *slave, enum mtd_parser_type type)
-+{
-+	struct mtd_partition *parts;
-+	int nr_parts;
-+	int i;
-+
-+	nr_parts = parse_mtd_partitions_by_type(&slave->mtd, type, (const struct mtd_partition **)&parts,
-+						NULL);
-+	if (nr_parts <= 0)
-+		return nr_parts;
-+
-+	if (WARN_ON(!parts))
-+		return 0;
-+
-+	for (i = 0; i < nr_parts; i++) {
-+		/* adjust partition offsets */
-+		parts[i].offset += slave->offset;
-+
-+		mtd_add_partition(slave->parent,
-+				  parts[i].name,
-+				  parts[i].offset,
-+				  parts[i].size);
-+	}
-+
-+	kfree(parts);
-+
-+	return nr_parts;
-+}
-+
- #ifdef CONFIG_MTD_SPLIT_FIRMWARE_NAME
- #define SPLIT_FIRMWARE_NAME	CONFIG_MTD_SPLIT_FIRMWARE_NAME
- #else
-@@ -1134,6 +1168,61 @@ void mtd_part_parser_cleanup(struct mtd_
- 	}
- }
- 
-+static struct mtd_part_parser *
-+get_partition_parser_by_type(enum mtd_parser_type type,
-+			     struct mtd_part_parser *start)
-+{
-+	struct mtd_part_parser *p, *ret = NULL;
-+
-+	spin_lock(&part_parser_lock);
-+
-+	p = list_prepare_entry(start, &part_parsers, list);
-+	if (start)
-+		mtd_part_parser_put(start);
-+
-+	list_for_each_entry_continue(p, &part_parsers, list) {
-+		if (p->type == type && try_module_get(p->owner)) {
-+			ret = p;
-+			break;
-+		}
-+	}
-+
-+	spin_unlock(&part_parser_lock);
-+
-+	return ret;
-+}
-+
-+static int parse_mtd_partitions_by_type(struct mtd_info *master,
-+					enum mtd_parser_type type,
-+					const struct mtd_partition **pparts,
-+					struct mtd_part_parser_data *data)
-+{
-+	struct mtd_part_parser *prev = NULL;
-+	int ret = 0;
-+
-+	while (1) {
-+		struct mtd_part_parser *parser;
-+
-+		parser = get_partition_parser_by_type(type, prev);
-+		if (!parser)
-+			break;
-+
-+		ret = (*parser->parse_fn)(master, pparts, data);
-+
-+		if (ret > 0) {
-+			mtd_part_parser_put(parser);
-+			printk(KERN_NOTICE
-+			       "%d %s partitions found on MTD device %s\n",
-+			       ret, parser->name, master->name);
-+			break;
-+		}
-+
-+		prev = parser;
-+	}
-+
-+	return ret;
-+}
-+
- int mtd_is_partition(const struct mtd_info *mtd)
- {
- 	struct mtd_part *part;
---- a/include/linux/mtd/partitions.h
-+++ b/include/linux/mtd/partitions.h
-@@ -73,6 +73,10 @@ struct mtd_part_parser_data {
-  * Functions dealing with the various ways of partitioning the space
-  */
- 
-+enum mtd_parser_type {
-+	MTD_PARSER_TYPE_DEVICE = 0,
-+};
-+
- struct mtd_part_parser {
- 	struct list_head list;
- 	struct module *owner;
-@@ -81,6 +85,7 @@ struct mtd_part_parser {
- 	int (*parse_fn)(struct mtd_info *, const struct mtd_partition **,
- 			struct mtd_part_parser_data *);
- 	void (*cleanup)(const struct mtd_partition *pparts, int nr_parts);
-+	enum mtd_parser_type type;
- };
- 
- /* Container for passing around a set of parsed partitions */
--- a/target/linux/generic/pending-4.9/402-mtd-use-typed-mtd-parsers-for-rootfs-and-firmware-split.patch	2022-03-22 08:54:47.429465039 +0800
+++ b/target/linux/generic/pending-4.9/402-mtd-use-typed-mtd-parsers-for-rootfs-and-firmware-split.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,44 +0,0 @@
-From: Gabor Juhos <juhosg@openwrt.org>
-Subject: kernel/3.10: allow to use partition parsers for rootfs and firmware split
-
-lede-commit: 3b71cd94bc9517bc25267dccb393b07d4b54564e
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/mtd/mtdpart.c          | 37 +++++++++++++++++++++++++++++++++++++
- include/linux/mtd/partitions.h |  2 ++
- 2 files changed, 39 insertions(+)
-
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -786,6 +786,7 @@ run_parsers_by_type(struct mtd_part *sla
- 
- static void split_firmware(struct mtd_info *master, struct mtd_part *part)
- {
-+	run_parsers_by_type(part, MTD_PARSER_TYPE_FIRMWARE);
- }
- 
- static void mtd_partition_split(struct mtd_info *master, struct mtd_part *part)
-@@ -795,6 +796,12 @@ static void mtd_partition_split(struct m
- 	if (rootfs_found)
- 		return;
- 
-+	if (!strcmp(part->mtd.name, "rootfs")) {
-+		run_parsers_by_type(part, MTD_PARSER_TYPE_ROOTFS);
-+
-+		rootfs_found = 1;
-+	}
-+
- 	if (IS_ENABLED(CONFIG_MTD_SPLIT_FIRMWARE) &&
- 	    !strcmp(part->mtd.name, SPLIT_FIRMWARE_NAME) &&
- 	    !of_find_property(mtd_get_of_node(&part->mtd), "compatible", NULL))
---- a/include/linux/mtd/partitions.h
-+++ b/include/linux/mtd/partitions.h
-@@ -75,6 +75,8 @@ struct mtd_part_parser_data {
- 
- enum mtd_parser_type {
- 	MTD_PARSER_TYPE_DEVICE = 0,
-+	MTD_PARSER_TYPE_ROOTFS,
-+	MTD_PARSER_TYPE_FIRMWARE,
- };
- 
- struct mtd_part_parser {
--- a/target/linux/generic/pending-4.9/403-mtd-hook-mtdsplit-to-Kbuild.patch	2022-03-22 08:54:47.430465041 +0800
+++ b/target/linux/generic/pending-4.9/403-mtd-hook-mtdsplit-to-Kbuild.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,32 +0,0 @@
-From: Gabor Juhos <juhosg@openwrt.org>
-Subject: [PATCH] kernel/3.10: move squashfs check from rootfs split code into a separate file
-
-lede-commit: d89bea92b31b4e157a0fa438e75370f089f73427
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/mtd/Kconfig  | 2 ++
- drivers/mtd/Makefile | 2 ++
- 2 files changed, 4 insertions(+)
-
---- a/drivers/mtd/Kconfig
-+++ b/drivers/mtd/Kconfig
-@@ -27,6 +27,8 @@ config MTD_SPLIT_FIRMWARE_NAME
- 	depends on MTD_SPLIT_FIRMWARE
- 	default "firmware"
- 
-+source "drivers/mtd/mtdsplit/Kconfig"
-+
- endmenu
- 
- config MTD_TESTS
---- a/drivers/mtd/Makefile
-+++ b/drivers/mtd/Makefile
-@@ -6,6 +6,8 @@
- obj-$(CONFIG_MTD)		+= mtd.o
- mtd-y				:= mtdcore.o mtdsuper.o mtdconcat.o mtdpart.o mtdchar.o
- 
-+obj-$(CONFIG_MTD_SPLIT)		+= mtdsplit/
-+
- obj-$(CONFIG_MTD_OF_PARTS)	+= ofpart.o
- obj-$(CONFIG_MTD_REDBOOT_PARTS) += redboot.o
- obj-$(CONFIG_MTD_CMDLINE_PARTS) += cmdlinepart.o
--- a/target/linux/generic/pending-4.9/404-mtd-add-more-helper-functions.patch	2022-03-22 08:54:47.430465041 +0800
+++ b/target/linux/generic/pending-4.9/404-mtd-add-more-helper-functions.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,76 +0,0 @@
-From: Gabor Juhos <juhosg@openwrt.org>
-Subject: kernel/3.10: add separate rootfs partition parser
-
-lede-commit: daec7ad7688415156e2730e401503d09bd3acf91
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/mtd/mtdpart.c          | 29 +++++++++++++++++++++++++++++
- include/linux/mtd/mtd.h        | 18 ++++++++++++++++++
- include/linux/mtd/partitions.h |  2 ++
- 3 files changed, 49 insertions(+)
-
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -1247,6 +1247,24 @@ int mtd_is_partition(const struct mtd_in
- }
- EXPORT_SYMBOL_GPL(mtd_is_partition);
- 
-+struct mtd_info *mtdpart_get_master(const struct mtd_info *mtd)
-+{
-+	if (!mtd_is_partition(mtd))
-+		return (struct mtd_info *)mtd;
-+
-+	return mtd_to_part(mtd)->parent;
-+}
-+EXPORT_SYMBOL_GPL(mtdpart_get_master);
-+
-+uint64_t mtdpart_get_offset(const struct mtd_info *mtd)
-+{
-+	if (!mtd_is_partition(mtd))
-+		return 0;
-+
-+	return mtd_to_part(mtd)->offset;
-+}
-+EXPORT_SYMBOL_GPL(mtdpart_get_offset);
-+
- /* Returns the size of the entire flash chip */
- uint64_t mtd_get_device_size(const struct mtd_info *mtd)
- {
---- a/include/linux/mtd/mtd.h
-+++ b/include/linux/mtd/mtd.h
-@@ -485,6 +485,24 @@ static inline uint32_t mtd_mod_by_eb(uin
- 	return do_div(sz, mtd->erasesize);
- }
- 
-+static inline uint64_t mtd_roundup_to_eb(uint64_t sz, struct mtd_info *mtd)
-+{
-+	if (mtd_mod_by_eb(sz, mtd) == 0)
-+		return sz;
-+
-+	/* Round up to next erase block */
-+	return (mtd_div_by_eb(sz, mtd) + 1) * mtd->erasesize;
-+}
-+
-+static inline uint64_t mtd_rounddown_to_eb(uint64_t sz, struct mtd_info *mtd)
-+{
-+	if (mtd_mod_by_eb(sz, mtd) == 0)
-+		return sz;
-+
-+	/* Round down to the start of the current erase block */
-+	return (mtd_div_by_eb(sz, mtd)) * mtd->erasesize;
-+}
-+
- static inline uint32_t mtd_div_by_ws(uint64_t sz, struct mtd_info *mtd)
- {
- 	if (mtd->writesize_shift)
---- a/include/linux/mtd/partitions.h
-+++ b/include/linux/mtd/partitions.h
-@@ -116,6 +116,8 @@ int mtd_is_partition(const struct mtd_in
- int mtd_add_partition(struct mtd_info *master, const char *name,
- 		      long long offset, long long length);
- int mtd_del_partition(struct mtd_info *master, int partno);
-+struct mtd_info *mtdpart_get_master(const struct mtd_info *mtd);
-+uint64_t mtdpart_get_offset(const struct mtd_info *mtd);
- uint64_t mtd_get_device_size(const struct mtd_info *mtd);
- 
- #endif
--- a/target/linux/generic/pending-4.9/411-mtd-partial_eraseblock_write.patch	2022-03-22 08:54:47.430465041 +0800
+++ b/target/linux/generic/pending-4.9/411-mtd-partial_eraseblock_write.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,154 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: mtd: implement write support for partitions covering only a part of an eraseblock (buffer data that would otherwise be erased)
-
-lede-commit: 87a8e8ac1067f58ba831c4aae443f3655c31cd80
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- drivers/mtd/mtdpart.c   | 90 ++++++++++++++++++++++++++++++++++++++++++++-----
- include/linux/mtd/mtd.h |  4 +++
- 2 files changed, 85 insertions(+), 9 deletions(-)
-
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -37,6 +37,8 @@
- #include "mtdcore.h"
- #include "mtdsplit/mtdsplit.h"
- 
-+#define MTD_ERASE_PARTIAL	0x8000 /* partition only covers parts of an erase block */
-+
- /* Our partition linked list */
- static LIST_HEAD(mtd_partitions);
- static DEFINE_MUTEX(mtd_partitions_mutex);
-@@ -246,13 +248,61 @@ static int part_erase(struct mtd_info *m
- 	struct mtd_part *part = mtd_to_part(mtd);
- 	int ret;
- 
-+
-+	instr->partial_start = false;
-+	if (mtd->flags & MTD_ERASE_PARTIAL) {
-+		size_t readlen = 0;
-+		u64 mtd_ofs;
-+
-+		instr->erase_buf = kmalloc(part->parent->erasesize, GFP_ATOMIC);
-+		if (!instr->erase_buf)
-+			return -ENOMEM;
-+
-+		mtd_ofs = part->offset + instr->addr;
-+		instr->erase_buf_ofs = do_div(mtd_ofs, part->parent->erasesize);
-+
-+		if (instr->erase_buf_ofs > 0) {
-+			instr->addr -= instr->erase_buf_ofs;
-+			ret = mtd_read(part->parent,
-+				instr->addr + part->offset,
-+				part->parent->erasesize,
-+				&readlen, instr->erase_buf);
-+
-+			instr->len += instr->erase_buf_ofs;
-+			instr->partial_start = true;
-+		} else {
-+			mtd_ofs = part->offset + part->mtd.size;
-+			instr->erase_buf_ofs = part->parent->erasesize -
-+				do_div(mtd_ofs, part->parent->erasesize);
-+
-+			if (instr->erase_buf_ofs > 0) {
-+				instr->len += instr->erase_buf_ofs;
-+				ret = mtd_read(part->parent,
-+					part->offset + instr->addr +
-+					instr->len - part->parent->erasesize,
-+					part->parent->erasesize, &readlen,
-+					instr->erase_buf);
-+			} else {
-+				ret = 0;
-+			}
-+		}
-+		if (ret < 0) {
-+			kfree(instr->erase_buf);
-+			return ret;
-+		}
-+
-+	}
-+
- 	instr->addr += part->offset;
- 	ret = part->parent->_erase(part->parent, instr);
- 	if (ret) {
- 		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
- 			instr->fail_addr -= part->offset;
- 		instr->addr -= part->offset;
-+		if (mtd->flags & MTD_ERASE_PARTIAL)
-+			kfree(instr->erase_buf);
- 	}
-+
- 	return ret;
- }
- 
-@@ -260,6 +310,25 @@ void mtd_erase_callback(struct erase_inf
- {
- 	if (instr->mtd->_erase == part_erase) {
- 		struct mtd_part *part = mtd_to_part(instr->mtd);
-+		size_t wrlen = 0;
-+
-+		if (instr->mtd->flags & MTD_ERASE_PARTIAL) {
-+			if (instr->partial_start) {
-+				part->parent->_write(part->parent,
-+					instr->addr, instr->erase_buf_ofs,
-+					&wrlen, instr->erase_buf);
-+				instr->addr += instr->erase_buf_ofs;
-+			} else {
-+				instr->len -= instr->erase_buf_ofs;
-+				part->parent->_write(part->parent,
-+					instr->addr + instr->len,
-+					instr->erase_buf_ofs, &wrlen,
-+					instr->erase_buf +
-+					part->parent->erasesize -
-+					instr->erase_buf_ofs);
-+			}
-+			kfree(instr->erase_buf);
-+		}
- 
- 		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
- 			instr->fail_addr -= part->offset;
-@@ -566,19 +635,22 @@ static struct mtd_part *allocate_partiti
- 	remainder = do_div(tmp, wr_alignment);
- 	if ((slave->mtd.flags & MTD_WRITEABLE) && remainder) {
- 		/* Doesn't start on a boundary of major erase size */
--		/* FIXME: Let it be writable if it is on a boundary of
--		 * _minor_ erase size though */
--		slave->mtd.flags &= ~MTD_WRITEABLE;
--		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase/write block boundary -- force read-only\n",
--			part->name);
-+		slave->mtd.flags |= MTD_ERASE_PARTIAL;
-+		if (((u32)slave->mtd.size) > parent->erasesize)
-+			slave->mtd.flags &= ~MTD_WRITEABLE;
-+		else
-+			slave->mtd.erasesize = slave->mtd.size;
- 	}
- 
--	tmp = slave->mtd.size;
-+	tmp = slave->offset + slave->mtd.size;
- 	remainder = do_div(tmp, wr_alignment);
- 	if ((slave->mtd.flags & MTD_WRITEABLE) && remainder) {
--		slave->mtd.flags &= ~MTD_WRITEABLE;
--		printk(KERN_WARNING"mtd: partition \"%s\" doesn't end on an erase/write block -- force read-only\n",
--			part->name);
-+		slave->mtd.flags |= MTD_ERASE_PARTIAL;
-+
-+		if ((u32)slave->mtd.size > parent->erasesize)
-+			slave->mtd.flags &= ~MTD_WRITEABLE;
-+		else
-+			slave->mtd.erasesize = slave->mtd.size;
- 	}
- 
- 	mtd_set_ooblayout(&slave->mtd, &part_ooblayout_ops);
---- a/include/linux/mtd/mtd.h
-+++ b/include/linux/mtd/mtd.h
-@@ -55,6 +55,10 @@ struct erase_info {
- 	u_long priv;
- 	u_char state;
- 	struct erase_info *next;
-+
-+	u8 *erase_buf;
-+	u32 erase_buf_ofs;
-+	bool partial_start;
- };
- 
- struct mtd_erase_region_info {
--- a/target/linux/generic/pending-4.9/412-mtd-partial_eraseblock_unlock.patch	2022-03-22 08:54:47.430465041 +0800
+++ b/target/linux/generic/pending-4.9/412-mtd-partial_eraseblock_unlock.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,40 +0,0 @@
-From: Tim Harvey <tharvey@gateworks.com>
-Subject: mtd: allow partial block unlock
-
-This allows sysupgrade for devices such as the Gateworks Avila/Cambria
-product families based on the ixp4xx using the redboot bootloader with
-combined FIS directory and RedBoot config partitions on larger FLASH
-devices with larger eraseblocks.
-
-This second iteration of this patch addresses previous issues:
-- whitespace breakage fixed
-- unlock in all scenarios
-- simplification and fix logic bug
-
-[john@phrozen.org: this should be moved to the ixp4xx folder]
-
-Signed-off-by: Tim Harvey <tharvey@gateworks.com>
----
- drivers/mtd/mtdpart.c | 11 ++++++++++-
- 1 file changed, 10 insertions(+), 1 deletion(-)
-
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -348,7 +348,16 @@ static int part_lock(struct mtd_info *mt
- static int part_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
- {
- 	struct mtd_part *part = mtd_to_part(mtd);
--	return part->parent->_unlock(part->parent, ofs + part->offset, len);
-+
-+	ofs += part->offset;
-+
-+	if (mtd->flags & MTD_ERASE_PARTIAL) {
-+		/* round up len to next erasesize and round down offset to prev block */
-+		len = (mtd_div_by_eb(len, part->parent) + 1) * part->parent->erasesize;
-+		ofs &= ~(part->parent->erasesize - 1);
-+	}
-+
-+	return part->parent->_unlock(part->parent, ofs, len);
- }
- 
- static int part_is_locked(struct mtd_info *mtd, loff_t ofs, uint64_t len)
--- a/target/linux/generic/pending-4.9/419-mtd-redboot-add-of_match_table-with-DT-binding.patch	2022-03-22 08:54:47.431465043 +0800
+++ b/target/linux/generic/pending-4.9/419-mtd-redboot-add-of_match_table-with-DT-binding.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,39 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Subject: [PATCH] mtd: redboot: add of_match_table with DT binding
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-This allows parsing RedBoot compatible partitions for properly described
-flash device in DT.
-
-Signed-off-by: Rafa Miecki <rafal@milecki.pl>
----
-
---- a/drivers/mtd/redboot.c
-+++ b/drivers/mtd/redboot.c
-@@ -29,6 +29,7 @@
- #include <linux/mtd/mtd.h>
- #include <linux/mtd/partitions.h>
- #include <linux/module.h>
-+#include <linux/mod_devicetable.h>
- 
- struct fis_image_desc {
-     unsigned char name[16];      // Null terminated name
-@@ -289,9 +290,16 @@ static int parse_redboot_partitions(stru
- 	return ret;
- }
- 
-+static const struct of_device_id redboot_parser_of_match_table[] = {
-+	{ .compatible = "ecoscentric,redboot-fis-partitions" },
-+	{},
-+};
-+MODULE_DEVICE_TABLE(of, redboot_parser_of_match_table);
-+
- static struct mtd_part_parser redboot_parser = {
- 	.parse_fn = parse_redboot_partitions,
- 	.name = "RedBoot",
-+	.of_match_table = redboot_parser_of_match_table,
- };
- module_mtd_part_parser(redboot_parser);
- 
--- a/target/linux/generic/pending-4.9/420-mtd-redboot_space.patch	2022-03-22 08:54:47.431465043 +0800
+++ b/target/linux/generic/pending-4.9/420-mtd-redboot_space.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,41 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: add patch for including unpartitioned space in the rootfs partition for redboot devices (if applicable)
-
-[john@phrozen.org: used by ixp and others]
-
-lede-commit: 394918851f84e4d00fa16eb900e7700e95091f00
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- drivers/mtd/redboot.c | 19 +++++++++++++------
- 1 file changed, 13 insertions(+), 6 deletions(-)
-
---- a/drivers/mtd/redboot.c
-+++ b/drivers/mtd/redboot.c
-@@ -266,14 +266,21 @@ static int parse_redboot_partitions(stru
- #endif
- 		names += strlen(names)+1;
- 
--#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED
- 		if(fl->next && fl->img->flash_base + fl->img->size + master->erasesize <= fl->next->img->flash_base) {
--			i++;
--			parts[i].offset = parts[i-1].size + parts[i-1].offset;
--			parts[i].size = fl->next->img->flash_base - parts[i].offset;
--			parts[i].name = nullname;
--		}
-+			if (!strcmp(parts[i].name, "rootfs")) {
-+				parts[i].size = fl->next->img->flash_base;
-+				parts[i].size &= ~(master->erasesize - 1);
-+				parts[i].size -= parts[i].offset;
-+#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED
-+				nrparts--;
-+			} else {
-+				i++;
-+				parts[i].offset = parts[i-1].size + parts[i-1].offset;
-+				parts[i].size = fl->next->img->flash_base - parts[i].offset;
-+				parts[i].name = nullname;
- #endif
-+			}
-+		}
- 		tmp_fl = fl;
- 		fl = fl->next;
- 		kfree(tmp_fl);
--- a/target/linux/generic/pending-4.9/430-mtd-add-myloader-partition-parser.patch	2022-03-22 08:54:47.431465043 +0800
+++ b/target/linux/generic/pending-4.9/430-mtd-add-myloader-partition-parser.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,47 +0,0 @@
-From: Florian Fainelli <f.fainelli@gmail.com>
-Subject: Add myloader partition table parser
-
-[john@phozen.org: shoud be upstreamable]
-
-lede-commit: d8bf22859b51faa09d22c056fe221a45d2f7a3b8
-Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
----
- drivers/mtd/Kconfig  | 16 ++++++++++++++++
- drivers/mtd/Makefile |  1 +
- 2 files changed, 17 insertions(+)
-
---- a/drivers/mtd/Kconfig
-+++ b/drivers/mtd/Kconfig
-@@ -178,6 +178,22 @@ menu "Partition parsers"
- source "drivers/mtd/parsers/Kconfig"
- endmenu
- 
-+config MTD_MYLOADER_PARTS
-+	tristate "MyLoader partition parsing"
-+	depends on ADM5120 || ATH25 || ATH79
-+	---help---
-+	  MyLoader is a bootloader which allows the user to define partitions
-+	  in flash devices, by putting a table in the second erase block
-+	  on the device, similar to a partition table. This table gives the 
-+	  offsets and lengths of the user defined partitions.
-+
-+	  If you need code which can detect and parse these tables, and
-+	  register MTD 'partitions' corresponding to each image detected,
-+	  enable this option.
-+
-+	  You will still need the parsing functions to be called by the driver
-+	  for your particular device. It won't happen automatically.
-+
- comment "User Modules And Translation Layers"
- 
- #
---- a/drivers/mtd/Makefile
-+++ b/drivers/mtd/Makefile
-@@ -15,6 +15,7 @@ obj-$(CONFIG_MTD_AFS_PARTS)	+= afs.o
- obj-$(CONFIG_MTD_AR7_PARTS)	+= ar7part.o
- obj-$(CONFIG_MTD_BCM63XX_PARTS)	+= bcm63xxpart.o
- obj-$(CONFIG_MTD_BCM47XX_PARTS)	+= bcm47xxpart.o
-+obj-$(CONFIG_MTD_MYLOADER_PARTS) += myloader.o
- obj-y				+= parsers/
- 
- # 'Users' - code which presents functionality to userspace.
--- a/target/linux/generic/pending-4.9/431-mtd-bcm47xxpart-check-for-bad-blocks-when-calculatin.patch	2022-03-22 08:54:47.431465043 +0800
+++ b/target/linux/generic/pending-4.9/431-mtd-bcm47xxpart-check-for-bad-blocks-when-calculatin.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,68 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
-Subject: [PATCH] mtd: bcm47xxpart: check for bad blocks when calculating offsets
-
-Signed-off-by: Rafa Miecki <zajec5@gmail.com>
----
-
---- a/drivers/mtd/parsers/parser_trx.c
-+++ b/drivers/mtd/parsers/parser_trx.c
-@@ -30,6 +30,33 @@ struct trx_header {
- 	uint32_t offset[3];
- } __packed;
- 
-+/*
-+ * Calculate real end offset (address) for a given amount of data. It checks
-+ * all blocks skipping bad ones.
-+ */
-+static size_t parser_trx_real_offset(struct mtd_info *mtd, size_t bytes)
-+{
-+	size_t real_offset = 0;
-+
-+	if (mtd_block_isbad(mtd, real_offset))
-+		pr_warn("Base offset shouldn't be at bad block");
-+
-+	while (bytes >= mtd->erasesize) {
-+		bytes -= mtd->erasesize;
-+		real_offset += mtd->erasesize;
-+		while (mtd_block_isbad(mtd, real_offset)) {
-+			real_offset += mtd->erasesize;
-+
-+			if (real_offset >= mtd->size)
-+				return real_offset - mtd->erasesize;
-+		}
-+	}
-+
-+	real_offset += bytes;
-+
-+	return real_offset;
-+}
-+
- static const char *parser_trx_data_part_name(struct mtd_info *master,
- 					     size_t offset)
- {
-@@ -84,21 +111,21 @@ static int parser_trx_parse(struct mtd_i
- 	if (trx.offset[2]) {
- 		part = &parts[curr_part++];
- 		part->name = "loader";
--		part->offset = trx.offset[i];
-+		part->offset = parser_trx_real_offset(mtd, trx.offset[i]);
- 		i++;
- 	}
- 
- 	if (trx.offset[i]) {
- 		part = &parts[curr_part++];
- 		part->name = "linux";
--		part->offset = trx.offset[i];
-+		part->offset = parser_trx_real_offset(mtd, trx.offset[i]);
- 		i++;
- 	}
- 
- 	if (trx.offset[i]) {
- 		part = &parts[curr_part++];
--		part->name = parser_trx_data_part_name(mtd, trx.offset[i]);
--		part->offset = trx.offset[i];
-+		part->offset = parser_trx_real_offset(mtd, trx.offset[i]);
-+		part->name = parser_trx_data_part_name(mtd, part->offset);
- 		i++;
- 	}
- 
--- a/target/linux/generic/pending-4.9/432-mtd-bcm47xxpart-detect-T_Meter-partition.patch	2022-03-22 08:54:47.432465044 +0800
+++ b/target/linux/generic/pending-4.9/432-mtd-bcm47xxpart-detect-T_Meter-partition.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,37 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
-Subject: mtd: bcm47xxpart: detect T_Meter partition
-
-It can be found on many Netgear devices. It consists of many 0x30 blocks
-starting with 4D 54.
-
-Signed-off-by: Rafa Miecki <zajec5@gmail.com>
----
- drivers/mtd/bcm47xxpart.c | 10 ++++++++++
- 1 file changed, 10 insertions(+)
-
---- a/drivers/mtd/bcm47xxpart.c
-+++ b/drivers/mtd/bcm47xxpart.c
-@@ -40,6 +40,7 @@
- #define NVRAM_HEADER			0x48534C46	/* FLSH */
- #define POT_MAGIC1			0x54544f50	/* POTT */
- #define POT_MAGIC2			0x504f		/* OP */
-+#define T_METER_MAGIC			0x4D540000	/* MT */
- #define ML_MAGIC1			0x39685a42
- #define ML_MAGIC2			0x26594131
- #define TRX_MAGIC			0x30524448
-@@ -183,6 +184,15 @@ static int bcm47xxpart_parse(struct mtd_
- 					     MTD_WRITEABLE);
- 			continue;
- 		}
-+
-+		/* T_Meter */
-+		if ((le32_to_cpu(buf[0x000 / 4]) & 0xFFFF0000) == T_METER_MAGIC &&
-+		    (le32_to_cpu(buf[0x030 / 4]) & 0xFFFF0000) == T_METER_MAGIC &&
-+		    (le32_to_cpu(buf[0x060 / 4]) & 0xFFFF0000) == T_METER_MAGIC) {
-+			bcm47xxpart_add_part(&parts[curr_part++], "T_Meter", offset,
-+					     MTD_WRITEABLE);
-+			continue;
-+		}
- 
- 		/* TRX */
- 		if (buf[0x000 / 4] == TRX_MAGIC) {
--- a/target/linux/generic/pending-4.9/440-block2mtd_init.patch	2022-03-22 08:54:47.432465044 +0800
+++ b/target/linux/generic/pending-4.9/440-block2mtd_init.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,116 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: block2mtd
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- drivers/mtd/devices/block2mtd.c | 30 ++++++++++++++++++++----------
- 1 file changed, 20 insertions(+), 10 deletions(-)
-
---- a/drivers/mtd/devices/block2mtd.c
-+++ b/drivers/mtd/devices/block2mtd.c
-@@ -26,6 +26,7 @@
- #include <linux/list.h>
- #include <linux/init.h>
- #include <linux/mtd/mtd.h>
-+#include <linux/mtd/partitions.h>
- #include <linux/mutex.h>
- #include <linux/mount.h>
- #include <linux/slab.h>
-@@ -219,7 +220,7 @@ static void block2mtd_free_device(struct
- 
- 
- static struct block2mtd_dev *add_device(char *devname, int erase_size,
--		int timeout)
-+		const char *mtdname, int timeout)
- {
- #ifndef MODULE
- 	int i;
-@@ -227,6 +228,7 @@ static struct block2mtd_dev *add_device(
- 	const fmode_t mode = FMODE_READ | FMODE_WRITE | FMODE_EXCL;
- 	struct block_device *bdev = ERR_PTR(-ENODEV);
- 	struct block2mtd_dev *dev;
-+	struct mtd_partition *part;
- 	char *name;
- 
- 	if (!devname)
-@@ -283,13 +285,16 @@ static struct block2mtd_dev *add_device(
- 
- 	/* Setup the MTD structure */
- 	/* make the name contain the block device in */
--	name = kasprintf(GFP_KERNEL, "block2mtd: %s", devname);
-+	if (!mtdname)
-+		mtdname = devname;
-+	name = kmalloc(strlen(mtdname) + 1, GFP_KERNEL);
- 	if (!name)
- 		goto err_destroy_mutex;
- 
-+	strcpy(name, mtdname);
- 	dev->mtd.name = name;
- 
--	dev->mtd.size = dev->blkdev->bd_inode->i_size & PAGE_MASK;
-+	dev->mtd.size = dev->blkdev->bd_inode->i_size & PAGE_MASK & ~(erase_size - 1);
- 	dev->mtd.erasesize = erase_size;
- 	dev->mtd.writesize = 1;
- 	dev->mtd.writebufsize = PAGE_SIZE;
-@@ -302,7 +307,11 @@ static struct block2mtd_dev *add_device(
- 	dev->mtd.priv = dev;
- 	dev->mtd.owner = THIS_MODULE;
- 
--	if (mtd_device_register(&dev->mtd, NULL, 0)) {
-+	part = kzalloc(sizeof(struct mtd_partition), GFP_KERNEL);
-+	part->name = name;
-+	part->offset = 0;
-+	part->size = dev->mtd.size;
-+	if (mtd_device_register(&dev->mtd, part, 1)) {
- 		/* Device didn't get added, so free the entry */
- 		goto err_destroy_mutex;
- 	}
-@@ -310,8 +319,7 @@ static struct block2mtd_dev *add_device(
- 	list_add(&dev->list, &blkmtd_device_list);
- 	pr_info("mtd%d: [%s] erase_size = %dKiB [%d]\n",
- 		dev->mtd.index,
--		dev->mtd.name + strlen("block2mtd: "),
--		dev->mtd.erasesize >> 10, dev->mtd.erasesize);
-+		mtdname, dev->mtd.erasesize >> 10, dev->mtd.erasesize);
- 	return dev;
- 
- err_destroy_mutex:
-@@ -384,7 +392,7 @@ static int block2mtd_setup2(const char *
- 	/* 80 for device, 12 for erase size, 80 for name, 8 for timeout */
- 	char buf[80 + 12 + 80 + 8];
- 	char *str = buf;
--	char *token[2];
-+	char *token[3];
- 	char *name;
- 	size_t erase_size = PAGE_SIZE;
- 	unsigned long timeout = MTD_DEFAULT_TIMEOUT;
-@@ -398,7 +406,7 @@ static int block2mtd_setup2(const char *
- 	strcpy(str, val);
- 	kill_final_newline(str);
- 
--	for (i = 0; i < 2; i++)
-+	for (i = 0; i < 3; i++)
- 		token[i] = strsep(&str, ",");
- 
- 	if (str) {
-@@ -424,8 +432,10 @@ static int block2mtd_setup2(const char *
- 			return 0;
- 		}
- 	}
-+	if (token[2] && (strlen(token[2]) + 1 > 80))
-+		pr_err("mtd device name too long\n");
- 
--	add_device(name, erase_size, timeout);
-+	add_device(name, erase_size, token[2], timeout);
- 
- 	return 0;
- }
-@@ -459,7 +469,7 @@ static int block2mtd_setup(const char *v
- 
- 
- module_param_call(block2mtd, block2mtd_setup, NULL, NULL, 0200);
--MODULE_PARM_DESC(block2mtd, "Device to use. \"block2mtd=<dev>[,<erasesize>]\"");
-+MODULE_PARM_DESC(block2mtd, "Device to use. \"block2mtd=<dev>[,<erasesize>[,<name>]]\"");
- 
- static int __init block2mtd_init(void)
- {
--- a/target/linux/generic/pending-4.9/441-block2mtd_probe.patch	2022-03-22 08:54:47.432465044 +0800
+++ b/target/linux/generic/pending-4.9/441-block2mtd_probe.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,47 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: block2mtd
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- drivers/mtd/devices/block2mtd.c | 9 ++++++---
- 1 file changed, 6 insertions(+), 3 deletions(-)
-
---- a/drivers/mtd/devices/block2mtd.c
-+++ b/drivers/mtd/devices/block2mtd.c
-@@ -392,7 +392,7 @@ static int block2mtd_setup2(const char *
- 	/* 80 for device, 12 for erase size, 80 for name, 8 for timeout */
- 	char buf[80 + 12 + 80 + 8];
- 	char *str = buf;
--	char *token[3];
-+	char *token[4];
- 	char *name;
- 	size_t erase_size = PAGE_SIZE;
- 	unsigned long timeout = MTD_DEFAULT_TIMEOUT;
-@@ -406,7 +406,7 @@ static int block2mtd_setup2(const char *
- 	strcpy(str, val);
- 	kill_final_newline(str);
- 
--	for (i = 0; i < 3; i++)
-+	for (i = 0; i < 4; i++)
- 		token[i] = strsep(&str, ",");
- 
- 	if (str) {
-@@ -435,6 +435,9 @@ static int block2mtd_setup2(const char *
- 	if (token[2] && (strlen(token[2]) + 1 > 80))
- 		pr_err("mtd device name too long\n");
- 
-+	if (token[3] && kstrtoul(token[3], 0, &timeout))
-+		pr_err("invalid timeout\n");
-+
- 	add_device(name, erase_size, token[2], timeout);
- 
- 	return 0;
-@@ -469,7 +472,7 @@ static int block2mtd_setup(const char *v
- 
- 
- module_param_call(block2mtd, block2mtd_setup, NULL, NULL, 0200);
--MODULE_PARM_DESC(block2mtd, "Device to use. \"block2mtd=<dev>[,<erasesize>[,<name>]]\"");
-+MODULE_PARM_DESC(block2mtd, "Device to use. \"block2mtd=<dev>[,<erasesize>[,<name>[,<timeout>]]]\"");
- 
- static int __init block2mtd_init(void)
- {
--- a/target/linux/generic/pending-4.9/450-mtd-m25p80-allow-fallback-from-spi_flash_read-to-reg.patch	2022-03-22 08:54:47.432465044 +0800
+++ b/target/linux/generic/pending-4.9/450-mtd-m25p80-allow-fallback-from-spi_flash_read-to-reg.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,36 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 23 Feb 2018 17:12:16 +0100
-Subject: [PATCH] mtd: m25p80: allow fallback from spi_flash_read to regular
- SPI transfer
-
-Some flash controllers, e.g. on the ath79 platform can support a fast
-flash read via memory mapping, but only if the flash chip is in
-3-byte address mode.
-
-Since spi_flash_read_supported does not have access to the same data as
-spi_flash_read, the driver can't detect an unsupported call until m25p80
-has decided to use spi_flash_read.
-
-Allow the driver to indicate a fallback to a regular SPI transfer by
-returning -EOPNOTSUPP
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/drivers/mtd/devices/m25p80.c
-+++ b/drivers/mtd/devices/m25p80.c
-@@ -155,9 +155,11 @@ static ssize_t m25p80_read(struct spi_no
- 		msg.data_nbits = m25p80_rx_nbits(nor);
- 
- 		ret = spi_flash_read(spi, &msg);
--		if (ret < 0)
--			return ret;
--		return msg.retlen;
-+		if (ret != -EOPNOTSUPP) {
-+			if (ret < 0)
-+				return ret;
-+			return msg.retlen;
-+		}
- 	}
- 
- 	spi_message_init(&m);
--- a/target/linux/generic/pending-4.9/460-mtd-cfi_cmdset_0002-no-erase_suspend.patch	2022-03-22 08:54:47.433465046 +0800
+++ b/target/linux/generic/pending-4.9/460-mtd-cfi_cmdset_0002-no-erase_suspend.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,25 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: kernel: disable cfi cmdset 0002 erase suspend
-
-on some platforms, erase suspend leads to data corruption and lockups when write
-ops collide with erase ops. this has been observed on the buffalo wzr-hp-g300nh.
-rather than play whack-a-mole with a hard to reproduce issue on a variety of devices,
-simply disable erase suspend, as it will usually not produce any useful gain on
-the small filesystems used on embedded hardware.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- drivers/mtd/chips/cfi_cmdset_0002.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/drivers/mtd/chips/cfi_cmdset_0002.c
-+++ b/drivers/mtd/chips/cfi_cmdset_0002.c
-@@ -807,7 +807,7 @@ static int get_chip(struct map_info *map
- 		return 0;
- 
- 	case FL_ERASING:
--		if (!cfip || !(cfip->EraseSuspend & (0x1|0x2)) ||
-+		if (1 /* no suspend */ || !cfip || !(cfip->EraseSuspend & (0x1|0x2)) ||
- 		    !(mode == FL_READY || mode == FL_POINT ||
- 		    (mode == FL_WRITING && (cfip->EraseSuspend & 0x2))))
- 			goto sleep;
--- a/target/linux/generic/pending-4.9/461-mtd-cfi_cmdset_0002-add-buffer-write-cmd-timeout.patch	2022-03-22 08:54:47.433465046 +0800
+++ b/target/linux/generic/pending-4.9/461-mtd-cfi_cmdset_0002-add-buffer-write-cmd-timeout.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,17 +0,0 @@
-From: George Kashperko <george@znau.edu.ua>
-Subject: Issue map read after Write Buffer Load command to ensure chip is ready to receive data.
-
-Signed-off-by: George Kashperko <george@znau.edu.ua>
----
- drivers/mtd/chips/cfi_cmdset_0002.c |    1 +
- 1 file changed, 1 insertion(+)
---- a/drivers/mtd/chips/cfi_cmdset_0002.c
-+++ b/drivers/mtd/chips/cfi_cmdset_0002.c
-@@ -1835,6 +1835,7 @@ static int __xipram do_write_buffer(stru
- 
- 	/* Write Buffer Load */
- 	map_write(map, CMD(0x25), cmd_adr);
-+	(void) map_read(map, cmd_adr);
- 
- 	chip->state = FL_WRITING_TO_BUFFER;
- 
--- a/target/linux/generic/pending-4.9/465-m25p80-mx-disable-software-protection.patch	2022-03-22 08:54:47.433465046 +0800
+++ b/target/linux/generic/pending-4.9/465-m25p80-mx-disable-software-protection.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,18 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: Disable software protection bits for Macronix flashes.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- drivers/mtd/spi-nor/spi-nor.c | 1 +
- 1 file changed, 1 insertion(+)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -1601,6 +1601,7 @@ int spi_nor_scan(struct spi_nor *nor, co
- 
- 	if (JEDEC_MFR(info) == SNOR_MFR_ATMEL ||
- 	    JEDEC_MFR(info) == SNOR_MFR_INTEL ||
-+	    JEDEC_MFR(info) == SNOR_MFR_MACRONIX ||
- 	    JEDEC_MFR(info) == SNOR_MFR_SST ||
- 	    info->flags & SPI_NOR_HAS_LOCK) {
- 		write_enable(nor);
--- a/target/linux/generic/pending-4.9/466-Revert-mtd-spi-nor-fix-Spansion-regressions-aliased-.patch	2022-03-22 08:54:47.433465046 +0800
+++ b/target/linux/generic/pending-4.9/466-Revert-mtd-spi-nor-fix-Spansion-regressions-aliased-.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,37 +0,0 @@
-From: Matthias Schiffer <mschiffer@universe-factory.net>
-Date: Tue, 9 Jan 2018 20:41:48 +0100
-Subject: [PATCH] Revert "mtd: spi-nor: fix Spansion regressions (aliased with
- Winbond)"
-
-This reverts commit 67b9bcd36906e12a15ffec19463afbbd6a41660e.
-
-The underlying issue breaking Spansion flash has been fixed with "mtd: spi-nor:
-wait until lock/unlock operations are ready" and "mtd: spi-nor: wait for SR_WIP
-to clear on initial unlock", so we can support unlocking for Winbond flash
-again.
-
-Signed-off-by: Matthias Schiffer <mschiffer@universe-factory.net>
----
- drivers/mtd/spi-nor/spi-nor.c | 4 +++-
- 1 file changed, 3 insertions(+), 1 deletion(-)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -1603,6 +1603,7 @@ int spi_nor_scan(struct spi_nor *nor, co
- 	    JEDEC_MFR(info) == SNOR_MFR_INTEL ||
- 	    JEDEC_MFR(info) == SNOR_MFR_MACRONIX ||
- 	    JEDEC_MFR(info) == SNOR_MFR_SST ||
-+	    JEDEC_MFR(info) == SNOR_MFR_WINBOND ||
- 	    info->flags & SPI_NOR_HAS_LOCK) {
- 		write_enable(nor);
- 		write_sr(nor, 0);
-@@ -1621,7 +1622,8 @@ int spi_nor_scan(struct spi_nor *nor, co
- 
- 	/* NOR protection support for STmicro/Micron chips and similar */
- 	if (JEDEC_MFR(info) == SNOR_MFR_MICRON ||
--			info->flags & SPI_NOR_HAS_LOCK) {
-+	    JEDEC_MFR(info) == SNOR_MFR_WINBOND ||
-+	    info->flags & SPI_NOR_HAS_LOCK) {
- 		nor->flash_lock = stm_lock;
- 		nor->flash_unlock = stm_unlock;
- 		nor->flash_is_locked = stm_is_locked;
--- a/target/linux/generic/pending-4.9/470-mtd-spi-nor-support-limiting-4K-sectors-support-base.patch	2022-03-22 08:54:47.434465048 +0800
+++ b/target/linux/generic/pending-4.9/470-mtd-spi-nor-support-limiting-4K-sectors-support-base.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,56 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 4 Nov 2017 07:40:23 +0100
-Subject: [PATCH] mtd: spi-nor: support limiting 4K sectors support based on
- flash size
-
-Some devices need 4K sectors to be able to deal with small flash chips.
-For instance, w25x05 is 64 KiB in size, and without 4K sectors, the
-entire chip is just one erase block.
-On bigger flash chip sizes, using 4K sectors can significantly slow down
-many operations, including using a writable filesystem. There are several
-platforms where it makes sense to use a single kernel on both kinds of
-devices.
-
-To support this properly, allow configuring an upper flash chip size
-limit for 4K sectors support.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/drivers/mtd/spi-nor/Kconfig
-+++ b/drivers/mtd/spi-nor/Kconfig
-@@ -29,6 +29,17 @@ config MTD_SPI_NOR_USE_4K_SECTORS
- 	  Please note that some tools/drivers/filesystems may not work with
- 	  4096 B erase size (e.g. UBIFS requires 15 KiB as a minimum).
- 
-+config MTD_SPI_NOR_USE_4K_SECTORS_LIMIT
-+	int "Maximum flash chip size to use 4K sectors on (in KiB)"
-+	depends on MTD_SPI_NOR_USE_4K_SECTORS
-+	default "4096"
-+	help
-+	  There are many flash chips that support 4K sectors, but are so large
-+	  that using them significantly slows down writing large amounts of
-+	  data or using a writable filesystem.
-+	  Any flash chip larger than the size specified in this option will
-+	  not use 4K sectors.
-+
- config SPI_ATMEL_QUADSPI
- 	tristate "Atmel Quad SPI Controller"
- 	depends on ARCH_AT91 || (ARM && COMPILE_TEST && !ARCH_EBSA110)
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -1648,10 +1648,12 @@ int spi_nor_scan(struct spi_nor *nor, co
- 
- #ifdef CONFIG_MTD_SPI_NOR_USE_4K_SECTORS
- 	/* prefer "small sector" erase if possible */
--	if (info->flags & SECT_4K) {
-+	if ((info->flags & SECT_4K) && (mtd->size <=
-+	    CONFIG_MTD_SPI_NOR_USE_4K_SECTORS_LIMIT * 1024)) {
- 		nor->erase_opcode = SPINOR_OP_BE_4K;
- 		mtd->erasesize = 4096;
--	} else if (info->flags & SECT_4K_PMC) {
-+	} else if ((info->flags & SECT_4K_PMC) && (mtd->size <=
-+		   CONFIG_MTD_SPI_NOR_USE_4K_SECTORS_LIMIT * 1024)) {
- 		nor->erase_opcode = SPINOR_OP_BE_4K_PMC;
- 		mtd->erasesize = 4096;
- 	} else
--- a/target/linux/generic/pending-4.9/475-mtd-spi-nor-Add-Winbond-w25q128jv-support.patch	2022-03-22 08:54:47.434465048 +0800
+++ b/target/linux/generic/pending-4.9/475-mtd-spi-nor-Add-Winbond-w25q128jv-support.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,34 +0,0 @@
-From: Robert Marko <robimarko@gmail.com>
-To: linux-mtd@lists.infradead.org
-Subject: mtd: spi-nor: Add Winbond w25q128jv support
-Date: Mon, 25 Jun 2018 13:17:48 +0200
-
-Datasheet:
-http://www.winbond.com/resource-files/w25q128jv%20revf%2003272018%20plus.pdf
-
-Testing done on Mikrotik Routerboard  wAP R board.
-It does not support Dual or Quad modes.
-
-Signed-off-by: Robert Marko <robimarko@gmail.com>
----
-
-Changes in v2:
-	- Correct the title
----
- drivers/mtd/spi-nor/spi-nor.c | 5 +++++
- 1 file changed, 5 insertions(+)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -1152,6 +1152,11 @@ static const struct flash_info spi_nor_i
- 			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
- 			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
- 	},
-+	{
-+		"w25q128jv", INFO(0xef7018, 0, 64 * 1024, 256,
-+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
-+			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
-+	},
- 	{ "w25q80", INFO(0xef5014, 0, 64 * 1024,  16, SECT_4K) },
- 	{ "w25q80bl", INFO(0xef4014, 0, 64 * 1024,  16, SECT_4K) },
- 	{ "w25q128", INFO(0xef4018, 0, 64 * 1024, 256, SECT_4K) },
--- a/target/linux/generic/pending-4.9/476-mtd-spi-nor-add-eon-en25q128.patch	2022-03-22 08:54:47.434465048 +0800
+++ b/target/linux/generic/pending-4.9/476-mtd-spi-nor-add-eon-en25q128.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,18 +0,0 @@
-From: Piotr Dymacz <pepe2k@gmail.com>
-Subject: kernel/mtd: add support for EON EN25Q128
-
-Signed-off-by: Piotr Dymacz <pepe2k@gmail.com>
----
- drivers/mtd/spi-nor/spi-nor.c | 1 +
- 1 file changed, 1 insertion(+)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -954,6 +954,7 @@ static const struct flash_info spi_nor_i
- 	{ "en25q32b",   INFO(0x1c3016, 0, 64 * 1024,   64, 0) },
- 	{ "en25p64",    INFO(0x1c2017, 0, 64 * 1024,  128, 0) },
- 	{ "en25q64",    INFO(0x1c3017, 0, 64 * 1024,  128, SECT_4K) },
-+	{ "en25q128",   INFO(0x1c3018, 0, 64 * 1024,  256, SECT_4K) },
- 	{ "en25qh128",  INFO(0x1c7018, 0, 64 * 1024,  256, 0) },
- 	{ "en25qh256",  INFO(0x1c7019, 0, 64 * 1024,  512, 0) },
- 	{ "en25s64",	INFO(0x1c3817, 0, 64 * 1024,  128, SECT_4K) },
--- a/target/linux/generic/pending-4.9/477-mtd-add-spi-nor-add-mx25u3235f.patch	2022-03-22 08:54:47.434465048 +0800
+++ b/target/linux/generic/pending-4.9/477-mtd-add-spi-nor-add-mx25u3235f.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,18 +0,0 @@
-From: Andr Valentin <avalentin@marcant.net>
-Subject: linux/mtd: add id for mx25u3235f needed by ZyXEL NBG6817
-
-Signed-off-by: Andr Valentin <avalentin@marcant.net>
----
- drivers/mtd/spi-nor/spi-nor.c | 1 +
- 1 file changed, 1 insertion(+)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -1020,6 +1020,7 @@ static const struct flash_info spi_nor_i
- 	{ "mx25l3205d",  INFO(0xc22016, 0, 64 * 1024,  64, SECT_4K) },
- 	{ "mx25l3255e",  INFO(0xc29e16, 0, 64 * 1024,  64, SECT_4K) },
- 	{ "mx25l6405d",  INFO(0xc22017, 0, 64 * 1024, 128, SECT_4K) },
-+	{ "mx25u3235f",	 INFO(0xc22536, 0, 64 * 1024, 64, 0) },
- 	{ "mx25u6435f",  INFO(0xc22537, 0, 64 * 1024, 128, SECT_4K) },
- 	{ "mx25l12805d", INFO(0xc22018, 0, 64 * 1024, 256, 0) },
- 	{ "mx25l12855e", INFO(0xc22618, 0, 64 * 1024, 256, 0) },
--- a/target/linux/generic/pending-4.9/478-mtd-spi-nor-Add-support-for-XM25QH64A-and-XM25QH128A.patch	2022-03-22 08:54:47.435465049 +0800
+++ b/target/linux/generic/pending-4.9/478-mtd-spi-nor-Add-support-for-XM25QH64A-and-XM25QH128A.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,30 +0,0 @@
-From b02f3405c935a28200db26b63e42086057565cf4 Mon Sep 17 00:00:00 2001
-From: Hauke Mehrtens <hauke@hauke-m.de>
-Date: Sat, 31 Mar 2018 20:09:54 +0200
-Subject: [PATCH] mtd: spi-nor: Add support for XM25QH64A and XM25QH128A
-
-These devices are produced by Wuhan Xinxin Semiconductor Manufacturing
-Corp. (XMC) and found on some routers from Chinese manufactures.
-
-The data sheets can be found here:
-http://www.xmcwh.com/Uploads/2018-03-01/5a9799e4cb355.pdf
-http://www.xmcwh.com/Uploads/2018-02-05/5a77e6dbe968b.pdf
-
-Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
----
- drivers/mtd/spi-nor/spi-nor.c | 4 ++++
- 1 file changed, 4 insertions(+)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -1177,6 +1177,10 @@ static const struct flash_info spi_nor_i
- 	{ "3S400AN", S3AN_INFO(0x1f2400, 256, 264) },
- 	{ "3S700AN", S3AN_INFO(0x1f2500, 512, 264) },
- 	{ "3S1400AN", S3AN_INFO(0x1f2600, 512, 528) },
-+
-+	/* XMC (Wuhan Xinxin Semiconductor Manufacturing Corp.) */
-+	{ "XM25QH64A", INFO(0x207017, 0, 64 * 1024, 128, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
-+	{ "XM25QH128A", INFO(0x207018, 0, 64 * 1024, 256, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
- 	{ },
- };
- 
--- a/target/linux/generic/pending-4.9/479-mtd-spi-nor-add-eon-en25qh32.patch	2022-03-22 08:54:47.435465049 +0800
+++ b/target/linux/generic/pending-4.9/479-mtd-spi-nor-add-eon-en25qh32.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,10 +0,0 @@
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -955,6 +955,7 @@ static const struct flash_info spi_nor_i
- 	{ "en25p64",    INFO(0x1c2017, 0, 64 * 1024,  128, 0) },
- 	{ "en25q64",    INFO(0x1c3017, 0, 64 * 1024,  128, SECT_4K) },
- 	{ "en25q128",   INFO(0x1c3018, 0, 64 * 1024,  256, SECT_4K) },
-+	{ "en25qh32",   INFO(0x1c7016, 0, 64 * 1024,   64, 0) },
- 	{ "en25qh128",  INFO(0x1c7018, 0, 64 * 1024,  256, 0) },
- 	{ "en25qh256",  INFO(0x1c7019, 0, 64 * 1024,  512, 0) },
- 	{ "en25s64",	INFO(0x1c3817, 0, 64 * 1024,  128, SECT_4K) },
--- a/target/linux/generic/pending-4.9/480-mtd-set-rootfs-to-be-root-dev.patch	2022-03-22 08:54:47.435465049 +0800
+++ b/target/linux/generic/pending-4.9/480-mtd-set-rootfs-to-be-root-dev.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,38 +0,0 @@
-From: Gabor Juhos <juhosg@openwrt.org>
-Subject: kernel/3.1[02]: move MTD root device setup code to mtdcore
-
-The current code only allows to automatically set
-root device on MTD partitions. Move the code to MTD
-core to allow to use it with all MTD devices.
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/mtd/mtdcore.c | 10 ++++++++++
- 1 file changed, 10 insertions(+)
-
---- a/drivers/mtd/mtdcore.c
-+++ b/drivers/mtd/mtdcore.c
-@@ -40,6 +40,7 @@
- #include <linux/slab.h>
- #include <linux/reboot.h>
- #include <linux/leds.h>
-+#include <linux/root_dev.h>
- 
- #include <linux/mtd/mtd.h>
- #include <linux/mtd/partitions.h>
-@@ -570,6 +571,15 @@ int add_mtd_device(struct mtd_info *mtd)
- 	   of this try_ nonsense, and no bitching about it
- 	   either. :) */
- 	__module_get(THIS_MODULE);
-+
-+	if (!strcmp(mtd->name, "rootfs") &&
-+	    IS_ENABLED(CONFIG_MTD_ROOTFS_ROOT_DEV) &&
-+	    ROOT_DEV == 0) {
-+		pr_notice("mtd: device %d (%s) set to be root filesystem\n",
-+			  mtd->index, mtd->name);
-+		ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, mtd->index);
-+	}
-+
- 	return 0;
- 
- fail_added:
--- a/target/linux/generic/pending-4.9/490-ubi-auto-attach-mtd-device-named-ubi-or-data-on-boot.patch	2022-03-22 08:54:47.435465049 +0800
+++ b/target/linux/generic/pending-4.9/490-ubi-auto-attach-mtd-device-named-ubi-or-data-on-boot.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,97 +0,0 @@
-From: Daniel Golle <daniel@makrotopia.org>
-Subject: ubi: auto-attach mtd device named "ubi" or "data" on boot
-
-Signed-off-by: Daniel Golle <daniel@makrotopia.org>
----
- drivers/mtd/ubi/build.c | 36 ++++++++++++++++++++++++++++++++++++
- 1 file changed, 36 insertions(+)
-
---- a/drivers/mtd/ubi/build.c
-+++ b/drivers/mtd/ubi/build.c
-@@ -1226,6 +1226,73 @@ static struct mtd_info * __init open_mtd
- 	return mtd;
- }
- 
-+/*
-+ * This function tries attaching mtd partitions named either "ubi" or "data"
-+ * during boot.
-+ */
-+static void __init ubi_auto_attach(void)
-+{
-+	int err;
-+	struct mtd_info *mtd;
-+	loff_t offset = 0;
-+	size_t len;
-+	char magic[4];
-+
-+	/* try attaching mtd device named "ubi" or "data" */
-+	mtd = open_mtd_device("ubi");
-+	if (IS_ERR(mtd))
-+		mtd = open_mtd_device("data");
-+
-+	if (IS_ERR(mtd))
-+		return;
-+
-+	/* get the first not bad block */
-+	if (mtd_can_have_bb(mtd))
-+		while (mtd_block_isbad(mtd, offset)) {
-+			offset += mtd->erasesize;
-+
-+			if (offset > mtd->size) {
-+				pr_err("UBI error: Failed to find a non-bad "
-+				       "block on mtd%d\n", mtd->index);
-+				goto cleanup;
-+			}
-+		}
-+
-+	/* check if the read from flash was successful */
-+	err = mtd_read(mtd, offset, 4, &len, (void *) magic);
-+	if ((err && !mtd_is_bitflip(err)) || len != 4) {
-+		pr_err("UBI error: unable to read from mtd%d\n", mtd->index);
-+		goto cleanup;
-+	}
-+
-+	/* check for a valid ubi magic */
-+	if (strncmp(magic, "UBI#", 4)) {
-+		pr_err("UBI error: no valid UBI magic found inside mtd%d\n", mtd->index);
-+		goto cleanup;
-+	}
-+
-+	/* don't auto-add media types where UBI doesn't makes sense */
-+	if (mtd->type != MTD_NANDFLASH &&
-+	    mtd->type != MTD_NORFLASH &&
-+	    mtd->type != MTD_DATAFLASH &&
-+	    mtd->type != MTD_MLCNANDFLASH)
-+		goto cleanup;
-+
-+	mutex_lock(&ubi_devices_mutex);
-+	pr_notice("UBI: auto-attach mtd%d\n", mtd->index);
-+	err = ubi_attach_mtd_dev(mtd, UBI_DEV_NUM_AUTO, 0, 0);
-+	mutex_unlock(&ubi_devices_mutex);
-+	if (err < 0) {
-+		pr_err("UBI error: cannot attach mtd%d\n", mtd->index);
-+		goto cleanup;
-+	}
-+
-+	return;
-+
-+cleanup:
-+	put_mtd_device(mtd);
-+}
-+
- static int __init ubi_init(void)
- {
- 	int err, i, k;
-@@ -1309,6 +1376,12 @@ static int __init ubi_init(void)
- 		}
- 	}
- 
-+	/* auto-attach mtd devices only if built-in to the kernel and no ubi.mtd
-+	 * parameter was given */
-+	if (IS_ENABLED(CONFIG_MTD_ROOTFS_ROOT_DEV) &&
-+	    !ubi_is_module() && !mtd_devs)
-+		ubi_auto_attach();
-+
- 	err = ubiblock_init();
- 	if (err) {
- 		pr_err("UBI error: block: cannot initialize, error %d", err);
--- a/target/linux/generic/pending-4.9/491-ubi-auto-create-ubiblock-device-for-rootfs.patch	2022-03-22 08:54:47.436465051 +0800
+++ b/target/linux/generic/pending-4.9/491-ubi-auto-create-ubiblock-device-for-rootfs.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,66 +0,0 @@
-From: Daniel Golle <daniel@makrotopia.org>
-Subject: ubi: auto-create ubiblock device for rootfs
-
-Signed-off-by: Daniel Golle <daniel@makrotopia.org>
----
- drivers/mtd/ubi/block.c | 42 ++++++++++++++++++++++++++++++++++++++++++
- 1 file changed, 42 insertions(+)
-
---- a/drivers/mtd/ubi/block.c
-+++ b/drivers/mtd/ubi/block.c
-@@ -635,6 +635,44 @@ static void __init ubiblock_create_from_
- 	}
- }
- 
-+#define UBIFS_NODE_MAGIC  0x06101831
-+static inline int ubi_vol_is_ubifs(struct ubi_volume_desc *desc)
-+{
-+	int ret;
-+	uint32_t magic_of, magic;
-+	ret = ubi_read(desc, 0, (char *)&magic_of, 0, 4);
-+	if (ret)
-+		return 0;
-+	magic = le32_to_cpu(magic_of);
-+	return magic == UBIFS_NODE_MAGIC;
-+}
-+
-+static void __init ubiblock_create_auto_rootfs(void)
-+{
-+	int ubi_num, ret, is_ubifs;
-+	struct ubi_volume_desc *desc;
-+	struct ubi_volume_info vi;
-+
-+	for (ubi_num = 0; ubi_num < UBI_MAX_DEVICES; ubi_num++) {
-+		desc = ubi_open_volume_nm(ubi_num, "rootfs", UBI_READONLY);
-+		if (IS_ERR(desc))
-+			continue;
-+
-+		ubi_get_volume_info(desc, &vi);
-+		is_ubifs = ubi_vol_is_ubifs(desc);
-+		ubi_close_volume(desc);
-+		if (is_ubifs)
-+			break;
-+
-+		ret = ubiblock_create(&vi);
-+		if (ret)
-+			pr_err("UBI error: block: can't add '%s' volume, err=%d\n",
-+				vi.name, ret);
-+		/* always break if we get here */
-+		break;
-+	}
-+}
-+
- static void ubiblock_remove_all(void)
- {
- 	struct ubiblock *next;
-@@ -667,6 +705,10 @@ int __init ubiblock_init(void)
- 	 */
- 	ubiblock_create_from_param();
- 
-+	/* auto-attach "rootfs" volume if existing and non-ubifs */
-+	if (IS_ENABLED(CONFIG_MTD_ROOTFS_ROOT_DEV))
-+		ubiblock_create_auto_rootfs();
-+
- 	/*
- 	 * Block devices are only created upon user requests, so we ignore
- 	 * existing volumes.
--- a/target/linux/generic/pending-4.9/492-try-auto-mounting-ubi0-rootfs-in-init-do_mounts.c.patch	2022-03-22 08:54:47.436465051 +0800
+++ b/target/linux/generic/pending-4.9/492-try-auto-mounting-ubi0-rootfs-in-init-do_mounts.c.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,51 +0,0 @@
-From: Daniel Golle <daniel@makrotopia.org>
-Subject: try auto-mounting ubi0:rootfs in init/do_mounts.c
-
-Signed-off-by: Daniel Golle <daniel@makrotopia.org>
----
- init/do_mounts.c | 26 +++++++++++++++++++++++++-
- 1 file changed, 25 insertions(+), 1 deletion(-)
-
---- a/init/do_mounts.c
-+++ b/init/do_mounts.c
-@@ -438,7 +438,28 @@ retry:
- out:
- 	put_page(page);
- }
-- 
-+
-+static int __init mount_ubi_rootfs(void)
-+{
-+	int flags = MS_SILENT;
-+	int err, tried = 0;
-+
-+	while (tried < 2) {
-+		err = do_mount_root("ubi0:rootfs", "ubifs", flags, \
-+					root_mount_data);
-+		switch (err) {
-+			case -EACCES:
-+				flags |= MS_RDONLY;
-+				tried++;
-+				break;
-+			default:
-+				return err;
-+		}
-+	}
-+
-+	return -EINVAL;
-+}
-+
- #ifdef CONFIG_ROOT_NFS
- 
- #define NFSROOT_TIMEOUT_MIN	5
-@@ -532,6 +553,10 @@ void __init mount_root(void)
- 			change_floppy("root floppy");
- 	}
- #endif
-+#ifdef CONFIG_MTD_ROOTFS_ROOT_DEV
-+	if (!mount_ubi_rootfs())
-+		return;
-+#endif
- #ifdef CONFIG_BLOCK
- 	{
- 		int err = create_dev("/dev/root", ROOT_DEV);
--- a/target/linux/generic/pending-4.9/493-ubi-set-ROOT_DEV-to-ubiblock-rootfs-if-unset.patch	2022-03-22 08:54:47.436465051 +0800
+++ b/target/linux/generic/pending-4.9/493-ubi-set-ROOT_DEV-to-ubiblock-rootfs-if-unset.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,34 +0,0 @@
-From: Daniel Golle <daniel@makrotopia.org>
-Subject: ubi: set ROOT_DEV to ubiblock "rootfs" if unset
-
-Signed-off-by: Daniel Golle <daniel@makrotopia.org>
----
- drivers/mtd/ubi/block.c | 10 ++++++++++
- 1 file changed, 10 insertions(+)
-
---- a/drivers/mtd/ubi/block.c
-+++ b/drivers/mtd/ubi/block.c
-@@ -50,6 +50,7 @@
- #include <linux/scatterlist.h>
- #include <linux/idr.h>
- #include <asm/div64.h>
-+#include <linux/root_dev.h>
- 
- #include "ubi-media.h"
- #include "ubi.h"
-@@ -447,6 +448,15 @@ int ubiblock_create(struct ubi_volume_in
- 	dev_info(disk_to_dev(dev->gd), "created from ubi%d:%d(%s)",
- 		 dev->ubi_num, dev->vol_id, vi->name);
- 	mutex_unlock(&devices_mutex);
-+
-+	if (!strcmp(vi->name, "rootfs") &&
-+	    IS_ENABLED(CONFIG_MTD_ROOTFS_ROOT_DEV) &&
-+	    ROOT_DEV == 0) {
-+		pr_notice("ubiblock: device ubiblock%d_%d (%s) set to be root filesystem\n",
-+			  dev->ubi_num, dev->vol_id, vi->name);
-+		ROOT_DEV = MKDEV(gd->major, gd->first_minor);
-+	}
-+
- 	return 0;
- 
- out_free_queue:
--- a/target/linux/generic/pending-4.9/494-mtd-ubi-add-EOF-marker-support.patch	2022-03-22 08:54:47.436465051 +0800
+++ b/target/linux/generic/pending-4.9/494-mtd-ubi-add-EOF-marker-support.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,60 +0,0 @@
-From: Gabor Juhos <juhosg@openwrt.org>
-Subject: mtd: add EOF marker support to the UBI layer
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/mtd/ubi/attach.c | 25 ++++++++++++++++++++++---
- drivers/mtd/ubi/ubi.h    |  1 +
- 2 files changed, 23 insertions(+), 3 deletions(-)
-
---- a/drivers/mtd/ubi/attach.c
-+++ b/drivers/mtd/ubi/attach.c
-@@ -939,6 +939,13 @@ static bool vol_ignored(int vol_id)
- #endif
- }
- 
-+static bool ec_hdr_has_eof(struct ubi_ec_hdr *ech)
-+{
-+	return ech->padding1[0] == 'E' &&
-+	       ech->padding1[1] == 'O' &&
-+	       ech->padding1[2] == 'F';
-+}
-+
- /**
-  * scan_peb - scan and process UBI headers of a PEB.
-  * @ubi: UBI device description object
-@@ -971,9 +978,21 @@ static int scan_peb(struct ubi_device *u
- 		return 0;
- 	}
- 
--	err = ubi_io_read_ec_hdr(ubi, pnum, ech, 0);
--	if (err < 0)
--		return err;
-+	if (!ai->eof_found) {
-+		err = ubi_io_read_ec_hdr(ubi, pnum, ech, 0);
-+		if (err < 0)
-+			return err;
-+
-+		if (ec_hdr_has_eof(ech)) {
-+			pr_notice("UBI: EOF marker found, PEBs from %d will be erased\n",
-+				pnum);
-+			ai->eof_found = true;
-+		}
-+	}
-+
-+	if (ai->eof_found)
-+		err = UBI_IO_FF_BITFLIPS;
-+
- 	switch (err) {
- 	case 0:
- 		break;
---- a/drivers/mtd/ubi/ubi.h
-+++ b/drivers/mtd/ubi/ubi.h
-@@ -779,6 +779,7 @@ struct ubi_attach_info {
- 	int mean_ec;
- 	uint64_t ec_sum;
- 	int ec_count;
-+	bool eof_found;
- 	struct kmem_cache *aeb_slab_cache;
- 	struct ubi_ec_hdr *ech;
- 	struct ubi_vid_io_buf *vidb;
--- a/target/linux/generic/pending-4.9/530-jffs2_make_lzma_available.patch	2022-03-22 08:54:47.438465054 +0800
+++ b/target/linux/generic/pending-4.9/530-jffs2_make_lzma_available.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,5180 +0,0 @@
-From: Alexandros C. Couloumbis <alex@ozo.com>
-Subject: fs: add jffs2/lzma support (not activated by default yet)
-
-lede-commit: c2c88d315fa0e881f8b19da07b62859b915b11b2
-Signed-off-by: Alexandros C. Couloumbis <alex@ozo.com>
----
- fs/jffs2/Kconfig             |    9 +
- fs/jffs2/Makefile            |    3 +
- fs/jffs2/compr.c             |    6 +
- fs/jffs2/compr.h             |   10 +-
- fs/jffs2/compr_lzma.c        |  128 +++
- fs/jffs2/super.c             |   33 +-
- include/linux/lzma.h         |   62 ++
- include/linux/lzma/LzFind.h  |  115 +++
- include/linux/lzma/LzHash.h  |   54 +
- include/linux/lzma/LzmaDec.h |  231 +++++
- include/linux/lzma/LzmaEnc.h |   80 ++
- include/linux/lzma/Types.h   |  226 +++++
- include/uapi/linux/jffs2.h   |    1 +
- lib/Kconfig                  |    6 +
- lib/Makefile                 |   12 +
- lib/lzma/LzFind.c            |  761 ++++++++++++++
- lib/lzma/LzmaDec.c           |  999 +++++++++++++++++++
- lib/lzma/LzmaEnc.c           | 2271 ++++++++++++++++++++++++++++++++++++++++++
- lib/lzma/Makefile            |    7 +
- 19 files changed, 5008 insertions(+), 6 deletions(-)
- create mode 100644 fs/jffs2/compr_lzma.c
- create mode 100644 include/linux/lzma.h
- create mode 100644 include/linux/lzma/LzFind.h
- create mode 100644 include/linux/lzma/LzHash.h
- create mode 100644 include/linux/lzma/LzmaDec.h
- create mode 100644 include/linux/lzma/LzmaEnc.h
- create mode 100644 include/linux/lzma/Types.h
- create mode 100644 lib/lzma/LzFind.c
- create mode 100644 lib/lzma/LzmaDec.c
- create mode 100644 lib/lzma/LzmaEnc.c
- create mode 100644 lib/lzma/Makefile
-
---- a/fs/jffs2/Kconfig
-+++ b/fs/jffs2/Kconfig
-@@ -139,6 +139,15 @@ config JFFS2_LZO
- 	  This feature was added in July, 2007. Say 'N' if you need
- 	  compatibility with older bootloaders or kernels.
- 
-+config JFFS2_LZMA
-+	bool "JFFS2 LZMA compression support" if JFFS2_COMPRESSION_OPTIONS
-+	select LZMA_COMPRESS
-+	select LZMA_DECOMPRESS
-+	depends on JFFS2_FS
-+	default n
-+	help
-+	  JFFS2 wrapper to the LZMA C SDK
-+
- config JFFS2_RTIME
- 	bool "JFFS2 RTIME compression support" if JFFS2_COMPRESSION_OPTIONS
- 	depends on JFFS2_FS
---- a/fs/jffs2/Makefile
-+++ b/fs/jffs2/Makefile
-@@ -18,4 +18,7 @@ jffs2-$(CONFIG_JFFS2_RUBIN)	+= compr_rub
- jffs2-$(CONFIG_JFFS2_RTIME)	+= compr_rtime.o
- jffs2-$(CONFIG_JFFS2_ZLIB)	+= compr_zlib.o
- jffs2-$(CONFIG_JFFS2_LZO)	+= compr_lzo.o
-+jffs2-$(CONFIG_JFFS2_LZMA)      += compr_lzma.o
- jffs2-$(CONFIG_JFFS2_SUMMARY)   += summary.o
-+
-+CFLAGS_compr_lzma.o += -Iinclude/linux -Ilib/lzma
---- a/fs/jffs2/compr.c
-+++ b/fs/jffs2/compr.c
-@@ -378,6 +378,9 @@ int __init jffs2_compressors_init(void)
- #ifdef CONFIG_JFFS2_LZO
- 	jffs2_lzo_init();
- #endif
-+#ifdef CONFIG_JFFS2_LZMA
-+        jffs2_lzma_init();
-+#endif
- /* Setting default compression mode */
- #ifdef CONFIG_JFFS2_CMODE_NONE
- 	jffs2_compression_mode = JFFS2_COMPR_MODE_NONE;
-@@ -401,6 +404,9 @@ int __init jffs2_compressors_init(void)
- int jffs2_compressors_exit(void)
- {
- /* Unregistering compressors */
-+#ifdef CONFIG_JFFS2_LZMA
-+        jffs2_lzma_exit();
-+#endif
- #ifdef CONFIG_JFFS2_LZO
- 	jffs2_lzo_exit();
- #endif
---- a/fs/jffs2/compr.h
-+++ b/fs/jffs2/compr.h
-@@ -29,9 +29,9 @@
- #define JFFS2_DYNRUBIN_PRIORITY  20
- #define JFFS2_LZARI_PRIORITY     30
- #define JFFS2_RTIME_PRIORITY     50
--#define JFFS2_ZLIB_PRIORITY      60
--#define JFFS2_LZO_PRIORITY       80
--
-+#define JFFS2_LZMA_PRIORITY      70
-+#define JFFS2_ZLIB_PRIORITY      80
-+#define JFFS2_LZO_PRIORITY       90
- 
- #define JFFS2_RUBINMIPS_DISABLED /* RUBINs will be used only */
- #define JFFS2_DYNRUBIN_DISABLED  /*	   for decompression */
-@@ -101,5 +101,9 @@ void jffs2_zlib_exit(void);
- int jffs2_lzo_init(void);
- void jffs2_lzo_exit(void);
- #endif
-+#ifdef CONFIG_JFFS2_LZMA
-+int jffs2_lzma_init(void);
-+void jffs2_lzma_exit(void);
-+#endif
- 
- #endif /* __JFFS2_COMPR_H__ */
---- /dev/null
-+++ b/fs/jffs2/compr_lzma.c
-@@ -0,0 +1,128 @@
-+/*
-+ * JFFS2 -- Journalling Flash File System, Version 2.
-+ *
-+ * For licensing information, see the file 'LICENCE' in this directory.
-+ *
-+ * JFFS2 wrapper to the LZMA C SDK
-+ *
-+ */
-+
-+#include <linux/lzma.h>
-+#include "compr.h"
-+
-+#ifdef __KERNEL__
-+	static DEFINE_MUTEX(deflate_mutex);
-+#endif
-+
-+CLzmaEncHandle *p;
-+Byte propsEncoded[LZMA_PROPS_SIZE];
-+SizeT propsSize = sizeof(propsEncoded);
-+
-+STATIC void lzma_free_workspace(void)
-+{
-+	LzmaEnc_Destroy(p, &lzma_alloc, &lzma_alloc);
-+}
-+
-+STATIC int INIT lzma_alloc_workspace(CLzmaEncProps *props)
-+{
-+	if ((p = (CLzmaEncHandle *)LzmaEnc_Create(&lzma_alloc)) == NULL)
-+	{
-+		PRINT_ERROR("Failed to allocate lzma deflate workspace\n");
-+		return -ENOMEM;
-+	}
-+
-+	if (LzmaEnc_SetProps(p, props) != SZ_OK)
-+	{
-+		lzma_free_workspace();
-+		return -1;
-+	}
-+	
-+	if (LzmaEnc_WriteProperties(p, propsEncoded, &propsSize) != SZ_OK)
-+	{
-+		lzma_free_workspace();
-+		return -1;
-+	}
-+
-+        return 0;
-+}
-+
-+STATIC int jffs2_lzma_compress(unsigned char *data_in, unsigned char *cpage_out,
-+			      uint32_t *sourcelen, uint32_t *dstlen)
-+{
-+	SizeT compress_size = (SizeT)(*dstlen);
-+	int ret;
-+
-+	#ifdef __KERNEL__
-+		mutex_lock(&deflate_mutex);
-+	#endif
-+
-+	ret = LzmaEnc_MemEncode(p, cpage_out, &compress_size, data_in, *sourcelen,
-+		0, NULL, &lzma_alloc, &lzma_alloc);
-+
-+	#ifdef __KERNEL__
-+		mutex_unlock(&deflate_mutex);
-+	#endif
-+
-+	if (ret != SZ_OK)
-+		return -1;
-+
-+	*dstlen = (uint32_t)compress_size;
-+
-+	return 0;
-+}
-+
-+STATIC int jffs2_lzma_decompress(unsigned char *data_in, unsigned char *cpage_out,
-+				 uint32_t srclen, uint32_t destlen)
-+{
-+	int ret;
-+	SizeT dl = (SizeT)destlen;
-+	SizeT sl = (SizeT)srclen;
-+	ELzmaStatus status;
-+	
-+	ret = LzmaDecode(cpage_out, &dl, data_in, &sl, propsEncoded,
-+		propsSize, LZMA_FINISH_ANY, &status, &lzma_alloc);
-+
-+	if (ret != SZ_OK || status == LZMA_STATUS_NOT_FINISHED || dl != (SizeT)destlen)
-+		return -1;
-+
-+	return 0;
-+}
-+
-+static struct jffs2_compressor jffs2_lzma_comp = {
-+	.priority = JFFS2_LZMA_PRIORITY,
-+	.name = "lzma",
-+	.compr = JFFS2_COMPR_LZMA,
-+	.compress = &jffs2_lzma_compress,
-+	.decompress = &jffs2_lzma_decompress,
-+	.disabled = 0,
-+};
-+
-+int INIT jffs2_lzma_init(void)
-+{
-+        int ret;
-+	CLzmaEncProps props;
-+	LzmaEncProps_Init(&props);
-+
-+        props.dictSize = LZMA_BEST_DICT(0x2000);
-+        props.level = LZMA_BEST_LEVEL;
-+        props.lc = LZMA_BEST_LC;
-+        props.lp = LZMA_BEST_LP;
-+        props.pb = LZMA_BEST_PB;
-+        props.fb = LZMA_BEST_FB;
-+
-+	ret = lzma_alloc_workspace(&props);
-+        if (ret < 0)
-+                return ret;
-+
-+	ret = jffs2_register_compressor(&jffs2_lzma_comp);
-+	if (ret)
-+		lzma_free_workspace();
-+	
-+        return ret;
-+}
-+
-+void jffs2_lzma_exit(void)
-+{
-+	jffs2_unregister_compressor(&jffs2_lzma_comp);
-+	lzma_free_workspace();
-+}
---- a/fs/jffs2/super.c
-+++ b/fs/jffs2/super.c
-@@ -374,14 +374,41 @@ static int __init init_jffs2_fs(void)
- 	BUILD_BUG_ON(sizeof(struct jffs2_raw_inode) != 68);
- 	BUILD_BUG_ON(sizeof(struct jffs2_raw_summary) != 32);
- 
--	pr_info("version 2.2."
-+	pr_info("version 2.2"
- #ifdef CONFIG_JFFS2_FS_WRITEBUFFER
- 	       " (NAND)"
- #endif
- #ifdef CONFIG_JFFS2_SUMMARY
--	       " (SUMMARY) "
-+	       " (SUMMARY)"
- #endif
--	       "  2001-2006 Red Hat, Inc.\n");
-+#ifdef CONFIG_JFFS2_ZLIB
-+	       " (ZLIB)"
-+#endif
-+#ifdef CONFIG_JFFS2_LZO
-+	       " (LZO)"
-+#endif
-+#ifdef CONFIG_JFFS2_LZMA
-+	       " (LZMA)"
-+#endif
-+#ifdef CONFIG_JFFS2_RTIME
-+	       " (RTIME)"
-+#endif
-+#ifdef CONFIG_JFFS2_RUBIN
-+	       " (RUBIN)"
-+#endif
-+#ifdef  CONFIG_JFFS2_CMODE_NONE
-+	       " (CMODE_NONE)"
-+#endif
-+#ifdef CONFIG_JFFS2_CMODE_PRIORITY
-+	       " (CMODE_PRIORITY)"
-+#endif
-+#ifdef CONFIG_JFFS2_CMODE_SIZE
-+	       " (CMODE_SIZE)"
-+#endif
-+#ifdef CONFIG_JFFS2_CMODE_FAVOURLZO
-+	       " (CMODE_FAVOURLZO)"
-+#endif
-+	       " (c) 2001-2006 Red Hat, Inc.\n");
- 
- 	jffs2_inode_cachep = kmem_cache_create("jffs2_i",
- 					     sizeof(struct jffs2_inode_info),
---- /dev/null
-+++ b/include/linux/lzma.h
-@@ -0,0 +1,62 @@
-+#ifndef __LZMA_H__
-+#define __LZMA_H__
-+
-+#ifdef __KERNEL__
-+	#include <linux/kernel.h>
-+	#include <linux/sched.h>
-+	#include <linux/slab.h>
-+	#include <linux/vmalloc.h>
-+	#include <linux/init.h>
-+	#define LZMA_MALLOC vmalloc
-+	#define LZMA_FREE vfree
-+	#define PRINT_ERROR(msg) printk(KERN_WARNING #msg)
-+	#define INIT __init
-+	#define STATIC static
-+#else
-+	#include <stdint.h>
-+	#include <stdlib.h>
-+	#include <stdio.h>
-+	#include <unistd.h>
-+	#include <string.h>
-+	#include <asm/types.h>
-+	#include <errno.h>
-+	#include <linux/jffs2.h>
-+	#ifndef PAGE_SIZE
-+		extern int page_size;
-+		#define PAGE_SIZE page_size
-+	#endif
-+	#define LZMA_MALLOC malloc
-+	#define LZMA_FREE free
-+	#define PRINT_ERROR(msg) fprintf(stderr, msg)
-+	#define INIT
-+	#define STATIC
-+#endif
-+
-+#include "lzma/LzmaDec.h"
-+#include "lzma/LzmaEnc.h"
-+
-+#define LZMA_BEST_LEVEL (9)
-+#define LZMA_BEST_LC    (0)
-+#define LZMA_BEST_LP    (0)
-+#define LZMA_BEST_PB    (0)
-+#define LZMA_BEST_FB  (273)
-+
-+#define LZMA_BEST_DICT(n) (((int)((n) / 2)) * 2)
-+
-+static void *p_lzma_malloc(void *p, size_t size)
-+{
-+        if (size == 0)
-+                return NULL;
-+
-+        return LZMA_MALLOC(size);
-+}
-+
-+static void p_lzma_free(void *p, void *address)
-+{
-+        if (address != NULL)
-+                LZMA_FREE(address);
-+}
-+
-+static ISzAlloc lzma_alloc = {p_lzma_malloc, p_lzma_free};
-+
-+#endif
---- /dev/null
-+++ b/include/linux/lzma/LzFind.h
-@@ -0,0 +1,115 @@
-+/* LzFind.h -- Match finder for LZ algorithms
-+2009-04-22 : Igor Pavlov : Public domain */
-+
-+#ifndef __LZ_FIND_H
-+#define __LZ_FIND_H
-+
-+#include "Types.h"
-+
-+#ifdef __cplusplus
-+extern "C" {
-+#endif
-+
-+typedef UInt32 CLzRef;
-+
-+typedef struct _CMatchFinder
-+{
-+  Byte *buffer;
-+  UInt32 pos;
-+  UInt32 posLimit;
-+  UInt32 streamPos;
-+  UInt32 lenLimit;
-+
-+  UInt32 cyclicBufferPos;
-+  UInt32 cyclicBufferSize; /* it must be = (historySize + 1) */
-+
-+  UInt32 matchMaxLen;
-+  CLzRef *hash;
-+  CLzRef *son;
-+  UInt32 hashMask;
-+  UInt32 cutValue;
-+
-+  Byte *bufferBase;
-+  ISeqInStream *stream;
-+  int streamEndWasReached;
-+
-+  UInt32 blockSize;
-+  UInt32 keepSizeBefore;
-+  UInt32 keepSizeAfter;
-+
-+  UInt32 numHashBytes;
-+  int directInput;
-+  size_t directInputRem;
-+  int btMode;
-+  int bigHash;
-+  UInt32 historySize;
-+  UInt32 fixedHashSize;
-+  UInt32 hashSizeSum;
-+  UInt32 numSons;
-+  SRes result;
-+  UInt32 crc[256];
-+} CMatchFinder;
-+
-+#define Inline_MatchFinder_GetPointerToCurrentPos(p) ((p)->buffer)
-+#define Inline_MatchFinder_GetIndexByte(p, index) ((p)->buffer[(Int32)(index)])
-+
-+#define Inline_MatchFinder_GetNumAvailableBytes(p) ((p)->streamPos - (p)->pos)
-+
-+int MatchFinder_NeedMove(CMatchFinder *p);
-+Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p);
-+void MatchFinder_MoveBlock(CMatchFinder *p);
-+void MatchFinder_ReadIfRequired(CMatchFinder *p);
-+
-+void MatchFinder_Construct(CMatchFinder *p);
-+
-+/* Conditions:
-+     historySize <= 3 GB
-+     keepAddBufferBefore + matchMaxLen + keepAddBufferAfter < 511MB
-+*/
-+int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
-+    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
-+    ISzAlloc *alloc);
-+void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc);
-+void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems);
-+void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue);
-+
-+UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *buffer, CLzRef *son,
-+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
-+    UInt32 *distances, UInt32 maxLen);
-+
-+/*
-+Conditions:
-+  Mf_GetNumAvailableBytes_Func must be called before each Mf_GetMatchLen_Func.
-+  Mf_GetPointerToCurrentPos_Func's result must be used only before any other function
-+*/
-+
-+typedef void (*Mf_Init_Func)(void *object);
-+typedef Byte (*Mf_GetIndexByte_Func)(void *object, Int32 index);
-+typedef UInt32 (*Mf_GetNumAvailableBytes_Func)(void *object);
-+typedef const Byte * (*Mf_GetPointerToCurrentPos_Func)(void *object);
-+typedef UInt32 (*Mf_GetMatches_Func)(void *object, UInt32 *distances);
-+typedef void (*Mf_Skip_Func)(void *object, UInt32);
-+
-+typedef struct _IMatchFinder
-+{
-+  Mf_Init_Func Init;
-+  Mf_GetIndexByte_Func GetIndexByte;
-+  Mf_GetNumAvailableBytes_Func GetNumAvailableBytes;
-+  Mf_GetPointerToCurrentPos_Func GetPointerToCurrentPos;
-+  Mf_GetMatches_Func GetMatches;
-+  Mf_Skip_Func Skip;
-+} IMatchFinder;
-+
-+void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable);
-+
-+void MatchFinder_Init(CMatchFinder *p);
-+UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
-+UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
-+void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
-+void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
-+
-+#ifdef __cplusplus
-+}
-+#endif
-+
-+#endif
---- /dev/null
-+++ b/include/linux/lzma/LzHash.h
-@@ -0,0 +1,54 @@
-+/* LzHash.h -- HASH functions for LZ algorithms
-+2009-02-07 : Igor Pavlov : Public domain */
-+
-+#ifndef __LZ_HASH_H
-+#define __LZ_HASH_H
-+
-+#define kHash2Size (1 << 10)
-+#define kHash3Size (1 << 16)
-+#define kHash4Size (1 << 20)
-+
-+#define kFix3HashSize (kHash2Size)
-+#define kFix4HashSize (kHash2Size + kHash3Size)
-+#define kFix5HashSize (kHash2Size + kHash3Size + kHash4Size)
-+
-+#define HASH2_CALC hashValue = cur[0] | ((UInt32)cur[1] << 8);
-+
-+#define HASH3_CALC { \
-+  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
-+  hash2Value = temp & (kHash2Size - 1); \
-+  hashValue = (temp ^ ((UInt32)cur[2] << 8)) & p->hashMask; }
-+
-+#define HASH4_CALC { \
-+  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
-+  hash2Value = temp & (kHash2Size - 1); \
-+  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
-+  hashValue = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)) & p->hashMask; }
-+
-+#define HASH5_CALC { \
-+  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
-+  hash2Value = temp & (kHash2Size - 1); \
-+  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
-+  hash4Value = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)); \
-+  hashValue = (hash4Value ^ (p->crc[cur[4]] << 3)) & p->hashMask; \
-+  hash4Value &= (kHash4Size - 1); }
-+
-+/* #define HASH_ZIP_CALC hashValue = ((cur[0] | ((UInt32)cur[1] << 8)) ^ p->crc[cur[2]]) & 0xFFFF; */
-+#define HASH_ZIP_CALC hashValue = ((cur[2] | ((UInt32)cur[0] << 8)) ^ p->crc[cur[1]]) & 0xFFFF;
-+
-+
-+#define MT_HASH2_CALC \
-+  hash2Value = (p->crc[cur[0]] ^ cur[1]) & (kHash2Size - 1);
-+
-+#define MT_HASH3_CALC { \
-+  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
-+  hash2Value = temp & (kHash2Size - 1); \
-+  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); }
-+
-+#define MT_HASH4_CALC { \
-+  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
-+  hash2Value = temp & (kHash2Size - 1); \
-+  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
-+  hash4Value = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)) & (kHash4Size - 1); }
-+
-+#endif
---- /dev/null
-+++ b/include/linux/lzma/LzmaDec.h
-@@ -0,0 +1,231 @@
-+/* LzmaDec.h -- LZMA Decoder
-+2009-02-07 : Igor Pavlov : Public domain */
-+
-+#ifndef __LZMA_DEC_H
-+#define __LZMA_DEC_H
-+
-+#include "Types.h"
-+
-+#ifdef __cplusplus
-+extern "C" {
-+#endif
-+
-+/* #define _LZMA_PROB32 */
-+/* _LZMA_PROB32 can increase the speed on some CPUs,
-+   but memory usage for CLzmaDec::probs will be doubled in that case */
-+
-+#ifdef _LZMA_PROB32
-+#define CLzmaProb UInt32
-+#else
-+#define CLzmaProb UInt16
-+#endif
-+
-+
-+/* ---------- LZMA Properties ---------- */
-+
-+#define LZMA_PROPS_SIZE 5
-+
-+typedef struct _CLzmaProps
-+{
-+  unsigned lc, lp, pb;
-+  UInt32 dicSize;
-+} CLzmaProps;
-+
-+/* LzmaProps_Decode - decodes properties
-+Returns:
-+  SZ_OK
-+  SZ_ERROR_UNSUPPORTED - Unsupported properties
-+*/
-+
-+SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size);
-+
-+
-+/* ---------- LZMA Decoder state ---------- */
-+
-+/* LZMA_REQUIRED_INPUT_MAX = number of required input bytes for worst case.
-+   Num bits = log2((2^11 / 31) ^ 22) + 26 < 134 + 26 = 160; */
-+
-+#define LZMA_REQUIRED_INPUT_MAX 20
-+
-+typedef struct
-+{
-+  CLzmaProps prop;
-+  CLzmaProb *probs;
-+  Byte *dic;
-+  const Byte *buf;
-+  UInt32 range, code;
-+  SizeT dicPos;
-+  SizeT dicBufSize;
-+  UInt32 processedPos;
-+  UInt32 checkDicSize;
-+  unsigned state;
-+  UInt32 reps[4];
-+  unsigned remainLen;
-+  int needFlush;
-+  int needInitState;
-+  UInt32 numProbs;
-+  unsigned tempBufSize;
-+  Byte tempBuf[LZMA_REQUIRED_INPUT_MAX];
-+} CLzmaDec;
-+
-+#define LzmaDec_Construct(p) { (p)->dic = 0; (p)->probs = 0; }
-+
-+void LzmaDec_Init(CLzmaDec *p);
-+
-+/* There are two types of LZMA streams:
-+     0) Stream with end mark. That end mark adds about 6 bytes to compressed size.
-+     1) Stream without end mark. You must know exact uncompressed size to decompress such stream. */
-+
-+typedef enum
-+{
-+  LZMA_FINISH_ANY,   /* finish at any point */
-+  LZMA_FINISH_END    /* block must be finished at the end */
-+} ELzmaFinishMode;
-+
-+/* ELzmaFinishMode has meaning only if the decoding reaches output limit !!!
-+
-+   You must use LZMA_FINISH_END, when you know that current output buffer
-+   covers last bytes of block. In other cases you must use LZMA_FINISH_ANY.
-+
-+   If LZMA decoder sees end marker before reaching output limit, it returns SZ_OK,
-+   and output value of destLen will be less than output buffer size limit.
-+   You can check status result also.
-+
-+   You can use multiple checks to test data integrity after full decompression:
-+     1) Check Result and "status" variable.
-+     2) Check that output(destLen) = uncompressedSize, if you know real uncompressedSize.
-+     3) Check that output(srcLen) = compressedSize, if you know real compressedSize.
-+        You must use correct finish mode in that case. */
-+
-+typedef enum
-+{
-+  LZMA_STATUS_NOT_SPECIFIED,               /* use main error code instead */
-+  LZMA_STATUS_FINISHED_WITH_MARK,          /* stream was finished with end mark. */
-+  LZMA_STATUS_NOT_FINISHED,                /* stream was not finished */
-+  LZMA_STATUS_NEEDS_MORE_INPUT,            /* you must provide more input bytes */
-+  LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK  /* there is probability that stream was finished without end mark */
-+} ELzmaStatus;
-+
-+/* ELzmaStatus is used only as output value for function call */
-+
-+
-+/* ---------- Interfaces ---------- */
-+
-+/* There are 3 levels of interfaces:
-+     1) Dictionary Interface
-+     2) Buffer Interface
-+     3) One Call Interface
-+   You can select any of these interfaces, but don't mix functions from different
-+   groups for same object. */
-+
-+
-+/* There are two variants to allocate state for Dictionary Interface:
-+     1) LzmaDec_Allocate / LzmaDec_Free
-+     2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs
-+   You can use variant 2, if you set dictionary buffer manually.
-+   For Buffer Interface you must always use variant 1.
-+
-+LzmaDec_Allocate* can return:
-+  SZ_OK
-+  SZ_ERROR_MEM         - Memory allocation error
-+  SZ_ERROR_UNSUPPORTED - Unsupported properties
-+*/
-+   
-+SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc);
-+void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc);
-+
-+SRes LzmaDec_Allocate(CLzmaDec *state, const Byte *prop, unsigned propsSize, ISzAlloc *alloc);
-+void LzmaDec_Free(CLzmaDec *state, ISzAlloc *alloc);
-+
-+/* ---------- Dictionary Interface ---------- */
-+
-+/* You can use it, if you want to eliminate the overhead for data copying from
-+   dictionary to some other external buffer.
-+   You must work with CLzmaDec variables directly in this interface.
-+
-+   STEPS:
-+     LzmaDec_Constr()
-+     LzmaDec_Allocate()
-+     for (each new stream)
-+     {
-+       LzmaDec_Init()
-+       while (it needs more decompression)
-+       {
-+         LzmaDec_DecodeToDic()
-+         use data from CLzmaDec::dic and update CLzmaDec::dicPos
-+       }
-+     }
-+     LzmaDec_Free()
-+*/
-+
-+/* LzmaDec_DecodeToDic
-+   
-+   The decoding to internal dictionary buffer (CLzmaDec::dic).
-+   You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!
-+
-+finishMode:
-+  It has meaning only if the decoding reaches output limit (dicLimit).
-+  LZMA_FINISH_ANY - Decode just dicLimit bytes.
-+  LZMA_FINISH_END - Stream must be finished after dicLimit.
-+
-+Returns:
-+  SZ_OK
-+    status:
-+      LZMA_STATUS_FINISHED_WITH_MARK
-+      LZMA_STATUS_NOT_FINISHED
-+      LZMA_STATUS_NEEDS_MORE_INPUT
-+      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
-+  SZ_ERROR_DATA - Data error
-+*/
-+
-+SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit,
-+    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
-+
-+
-+/* ---------- Buffer Interface ---------- */
-+
-+/* It's zlib-like interface.
-+   See LzmaDec_DecodeToDic description for information about STEPS and return results,
-+   but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need
-+   to work with CLzmaDec variables manually.
-+
-+finishMode:
-+  It has meaning only if the decoding reaches output limit (*destLen).
-+  LZMA_FINISH_ANY - Decode just destLen bytes.
-+  LZMA_FINISH_END - Stream must be finished after (*destLen).
-+*/
-+
-+SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen,
-+    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
-+
-+
-+/* ---------- One Call Interface ---------- */
-+
-+/* LzmaDecode
-+
-+finishMode:
-+  It has meaning only if the decoding reaches output limit (*destLen).
-+  LZMA_FINISH_ANY - Decode just destLen bytes.
-+  LZMA_FINISH_END - Stream must be finished after (*destLen).
-+
-+Returns:
-+  SZ_OK
-+    status:
-+      LZMA_STATUS_FINISHED_WITH_MARK
-+      LZMA_STATUS_NOT_FINISHED
-+      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
-+  SZ_ERROR_DATA - Data error
-+  SZ_ERROR_MEM  - Memory allocation error
-+  SZ_ERROR_UNSUPPORTED - Unsupported properties
-+  SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
-+*/
-+
-+SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
-+    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
-+    ELzmaStatus *status, ISzAlloc *alloc);
-+
-+#ifdef __cplusplus
-+}
-+#endif
-+
-+#endif
---- /dev/null
-+++ b/include/linux/lzma/LzmaEnc.h
-@@ -0,0 +1,80 @@
-+/*  LzmaEnc.h -- LZMA Encoder
-+2009-02-07 : Igor Pavlov : Public domain */
-+
-+#ifndef __LZMA_ENC_H
-+#define __LZMA_ENC_H
-+
-+#include "Types.h"
-+
-+#ifdef __cplusplus
-+extern "C" {
-+#endif
-+
-+#define LZMA_PROPS_SIZE 5
-+
-+typedef struct _CLzmaEncProps
-+{
-+  int level;       /*  0 <= level <= 9 */
-+  UInt32 dictSize; /* (1 << 12) <= dictSize <= (1 << 27) for 32-bit version
-+                      (1 << 12) <= dictSize <= (1 << 30) for 64-bit version
-+                       default = (1 << 24) */
-+  int lc;          /* 0 <= lc <= 8, default = 3 */
-+  int lp;          /* 0 <= lp <= 4, default = 0 */
-+  int pb;          /* 0 <= pb <= 4, default = 2 */
-+  int algo;        /* 0 - fast, 1 - normal, default = 1 */
-+  int fb;          /* 5 <= fb <= 273, default = 32 */
-+  int btMode;      /* 0 - hashChain Mode, 1 - binTree mode - normal, default = 1 */
-+  int numHashBytes; /* 2, 3 or 4, default = 4 */
-+  UInt32 mc;        /* 1 <= mc <= (1 << 30), default = 32 */
-+  unsigned writeEndMark;  /* 0 - do not write EOPM, 1 - write EOPM, default = 0 */
-+  int numThreads;  /* 1 or 2, default = 2 */
-+} CLzmaEncProps;
-+
-+void LzmaEncProps_Init(CLzmaEncProps *p);
-+void LzmaEncProps_Normalize(CLzmaEncProps *p);
-+UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2);
-+
-+
-+/* ---------- CLzmaEncHandle Interface ---------- */
-+
-+/* LzmaEnc_* functions can return the following exit codes:
-+Returns:
-+  SZ_OK           - OK
-+  SZ_ERROR_MEM    - Memory allocation error
-+  SZ_ERROR_PARAM  - Incorrect paramater in props
-+  SZ_ERROR_WRITE  - Write callback error.
-+  SZ_ERROR_PROGRESS - some break from progress callback
-+  SZ_ERROR_THREAD - errors in multithreading functions (only for Mt version)
-+*/
-+
-+typedef void * CLzmaEncHandle;
-+
-+CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc);
-+void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig);
-+SRes LzmaEnc_SetProps(CLzmaEncHandle p, const CLzmaEncProps *props);
-+SRes LzmaEnc_WriteProperties(CLzmaEncHandle p, Byte *properties, SizeT *size);
-+SRes LzmaEnc_Encode(CLzmaEncHandle p, ISeqOutStream *outStream, ISeqInStream *inStream,
-+    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
-+SRes LzmaEnc_MemEncode(CLzmaEncHandle p, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-+    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
-+
-+/* ---------- One Call Interface ---------- */
-+
-+/* LzmaEncode
-+Return code:
-+  SZ_OK               - OK
-+  SZ_ERROR_MEM        - Memory allocation error
-+  SZ_ERROR_PARAM      - Incorrect paramater
-+  SZ_ERROR_OUTPUT_EOF - output buffer overflow
-+  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
-+*/
-+
-+SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-+    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
-+    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
-+
-+#ifdef __cplusplus
-+}
-+#endif
-+
-+#endif
---- /dev/null
-+++ b/include/linux/lzma/Types.h
-@@ -0,0 +1,226 @@
-+/* Types.h -- Basic types
-+2009-11-23 : Igor Pavlov : Public domain */
-+
-+#ifndef __7Z_TYPES_H
-+#define __7Z_TYPES_H
-+
-+#include <stddef.h>
-+
-+#ifdef _WIN32
-+#include <windows.h>
-+#endif
-+
-+#ifndef EXTERN_C_BEGIN
-+#ifdef __cplusplus
-+#define EXTERN_C_BEGIN extern "C" {
-+#define EXTERN_C_END }
-+#else
-+#define EXTERN_C_BEGIN
-+#define EXTERN_C_END
-+#endif
-+#endif
-+
-+EXTERN_C_BEGIN
-+
-+#define SZ_OK 0
-+
-+#define SZ_ERROR_DATA 1
-+#define SZ_ERROR_MEM 2
-+#define SZ_ERROR_CRC 3
-+#define SZ_ERROR_UNSUPPORTED 4
-+#define SZ_ERROR_PARAM 5
-+#define SZ_ERROR_INPUT_EOF 6
-+#define SZ_ERROR_OUTPUT_EOF 7
-+#define SZ_ERROR_READ 8
-+#define SZ_ERROR_WRITE 9
-+#define SZ_ERROR_PROGRESS 10
-+#define SZ_ERROR_FAIL 11
-+#define SZ_ERROR_THREAD 12
-+
-+#define SZ_ERROR_ARCHIVE 16
-+#define SZ_ERROR_NO_ARCHIVE 17
-+
-+typedef int SRes;
-+
-+#ifdef _WIN32
-+typedef DWORD WRes;
-+#else
-+typedef int WRes;
-+#endif
-+
-+#ifndef RINOK
-+#define RINOK(x) { int __result__ = (x); if (__result__ != 0) return __result__; }
-+#endif
-+
-+typedef unsigned char Byte;
-+typedef short Int16;
-+typedef unsigned short UInt16;
-+
-+#ifdef _LZMA_UINT32_IS_ULONG
-+typedef long Int32;
-+typedef unsigned long UInt32;
-+#else
-+typedef int Int32;
-+typedef unsigned int UInt32;
-+#endif
-+
-+#ifdef _SZ_NO_INT_64
-+
-+/* define _SZ_NO_INT_64, if your compiler doesn't support 64-bit integers.
-+   NOTES: Some code will work incorrectly in that case! */
-+
-+typedef long Int64;
-+typedef unsigned long UInt64;
-+
-+#else
-+
-+#if defined(_MSC_VER) || defined(__BORLANDC__)
-+typedef __int64 Int64;
-+typedef unsigned __int64 UInt64;
-+#else
-+typedef long long int Int64;
-+typedef unsigned long long int UInt64;
-+#endif
-+
-+#endif
-+
-+#ifdef _LZMA_NO_SYSTEM_SIZE_T
-+typedef UInt32 SizeT;
-+#else
-+typedef size_t SizeT;
-+#endif
-+
-+typedef int Bool;
-+#define True 1
-+#define False 0
-+
-+
-+#ifdef _WIN32
-+#define MY_STD_CALL __stdcall
-+#else
-+#define MY_STD_CALL
-+#endif
-+
-+#ifdef _MSC_VER
-+
-+#if _MSC_VER >= 1300
-+#define MY_NO_INLINE __declspec(noinline)
-+#else
-+#define MY_NO_INLINE
-+#endif
-+
-+#define MY_CDECL __cdecl
-+#define MY_FAST_CALL __fastcall
-+
-+#else
-+
-+#define MY_CDECL
-+#define MY_FAST_CALL
-+
-+#endif
-+
-+
-+/* The following interfaces use first parameter as pointer to structure */
-+
-+typedef struct
-+{
-+  SRes (*Read)(void *p, void *buf, size_t *size);
-+    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
-+       (output(*size) < input(*size)) is allowed */
-+} ISeqInStream;
-+
-+/* it can return SZ_ERROR_INPUT_EOF */
-+SRes SeqInStream_Read(ISeqInStream *stream, void *buf, size_t size);
-+SRes SeqInStream_Read2(ISeqInStream *stream, void *buf, size_t size, SRes errorType);
-+SRes SeqInStream_ReadByte(ISeqInStream *stream, Byte *buf);
-+
-+typedef struct
-+{
-+  size_t (*Write)(void *p, const void *buf, size_t size);
-+    /* Returns: result - the number of actually written bytes.
-+       (result < size) means error */
-+} ISeqOutStream;
-+
-+typedef enum
-+{
-+  SZ_SEEK_SET = 0,
-+  SZ_SEEK_CUR = 1,
-+  SZ_SEEK_END = 2
-+} ESzSeek;
-+
-+typedef struct
-+{
-+  SRes (*Read)(void *p, void *buf, size_t *size);  /* same as ISeqInStream::Read */
-+  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
-+} ISeekInStream;
-+
-+typedef struct
-+{
-+  SRes (*Look)(void *p, void **buf, size_t *size);
-+    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
-+       (output(*size) > input(*size)) is not allowed
-+       (output(*size) < input(*size)) is allowed */
-+  SRes (*Skip)(void *p, size_t offset);
-+    /* offset must be <= output(*size) of Look */
-+
-+  SRes (*Read)(void *p, void *buf, size_t *size);
-+    /* reads directly (without buffer). It's same as ISeqInStream::Read */
-+  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
-+} ILookInStream;
-+
-+SRes LookInStream_LookRead(ILookInStream *stream, void *buf, size_t *size);
-+SRes LookInStream_SeekTo(ILookInStream *stream, UInt64 offset);
-+
-+/* reads via ILookInStream::Read */
-+SRes LookInStream_Read2(ILookInStream *stream, void *buf, size_t size, SRes errorType);
-+SRes LookInStream_Read(ILookInStream *stream, void *buf, size_t size);
-+
-+#define LookToRead_BUF_SIZE (1 << 14)
-+
-+typedef struct
-+{
-+  ILookInStream s;
-+  ISeekInStream *realStream;
-+  size_t pos;
-+  size_t size;
-+  Byte buf[LookToRead_BUF_SIZE];
-+} CLookToRead;
-+
-+void LookToRead_CreateVTable(CLookToRead *p, int lookahead);
-+void LookToRead_Init(CLookToRead *p);
-+
-+typedef struct
-+{
-+  ISeqInStream s;
-+  ILookInStream *realStream;
-+} CSecToLook;
-+
-+void SecToLook_CreateVTable(CSecToLook *p);
-+
-+typedef struct
-+{
-+  ISeqInStream s;
-+  ILookInStream *realStream;
-+} CSecToRead;
-+
-+void SecToRead_CreateVTable(CSecToRead *p);
-+
-+typedef struct
-+{
-+  SRes (*Progress)(void *p, UInt64 inSize, UInt64 outSize);
-+    /* Returns: result. (result != SZ_OK) means break.
-+       Value (UInt64)(Int64)-1 for size means unknown value. */
-+} ICompressProgress;
-+
-+typedef struct
-+{
-+  void *(*Alloc)(void *p, size_t size);
-+  void (*Free)(void *p, void *address); /* address can be 0 */
-+} ISzAlloc;
-+
-+#define IAlloc_Alloc(p, size) (p)->Alloc((p), size)
-+#define IAlloc_Free(p, a) (p)->Free((p), a)
-+
-+EXTERN_C_END
-+
-+#endif
---- a/include/uapi/linux/jffs2.h
-+++ b/include/uapi/linux/jffs2.h
-@@ -46,6 +46,7 @@
- #define JFFS2_COMPR_DYNRUBIN	0x05
- #define JFFS2_COMPR_ZLIB	0x06
- #define JFFS2_COMPR_LZO		0x07
-+#define JFFS2_COMPR_LZMA	0x08
- /* Compatibility flags. */
- #define JFFS2_COMPAT_MASK 0xc000      /* What do to if an unknown nodetype is found */
- #define JFFS2_NODE_ACCURATE 0x2000
---- a/lib/Kconfig
-+++ b/lib/Kconfig
-@@ -241,6 +241,12 @@ config LZ4_DECOMPRESS
- 
- source "lib/xz/Kconfig"
- 
-+config LZMA_COMPRESS
-+    tristate
-+
-+config LZMA_DECOMPRESS
-+    tristate
-+
- #
- # These all provide a common interface (hence the apparent duplication with
- # ZLIB_INFLATE; DECOMPRESS_GZIP is just a wrapper.)
---- a/lib/Makefile
-+++ b/lib/Makefile
-@@ -2,6 +2,16 @@
- # Makefile for some libs needed in the kernel.
- #
- 
-+ifdef CONFIG_JFFS2_ZLIB
-+	CONFIG_ZLIB_INFLATE:=y
-+	CONFIG_ZLIB_DEFLATE:=y
-+endif
-+
-+ifdef CONFIG_JFFS2_LZMA
-+	CONFIG_LZMA_DECOMPRESS:=y
-+	CONFIG_LZMA_COMPRESS:=y
-+endif
-+
- ifdef CONFIG_FUNCTION_TRACER
- ORIG_CFLAGS := $(KBUILD_CFLAGS)
- KBUILD_CFLAGS = $(subst $(CC_FLAGS_FTRACE),,$(ORIG_CFLAGS))
-@@ -110,6 +120,8 @@ obj-$(CONFIG_LZ4HC_COMPRESS) += lz4/
- obj-$(CONFIG_LZ4_DECOMPRESS) += lz4/
- obj-$(CONFIG_XZ_DEC) += xz/
- obj-$(CONFIG_RAID6_PQ) += raid6/
-+obj-$(CONFIG_LZMA_COMPRESS) += lzma/
-+obj-$(CONFIG_LZMA_DECOMPRESS) += lzma/
- 
- lib-$(CONFIG_DECOMPRESS_GZIP) += decompress_inflate.o
- lib-$(CONFIG_DECOMPRESS_BZIP2) += decompress_bunzip2.o
---- /dev/null
-+++ b/lib/lzma/LzFind.c
-@@ -0,0 +1,761 @@
-+/* LzFind.c -- Match finder for LZ algorithms
-+2009-04-22 : Igor Pavlov : Public domain */
-+
-+#include <string.h>
-+
-+#include "LzFind.h"
-+#include "LzHash.h"
-+
-+#define kEmptyHashValue 0
-+#define kMaxValForNormalize ((UInt32)0xFFFFFFFF)
-+#define kNormalizeStepMin (1 << 10) /* it must be power of 2 */
-+#define kNormalizeMask (~(kNormalizeStepMin - 1))
-+#define kMaxHistorySize ((UInt32)3 << 30)
-+
-+#define kStartMaxLen 3
-+
-+static void LzInWindow_Free(CMatchFinder *p, ISzAlloc *alloc)
-+{
-+  if (!p->directInput)
-+  {
-+    alloc->Free(alloc, p->bufferBase);
-+    p->bufferBase = 0;
-+  }
-+}
-+
-+/* keepSizeBefore + keepSizeAfter + keepSizeReserv must be < 4G) */
-+
-+static int LzInWindow_Create(CMatchFinder *p, UInt32 keepSizeReserv, ISzAlloc *alloc)
-+{
-+  UInt32 blockSize = p->keepSizeBefore + p->keepSizeAfter + keepSizeReserv;
-+  if (p->directInput)
-+  {
-+    p->blockSize = blockSize;
-+    return 1;
-+  }
-+  if (p->bufferBase == 0 || p->blockSize != blockSize)
-+  {
-+    LzInWindow_Free(p, alloc);
-+    p->blockSize = blockSize;
-+    p->bufferBase = (Byte *)alloc->Alloc(alloc, (size_t)blockSize);
-+  }
-+  return (p->bufferBase != 0);
-+}
-+
-+Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }
-+Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p->buffer[index]; }
-+
-+UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }
-+
-+void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
-+{
-+  p->posLimit -= subValue;
-+  p->pos -= subValue;
-+  p->streamPos -= subValue;
-+}
-+
-+static void MatchFinder_ReadBlock(CMatchFinder *p)
-+{
-+  if (p->streamEndWasReached || p->result != SZ_OK)
-+    return;
-+  if (p->directInput)
-+  {
-+    UInt32 curSize = 0xFFFFFFFF - p->streamPos;
-+    if (curSize > p->directInputRem)
-+      curSize = (UInt32)p->directInputRem;
-+    p->directInputRem -= curSize;
-+    p->streamPos += curSize;
-+    if (p->directInputRem == 0)
-+      p->streamEndWasReached = 1;
-+    return;
-+  }
-+  for (;;)
-+  {
-+    Byte *dest = p->buffer + (p->streamPos - p->pos);
-+    size_t size = (p->bufferBase + p->blockSize - dest);
-+    if (size == 0)
-+      return;
-+    p->result = p->stream->Read(p->stream, dest, &size);
-+    if (p->result != SZ_OK)
-+      return;
-+    if (size == 0)
-+    {
-+      p->streamEndWasReached = 1;
-+      return;
-+    }
-+    p->streamPos += (UInt32)size;
-+    if (p->streamPos - p->pos > p->keepSizeAfter)
-+      return;
-+  }
-+}
-+
-+void MatchFinder_MoveBlock(CMatchFinder *p)
-+{
-+  memmove(p->bufferBase,
-+    p->buffer - p->keepSizeBefore,
-+    (size_t)(p->streamPos - p->pos + p->keepSizeBefore));
-+  p->buffer = p->bufferBase + p->keepSizeBefore;
-+}
-+
-+int MatchFinder_NeedMove(CMatchFinder *p)
-+{
-+  if (p->directInput)
-+    return 0;
-+  /* if (p->streamEndWasReached) return 0; */
-+  return ((size_t)(p->bufferBase + p->blockSize - p->buffer) <= p->keepSizeAfter);
-+}
-+
-+void MatchFinder_ReadIfRequired(CMatchFinder *p)
-+{
-+  if (p->streamEndWasReached)
-+    return;
-+  if (p->keepSizeAfter >= p->streamPos - p->pos)
-+    MatchFinder_ReadBlock(p);
-+}
-+
-+static void MatchFinder_CheckAndMoveAndRead(CMatchFinder *p)
-+{
-+  if (MatchFinder_NeedMove(p))
-+    MatchFinder_MoveBlock(p);
-+  MatchFinder_ReadBlock(p);
-+}
-+
-+static void MatchFinder_SetDefaultSettings(CMatchFinder *p)
-+{
-+  p->cutValue = 32;
-+  p->btMode = 1;
-+  p->numHashBytes = 4;
-+  p->bigHash = 0;
-+}
-+
-+#define kCrcPoly 0xEDB88320
-+
-+void MatchFinder_Construct(CMatchFinder *p)
-+{
-+  UInt32 i;
-+  p->bufferBase = 0;
-+  p->directInput = 0;
-+  p->hash = 0;
-+  MatchFinder_SetDefaultSettings(p);
-+
-+  for (i = 0; i < 256; i++)
-+  {
-+    UInt32 r = i;
-+    int j;
-+    for (j = 0; j < 8; j++)
-+      r = (r >> 1) ^ (kCrcPoly & ~((r & 1) - 1));
-+    p->crc[i] = r;
-+  }
-+}
-+
-+static void MatchFinder_FreeThisClassMemory(CMatchFinder *p, ISzAlloc *alloc)
-+{
-+  alloc->Free(alloc, p->hash);
-+  p->hash = 0;
-+}
-+
-+void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc)
-+{
-+  MatchFinder_FreeThisClassMemory(p, alloc);
-+  LzInWindow_Free(p, alloc);
-+}
-+
-+static CLzRef* AllocRefs(UInt32 num, ISzAlloc *alloc)
-+{
-+  size_t sizeInBytes = (size_t)num * sizeof(CLzRef);
-+  if (sizeInBytes / sizeof(CLzRef) != num)
-+    return 0;
-+  return (CLzRef *)alloc->Alloc(alloc, sizeInBytes);
-+}
-+
-+int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
-+    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
-+    ISzAlloc *alloc)
-+{
-+  UInt32 sizeReserv;
-+  if (historySize > kMaxHistorySize)
-+  {
-+    MatchFinder_Free(p, alloc);
-+    return 0;
-+  }
-+  sizeReserv = historySize >> 1;
-+  if (historySize > ((UInt32)2 << 30))
-+    sizeReserv = historySize >> 2;
-+  sizeReserv += (keepAddBufferBefore + matchMaxLen + keepAddBufferAfter) / 2 + (1 << 19);
-+
-+  p->keepSizeBefore = historySize + keepAddBufferBefore + 1;
-+  p->keepSizeAfter = matchMaxLen + keepAddBufferAfter;
-+  /* we need one additional byte, since we use MoveBlock after pos++ and before dictionary using */
-+  if (LzInWindow_Create(p, sizeReserv, alloc))
-+  {
-+    UInt32 newCyclicBufferSize = historySize + 1;
-+    UInt32 hs;
-+    p->matchMaxLen = matchMaxLen;
-+    {
-+      p->fixedHashSize = 0;
-+      if (p->numHashBytes == 2)
-+        hs = (1 << 16) - 1;
-+      else
-+      {
-+        hs = historySize - 1;
-+        hs |= (hs >> 1);
-+        hs |= (hs >> 2);
-+        hs |= (hs >> 4);
-+        hs |= (hs >> 8);
-+        hs >>= 1;
-+        hs |= 0xFFFF; /* don't change it! It's required for Deflate */
-+        if (hs > (1 << 24))
-+        {
-+          if (p->numHashBytes == 3)
-+            hs = (1 << 24) - 1;
-+          else
-+            hs >>= 1;
-+        }
-+      }
-+      p->hashMask = hs;
-+      hs++;
-+      if (p->numHashBytes > 2) p->fixedHashSize += kHash2Size;
-+      if (p->numHashBytes > 3) p->fixedHashSize += kHash3Size;
-+      if (p->numHashBytes > 4) p->fixedHashSize += kHash4Size;
-+      hs += p->fixedHashSize;
-+    }
-+
-+    {
-+      UInt32 prevSize = p->hashSizeSum + p->numSons;
-+      UInt32 newSize;
-+      p->historySize = historySize;
-+      p->hashSizeSum = hs;
-+      p->cyclicBufferSize = newCyclicBufferSize;
-+      p->numSons = (p->btMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);
-+      newSize = p->hashSizeSum + p->numSons;
-+      if (p->hash != 0 && prevSize == newSize)
-+        return 1;
-+      MatchFinder_FreeThisClassMemory(p, alloc);
-+      p->hash = AllocRefs(newSize, alloc);
-+      if (p->hash != 0)
-+      {
-+        p->son = p->hash + p->hashSizeSum;
-+        return 1;
-+      }
-+    }
-+  }
-+  MatchFinder_Free(p, alloc);
-+  return 0;
-+}
-+
-+static void MatchFinder_SetLimits(CMatchFinder *p)
-+{
-+  UInt32 limit = kMaxValForNormalize - p->pos;
-+  UInt32 limit2 = p->cyclicBufferSize - p->cyclicBufferPos;
-+  if (limit2 < limit)
-+    limit = limit2;
-+  limit2 = p->streamPos - p->pos;
-+  if (limit2 <= p->keepSizeAfter)
-+  {
-+    if (limit2 > 0)
-+      limit2 = 1;
-+  }
-+  else
-+    limit2 -= p->keepSizeAfter;
-+  if (limit2 < limit)
-+    limit = limit2;
-+  {
-+    UInt32 lenLimit = p->streamPos - p->pos;
-+    if (lenLimit > p->matchMaxLen)
-+      lenLimit = p->matchMaxLen;
-+    p->lenLimit = lenLimit;
-+  }
-+  p->posLimit = p->pos + limit;
-+}
-+
-+void MatchFinder_Init(CMatchFinder *p)
-+{
-+  UInt32 i;
-+  for (i = 0; i < p->hashSizeSum; i++)
-+    p->hash[i] = kEmptyHashValue;
-+  p->cyclicBufferPos = 0;
-+  p->buffer = p->bufferBase;
-+  p->pos = p->streamPos = p->cyclicBufferSize;
-+  p->result = SZ_OK;
-+  p->streamEndWasReached = 0;
-+  MatchFinder_ReadBlock(p);
-+  MatchFinder_SetLimits(p);
-+}
-+
-+static UInt32 MatchFinder_GetSubValue(CMatchFinder *p)
-+{
-+  return (p->pos - p->historySize - 1) & kNormalizeMask;
-+}
-+
-+void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems)
-+{
-+  UInt32 i;
-+  for (i = 0; i < numItems; i++)
-+  {
-+    UInt32 value = items[i];
-+    if (value <= subValue)
-+      value = kEmptyHashValue;
-+    else
-+      value -= subValue;
-+    items[i] = value;
-+  }
-+}
-+
-+static void MatchFinder_Normalize(CMatchFinder *p)
-+{
-+  UInt32 subValue = MatchFinder_GetSubValue(p);
-+  MatchFinder_Normalize3(subValue, p->hash, p->hashSizeSum + p->numSons);
-+  MatchFinder_ReduceOffsets(p, subValue);
-+}
-+
-+static void MatchFinder_CheckLimits(CMatchFinder *p)
-+{
-+  if (p->pos == kMaxValForNormalize)
-+    MatchFinder_Normalize(p);
-+  if (!p->streamEndWasReached && p->keepSizeAfter == p->streamPos - p->pos)
-+    MatchFinder_CheckAndMoveAndRead(p);
-+  if (p->cyclicBufferPos == p->cyclicBufferSize)
-+    p->cyclicBufferPos = 0;
-+  MatchFinder_SetLimits(p);
-+}
-+
-+static UInt32 * Hc_GetMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
-+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
-+    UInt32 *distances, UInt32 maxLen)
-+{
-+  son[_cyclicBufferPos] = curMatch;
-+  for (;;)
-+  {
-+    UInt32 delta = pos - curMatch;
-+    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
-+      return distances;
-+    {
-+      const Byte *pb = cur - delta;
-+      curMatch = son[_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)];
-+      if (pb[maxLen] == cur[maxLen] && *pb == *cur)
-+      {
-+        UInt32 len = 0;
-+        while (++len != lenLimit)
-+          if (pb[len] != cur[len])
-+            break;
-+        if (maxLen < len)
-+        {
-+          *distances++ = maxLen = len;
-+          *distances++ = delta - 1;
-+          if (len == lenLimit)
-+            return distances;
-+        }
-+      }
-+    }
-+  }
-+}
-+
-+UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
-+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
-+    UInt32 *distances, UInt32 maxLen)
-+{
-+  CLzRef *ptr0 = son + (_cyclicBufferPos << 1) + 1;
-+  CLzRef *ptr1 = son + (_cyclicBufferPos << 1);
-+  UInt32 len0 = 0, len1 = 0;
-+  for (;;)
-+  {
-+    UInt32 delta = pos - curMatch;
-+    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
-+    {
-+      *ptr0 = *ptr1 = kEmptyHashValue;
-+      return distances;
-+    }
-+    {
-+      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
-+      const Byte *pb = cur - delta;
-+      UInt32 len = (len0 < len1 ? len0 : len1);
-+      if (pb[len] == cur[len])
-+      {
-+        if (++len != lenLimit && pb[len] == cur[len])
-+          while (++len != lenLimit)
-+            if (pb[len] != cur[len])
-+              break;
-+        if (maxLen < len)
-+        {
-+          *distances++ = maxLen = len;
-+          *distances++ = delta - 1;
-+          if (len == lenLimit)
-+          {
-+            *ptr1 = pair[0];
-+            *ptr0 = pair[1];
-+            return distances;
-+          }
-+        }
-+      }
-+      if (pb[len] < cur[len])
-+      {
-+        *ptr1 = curMatch;
-+        ptr1 = pair + 1;
-+        curMatch = *ptr1;
-+        len1 = len;
-+      }
-+      else
-+      {
-+        *ptr0 = curMatch;
-+        ptr0 = pair;
-+        curMatch = *ptr0;
-+        len0 = len;
-+      }
-+    }
-+  }
-+}
-+
-+static void SkipMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
-+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue)
-+{
-+  CLzRef *ptr0 = son + (_cyclicBufferPos << 1) + 1;
-+  CLzRef *ptr1 = son + (_cyclicBufferPos << 1);
-+  UInt32 len0 = 0, len1 = 0;
-+  for (;;)
-+  {
-+    UInt32 delta = pos - curMatch;
-+    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
-+    {
-+      *ptr0 = *ptr1 = kEmptyHashValue;
-+      return;
-+    }
-+    {
-+      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
-+      const Byte *pb = cur - delta;
-+      UInt32 len = (len0 < len1 ? len0 : len1);
-+      if (pb[len] == cur[len])
-+      {
-+        while (++len != lenLimit)
-+          if (pb[len] != cur[len])
-+            break;
-+        {
-+          if (len == lenLimit)
-+          {
-+            *ptr1 = pair[0];
-+            *ptr0 = pair[1];
-+            return;
-+          }
-+        }
-+      }
-+      if (pb[len] < cur[len])
-+      {
-+        *ptr1 = curMatch;
-+        ptr1 = pair + 1;
-+        curMatch = *ptr1;
-+        len1 = len;
-+      }
-+      else
-+      {
-+        *ptr0 = curMatch;
-+        ptr0 = pair;
-+        curMatch = *ptr0;
-+        len0 = len;
-+      }
-+    }
-+  }
-+}
-+
-+#define MOVE_POS \
-+  ++p->cyclicBufferPos; \
-+  p->buffer++; \
-+  if (++p->pos == p->posLimit) MatchFinder_CheckLimits(p);
-+
-+#define MOVE_POS_RET MOVE_POS return offset;
-+
-+static void MatchFinder_MovePos(CMatchFinder *p) { MOVE_POS; }
-+
-+#define GET_MATCHES_HEADER2(minLen, ret_op) \
-+  UInt32 lenLimit; UInt32 hashValue; const Byte *cur; UInt32 curMatch; \
-+  lenLimit = p->lenLimit; { if (lenLimit < minLen) { MatchFinder_MovePos(p); ret_op; }} \
-+  cur = p->buffer;
-+
-+#define GET_MATCHES_HEADER(minLen) GET_MATCHES_HEADER2(minLen, return 0)
-+#define SKIP_HEADER(minLen)        GET_MATCHES_HEADER2(minLen, continue)
-+
-+#define MF_PARAMS(p) p->pos, p->buffer, p->son, p->cyclicBufferPos, p->cyclicBufferSize, p->cutValue
-+
-+#define GET_MATCHES_FOOTER(offset, maxLen) \
-+  offset = (UInt32)(GetMatchesSpec1(lenLimit, curMatch, MF_PARAMS(p), \
-+  distances + offset, maxLen) - distances); MOVE_POS_RET;
-+
-+#define SKIP_FOOTER \
-+  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MOVE_POS;
-+
-+static UInt32 Bt2_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-+{
-+  UInt32 offset;
-+  GET_MATCHES_HEADER(2)
-+  HASH2_CALC;
-+  curMatch = p->hash[hashValue];
-+  p->hash[hashValue] = p->pos;
-+  offset = 0;
-+  GET_MATCHES_FOOTER(offset, 1)
-+}
-+
-+UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-+{
-+  UInt32 offset;
-+  GET_MATCHES_HEADER(3)
-+  HASH_ZIP_CALC;
-+  curMatch = p->hash[hashValue];
-+  p->hash[hashValue] = p->pos;
-+  offset = 0;
-+  GET_MATCHES_FOOTER(offset, 2)
-+}
-+
-+static UInt32 Bt3_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-+{
-+  UInt32 hash2Value, delta2, maxLen, offset;
-+  GET_MATCHES_HEADER(3)
-+
-+  HASH3_CALC;
-+
-+  delta2 = p->pos - p->hash[hash2Value];
-+  curMatch = p->hash[kFix3HashSize + hashValue];
-+  
-+  p->hash[hash2Value] =
-+  p->hash[kFix3HashSize + hashValue] = p->pos;
-+
-+
-+  maxLen = 2;
-+  offset = 0;
-+  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
-+  {
-+    for (; maxLen != lenLimit; maxLen++)
-+      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
-+        break;
-+    distances[0] = maxLen;
-+    distances[1] = delta2 - 1;
-+    offset = 2;
-+    if (maxLen == lenLimit)
-+    {
-+      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
-+      MOVE_POS_RET;
-+    }
-+  }
-+  GET_MATCHES_FOOTER(offset, maxLen)
-+}
-+
-+static UInt32 Bt4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-+{
-+  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
-+  GET_MATCHES_HEADER(4)
-+
-+  HASH4_CALC;
-+
-+  delta2 = p->pos - p->hash[                hash2Value];
-+  delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
-+  curMatch = p->hash[kFix4HashSize + hashValue];
-+  
-+  p->hash[                hash2Value] =
-+  p->hash[kFix3HashSize + hash3Value] =
-+  p->hash[kFix4HashSize + hashValue] = p->pos;
-+
-+  maxLen = 1;
-+  offset = 0;
-+  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
-+  {
-+    distances[0] = maxLen = 2;
-+    distances[1] = delta2 - 1;
-+    offset = 2;
-+  }
-+  if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
-+  {
-+    maxLen = 3;
-+    distances[offset + 1] = delta3 - 1;
-+    offset += 2;
-+    delta2 = delta3;
-+  }
-+  if (offset != 0)
-+  {
-+    for (; maxLen != lenLimit; maxLen++)
-+      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
-+        break;
-+    distances[offset - 2] = maxLen;
-+    if (maxLen == lenLimit)
-+    {
-+      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
-+      MOVE_POS_RET;
-+    }
-+  }
-+  if (maxLen < 3)
-+    maxLen = 3;
-+  GET_MATCHES_FOOTER(offset, maxLen)
-+}
-+
-+static UInt32 Hc4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-+{
-+  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
-+  GET_MATCHES_HEADER(4)
-+
-+  HASH4_CALC;
-+
-+  delta2 = p->pos - p->hash[                hash2Value];
-+  delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
-+  curMatch = p->hash[kFix4HashSize + hashValue];
-+
-+  p->hash[                hash2Value] =
-+  p->hash[kFix3HashSize + hash3Value] =
-+  p->hash[kFix4HashSize + hashValue] = p->pos;
-+
-+  maxLen = 1;
-+  offset = 0;
-+  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
-+  {
-+    distances[0] = maxLen = 2;
-+    distances[1] = delta2 - 1;
-+    offset = 2;
-+  }
-+  if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
-+  {
-+    maxLen = 3;
-+    distances[offset + 1] = delta3 - 1;
-+    offset += 2;
-+    delta2 = delta3;
-+  }
-+  if (offset != 0)
-+  {
-+    for (; maxLen != lenLimit; maxLen++)
-+      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
-+        break;
-+    distances[offset - 2] = maxLen;
-+    if (maxLen == lenLimit)
-+    {
-+      p->son[p->cyclicBufferPos] = curMatch;
-+      MOVE_POS_RET;
-+    }
-+  }
-+  if (maxLen < 3)
-+    maxLen = 3;
-+  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
-+    distances + offset, maxLen) - (distances));
-+  MOVE_POS_RET
-+}
-+
-+UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-+{
-+  UInt32 offset;
-+  GET_MATCHES_HEADER(3)
-+  HASH_ZIP_CALC;
-+  curMatch = p->hash[hashValue];
-+  p->hash[hashValue] = p->pos;
-+  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
-+    distances, 2) - (distances));
-+  MOVE_POS_RET
-+}
-+
-+static void Bt2_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-+{
-+  do
-+  {
-+    SKIP_HEADER(2)
-+    HASH2_CALC;
-+    curMatch = p->hash[hashValue];
-+    p->hash[hashValue] = p->pos;
-+    SKIP_FOOTER
-+  }
-+  while (--num != 0);
-+}
-+
-+void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-+{
-+  do
-+  {
-+    SKIP_HEADER(3)
-+    HASH_ZIP_CALC;
-+    curMatch = p->hash[hashValue];
-+    p->hash[hashValue] = p->pos;
-+    SKIP_FOOTER
-+  }
-+  while (--num != 0);
-+}
-+
-+static void Bt3_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-+{
-+  do
-+  {
-+    UInt32 hash2Value;
-+    SKIP_HEADER(3)
-+    HASH3_CALC;
-+    curMatch = p->hash[kFix3HashSize + hashValue];
-+    p->hash[hash2Value] =
-+    p->hash[kFix3HashSize + hashValue] = p->pos;
-+    SKIP_FOOTER
-+  }
-+  while (--num != 0);
-+}
-+
-+static void Bt4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-+{
-+  do
-+  {
-+    UInt32 hash2Value, hash3Value;
-+    SKIP_HEADER(4)
-+    HASH4_CALC;
-+    curMatch = p->hash[kFix4HashSize + hashValue];
-+    p->hash[                hash2Value] =
-+    p->hash[kFix3HashSize + hash3Value] = p->pos;
-+    p->hash[kFix4HashSize + hashValue] = p->pos;
-+    SKIP_FOOTER
-+  }
-+  while (--num != 0);
-+}
-+
-+static void Hc4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-+{
-+  do
-+  {
-+    UInt32 hash2Value, hash3Value;
-+    SKIP_HEADER(4)
-+    HASH4_CALC;
-+    curMatch = p->hash[kFix4HashSize + hashValue];
-+    p->hash[                hash2Value] =
-+    p->hash[kFix3HashSize + hash3Value] =
-+    p->hash[kFix4HashSize + hashValue] = p->pos;
-+    p->son[p->cyclicBufferPos] = curMatch;
-+    MOVE_POS
-+  }
-+  while (--num != 0);
-+}
-+
-+void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-+{
-+  do
-+  {
-+    SKIP_HEADER(3)
-+    HASH_ZIP_CALC;
-+    curMatch = p->hash[hashValue];
-+    p->hash[hashValue] = p->pos;
-+    p->son[p->cyclicBufferPos] = curMatch;
-+    MOVE_POS
-+  }
-+  while (--num != 0);
-+}
-+
-+void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable)
-+{
-+  vTable->Init = (Mf_Init_Func)MatchFinder_Init;
-+  vTable->GetIndexByte = (Mf_GetIndexByte_Func)MatchFinder_GetIndexByte;
-+  vTable->GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinder_GetNumAvailableBytes;
-+  vTable->GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinder_GetPointerToCurrentPos;
-+  if (!p->btMode)
-+  {
-+    vTable->GetMatches = (Mf_GetMatches_Func)Hc4_MatchFinder_GetMatches;
-+    vTable->Skip = (Mf_Skip_Func)Hc4_MatchFinder_Skip;
-+  }
-+  else if (p->numHashBytes == 2)
-+  {
-+    vTable->GetMatches = (Mf_GetMatches_Func)Bt2_MatchFinder_GetMatches;
-+    vTable->Skip = (Mf_Skip_Func)Bt2_MatchFinder_Skip;
-+  }
-+  else if (p->numHashBytes == 3)
-+  {
-+    vTable->GetMatches = (Mf_GetMatches_Func)Bt3_MatchFinder_GetMatches;
-+    vTable->Skip = (Mf_Skip_Func)Bt3_MatchFinder_Skip;
-+  }
-+  else
-+  {
-+    vTable->GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
-+    vTable->Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
-+  }
-+}
---- /dev/null
-+++ b/lib/lzma/LzmaDec.c
-@@ -0,0 +1,999 @@
-+/* LzmaDec.c -- LZMA Decoder
-+2009-09-20 : Igor Pavlov : Public domain */
-+
-+#include "LzmaDec.h"
-+
-+#include <string.h>
-+
-+#define kNumTopBits 24
-+#define kTopValue ((UInt32)1 << kNumTopBits)
-+
-+#define kNumBitModelTotalBits 11
-+#define kBitModelTotal (1 << kNumBitModelTotalBits)
-+#define kNumMoveBits 5
-+
-+#define RC_INIT_SIZE 5
-+
-+#define NORMALIZE if (range < kTopValue) { range <<= 8; code = (code << 8) | (*buf++); }
-+
-+#define IF_BIT_0(p) ttt = *(p); NORMALIZE; bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)
-+#define UPDATE_0(p) range = bound; *(p) = (CLzmaProb)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits));
-+#define UPDATE_1(p) range -= bound; code -= bound; *(p) = (CLzmaProb)(ttt - (ttt >> kNumMoveBits));
-+#define GET_BIT2(p, i, A0, A1) IF_BIT_0(p) \
-+  { UPDATE_0(p); i = (i + i); A0; } else \
-+  { UPDATE_1(p); i = (i + i) + 1; A1; }
-+#define GET_BIT(p, i) GET_BIT2(p, i, ; , ;)
-+
-+#define TREE_GET_BIT(probs, i) { GET_BIT((probs + i), i); }
-+#define TREE_DECODE(probs, limit, i) \
-+  { i = 1; do { TREE_GET_BIT(probs, i); } while (i < limit); i -= limit; }
-+
-+/* #define _LZMA_SIZE_OPT */
-+
-+#ifdef _LZMA_SIZE_OPT
-+#define TREE_6_DECODE(probs, i) TREE_DECODE(probs, (1 << 6), i)
-+#else
-+#define TREE_6_DECODE(probs, i) \
-+  { i = 1; \
-+  TREE_GET_BIT(probs, i); \
-+  TREE_GET_BIT(probs, i); \
-+  TREE_GET_BIT(probs, i); \
-+  TREE_GET_BIT(probs, i); \
-+  TREE_GET_BIT(probs, i); \
-+  TREE_GET_BIT(probs, i); \
-+  i -= 0x40; }
-+#endif
-+
-+#define NORMALIZE_CHECK if (range < kTopValue) { if (buf >= bufLimit) return DUMMY_ERROR; range <<= 8; code = (code << 8) | (*buf++); }
-+
-+#define IF_BIT_0_CHECK(p) ttt = *(p); NORMALIZE_CHECK; bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)
-+#define UPDATE_0_CHECK range = bound;
-+#define UPDATE_1_CHECK range -= bound; code -= bound;
-+#define GET_BIT2_CHECK(p, i, A0, A1) IF_BIT_0_CHECK(p) \
-+  { UPDATE_0_CHECK; i = (i + i); A0; } else \
-+  { UPDATE_1_CHECK; i = (i + i) + 1; A1; }
-+#define GET_BIT_CHECK(p, i) GET_BIT2_CHECK(p, i, ; , ;)
-+#define TREE_DECODE_CHECK(probs, limit, i) \
-+  { i = 1; do { GET_BIT_CHECK(probs + i, i) } while (i < limit); i -= limit; }
-+
-+
-+#define kNumPosBitsMax 4
-+#define kNumPosStatesMax (1 << kNumPosBitsMax)
-+
-+#define kLenNumLowBits 3
-+#define kLenNumLowSymbols (1 << kLenNumLowBits)
-+#define kLenNumMidBits 3
-+#define kLenNumMidSymbols (1 << kLenNumMidBits)
-+#define kLenNumHighBits 8
-+#define kLenNumHighSymbols (1 << kLenNumHighBits)
-+
-+#define LenChoice 0
-+#define LenChoice2 (LenChoice + 1)
-+#define LenLow (LenChoice2 + 1)
-+#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
-+#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
-+#define kNumLenProbs (LenHigh + kLenNumHighSymbols)
-+
-+
-+#define kNumStates 12
-+#define kNumLitStates 7
-+
-+#define kStartPosModelIndex 4
-+#define kEndPosModelIndex 14
-+#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
-+
-+#define kNumPosSlotBits 6
-+#define kNumLenToPosStates 4
-+
-+#define kNumAlignBits 4
-+#define kAlignTableSize (1 << kNumAlignBits)
-+
-+#define kMatchMinLen 2
-+#define kMatchSpecLenStart (kMatchMinLen + kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)
-+
-+#define IsMatch 0
-+#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
-+#define IsRepG0 (IsRep + kNumStates)
-+#define IsRepG1 (IsRepG0 + kNumStates)
-+#define IsRepG2 (IsRepG1 + kNumStates)
-+#define IsRep0Long (IsRepG2 + kNumStates)
-+#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
-+#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
-+#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
-+#define LenCoder (Align + kAlignTableSize)
-+#define RepLenCoder (LenCoder + kNumLenProbs)
-+#define Literal (RepLenCoder + kNumLenProbs)
-+
-+#define LZMA_BASE_SIZE 1846
-+#define LZMA_LIT_SIZE 768
-+
-+#define LzmaProps_GetNumProbs(p) ((UInt32)LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((p)->lc + (p)->lp)))
-+
-+#if Literal != LZMA_BASE_SIZE
-+StopCompilingDueBUG
-+#endif
-+
-+#define LZMA_DIC_MIN (1 << 12)
-+
-+/* First LZMA-symbol is always decoded.
-+And it decodes new LZMA-symbols while (buf < bufLimit), but "buf" is without last normalization
-+Out:
-+  Result:
-+    SZ_OK - OK
-+    SZ_ERROR_DATA - Error
-+  p->remainLen:
-+    < kMatchSpecLenStart : normal remain
-+    = kMatchSpecLenStart : finished
-+    = kMatchSpecLenStart + 1 : Flush marker
-+    = kMatchSpecLenStart + 2 : State Init Marker
-+*/
-+
-+static int MY_FAST_CALL LzmaDec_DecodeReal(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
-+{
-+  CLzmaProb *probs = p->probs;
-+
-+  unsigned state = p->state;
-+  UInt32 rep0 = p->reps[0], rep1 = p->reps[1], rep2 = p->reps[2], rep3 = p->reps[3];
-+  unsigned pbMask = ((unsigned)1 << (p->prop.pb)) - 1;
-+  unsigned lpMask = ((unsigned)1 << (p->prop.lp)) - 1;
-+  unsigned lc = p->prop.lc;
-+
-+  Byte *dic = p->dic;
-+  SizeT dicBufSize = p->dicBufSize;
-+  SizeT dicPos = p->dicPos;
-+  
-+  UInt32 processedPos = p->processedPos;
-+  UInt32 checkDicSize = p->checkDicSize;
-+  unsigned len = 0;
-+
-+  const Byte *buf = p->buf;
-+  UInt32 range = p->range;
-+  UInt32 code = p->code;
-+
-+  do
-+  {
-+    CLzmaProb *prob;
-+    UInt32 bound;
-+    unsigned ttt;
-+    unsigned posState = processedPos & pbMask;
-+
-+    prob = probs + IsMatch + (state << kNumPosBitsMax) + posState;
-+    IF_BIT_0(prob)
-+    {
-+      unsigned symbol;
-+      UPDATE_0(prob);
-+      prob = probs + Literal;
-+      if (checkDicSize != 0 || processedPos != 0)
-+        prob += (LZMA_LIT_SIZE * (((processedPos & lpMask) << lc) +
-+        (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] >> (8 - lc))));
-+
-+      if (state < kNumLitStates)
-+      {
-+        state -= (state < 4) ? state : 3;
-+        symbol = 1;
-+        do { GET_BIT(prob + symbol, symbol) } while (symbol < 0x100);
-+      }
-+      else
-+      {
-+        unsigned matchByte = p->dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
-+        unsigned offs = 0x100;
-+        state -= (state < 10) ? 3 : 6;
-+        symbol = 1;
-+        do
-+        {
-+          unsigned bit;
-+          CLzmaProb *probLit;
-+          matchByte <<= 1;
-+          bit = (matchByte & offs);
-+          probLit = prob + offs + bit + symbol;
-+          GET_BIT2(probLit, symbol, offs &= ~bit, offs &= bit)
-+        }
-+        while (symbol < 0x100);
-+      }
-+      dic[dicPos++] = (Byte)symbol;
-+      processedPos++;
-+      continue;
-+    }
-+    else
-+    {
-+      UPDATE_1(prob);
-+      prob = probs + IsRep + state;
-+      IF_BIT_0(prob)
-+      {
-+        UPDATE_0(prob);
-+        state += kNumStates;
-+        prob = probs + LenCoder;
-+      }
-+      else
-+      {
-+        UPDATE_1(prob);
-+        if (checkDicSize == 0 && processedPos == 0)
-+          return SZ_ERROR_DATA;
-+        prob = probs + IsRepG0 + state;
-+        IF_BIT_0(prob)
-+        {
-+          UPDATE_0(prob);
-+          prob = probs + IsRep0Long + (state << kNumPosBitsMax) + posState;
-+          IF_BIT_0(prob)
-+          {
-+            UPDATE_0(prob);
-+            dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
-+            dicPos++;
-+            processedPos++;
-+            state = state < kNumLitStates ? 9 : 11;
-+            continue;
-+          }
-+          UPDATE_1(prob);
-+        }
-+        else
-+        {
-+          UInt32 distance;
-+          UPDATE_1(prob);
-+          prob = probs + IsRepG1 + state;
-+          IF_BIT_0(prob)
-+          {
-+            UPDATE_0(prob);
-+            distance = rep1;
-+          }
-+          else
-+          {
-+            UPDATE_1(prob);
-+            prob = probs + IsRepG2 + state;
-+            IF_BIT_0(prob)
-+            {
-+              UPDATE_0(prob);
-+              distance = rep2;
-+            }
-+            else
-+            {
-+              UPDATE_1(prob);
-+              distance = rep3;
-+              rep3 = rep2;
-+            }
-+            rep2 = rep1;
-+          }
-+          rep1 = rep0;
-+          rep0 = distance;
-+        }
-+        state = state < kNumLitStates ? 8 : 11;
-+        prob = probs + RepLenCoder;
-+      }
-+      {
-+        unsigned limit, offset;
-+        CLzmaProb *probLen = prob + LenChoice;
-+        IF_BIT_0(probLen)
-+        {
-+          UPDATE_0(probLen);
-+          probLen = prob + LenLow + (posState << kLenNumLowBits);
-+          offset = 0;
-+          limit = (1 << kLenNumLowBits);
-+        }
-+        else
-+        {
-+          UPDATE_1(probLen);
-+          probLen = prob + LenChoice2;
-+          IF_BIT_0(probLen)
-+          {
-+            UPDATE_0(probLen);
-+            probLen = prob + LenMid + (posState << kLenNumMidBits);
-+            offset = kLenNumLowSymbols;
-+            limit = (1 << kLenNumMidBits);
-+          }
-+          else
-+          {
-+            UPDATE_1(probLen);
-+            probLen = prob + LenHigh;
-+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
-+            limit = (1 << kLenNumHighBits);
-+          }
-+        }
-+        TREE_DECODE(probLen, limit, len);
-+        len += offset;
-+      }
-+
-+      if (state >= kNumStates)
-+      {
-+        UInt32 distance;
-+        prob = probs + PosSlot +
-+            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);
-+        TREE_6_DECODE(prob, distance);
-+        if (distance >= kStartPosModelIndex)
-+        {
-+          unsigned posSlot = (unsigned)distance;
-+          int numDirectBits = (int)(((distance >> 1) - 1));
-+          distance = (2 | (distance & 1));
-+          if (posSlot < kEndPosModelIndex)
-+          {
-+            distance <<= numDirectBits;
-+            prob = probs + SpecPos + distance - posSlot - 1;
-+            {
-+              UInt32 mask = 1;
-+              unsigned i = 1;
-+              do
-+              {
-+                GET_BIT2(prob + i, i, ; , distance |= mask);
-+                mask <<= 1;
-+              }
-+              while (--numDirectBits != 0);
-+            }
-+          }
-+          else
-+          {
-+            numDirectBits -= kNumAlignBits;
-+            do
-+            {
-+              NORMALIZE
-+              range >>= 1;
-+              
-+              {
-+                UInt32 t;
-+                code -= range;
-+                t = (0 - ((UInt32)code >> 31)); /* (UInt32)((Int32)code >> 31) */
-+                distance = (distance << 1) + (t + 1);
-+                code += range & t;
-+              }
-+              /*
-+              distance <<= 1;
-+              if (code >= range)
-+              {
-+                code -= range;
-+                distance |= 1;
-+              }
-+              */
-+            }
-+            while (--numDirectBits != 0);
-+            prob = probs + Align;
-+            distance <<= kNumAlignBits;
-+            {
-+              unsigned i = 1;
-+              GET_BIT2(prob + i, i, ; , distance |= 1);
-+              GET_BIT2(prob + i, i, ; , distance |= 2);
-+              GET_BIT2(prob + i, i, ; , distance |= 4);
-+              GET_BIT2(prob + i, i, ; , distance |= 8);
-+            }
-+            if (distance == (UInt32)0xFFFFFFFF)
-+            {
-+              len += kMatchSpecLenStart;
-+              state -= kNumStates;
-+              break;
-+            }
-+          }
-+        }
-+        rep3 = rep2;
-+        rep2 = rep1;
-+        rep1 = rep0;
-+        rep0 = distance + 1;
-+        if (checkDicSize == 0)
-+        {
-+          if (distance >= processedPos)
-+            return SZ_ERROR_DATA;
-+        }
-+        else if (distance >= checkDicSize)
-+          return SZ_ERROR_DATA;
-+        state = (state < kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3;
-+      }
-+
-+      len += kMatchMinLen;
-+
-+      if (limit == dicPos)
-+        return SZ_ERROR_DATA;
-+      {
-+        SizeT rem = limit - dicPos;
-+        unsigned curLen = ((rem < len) ? (unsigned)rem : len);
-+        SizeT pos = (dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0);
-+
-+        processedPos += curLen;
-+
-+        len -= curLen;
-+        if (pos + curLen <= dicBufSize)
-+        {
-+          Byte *dest = dic + dicPos;
-+          ptrdiff_t src = (ptrdiff_t)pos - (ptrdiff_t)dicPos;
-+          const Byte *lim = dest + curLen;
-+          dicPos += curLen;
-+          do
-+            *(dest) = (Byte)*(dest + src);
-+          while (++dest != lim);
-+        }
-+        else
-+        {
-+          do
-+          {
-+            dic[dicPos++] = dic[pos];
-+            if (++pos == dicBufSize)
-+              pos = 0;
-+          }
-+          while (--curLen != 0);
-+        }
-+      }
-+    }
-+  }
-+  while (dicPos < limit && buf < bufLimit);
-+  NORMALIZE;
-+  p->buf = buf;
-+  p->range = range;
-+  p->code = code;
-+  p->remainLen = len;
-+  p->dicPos = dicPos;
-+  p->processedPos = processedPos;
-+  p->reps[0] = rep0;
-+  p->reps[1] = rep1;
-+  p->reps[2] = rep2;
-+  p->reps[3] = rep3;
-+  p->state = state;
-+
-+  return SZ_OK;
-+}
-+
-+static void MY_FAST_CALL LzmaDec_WriteRem(CLzmaDec *p, SizeT limit)
-+{
-+  if (p->remainLen != 0 && p->remainLen < kMatchSpecLenStart)
-+  {
-+    Byte *dic = p->dic;
-+    SizeT dicPos = p->dicPos;
-+    SizeT dicBufSize = p->dicBufSize;
-+    unsigned len = p->remainLen;
-+    UInt32 rep0 = p->reps[0];
-+    if (limit - dicPos < len)
-+      len = (unsigned)(limit - dicPos);
-+
-+    if (p->checkDicSize == 0 && p->prop.dicSize - p->processedPos <= len)
-+      p->checkDicSize = p->prop.dicSize;
-+
-+    p->processedPos += len;
-+    p->remainLen -= len;
-+    while (len-- != 0)
-+    {
-+      dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
-+      dicPos++;
-+    }
-+    p->dicPos = dicPos;
-+  }
-+}
-+
-+static int MY_FAST_CALL LzmaDec_DecodeReal2(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
-+{
-+  do
-+  {
-+    SizeT limit2 = limit;
-+    if (p->checkDicSize == 0)
-+    {
-+      UInt32 rem = p->prop.dicSize - p->processedPos;
-+      if (limit - p->dicPos > rem)
-+        limit2 = p->dicPos + rem;
-+    }
-+    RINOK(LzmaDec_DecodeReal(p, limit2, bufLimit));
-+    if (p->processedPos >= p->prop.dicSize)
-+      p->checkDicSize = p->prop.dicSize;
-+    LzmaDec_WriteRem(p, limit);
-+  }
-+  while (p->dicPos < limit && p->buf < bufLimit && p->remainLen < kMatchSpecLenStart);
-+
-+  if (p->remainLen > kMatchSpecLenStart)
-+  {
-+    p->remainLen = kMatchSpecLenStart;
-+  }
-+  return 0;
-+}
-+
-+typedef enum
-+{
-+  DUMMY_ERROR, /* unexpected end of input stream */
-+  DUMMY_LIT,
-+  DUMMY_MATCH,
-+  DUMMY_REP
-+} ELzmaDummy;
-+
-+static ELzmaDummy LzmaDec_TryDummy(const CLzmaDec *p, const Byte *buf, SizeT inSize)
-+{
-+  UInt32 range = p->range;
-+  UInt32 code = p->code;
-+  const Byte *bufLimit = buf + inSize;
-+  CLzmaProb *probs = p->probs;
-+  unsigned state = p->state;
-+  ELzmaDummy res;
-+
-+  {
-+    CLzmaProb *prob;
-+    UInt32 bound;
-+    unsigned ttt;
-+    unsigned posState = (p->processedPos) & ((1 << p->prop.pb) - 1);
-+
-+    prob = probs + IsMatch + (state << kNumPosBitsMax) + posState;
-+    IF_BIT_0_CHECK(prob)
-+    {
-+      UPDATE_0_CHECK
-+
-+      /* if (bufLimit - buf >= 7) return DUMMY_LIT; */
-+
-+      prob = probs + Literal;
-+      if (p->checkDicSize != 0 || p->processedPos != 0)
-+        prob += (LZMA_LIT_SIZE *
-+          ((((p->processedPos) & ((1 << (p->prop.lp)) - 1)) << p->prop.lc) +
-+          (p->dic[(p->dicPos == 0 ? p->dicBufSize : p->dicPos) - 1] >> (8 - p->prop.lc))));
-+
-+      if (state < kNumLitStates)
-+      {
-+        unsigned symbol = 1;
-+        do { GET_BIT_CHECK(prob + symbol, symbol) } while (symbol < 0x100);
-+      }
-+      else
-+      {
-+        unsigned matchByte = p->dic[p->dicPos - p->reps[0] +
-+            ((p->dicPos < p->reps[0]) ? p->dicBufSize : 0)];
-+        unsigned offs = 0x100;
-+        unsigned symbol = 1;
-+        do
-+        {
-+          unsigned bit;
-+          CLzmaProb *probLit;
-+          matchByte <<= 1;
-+          bit = (matchByte & offs);
-+          probLit = prob + offs + bit + symbol;
-+          GET_BIT2_CHECK(probLit, symbol, offs &= ~bit, offs &= bit)
-+        }
-+        while (symbol < 0x100);
-+      }
-+      res = DUMMY_LIT;
-+    }
-+    else
-+    {
-+      unsigned len;
-+      UPDATE_1_CHECK;
-+
-+      prob = probs + IsRep + state;
-+      IF_BIT_0_CHECK(prob)
-+      {
-+        UPDATE_0_CHECK;
-+        state = 0;
-+        prob = probs + LenCoder;
-+        res = DUMMY_MATCH;
-+      }
-+      else
-+      {
-+        UPDATE_1_CHECK;
-+        res = DUMMY_REP;
-+        prob = probs + IsRepG0 + state;
-+        IF_BIT_0_CHECK(prob)
-+        {
-+          UPDATE_0_CHECK;
-+          prob = probs + IsRep0Long + (state << kNumPosBitsMax) + posState;
-+          IF_BIT_0_CHECK(prob)
-+          {
-+            UPDATE_0_CHECK;
-+            NORMALIZE_CHECK;
-+            return DUMMY_REP;
-+          }
-+          else
-+          {
-+            UPDATE_1_CHECK;
-+          }
-+        }
-+        else
-+        {
-+          UPDATE_1_CHECK;
-+          prob = probs + IsRepG1 + state;
-+          IF_BIT_0_CHECK(prob)
-+          {
-+            UPDATE_0_CHECK;
-+          }
-+          else
-+          {
-+            UPDATE_1_CHECK;
-+            prob = probs + IsRepG2 + state;
-+            IF_BIT_0_CHECK(prob)
-+            {
-+              UPDATE_0_CHECK;
-+            }
-+            else
-+            {
-+              UPDATE_1_CHECK;
-+            }
-+          }
-+        }
-+        state = kNumStates;
-+        prob = probs + RepLenCoder;
-+      }
-+      {
-+        unsigned limit, offset;
-+        CLzmaProb *probLen = prob + LenChoice;
-+        IF_BIT_0_CHECK(probLen)
-+        {
-+          UPDATE_0_CHECK;
-+          probLen = prob + LenLow + (posState << kLenNumLowBits);
-+          offset = 0;
-+          limit = 1 << kLenNumLowBits;
-+        }
-+        else
-+        {
-+          UPDATE_1_CHECK;
-+          probLen = prob + LenChoice2;
-+          IF_BIT_0_CHECK(probLen)
-+          {
-+            UPDATE_0_CHECK;
-+            probLen = prob + LenMid + (posState << kLenNumMidBits);
-+            offset = kLenNumLowSymbols;
-+            limit = 1 << kLenNumMidBits;
-+          }
-+          else
-+          {
-+            UPDATE_1_CHECK;
-+            probLen = prob + LenHigh;
-+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
-+            limit = 1 << kLenNumHighBits;
-+          }
-+        }
-+        TREE_DECODE_CHECK(probLen, limit, len);
-+        len += offset;
-+      }
-+
-+      if (state < 4)
-+      {
-+        unsigned posSlot;
-+        prob = probs + PosSlot +
-+            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) <<
-+            kNumPosSlotBits);
-+        TREE_DECODE_CHECK(prob, 1 << kNumPosSlotBits, posSlot);
-+        if (posSlot >= kStartPosModelIndex)
-+        {
-+          int numDirectBits = ((posSlot >> 1) - 1);
-+
-+          /* if (bufLimit - buf >= 8) return DUMMY_MATCH; */
-+
-+          if (posSlot < kEndPosModelIndex)
-+          {
-+            prob = probs + SpecPos + ((2 | (posSlot & 1)) << numDirectBits) - posSlot - 1;
-+          }
-+          else
-+          {
-+            numDirectBits -= kNumAlignBits;
-+            do
-+            {
-+              NORMALIZE_CHECK
-+              range >>= 1;
-+              code -= range & (((code - range) >> 31) - 1);
-+              /* if (code >= range) code -= range; */
-+            }
-+            while (--numDirectBits != 0);
-+            prob = probs + Align;
-+            numDirectBits = kNumAlignBits;
-+          }
-+          {
-+            unsigned i = 1;
-+            do
-+            {
-+              GET_BIT_CHECK(prob + i, i);
-+            }
-+            while (--numDirectBits != 0);
-+          }
-+        }
-+      }
-+    }
-+  }
-+  NORMALIZE_CHECK;
-+  return res;
-+}
-+
-+
-+static void LzmaDec_InitRc(CLzmaDec *p, const Byte *data)
-+{
-+  p->code = ((UInt32)data[1] << 24) | ((UInt32)data[2] << 16) | ((UInt32)data[3] << 8) | ((UInt32)data[4]);
-+  p->range = 0xFFFFFFFF;
-+  p->needFlush = 0;
-+}
-+
-+void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
-+{
-+  p->needFlush = 1;
-+  p->remainLen = 0;
-+  p->tempBufSize = 0;
-+
-+  if (initDic)
-+  {
-+    p->processedPos = 0;
-+    p->checkDicSize = 0;
-+    p->needInitState = 1;
-+  }
-+  if (initState)
-+    p->needInitState = 1;
-+}
-+
-+void LzmaDec_Init(CLzmaDec *p)
-+{
-+  p->dicPos = 0;
-+  LzmaDec_InitDicAndState(p, True, True);
-+}
-+
-+static void LzmaDec_InitStateReal(CLzmaDec *p)
-+{
-+  UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (p->prop.lc + p->prop.lp));
-+  UInt32 i;
-+  CLzmaProb *probs = p->probs;
-+  for (i = 0; i < numProbs; i++)
-+    probs[i] = kBitModelTotal >> 1;
-+  p->reps[0] = p->reps[1] = p->reps[2] = p->reps[3] = 1;
-+  p->state = 0;
-+  p->needInitState = 0;
-+}
-+
-+SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
-+    ELzmaFinishMode finishMode, ELzmaStatus *status)
-+{
-+  SizeT inSize = *srcLen;
-+  (*srcLen) = 0;
-+  LzmaDec_WriteRem(p, dicLimit);
-+  
-+  *status = LZMA_STATUS_NOT_SPECIFIED;
-+
-+  while (p->remainLen != kMatchSpecLenStart)
-+  {
-+      int checkEndMarkNow;
-+
-+      if (p->needFlush != 0)
-+      {
-+        for (; inSize > 0 && p->tempBufSize < RC_INIT_SIZE; (*srcLen)++, inSize--)
-+          p->tempBuf[p->tempBufSize++] = *src++;
-+        if (p->tempBufSize < RC_INIT_SIZE)
-+        {
-+          *status = LZMA_STATUS_NEEDS_MORE_INPUT;
-+          return SZ_OK;
-+        }
-+        if (p->tempBuf[0] != 0)
-+          return SZ_ERROR_DATA;
-+
-+        LzmaDec_InitRc(p, p->tempBuf);
-+        p->tempBufSize = 0;
-+      }
-+
-+      checkEndMarkNow = 0;
-+      if (p->dicPos >= dicLimit)
-+      {
-+        if (p->remainLen == 0 && p->code == 0)
-+        {
-+          *status = LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK;
-+          return SZ_OK;
-+        }
-+        if (finishMode == LZMA_FINISH_ANY)
-+        {
-+          *status = LZMA_STATUS_NOT_FINISHED;
-+          return SZ_OK;
-+        }
-+        if (p->remainLen != 0)
-+        {
-+          *status = LZMA_STATUS_NOT_FINISHED;
-+          return SZ_ERROR_DATA;
-+        }
-+        checkEndMarkNow = 1;
-+      }
-+
-+      if (p->needInitState)
-+        LzmaDec_InitStateReal(p);
-+  
-+      if (p->tempBufSize == 0)
-+      {
-+        SizeT processed;
-+        const Byte *bufLimit;
-+        if (inSize < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
-+        {
-+          int dummyRes = LzmaDec_TryDummy(p, src, inSize);
-+          if (dummyRes == DUMMY_ERROR)
-+          {
-+            memcpy(p->tempBuf, src, inSize);
-+            p->tempBufSize = (unsigned)inSize;
-+            (*srcLen) += inSize;
-+            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
-+            return SZ_OK;
-+          }
-+          if (checkEndMarkNow && dummyRes != DUMMY_MATCH)
-+          {
-+            *status = LZMA_STATUS_NOT_FINISHED;
-+            return SZ_ERROR_DATA;
-+          }
-+          bufLimit = src;
-+        }
-+        else
-+          bufLimit = src + inSize - LZMA_REQUIRED_INPUT_MAX;
-+        p->buf = src;
-+        if (LzmaDec_DecodeReal2(p, dicLimit, bufLimit) != 0)
-+          return SZ_ERROR_DATA;
-+        processed = (SizeT)(p->buf - src);
-+        (*srcLen) += processed;
-+        src += processed;
-+        inSize -= processed;
-+      }
-+      else
-+      {
-+        unsigned rem = p->tempBufSize, lookAhead = 0;
-+        while (rem < LZMA_REQUIRED_INPUT_MAX && lookAhead < inSize)
-+          p->tempBuf[rem++] = src[lookAhead++];
-+        p->tempBufSize = rem;
-+        if (rem < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
-+        {
-+          int dummyRes = LzmaDec_TryDummy(p, p->tempBuf, rem);
-+          if (dummyRes == DUMMY_ERROR)
-+          {
-+            (*srcLen) += lookAhead;
-+            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
-+            return SZ_OK;
-+          }
-+          if (checkEndMarkNow && dummyRes != DUMMY_MATCH)
-+          {
-+            *status = LZMA_STATUS_NOT_FINISHED;
-+            return SZ_ERROR_DATA;
-+          }
-+        }
-+        p->buf = p->tempBuf;
-+        if (LzmaDec_DecodeReal2(p, dicLimit, p->buf) != 0)
-+          return SZ_ERROR_DATA;
-+        lookAhead -= (rem - (unsigned)(p->buf - p->tempBuf));
-+        (*srcLen) += lookAhead;
-+        src += lookAhead;
-+        inSize -= lookAhead;
-+        p->tempBufSize = 0;
-+      }
-+  }
-+  if (p->code == 0)
-+    *status = LZMA_STATUS_FINISHED_WITH_MARK;
-+  return (p->code == 0) ? SZ_OK : SZ_ERROR_DATA;
-+}
-+
-+SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
-+{
-+  SizeT outSize = *destLen;
-+  SizeT inSize = *srcLen;
-+  *srcLen = *destLen = 0;
-+  for (;;)
-+  {
-+    SizeT inSizeCur = inSize, outSizeCur, dicPos;
-+    ELzmaFinishMode curFinishMode;
-+    SRes res;
-+    if (p->dicPos == p->dicBufSize)
-+      p->dicPos = 0;
-+    dicPos = p->dicPos;
-+    if (outSize > p->dicBufSize - dicPos)
-+    {
-+      outSizeCur = p->dicBufSize;
-+      curFinishMode = LZMA_FINISH_ANY;
-+    }
-+    else
-+    {
-+      outSizeCur = dicPos + outSize;
-+      curFinishMode = finishMode;
-+    }
-+
-+    res = LzmaDec_DecodeToDic(p, outSizeCur, src, &inSizeCur, curFinishMode, status);
-+    src += inSizeCur;
-+    inSize -= inSizeCur;
-+    *srcLen += inSizeCur;
-+    outSizeCur = p->dicPos - dicPos;
-+    memcpy(dest, p->dic + dicPos, outSizeCur);
-+    dest += outSizeCur;
-+    outSize -= outSizeCur;
-+    *destLen += outSizeCur;
-+    if (res != 0)
-+      return res;
-+    if (outSizeCur == 0 || outSize == 0)
-+      return SZ_OK;
-+  }
-+}
-+
-+void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
-+{
-+  alloc->Free(alloc, p->probs);
-+  p->probs = 0;
-+}
-+
-+static void LzmaDec_FreeDict(CLzmaDec *p, ISzAlloc *alloc)
-+{
-+  alloc->Free(alloc, p->dic);
-+  p->dic = 0;
-+}
-+
-+void LzmaDec_Free(CLzmaDec *p, ISzAlloc *alloc)
-+{
-+  LzmaDec_FreeProbs(p, alloc);
-+  LzmaDec_FreeDict(p, alloc);
-+}
-+
-+SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
-+{
-+  UInt32 dicSize;
-+  Byte d;
-+  
-+  if (size < LZMA_PROPS_SIZE)
-+    return SZ_ERROR_UNSUPPORTED;
-+  else
-+    dicSize = data[1] | ((UInt32)data[2] << 8) | ((UInt32)data[3] << 16) | ((UInt32)data[4] << 24);
-+ 
-+  if (dicSize < LZMA_DIC_MIN)
-+    dicSize = LZMA_DIC_MIN;
-+  p->dicSize = dicSize;
-+
-+  d = data[0];
-+  if (d >= (9 * 5 * 5))
-+    return SZ_ERROR_UNSUPPORTED;
-+
-+  p->lc = d % 9;
-+  d /= 9;
-+  p->pb = d / 5;
-+  p->lp = d % 5;
-+
-+  return SZ_OK;
-+}
-+
-+static SRes LzmaDec_AllocateProbs2(CLzmaDec *p, const CLzmaProps *propNew, ISzAlloc *alloc)
-+{
-+  UInt32 numProbs = LzmaProps_GetNumProbs(propNew);
-+  if (p->probs == 0 || numProbs != p->numProbs)
-+  {
-+    LzmaDec_FreeProbs(p, alloc);
-+    p->probs = (CLzmaProb *)alloc->Alloc(alloc, numProbs * sizeof(CLzmaProb));
-+    p->numProbs = numProbs;
-+    if (p->probs == 0)
-+      return SZ_ERROR_MEM;
-+  }
-+  return SZ_OK;
-+}
-+
-+SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
-+{
-+  CLzmaProps propNew;
-+  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
-+  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
-+  p->prop = propNew;
-+  return SZ_OK;
-+}
-+
-+SRes LzmaDec_Allocate(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
-+{
-+  CLzmaProps propNew;
-+  SizeT dicBufSize;
-+  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
-+  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
-+  dicBufSize = propNew.dicSize;
-+  if (p->dic == 0 || dicBufSize != p->dicBufSize)
-+  {
-+    LzmaDec_FreeDict(p, alloc);
-+    p->dic = (Byte *)alloc->Alloc(alloc, dicBufSize);
-+    if (p->dic == 0)
-+    {
-+      LzmaDec_FreeProbs(p, alloc);
-+      return SZ_ERROR_MEM;
-+    }
-+  }
-+  p->dicBufSize = dicBufSize;
-+  p->prop = propNew;
-+  return SZ_OK;
-+}
-+
-+SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
-+    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
-+    ELzmaStatus *status, ISzAlloc *alloc)
-+{
-+  CLzmaDec p;
-+  SRes res;
-+  SizeT inSize = *srcLen;
-+  SizeT outSize = *destLen;
-+  *srcLen = *destLen = 0;
-+  if (inSize < RC_INIT_SIZE)
-+    return SZ_ERROR_INPUT_EOF;
-+
-+  LzmaDec_Construct(&p);
-+  res = LzmaDec_AllocateProbs(&p, propData, propSize, alloc);
-+  if (res != 0)
-+    return res;
-+  p.dic = dest;
-+  p.dicBufSize = outSize;
-+
-+  LzmaDec_Init(&p);
-+  
-+  *srcLen = inSize;
-+  res = LzmaDec_DecodeToDic(&p, outSize, src, srcLen, finishMode, status);
-+
-+  if (res == SZ_OK && *status == LZMA_STATUS_NEEDS_MORE_INPUT)
-+    res = SZ_ERROR_INPUT_EOF;
-+
-+  (*destLen) = p.dicPos;
-+  LzmaDec_FreeProbs(&p, alloc);
-+  return res;
-+}
---- /dev/null
-+++ b/lib/lzma/LzmaEnc.c
-@@ -0,0 +1,2271 @@
-+/* LzmaEnc.c -- LZMA Encoder
-+2009-11-24 : Igor Pavlov : Public domain */
-+
-+#include <string.h>
-+
-+/* #define SHOW_STAT */
-+/* #define SHOW_STAT2 */
-+
-+#if defined(SHOW_STAT) || defined(SHOW_STAT2)
-+#include <stdio.h>
-+#endif
-+
-+#include "LzmaEnc.h"
-+
-+/* disable MT */
-+#define _7ZIP_ST
-+
-+#include "LzFind.h"
-+#ifndef _7ZIP_ST
-+#include "LzFindMt.h"
-+#endif
-+
-+#ifdef SHOW_STAT
-+static int ttt = 0;
-+#endif
-+
-+#define kBlockSizeMax ((1 << LZMA_NUM_BLOCK_SIZE_BITS) - 1)
-+
-+#define kBlockSize (9 << 10)
-+#define kUnpackBlockSize (1 << 18)
-+#define kMatchArraySize (1 << 21)
-+#define kMatchRecordMaxSize ((LZMA_MATCH_LEN_MAX * 2 + 3) * LZMA_MATCH_LEN_MAX)
-+
-+#define kNumMaxDirectBits (31)
-+
-+#define kNumTopBits 24
-+#define kTopValue ((UInt32)1 << kNumTopBits)
-+
-+#define kNumBitModelTotalBits 11
-+#define kBitModelTotal (1 << kNumBitModelTotalBits)
-+#define kNumMoveBits 5
-+#define kProbInitValue (kBitModelTotal >> 1)
-+
-+#define kNumMoveReducingBits 4
-+#define kNumBitPriceShiftBits 4
-+#define kBitPrice (1 << kNumBitPriceShiftBits)
-+
-+void LzmaEncProps_Init(CLzmaEncProps *p)
-+{
-+  p->level = 5;
-+  p->dictSize = p->mc = 0;
-+  p->lc = p->lp = p->pb = p->algo = p->fb = p->btMode = p->numHashBytes = p->numThreads = -1;
-+  p->writeEndMark = 0;
-+}
-+
-+void LzmaEncProps_Normalize(CLzmaEncProps *p)
-+{
-+  int level = p->level;
-+  if (level < 0) level = 5;
-+  p->level = level;
-+  if (p->dictSize == 0) p->dictSize = (level <= 5 ? (1 << (level * 2 + 14)) : (level == 6 ? (1 << 25) : (1 << 26)));
-+  if (p->lc < 0) p->lc = 3;
-+  if (p->lp < 0) p->lp = 0;
-+  if (p->pb < 0) p->pb = 2;
-+  if (p->algo < 0) p->algo = (level < 5 ? 0 : 1);
-+  if (p->fb < 0) p->fb = (level < 7 ? 32 : 64);
-+  if (p->btMode < 0) p->btMode = (p->algo == 0 ? 0 : 1);
-+  if (p->numHashBytes < 0) p->numHashBytes = 4;
-+  if (p->mc == 0)  p->mc = (16 + (p->fb >> 1)) >> (p->btMode ? 0 : 1);
-+  if (p->numThreads < 0)
-+    p->numThreads =
-+      #ifndef _7ZIP_ST
-+      ((p->btMode && p->algo) ? 2 : 1);
-+      #else
-+      1;
-+      #endif
-+}
-+
-+UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
-+{
-+  CLzmaEncProps props = *props2;
-+  LzmaEncProps_Normalize(&props);
-+  return props.dictSize;
-+}
-+
-+/* #define LZMA_LOG_BSR */
-+/* Define it for Intel's CPU */
-+
-+
-+#ifdef LZMA_LOG_BSR
-+
-+#define kDicLogSizeMaxCompress 30
-+
-+#define BSR2_RET(pos, res) { unsigned long i; _BitScanReverse(&i, (pos)); res = (i + i) + ((pos >> (i - 1)) & 1); }
-+
-+UInt32 GetPosSlot1(UInt32 pos)
-+{
-+  UInt32 res;
-+  BSR2_RET(pos, res);
-+  return res;
-+}
-+#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
-+#define GetPosSlot(pos, res) { if (pos < 2) res = pos; else BSR2_RET(pos, res); }
-+
-+#else
-+
-+#define kNumLogBits (9 + (int)sizeof(size_t) / 2)
-+#define kDicLogSizeMaxCompress ((kNumLogBits - 1) * 2 + 7)
-+
-+void LzmaEnc_FastPosInit(Byte *g_FastPos)
-+{
-+  int c = 2, slotFast;
-+  g_FastPos[0] = 0;
-+  g_FastPos[1] = 1;
-+  
-+  for (slotFast = 2; slotFast < kNumLogBits * 2; slotFast++)
-+  {
-+    UInt32 k = (1 << ((slotFast >> 1) - 1));
-+    UInt32 j;
-+    for (j = 0; j < k; j++, c++)
-+      g_FastPos[c] = (Byte)slotFast;
-+  }
-+}
-+
-+#define BSR2_RET(pos, res) { UInt32 i = 6 + ((kNumLogBits - 1) & \
-+  (0 - (((((UInt32)1 << (kNumLogBits + 6)) - 1) - pos) >> 31))); \
-+  res = p->g_FastPos[pos >> i] + (i * 2); }
-+/*
-+#define BSR2_RET(pos, res) { res = (pos < (1 << (kNumLogBits + 6))) ? \
-+  p->g_FastPos[pos >> 6] + 12 : \
-+  p->g_FastPos[pos >> (6 + kNumLogBits - 1)] + (6 + (kNumLogBits - 1)) * 2; }
-+*/
-+
-+#define GetPosSlot1(pos) p->g_FastPos[pos]
-+#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
-+#define GetPosSlot(pos, res) { if (pos < kNumFullDistances) res = p->g_FastPos[pos]; else BSR2_RET(pos, res); }
-+
-+#endif
-+
-+
-+#define LZMA_NUM_REPS 4
-+
-+typedef unsigned CState;
-+
-+typedef struct
-+{
-+  UInt32 price;
-+
-+  CState state;
-+  int prev1IsChar;
-+  int prev2;
-+
-+  UInt32 posPrev2;
-+  UInt32 backPrev2;
-+
-+  UInt32 posPrev;
-+  UInt32 backPrev;
-+  UInt32 backs[LZMA_NUM_REPS];
-+} COptimal;
-+
-+#define kNumOpts (1 << 12)
-+
-+#define kNumLenToPosStates 4
-+#define kNumPosSlotBits 6
-+#define kDicLogSizeMin 0
-+#define kDicLogSizeMax 32
-+#define kDistTableSizeMax (kDicLogSizeMax * 2)
-+
-+
-+#define kNumAlignBits 4
-+#define kAlignTableSize (1 << kNumAlignBits)
-+#define kAlignMask (kAlignTableSize - 1)
-+
-+#define kStartPosModelIndex 4
-+#define kEndPosModelIndex 14
-+#define kNumPosModels (kEndPosModelIndex - kStartPosModelIndex)
-+
-+#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
-+
-+#ifdef _LZMA_PROB32
-+#define CLzmaProb UInt32
-+#else
-+#define CLzmaProb UInt16
-+#endif
-+
-+#define LZMA_PB_MAX 4
-+#define LZMA_LC_MAX 8
-+#define LZMA_LP_MAX 4
-+
-+#define LZMA_NUM_PB_STATES_MAX (1 << LZMA_PB_MAX)
-+
-+
-+#define kLenNumLowBits 3
-+#define kLenNumLowSymbols (1 << kLenNumLowBits)
-+#define kLenNumMidBits 3
-+#define kLenNumMidSymbols (1 << kLenNumMidBits)
-+#define kLenNumHighBits 8
-+#define kLenNumHighSymbols (1 << kLenNumHighBits)
-+
-+#define kLenNumSymbolsTotal (kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)
-+
-+#define LZMA_MATCH_LEN_MIN 2
-+#define LZMA_MATCH_LEN_MAX (LZMA_MATCH_LEN_MIN + kLenNumSymbolsTotal - 1)
-+
-+#define kNumStates 12
-+
-+typedef struct
-+{
-+  CLzmaProb choice;
-+  CLzmaProb choice2;
-+  CLzmaProb low[LZMA_NUM_PB_STATES_MAX << kLenNumLowBits];
-+  CLzmaProb mid[LZMA_NUM_PB_STATES_MAX << kLenNumMidBits];
-+  CLzmaProb high[kLenNumHighSymbols];
-+} CLenEnc;
-+
-+typedef struct
-+{
-+  CLenEnc p;
-+  UInt32 prices[LZMA_NUM_PB_STATES_MAX][kLenNumSymbolsTotal];
-+  UInt32 tableSize;
-+  UInt32 counters[LZMA_NUM_PB_STATES_MAX];
-+} CLenPriceEnc;
-+
-+typedef struct
-+{
-+  UInt32 range;
-+  Byte cache;
-+  UInt64 low;
-+  UInt64 cacheSize;
-+  Byte *buf;
-+  Byte *bufLim;
-+  Byte *bufBase;
-+  ISeqOutStream *outStream;
-+  UInt64 processed;
-+  SRes res;
-+} CRangeEnc;
-+
-+typedef struct
-+{
-+  CLzmaProb *litProbs;
-+
-+  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
-+  CLzmaProb isRep[kNumStates];
-+  CLzmaProb isRepG0[kNumStates];
-+  CLzmaProb isRepG1[kNumStates];
-+  CLzmaProb isRepG2[kNumStates];
-+  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];
-+
-+  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 << kNumPosSlotBits];
-+  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
-+  CLzmaProb posAlignEncoder[1 << kNumAlignBits];
-+  
-+  CLenPriceEnc lenEnc;
-+  CLenPriceEnc repLenEnc;
-+
-+  UInt32 reps[LZMA_NUM_REPS];
-+  UInt32 state;
-+} CSaveState;
-+
-+typedef struct
-+{
-+  IMatchFinder matchFinder;
-+  void *matchFinderObj;
-+
-+  #ifndef _7ZIP_ST
-+  Bool mtMode;
-+  CMatchFinderMt matchFinderMt;
-+  #endif
-+
-+  CMatchFinder matchFinderBase;
-+
-+  #ifndef _7ZIP_ST
-+  Byte pad[128];
-+  #endif
-+  
-+  UInt32 optimumEndIndex;
-+  UInt32 optimumCurrentIndex;
-+
-+  UInt32 longestMatchLength;
-+  UInt32 numPairs;
-+  UInt32 numAvail;
-+  COptimal opt[kNumOpts];
-+  
-+  #ifndef LZMA_LOG_BSR
-+  Byte g_FastPos[1 << kNumLogBits];
-+  #endif
-+
-+  UInt32 ProbPrices[kBitModelTotal >> kNumMoveReducingBits];
-+  UInt32 matches[LZMA_MATCH_LEN_MAX * 2 + 2 + 1];
-+  UInt32 numFastBytes;
-+  UInt32 additionalOffset;
-+  UInt32 reps[LZMA_NUM_REPS];
-+  UInt32 state;
-+
-+  UInt32 posSlotPrices[kNumLenToPosStates][kDistTableSizeMax];
-+  UInt32 distancesPrices[kNumLenToPosStates][kNumFullDistances];
-+  UInt32 alignPrices[kAlignTableSize];
-+  UInt32 alignPriceCount;
-+
-+  UInt32 distTableSize;
-+
-+  unsigned lc, lp, pb;
-+  unsigned lpMask, pbMask;
-+
-+  CLzmaProb *litProbs;
-+
-+  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
-+  CLzmaProb isRep[kNumStates];
-+  CLzmaProb isRepG0[kNumStates];
-+  CLzmaProb isRepG1[kNumStates];
-+  CLzmaProb isRepG2[kNumStates];
-+  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];
-+
-+  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 << kNumPosSlotBits];
-+  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
-+  CLzmaProb posAlignEncoder[1 << kNumAlignBits];
-+  
-+  CLenPriceEnc lenEnc;
-+  CLenPriceEnc repLenEnc;
-+
-+  unsigned lclp;
-+
-+  Bool fastMode;
-+  
-+  CRangeEnc rc;
-+
-+  Bool writeEndMark;
-+  UInt64 nowPos64;
-+  UInt32 matchPriceCount;
-+  Bool finished;
-+  Bool multiThread;
-+
-+  SRes result;
-+  UInt32 dictSize;
-+  UInt32 matchFinderCycles;
-+
-+  int needInit;
-+
-+  CSaveState saveState;
-+} CLzmaEnc;
-+
-+void LzmaEnc_SaveState(CLzmaEncHandle pp)
-+{
-+  CLzmaEnc *p = (CLzmaEnc *)pp;
-+  CSaveState *dest = &p->saveState;
-+  int i;
-+  dest->lenEnc = p->lenEnc;
-+  dest->repLenEnc = p->repLenEnc;
-+  dest->state = p->state;
-+
-+  for (i = 0; i < kNumStates; i++)
-+  {
-+    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
-+    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
-+  }
-+  for (i = 0; i < kNumLenToPosStates; i++)
-+    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
-+  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
-+  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
-+  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
-+  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
-+  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
-+  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
-+  memcpy(dest->reps, p->reps, sizeof(p->reps));
-+  memcpy(dest->litProbs, p->litProbs, (0x300 << p->lclp) * sizeof(CLzmaProb));
-+}
-+
-+void LzmaEnc_RestoreState(CLzmaEncHandle pp)
-+{
-+  CLzmaEnc *dest = (CLzmaEnc *)pp;
-+  const CSaveState *p = &dest->saveState;
-+  int i;
-+  dest->lenEnc = p->lenEnc;
-+  dest->repLenEnc = p->repLenEnc;
-+  dest->state = p->state;
-+
-+  for (i = 0; i < kNumStates; i++)
-+  {
-+    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
-+    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
-+  }
-+  for (i = 0; i < kNumLenToPosStates; i++)
-+    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
-+  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
-+  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
-+  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
-+  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
-+  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
-+  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
-+  memcpy(dest->reps, p->reps, sizeof(p->reps));
-+  memcpy(dest->litProbs, p->litProbs, (0x300 << dest->lclp) * sizeof(CLzmaProb));
-+}
-+
-+SRes LzmaEnc_SetProps(CLzmaEncHandle pp, const CLzmaEncProps *props2)
-+{
-+  CLzmaEnc *p = (CLzmaEnc *)pp;
-+  CLzmaEncProps props = *props2;
-+  LzmaEncProps_Normalize(&props);
-+
-+  if (props.lc > LZMA_LC_MAX || props.lp > LZMA_LP_MAX || props.pb > LZMA_PB_MAX ||
-+      props.dictSize > (1 << kDicLogSizeMaxCompress) || props.dictSize > (1 << 30))
-+    return SZ_ERROR_PARAM;
-+  p->dictSize = props.dictSize;
-+  p->matchFinderCycles = props.mc;
-+  {
-+    unsigned fb = props.fb;
-+    if (fb < 5)
-+      fb = 5;
-+    if (fb > LZMA_MATCH_LEN_MAX)
-+      fb = LZMA_MATCH_LEN_MAX;
-+    p->numFastBytes = fb;
-+  }
-+  p->lc = props.lc;
-+  p->lp = props.lp;
-+  p->pb = props.pb;
-+  p->fastMode = (props.algo == 0);
-+  p->matchFinderBase.btMode = props.btMode;
-+  {
-+    UInt32 numHashBytes = 4;
-+    if (props.btMode)
-+    {
-+      if (props.numHashBytes < 2)
-+        numHashBytes = 2;
-+      else if (props.numHashBytes < 4)
-+        numHashBytes = props.numHashBytes;
-+    }
-+    p->matchFinderBase.numHashBytes = numHashBytes;
-+  }
-+
-+  p->matchFinderBase.cutValue = props.mc;
-+
-+  p->writeEndMark = props.writeEndMark;
-+
-+  #ifndef _7ZIP_ST
-+  /*
-+  if (newMultiThread != _multiThread)
-+  {
-+    ReleaseMatchFinder();
-+    _multiThread = newMultiThread;
-+  }
-+  */
-+  p->multiThread = (props.numThreads > 1);
-+  #endif
-+
-+  return SZ_OK;
-+}
-+
-+static const int kLiteralNextStates[kNumStates] = {0, 0, 0, 0, 1, 2, 3, 4,  5,  6,   4, 5};
-+static const int kMatchNextStates[kNumStates]   = {7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10};
-+static const int kRepNextStates[kNumStates]     = {8, 8, 8, 8, 8, 8, 8, 11, 11, 11, 11, 11};
-+static const int kShortRepNextStates[kNumStates]= {9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11};
-+
-+#define IsCharState(s) ((s) < 7)
-+
-+#define GetLenToPosState(len) (((len) < kNumLenToPosStates + 1) ? (len) - 2 : kNumLenToPosStates - 1)
-+
-+#define kInfinityPrice (1 << 30)
-+
-+static void RangeEnc_Construct(CRangeEnc *p)
-+{
-+  p->outStream = 0;
-+  p->bufBase = 0;
-+}
-+
-+#define RangeEnc_GetProcessed(p) ((p)->processed + ((p)->buf - (p)->bufBase) + (p)->cacheSize)
-+
-+#define RC_BUF_SIZE (1 << 16)
-+static int RangeEnc_Alloc(CRangeEnc *p, ISzAlloc *alloc)
-+{
-+  if (p->bufBase == 0)
-+  {
-+    p->bufBase = (Byte *)alloc->Alloc(alloc, RC_BUF_SIZE);
-+    if (p->bufBase == 0)
-+      return 0;
-+    p->bufLim = p->bufBase + RC_BUF_SIZE;
-+  }
-+  return 1;
-+}
-+
-+static void RangeEnc_Free(CRangeEnc *p, ISzAlloc *alloc)
-+{
-+  alloc->Free(alloc, p->bufBase);
-+  p->bufBase = 0;
-+}
-+
-+static void RangeEnc_Init(CRangeEnc *p)
-+{
-+  /* Stream.Init(); */
-+  p->low = 0;
-+  p->range = 0xFFFFFFFF;
-+  p->cacheSize = 1;
-+  p->cache = 0;
-+
-+  p->buf = p->bufBase;
-+
-+  p->processed = 0;
-+  p->res = SZ_OK;
-+}
-+
-+static void RangeEnc_FlushStream(CRangeEnc *p)
-+{
-+  size_t num;
-+  if (p->res != SZ_OK)
-+    return;
-+  num = p->buf - p->bufBase;
-+  if (num != p->outStream->Write(p->outStream, p->bufBase, num))
-+    p->res = SZ_ERROR_WRITE;
-+  p->processed += num;
-+  p->buf = p->bufBase;
-+}
-+
-+static void MY_FAST_CALL RangeEnc_ShiftLow(CRangeEnc *p)
-+{
-+  if ((UInt32)p->low < (UInt32)0xFF000000 || (int)(p->low >> 32) != 0)
-+  {
-+    Byte temp = p->cache;
-+    do
-+    {
-+      Byte *buf = p->buf;
-+      *buf++ = (Byte)(temp + (Byte)(p->low >> 32));
-+      p->buf = buf;
-+      if (buf == p->bufLim)
-+        RangeEnc_FlushStream(p);
-+      temp = 0xFF;
-+    }
-+    while (--p->cacheSize != 0);
-+    p->cache = (Byte)((UInt32)p->low >> 24);
-+  }
-+  p->cacheSize++;
-+  p->low = (UInt32)p->low << 8;
-+}
-+
-+static void RangeEnc_FlushData(CRangeEnc *p)
-+{
-+  int i;
-+  for (i = 0; i < 5; i++)
-+    RangeEnc_ShiftLow(p);
-+}
-+
-+static void RangeEnc_EncodeDirectBits(CRangeEnc *p, UInt32 value, int numBits)
-+{
-+  do
-+  {
-+    p->range >>= 1;
-+    p->low += p->range & (0 - ((value >> --numBits) & 1));
-+    if (p->range < kTopValue)
-+    {
-+      p->range <<= 8;
-+      RangeEnc_ShiftLow(p);
-+    }
-+  }
-+  while (numBits != 0);
-+}
-+
-+static void RangeEnc_EncodeBit(CRangeEnc *p, CLzmaProb *prob, UInt32 symbol)
-+{
-+  UInt32 ttt = *prob;
-+  UInt32 newBound = (p->range >> kNumBitModelTotalBits) * ttt;
-+  if (symbol == 0)
-+  {
-+    p->range = newBound;
-+    ttt += (kBitModelTotal - ttt) >> kNumMoveBits;
-+  }
-+  else
-+  {
-+    p->low += newBound;
-+    p->range -= newBound;
-+    ttt -= ttt >> kNumMoveBits;
-+  }
-+  *prob = (CLzmaProb)ttt;
-+  if (p->range < kTopValue)
-+  {
-+    p->range <<= 8;
-+    RangeEnc_ShiftLow(p);
-+  }
-+}
-+
-+static void LitEnc_Encode(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol)
-+{
-+  symbol |= 0x100;
-+  do
-+  {
-+    RangeEnc_EncodeBit(p, probs + (symbol >> 8), (symbol >> 7) & 1);
-+    symbol <<= 1;
-+  }
-+  while (symbol < 0x10000);
-+}
-+
-+static void LitEnc_EncodeMatched(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol, UInt32 matchByte)
-+{
-+  UInt32 offs = 0x100;
-+  symbol |= 0x100;
-+  do
-+  {
-+    matchByte <<= 1;
-+    RangeEnc_EncodeBit(p, probs + (offs + (matchByte & offs) + (symbol >> 8)), (symbol >> 7) & 1);
-+    symbol <<= 1;
-+    offs &= ~(matchByte ^ symbol);
-+  }
-+  while (symbol < 0x10000);
-+}
-+
-+void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
-+{
-+  UInt32 i;
-+  for (i = (1 << kNumMoveReducingBits) / 2; i < kBitModelTotal; i += (1 << kNumMoveReducingBits))
-+  {
-+    const int kCyclesBits = kNumBitPriceShiftBits;
-+    UInt32 w = i;
-+    UInt32 bitCount = 0;
-+    int j;
-+    for (j = 0; j < kCyclesBits; j++)
-+    {
-+      w = w * w;
-+      bitCount <<= 1;
-+      while (w >= ((UInt32)1 << 16))
-+      {
-+        w >>= 1;
-+        bitCount++;
-+      }
-+    }
-+    ProbPrices[i >> kNumMoveReducingBits] = ((kNumBitModelTotalBits << kCyclesBits) - 15 - bitCount);
-+  }
-+}
-+
-+
-+#define GET_PRICE(prob, symbol) \
-+  p->ProbPrices[((prob) ^ (((-(int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];
-+
-+#define GET_PRICEa(prob, symbol) \
-+  ProbPrices[((prob) ^ ((-((int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];
-+
-+#define GET_PRICE_0(prob) p->ProbPrices[(prob) >> kNumMoveReducingBits]
-+#define GET_PRICE_1(prob) p->ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]
-+
-+#define GET_PRICE_0a(prob) ProbPrices[(prob) >> kNumMoveReducingBits]
-+#define GET_PRICE_1a(prob) ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]
-+
-+static UInt32 LitEnc_GetPrice(const CLzmaProb *probs, UInt32 symbol, UInt32 *ProbPrices)
-+{
-+  UInt32 price = 0;
-+  symbol |= 0x100;
-+  do
-+  {
-+    price += GET_PRICEa(probs[symbol >> 8], (symbol >> 7) & 1);
-+    symbol <<= 1;
-+  }
-+  while (symbol < 0x10000);
-+  return price;
-+}
-+
-+static UInt32 LitEnc_GetPriceMatched(const CLzmaProb *probs, UInt32 symbol, UInt32 matchByte, UInt32 *ProbPrices)
-+{
-+  UInt32 price = 0;
-+  UInt32 offs = 0x100;
-+  symbol |= 0x100;
-+  do
-+  {
-+    matchByte <<= 1;
-+    price += GET_PRICEa(probs[offs + (matchByte & offs) + (symbol >> 8)], (symbol >> 7) & 1);
-+    symbol <<= 1;
-+    offs &= ~(matchByte ^ symbol);
-+  }
-+  while (symbol < 0x10000);
-+  return price;
-+}
-+
-+
-+static void RcTree_Encode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
-+{
-+  UInt32 m = 1;
-+  int i;
-+  for (i = numBitLevels; i != 0;)
-+  {
-+    UInt32 bit;
-+    i--;
-+    bit = (symbol >> i) & 1;
-+    RangeEnc_EncodeBit(rc, probs + m, bit);
-+    m = (m << 1) | bit;
-+  }
-+}
-+
-+static void RcTree_ReverseEncode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
-+{
-+  UInt32 m = 1;
-+  int i;
-+  for (i = 0; i < numBitLevels; i++)
-+  {
-+    UInt32 bit = symbol & 1;
-+    RangeEnc_EncodeBit(rc, probs + m, bit);
-+    m = (m << 1) | bit;
-+    symbol >>= 1;
-+  }
-+}
-+
-+static UInt32 RcTree_GetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
-+{
-+  UInt32 price = 0;
-+  symbol |= (1 << numBitLevels);
-+  while (symbol != 1)
-+  {
-+    price += GET_PRICEa(probs[symbol >> 1], symbol & 1);
-+    symbol >>= 1;
-+  }
-+  return price;
-+}
-+
-+static UInt32 RcTree_ReverseGetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
-+{
-+  UInt32 price = 0;
-+  UInt32 m = 1;
-+  int i;
-+  for (i = numBitLevels; i != 0; i--)
-+  {
-+    UInt32 bit = symbol & 1;
-+    symbol >>= 1;
-+    price += GET_PRICEa(probs[m], bit);
-+    m = (m << 1) | bit;
-+  }
-+  return price;
-+}
-+
-+
-+static void LenEnc_Init(CLenEnc *p)
-+{
-+  unsigned i;
-+  p->choice = p->choice2 = kProbInitValue;
-+  for (i = 0; i < (LZMA_NUM_PB_STATES_MAX << kLenNumLowBits); i++)
-+    p->low[i] = kProbInitValue;
-+  for (i = 0; i < (LZMA_NUM_PB_STATES_MAX << kLenNumMidBits); i++)
-+    p->mid[i] = kProbInitValue;
-+  for (i = 0; i < kLenNumHighSymbols; i++)
-+    p->high[i] = kProbInitValue;
-+}
-+
-+static void LenEnc_Encode(CLenEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState)
-+{
-+  if (symbol < kLenNumLowSymbols)
-+  {
-+    RangeEnc_EncodeBit(rc, &p->choice, 0);
-+    RcTree_Encode(rc, p->low + (posState << kLenNumLowBits), kLenNumLowBits, symbol);
-+  }
-+  else
-+  {
-+    RangeEnc_EncodeBit(rc, &p->choice, 1);
-+    if (symbol < kLenNumLowSymbols + kLenNumMidSymbols)
-+    {
-+      RangeEnc_EncodeBit(rc, &p->choice2, 0);
-+      RcTree_Encode(rc, p->mid + (posState << kLenNumMidBits), kLenNumMidBits, symbol - kLenNumLowSymbols);
-+    }
-+    else
-+    {
-+      RangeEnc_EncodeBit(rc, &p->choice2, 1);
-+      RcTree_Encode(rc, p->high, kLenNumHighBits, symbol - kLenNumLowSymbols - kLenNumMidSymbols);
-+    }
-+  }
-+}
-+
-+static void LenEnc_SetPrices(CLenEnc *p, UInt32 posState, UInt32 numSymbols, UInt32 *prices, UInt32 *ProbPrices)
-+{
-+  UInt32 a0 = GET_PRICE_0a(p->choice);
-+  UInt32 a1 = GET_PRICE_1a(p->choice);
-+  UInt32 b0 = a1 + GET_PRICE_0a(p->choice2);
-+  UInt32 b1 = a1 + GET_PRICE_1a(p->choice2);
-+  UInt32 i = 0;
-+  for (i = 0; i < kLenNumLowSymbols; i++)
-+  {
-+    if (i >= numSymbols)
-+      return;
-+    prices[i] = a0 + RcTree_GetPrice(p->low + (posState << kLenNumLowBits), kLenNumLowBits, i, ProbPrices);
-+  }
-+  for (; i < kLenNumLowSymbols + kLenNumMidSymbols; i++)
-+  {
-+    if (i >= numSymbols)
-+      return;
-+    prices[i] = b0 + RcTree_GetPrice(p->mid + (posState << kLenNumMidBits), kLenNumMidBits, i - kLenNumLowSymbols, ProbPrices);
-+  }
-+  for (; i < numSymbols; i++)
-+    prices[i] = b1 + RcTree_GetPrice(p->high, kLenNumHighBits, i - kLenNumLowSymbols - kLenNumMidSymbols, ProbPrices);
-+}
-+
-+static void MY_FAST_CALL LenPriceEnc_UpdateTable(CLenPriceEnc *p, UInt32 posState, UInt32 *ProbPrices)
-+{
-+  LenEnc_SetPrices(&p->p, posState, p->tableSize, p->prices[posState], ProbPrices);
-+  p->counters[posState] = p->tableSize;
-+}
-+
-+static void LenPriceEnc_UpdateTables(CLenPriceEnc *p, UInt32 numPosStates, UInt32 *ProbPrices)
-+{
-+  UInt32 posState;
-+  for (posState = 0; posState < numPosStates; posState++)
-+    LenPriceEnc_UpdateTable(p, posState, ProbPrices);
-+}
-+
-+static void LenEnc_Encode2(CLenPriceEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState, Bool updatePrice, UInt32 *ProbPrices)
-+{
-+  LenEnc_Encode(&p->p, rc, symbol, posState);
-+  if (updatePrice)
-+    if (--p->counters[posState] == 0)
-+      LenPriceEnc_UpdateTable(p, posState, ProbPrices);
-+}
-+
-+
-+
-+
-+static void MovePos(CLzmaEnc *p, UInt32 num)
-+{
-+  #ifdef SHOW_STAT
-+  ttt += num;
-+  printf("\n MovePos %d", num);
-+  #endif
-+  if (num != 0)
-+  {
-+    p->additionalOffset += num;
-+    p->matchFinder.Skip(p->matchFinderObj, num);
-+  }
-+}
-+
-+static UInt32 ReadMatchDistances(CLzmaEnc *p, UInt32 *numDistancePairsRes)
-+{
-+  UInt32 lenRes = 0, numPairs;
-+  p->numAvail = p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
-+  numPairs = p->matchFinder.GetMatches(p->matchFinderObj, p->matches);
-+  #ifdef SHOW_STAT
-+  printf("\n i = %d numPairs = %d    ", ttt, numPairs / 2);
-+  ttt++;
-+  {
-+    UInt32 i;
-+    for (i = 0; i < numPairs; i += 2)
-+      printf("%2d %6d   | ", p->matches[i], p->matches[i + 1]);
-+  }
-+  #endif
-+  if (numPairs > 0)
-+  {
-+    lenRes = p->matches[numPairs - 2];
-+    if (lenRes == p->numFastBytes)
-+    {
-+      const Byte *pby = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
-+      UInt32 distance = p->matches[numPairs - 1] + 1;
-+      UInt32 numAvail = p->numAvail;
-+      if (numAvail > LZMA_MATCH_LEN_MAX)
-+        numAvail = LZMA_MATCH_LEN_MAX;
-+      {
-+        const Byte *pby2 = pby - distance;
-+        for (; lenRes < numAvail && pby[lenRes] == pby2[lenRes]; lenRes++);
-+      }
-+    }
-+  }
-+  p->additionalOffset++;
-+  *numDistancePairsRes = numPairs;
-+  return lenRes;
-+}
-+
-+
-+#define MakeAsChar(p) (p)->backPrev = (UInt32)(-1); (p)->prev1IsChar = False;
-+#define MakeAsShortRep(p) (p)->backPrev = 0; (p)->prev1IsChar = False;
-+#define IsShortRep(p) ((p)->backPrev == 0)
-+
-+static UInt32 GetRepLen1Price(CLzmaEnc *p, UInt32 state, UInt32 posState)
-+{
-+  return
-+    GET_PRICE_0(p->isRepG0[state]) +
-+    GET_PRICE_0(p->isRep0Long[state][posState]);
-+}
-+
-+static UInt32 GetPureRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 state, UInt32 posState)
-+{
-+  UInt32 price;
-+  if (repIndex == 0)
-+  {
-+    price = GET_PRICE_0(p->isRepG0[state]);
-+    price += GET_PRICE_1(p->isRep0Long[state][posState]);
-+  }
-+  else
-+  {
-+    price = GET_PRICE_1(p->isRepG0[state]);
-+    if (repIndex == 1)
-+      price += GET_PRICE_0(p->isRepG1[state]);
-+    else
-+    {
-+      price += GET_PRICE_1(p->isRepG1[state]);
-+      price += GET_PRICE(p->isRepG2[state], repIndex - 2);
-+    }
-+  }
-+  return price;
-+}
-+
-+static UInt32 GetRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 len, UInt32 state, UInt32 posState)
-+{
-+  return p->repLenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN] +
-+    GetPureRepPrice(p, repIndex, state, posState);
-+}
-+
-+static UInt32 Backward(CLzmaEnc *p, UInt32 *backRes, UInt32 cur)
-+{
-+  UInt32 posMem = p->opt[cur].posPrev;
-+  UInt32 backMem = p->opt[cur].backPrev;
-+  p->optimumEndIndex = cur;
-+  do
-+  {
-+    if (p->opt[cur].prev1IsChar)
-+    {
-+      MakeAsChar(&p->opt[posMem])
-+      p->opt[posMem].posPrev = posMem - 1;
-+      if (p->opt[cur].prev2)
-+      {
-+        p->opt[posMem - 1].prev1IsChar = False;
-+        p->opt[posMem - 1].posPrev = p->opt[cur].posPrev2;
-+        p->opt[posMem - 1].backPrev = p->opt[cur].backPrev2;
-+      }
-+    }
-+    {
-+      UInt32 posPrev = posMem;
-+      UInt32 backCur = backMem;
-+      
-+      backMem = p->opt[posPrev].backPrev;
-+      posMem = p->opt[posPrev].posPrev;
-+      
-+      p->opt[posPrev].backPrev = backCur;
-+      p->opt[posPrev].posPrev = cur;
-+      cur = posPrev;
-+    }
-+  }
-+  while (cur != 0);
-+  *backRes = p->opt[0].backPrev;
-+  p->optimumCurrentIndex  = p->opt[0].posPrev;
-+  return p->optimumCurrentIndex;
-+}
-+
-+#define LIT_PROBS(pos, prevByte) (p->litProbs + ((((pos) & p->lpMask) << p->lc) + ((prevByte) >> (8 - p->lc))) * 0x300)
-+
-+static UInt32 GetOptimum(CLzmaEnc *p, UInt32 position, UInt32 *backRes)
-+{
-+  UInt32 numAvail, mainLen, numPairs, repMaxIndex, i, posState, lenEnd, len, cur;
-+  UInt32 matchPrice, repMatchPrice, normalMatchPrice;
-+  UInt32 reps[LZMA_NUM_REPS], repLens[LZMA_NUM_REPS];
-+  UInt32 *matches;
-+  const Byte *data;
-+  Byte curByte, matchByte;
-+  if (p->optimumEndIndex != p->optimumCurrentIndex)
-+  {
-+    const COptimal *opt = &p->opt[p->optimumCurrentIndex];
-+    UInt32 lenRes = opt->posPrev - p->optimumCurrentIndex;
-+    *backRes = opt->backPrev;
-+    p->optimumCurrentIndex = opt->posPrev;
-+    return lenRes;
-+  }
-+  p->optimumCurrentIndex = p->optimumEndIndex = 0;
-+  
-+  if (p->additionalOffset == 0)
-+    mainLen = ReadMatchDistances(p, &numPairs);
-+  else
-+  {
-+    mainLen = p->longestMatchLength;
-+    numPairs = p->numPairs;
-+  }
-+
-+  numAvail = p->numAvail;
-+  if (numAvail < 2)
-+  {
-+    *backRes = (UInt32)(-1);
-+    return 1;
-+  }
-+  if (numAvail > LZMA_MATCH_LEN_MAX)
-+    numAvail = LZMA_MATCH_LEN_MAX;
-+
-+  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
-+  repMaxIndex = 0;
-+  for (i = 0; i < LZMA_NUM_REPS; i++)
-+  {
-+    UInt32 lenTest;
-+    const Byte *data2;
-+    reps[i] = p->reps[i];
-+    data2 = data - (reps[i] + 1);
-+    if (data[0] != data2[0] || data[1] != data2[1])
-+    {
-+      repLens[i] = 0;
-+      continue;
-+    }
-+    for (lenTest = 2; lenTest < numAvail && data[lenTest] == data2[lenTest]; lenTest++);
-+    repLens[i] = lenTest;
-+    if (lenTest > repLens[repMaxIndex])
-+      repMaxIndex = i;
-+  }
-+  if (repLens[repMaxIndex] >= p->numFastBytes)
-+  {
-+    UInt32 lenRes;
-+    *backRes = repMaxIndex;
-+    lenRes = repLens[repMaxIndex];
-+    MovePos(p, lenRes - 1);
-+    return lenRes;
-+  }
-+
-+  matches = p->matches;
-+  if (mainLen >= p->numFastBytes)
-+  {
-+    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
-+    MovePos(p, mainLen - 1);
-+    return mainLen;
-+  }
-+  curByte = *data;
-+  matchByte = *(data - (reps[0] + 1));
-+
-+  if (mainLen < 2 && curByte != matchByte && repLens[repMaxIndex] < 2)
-+  {
-+    *backRes = (UInt32)-1;
-+    return 1;
-+  }
-+
-+  p->opt[0].state = (CState)p->state;
-+
-+  posState = (position & p->pbMask);
-+
-+  {
-+    const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
-+    p->opt[1].price = GET_PRICE_0(p->isMatch[p->state][posState]) +
-+        (!IsCharState(p->state) ?
-+          LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
-+          LitEnc_GetPrice(probs, curByte, p->ProbPrices));
-+  }
-+
-+  MakeAsChar(&p->opt[1]);
-+
-+  matchPrice = GET_PRICE_1(p->isMatch[p->state][posState]);
-+  repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[p->state]);
-+
-+  if (matchByte == curByte)
-+  {
-+    UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, p->state, posState);
-+    if (shortRepPrice < p->opt[1].price)
-+    {
-+      p->opt[1].price = shortRepPrice;
-+      MakeAsShortRep(&p->opt[1]);
-+    }
-+  }
-+  lenEnd = ((mainLen >= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);
-+
-+  if (lenEnd < 2)
-+  {
-+    *backRes = p->opt[1].backPrev;
-+    return 1;
-+  }
-+
-+  p->opt[1].posPrev = 0;
-+  for (i = 0; i < LZMA_NUM_REPS; i++)
-+    p->opt[0].backs[i] = reps[i];
-+
-+  len = lenEnd;
-+  do
-+    p->opt[len--].price = kInfinityPrice;
-+  while (len >= 2);
-+
-+  for (i = 0; i < LZMA_NUM_REPS; i++)
-+  {
-+    UInt32 repLen = repLens[i];
-+    UInt32 price;
-+    if (repLen < 2)
-+      continue;
-+    price = repMatchPrice + GetPureRepPrice(p, i, p->state, posState);
-+    do
-+    {
-+      UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][repLen - 2];
-+      COptimal *opt = &p->opt[repLen];
-+      if (curAndLenPrice < opt->price)
-+      {
-+        opt->price = curAndLenPrice;
-+        opt->posPrev = 0;
-+        opt->backPrev = i;
-+        opt->prev1IsChar = False;
-+      }
-+    }
-+    while (--repLen >= 2);
-+  }
-+
-+  normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[p->state]);
-+
-+  len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
-+  if (len <= mainLen)
-+  {
-+    UInt32 offs = 0;
-+    while (len > matches[offs])
-+      offs += 2;
-+    for (; ; len++)
-+    {
-+      COptimal *opt;
-+      UInt32 distance = matches[offs + 1];
-+
-+      UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN];
-+      UInt32 lenToPosState = GetLenToPosState(len);
-+      if (distance < kNumFullDistances)
-+        curAndLenPrice += p->distancesPrices[lenToPosState][distance];
-+      else
-+      {
-+        UInt32 slot;
-+        GetPosSlot2(distance, slot);
-+        curAndLenPrice += p->alignPrices[distance & kAlignMask] + p->posSlotPrices[lenToPosState][slot];
-+      }
-+      opt = &p->opt[len];
-+      if (curAndLenPrice < opt->price)
-+      {
-+        opt->price = curAndLenPrice;
-+        opt->posPrev = 0;
-+        opt->backPrev = distance + LZMA_NUM_REPS;
-+        opt->prev1IsChar = False;
-+      }
-+      if (len == matches[offs])
-+      {
-+        offs += 2;
-+        if (offs == numPairs)
-+          break;
-+      }
-+    }
-+  }
-+
-+  cur = 0;
-+
-+    #ifdef SHOW_STAT2
-+    if (position >= 0)
-+    {
-+      unsigned i;
-+      printf("\n pos = %4X", position);
-+      for (i = cur; i <= lenEnd; i++)
-+      printf("\nprice[%4X] = %d", position - cur + i, p->opt[i].price);
-+    }
-+    #endif
-+
-+  for (;;)
-+  {
-+    UInt32 numAvailFull, newLen, numPairs, posPrev, state, posState, startLen;
-+    UInt32 curPrice, curAnd1Price, matchPrice, repMatchPrice;
-+    Bool nextIsChar;
-+    Byte curByte, matchByte;
-+    const Byte *data;
-+    COptimal *curOpt;
-+    COptimal *nextOpt;
-+
-+    cur++;
-+    if (cur == lenEnd)
-+      return Backward(p, backRes, cur);
-+
-+    newLen = ReadMatchDistances(p, &numPairs);
-+    if (newLen >= p->numFastBytes)
-+    {
-+      p->numPairs = numPairs;
-+      p->longestMatchLength = newLen;
-+      return Backward(p, backRes, cur);
-+    }
-+    position++;
-+    curOpt = &p->opt[cur];
-+    posPrev = curOpt->posPrev;
-+    if (curOpt->prev1IsChar)
-+    {
-+      posPrev--;
-+      if (curOpt->prev2)
-+      {
-+        state = p->opt[curOpt->posPrev2].state;
-+        if (curOpt->backPrev2 < LZMA_NUM_REPS)
-+          state = kRepNextStates[state];
-+        else
-+          state = kMatchNextStates[state];
-+      }
-+      else
-+        state = p->opt[posPrev].state;
-+      state = kLiteralNextStates[state];
-+    }
-+    else
-+      state = p->opt[posPrev].state;
-+    if (posPrev == cur - 1)
-+    {
-+      if (IsShortRep(curOpt))
-+        state = kShortRepNextStates[state];
-+      else
-+        state = kLiteralNextStates[state];
-+    }
-+    else
-+    {
-+      UInt32 pos;
-+      const COptimal *prevOpt;
-+      if (curOpt->prev1IsChar && curOpt->prev2)
-+      {
-+        posPrev = curOpt->posPrev2;
-+        pos = curOpt->backPrev2;
-+        state = kRepNextStates[state];
-+      }
-+      else
-+      {
-+        pos = curOpt->backPrev;
-+        if (pos < LZMA_NUM_REPS)
-+          state = kRepNextStates[state];
-+        else
-+          state = kMatchNextStates[state];
-+      }
-+      prevOpt = &p->opt[posPrev];
-+      if (pos < LZMA_NUM_REPS)
-+      {
-+        UInt32 i;
-+        reps[0] = prevOpt->backs[pos];
-+        for (i = 1; i <= pos; i++)
-+          reps[i] = prevOpt->backs[i - 1];
-+        for (; i < LZMA_NUM_REPS; i++)
-+          reps[i] = prevOpt->backs[i];
-+      }
-+      else
-+      {
-+        UInt32 i;
-+        reps[0] = (pos - LZMA_NUM_REPS);
-+        for (i = 1; i < LZMA_NUM_REPS; i++)
-+          reps[i] = prevOpt->backs[i - 1];
-+      }
-+    }
-+    curOpt->state = (CState)state;
-+
-+    curOpt->backs[0] = reps[0];
-+    curOpt->backs[1] = reps[1];
-+    curOpt->backs[2] = reps[2];
-+    curOpt->backs[3] = reps[3];
-+
-+    curPrice = curOpt->price;
-+    nextIsChar = False;
-+    data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
-+    curByte = *data;
-+    matchByte = *(data - (reps[0] + 1));
-+
-+    posState = (position & p->pbMask);
-+
-+    curAnd1Price = curPrice + GET_PRICE_0(p->isMatch[state][posState]);
-+    {
-+      const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
-+      curAnd1Price +=
-+        (!IsCharState(state) ?
-+          LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
-+          LitEnc_GetPrice(probs, curByte, p->ProbPrices));
-+    }
-+
-+    nextOpt = &p->opt[cur + 1];
-+
-+    if (curAnd1Price < nextOpt->price)
-+    {
-+      nextOpt->price = curAnd1Price;
-+      nextOpt->posPrev = cur;
-+      MakeAsChar(nextOpt);
-+      nextIsChar = True;
-+    }
-+
-+    matchPrice = curPrice + GET_PRICE_1(p->isMatch[state][posState]);
-+    repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[state]);
-+    
-+    if (matchByte == curByte && !(nextOpt->posPrev < cur && nextOpt->backPrev == 0))
-+    {
-+      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, state, posState);
-+      if (shortRepPrice <= nextOpt->price)
-+      {
-+        nextOpt->price = shortRepPrice;
-+        nextOpt->posPrev = cur;
-+        MakeAsShortRep(nextOpt);
-+        nextIsChar = True;
-+      }
-+    }
-+    numAvailFull = p->numAvail;
-+    {
-+      UInt32 temp = kNumOpts - 1 - cur;
-+      if (temp < numAvailFull)
-+        numAvailFull = temp;
-+    }
-+
-+    if (numAvailFull < 2)
-+      continue;
-+    numAvail = (numAvailFull <= p->numFastBytes ? numAvailFull : p->numFastBytes);
-+
-+    if (!nextIsChar && matchByte != curByte) /* speed optimization */
-+    {
-+      /* try Literal + rep0 */
-+      UInt32 temp;
-+      UInt32 lenTest2;
-+      const Byte *data2 = data - (reps[0] + 1);
-+      UInt32 limit = p->numFastBytes + 1;
-+      if (limit > numAvailFull)
-+        limit = numAvailFull;
-+
-+      for (temp = 1; temp < limit && data[temp] == data2[temp]; temp++);
-+      lenTest2 = temp - 1;
-+      if (lenTest2 >= 2)
-+      {
-+        UInt32 state2 = kLiteralNextStates[state];
-+        UInt32 posStateNext = (position + 1) & p->pbMask;
-+        UInt32 nextRepMatchPrice = curAnd1Price +
-+            GET_PRICE_1(p->isMatch[state2][posStateNext]) +
-+            GET_PRICE_1(p->isRep[state2]);
-+        /* for (; lenTest2 >= 2; lenTest2--) */
-+        {
-+          UInt32 curAndLenPrice;
-+          COptimal *opt;
-+          UInt32 offset = cur + 1 + lenTest2;
-+          while (lenEnd < offset)
-+            p->opt[++lenEnd].price = kInfinityPrice;
-+          curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
-+          opt = &p->opt[offset];
-+          if (curAndLenPrice < opt->price)
-+          {
-+            opt->price = curAndLenPrice;
-+            opt->posPrev = cur + 1;
-+            opt->backPrev = 0;
-+            opt->prev1IsChar = True;
-+            opt->prev2 = False;
-+          }
-+        }
-+      }
-+    }
-+    
-+    startLen = 2; /* speed optimization */
-+    {
-+    UInt32 repIndex;
-+    for (repIndex = 0; repIndex < LZMA_NUM_REPS; repIndex++)
-+    {
-+      UInt32 lenTest;
-+      UInt32 lenTestTemp;
-+      UInt32 price;
-+      const Byte *data2 = data - (reps[repIndex] + 1);
-+      if (data[0] != data2[0] || data[1] != data2[1])
-+        continue;
-+      for (lenTest = 2; lenTest < numAvail && data[lenTest] == data2[lenTest]; lenTest++);
-+      while (lenEnd < cur + lenTest)
-+        p->opt[++lenEnd].price = kInfinityPrice;
-+      lenTestTemp = lenTest;
-+      price = repMatchPrice + GetPureRepPrice(p, repIndex, state, posState);
-+      do
-+      {
-+        UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][lenTest - 2];
-+        COptimal *opt = &p->opt[cur + lenTest];
-+        if (curAndLenPrice < opt->price)
-+        {
-+          opt->price = curAndLenPrice;
-+          opt->posPrev = cur;
-+          opt->backPrev = repIndex;
-+          opt->prev1IsChar = False;
-+        }
-+      }
-+      while (--lenTest >= 2);
-+      lenTest = lenTestTemp;
-+      
-+      if (repIndex == 0)
-+        startLen = lenTest + 1;
-+        
-+      /* if (_maxMode) */
-+        {
-+          UInt32 lenTest2 = lenTest + 1;
-+          UInt32 limit = lenTest2 + p->numFastBytes;
-+          UInt32 nextRepMatchPrice;
-+          if (limit > numAvailFull)
-+            limit = numAvailFull;
-+          for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
-+          lenTest2 -= lenTest + 1;
-+          if (lenTest2 >= 2)
-+          {
-+            UInt32 state2 = kRepNextStates[state];
-+            UInt32 posStateNext = (position + lenTest) & p->pbMask;
-+            UInt32 curAndLenCharPrice =
-+                price + p->repLenEnc.prices[posState][lenTest - 2] +
-+                GET_PRICE_0(p->isMatch[state2][posStateNext]) +
-+                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
-+                    data[lenTest], data2[lenTest], p->ProbPrices);
-+            state2 = kLiteralNextStates[state2];
-+            posStateNext = (position + lenTest + 1) & p->pbMask;
-+            nextRepMatchPrice = curAndLenCharPrice +
-+                GET_PRICE_1(p->isMatch[state2][posStateNext]) +
-+                GET_PRICE_1(p->isRep[state2]);
-+            
-+            /* for (; lenTest2 >= 2; lenTest2--) */
-+            {
-+              UInt32 curAndLenPrice;
-+              COptimal *opt;
-+              UInt32 offset = cur + lenTest + 1 + lenTest2;
-+              while (lenEnd < offset)
-+                p->opt[++lenEnd].price = kInfinityPrice;
-+              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
-+              opt = &p->opt[offset];
-+              if (curAndLenPrice < opt->price)
-+              {
-+                opt->price = curAndLenPrice;
-+                opt->posPrev = cur + lenTest + 1;
-+                opt->backPrev = 0;
-+                opt->prev1IsChar = True;
-+                opt->prev2 = True;
-+                opt->posPrev2 = cur;
-+                opt->backPrev2 = repIndex;
-+              }
-+            }
-+          }
-+        }
-+    }
-+    }
-+    /* for (UInt32 lenTest = 2; lenTest <= newLen; lenTest++) */
-+    if (newLen > numAvail)
-+    {
-+      newLen = numAvail;
-+      for (numPairs = 0; newLen > matches[numPairs]; numPairs += 2);
-+      matches[numPairs] = newLen;
-+      numPairs += 2;
-+    }
-+    if (newLen >= startLen)
-+    {
-+      UInt32 normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[state]);
-+      UInt32 offs, curBack, posSlot;
-+      UInt32 lenTest;
-+      while (lenEnd < cur + newLen)
-+        p->opt[++lenEnd].price = kInfinityPrice;
-+
-+      offs = 0;
-+      while (startLen > matches[offs])
-+        offs += 2;
-+      curBack = matches[offs + 1];
-+      GetPosSlot2(curBack, posSlot);
-+      for (lenTest = /*2*/ startLen; ; lenTest++)
-+      {
-+        UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][lenTest - LZMA_MATCH_LEN_MIN];
-+        UInt32 lenToPosState = GetLenToPosState(lenTest);
-+        COptimal *opt;
-+        if (curBack < kNumFullDistances)
-+          curAndLenPrice += p->distancesPrices[lenToPosState][curBack];
-+        else
-+          curAndLenPrice += p->posSlotPrices[lenToPosState][posSlot] + p->alignPrices[curBack & kAlignMask];
-+        
-+        opt = &p->opt[cur + lenTest];
-+        if (curAndLenPrice < opt->price)
-+        {
-+          opt->price = curAndLenPrice;
-+          opt->posPrev = cur;
-+          opt->backPrev = curBack + LZMA_NUM_REPS;
-+          opt->prev1IsChar = False;
-+        }
-+
-+        if (/*_maxMode && */lenTest == matches[offs])
-+        {
-+          /* Try Match + Literal + Rep0 */
-+          const Byte *data2 = data - (curBack + 1);
-+          UInt32 lenTest2 = lenTest + 1;
-+          UInt32 limit = lenTest2 + p->numFastBytes;
-+          UInt32 nextRepMatchPrice;
-+          if (limit > numAvailFull)
-+            limit = numAvailFull;
-+          for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
-+          lenTest2 -= lenTest + 1;
-+          if (lenTest2 >= 2)
-+          {
-+            UInt32 state2 = kMatchNextStates[state];
-+            UInt32 posStateNext = (position + lenTest) & p->pbMask;
-+            UInt32 curAndLenCharPrice = curAndLenPrice +
-+                GET_PRICE_0(p->isMatch[state2][posStateNext]) +
-+                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
-+                    data[lenTest], data2[lenTest], p->ProbPrices);
-+            state2 = kLiteralNextStates[state2];
-+            posStateNext = (posStateNext + 1) & p->pbMask;
-+            nextRepMatchPrice = curAndLenCharPrice +
-+                GET_PRICE_1(p->isMatch[state2][posStateNext]) +
-+                GET_PRICE_1(p->isRep[state2]);
-+            
-+            /* for (; lenTest2 >= 2; lenTest2--) */
-+            {
-+              UInt32 offset = cur + lenTest + 1 + lenTest2;
-+              UInt32 curAndLenPrice;
-+              COptimal *opt;
-+              while (lenEnd < offset)
-+                p->opt[++lenEnd].price = kInfinityPrice;
-+              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
-+              opt = &p->opt[offset];
-+              if (curAndLenPrice < opt->price)
-+              {
-+                opt->price = curAndLenPrice;
-+                opt->posPrev = cur + lenTest + 1;
-+                opt->backPrev = 0;
-+                opt->prev1IsChar = True;
-+                opt->prev2 = True;
-+                opt->posPrev2 = cur;
-+                opt->backPrev2 = curBack + LZMA_NUM_REPS;
-+              }
-+            }
-+          }
-+          offs += 2;
-+          if (offs == numPairs)
-+            break;
-+          curBack = matches[offs + 1];
-+          if (curBack >= kNumFullDistances)
-+            GetPosSlot2(curBack, posSlot);
-+        }
-+      }
-+    }
-+  }
-+}
-+
-+#define ChangePair(smallDist, bigDist) (((bigDist) >> 7) > (smallDist))
-+
-+static UInt32 GetOptimumFast(CLzmaEnc *p, UInt32 *backRes)
-+{
-+  UInt32 numAvail, mainLen, mainDist, numPairs, repIndex, repLen, i;
-+  const Byte *data;
-+  const UInt32 *matches;
-+
-+  if (p->additionalOffset == 0)
-+    mainLen = ReadMatchDistances(p, &numPairs);
-+  else
-+  {
-+    mainLen = p->longestMatchLength;
-+    numPairs = p->numPairs;
-+  }
-+
-+  numAvail = p->numAvail;
-+  *backRes = (UInt32)-1;
-+  if (numAvail < 2)
-+    return 1;
-+  if (numAvail > LZMA_MATCH_LEN_MAX)
-+    numAvail = LZMA_MATCH_LEN_MAX;
-+  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
-+
-+  repLen = repIndex = 0;
-+  for (i = 0; i < LZMA_NUM_REPS; i++)
-+  {
-+    UInt32 len;
-+    const Byte *data2 = data - (p->reps[i] + 1);
-+    if (data[0] != data2[0] || data[1] != data2[1])
-+      continue;
-+    for (len = 2; len < numAvail && data[len] == data2[len]; len++);
-+    if (len >= p->numFastBytes)
-+    {
-+      *backRes = i;
-+      MovePos(p, len - 1);
-+      return len;
-+    }
-+    if (len > repLen)
-+    {
-+      repIndex = i;
-+      repLen = len;
-+    }
-+  }
-+
-+  matches = p->matches;
-+  if (mainLen >= p->numFastBytes)
-+  {
-+    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
-+    MovePos(p, mainLen - 1);
-+    return mainLen;
-+  }
-+
-+  mainDist = 0; /* for GCC */
-+  if (mainLen >= 2)
-+  {
-+    mainDist = matches[numPairs - 1];
-+    while (numPairs > 2 && mainLen == matches[numPairs - 4] + 1)
-+    {
-+      if (!ChangePair(matches[numPairs - 3], mainDist))
-+        break;
-+      numPairs -= 2;
-+      mainLen = matches[numPairs - 2];
-+      mainDist = matches[numPairs - 1];
-+    }
-+    if (mainLen == 2 && mainDist >= 0x80)
-+      mainLen = 1;
-+  }
-+
-+  if (repLen >= 2 && (
-+        (repLen + 1 >= mainLen) ||
-+        (repLen + 2 >= mainLen && mainDist >= (1 << 9)) ||
-+        (repLen + 3 >= mainLen && mainDist >= (1 << 15))))
-+  {
-+    *backRes = repIndex;
-+    MovePos(p, repLen - 1);
-+    return repLen;
-+  }
-+  
-+  if (mainLen < 2 || numAvail <= 2)
-+    return 1;
-+
-+  p->longestMatchLength = ReadMatchDistances(p, &p->numPairs);
-+  if (p->longestMatchLength >= 2)
-+  {
-+    UInt32 newDistance = matches[p->numPairs - 1];
-+    if ((p->longestMatchLength >= mainLen && newDistance < mainDist) ||
-+        (p->longestMatchLength == mainLen + 1 && !ChangePair(mainDist, newDistance)) ||
-+        (p->longestMatchLength > mainLen + 1) ||
-+        (p->longestMatchLength + 1 >= mainLen && mainLen >= 3 && ChangePair(newDistance, mainDist)))
-+      return 1;
-+  }
-+  
-+  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
-+  for (i = 0; i < LZMA_NUM_REPS; i++)
-+  {
-+    UInt32 len, limit;
-+    const Byte *data2 = data - (p->reps[i] + 1);
-+    if (data[0] != data2[0] || data[1] != data2[1])
-+      continue;
-+    limit = mainLen - 1;
-+    for (len = 2; len < limit && data[len] == data2[len]; len++);
-+    if (len >= limit)
-+      return 1;
-+  }
-+  *backRes = mainDist + LZMA_NUM_REPS;
-+  MovePos(p, mainLen - 2);
-+  return mainLen;
-+}
-+
-+static void WriteEndMarker(CLzmaEnc *p, UInt32 posState)
-+{
-+  UInt32 len;
-+  RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 1);
-+  RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 0);
-+  p->state = kMatchNextStates[p->state];
-+  len = LZMA_MATCH_LEN_MIN;
-+  LenEnc_Encode2(&p->lenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
-+  RcTree_Encode(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, (1 << kNumPosSlotBits) - 1);
-+  RangeEnc_EncodeDirectBits(&p->rc, (((UInt32)1 << 30) - 1) >> kNumAlignBits, 30 - kNumAlignBits);
-+  RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, kAlignMask);
-+}
-+
-+static SRes CheckErrors(CLzmaEnc *p)
-+{
-+  if (p->result != SZ_OK)
-+    return p->result;
-+  if (p->rc.res != SZ_OK)
-+    p->result = SZ_ERROR_WRITE;
-+  if (p->matchFinderBase.result != SZ_OK)
-+    p->result = SZ_ERROR_READ;
-+  if (p->result != SZ_OK)
-+    p->finished = True;
-+  return p->result;
-+}
-+
-+static SRes Flush(CLzmaEnc *p, UInt32 nowPos)
-+{
-+  /* ReleaseMFStream(); */
-+  p->finished = True;
-+  if (p->writeEndMark)
-+    WriteEndMarker(p, nowPos & p->pbMask);
-+  RangeEnc_FlushData(&p->rc);
-+  RangeEnc_FlushStream(&p->rc);
-+  return CheckErrors(p);
-+}
-+
-+static void FillAlignPrices(CLzmaEnc *p)
-+{
-+  UInt32 i;
-+  for (i = 0; i < kAlignTableSize; i++)
-+    p->alignPrices[i] = RcTree_ReverseGetPrice(p->posAlignEncoder, kNumAlignBits, i, p->ProbPrices);
-+  p->alignPriceCount = 0;
-+}
-+
-+static void FillDistancesPrices(CLzmaEnc *p)
-+{
-+  UInt32 tempPrices[kNumFullDistances];
-+  UInt32 i, lenToPosState;
-+  for (i = kStartPosModelIndex; i < kNumFullDistances; i++)
-+  {
-+    UInt32 posSlot = GetPosSlot1(i);
-+    UInt32 footerBits = ((posSlot >> 1) - 1);
-+    UInt32 base = ((2 | (posSlot & 1)) << footerBits);
-+    tempPrices[i] = RcTree_ReverseGetPrice(p->posEncoders + base - posSlot - 1, footerBits, i - base, p->ProbPrices);
-+  }
-+
-+  for (lenToPosState = 0; lenToPosState < kNumLenToPosStates; lenToPosState++)
-+  {
-+    UInt32 posSlot;
-+    const CLzmaProb *encoder = p->posSlotEncoder[lenToPosState];
-+    UInt32 *posSlotPrices = p->posSlotPrices[lenToPosState];
-+    for (posSlot = 0; posSlot < p->distTableSize; posSlot++)
-+      posSlotPrices[posSlot] = RcTree_GetPrice(encoder, kNumPosSlotBits, posSlot, p->ProbPrices);
-+    for (posSlot = kEndPosModelIndex; posSlot < p->distTableSize; posSlot++)
-+      posSlotPrices[posSlot] += ((((posSlot >> 1) - 1) - kNumAlignBits) << kNumBitPriceShiftBits);
-+
-+    {
-+      UInt32 *distancesPrices = p->distancesPrices[lenToPosState];
-+      UInt32 i;
-+      for (i = 0; i < kStartPosModelIndex; i++)
-+        distancesPrices[i] = posSlotPrices[i];
-+      for (; i < kNumFullDistances; i++)
-+        distancesPrices[i] = posSlotPrices[GetPosSlot1(i)] + tempPrices[i];
-+    }
-+  }
-+  p->matchPriceCount = 0;
-+}
-+
-+void LzmaEnc_Construct(CLzmaEnc *p)
-+{
-+  RangeEnc_Construct(&p->rc);
-+  MatchFinder_Construct(&p->matchFinderBase);
-+  #ifndef _7ZIP_ST
-+  MatchFinderMt_Construct(&p->matchFinderMt);
-+  p->matchFinderMt.MatchFinder = &p->matchFinderBase;
-+  #endif
-+
-+  {
-+    CLzmaEncProps props;
-+    LzmaEncProps_Init(&props);
-+    LzmaEnc_SetProps(p, &props);
-+  }
-+
-+  #ifndef LZMA_LOG_BSR
-+  LzmaEnc_FastPosInit(p->g_FastPos);
-+  #endif
-+
-+  LzmaEnc_InitPriceTables(p->ProbPrices);
-+  p->litProbs = 0;
-+  p->saveState.litProbs = 0;
-+}
-+
-+CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc)
-+{
-+  void *p;
-+  p = alloc->Alloc(alloc, sizeof(CLzmaEnc));
-+  if (p != 0)
-+    LzmaEnc_Construct((CLzmaEnc *)p);
-+  return p;
-+}
-+
-+void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
-+{
-+  alloc->Free(alloc, p->litProbs);
-+  alloc->Free(alloc, p->saveState.litProbs);
-+  p->litProbs = 0;
-+  p->saveState.litProbs = 0;
-+}
-+
-+void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  #ifndef _7ZIP_ST
-+  MatchFinderMt_Destruct(&p->matchFinderMt, allocBig);
-+  #endif
-+  MatchFinder_Free(&p->matchFinderBase, allocBig);
-+  LzmaEnc_FreeLits(p, alloc);
-+  RangeEnc_Free(&p->rc, alloc);
-+}
-+
-+void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  LzmaEnc_Destruct((CLzmaEnc *)p, alloc, allocBig);
-+  alloc->Free(alloc, p);
-+}
-+
-+static SRes LzmaEnc_CodeOneBlock(CLzmaEnc *p, Bool useLimits, UInt32 maxPackSize, UInt32 maxUnpackSize)
-+{
-+  UInt32 nowPos32, startPos32;
-+  if (p->needInit)
-+  {
-+    p->matchFinder.Init(p->matchFinderObj);
-+    p->needInit = 0;
-+  }
-+
-+  if (p->finished)
-+    return p->result;
-+  RINOK(CheckErrors(p));
-+
-+  nowPos32 = (UInt32)p->nowPos64;
-+  startPos32 = nowPos32;
-+
-+  if (p->nowPos64 == 0)
-+  {
-+    UInt32 numPairs;
-+    Byte curByte;
-+    if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
-+      return Flush(p, nowPos32);
-+    ReadMatchDistances(p, &numPairs);
-+    RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][0], 0);
-+    p->state = kLiteralNextStates[p->state];
-+    curByte = p->matchFinder.GetIndexByte(p->matchFinderObj, 0 - p->additionalOffset);
-+    LitEnc_Encode(&p->rc, p->litProbs, curByte);
-+    p->additionalOffset--;
-+    nowPos32++;
-+  }
-+
-+  if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) != 0)
-+  for (;;)
-+  {
-+    UInt32 pos, len, posState;
-+
-+    if (p->fastMode)
-+      len = GetOptimumFast(p, &pos);
-+    else
-+      len = GetOptimum(p, nowPos32, &pos);
-+
-+    #ifdef SHOW_STAT2
-+    printf("\n pos = %4X,   len = %d   pos = %d", nowPos32, len, pos);
-+    #endif
-+
-+    posState = nowPos32 & p->pbMask;
-+    if (len == 1 && pos == (UInt32)-1)
-+    {
-+      Byte curByte;
-+      CLzmaProb *probs;
-+      const Byte *data;
-+
-+      RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 0);
-+      data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
-+      curByte = *data;
-+      probs = LIT_PROBS(nowPos32, *(data - 1));
-+      if (IsCharState(p->state))
-+        LitEnc_Encode(&p->rc, probs, curByte);
-+      else
-+        LitEnc_EncodeMatched(&p->rc, probs, curByte, *(data - p->reps[0] - 1));
-+      p->state = kLiteralNextStates[p->state];
-+    }
-+    else
-+    {
-+      RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 1);
-+      if (pos < LZMA_NUM_REPS)
-+      {
-+        RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 1);
-+        if (pos == 0)
-+        {
-+          RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 0);
-+          RangeEnc_EncodeBit(&p->rc, &p->isRep0Long[p->state][posState], ((len == 1) ? 0 : 1));
-+        }
-+        else
-+        {
-+          UInt32 distance = p->reps[pos];
-+          RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 1);
-+          if (pos == 1)
-+            RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 0);
-+          else
-+          {
-+            RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 1);
-+            RangeEnc_EncodeBit(&p->rc, &p->isRepG2[p->state], pos - 2);
-+            if (pos == 3)
-+              p->reps[3] = p->reps[2];
-+            p->reps[2] = p->reps[1];
-+          }
-+          p->reps[1] = p->reps[0];
-+          p->reps[0] = distance;
-+        }
-+        if (len == 1)
-+          p->state = kShortRepNextStates[p->state];
-+        else
-+        {
-+          LenEnc_Encode2(&p->repLenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
-+          p->state = kRepNextStates[p->state];
-+        }
-+      }
-+      else
-+      {
-+        UInt32 posSlot;
-+        RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 0);
-+        p->state = kMatchNextStates[p->state];
-+        LenEnc_Encode2(&p->lenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
-+        pos -= LZMA_NUM_REPS;
-+        GetPosSlot(pos, posSlot);
-+        RcTree_Encode(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, posSlot);
-+        
-+        if (posSlot >= kStartPosModelIndex)
-+        {
-+          UInt32 footerBits = ((posSlot >> 1) - 1);
-+          UInt32 base = ((2 | (posSlot & 1)) << footerBits);
-+          UInt32 posReduced = pos - base;
-+
-+          if (posSlot < kEndPosModelIndex)
-+            RcTree_ReverseEncode(&p->rc, p->posEncoders + base - posSlot - 1, footerBits, posReduced);
-+          else
-+          {
-+            RangeEnc_EncodeDirectBits(&p->rc, posReduced >> kNumAlignBits, footerBits - kNumAlignBits);
-+            RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, posReduced & kAlignMask);
-+            p->alignPriceCount++;
-+          }
-+        }
-+        p->reps[3] = p->reps[2];
-+        p->reps[2] = p->reps[1];
-+        p->reps[1] = p->reps[0];
-+        p->reps[0] = pos;
-+        p->matchPriceCount++;
-+      }
-+    }
-+    p->additionalOffset -= len;
-+    nowPos32 += len;
-+    if (p->additionalOffset == 0)
-+    {
-+      UInt32 processed;
-+      if (!p->fastMode)
-+      {
-+        if (p->matchPriceCount >= (1 << 7))
-+          FillDistancesPrices(p);
-+        if (p->alignPriceCount >= kAlignTableSize)
-+          FillAlignPrices(p);
-+      }
-+      if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
-+        break;
-+      processed = nowPos32 - startPos32;
-+      if (useLimits)
-+      {
-+        if (processed + kNumOpts + 300 >= maxUnpackSize ||
-+            RangeEnc_GetProcessed(&p->rc) + kNumOpts * 2 >= maxPackSize)
-+          break;
-+      }
-+      else if (processed >= (1 << 15))
-+      {
-+        p->nowPos64 += nowPos32 - startPos32;
-+        return CheckErrors(p);
-+      }
-+    }
-+  }
-+  p->nowPos64 += nowPos32 - startPos32;
-+  return Flush(p, nowPos32);
-+}
-+
-+#define kBigHashDicLimit ((UInt32)1 << 24)
-+
-+static SRes LzmaEnc_Alloc(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  UInt32 beforeSize = kNumOpts;
-+  Bool btMode;
-+  if (!RangeEnc_Alloc(&p->rc, alloc))
-+    return SZ_ERROR_MEM;
-+  btMode = (p->matchFinderBase.btMode != 0);
-+  #ifndef _7ZIP_ST
-+  p->mtMode = (p->multiThread && !p->fastMode && btMode);
-+  #endif
-+
-+  {
-+    unsigned lclp = p->lc + p->lp;
-+    if (p->litProbs == 0 || p->saveState.litProbs == 0 || p->lclp != lclp)
-+    {
-+      LzmaEnc_FreeLits(p, alloc);
-+      p->litProbs = (CLzmaProb *)alloc->Alloc(alloc, (0x300 << lclp) * sizeof(CLzmaProb));
-+      p->saveState.litProbs = (CLzmaProb *)alloc->Alloc(alloc, (0x300 << lclp) * sizeof(CLzmaProb));
-+      if (p->litProbs == 0 || p->saveState.litProbs == 0)
-+      {
-+        LzmaEnc_FreeLits(p, alloc);
-+        return SZ_ERROR_MEM;
-+      }
-+      p->lclp = lclp;
-+    }
-+  }
-+
-+  p->matchFinderBase.bigHash = (p->dictSize > kBigHashDicLimit);
-+
-+  if (beforeSize + p->dictSize < keepWindowSize)
-+    beforeSize = keepWindowSize - p->dictSize;
-+
-+  #ifndef _7ZIP_ST
-+  if (p->mtMode)
-+  {
-+    RINOK(MatchFinderMt_Create(&p->matchFinderMt, p->dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX, allocBig));
-+    p->matchFinderObj = &p->matchFinderMt;
-+    MatchFinderMt_CreateVTable(&p->matchFinderMt, &p->matchFinder);
-+  }
-+  else
-+  #endif
-+  {
-+    if (!MatchFinder_Create(&p->matchFinderBase, p->dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX, allocBig))
-+      return SZ_ERROR_MEM;
-+    p->matchFinderObj = &p->matchFinderBase;
-+    MatchFinder_CreateVTable(&p->matchFinderBase, &p->matchFinder);
-+  }
-+  return SZ_OK;
-+}
-+
-+void LzmaEnc_Init(CLzmaEnc *p)
-+{
-+  UInt32 i;
-+  p->state = 0;
-+  for (i = 0 ; i < LZMA_NUM_REPS; i++)
-+    p->reps[i] = 0;
-+
-+  RangeEnc_Init(&p->rc);
-+
-+
-+  for (i = 0; i < kNumStates; i++)
-+  {
-+    UInt32 j;
-+    for (j = 0; j < LZMA_NUM_PB_STATES_MAX; j++)
-+    {
-+      p->isMatch[i][j] = kProbInitValue;
-+      p->isRep0Long[i][j] = kProbInitValue;
-+    }
-+    p->isRep[i] = kProbInitValue;
-+    p->isRepG0[i] = kProbInitValue;
-+    p->isRepG1[i] = kProbInitValue;
-+    p->isRepG2[i] = kProbInitValue;
-+  }
-+
-+  {
-+    UInt32 num = 0x300 << (p->lp + p->lc);
-+    for (i = 0; i < num; i++)
-+      p->litProbs[i] = kProbInitValue;
-+  }
-+
-+  {
-+    for (i = 0; i < kNumLenToPosStates; i++)
-+    {
-+      CLzmaProb *probs = p->posSlotEncoder[i];
-+      UInt32 j;
-+      for (j = 0; j < (1 << kNumPosSlotBits); j++)
-+        probs[j] = kProbInitValue;
-+    }
-+  }
-+  {
-+    for (i = 0; i < kNumFullDistances - kEndPosModelIndex; i++)
-+      p->posEncoders[i] = kProbInitValue;
-+  }
-+
-+  LenEnc_Init(&p->lenEnc.p);
-+  LenEnc_Init(&p->repLenEnc.p);
-+
-+  for (i = 0; i < (1 << kNumAlignBits); i++)
-+    p->posAlignEncoder[i] = kProbInitValue;
-+
-+  p->optimumEndIndex = 0;
-+  p->optimumCurrentIndex = 0;
-+  p->additionalOffset = 0;
-+
-+  p->pbMask = (1 << p->pb) - 1;
-+  p->lpMask = (1 << p->lp) - 1;
-+}
-+
-+void LzmaEnc_InitPrices(CLzmaEnc *p)
-+{
-+  if (!p->fastMode)
-+  {
-+    FillDistancesPrices(p);
-+    FillAlignPrices(p);
-+  }
-+
-+  p->lenEnc.tableSize =
-+  p->repLenEnc.tableSize =
-+      p->numFastBytes + 1 - LZMA_MATCH_LEN_MIN;
-+  LenPriceEnc_UpdateTables(&p->lenEnc, 1 << p->pb, p->ProbPrices);
-+  LenPriceEnc_UpdateTables(&p->repLenEnc, 1 << p->pb, p->ProbPrices);
-+}
-+
-+static SRes LzmaEnc_AllocAndInit(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  UInt32 i;
-+  for (i = 0; i < (UInt32)kDicLogSizeMaxCompress; i++)
-+    if (p->dictSize <= ((UInt32)1 << i))
-+      break;
-+  p->distTableSize = i * 2;
-+
-+  p->finished = False;
-+  p->result = SZ_OK;
-+  RINOK(LzmaEnc_Alloc(p, keepWindowSize, alloc, allocBig));
-+  LzmaEnc_Init(p);
-+  LzmaEnc_InitPrices(p);
-+  p->nowPos64 = 0;
-+  return SZ_OK;
-+}
-+
-+static SRes LzmaEnc_Prepare(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream,
-+    ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  CLzmaEnc *p = (CLzmaEnc *)pp;
-+  p->matchFinderBase.stream = inStream;
-+  p->needInit = 1;
-+  p->rc.outStream = outStream;
-+  return LzmaEnc_AllocAndInit(p, 0, alloc, allocBig);
-+}
-+
-+SRes LzmaEnc_PrepareForLzma2(CLzmaEncHandle pp,
-+    ISeqInStream *inStream, UInt32 keepWindowSize,
-+    ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  CLzmaEnc *p = (CLzmaEnc *)pp;
-+  p->matchFinderBase.stream = inStream;
-+  p->needInit = 1;
-+  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
-+}
-+
-+static void LzmaEnc_SetInputBuf(CLzmaEnc *p, const Byte *src, SizeT srcLen)
-+{
-+  p->matchFinderBase.directInput = 1;
-+  p->matchFinderBase.bufferBase = (Byte *)src;
-+  p->matchFinderBase.directInputRem = srcLen;
-+}
-+
-+SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
-+    UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  CLzmaEnc *p = (CLzmaEnc *)pp;
-+  LzmaEnc_SetInputBuf(p, src, srcLen);
-+  p->needInit = 1;
-+
-+  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
-+}
-+
-+void LzmaEnc_Finish(CLzmaEncHandle pp)
-+{
-+  #ifndef _7ZIP_ST
-+  CLzmaEnc *p = (CLzmaEnc *)pp;
-+  if (p->mtMode)
-+    MatchFinderMt_ReleaseStream(&p->matchFinderMt);
-+  #else
-+  pp = pp;
-+  #endif
-+}
-+
-+typedef struct
-+{
-+  ISeqOutStream funcTable;
-+  Byte *data;
-+  SizeT rem;
-+  Bool overflow;
-+} CSeqOutStreamBuf;
-+
-+static size_t MyWrite(void *pp, const void *data, size_t size)
-+{
-+  CSeqOutStreamBuf *p = (CSeqOutStreamBuf *)pp;
-+  if (p->rem < size)
-+  {
-+    size = p->rem;
-+    p->overflow = True;
-+  }
-+  memcpy(p->data, data, size);
-+  p->rem -= size;
-+  p->data += size;
-+  return size;
-+}
-+
-+
-+UInt32 LzmaEnc_GetNumAvailableBytes(CLzmaEncHandle pp)
-+{
-+  const CLzmaEnc *p = (CLzmaEnc *)pp;
-+  return p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
-+}
-+
-+const Byte *LzmaEnc_GetCurBuf(CLzmaEncHandle pp)
-+{
-+  const CLzmaEnc *p = (CLzmaEnc *)pp;
-+  return p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
-+}
-+
-+SRes LzmaEnc_CodeOneMemBlock(CLzmaEncHandle pp, Bool reInit,
-+    Byte *dest, size_t *destLen, UInt32 desiredPackSize, UInt32 *unpackSize)
-+{
-+  CLzmaEnc *p = (CLzmaEnc *)pp;
-+  UInt64 nowPos64;
-+  SRes res;
-+  CSeqOutStreamBuf outStream;
-+
-+  outStream.funcTable.Write = MyWrite;
-+  outStream.data = dest;
-+  outStream.rem = *destLen;
-+  outStream.overflow = False;
-+
-+  p->writeEndMark = False;
-+  p->finished = False;
-+  p->result = SZ_OK;
-+
-+  if (reInit)
-+    LzmaEnc_Init(p);
-+  LzmaEnc_InitPrices(p);
-+  nowPos64 = p->nowPos64;
-+  RangeEnc_Init(&p->rc);
-+  p->rc.outStream = &outStream.funcTable;
-+
-+  res = LzmaEnc_CodeOneBlock(p, True, desiredPackSize, *unpackSize);
-+  
-+  *unpackSize = (UInt32)(p->nowPos64 - nowPos64);
-+  *destLen -= outStream.rem;
-+  if (outStream.overflow)
-+    return SZ_ERROR_OUTPUT_EOF;
-+
-+  return res;
-+}
-+
-+static SRes LzmaEnc_Encode2(CLzmaEnc *p, ICompressProgress *progress)
-+{
-+  SRes res = SZ_OK;
-+
-+  #ifndef _7ZIP_ST
-+  Byte allocaDummy[0x300];
-+  int i = 0;
-+  for (i = 0; i < 16; i++)
-+    allocaDummy[i] = (Byte)i;
-+  #endif
-+
-+  for (;;)
-+  {
-+    res = LzmaEnc_CodeOneBlock(p, False, 0, 0);
-+    if (res != SZ_OK || p->finished != 0)
-+      break;
-+    if (progress != 0)
-+    {
-+      res = progress->Progress(progress, p->nowPos64, RangeEnc_GetProcessed(&p->rc));
-+      if (res != SZ_OK)
-+      {
-+        res = SZ_ERROR_PROGRESS;
-+        break;
-+      }
-+    }
-+  }
-+  LzmaEnc_Finish(p);
-+  return res;
-+}
-+
-+SRes LzmaEnc_Encode(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress,
-+    ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  RINOK(LzmaEnc_Prepare(pp, outStream, inStream, alloc, allocBig));
-+  return LzmaEnc_Encode2((CLzmaEnc *)pp, progress);
-+}
-+
-+SRes LzmaEnc_WriteProperties(CLzmaEncHandle pp, Byte *props, SizeT *size)
-+{
-+  CLzmaEnc *p = (CLzmaEnc *)pp;
-+  int i;
-+  UInt32 dictSize = p->dictSize;
-+  if (*size < LZMA_PROPS_SIZE)
-+    return SZ_ERROR_PARAM;
-+  *size = LZMA_PROPS_SIZE;
-+  props[0] = (Byte)((p->pb * 5 + p->lp) * 9 + p->lc);
-+
-+  for (i = 11; i <= 30; i++)
-+  {
-+    if (dictSize <= ((UInt32)2 << i))
-+    {
-+      dictSize = (2 << i);
-+      break;
-+    }
-+    if (dictSize <= ((UInt32)3 << i))
-+    {
-+      dictSize = (3 << i);
-+      break;
-+    }
-+  }
-+
-+  for (i = 0; i < 4; i++)
-+    props[1 + i] = (Byte)(dictSize >> (8 * i));
-+  return SZ_OK;
-+}
-+
-+SRes LzmaEnc_MemEncode(CLzmaEncHandle pp, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-+    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  SRes res;
-+  CLzmaEnc *p = (CLzmaEnc *)pp;
-+
-+  CSeqOutStreamBuf outStream;
-+
-+  LzmaEnc_SetInputBuf(p, src, srcLen);
-+
-+  outStream.funcTable.Write = MyWrite;
-+  outStream.data = dest;
-+  outStream.rem = *destLen;
-+  outStream.overflow = False;
-+
-+  p->writeEndMark = writeEndMark;
-+
-+  p->rc.outStream = &outStream.funcTable;
-+  res = LzmaEnc_MemPrepare(pp, src, srcLen, 0, alloc, allocBig);
-+  if (res == SZ_OK)
-+    res = LzmaEnc_Encode2(p, progress);
-+
-+  *destLen -= outStream.rem;
-+  if (outStream.overflow)
-+    return SZ_ERROR_OUTPUT_EOF;
-+  return res;
-+}
-+
-+SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-+    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
-+    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
-+{
-+  CLzmaEnc *p = (CLzmaEnc *)LzmaEnc_Create(alloc);
-+  SRes res;
-+  if (p == 0)
-+    return SZ_ERROR_MEM;
-+
-+  res = LzmaEnc_SetProps(p, props);
-+  if (res == SZ_OK)
-+  {
-+    res = LzmaEnc_WriteProperties(p, propsEncoded, propsSize);
-+    if (res == SZ_OK)
-+      res = LzmaEnc_MemEncode(p, dest, destLen, src, srcLen,
-+          writeEndMark, progress, alloc, allocBig);
-+  }
-+
-+  LzmaEnc_Destroy(p, alloc, allocBig);
-+  return res;
-+}
---- /dev/null
-+++ b/lib/lzma/Makefile
-@@ -0,0 +1,7 @@
-+lzma_compress-objs := LzFind.o LzmaEnc.o
-+lzma_decompress-objs := LzmaDec.o
-+
-+obj-$(CONFIG_LZMA_COMPRESS) += lzma_compress.o
-+obj-$(CONFIG_LZMA_DECOMPRESS) += lzma_decompress.o
-+
-+EXTRA_CFLAGS += -Iinclude/linux -Iinclude/linux/lzma -include types.h
--- a/target/linux/generic/pending-4.9/532-jffs2_eofdetect.patch	2022-03-22 08:54:47.439465056 +0800
+++ b/target/linux/generic/pending-4.9/532-jffs2_eofdetect.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,65 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: fs: jffs2: EOF marker
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- fs/jffs2/build.c | 10 ++++++++++
- fs/jffs2/scan.c  | 21 +++++++++++++++++++--
- 2 files changed, 29 insertions(+), 2 deletions(-)
-
---- a/fs/jffs2/build.c
-+++ b/fs/jffs2/build.c
-@@ -117,6 +117,16 @@ static int jffs2_build_filesystem(struct
- 	dbg_fsbuild("scanned flash completely\n");
- 	jffs2_dbg_dump_block_lists_nolock(c);
- 
-+	if (c->flags & (1 << 7)) {
-+		printk("%s(): unlocking the mtd device... ", __func__);
-+		mtd_unlock(c->mtd, 0, c->mtd->size);
-+		printk("done.\n");
-+
-+		printk("%s(): erasing all blocks after the end marker... ", __func__);
-+		jffs2_erase_pending_blocks(c, -1);
-+		printk("done.\n");
-+	}
-+
- 	dbg_fsbuild("pass 1 starting\n");
- 	c->flags |= JFFS2_SB_FLAG_BUILDING;
- 	/* Now scan the directory tree, increasing nlink according to every dirent found. */
---- a/fs/jffs2/scan.c
-+++ b/fs/jffs2/scan.c
-@@ -148,8 +148,14 @@ int jffs2_scan_medium(struct jffs2_sb_in
- 		/* reset summary info for next eraseblock scan */
- 		jffs2_sum_reset_collected(s);
- 
--		ret = jffs2_scan_eraseblock(c, jeb, buf_size?flashbuf:(flashbuf+jeb->offset),
--						buf_size, s);
-+		if (c->flags & (1 << 7)) {
-+			if (mtd_block_isbad(c->mtd, jeb->offset))
-+				ret = BLK_STATE_BADBLOCK;
-+			else
-+				ret = BLK_STATE_ALLFF;
-+		} else
-+			ret = jffs2_scan_eraseblock(c, jeb, buf_size?flashbuf:(flashbuf+jeb->offset),
-+							buf_size, s);
- 
- 		if (ret < 0)
- 			goto out;
-@@ -561,6 +567,17 @@ full_scan:
- 			return err;
- 	}
- 
-+	if ((buf[0] == 0xde) &&
-+		(buf[1] == 0xad) &&
-+		(buf[2] == 0xc0) &&
-+		(buf[3] == 0xde)) {
-+		/* end of filesystem. erase everything after this point */
-+		printk("%s(): End of filesystem marker found at 0x%x\n", __func__, jeb->offset);
-+		c->flags |= (1 << 7);
-+
-+		return BLK_STATE_ALLFF;
-+	}
-+
- 	/* We temporarily use 'ofs' as a pointer into the buffer/jeb */
- 	ofs = 0;
- 	max_ofs = EMPTY_SCAN_SIZE(c->sector_size);
--- a/target/linux/generic/pending-4.9/551-ubifs-fix-default-compression-selection.patch	2022-03-22 08:54:47.439465056 +0800
+++ b/target/linux/generic/pending-4.9/551-ubifs-fix-default-compression-selection.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,37 +0,0 @@
-From: Gabor Juhos <juhosg@openwrt.org>
-Subject: fs: ubifs: fix default compression selection in ubifs
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- fs/ubifs/sb.c | 13 ++++++++++++-
- 1 file changed, 12 insertions(+), 1 deletion(-)
-
---- a/fs/ubifs/sb.c
-+++ b/fs/ubifs/sb.c
-@@ -63,6 +63,17 @@
- /* Default time granularity in nanoseconds */
- #define DEFAULT_TIME_GRAN 1000000000
- 
-+static int get_default_compressor(void)
-+{
-+	if (ubifs_compr_present(UBIFS_COMPR_LZO))
-+		return UBIFS_COMPR_LZO;
-+
-+	if (ubifs_compr_present(UBIFS_COMPR_ZLIB))
-+		return UBIFS_COMPR_ZLIB;
-+
-+	return UBIFS_COMPR_NONE;
-+}
-+
- /**
-  * create_default_filesystem - format empty UBI volume.
-  * @c: UBIFS file-system description object
-@@ -183,7 +194,7 @@ static int create_default_filesystem(str
- 	if (c->mount_opts.override_compr)
- 		sup->default_compr = cpu_to_le16(c->mount_opts.compr_type);
- 	else
--		sup->default_compr = cpu_to_le16(UBIFS_COMPR_LZO);
-+		sup->default_compr = cpu_to_le16(get_default_compressor());
- 
- 	generate_random_uuid(sup->uuid);
- 
--- a/target/linux/generic/pending-4.9/600-netfilter_conntrack_flush.patch	2022-03-22 08:54:47.439465056 +0800
+++ b/target/linux/generic/pending-4.9/600-netfilter_conntrack_flush.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,95 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: netfilter: add support for flushing conntrack via /proc
-
-lede-commit 8193bbe59a74d34d6a26d4a8cb857b1952905314
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- net/netfilter/nf_conntrack_standalone.c | 59 ++++++++++++++++++++++++++++++++-
- 1 file changed, 58 insertions(+), 1 deletion(-)
-
---- a/net/netfilter/nf_conntrack_standalone.c
-+++ b/net/netfilter/nf_conntrack_standalone.c
-@@ -17,6 +17,7 @@
- #include <linux/percpu.h>
- #include <linux/netdevice.h>
- #include <linux/security.h>
-+#include <linux/inet.h>
- #include <net/net_namespace.h>
- #ifdef CONFIG_SYSCTL
- #include <linux/sysctl.h>
-@@ -298,10 +299,66 @@ static int ct_open(struct inode *inode,
- 			sizeof(struct ct_iter_state));
- }
- 
-+struct kill_request {
-+	u16 family;
-+	union nf_inet_addr addr;
-+};
-+
-+static int kill_matching(struct nf_conn *i, void *data)
-+{
-+	struct kill_request *kr = data;
-+	struct nf_conntrack_tuple *t1 = &i->tuplehash[IP_CT_DIR_ORIGINAL].tuple;
-+	struct nf_conntrack_tuple *t2 = &i->tuplehash[IP_CT_DIR_REPLY].tuple;
-+
-+	if (!kr->family)
-+		return 1;
-+
-+	if (t1->src.l3num != kr->family)
-+		return 0;
-+
-+	return (nf_inet_addr_cmp(&kr->addr, &t1->src.u3) ||
-+	        nf_inet_addr_cmp(&kr->addr, &t1->dst.u3) ||
-+	        nf_inet_addr_cmp(&kr->addr, &t2->src.u3) ||
-+	        nf_inet_addr_cmp(&kr->addr, &t2->dst.u3));
-+}
-+
-+static ssize_t ct_file_write(struct file *file, const char __user *buf,
-+			     size_t count, loff_t *ppos)
-+{
-+	struct seq_file *seq = file->private_data;
-+	struct net *net = seq_file_net(seq);
-+	struct kill_request kr = { };
-+	char req[INET6_ADDRSTRLEN] = { };
-+
-+	if (count == 0)
-+		return 0;
-+
-+	if (count >= INET6_ADDRSTRLEN)
-+		count = INET6_ADDRSTRLEN - 1;
-+
-+	if (copy_from_user(req, buf, count))
-+		return -EFAULT;
-+
-+	if (strnchr(req, count, ':')) {
-+		kr.family = AF_INET6;
-+		if (!in6_pton(req, count, (void *)&kr.addr, '\n', NULL))
-+			return -EINVAL;
-+	} else if (strnchr(req, count, '.')) {
-+		kr.family = AF_INET;
-+		if (!in4_pton(req, count, (void *)&kr.addr, '\n', NULL))
-+			return -EINVAL;
-+	}
-+
-+	nf_ct_iterate_cleanup(net, kill_matching, &kr, 0, 0);
-+
-+	return count;
-+}
-+
- static const struct file_operations ct_file_ops = {
- 	.owner   = THIS_MODULE,
- 	.open    = ct_open,
- 	.read    = seq_read,
-+	.write	 = ct_file_write,
- 	.llseek  = seq_lseek,
- 	.release = seq_release_net,
- };
-@@ -405,7 +462,7 @@ static int nf_conntrack_standalone_init_
- 	kuid_t root_uid;
- 	kgid_t root_gid;
- 
--	pde = proc_create("nf_conntrack", 0440, net->proc_net, &ct_file_ops);
-+	pde = proc_create("nf_conntrack", 0660, net->proc_net, &ct_file_ops);
- 	if (!pde)
- 		goto out_nf_conntrack;
- 
--- a/target/linux/generic/pending-4.9/610-netfilter_match_bypass_default_checks.patch	2022-03-22 08:54:47.440465058 +0800
+++ b/target/linux/generic/pending-4.9/610-netfilter_match_bypass_default_checks.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,110 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: kernel: add a new version of my netfilter speedup patches for linux 2.6.39 and 3.0
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/uapi/linux/netfilter_ipv4/ip_tables.h |  1 +
- net/ipv4/netfilter/ip_tables.c                | 37 +++++++++++++++++++++++++++
- 2 files changed, 38 insertions(+)
-
---- a/include/uapi/linux/netfilter_ipv4/ip_tables.h
-+++ b/include/uapi/linux/netfilter_ipv4/ip_tables.h
-@@ -88,6 +88,7 @@ struct ipt_ip {
- #define IPT_F_FRAG		0x01	/* Set if rule is a fragment rule */
- #define IPT_F_GOTO		0x02	/* Set if jump is a goto */
- #define IPT_F_MASK		0x03	/* All possible flag bits mask. */
-+#define IPT_F_NO_DEF_MATCH	0x80	/* Internal: no default match rules present */
- 
- /* Values for "inv" field in struct ipt_ip. */
- #define IPT_INV_VIA_IN		0x01	/* Invert the sense of IN IFACE. */
---- a/net/ipv4/netfilter/ip_tables.c
-+++ b/net/ipv4/netfilter/ip_tables.c
-@@ -58,6 +58,9 @@ ip_packet_match(const struct iphdr *ip,
- {
- 	unsigned long ret;
- 
-+	if (ipinfo->flags & IPT_F_NO_DEF_MATCH)
-+		return true;
-+
- 	if (NF_INVF(ipinfo, IPT_INV_SRCIP,
- 		    (ip->saddr & ipinfo->smsk.s_addr) != ipinfo->src.s_addr) ||
- 	    NF_INVF(ipinfo, IPT_INV_DSTIP,
-@@ -88,6 +91,29 @@ ip_packet_match(const struct iphdr *ip,
- 	return true;
- }
- 
-+static void
-+ip_checkdefault(struct ipt_ip *ip)
-+{
-+	static const char iface_mask[IFNAMSIZ] = {};
-+
-+	if (ip->invflags || ip->flags & IPT_F_FRAG)
-+		return;
-+
-+	if (memcmp(ip->iniface_mask, iface_mask, IFNAMSIZ) != 0)
-+		return;
-+
-+	if (memcmp(ip->outiface_mask, iface_mask, IFNAMSIZ) != 0)
-+		return;
-+
-+	if (ip->smsk.s_addr || ip->dmsk.s_addr)
-+		return;
-+
-+	if (ip->proto)
-+		return;
-+
-+	ip->flags |= IPT_F_NO_DEF_MATCH;
-+}
-+
- static bool
- ip_checkentry(const struct ipt_ip *ip)
- {
-@@ -550,6 +576,8 @@ find_check_entry(struct ipt_entry *e, st
- 	struct xt_mtchk_param mtpar;
- 	struct xt_entry_match *ematch;
- 
-+	ip_checkdefault(&e->ip);
-+
- 	if (!xt_percpu_counter_alloc(alloc_state, &e->counters))
- 		return -ENOMEM;
- 
-@@ -830,6 +858,7 @@ copy_entries_to_user(unsigned int total_
- 	const struct xt_table_info *private = table->private;
- 	int ret = 0;
- 	const void *loc_cpu_entry;
-+	u8 flags;
- 
- 	counters = alloc_counters(table);
- 	if (IS_ERR(counters))
-@@ -857,6 +886,14 @@ copy_entries_to_user(unsigned int total_
- 			goto free_counters;
- 		}
- 
-+		flags = e->ip.flags & IPT_F_MASK;
-+		if (copy_to_user(userptr + off
-+				 + offsetof(struct ipt_entry, ip.flags),
-+				 &flags, sizeof(flags)) != 0) {
-+			ret = -EFAULT;
-+			goto free_counters;
-+		}
-+
- 		for (i = sizeof(struct ipt_entry);
- 		     i < e->target_offset;
- 		     i += m->u.match_size) {
-@@ -1246,12 +1283,15 @@ compat_copy_entry_to_user(struct ipt_ent
- 	compat_uint_t origsize;
- 	const struct xt_entry_match *ematch;
- 	int ret = 0;
-+	u8 flags = e->ip.flags & IPT_F_MASK;
- 
- 	origsize = *size;
- 	ce = (struct compat_ipt_entry __user *)*dstptr;
- 	if (copy_to_user(ce, e, sizeof(struct ipt_entry)) != 0 ||
- 	    copy_to_user(&ce->counters, &counters[i],
--	    sizeof(counters[i])) != 0)
-+	    sizeof(counters[i])) != 0 ||
-+	    copy_to_user(&ce->ip.flags, &flags,
-+	    sizeof(flags)) != 0)
- 		return -EFAULT;
- 
- 	*dstptr += sizeof(struct compat_ipt_entry);
--- a/target/linux/generic/pending-4.9/611-netfilter_match_bypass_default_table.patch	2022-03-22 08:54:47.440465058 +0800
+++ b/target/linux/generic/pending-4.9/611-netfilter_match_bypass_default_table.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,119 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: netfilter: match bypass default table
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- net/ipv4/netfilter/ip_tables.c | 79 +++++++++++++++++++++++++++++++-----------
- 1 file changed, 58 insertions(+), 21 deletions(-)
-
---- a/net/ipv4/netfilter/ip_tables.c
-+++ b/net/ipv4/netfilter/ip_tables.c
-@@ -254,6 +254,33 @@ struct ipt_entry *ipt_next_entry(const s
- 	return (void *)entry + entry->next_offset;
- }
- 
-+static bool
-+ipt_handle_default_rule(struct ipt_entry *e, unsigned int *verdict)
-+{
-+	struct xt_entry_target *t;
-+	struct xt_standard_target *st;
-+
-+	if (e->target_offset != sizeof(struct ipt_entry))
-+		return false;
-+
-+	if (!(e->ip.flags & IPT_F_NO_DEF_MATCH))
-+		return false;
-+
-+	t = ipt_get_target(e);
-+	if (t->u.kernel.target->target)
-+		return false;
-+
-+	st = (struct xt_standard_target *) t;
-+	if (st->verdict == XT_RETURN)
-+		return false;
-+
-+	if (st->verdict >= 0)
-+		return false;
-+
-+	*verdict = (unsigned)(-st->verdict) - 1;
-+	return true;
-+}
-+
- /* Returns one of the generic firewall policies, like NF_ACCEPT. */
- unsigned int
- ipt_do_table(struct sk_buff *skb,
-@@ -274,28 +301,8 @@ ipt_do_table(struct sk_buff *skb,
- 	unsigned int addend;
- 
- 	/* Initialization */
--	stackidx = 0;
--	ip = ip_hdr(skb);
--	indev = state->in ? state->in->name : nulldevname;
--	outdev = state->out ? state->out->name : nulldevname;
--	/* We handle fragments by dealing with the first fragment as
--	 * if it was a normal packet.  All other fragments are treated
--	 * normally, except that they will NEVER match rules that ask
--	 * things we don't know, ie. tcp syn flag or ports).  If the
--	 * rule is also a fragment-specific rule, non-fragments won't
--	 * match it. */
--	acpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;
--	acpar.thoff   = ip_hdrlen(skb);
--	acpar.hotdrop = false;
--	acpar.net     = state->net;
--	acpar.in      = state->in;
--	acpar.out     = state->out;
--	acpar.family  = NFPROTO_IPV4;
--	acpar.hooknum = hook;
--
- 	IP_NF_ASSERT(table->valid_hooks & (1 << hook));
- 	local_bh_disable();
--	addend = xt_write_recseq_begin();
- 	private = table->private;
- 	cpu        = smp_processor_id();
- 	/*
-@@ -304,6 +311,23 @@ ipt_do_table(struct sk_buff *skb,
- 	 */
- 	smp_read_barrier_depends();
- 	table_base = private->entries;
-+
-+	e = get_entry(table_base, private->hook_entry[hook]);
-+	if (ipt_handle_default_rule(e, &verdict)) {
-+		struct xt_counters *counter;
-+
-+		counter = xt_get_this_cpu_counter(&e->counters);
-+		ADD_COUNTER(*counter, skb->len, 1);
-+		local_bh_enable();
-+		return verdict;
-+	}
-+
-+	stackidx = 0;
-+	ip = ip_hdr(skb);
-+	indev = state->in ? state->in->name : nulldevname;
-+	outdev = state->out ? state->out->name : nulldevname;
-+
-+	addend = xt_write_recseq_begin();
- 	jumpstack  = (struct ipt_entry **)private->jumpstack[cpu];
- 
- 	/* Switch to alternate jumpstack if we're being invoked via TEE.
-@@ -316,7 +340,20 @@ ipt_do_table(struct sk_buff *skb,
- 	if (static_key_false(&xt_tee_enabled))
- 		jumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);
- 
--	e = get_entry(table_base, private->hook_entry[hook]);
-+	/* We handle fragments by dealing with the first fragment as
-+	 * if it was a normal packet.  All other fragments are treated
-+	 * normally, except that they will NEVER match rules that ask
-+	 * things we don't know, ie. tcp syn flag or ports).  If the
-+	 * rule is also a fragment-specific rule, non-fragments won't
-+	 * match it. */
-+	acpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;
-+	acpar.thoff   = ip_hdrlen(skb);
-+	acpar.hotdrop = false;
-+	acpar.net     = state->net;
-+	acpar.in      = state->in;
-+	acpar.out     = state->out;
-+	acpar.family  = NFPROTO_IPV4;
-+	acpar.hooknum = hook;
- 
- 	do {
- 		const struct xt_entry_target *t;
--- a/target/linux/generic/pending-4.9/612-netfilter_match_reduce_memory_access.patch	2022-03-22 08:54:47.440465058 +0800
+++ b/target/linux/generic/pending-4.9/612-netfilter_match_reduce_memory_access.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,22 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: netfilter: reduce match memory access
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- net/ipv4/netfilter/ip_tables.c | 4 ++--
- 1 file changed, 2 insertions(+), 2 deletions(-)
-
---- a/net/ipv4/netfilter/ip_tables.c
-+++ b/net/ipv4/netfilter/ip_tables.c
-@@ -61,9 +61,9 @@ ip_packet_match(const struct iphdr *ip,
- 	if (ipinfo->flags & IPT_F_NO_DEF_MATCH)
- 		return true;
- 
--	if (NF_INVF(ipinfo, IPT_INV_SRCIP,
-+	if (NF_INVF(ipinfo, IPT_INV_SRCIP, ipinfo->smsk.s_addr &&
- 		    (ip->saddr & ipinfo->smsk.s_addr) != ipinfo->src.s_addr) ||
--	    NF_INVF(ipinfo, IPT_INV_DSTIP,
-+	    NF_INVF(ipinfo, IPT_INV_DSTIP, ipinfo->dmsk.s_addr &&
- 		    (ip->daddr & ipinfo->dmsk.s_addr) != ipinfo->dst.s_addr))
- 		return false;
- 
--- a/target/linux/generic/pending-4.9/613-netfilter_optional_tcp_window_check.patch	2022-03-22 08:54:47.440465058 +0800
+++ b/target/linux/generic/pending-4.9/613-netfilter_optional_tcp_window_check.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,44 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: netfilter: optional tcp window check
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- net/netfilter/nf_conntrack_proto_tcp.c | 13 +++++++++++++
- 1 file changed, 13 insertions(+)
-
---- a/net/netfilter/nf_conntrack_proto_tcp.c
-+++ b/net/netfilter/nf_conntrack_proto_tcp.c
-@@ -33,6 +33,9 @@
- #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
- #include <net/netfilter/ipv6/nf_conntrack_ipv6.h>
- 
-+/* Do not check the TCP window for incoming packets  */
-+static int nf_ct_tcp_no_window_check __read_mostly = 1;
-+
- /* "Be conservative in what you do,
-     be liberal in what you accept from others."
-     If it's non-zero, we mark only out of window RST segments as INVALID. */
-@@ -513,6 +516,9 @@ static bool tcp_in_window(const struct n
- 	s32 receiver_offset;
- 	bool res, in_recv_win;
- 
-+	if (nf_ct_tcp_no_window_check)
-+		return true;
-+
- 	/*
- 	 * Get the required data from the packet.
- 	 */
-@@ -1479,6 +1485,13 @@ static struct ctl_table tcp_sysctl_table
- 		.mode		= 0644,
- 		.proc_handler	= proc_dointvec,
- 	},
-+	{
-+		.procname       = "nf_conntrack_tcp_no_window_check",
-+		.data           = &nf_ct_tcp_no_window_check,
-+		.maxlen         = sizeof(unsigned int),
-+		.mode           = 0644,
-+		.proc_handler   = proc_dointvec,
-+	},
- 	{ }
- };
- #endif /* CONFIG_SYSCTL */
--- a/target/linux/generic/pending-4.9/616-net_optimize_xfrm_calls.patch	2022-03-22 08:54:47.441465059 +0800
+++ b/target/linux/generic/pending-4.9/616-net_optimize_xfrm_calls.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,20 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: kernel: add a small xfrm related performance optimization
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- net/netfilter/nf_nat_core.c | 3 +++
- 1 file changed, 3 insertions(+)
-
---- a/net/netfilter/nf_nat_core.c
-+++ b/net/netfilter/nf_nat_core.c
-@@ -93,6 +93,9 @@ int nf_xfrm_me_harder(struct net *net, s
- 	struct dst_entry *dst;
- 	int err;
- 
-+	if (skb->dev && !dev_net(skb->dev)->xfrm.policy_count[XFRM_POLICY_OUT])
-+		return 0;
-+
- 	err = xfrm_decode_session(skb, &fl, family);
- 	if (err < 0)
- 		return err;
--- a/target/linux/generic/pending-4.9/620-net_sched-codel-do-not-defer-queue-length-update.patch	2022-03-22 08:54:47.441465059 +0800
+++ b/target/linux/generic/pending-4.9/620-net_sched-codel-do-not-defer-queue-length-update.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,86 +0,0 @@
-From: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
-Date: Mon, 21 Aug 2017 11:14:14 +0300
-Subject: [PATCH] net_sched/codel: do not defer queue length update
-
-When codel wants to drop last packet in ->dequeue() it cannot call
-qdisc_tree_reduce_backlog() right away - it will notify parent qdisc
-about zero qlen and HTB/HFSC will deactivate class. The same class will
-be deactivated second time by caller of ->dequeue(). Currently codel and
-fq_codel defer update. This triggers warning in HFSC when it's qlen != 0
-but there is no active classes.
-
-This patch update parent queue length immediately: just temporary increase
-qlen around qdisc_tree_reduce_backlog() to prevent first class deactivation
-if we have skb to return.
-
-This might open another problem in HFSC - now operation peek could fail and
-deactivate parent class.
-
-Signed-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
-Link: https://bugzilla.kernel.org/show_bug.cgi?id=109581
----
-
---- a/net/sched/sch_codel.c
-+++ b/net/sched/sch_codel.c
-@@ -95,11 +95,17 @@ static struct sk_buff *codel_qdisc_deque
- 			    &q->stats, qdisc_pkt_len, codel_get_enqueue_time,
- 			    drop_func, dequeue_func);
- 
--	/* We cant call qdisc_tree_reduce_backlog() if our qlen is 0,
--	 * or HTB crashes. Defer it for next round.
-+	/* If our qlen is 0 qdisc_tree_reduce_backlog() will deactivate
-+	 * parent class, dequeue in parent qdisc will do the same if we
-+	 * return skb. Temporary increment qlen if we have skb.
- 	 */
--	if (q->stats.drop_count && sch->q.qlen) {
--		qdisc_tree_reduce_backlog(sch, q->stats.drop_count, q->stats.drop_len);
-+	if (q->stats.drop_count) {
-+		if (skb)
-+			sch->q.qlen++;
-+		qdisc_tree_reduce_backlog(sch, q->stats.drop_count,
-+					  q->stats.drop_len);
-+		if (skb)
-+			sch->q.qlen--;
- 		q->stats.drop_count = 0;
- 		q->stats.drop_len = 0;
- 	}
---- a/net/sched/sch_fq_codel.c
-+++ b/net/sched/sch_fq_codel.c
-@@ -318,6 +318,21 @@ begin:
- 	flow->dropped += q->cstats.drop_count - prev_drop_count;
- 	flow->dropped += q->cstats.ecn_mark - prev_ecn_mark;
- 
-+	/* If our qlen is 0 qdisc_tree_reduce_backlog() will deactivate
-+	 * parent class, dequeue in parent qdisc will do the same if we
-+	 * return skb. Temporary increment qlen if we have skb.
-+	 */
-+	if (q->cstats.drop_count) {
-+		if (skb)
-+			sch->q.qlen++;
-+		qdisc_tree_reduce_backlog(sch, q->cstats.drop_count,
-+					  q->cstats.drop_len);
-+		if (skb)
-+			sch->q.qlen--;
-+		q->cstats.drop_count = 0;
-+		q->cstats.drop_len = 0;
-+	}
-+
- 	if (!skb) {
- 		/* force a pass through old_flows to prevent starvation */
- 		if ((head == &q->new_flows) && !list_empty(&q->old_flows))
-@@ -328,15 +343,6 @@ begin:
- 	}
- 	qdisc_bstats_update(sch, skb);
- 	flow->deficit -= qdisc_pkt_len(skb);
--	/* We cant call qdisc_tree_reduce_backlog() if our qlen is 0,
--	 * or HTB crashes. Defer it for next round.
--	 */
--	if (q->cstats.drop_count && sch->q.qlen) {
--		qdisc_tree_reduce_backlog(sch, q->cstats.drop_count,
--					  q->cstats.drop_len);
--		q->cstats.drop_count = 0;
--		q->cstats.drop_len = 0;
--	}
- 	return skb;
- }
- 
--- a/target/linux/generic/pending-4.9/630-packet_socket_type.patch	2022-03-22 08:54:47.442465061 +0800
+++ b/target/linux/generic/pending-4.9/630-packet_socket_type.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,138 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: net: add an optimization for dealing with raw sockets
-
-lede-commit: 4898039703d7315f0f3431c860123338ec3be0f6
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/uapi/linux/if_packet.h |  3 +++
- net/packet/af_packet.c         | 34 +++++++++++++++++++++++++++-------
- net/packet/internal.h          |  1 +
- 3 files changed, 31 insertions(+), 7 deletions(-)
-
---- a/include/uapi/linux/if_packet.h
-+++ b/include/uapi/linux/if_packet.h
-@@ -31,6 +31,8 @@ struct sockaddr_ll {
- #define PACKET_KERNEL		7		/* To kernel space	*/
- /* Unused, PACKET_FASTROUTE and PACKET_LOOPBACK are invisible to user space */
- #define PACKET_FASTROUTE	6		/* Fastrouted frame	*/
-+#define PACKET_MASK_ANY		0xffffffff	/* mask for packet type bits */
-+
- 
- /* Packet socket options */
- 
-@@ -56,6 +58,7 @@ struct sockaddr_ll {
- #define PACKET_QDISC_BYPASS		20
- #define PACKET_ROLLOVER_STATS		21
- #define PACKET_FANOUT_DATA		22
-+#define PACKET_RECV_TYPE		23
- 
- #define PACKET_FANOUT_HASH		0
- #define PACKET_FANOUT_LB		1
---- a/net/packet/af_packet.c
-+++ b/net/packet/af_packet.c
-@@ -1780,6 +1780,7 @@ static int packet_rcv_spkt(struct sk_buf
- {
- 	struct sock *sk;
- 	struct sockaddr_pkt *spkt;
-+	struct packet_sock *po;
- 
- 	/*
- 	 *	When we registered the protocol we saved the socket in the data
-@@ -1787,6 +1788,7 @@ static int packet_rcv_spkt(struct sk_buf
- 	 */
- 
- 	sk = pt->af_packet_priv;
-+	po = pkt_sk(sk);
- 
- 	/*
- 	 *	Yank back the headers [hope the device set this
-@@ -1799,7 +1801,7 @@ static int packet_rcv_spkt(struct sk_buf
- 	 *	so that this procedure is noop.
- 	 */
- 
--	if (skb->pkt_type == PACKET_LOOPBACK)
-+	if (!(po->pkt_type & (1 << skb->pkt_type)))
- 		goto out;
- 
- 	if (!net_eq(dev_net(dev), sock_net(sk)))
-@@ -2037,12 +2039,12 @@ static int packet_rcv(struct sk_buff *sk
- 	unsigned int snaplen, res;
- 	bool is_drop_n_account = false;
- 
--	if (skb->pkt_type == PACKET_LOOPBACK)
--		goto drop;
--
- 	sk = pt->af_packet_priv;
- 	po = pkt_sk(sk);
- 
-+	if (!(po->pkt_type & (1 << skb->pkt_type)))
-+		goto drop;
-+
- 	if (!net_eq(dev_net(dev), sock_net(sk)))
- 		goto drop;
- 
-@@ -2168,12 +2170,12 @@ static int tpacket_rcv(struct sk_buff *s
- 	BUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h2)) != 32);
- 	BUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h3)) != 48);
- 
--	if (skb->pkt_type == PACKET_LOOPBACK)
--		goto drop;
--
- 	sk = pt->af_packet_priv;
- 	po = pkt_sk(sk);
- 
-+	if (!(po->pkt_type & (1 << skb->pkt_type)))
-+		goto drop;
-+
- 	if (!net_eq(dev_net(dev), sock_net(sk)))
- 		goto drop;
- 
-@@ -3291,6 +3293,7 @@ static int packet_create(struct net *net
- 	mutex_init(&po->pg_vec_lock);
- 	po->rollover = NULL;
- 	po->prot_hook.func = packet_rcv;
-+	po->pkt_type = PACKET_MASK_ANY & ~(1 << PACKET_LOOPBACK);
- 
- 	if (sock->type == SOCK_PACKET)
- 		po->prot_hook.func = packet_rcv_spkt;
-@@ -3904,6 +3907,16 @@ packet_setsockopt(struct socket *sock, i
- 		po->xmit = val ? packet_direct_xmit : dev_queue_xmit;
- 		return 0;
- 	}
-+        case PACKET_RECV_TYPE:
-+        {
-+                unsigned int val;
-+                if (optlen != sizeof(val))
-+                        return -EINVAL;
-+                if (copy_from_user(&val, optval, sizeof(val)))
-+                        return -EFAULT;
-+                po->pkt_type = val & ~BIT(PACKET_LOOPBACK);
-+                return 0;
-+        }
- 	default:
- 		return -ENOPROTOOPT;
- 	}
-@@ -3956,6 +3969,13 @@ static int packet_getsockopt(struct sock
- 	case PACKET_VNET_HDR:
- 		val = po->has_vnet_hdr;
- 		break;
-+	case PACKET_RECV_TYPE:
-+		if (len > sizeof(unsigned int))
-+			len = sizeof(unsigned int);
-+		val = po->pkt_type;
-+
-+		data = &val;
-+		break;
- 	case PACKET_VERSION:
- 		val = po->tp_version;
- 		break;
---- a/net/packet/internal.h
-+++ b/net/packet/internal.h
-@@ -129,6 +129,7 @@ struct packet_sock {
- 	struct net_device __rcu	*cached_dev;
- 	int			(*xmit)(struct sk_buff *skb);
- 	struct packet_type	prot_hook ____cacheline_aligned_in_smp;
-+	unsigned int		pkt_type;
- };
- 
- static struct packet_sock *pkt_sk(struct sock *sk)
--- a/target/linux/generic/pending-4.9/655-increase_skb_pad.patch	2022-03-22 08:54:47.442465061 +0800
+++ b/target/linux/generic/pending-4.9/655-increase_skb_pad.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,20 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: kernel: add a few patches for avoiding unnecessary skb reallocations - significantly improves ethernet<->wireless performance
-
-lede-commit: 6f89cffc9add6939d44a6b54cf9a5e77849aa7fd
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/linux/skbuff.h | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/include/linux/skbuff.h
-+++ b/include/linux/skbuff.h
-@@ -2304,7 +2304,7 @@ static inline int pskb_network_may_pull(
-  * NET_IP_ALIGN(2) + ethernet_header(14) + IP_header(20/40) + ports(8)
-  */
- #ifndef NET_SKB_PAD
--#define NET_SKB_PAD	max(32, L1_CACHE_BYTES)
-+#define NET_SKB_PAD	max(64, L1_CACHE_BYTES)
- #endif
- 
- int ___pskb_trim(struct sk_buff *skb, unsigned int len);
--- a/target/linux/generic/pending-4.9/666-Add-support-for-MAP-E-FMRs-mesh-mode.patch	2022-03-22 08:54:47.442465061 +0800
+++ b/target/linux/generic/pending-4.9/666-Add-support-for-MAP-E-FMRs-mesh-mode.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,500 +0,0 @@
-From: Steven Barth <steven@midlink.org>
-Subject: Add support for MAP-E FMRs (mesh mode)
-
-MAP-E FMRs (draft-ietf-softwire-map-10) are rules for IPv4-communication
-between MAP CEs (mesh mode) without the need to forward such data to a
-border relay. This is similar to how 6rd works but for IPv4 over IPv6.
-
-Signed-off-by: Steven Barth <cyrus@openwrt.org>
----
- include/net/ip6_tunnel.h       |  13 ++
- include/uapi/linux/if_tunnel.h |  13 ++
- net/ipv6/ip6_tunnel.c          | 276 +++++++++++++++++++++++++++++++++++++++--
- 3 files changed, 291 insertions(+), 11 deletions(-)
-
---- a/include/net/ip6_tunnel.h
-+++ b/include/net/ip6_tunnel.h
-@@ -17,6 +17,18 @@
- /* determine capability on a per-packet basis */
- #define IP6_TNL_F_CAP_PER_PACKET 0x40000
- 
-+/* IPv6 tunnel FMR */
-+struct __ip6_tnl_fmr {
-+	struct __ip6_tnl_fmr *next; /* next fmr in list */
-+	struct in6_addr ip6_prefix;
-+	struct in_addr ip4_prefix;
-+
-+	__u8 ip6_prefix_len;
-+	__u8 ip4_prefix_len;
-+	__u8 ea_len;
-+	__u8 offset;
-+};
-+
- struct __ip6_tnl_parm {
- 	char name[IFNAMSIZ];	/* name of tunnel device */
- 	int link;		/* ifindex of underlying L2 interface */
-@@ -28,6 +40,7 @@ struct __ip6_tnl_parm {
- 	__u32 flags;		/* tunnel flags */
- 	struct in6_addr laddr;	/* local tunnel end-point address */
- 	struct in6_addr raddr;	/* remote tunnel end-point address */
-+	struct __ip6_tnl_fmr *fmrs;	/* FMRs */
- 
- 	__be16			i_flags;
- 	__be16			o_flags;
---- a/include/uapi/linux/if_tunnel.h
-+++ b/include/uapi/linux/if_tunnel.h
-@@ -75,10 +75,23 @@ enum {
- 	IFLA_IPTUN_ENCAP_SPORT,
- 	IFLA_IPTUN_ENCAP_DPORT,
- 	IFLA_IPTUN_COLLECT_METADATA,
-+	IFLA_IPTUN_FMRS,
- 	__IFLA_IPTUN_MAX,
- };
- #define IFLA_IPTUN_MAX	(__IFLA_IPTUN_MAX - 1)
- 
-+enum {
-+	IFLA_IPTUN_FMR_UNSPEC,
-+	IFLA_IPTUN_FMR_IP6_PREFIX,
-+	IFLA_IPTUN_FMR_IP4_PREFIX,
-+	IFLA_IPTUN_FMR_IP6_PREFIX_LEN,
-+	IFLA_IPTUN_FMR_IP4_PREFIX_LEN,
-+	IFLA_IPTUN_FMR_EA_LEN,
-+	IFLA_IPTUN_FMR_OFFSET,
-+	__IFLA_IPTUN_FMR_MAX,
-+};
-+#define IFLA_IPTUN_FMR_MAX (__IFLA_IPTUN_FMR_MAX - 1)
-+
- enum tunnel_encap_types {
- 	TUNNEL_ENCAP_NONE,
- 	TUNNEL_ENCAP_FOU,
---- a/net/ipv6/ip6_tunnel.c
-+++ b/net/ipv6/ip6_tunnel.c
-@@ -16,6 +16,8 @@
-  *      as published by the Free Software Foundation; either version
-  *      2 of the License, or (at your option) any later version.
-  *
-+ *	Changes:
-+ * Steven Barth <cyrus@openwrt.org>:		MAP-E FMR support
-  */
- 
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-@@ -72,9 +74,9 @@ static bool log_ecn_error = true;
- module_param(log_ecn_error, bool, 0644);
- MODULE_PARM_DESC(log_ecn_error, "Log packets received with corrupted ECN");
- 
--static u32 HASH(const struct in6_addr *addr1, const struct in6_addr *addr2)
-+static u32 HASH(const struct in6_addr *addr)
- {
--	u32 hash = ipv6_addr_hash(addr1) ^ ipv6_addr_hash(addr2);
-+	u32 hash = ipv6_addr_hash(addr);
- 
- 	return hash_32(hash, IP6_TUNNEL_HASH_SIZE_SHIFT);
- }
-@@ -141,20 +143,29 @@ static struct net_device_stats *ip6_get_
- static struct ip6_tnl *
- ip6_tnl_lookup(struct net *net, const struct in6_addr *remote, const struct in6_addr *local)
- {
--	unsigned int hash = HASH(remote, local);
-+	unsigned int hash = HASH(local);
- 	struct ip6_tnl *t;
- 	struct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);
- 	struct in6_addr any;
-+	struct __ip6_tnl_fmr *fmr;
- 
- 	for_each_ip6_tunnel_rcu(ip6n->tnls_r_l[hash]) {
--		if (ipv6_addr_equal(local, &t->parms.laddr) &&
--		    ipv6_addr_equal(remote, &t->parms.raddr) &&
--		    (t->dev->flags & IFF_UP))
-+		if (!ipv6_addr_equal(local, &t->parms.laddr) ||
-+				!(t->dev->flags & IFF_UP))
-+			continue;
-+
-+		if (ipv6_addr_equal(remote, &t->parms.raddr))
- 			return t;
-+
-+		for (fmr = t->parms.fmrs; fmr; fmr = fmr->next) {
-+			if (ipv6_prefix_equal(remote, &fmr->ip6_prefix,
-+					fmr->ip6_prefix_len))
-+				return t;
-+		}
- 	}
- 
- 	memset(&any, 0, sizeof(any));
--	hash = HASH(&any, local);
-+	hash = HASH(local);
- 	for_each_ip6_tunnel_rcu(ip6n->tnls_r_l[hash]) {
- 		if (ipv6_addr_equal(local, &t->parms.laddr) &&
- 		    ipv6_addr_any(&t->parms.raddr) &&
-@@ -162,7 +173,7 @@ ip6_tnl_lookup(struct net *net, const st
- 			return t;
- 	}
- 
--	hash = HASH(remote, &any);
-+	hash = HASH(&any);
- 	for_each_ip6_tunnel_rcu(ip6n->tnls_r_l[hash]) {
- 		if (ipv6_addr_equal(remote, &t->parms.raddr) &&
- 		    ipv6_addr_any(&t->parms.laddr) &&
-@@ -202,7 +213,7 @@ ip6_tnl_bucket(struct ip6_tnl_net *ip6n,
- 
- 	if (!ipv6_addr_any(remote) || !ipv6_addr_any(local)) {
- 		prio = 1;
--		h = HASH(remote, local);
-+		h = HASH(local);
- 	}
- 	return &ip6n->tnls[prio][h];
- }
-@@ -384,6 +395,12 @@ ip6_tnl_dev_uninit(struct net_device *de
- 	struct net *net = t->net;
- 	struct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);
- 
-+	while (t->parms.fmrs) {
-+		struct __ip6_tnl_fmr *next = t->parms.fmrs->next;
-+		kfree(t->parms.fmrs);
-+		t->parms.fmrs = next;
-+	}
-+
- 	if (dev == ip6n->fb_tnl_dev)
- 		RCU_INIT_POINTER(ip6n->tnls_wc[0], NULL);
- 	else
-@@ -780,6 +797,107 @@ int ip6_tnl_rcv_ctl(struct ip6_tnl *t,
- }
- EXPORT_SYMBOL_GPL(ip6_tnl_rcv_ctl);
- 
-+/**
-+ * ip4ip6_fmr_calc - calculate target / source IPv6-address based on FMR
-+ *   @dest: destination IPv6 address buffer
-+ *   @skb: received socket buffer
-+ *   @fmr: MAP FMR
-+ *   @xmit: Calculate for xmit or rcv
-+ **/
-+static void ip4ip6_fmr_calc(struct in6_addr *dest,
-+		const struct iphdr *iph, const uint8_t *end,
-+		const struct __ip6_tnl_fmr *fmr, bool xmit)
-+{
-+	int psidlen = fmr->ea_len - (32 - fmr->ip4_prefix_len);
-+	u8 *portp = NULL;
-+	bool use_dest_addr;
-+	const struct iphdr *dsth = iph;
-+
-+	if ((u8*)dsth >= end)
-+		return;
-+
-+	/* find significant IP header */
-+	if (iph->protocol == IPPROTO_ICMP) {
-+		struct icmphdr *ih = (struct icmphdr*)(((u8*)dsth) + dsth->ihl * 4);
-+		if (ih && ((u8*)&ih[1]) <= end && (
-+			ih->type == ICMP_DEST_UNREACH ||
-+			ih->type == ICMP_SOURCE_QUENCH ||
-+			ih->type == ICMP_TIME_EXCEEDED ||
-+			ih->type == ICMP_PARAMETERPROB ||
-+			ih->type == ICMP_REDIRECT))
-+				dsth = (const struct iphdr*)&ih[1];
-+	}
-+
-+	/* in xmit-path use dest port by default and source port only if
-+		this is an ICMP reply to something else; vice versa in rcv-path */
-+	use_dest_addr = (xmit && dsth == iph) || (!xmit && dsth != iph);
-+
-+	/* get dst port */
-+	if (((u8*)&dsth[1]) <= end && (
-+		dsth->protocol == IPPROTO_UDP ||
-+		dsth->protocol == IPPROTO_TCP ||
-+		dsth->protocol == IPPROTO_SCTP ||
-+		dsth->protocol == IPPROTO_DCCP)) {
-+			/* for UDP, TCP, SCTP and DCCP source and dest port
-+			follow IPv4 header directly */
-+			portp = ((u8*)dsth) + dsth->ihl * 4;
-+
-+			if (use_dest_addr)
-+				portp += sizeof(u16);
-+	} else if (iph->protocol == IPPROTO_ICMP) {
-+		struct icmphdr *ih = (struct icmphdr*)(((u8*)dsth) + dsth->ihl * 4);
-+
-+		/* use icmp identifier as port */
-+		if (((u8*)&ih) <= end && (
-+		    (use_dest_addr && (
-+		    ih->type == ICMP_ECHOREPLY ||
-+			ih->type == ICMP_TIMESTAMPREPLY ||
-+			ih->type == ICMP_INFO_REPLY ||
-+			ih->type == ICMP_ADDRESSREPLY)) ||
-+			(!use_dest_addr && (
-+			ih->type == ICMP_ECHO ||
-+			ih->type == ICMP_TIMESTAMP ||
-+			ih->type == ICMP_INFO_REQUEST ||
-+			ih->type == ICMP_ADDRESS)
-+			)))
-+				portp = (u8*)&ih->un.echo.id;
-+	}
-+
-+	if ((portp && &portp[2] <= end) || psidlen == 0) {
-+		int frombyte = fmr->ip6_prefix_len / 8;
-+		int fromrem = fmr->ip6_prefix_len % 8;
-+		int bytes = sizeof(struct in6_addr) - frombyte;
-+		const u32 *addr = (use_dest_addr) ? &iph->daddr : &iph->saddr;
-+		u64 eabits = ((u64)ntohl(*addr)) << (32 + fmr->ip4_prefix_len);
-+		u64 t = 0;
-+
-+		/* extract PSID from port and add it to eabits */
-+		u16 psidbits = 0;
-+		if (psidlen > 0) {
-+			psidbits = ((u16)portp[0]) << 8 | ((u16)portp[1]);
-+			psidbits >>= 16 - psidlen - fmr->offset;
-+			psidbits = (u16)(psidbits << (16 - psidlen));
-+			eabits |= ((u64)psidbits) << (48 - (fmr->ea_len - psidlen));
-+		}
-+
-+		/* rewrite destination address */
-+		*dest = fmr->ip6_prefix;
-+		memcpy(&dest->s6_addr[10], addr, sizeof(*addr));
-+		dest->s6_addr16[7] = htons(psidbits >> (16 - psidlen));
-+
-+		if (bytes > sizeof(u64))
-+			bytes = sizeof(u64);
-+
-+		/* insert eabits */
-+		memcpy(&t, &dest->s6_addr[frombyte], bytes);
-+		t = be64_to_cpu(t) & ~(((((u64)1) << fmr->ea_len) - 1)
-+			<< (64 - fmr->ea_len - fromrem));
-+		t = cpu_to_be64(t | (eabits >> fromrem));
-+		memcpy(&dest->s6_addr[frombyte], &t, bytes);
-+	}
-+}
-+
-+
- static int __ip6_tnl_rcv(struct ip6_tnl *tunnel, struct sk_buff *skb,
- 			 const struct tnl_ptk_info *tpi,
- 			 struct metadata_dst *tun_dst,
-@@ -832,6 +950,27 @@ static int __ip6_tnl_rcv(struct ip6_tnl
- 	skb_reset_network_header(skb);
- 	memset(skb->cb, 0, sizeof(struct inet6_skb_parm));
- 
-+	if (tpi->proto == htons(ETH_P_IP) && tunnel->parms.fmrs &&
-+		!ipv6_addr_equal(&ipv6h->saddr, &tunnel->parms.raddr)) {
-+			/* Packet didn't come from BR, so lookup FMR */
-+			struct __ip6_tnl_fmr *fmr;
-+			struct in6_addr expected = tunnel->parms.raddr;
-+			for (fmr = tunnel->parms.fmrs; fmr; fmr = fmr->next)
-+				if (ipv6_prefix_equal(&ipv6h->saddr,
-+					&fmr->ip6_prefix, fmr->ip6_prefix_len))
-+						break;
-+
-+			/* Check that IPv6 matches IPv4 source to prevent spoofing */
-+			if (fmr)
-+				ip4ip6_fmr_calc(&expected, ip_hdr(skb),
-+						skb_tail_pointer(skb), fmr, false);
-+
-+			if (!ipv6_addr_equal(&ipv6h->saddr, &expected)) {
-+				rcu_read_unlock();
-+				goto drop;
-+			}
-+	}
-+
- 	__skb_tunnel_rx(skb, tunnel->dev, tunnel->net);
- 
- 	err = dscp_ecn_decapsulate(tunnel, ipv6h, skb);
-@@ -962,6 +1101,7 @@ static void init_tel_txopt(struct ipv6_t
- 	opt->ops.opt_nflen = 8;
- }
- 
-+
- /**
-  * ip6_tnl_addr_conflict - compare packet addresses to tunnel's own
-  *   @t: the outgoing tunnel device
-@@ -1300,6 +1440,7 @@ ip6ip6_tnl_xmit(struct sk_buff *skb, str
- {
- 	struct ip6_tnl *t = netdev_priv(dev);
- 	struct ipv6hdr *ipv6h;
-+	struct __ip6_tnl_fmr *fmr;
- 	int encap_limit = -1;
- 	__u16 offset;
- 	struct flowi6 fl6;
-@@ -1364,6 +1505,18 @@ ip6ip6_tnl_xmit(struct sk_buff *skb, str
- 
- 	dsfield = INET_ECN_encapsulate(dsfield, ipv6_get_dsfield(ipv6h));
- 
-+	/* try to find matching FMR */
-+	for (fmr = t->parms.fmrs; fmr; fmr = fmr->next) {
-+		unsigned mshift = 32 - fmr->ip4_prefix_len;
-+		if (ntohl(fmr->ip4_prefix.s_addr) >> mshift ==
-+				ntohl(ip_hdr(skb)->daddr) >> mshift)
-+			break;
-+	}
-+
-+	/* change dstaddr according to FMR */
-+	if (fmr)
-+		ip4ip6_fmr_calc(&fl6.daddr, ip_hdr(skb), skb_tail_pointer(skb), fmr, true);
-+
- 	if (iptunnel_handle_offloads(skb, SKB_GSO_IPXIP6))
- 		return -1;
- 
-@@ -1489,6 +1642,14 @@ ip6_tnl_change(struct ip6_tnl *t, const
- 	t->parms.flowinfo = p->flowinfo;
- 	t->parms.link = p->link;
- 	t->parms.proto = p->proto;
-+
-+	while (t->parms.fmrs) {
-+		struct __ip6_tnl_fmr *next = t->parms.fmrs->next;
-+		kfree(t->parms.fmrs);
-+		t->parms.fmrs = next;
-+	}
-+	t->parms.fmrs = p->fmrs;
-+
- 	dst_cache_reset(&t->dst_cache);
- 	ip6_tnl_link_config(t);
- 	return 0;
-@@ -1527,6 +1688,7 @@ ip6_tnl_parm_from_user(struct __ip6_tnl_
- 	p->flowinfo = u->flowinfo;
- 	p->link = u->link;
- 	p->proto = u->proto;
-+	p->fmrs = NULL;
- 	memcpy(p->name, u->name, sizeof(u->name));
- }
- 
-@@ -1904,6 +2066,15 @@ static int ip6_tnl_validate(struct nlatt
- 	return 0;
- }
- 
-+static const struct nla_policy ip6_tnl_fmr_policy[IFLA_IPTUN_FMR_MAX + 1] = {
-+	[IFLA_IPTUN_FMR_IP6_PREFIX] = { .len = sizeof(struct in6_addr) },
-+	[IFLA_IPTUN_FMR_IP4_PREFIX] = { .len = sizeof(struct in_addr) },
-+	[IFLA_IPTUN_FMR_IP6_PREFIX_LEN] = { .type = NLA_U8 },
-+	[IFLA_IPTUN_FMR_IP4_PREFIX_LEN] = { .type = NLA_U8 },
-+	[IFLA_IPTUN_FMR_EA_LEN] = { .type = NLA_U8 },
-+	[IFLA_IPTUN_FMR_OFFSET] = { .type = NLA_U8 }
-+};
-+
- static void ip6_tnl_netlink_parms(struct nlattr *data[],
- 				  struct __ip6_tnl_parm *parms)
- {
-@@ -1938,6 +2109,46 @@ static void ip6_tnl_netlink_parms(struct
- 
- 	if (data[IFLA_IPTUN_COLLECT_METADATA])
- 		parms->collect_md = true;
-+
-+	if (data[IFLA_IPTUN_FMRS]) {
-+		unsigned rem;
-+		struct nlattr *fmr;
-+		nla_for_each_nested(fmr, data[IFLA_IPTUN_FMRS], rem) {
-+			struct nlattr *fmrd[IFLA_IPTUN_FMR_MAX + 1], *c;
-+			struct __ip6_tnl_fmr *nfmr;
-+
-+			nla_parse_nested(fmrd, IFLA_IPTUN_FMR_MAX,
-+				fmr, ip6_tnl_fmr_policy);
-+
-+			if (!(nfmr = kzalloc(sizeof(*nfmr), GFP_KERNEL)))
-+				continue;
-+
-+			nfmr->offset = 6;
-+
-+			if ((c = fmrd[IFLA_IPTUN_FMR_IP6_PREFIX]))
-+				nla_memcpy(&nfmr->ip6_prefix, fmrd[IFLA_IPTUN_FMR_IP6_PREFIX],
-+					sizeof(nfmr->ip6_prefix));
-+
-+			if ((c = fmrd[IFLA_IPTUN_FMR_IP4_PREFIX]))
-+				nla_memcpy(&nfmr->ip4_prefix, fmrd[IFLA_IPTUN_FMR_IP4_PREFIX],
-+					sizeof(nfmr->ip4_prefix));
-+
-+			if ((c = fmrd[IFLA_IPTUN_FMR_IP6_PREFIX_LEN]))
-+				nfmr->ip6_prefix_len = nla_get_u8(c);
-+
-+			if ((c = fmrd[IFLA_IPTUN_FMR_IP4_PREFIX_LEN]))
-+				nfmr->ip4_prefix_len = nla_get_u8(c);
-+
-+			if ((c = fmrd[IFLA_IPTUN_FMR_EA_LEN]))
-+				nfmr->ea_len = nla_get_u8(c);
-+
-+			if ((c = fmrd[IFLA_IPTUN_FMR_OFFSET]))
-+				nfmr->offset = nla_get_u8(c);
-+
-+			nfmr->next = parms->fmrs;
-+			parms->fmrs = nfmr;
-+		}
-+	}
- }
- 
- static bool ip6_tnl_netlink_encap_parms(struct nlattr *data[],
-@@ -2051,6 +2262,12 @@ static void ip6_tnl_dellink(struct net_d
- 
- static size_t ip6_tnl_get_size(const struct net_device *dev)
- {
-+	const struct ip6_tnl *t = netdev_priv(dev);
-+	struct __ip6_tnl_fmr *c;
-+	int fmrs = 0;
-+	for (c = t->parms.fmrs; c; c = c->next)
-+		++fmrs;
-+
- 	return
- 		/* IFLA_IPTUN_LINK */
- 		nla_total_size(4) +
-@@ -2078,6 +2295,24 @@ static size_t ip6_tnl_get_size(const str
- 		nla_total_size(2) +
- 		/* IFLA_IPTUN_COLLECT_METADATA */
- 		nla_total_size(0) +
-+		/* IFLA_IPTUN_FMRS */
-+		nla_total_size(0) +
-+		(
-+			/* nest */
-+			nla_total_size(0) +
-+			/* IFLA_IPTUN_FMR_IP6_PREFIX */
-+			nla_total_size(sizeof(struct in6_addr)) +
-+			/* IFLA_IPTUN_FMR_IP4_PREFIX */
-+			nla_total_size(sizeof(struct in_addr)) +
-+			/* IFLA_IPTUN_FMR_EA_LEN */
-+			nla_total_size(1) +
-+			/* IFLA_IPTUN_FMR_IP6_PREFIX_LEN */
-+			nla_total_size(1) +
-+			/* IFLA_IPTUN_FMR_IP4_PREFIX_LEN */
-+			nla_total_size(1) +
-+			/* IFLA_IPTUN_FMR_OFFSET */
-+			nla_total_size(1)
-+		) * fmrs +
- 		0;
- }
- 
-@@ -2085,6 +2320,9 @@ static int ip6_tnl_fill_info(struct sk_b
- {
- 	struct ip6_tnl *tunnel = netdev_priv(dev);
- 	struct __ip6_tnl_parm *parm = &tunnel->parms;
-+	struct __ip6_tnl_fmr *c;
-+	int fmrcnt = 0;
-+	struct nlattr *fmrs;
- 
- 	if (nla_put_u32(skb, IFLA_IPTUN_LINK, parm->link) ||
- 	    nla_put_in6_addr(skb, IFLA_IPTUN_LOCAL, &parm->laddr) ||
-@@ -2093,9 +2331,27 @@ static int ip6_tnl_fill_info(struct sk_b
- 	    nla_put_u8(skb, IFLA_IPTUN_ENCAP_LIMIT, parm->encap_limit) ||
- 	    nla_put_be32(skb, IFLA_IPTUN_FLOWINFO, parm->flowinfo) ||
- 	    nla_put_u32(skb, IFLA_IPTUN_FLAGS, parm->flags) ||
--	    nla_put_u8(skb, IFLA_IPTUN_PROTO, parm->proto))
-+	    nla_put_u8(skb, IFLA_IPTUN_PROTO, parm->proto) ||
-+	    !(fmrs = nla_nest_start(skb, IFLA_IPTUN_FMRS)))
- 		goto nla_put_failure;
- 
-+	for (c = parm->fmrs; c; c = c->next) {
-+		struct nlattr *fmr = nla_nest_start(skb, ++fmrcnt);
-+		if (!fmr ||
-+			nla_put(skb, IFLA_IPTUN_FMR_IP6_PREFIX,
-+				sizeof(c->ip6_prefix), &c->ip6_prefix) ||
-+			nla_put(skb, IFLA_IPTUN_FMR_IP4_PREFIX,
-+				sizeof(c->ip4_prefix), &c->ip4_prefix) ||
-+			nla_put_u8(skb, IFLA_IPTUN_FMR_IP6_PREFIX_LEN, c->ip6_prefix_len) ||
-+			nla_put_u8(skb, IFLA_IPTUN_FMR_IP4_PREFIX_LEN, c->ip4_prefix_len) ||
-+			nla_put_u8(skb, IFLA_IPTUN_FMR_EA_LEN, c->ea_len) ||
-+			nla_put_u8(skb, IFLA_IPTUN_FMR_OFFSET, c->offset))
-+				goto nla_put_failure;
-+
-+		nla_nest_end(skb, fmr);
-+	}
-+	nla_nest_end(skb, fmrs);
-+
- 	if (nla_put_u16(skb, IFLA_IPTUN_ENCAP_TYPE, tunnel->encap.type) ||
- 	    nla_put_be16(skb, IFLA_IPTUN_ENCAP_SPORT, tunnel->encap.sport) ||
- 	    nla_put_be16(skb, IFLA_IPTUN_ENCAP_DPORT, tunnel->encap.dport) ||
-@@ -2133,6 +2389,7 @@ static const struct nla_policy ip6_tnl_p
- 	[IFLA_IPTUN_ENCAP_SPORT]	= { .type = NLA_U16 },
- 	[IFLA_IPTUN_ENCAP_DPORT]	= { .type = NLA_U16 },
- 	[IFLA_IPTUN_COLLECT_METADATA]	= { .type = NLA_FLAG },
-+	[IFLA_IPTUN_FMRS]		= { .type = NLA_NESTED },
- };
- 
- static struct rtnl_link_ops ip6_link_ops __read_mostly = {
--- a/target/linux/generic/pending-4.9/670-ipv6-allow-rejecting-with-source-address-failed-policy.patch	2022-03-22 08:54:47.443465063 +0800
+++ b/target/linux/generic/pending-4.9/670-ipv6-allow-rejecting-with-source-address-failed-policy.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,255 +0,0 @@
-From: Jonas Gorski <jogo@openwrt.org>
-Subject: ipv6: allow rejecting with "source address failed policy"
-
-RFC6204 L-14 requires rejecting traffic from invalid addresses with
-ICMPv6 Destination Unreachable, Code 5 (Source address failed ingress/
-egress policy) on the LAN side, so add an appropriate rule for that.
-
-Signed-off-by: Jonas Gorski <jogo@openwrt.org>
----
- include/net/netns/ipv6.h       |  1 +
- include/uapi/linux/fib_rules.h |  4 +++
- include/uapi/linux/rtnetlink.h |  1 +
- net/ipv4/fib_semantics.c       |  4 +++
- net/ipv4/fib_trie.c            |  1 +
- net/ipv4/ipmr.c                |  1 +
- net/ipv6/fib6_rules.c          |  4 +++
- net/ipv6/ip6mr.c               |  2 ++
- net/ipv6/route.c               | 58 +++++++++++++++++++++++++++++++++++++++++-
- 9 files changed, 75 insertions(+), 1 deletion(-)
-
---- a/include/net/netns/ipv6.h
-+++ b/include/net/netns/ipv6.h
-@@ -66,6 +66,7 @@ struct netns_ipv6 {
- 	unsigned long		 ip6_rt_last_gc;
- #ifdef CONFIG_IPV6_MULTIPLE_TABLES
- 	struct rt6_info         *ip6_prohibit_entry;
-+	struct rt6_info		*ip6_policy_failed_entry;
- 	struct rt6_info         *ip6_blk_hole_entry;
- 	struct fib6_table       *fib6_local_tbl;
- 	struct fib_rules_ops    *fib6_rules_ops;
---- a/include/uapi/linux/fib_rules.h
-+++ b/include/uapi/linux/fib_rules.h
-@@ -66,6 +66,10 @@ enum {
- 	FR_ACT_BLACKHOLE,	/* Drop without notification */
- 	FR_ACT_UNREACHABLE,	/* Drop with ENETUNREACH */
- 	FR_ACT_PROHIBIT,	/* Drop with EACCES */
-+	FR_ACT_RES9,
-+	FR_ACT_RES10,
-+	FR_ACT_RES11,
-+	FR_ACT_POLICY_FAILED,	/* Drop with EACCES */
- 	__FR_ACT_MAX,
- };
- 
---- a/include/uapi/linux/rtnetlink.h
-+++ b/include/uapi/linux/rtnetlink.h
-@@ -215,6 +215,7 @@ enum {
- 	RTN_THROW,		/* Not in this table		*/
- 	RTN_NAT,		/* Translate this address	*/
- 	RTN_XRESOLVE,		/* Use external resolver	*/
-+	RTN_POLICY_FAILED,	/* Failed ingress/egress policy */
- 	__RTN_MAX
- };
- 
---- a/net/ipv4/fib_semantics.c
-+++ b/net/ipv4/fib_semantics.c
-@@ -138,6 +138,10 @@ const struct fib_prop fib_props[RTN_MAX
- 		.error	= -EINVAL,
- 		.scope	= RT_SCOPE_NOWHERE,
- 	},
-+	[RTN_POLICY_FAILED] = {
-+		.error	= -EACCES,
-+		.scope	= RT_SCOPE_UNIVERSE,
-+	},
- };
- 
- static void rt_fibinfo_free(struct rtable __rcu **rtp)
---- a/net/ipv4/fib_trie.c
-+++ b/net/ipv4/fib_trie.c
-@@ -2406,6 +2406,7 @@ static const char *const rtn_type_names[
- 	[RTN_THROW] = "THROW",
- 	[RTN_NAT] = "NAT",
- 	[RTN_XRESOLVE] = "XRESOLVE",
-+	[RTN_POLICY_FAILED] = "POLICY_FAILED",
- };
- 
- static inline const char *rtn_type(char *buf, size_t len, unsigned int t)
---- a/net/ipv4/ipmr.c
-+++ b/net/ipv4/ipmr.c
-@@ -159,6 +159,7 @@ static int ipmr_rule_action(struct fib_r
- 	case FR_ACT_UNREACHABLE:
- 		return -ENETUNREACH;
- 	case FR_ACT_PROHIBIT:
-+	case FR_ACT_POLICY_FAILED:
- 		return -EACCES;
- 	case FR_ACT_BLACKHOLE:
- 	default:
---- a/net/ipv6/fib6_rules.c
-+++ b/net/ipv6/fib6_rules.c
-@@ -77,6 +77,10 @@ static int fib6_rule_action(struct fib_r
- 		err = -EACCES;
- 		rt = net->ipv6.ip6_prohibit_entry;
- 		goto discard_pkt;
-+	case FR_ACT_POLICY_FAILED:
-+		err = -EACCES;
-+		rt = net->ipv6.ip6_policy_failed_entry;
-+		goto discard_pkt;
- 	}
- 
- 	tb_id = fib_rule_get_table(rule, arg);
---- a/net/ipv6/ip6mr.c
-+++ b/net/ipv6/ip6mr.c
-@@ -169,6 +169,8 @@ static int ip6mr_rule_action(struct fib_
- 		return -ENETUNREACH;
- 	case FR_ACT_PROHIBIT:
- 		return -EACCES;
-+	case FR_ACT_POLICY_FAILED:
-+		return -EACCES;
- 	case FR_ACT_BLACKHOLE:
- 	default:
- 		return -EINVAL;
---- a/net/ipv6/route.c
-+++ b/net/ipv6/route.c
-@@ -91,6 +91,8 @@ static int		ip6_pkt_discard(struct sk_bu
- static int		ip6_pkt_discard_out(struct net *net, struct sock *sk, struct sk_buff *skb);
- static int		ip6_pkt_prohibit(struct sk_buff *skb);
- static int		ip6_pkt_prohibit_out(struct net *net, struct sock *sk, struct sk_buff *skb);
-+static int		ip6_pkt_policy_failed(struct sk_buff *skb);
-+static int		ip6_pkt_policy_failed_out(struct net *net, struct sock *sk, struct sk_buff *skb);
- static void		ip6_link_failure(struct sk_buff *skb);
- static void		ip6_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,
- 					   struct sk_buff *skb, u32 mtu);
-@@ -300,6 +302,21 @@ static const struct rt6_info ip6_prohibi
- 	.rt6i_ref	= ATOMIC_INIT(1),
- };
- 
-+static const struct rt6_info ip6_policy_failed_entry_template = {
-+	.dst = {
-+		.__refcnt	= ATOMIC_INIT(1),
-+		.__use		= 1,
-+		.obsolete	= DST_OBSOLETE_FORCE_CHK,
-+		.error		= -EACCES,
-+		.input		= ip6_pkt_policy_failed,
-+		.output		= ip6_pkt_policy_failed_out,
-+	},
-+	.rt6i_flags	= (RTF_REJECT | RTF_NONEXTHOP),
-+	.rt6i_protocol	= RTPROT_KERNEL,
-+	.rt6i_metric	= ~(u32) 0,
-+	.rt6i_ref	= ATOMIC_INIT(1),
-+};
-+
- static const struct rt6_info ip6_blk_hole_entry_template = {
- 	.dst = {
- 		.__refcnt	= ATOMIC_INIT(1),
-@@ -1970,6 +1987,11 @@ static struct rt6_info *ip6_route_info_c
- 			rt->dst.output = ip6_pkt_prohibit_out;
- 			rt->dst.input = ip6_pkt_prohibit;
- 			break;
-+		case RTN_POLICY_FAILED:
-+			rt->dst.error = -EACCES;
-+			rt->dst.output = ip6_pkt_policy_failed_out;
-+			rt->dst.input = ip6_pkt_policy_failed;
-+			break;
- 		case RTN_THROW:
- 		case RTN_UNREACHABLE:
- 		default:
-@@ -2613,6 +2635,17 @@ static int ip6_pkt_prohibit_out(struct n
- 	return ip6_pkt_drop(skb, ICMPV6_ADM_PROHIBITED, IPSTATS_MIB_OUTNOROUTES);
- }
- 
-+static int ip6_pkt_policy_failed(struct sk_buff *skb)
-+{
-+	return ip6_pkt_drop(skb, ICMPV6_POLICY_FAIL, IPSTATS_MIB_INNOROUTES);
-+}
-+
-+static int ip6_pkt_policy_failed_out(struct net *net, struct sock *sk, struct sk_buff *skb)
-+{
-+	skb->dev = skb_dst(skb)->dev;
-+	return ip6_pkt_drop(skb, ICMPV6_POLICY_FAIL, IPSTATS_MIB_OUTNOROUTES);
-+}
-+
- /*
-  *	Allocate a dst for local (unicast / anycast) address.
-  */
-@@ -2850,7 +2883,8 @@ static int rtm_to_fib6_config(struct sk_
- 	if (rtm->rtm_type == RTN_UNREACHABLE ||
- 	    rtm->rtm_type == RTN_BLACKHOLE ||
- 	    rtm->rtm_type == RTN_PROHIBIT ||
--	    rtm->rtm_type == RTN_THROW)
-+	    rtm->rtm_type == RTN_THROW ||
-+	    rtm->rtm_type == RTN_POLICY_FAILED)
- 		cfg->fc_flags |= RTF_REJECT;
- 
- 	if (rtm->rtm_type == RTN_LOCAL)
-@@ -3222,6 +3256,9 @@ static int rt6_fill_node(struct net *net
- 		case -EACCES:
- 			rtm->rtm_type = RTN_PROHIBIT;
- 			break;
-+		case -EPERM:
-+			rtm->rtm_type = RTN_POLICY_FAILED;
-+			break;
- 		case -EAGAIN:
- 			rtm->rtm_type = RTN_THROW;
- 			break;
-@@ -3498,6 +3535,8 @@ static int ip6_route_dev_notify(struct n
- #ifdef CONFIG_IPV6_MULTIPLE_TABLES
- 		net->ipv6.ip6_prohibit_entry->dst.dev = dev;
- 		net->ipv6.ip6_prohibit_entry->rt6i_idev = in6_dev_get(dev);
-+		net->ipv6.ip6_policy_failed_entry->dst.dev = dev;
-+		net->ipv6.ip6_policy_failed_entry->rt6i_idev = in6_dev_get(dev);
- 		net->ipv6.ip6_blk_hole_entry->dst.dev = dev;
- 		net->ipv6.ip6_blk_hole_entry->rt6i_idev = in6_dev_get(dev);
- #endif
-@@ -3509,6 +3548,7 @@ static int ip6_route_dev_notify(struct n
- 		in6_dev_put(net->ipv6.ip6_null_entry->rt6i_idev);
- #ifdef CONFIG_IPV6_MULTIPLE_TABLES
- 		in6_dev_put(net->ipv6.ip6_prohibit_entry->rt6i_idev);
-+		in6_dev_put(net->ipv6.ip6_policy_failed_entry->rt6i_idev);
- 		in6_dev_put(net->ipv6.ip6_blk_hole_entry->rt6i_idev);
- #endif
- 	}
-@@ -3724,6 +3764,17 @@ static int __net_init ip6_route_net_init
- 	net->ipv6.ip6_blk_hole_entry->dst.ops = &net->ipv6.ip6_dst_ops;
- 	dst_init_metrics(&net->ipv6.ip6_blk_hole_entry->dst,
- 			 ip6_template_metrics, true);
-+
-+	net->ipv6.ip6_policy_failed_entry =
-+		kmemdup(&ip6_policy_failed_entry_template,
-+			sizeof(*net->ipv6.ip6_policy_failed_entry), GFP_KERNEL);
-+	if (!net->ipv6.ip6_policy_failed_entry)
-+		goto out_ip6_blk_hole_entry;
-+	net->ipv6.ip6_policy_failed_entry->dst.path =
-+		(struct dst_entry *)net->ipv6.ip6_policy_failed_entry;
-+	net->ipv6.ip6_policy_failed_entry->dst.ops = &net->ipv6.ip6_dst_ops;
-+	dst_init_metrics(&net->ipv6.ip6_policy_failed_entry->dst,
-+			 ip6_template_metrics, true);
- #endif
- 
- 	net->ipv6.sysctl.flush_delay = 0;
-@@ -3742,6 +3793,8 @@ out:
- 	return ret;
- 
- #ifdef CONFIG_IPV6_MULTIPLE_TABLES
-+out_ip6_blk_hole_entry:
-+	kfree(net->ipv6.ip6_blk_hole_entry);
- out_ip6_prohibit_entry:
- 	kfree(net->ipv6.ip6_prohibit_entry);
- out_ip6_null_entry:
-@@ -3759,6 +3812,7 @@ static void __net_exit ip6_route_net_exi
- #ifdef CONFIG_IPV6_MULTIPLE_TABLES
- 	kfree(net->ipv6.ip6_prohibit_entry);
- 	kfree(net->ipv6.ip6_blk_hole_entry);
-+	kfree(net->ipv6.ip6_policy_failed_entry);
- #endif
- 	dst_entries_destroy(&net->ipv6.ip6_dst_ops);
- }
-@@ -3832,6 +3886,9 @@ void __init ip6_route_init_special_entri
- 	init_net.ipv6.ip6_prohibit_entry->rt6i_idev = in6_dev_get(init_net.loopback_dev);
- 	init_net.ipv6.ip6_blk_hole_entry->dst.dev = init_net.loopback_dev;
- 	init_net.ipv6.ip6_blk_hole_entry->rt6i_idev = in6_dev_get(init_net.loopback_dev);
-+	init_net.ipv6.ip6_policy_failed_entry->dst.dev = init_net.loopback_dev;
-+	init_net.ipv6.ip6_policy_failed_entry->rt6i_idev =
-+		in6_dev_get(init_net.loopback_dev);
-   #endif
- }
- 
--- a/target/linux/generic/pending-4.9/671-net-provide-defines-for-_POLICY_FAILED-until-all-cod.patch	2022-03-22 08:54:47.443465063 +0800
+++ b/target/linux/generic/pending-4.9/671-net-provide-defines-for-_POLICY_FAILED-until-all-cod.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,50 +0,0 @@
-From: Jonas Gorski <jogo@openwrt.org>
-Subject: net: provide defines for _POLICY_FAILED until all code is updated
-
-Upstream introduced ICMPV6_POLICY_FAIL for code 5 of destination
-unreachable, conflicting with our name.
-
-Add appropriate defines to allow our code to build with the new
-name until we have updated our local patches for older kernels
-and userspace packages.
-
-Signed-off-by: Jonas Gorski <jogo@openwrt.org>
----
- include/uapi/linux/fib_rules.h | 2 ++
- include/uapi/linux/icmpv6.h    | 2 ++
- include/uapi/linux/rtnetlink.h | 2 ++
- 3 files changed, 6 insertions(+)
-
---- a/include/uapi/linux/fib_rules.h
-+++ b/include/uapi/linux/fib_rules.h
-@@ -73,6 +73,8 @@ enum {
- 	__FR_ACT_MAX,
- };
- 
-+#define FR_ACT_FAILED_POLICY FR_ACT_POLICY_FAILED
-+
- #define FR_ACT_MAX (__FR_ACT_MAX - 1)
- 
- #endif
---- a/include/uapi/linux/icmpv6.h
-+++ b/include/uapi/linux/icmpv6.h
-@@ -118,6 +118,8 @@ struct icmp6hdr {
- #define ICMPV6_POLICY_FAIL		5
- #define ICMPV6_REJECT_ROUTE		6
- 
-+#define ICMPV6_FAILED_POLICY		ICMPV6_POLICY_FAIL
-+
- /*
-  *	Codes for Time Exceeded
-  */
---- a/include/uapi/linux/rtnetlink.h
-+++ b/include/uapi/linux/rtnetlink.h
-@@ -219,6 +219,8 @@ enum {
- 	__RTN_MAX
- };
- 
-+#define RTN_FAILED_POLICY RTN_POLICY_FAILED
-+
- #define RTN_MAX (__RTN_MAX - 1)
- 
- 
--- a/target/linux/generic/pending-4.9/680-NET-skip-GRO-for-foreign-MAC-addresses.patch	2022-03-22 08:54:47.443465063 +0800
+++ b/target/linux/generic/pending-4.9/680-NET-skip-GRO-for-foreign-MAC-addresses.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,154 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: net: replace GRO optimization patch with a new one that supports VLANs/bridges with different MAC addresses
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/linux/netdevice.h |  2 ++
- include/linux/skbuff.h    |  3 ++-
- net/core/dev.c            | 48 +++++++++++++++++++++++++++++++++++++++++++++++
- net/ethernet/eth.c        | 18 +++++++++++++++++-
- 4 files changed, 69 insertions(+), 2 deletions(-)
-
---- a/include/linux/netdevice.h
-+++ b/include/linux/netdevice.h
-@@ -1752,6 +1752,8 @@ struct net_device {
- 	struct netdev_hw_addr_list	mc;
- 	struct netdev_hw_addr_list	dev_addrs;
- 
-+	unsigned char		local_addr_mask[MAX_ADDR_LEN];
-+
- #ifdef CONFIG_SYSFS
- 	struct kset		*queues_kset;
- #endif
---- a/include/linux/skbuff.h
-+++ b/include/linux/skbuff.h
-@@ -747,7 +747,8 @@ struct sk_buff {
- #ifdef CONFIG_NET_SWITCHDEV
- 	__u8			offload_fwd_mark:1;
- #endif
--	/* 2, 4 or 5 bit hole */
-+	__u8			gro_skip:1;
-+	/* 1, 3 or 4 bit hole */
- 
- #ifdef CONFIG_NET_SCHED
- 	__u16			tc_index;	/* traffic control index */
---- a/net/core/dev.c
-+++ b/net/core/dev.c
-@@ -4572,6 +4572,9 @@ static enum gro_result dev_gro_receive(s
- 	enum gro_result ret;
- 	int grow;
- 
-+	if (skb->gro_skip)
-+		goto normal;
-+
- 	if (!(skb->dev->features & NETIF_F_GRO))
- 		goto normal;
- 
-@@ -5867,6 +5870,48 @@ static void __netdev_adjacent_dev_unlink
- 					   &upper_dev->adj_list.lower);
- }
- 
-+static void __netdev_addr_mask(unsigned char *mask, const unsigned char *addr,
-+			       struct net_device *dev)
-+{
-+	int i;
-+
-+	for (i = 0; i < dev->addr_len; i++)
-+		mask[i] |= addr[i] ^ dev->dev_addr[i];
-+}
-+
-+static void __netdev_upper_mask(unsigned char *mask, struct net_device *dev,
-+				struct net_device *lower)
-+{
-+	struct net_device *cur;
-+	struct list_head *iter;
-+
-+	netdev_for_each_upper_dev_rcu(dev, cur, iter) {
-+		__netdev_addr_mask(mask, cur->dev_addr, lower);
-+		__netdev_upper_mask(mask, cur, lower);
-+	}
-+}
-+
-+static void __netdev_update_addr_mask(struct net_device *dev)
-+{
-+	unsigned char mask[MAX_ADDR_LEN];
-+	struct net_device *cur;
-+	struct list_head *iter;
-+
-+	memset(mask, 0, sizeof(mask));
-+	__netdev_upper_mask(mask, dev, dev);
-+	memcpy(dev->local_addr_mask, mask, dev->addr_len);
-+
-+	netdev_for_each_lower_dev(dev, cur, iter)
-+		__netdev_update_addr_mask(cur);
-+}
-+
-+static void netdev_update_addr_mask(struct net_device *dev)
-+{
-+	rcu_read_lock();
-+	__netdev_update_addr_mask(dev);
-+	rcu_read_unlock();
-+}
-+
- static int __netdev_upper_dev_link(struct net_device *dev,
- 				   struct net_device *upper_dev, bool master,
- 				   void *upper_priv, void *upper_info)
-@@ -5939,6 +5984,7 @@ static int __netdev_upper_dev_link(struc
- 			goto rollback_lower_mesh;
- 	}
- 
-+	netdev_update_addr_mask(dev);
- 	ret = call_netdevice_notifiers_info(NETDEV_CHANGEUPPER, dev,
- 					    &changeupper_info.info);
- 	ret = notifier_to_errno(ret);
-@@ -6065,6 +6111,7 @@ void netdev_upper_dev_unlink(struct net_
- 	list_for_each_entry(i, &upper_dev->all_adj_list.upper, list)
- 		__netdev_adjacent_dev_unlink(dev, i->dev, i->ref_nr);
- 
-+	netdev_update_addr_mask(dev);
- 	call_netdevice_notifiers_info(NETDEV_CHANGEUPPER, dev,
- 				      &changeupper_info.info);
- }
-@@ -6667,6 +6714,7 @@ int dev_set_mac_address(struct net_devic
- 	if (err)
- 		return err;
- 	dev->addr_assign_type = NET_ADDR_SET;
-+	netdev_update_addr_mask(dev);
- 	call_netdevice_notifiers(NETDEV_CHANGEADDR, dev);
- 	add_device_randomness(dev->dev_addr, dev->addr_len);
- 	return 0;
---- a/net/ethernet/eth.c
-+++ b/net/ethernet/eth.c
-@@ -143,6 +143,18 @@ u32 eth_get_headlen(void *data, unsigned
- }
- EXPORT_SYMBOL(eth_get_headlen);
- 
-+static inline bool
-+eth_check_local_mask(const void *addr1, const void *addr2, const void *mask)
-+{
-+	const u16 *a1 = addr1;
-+	const u16 *a2 = addr2;
-+	const u16 *m = mask;
-+
-+	return (((a1[0] ^ a2[0]) & ~m[0]) |
-+		((a1[1] ^ a2[1]) & ~m[1]) |
-+		((a1[2] ^ a2[2]) & ~m[2]));
-+}
-+
- /**
-  * eth_type_trans - determine the packet's protocol ID.
-  * @skb: received socket data
-@@ -171,8 +183,12 @@ __be16 eth_type_trans(struct sk_buff *sk
- 			skb->pkt_type = PACKET_MULTICAST;
- 	}
- 	else if (unlikely(!ether_addr_equal_64bits(eth->h_dest,
--						   dev->dev_addr)))
-+						   dev->dev_addr))) {
- 		skb->pkt_type = PACKET_OTHERHOST;
-+		if (eth_check_local_mask(eth->h_dest, dev->dev_addr,
-+					 dev->local_addr_mask))
-+			skb->gro_skip = 1;
-+	}
- 
- 	/*
- 	 * Some variants of DSA tagging don't have an ethertype field
--- a/target/linux/generic/pending-4.9/681-NET-add-of_get_mac_address_mtd.patch	2022-03-22 08:54:47.444465064 +0800
+++ b/target/linux/generic/pending-4.9/681-NET-add-of_get_mac_address_mtd.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,127 +0,0 @@
-From: John Crispin <blogic@openwrt.org>
-Subject: NET: add mtd-mac-address support to of_get_mac_address()
-
-Many embedded devices have information such as mac addresses stored inside mtd
-devices. This patch allows us to add a property inside a node describing a
-network interface. The new property points at a mtd partition with an offset
-where the mac address can be found.
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- drivers/of/of_net.c    |   37 +++++++++++++++++++++++++++++++++++++
- include/linux/of_net.h |    1 +
- 2 files changed, 38 insertions(+)
-
---- a/drivers/of/of_net.c
-+++ b/drivers/of/of_net.c
-@@ -10,6 +10,7 @@
- #include <linux/of_net.h>
- #include <linux/phy.h>
- #include <linux/export.h>
-+#include <linux/mtd/mtd.h>
- 
- /**
-  * of_get_phy_mode - Get phy mode for given device_node
-@@ -38,7 +39,7 @@ int of_get_phy_mode(struct device_node *
- }
- EXPORT_SYMBOL_GPL(of_get_phy_mode);
- 
--static const void *of_get_mac_addr(struct device_node *np, const char *name)
-+static void *of_get_mac_addr(struct device_node *np, const char *name)
- {
- 	struct property *pp = of_find_property(np, name, NULL);
- 
-@@ -47,6 +48,73 @@ static const void *of_get_mac_addr(struc
- 	return NULL;
- }
- 
-+static const void *of_get_mac_address_mtd(struct device_node *np)
-+{
-+#ifdef CONFIG_MTD
-+	struct device_node *mtd_np = NULL;
-+	struct property *prop;
-+	size_t retlen;
-+	int size, ret;
-+	struct mtd_info *mtd;
-+	const char *part;
-+	const __be32 *list;
-+	phandle phandle;
-+	u32 mac_inc = 0;
-+	u8 mac[ETH_ALEN];
-+	void *addr;
-+
-+	list = of_get_property(np, "mtd-mac-address", &size);
-+	if (!list || (size != (2 * sizeof(*list))))
-+		return NULL;
-+
-+	phandle = be32_to_cpup(list++);
-+	if (phandle)
-+		mtd_np = of_find_node_by_phandle(phandle);
-+
-+	if (!mtd_np)
-+		return NULL;
-+
-+	part = of_get_property(mtd_np, "label", NULL);
-+	if (!part)
-+		part = mtd_np->name;
-+
-+	mtd = get_mtd_device_nm(part);
-+	if (IS_ERR(mtd))
-+		return NULL;
-+
-+	ret = mtd_read(mtd, be32_to_cpup(list), 6, &retlen, mac);
-+	put_mtd_device(mtd);
-+
-+	if (!of_property_read_u32(np, "mtd-mac-address-increment", &mac_inc))
-+		mac[5] += mac_inc;
-+
-+	if (!is_valid_ether_addr(mac))
-+		return NULL;
-+
-+	addr = of_get_mac_addr(np, "mac-address");
-+	if (addr) {
-+		memcpy(addr, mac, ETH_ALEN);
-+		return addr;
-+	}
-+
-+	prop = kzalloc(sizeof(*prop), GFP_KERNEL);
-+	if (!prop)
-+		return NULL;
-+
-+	prop->name = "mac-address";
-+	prop->length = ETH_ALEN;
-+	prop->value = kmemdup(mac, ETH_ALEN, GFP_KERNEL);
-+	if (!prop->value || of_add_property(np, prop))
-+		goto free;
-+
-+	return prop->value;
-+free:
-+	kfree(prop->value);
-+	kfree(prop);
-+#endif
-+	return NULL;
-+}
-+
- /**
-  * Search the device tree for the best MAC address to use.  'mac-address' is
-  * checked first, because that is supposed to contain to "most recent" MAC
-@@ -64,11 +132,18 @@ static const void *of_get_mac_addr(struc
-  * addresses.  Some older U-Boots only initialized 'local-mac-address'.  In
-  * this case, the real MAC is in 'local-mac-address', and 'mac-address' exists
-  * but is all zeros.
-+ *
-+ * If a mtd-mac-address property exists, try to fetch the MAC address from the
-+ * specified mtd device, and store it as a 'mac-address' property
- */
- const void *of_get_mac_address(struct device_node *np)
- {
- 	const void *addr;
- 
-+	addr = of_get_mac_address_mtd(np);
-+	if (addr)
-+		return addr;
-+
- 	addr = of_get_mac_addr(np, "mac-address");
- 	if (addr)
- 		return addr;
--- a/target/linux/generic/pending-4.9/701-phy_extension.patch	2022-03-22 08:54:47.444465064 +0800
+++ b/target/linux/generic/pending-4.9/701-phy_extension.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,72 +0,0 @@
-From: John Crispin <john@phrozen.org>
-Subject: net: phy: add phy_ethtool_ioctl()
-
-Signed-off-by: John Crispin <john@phrozen.org>
----
- drivers/net/phy/phy.c | 44 ++++++++++++++++++++++++++++++++++++++++++++
- include/linux/phy.h   |  1 +
- 2 files changed, 45 insertions(+)
-
---- a/drivers/net/phy/phy.c
-+++ b/drivers/net/phy/phy.c
-@@ -472,6 +472,50 @@ int phy_ethtool_ksettings_get(struct phy
- }
- EXPORT_SYMBOL(phy_ethtool_ksettings_get);
- 
-+int phy_ethtool_ioctl(struct phy_device *phydev, void *useraddr)
-+{
-+	u32 cmd;
-+	int tmp;
-+	struct ethtool_cmd ecmd = { ETHTOOL_GSET };
-+	struct ethtool_value edata = { ETHTOOL_GLINK };
-+
-+	if (get_user(cmd, (u32 *) useraddr))
-+		return -EFAULT;
-+
-+	switch (cmd) {
-+	case ETHTOOL_GSET:
-+		phy_ethtool_gset(phydev, &ecmd);
-+		if (copy_to_user(useraddr, &ecmd, sizeof(ecmd)))
-+			return -EFAULT;
-+		return 0;
-+
-+	case ETHTOOL_SSET:
-+		if (copy_from_user(&ecmd, useraddr, sizeof(ecmd)))
-+			return -EFAULT;
-+		return phy_ethtool_sset(phydev, &ecmd);
-+
-+	case ETHTOOL_NWAY_RST:
-+		/* if autoneg is off, it's an error */
-+		tmp = phy_read(phydev, MII_BMCR);
-+		if (tmp & BMCR_ANENABLE) {
-+			tmp |= (BMCR_ANRESTART);
-+			phy_write(phydev, MII_BMCR, tmp);
-+			return 0;
-+		}
-+		return -EINVAL;
-+
-+	case ETHTOOL_GLINK:
-+		edata.data = (phy_read(phydev,
-+				MII_BMSR) & BMSR_LSTATUS) ? 1 : 0;
-+		if (copy_to_user(useraddr, &edata, sizeof(edata)))
-+			return -EFAULT;
-+		return 0;
-+	}
-+
-+	return -EOPNOTSUPP;
-+}
-+EXPORT_SYMBOL(phy_ethtool_ioctl);
-+
- /**
-  * phy_mii_ioctl - generic PHY MII ioctl interface
-  * @phydev: the phy_device struct
---- a/include/linux/phy.h
-+++ b/include/linux/phy.h
-@@ -827,6 +827,7 @@ int phy_ethtool_ksettings_get(struct phy
- 			      struct ethtool_link_ksettings *cmd);
- int phy_ethtool_ksettings_set(struct phy_device *phydev,
- 			      const struct ethtool_link_ksettings *cmd);
-+int phy_ethtool_ioctl(struct phy_device *phydev, void *useraddr);
- int phy_mii_ioctl(struct phy_device *phydev, struct ifreq *ifr, int cmd);
- int phy_start_interrupts(struct phy_device *phydev);
- void phy_print_status(struct phy_device *phydev);
--- a/target/linux/generic/pending-4.9/703-phy-add-detach-callback-to-struct-phy_driver.patch	2022-03-22 08:54:47.444465064 +0800
+++ b/target/linux/generic/pending-4.9/703-phy-add-detach-callback-to-struct-phy_driver.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,38 +0,0 @@
-From: Gabor Juhos <juhosg@openwrt.org>
-Subject: generic: add detach callback to struct phy_driver
-
-lede-commit: fe61fc2d7d0b3fb348b502f68f98243b3ddf5867
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/phy/phy_device.c | 3 +++
- include/linux/phy.h          | 6 ++++++
- 2 files changed, 9 insertions(+)
-
---- a/drivers/net/phy/phy_device.c
-+++ b/drivers/net/phy/phy_device.c
-@@ -1004,6 +1004,9 @@ void phy_detach(struct phy_device *phyde
- 	struct mii_bus *bus;
- 	int i;
- 
-+	if (phydev->drv && phydev->drv->detach)
-+		phydev->drv->detach(phydev);
-+
- 	phydev->attached_dev->phydev = NULL;
- 	phydev->attached_dev = NULL;
- 	phy_suspend(phydev);
---- a/include/linux/phy.h
-+++ b/include/linux/phy.h
-@@ -507,6 +507,12 @@ struct phy_driver {
- 	 */
- 	int (*did_interrupt)(struct phy_device *phydev);
- 
-+	/*
-+	 * Called before an ethernet device is detached
-+	 * from the PHY.
-+	 */
-+	void (*detach)(struct phy_device *phydev);
-+
- 	/* Clears up any memory if needed */
- 	void (*remove)(struct phy_device *phydev);
- 
--- a/target/linux/generic/pending-4.9/734-net-phy-at803x-allow-to-configure-via-pdata.patch	2022-03-22 08:54:47.445465066 +0800
+++ b/target/linux/generic/pending-4.9/734-net-phy-at803x-allow-to-configure-via-pdata.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,142 +0,0 @@
-From: Gabor Juhos <juhosg@openwrt.org>
-Subject: net: phy: allow to configure AR803x PHYs via platform data
-
-Add a patch for the at803x phy driver, in order to be able
-to configure some register settings via platform data.
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/phy/at803x.c                 | 56 ++++++++++++++++++++++++++++++++
- include/linux/platform_data/phy-at803x.h | 11 +++++++
- 2 files changed, 67 insertions(+)
- create mode 100644 include/linux/platform_data/phy-at803x.h
-
---- a/drivers/net/phy/at803x.c
-+++ b/drivers/net/phy/at803x.c
-@@ -12,12 +12,14 @@
-  */
- 
- #include <linux/phy.h>
-+#include <linux/mdio.h>
- #include <linux/module.h>
- #include <linux/string.h>
- #include <linux/netdevice.h>
- #include <linux/etherdevice.h>
- #include <linux/of_gpio.h>
- #include <linux/gpio/consumer.h>
-+#include <linux/platform_data/phy-at803x.h>
- 
- #define AT803X_INTR_ENABLE			0x12
- #define AT803X_INTR_ENABLE_AUTONEG_ERR		BIT(15)
-@@ -45,6 +47,11 @@
- #define AT803X_REG_CHIP_CONFIG			0x1f
- #define AT803X_BT_BX_REG_SEL			0x8000
- 
-+#define AT803X_PCS_SMART_EEE_CTRL3			0x805D
-+#define AT803X_SMART_EEE_CTRL3_LPI_TX_DELAY_SEL_MASK	0x3
-+#define AT803X_SMART_EEE_CTRL3_LPI_TX_DELAY_SEL_SHIFT	12
-+#define AT803X_SMART_EEE_CTRL3_LPI_EN			BIT(8)
-+
- #define AT803X_DEBUG_ADDR			0x1D
- #define AT803X_DEBUG_DATA			0x1E
- 
-@@ -72,6 +79,7 @@ MODULE_LICENSE("GPL");
- struct at803x_priv {
- 	bool phy_reset:1;
- 	struct gpio_desc *gpiod_reset;
-+	int prev_speed;
- };
- 
- struct at803x_context {
-@@ -276,8 +284,16 @@ does_not_require_reset_workaround:
- 	return 0;
- }
- 
-+static void at803x_disable_smarteee(struct phy_device *phydev)
-+{
-+	phy_write_mmd(phydev, MDIO_MMD_PCS, AT803X_PCS_SMART_EEE_CTRL3,
-+		1 << AT803X_SMART_EEE_CTRL3_LPI_TX_DELAY_SEL_SHIFT);
-+	phy_write_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_ADV, 0);
-+}
-+
- static int at803x_config_init(struct phy_device *phydev)
- {
-+	struct at803x_platform_data *pdata;
- 	int ret;
- 
- 	ret = genphy_config_init(phydev);
-@@ -298,6 +314,26 @@ static int at803x_config_init(struct phy
- 			return ret;
- 	}
- 
-+	pdata = dev_get_platdata(&phydev->mdio.dev);
-+	if (pdata) {
-+		if (pdata->disable_smarteee)
-+			at803x_disable_smarteee(phydev);
-+
-+		if (pdata->enable_rgmii_rx_delay)
-+			at803x_debug_reg_mask(phydev, AT803X_DEBUG_REG_0, 0,
-+				AT803X_DEBUG_RX_CLK_DLY_EN);
-+		else
-+			at803x_debug_reg_mask(phydev, AT803X_DEBUG_REG_0,
-+				AT803X_DEBUG_RX_CLK_DLY_EN, 0);
-+
-+		if (pdata->enable_rgmii_tx_delay)
-+			at803x_debug_reg_mask(phydev, AT803X_DEBUG_REG_5, 0,
-+				AT803X_DEBUG_TX_CLK_DLY_EN);
-+		else
-+			at803x_debug_reg_mask(phydev, AT803X_DEBUG_REG_5,
-+				AT803X_DEBUG_TX_CLK_DLY_EN, 0);
-+	}
-+
- 	return 0;
- }
- 
-@@ -335,6 +371,8 @@ static int at803x_config_intr(struct phy
- static void at803x_link_change_notify(struct phy_device *phydev)
- {
- 	struct at803x_priv *priv = phydev->priv;
-+	struct at803x_platform_data *pdata;
-+	pdata = dev_get_platdata(&phydev->mdio.dev);
- 
- 	/*
- 	 * Conduct a hardware reset for AT8030/2 every time a link loss is
-@@ -363,6 +401,24 @@ static void at803x_link_change_notify(st
- 	} else {
- 		priv->phy_reset = false;
- 	}
-+	if (pdata && pdata->fixup_rgmii_tx_delay &&
-+	    phydev->speed != priv->prev_speed) {
-+		switch (phydev->speed) {
-+		case SPEED_10:
-+		case SPEED_100:
-+			at803x_debug_reg_mask(phydev, AT803X_DEBUG_REG_5, 0,
-+				AT803X_DEBUG_TX_CLK_DLY_EN);
-+			break;
-+		case SPEED_1000:
-+			at803x_debug_reg_mask(phydev, AT803X_DEBUG_REG_5,
-+				AT803X_DEBUG_TX_CLK_DLY_EN, 0);
-+			break;
-+		default:
-+			break;
-+		}
-+
-+		priv->prev_speed = phydev->speed;
-+	}
- }
- 
- static int at803x_aneg_done(struct phy_device *phydev)
---- /dev/null
-+++ b/include/linux/platform_data/phy-at803x.h
-@@ -0,0 +1,11 @@
-+#ifndef _PHY_AT803X_PDATA_H
-+#define _PHY_AT803X_PDATA_H
-+
-+struct at803x_platform_data {
-+	int disable_smarteee:1;
-+	int enable_rgmii_tx_delay:1;
-+	int enable_rgmii_rx_delay:1;
-+	int fixup_rgmii_tx_delay:1;
-+};
-+
-+#endif /* _PHY_AT803X_PDATA_H */
--- a/target/linux/generic/pending-4.9/735-net-phy-at803x-fix-at8033-sgmii-mode.patch	2022-03-22 08:54:47.445465066 +0800
+++ b/target/linux/generic/pending-4.9/735-net-phy-at803x-fix-at8033-sgmii-mode.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,51 +0,0 @@
-From: Roman Yeryomin <roman@advem.lv>
-Subject: kernel: add at803x fix for sgmii mode
-
-Some (possibly broken) bootloaders incorreclty initialize at8033
-phy. This patch enables sgmii autonegotiation mode.
-
-[john@phrozen.org: felix added this to his upstream queue]
-
-Signed-off-by: Roman Yeryomin <roman@advem.lv>
----
- drivers/net/phy/at803x.c | 25 +++++++++++++++++++++++++
- 1 file changed, 25 insertions(+)
-
---- a/drivers/net/phy/at803x.c
-+++ b/drivers/net/phy/at803x.c
-@@ -46,6 +46,7 @@
- #define AT803X_FUNC_DATA			0x4003
- #define AT803X_REG_CHIP_CONFIG			0x1f
- #define AT803X_BT_BX_REG_SEL			0x8000
-+#define AT803X_SGMII_ANEG_EN			0x1000
- 
- #define AT803X_PCS_SMART_EEE_CTRL3			0x805D
- #define AT803X_SMART_EEE_CTRL3_LPI_TX_DELAY_SEL_MASK	0x3
-@@ -295,6 +296,27 @@ static int at803x_config_init(struct phy
- {
- 	struct at803x_platform_data *pdata;
- 	int ret;
-+	u32 v;
-+
-+	if (phydev->drv->phy_id == ATH8031_PHY_ID &&
-+		phydev->interface == PHY_INTERFACE_MODE_SGMII)
-+	{
-+		v = phy_read(phydev, AT803X_REG_CHIP_CONFIG);
-+		/* select SGMII/fiber page */
-+		ret = phy_write(phydev, AT803X_REG_CHIP_CONFIG,
-+						v & ~AT803X_BT_BX_REG_SEL);
-+		if (ret)
-+			return ret;
-+		/* enable SGMII autonegotiation */
-+		ret = phy_write(phydev, MII_BMCR, AT803X_SGMII_ANEG_EN);
-+		if (ret)
-+			return ret;
-+		/* select copper page */
-+		ret = phy_write(phydev, AT803X_REG_CHIP_CONFIG,
-+						v | AT803X_BT_BX_REG_SEL);
-+		if (ret)
-+			return ret;
-+	}
- 
- 	ret = genphy_config_init(phydev);
- 	if (ret < 0)
--- a/target/linux/generic/pending-4.9/810-pci_disable_common_quirks.patch	2022-03-22 08:54:47.445465066 +0800
+++ b/target/linux/generic/pending-4.9/810-pci_disable_common_quirks.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,60 +0,0 @@
-From: Gabor Juhos <juhosg@openwrt.org>
-Subject: debloat: add kernel config option to disabling common PCI quirks
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/pci/Kconfig  | 6 ++++++
- drivers/pci/quirks.c | 6 ++++++
- 2 files changed, 12 insertions(+)
-
---- a/drivers/pci/Kconfig
-+++ b/drivers/pci/Kconfig
-@@ -71,6 +71,12 @@ config XEN_PCIDEV_FRONTEND
-           The PCI device frontend driver allows the kernel to import arbitrary
-           PCI devices from a PCI backend to support PCI driver domains.
- 
-+config PCI_DISABLE_COMMON_QUIRKS
-+	bool "PCI disable common quirks"
-+	depends on PCI
-+	help
-+	  If you don't know what to do here, say N.
-+
- config HT_IRQ
- 	bool "Interrupts on hypertransport devices"
- 	default y
---- a/drivers/pci/quirks.c
-+++ b/drivers/pci/quirks.c
-@@ -41,6 +41,7 @@ static void quirk_mmio_always_on(struct
- DECLARE_PCI_FIXUP_CLASS_EARLY(PCI_ANY_ID, PCI_ANY_ID,
- 				PCI_CLASS_BRIDGE_HOST, 8, quirk_mmio_always_on);
- 
-+#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
- /* The Mellanox Tavor device gives false positive parity errors
-  * Mark this device with a broken_parity_status, to allow
-  * PCI scanning code to "skip" this now blacklisted device.
-@@ -3055,6 +3056,7 @@ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_I
- DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x65f9, quirk_intel_mc_errata);
- DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x65fa, quirk_intel_mc_errata);
- 
-+#endif /* !CONFIG_PCI_DISABLE_COMMON_QUIRKS */
- 
- /*
-  * Ivytown NTB BAR sizes are misreported by the hardware due to an erratum.  To
-@@ -3111,6 +3113,8 @@ static void fixup_debug_report(struct pc
- 	}
- }
- 
-+#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
-+
- /*
-  * Some BIOS implementations leave the Intel GPU interrupts enabled,
-  * even though no one is handling them (f.e. i915 driver is never loaded).
-@@ -3149,6 +3153,8 @@ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_IN
- DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x010a, disable_igfx_irq);
- DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x0152, disable_igfx_irq);
- 
-+#endif /* !CONFIG_PCI_DISABLE_COMMON_QUIRKS */
-+
- /*
-  * PCI devices which are on Intel chips can skip the 10ms delay
-  * before entering D3 mode.
--- a/target/linux/generic/pending-4.9/811-pci_disable_usb_common_quirks.patch	2022-03-22 08:54:47.445465066 +0800
+++ b/target/linux/generic/pending-4.9/811-pci_disable_usb_common_quirks.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,110 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: debloat: disable common USB quirks
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- drivers/usb/host/pci-quirks.c | 16 ++++++++++++++++
- drivers/usb/host/pci-quirks.h | 18 +++++++++++++++++-
- include/linux/usb/hcd.h       |  7 +++++++
- 3 files changed, 40 insertions(+), 1 deletion(-)
-
---- a/drivers/usb/host/pci-quirks.c
-+++ b/drivers/usb/host/pci-quirks.c
-@@ -107,6 +107,8 @@ struct amd_chipset_type {
- 	u8 rev;
- };
- 
-+#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
-+
- static struct amd_chipset_info {
- 	struct pci_dev	*nb_dev;
- 	struct pci_dev	*smbus_dev;
-@@ -518,6 +520,10 @@ void usb_amd_dev_put(void)
- }
- EXPORT_SYMBOL_GPL(usb_amd_dev_put);
- 
-+#endif /* CONFIG_PCI_DISABLE_COMMON_QUIRKS */
-+
-+#if IS_ENABLED(CONFIG_USB_UHCI_HCD)
-+
- /*
-  * Make sure the controller is completely inactive, unable to
-  * generate interrupts or do DMA.
-@@ -597,8 +603,17 @@ reset_needed:
- 	uhci_reset_hc(pdev, base);
- 	return 1;
- }
-+#else
-+int uhci_check_and_reset_hc(struct pci_dev *pdev, unsigned long base)
-+{
-+	return 0;
-+}
-+
-+#endif
- EXPORT_SYMBOL_GPL(uhci_check_and_reset_hc);
- 
-+#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
-+
- static inline int io_type_enabled(struct pci_dev *pdev, unsigned int mask)
- {
- 	u16 cmd;
-@@ -1165,3 +1180,4 @@ static void quirk_usb_early_handoff(stru
- }
- DECLARE_PCI_FIXUP_CLASS_FINAL(PCI_ANY_ID, PCI_ANY_ID,
- 			PCI_CLASS_SERIAL_USB, 8, quirk_usb_early_handoff);
-+#endif
---- a/drivers/usb/host/pci-quirks.h
-+++ b/drivers/usb/host/pci-quirks.h
-@@ -4,6 +4,9 @@
- #ifdef CONFIG_PCI
- void uhci_reset_hc(struct pci_dev *pdev, unsigned long base);
- int uhci_check_and_reset_hc(struct pci_dev *pdev, unsigned long base);
-+#endif  /* CONFIG_PCI */
-+
-+#if defined(CONFIG_PCI) && !defined(CONFIG_PCI_DISABLE_COMMON_QUIRKS)
- int usb_amd_find_chipset_info(void);
- int usb_hcd_amd_remote_wakeup_quirk(struct pci_dev *pdev);
- bool usb_amd_hang_symptom_quirk(void);
-@@ -17,12 +20,25 @@ void usb_disable_xhci_ports(struct pci_d
- void sb800_prefetch(struct device *dev, int on);
- #else
- struct pci_dev;
-+static inline int usb_amd_find_chipset_info(void)
-+{
-+	return 0;
-+}
-+static inline bool usb_amd_hang_symptom_quirk(void)
-+{
-+	return false;
-+}
-+static inline bool usb_amd_prefetch_quirk(void)
-+{
-+	return false;
-+}
- static inline void usb_amd_quirk_pll_disable(void) {}
- static inline void usb_amd_quirk_pll_enable(void) {}
- static inline void usb_asmedia_modifyflowcontrol(struct pci_dev *pdev) {}
- static inline void usb_amd_dev_put(void) {}
- static inline void usb_disable_xhci_ports(struct pci_dev *xhci_pdev) {}
- static inline void sb800_prefetch(struct device *dev, int on) {}
-+static inline void usb_enable_intel_xhci_ports(struct pci_dev *xhci_pdev) {}
- #endif  /* CONFIG_PCI */
- 
- #endif  /*  __LINUX_USB_PCI_QUIRKS_H  */
---- a/include/linux/usb/hcd.h
-+++ b/include/linux/usb/hcd.h
-@@ -461,7 +461,14 @@ extern int usb_hcd_pci_probe(struct pci_
- extern void usb_hcd_pci_remove(struct pci_dev *dev);
- extern void usb_hcd_pci_shutdown(struct pci_dev *dev);
- 
-+#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
- extern int usb_hcd_amd_remote_wakeup_quirk(struct pci_dev *dev);
-+#else
-+static inline int usb_hcd_amd_remote_wakeup_quirk(struct pci_dev *dev)
-+{
-+	return 0;
-+}
-+#endif
- 
- #ifdef CONFIG_PM
- extern const struct dev_pm_ops usb_hcd_pci_pm_ops;
--- a/target/linux/generic/pending-4.9/821-usb-Remove-annoying-warning-about-bogus-URB.patch	2022-03-22 08:54:47.446465068 +0800
+++ b/target/linux/generic/pending-4.9/821-usb-Remove-annoying-warning-about-bogus-URB.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,76 +0,0 @@
-From: Alexey Brodkin <abrodkin@synopsys.com>
-Subject: usb: Remove annoying warning about bogus URB
-
-When ath9k-htc Wi-Fi dongle is used with generic OHCI controller
-infinite stream of warnings appears in debug console like this:
--------------------------->8----------------------
-usb 1-1: new full-speed USB device number 2 using ohci-platform
-usb 1-1: ath9k_htc: Firmware ath9k_htc/htc_9271-1.4.0.fw requested
-usb 1-1: ath9k_htc: Transferred FW: ath9k_htc/htc_9271-1.4.0.fw, size:
-51008
-------------[ cut here ]------------
-WARNING: CPU: 0 PID: 19 at drivers/usb/core/urb.c:449
-usb_submit_urb+0x1b4/0x498()
-usb 1-1: BOGUS urb xfer, pipe 1 != type 3
-Modules linked in:
-CPU: 0 PID: 19 Comm: kworker/0:1 Not tainted
-4.4.0-rc4-00017-g00e2d79-dirty #3
-Workqueue: events request_firmware_work_func
-
-Stack Trace:
-  arc_unwind_core.constprop.1+0xa4/0x110
----[ end trace 649ef8c342817fc2 ]---
-------------[ cut here ]------------
-WARNING: CPU: 0 PID: 19 at drivers/usb/core/urb.c:449
-usb_submit_urb+0x1b4/0x498()
-usb 1-1: BOGUS urb xfer, pipe 1 != type 3
-Modules linked in:
-CPU: 0 PID: 19 Comm: kworker/0:1 Tainted: G        W
-4.4.0-rc4-00017-g00e2d79-dirty #3
-Workqueue: events request_firmware_work_func
-
-Stack Trace:
-  arc_unwind_core.constprop.1+0xa4/0x110
----[ end trace 649ef8c342817fc3 ]---
-------------[ cut here ]------------
--------------------------->8----------------------
-
-There're some discussions in mailing lists proposing to disable
-that particular check alltogether and magically all seem to work
-fine with muted warning.
-
-Anyways new thread on that regard could be found here:
-http://lists.infradead.org/pipermail/linux-snps-arc/2016-July/001310.html
-
-Let's see what comes out of that new discussion, hopefully patching
-of generic USB stuff won't be required then.
-
-Signed-off-by: Alexey Brodkin <abrodkin@synopsys.com>
----
- drivers/usb/core/urb.c | 5 -----
- 1 file changed, 5 deletions(-)
-
---- a/drivers/usb/core/urb.c
-+++ b/drivers/usb/core/urb.c
-@@ -321,9 +321,6 @@ EXPORT_SYMBOL_GPL(usb_unanchor_urb);
-  */
- int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
- {
--	static int			pipetypes[4] = {
--		PIPE_CONTROL, PIPE_ISOCHRONOUS, PIPE_BULK, PIPE_INTERRUPT
--	};
- 	int				xfertype, max;
- 	struct usb_device		*dev;
- 	struct usb_host_endpoint	*ep;
-@@ -441,11 +438,6 @@ int usb_submit_urb(struct urb *urb, gfp_
- 	 * cause problems in HCDs if they get it wrong.
- 	 */
- 
--	/* Check that the pipe's type matches the endpoint's type */
--	if (usb_pipetype(urb->pipe) != pipetypes[xfertype])
--		dev_WARN(&dev->dev, "BOGUS urb xfer, pipe %x != type %x\n",
--			usb_pipetype(urb->pipe), pipetypes[xfertype]);
--
- 	/* Check against a simple/standard policy */
- 	allowed = (URB_NO_TRANSFER_DMA_MAP | URB_NO_INTERRUPT | URB_DIR_MASK |
- 			URB_FREE_BUFFER);
--- a/target/linux/generic/pending-4.9/834-ledtrig-libata.patch	2022-03-22 08:54:47.446465068 +0800
+++ b/target/linux/generic/pending-4.9/834-ledtrig-libata.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,149 +0,0 @@
-From: Daniel Golle <daniel@makrotopia.org>
-Subject: libata: add ledtrig support
-
-This adds a LED trigger for each ATA port indicating disk activity.
-
-As this is needed only on specific platforms (NAS SoCs and such),
-these platforms should define ARCH_WANTS_LIBATA_LEDS if there
-are boards with LED(s) intended to indicate ATA disk activity and
-need the OS to take care of that.
-In that way, if not selected, LED trigger support not will be
-included in libata-core and both, codepaths and structures remain
-untouched.
-
-Signed-off-by: Daniel Golle <daniel@makrotopia.org>
----
- drivers/ata/Kconfig       | 16 ++++++++++++++++
- drivers/ata/libata-core.c | 41 +++++++++++++++++++++++++++++++++++++++++
- include/linux/libata.h    |  9 +++++++++
- 3 files changed, 66 insertions(+)
-
---- a/drivers/ata/Kconfig
-+++ b/drivers/ata/Kconfig
-@@ -46,6 +46,22 @@ config ATA_VERBOSE_ERROR
- 
- 	  If unsure, say Y.
- 
-+config ARCH_WANT_LIBATA_LEDS
-+	bool
-+
-+config ATA_LEDS
-+	bool "support ATA port LED triggers"
-+	depends on ARCH_WANT_LIBATA_LEDS
-+	select NEW_LEDS
-+	select LEDS_CLASS
-+	select LEDS_TRIGGERS
-+	default y
-+	help
-+	  This option adds a LED trigger for each registered ATA port.
-+	  It is used to drive disk activity leds connected via GPIO.
-+
-+	  If unsure, say N.
-+
- config ATA_ACPI
- 	bool "ATA ACPI Support"
- 	depends on ACPI
---- a/drivers/ata/libata-core.c
-+++ b/drivers/ata/libata-core.c
-@@ -731,6 +731,19 @@ u64 ata_tf_read_block(const struct ata_t
- 	return block;
- }
- 
-+#ifdef CONFIG_ATA_LEDS
-+#define LIBATA_BLINK_DELAY 20 /* ms */
-+static inline void ata_led_act(struct ata_port *ap)
-+{
-+	unsigned long led_delay = LIBATA_BLINK_DELAY;
-+
-+	if (unlikely(!ap->ledtrig))
-+		return;
-+
-+	led_trigger_blink_oneshot(ap->ledtrig, &led_delay, &led_delay, 0);
-+}
-+#endif
-+
- /**
-  *	ata_build_rw_tf - Build ATA taskfile for given read/write request
-  *	@tf: Target ATA taskfile
-@@ -4998,6 +5011,9 @@ struct ata_queued_cmd *ata_qc_new_init(s
- 		if (tag < 0)
- 			return NULL;
- 	}
-+#ifdef CONFIG_ATA_LEDS
-+	ata_led_act(ap);
-+#endif
- 
- 	qc = __ata_qc_from_tag(ap, tag);
- 	qc->tag = tag;
-@@ -5899,6 +5915,9 @@ struct ata_port *ata_port_alloc(struct a
- 	ap->stats.unhandled_irq = 1;
- 	ap->stats.idle_irq = 1;
- #endif
-+#ifdef CONFIG_ATA_LEDS
-+	ap->ledtrig = kzalloc(sizeof(struct led_trigger), GFP_KERNEL);
-+#endif
- 	ata_sff_port_init(ap);
- 
- 	return ap;
-@@ -5920,6 +5939,12 @@ static void ata_host_release(struct devi
- 
- 		kfree(ap->pmp_link);
- 		kfree(ap->slave_link);
-+#ifdef CONFIG_ATA_LEDS
-+		if (ap->ledtrig) {
-+			led_trigger_unregister(ap->ledtrig);
-+			kfree(ap->ledtrig);
-+		};
-+#endif
- 		kfree(ap);
- 		host->ports[i] = NULL;
- 	}
-@@ -6366,7 +6391,23 @@ int ata_host_register(struct ata_host *h
- 		host->ports[i]->print_id = atomic_inc_return(&ata_print_id);
- 		host->ports[i]->local_port_no = i + 1;
- 	}
-+#ifdef CONFIG_ATA_LEDS
-+	for (i = 0; i < host->n_ports; i++) {
-+		if (unlikely(!host->ports[i]->ledtrig))
-+			continue;
- 
-+		snprintf(host->ports[i]->ledtrig_name,
-+			sizeof(host->ports[i]->ledtrig_name), "ata%u",
-+			host->ports[i]->print_id);
-+
-+		host->ports[i]->ledtrig->name = host->ports[i]->ledtrig_name;
-+
-+		if (led_trigger_register(host->ports[i]->ledtrig)) {
-+			kfree(host->ports[i]->ledtrig);
-+			host->ports[i]->ledtrig = NULL;
-+		}
-+	}
-+#endif
- 	/* Create associated sysfs transport objects  */
- 	for (i = 0; i < host->n_ports; i++) {
- 		rc = ata_tport_add(host->dev,host->ports[i]);
---- a/include/linux/libata.h
-+++ b/include/linux/libata.h
-@@ -38,6 +38,9 @@
- #include <linux/acpi.h>
- #include <linux/cdrom.h>
- #include <linux/sched.h>
-+#ifdef CONFIG_ATA_LEDS
-+#include <linux/leds.h>
-+#endif
- 
- /*
-  * Define if arch has non-standard setup.  This is a _PCI_ standard
-@@ -884,6 +887,12 @@ struct ata_port {
- #ifdef CONFIG_ATA_ACPI
- 	struct ata_acpi_gtm	__acpi_init_gtm; /* use ata_acpi_init_gtm() */
- #endif
-+
-+#ifdef CONFIG_ATA_LEDS
-+	struct led_trigger	*ledtrig;
-+	char			ledtrig_name[8];
-+#endif
-+
- 	/* owned by EH */
- 	u8			sector_buf[ATA_SECT_SIZE] ____cacheline_aligned;
- };
--- a/target/linux/generic/pending-4.9/890-uart_optional_sysrq.patch	2022-03-22 08:54:47.446465068 +0800
+++ b/target/linux/generic/pending-4.9/890-uart_optional_sysrq.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,40 +0,0 @@
-From: John Crispin <john@phrozen.org>
-Subject: serial: do not accept sysrq characters via serial port
-
-many embedded boards have a disconnected TTL level serial which can
-generate some garbage that can lead to spurious false sysrq detects.
-
-[john@phrozen.org: sent upstream 22.12.2016]
-
-Signed-off-by: John Crispin <john@phrozen.org>
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/linux/serial_core.h | 2 +-
- lib/Kconfig.debug           | 5 +++++
- 2 files changed, 6 insertions(+), 1 deletion(-)
-
---- a/include/linux/serial_core.h
-+++ b/include/linux/serial_core.h
-@@ -456,7 +456,7 @@ extern void uart_handle_cts_change(struc
- extern void uart_insert_char(struct uart_port *port, unsigned int status,
- 		 unsigned int overrun, unsigned int ch, unsigned int flag);
- 
--#ifdef SUPPORT_SYSRQ
-+#if defined(SUPPORT_SYSRQ) && defined(CONFIG_MAGIC_SYSRQ_SERIAL)
- static inline int
- uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
- {
---- a/lib/Kconfig.debug
-+++ b/lib/Kconfig.debug
-@@ -410,6 +410,11 @@ config MAGIC_SYSRQ_DEFAULT_ENABLE
- 	  This may be set to 1 or 0 to enable or disable them all, or
- 	  to a bitmask as described in Documentation/sysrq.txt.
- 
-+config MAGIC_SYSRQ_SERIAL
-+	bool "Enable magic SysRq key over serial"
-+	depends on MAGIC_SYSRQ
-+	default y
-+
- config DEBUG_KERNEL
- 	bool "Kernel debugging"
- 	help
--- a/target/linux/generic/pending-4.9/920-mangle_bootargs.patch	2022-03-22 08:54:47.447465069 +0800
+++ b/target/linux/generic/pending-4.9/920-mangle_bootargs.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,71 +0,0 @@
-From: Imre Kaloz <kaloz@openwrt.org>
-Subject: init: add CONFIG_MANGLE_BOOTARGS and disable it by default
-
-Enabling this option renames the bootloader supplied root=
-and rootfstype= variables, which might have to be know but
-would break the automatisms OpenWrt uses.
-
-Signed-off-by: Imre Kaloz <kaloz@openwrt.org>
----
- init/Kconfig |  9 +++++++++
- init/main.c  | 24 ++++++++++++++++++++++++
- 2 files changed, 33 insertions(+)
-
---- a/init/Kconfig
-+++ b/init/Kconfig
-@@ -1694,6 +1694,15 @@ config EMBEDDED
- 	  an embedded system so certain expert options are available
- 	  for configuration.
- 
-+config MANGLE_BOOTARGS
-+	bool "Rename offending bootargs"
-+	depends on EXPERT
-+	help
-+	  Sometimes the bootloader passed bogus root= and rootfstype=
-+	  parameters to the kernel, and while you want to ignore them,
-+	  you need to know the values f.e. to support dual firmware
-+	  layouts on the flash.
-+
- config HAVE_PERF_EVENTS
- 	bool
- 	help
---- a/init/main.c
-+++ b/init/main.c
-@@ -353,6 +353,29 @@ static inline void setup_nr_cpu_ids(void
- static inline void smp_prepare_cpus(unsigned int maxcpus) { }
- #endif
- 
-+#ifdef CONFIG_MANGLE_BOOTARGS
-+static void __init mangle_bootargs(char *command_line)
-+{
-+	char *rootdev;
-+	char *rootfs;
-+
-+	rootdev = strstr(command_line, "root=/dev/mtdblock");
-+
-+	if (rootdev)
-+		strncpy(rootdev, "mangled_rootblock=", 18);
-+
-+	rootfs = strstr(command_line, "rootfstype");
-+
-+	if (rootfs)
-+		strncpy(rootfs, "mangled_fs", 10);
-+
-+}
-+#else
-+static void __init mangle_bootargs(char *command_line)
-+{
-+}
-+#endif
-+
- /*
-  * We need to store the untouched command line for future reference.
-  * We also need to store the touched command line since the parameter
-@@ -506,6 +529,7 @@ asmlinkage __visible void __init start_k
- 	pr_notice("%s", linux_banner);
- 	setup_arch(&command_line);
- 	mm_init_cpumask(&init_mm);
-+	mangle_bootargs(command_line);
- 	setup_command_line(command_line);
- 	setup_nr_cpu_ids();
- 	setup_per_cpu_areas();
